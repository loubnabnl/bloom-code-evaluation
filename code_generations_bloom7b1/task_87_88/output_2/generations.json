[["def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Init\n    res = []\n    for row in lst:\n        res.append([])\n    # Main Loop\n    for i in range(len(lst)):\n        res[i].append(i)\n        for j in range(i + 1, len(lst)):\n            if lst[i][j]!= lst[i][j - 1]:\n                res[i].append(j)\n    # Sort by rows\n    res.sort(key=lambda x: x[0])\n    # Sort by columns\n    res.sort(key=lambda x: x[1])\n    return res", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if len(lst) == 1:\n        return [(0, 0)]\n    if x == 0:\n        return lst\n    if x == len(lst):\n        return [(x, len(lst))]\n    if x < len(lst):\n        return get_row(lst[x:], x-1)\n    else:\n        return get_row(lst[:x], x-1)\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = [x for x in range(len(lst)) if x > 0]\n    columns = [x for x in range(len(lst[0])) if x > 0]\n    rows.sort()\n    columns.sort()\n    rows = [[x,y] for y in range(len(lst)[0]) for x in range(len(lst))]\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = [lst[x] for x in range(len(lst))]\n    rows.sort(key=lambda x: x[0])\n    rows = [(x[0], x[1:]) for x in rows]\n    rows.sort(key=lambda x: x[1])\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Sort the columns in descending order.\n    lst_sorted_by_column = sorted(lst, key=lambda x: x[0], reverse=True)\n    # Sort the rows in ascending order.\n    lst_sorted_by_row = sorted(lst_sorted_by_column, key=lambda x: x[1], reverse=True)\n    # Get the coordinates of the row.\n    row_coords = []\n    for i in range(len(lst_sorted_by_row)):\n        row_coords.append((lst_sorted_by_row[i][0], i))\n    # Get the coordinates of the column.\n    col_coords = []\n    for i in range(len(lst_sorted_by_column)):\n        col_coords.append((i, lst_sorted_by_column[i][1]))\n    # Sort the coordinates of the row by columns.\n    row_coords = sorted(row_coords, key=lambda x: x[1], reverse=True)\n    # Sort the coordinates of the column by rows.\n    col_coords = sorted(col_coords, key=lambda x: x[0], reverse=True)\n    # Get the coordinates of the row.\n    row_coords = sorted(row_coords, key=lambda x: x[1], reverse=True)\n    # Get the coordinates of the column.\n    col_coords = sorted(col_coords", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if len(lst) < x:\n        return get_row(lst, x - 1)\n    if x == 0:\n        return []\n    if x > len(lst):\n        return get_row(lst, x - 1)\n    if x < 0:\n        return get_row(lst, x + 1)\n    if x > len(lst):\n        return get_row(lst, x - 1)\n    if x < 0:\n        return get_row(lst, x + 1)\n    if x > len(lst):\n        return get_row(lst, x - 1)\n    if x < 0:\n        return get_row(lst, x + 1)\n    if x == 0:\n        return []\n    return sorted([(x, get_row(lst, x - 1)) for x in range(0, x)])", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = []\n    cols_ = []\n    for r in range(len(lst)):\n        if lst[r][x]!= None:\n            rows.append(r)\n            cols_.append(x)\n    if len(rows) == 0:\n        return []\n    for c in range(len(cols_)):\n        if cols_[c]!= 0:\n            rows.sort(key=lambda x: x[1])\n            rows.sort(key=lambda x: x[0])\n            rows.sort(key=lambda x: x[cols_[c]])\n            rows.sort(key=lambda x: x[cols_[c]])\n            for r in range(len(rows)):\n                for c in range(len(cols_)):\n                    if cols_[c]!= 0:\n                        if cols_[c] == x[cols_[c]]:\n                            if x[cols_[c]] < x[r][cols_[c]]:\n                                rows.pop()\n                                cols_.pop()\n                            else:\n                                rows.append(r)\n                                cols_.append(x[cols_[c]])\n        else:\n            return []\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x > len(lst):\n        return []\n    row = 0\n    col = 0\n    i = 0\n    while i < x:\n        if row == len(lst):\n            return []\n        if lst[row][col] == x:\n            if col > i:\n                return [(row, col - i)]\n            else:\n                return [(row, col)]\n        col += 1\n        if col >= len(lst[row]):\n            col = 0\n            row += 1\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    if x == 1:\n        return get_row(lst, x - 1)\n    if x == len(lst):\n        return [(x, 0)]\n    if x > len(lst):\n        return []\n    y = 0\n    x = 0\n    return get_row(lst, x - 1) + [(y, x)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    if x == len(lst):\n        return [(x, len(lst))]\n    if x > len(lst):\n        return []\n    lst = sorted(lst, key=lambda x: x[0])\n    if x > 1:\n        lst = sorted(lst, key=lambda x: x[1], reverse=True)\n    return [(x, y) for x, y in zip(lst[:x], lst[x+1:])]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row, col = 0, 0\n    rows = []\n    while row < len(lst):\n        if row < x:\n            row += 1\n        else:\n            col += 1\n            if col < x:\n                return rows\n            else:\n                if len(rows) > 0:\n                    rows.append((row, col))\n                row, col = 0, 0\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # first sort by rows\n    lst = sorted(lst, key=lambda x: (x[0], x[1]))\n    # then sort by columns\n    lst = sorted(lst, key=lambda x: x[1], reverse=True)\n    # now iterate through the rows\n    for i in range(len(lst)):\n        # iterate through the columns\n        for j in range(len(lst[i])):\n            # if the coordinates are the same, then return the row\n            if lst[i][j] == x:\n                return [(i, j)]\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if x == 0:\n        return []\n    x = x - 1\n    if x == 0:\n        return [(0, 0)]\n    if x == len(lst) - 1:\n        return [(x, len(lst) - x)]\n    return [(x, lst[x][0]) for x in range(0, len(lst[x]))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if len(lst) == 1:\n        return lst\n    x = 0\n    row = 0\n    col = 0\n    result = []\n    while x < len(lst):\n        if len(lst[x]) == 1:\n            result.append((row, col))\n            row += 1\n            col += 1\n            x += 1\n        elif x < len(lst)-1:\n            result.append((row, col))\n            col += 1\n            x += 1\n        else:\n            result.append((row, col))\n            row += 1\n            col += 1\n            x += 1\n    return result", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x < 0 or x > len(lst):\n        return []\n    x = x % len(lst)\n    # sort coordinates by rows in ascending order\n    lst = sorted(lst, key=lambda x: x[0])\n    # sort coordinates of the row by columns in descending order\n    lst = sorted(lst, key=lambda x: x[1], reverse=True)\n    return [(x, get_row(lst, x+1)) for x in range(len(lst))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = x\n    cols = 0\n    row_idx = 0\n    while row_idx < len(lst):\n        col = 0\n        while col < len(lst[row_idx]):\n            if col in range(x, len(lst[row_idx])):\n                return [(row_idx, cols), (row_idx, col + 1)]\n            col += 1\n        row_idx += 1\n        cols += 1\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    rows = [lst[0]]\n    for i in range(len(lst) - 1):\n        rows.append(lst[i])\n    rows.append(lst[-1])\n    if len(rows) == 1:\n        return [(0, 0)]\n    sorted = sorted(rows, key=lambda x: x[0])\n    sorted.sort(key=lambda x: x[1])\n    return sorted", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if len(lst) == 1:\n        return lst[0]\n    if len(lst) == 2:\n        if lst[0] == lst[1]:\n            return get_row(lst[1:], x)\n        return get_row(get_row(lst[1:], x), x)\n    if x < 0:\n        return get_row(lst[:-x], x)\n    return get_row(get_row(lst[:-x-1], x-1), x-1)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Sort coordinates initially by rows in ascending order\n    lst.sort(key=lambda x: x[0])\n    # Sort coordinates of the row by columns in descending order\n    for i in range(0, len(lst)):\n        for j in range(0, len(lst[i])):\n            if lst[i][j] > lst[i][j + 1]:\n                tmp = lst[i][j]\n                lst[i][j] = lst[i][j + 1]\n                lst[i][j + 1] = tmp\n    return lst[x]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Get the row we are interested in.\n    row = lst[x][0]\n    # If row is empty, return [].\n    if not row:\n        return []\n    # Get the column we are interested in.\n    column = row[-1]\n    # If column is empty, return [].\n    if not column:\n        return []\n    # Get the coordinates of the row.\n    row_coords = [lst[x][col] for col in range(len(row))]\n    # Sort the row coordinates by columns in descending order.\n    row_coords.sort(key=lambda x: x[-1], reverse=True)\n    # Get the coordinates of the column.\n    col_coords = [lst[x][1] for x in row_coords]\n    # Sort the column coordinates by rows in ascending order.\n    col_coords.sort(key=lambda x: x[0], reverse=True)\n    # Return the coordinates.\n    return [(row, col) for row, col in zip(row_coords, col_coords)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # check for empty list\n    if not lst:\n        return []\n    # check for duplicate row\n    if not [x for x in lst if x[0] == x[1]]:\n        return []\n    # check for empty row\n    if not [x for x in lst if len(x) == 0] and not [x for x in lst if x[0] == x[1]]:\n        return []\n    # check for empty column\n    if not [x for x in lst if len(x) == 0] and not [x for x in lst if x[1] == x[2]]:\n        return []\n    # check for duplicate column\n    if not [x for x in lst if x[0] == x[1]] and not [x for x in lst if x[1] == x[2]]:\n        return []\n    # check for duplicate row and column\n    if not [x for x in lst if x[0] == x[1]] and not [x for x in lst if x[1] == x[2]] and not [x for x in lst if x[0] == x[1]] and not [x for x in lst if x[1] == x[2]]:\n        return []\n    # check for empty row and column\n    if not [x for x in lst if len(x) == 0] and not [x for x in lst if", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row, col = 0, 0\n    while row < len(lst):\n        while col < len(lst[row]):\n            if lst[row][col] == x:\n                return [(row, col)]\n            col += 1\n        row += 1\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return lst\n    else:\n        x = int(x)\n        if x < len(lst):\n            if x == 1:\n                return [(i, j) for i in range(x) for j in range(len(lst))]\n            else:\n                return [(i, j) for i in range(x) for j in range(x)]\n        else:\n            return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    if x == len(lst) - 1:\n        return [(x, 0)]\n    # if x < 0 or x > len(lst) - 1:\n    #   return []\n    if x == 0:\n        return get_row(lst[1:], x - 1)\n    # find the index of the row with the desired number of columns\n    # and return a list of tuples, [(x1, y1), (x2, y2)...] such that\n    # each tuple is a coordinate - (row, columns), starting with 0\n    # and sort them in ascending order\n    r = []\n    for i in range(0, len(lst) - 1):\n        if x < len(lst[i]):\n            r.append((i, x))\n        x -= len(lst[i])\n    r.sort(key=lambda x: x[0])\n    return r", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    result = []\n    for row in lst:\n        if row == []:\n            continue\n        if x == 1:\n            result.append((row[0], row[1]))\n        else:\n            result.extend(get_row(row, x-1))\n    result.sort(key=lambda x: (x[0], x[1]))\n    return result", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = []\n    for i in range(x):\n        if lst[i][0] is None:\n            row.append((0, i))\n        else:\n            row.append((i, i))\n    return sorted(row, key=itemgetter(0), reverse=True)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # sort rows in ascending order\n    rows = sorted(lst, key=lambda x: x[0], reverse=True)\n    # sort columns in descending order\n    cols = sorted(list(map(lambda x: x[1], rows)), key=lambda x: x[1], reverse=True)\n    # get the index of the coordinates\n    return [(i, j) for i, j in zip(range(len(rows)), cols)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if x == 0:\n        return get_row(lst, x - 1)\n    row = get_row(lst, x - 1)\n    cols = x - 1\n    return [(row[0][0], row[1][0])] + get_row(lst, x) + [(cols, row[1][0])]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x = x % len(lst)\n    if x == 0:\n        return []\n    return [(x, y) for y in xrange(0, len(lst) - x) for x in get_row(lst[y : y + x], x)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if x < 0:\n        x += len(lst)\n    if x >= len(lst):\n        return []\n    rows = list(range(x))\n    for row in rows:\n        rows.sort(key=lambda x: x[1], reverse=True)\n    rows.sort(key=lambda x: x[0], reverse=True)\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    l = lst\n    r = []\n    for i in range(0, len(l)):\n        if l[i]:\n            r.append((l[i][0], i))\n    r.sort(key=lambda x: x[0])\n    return r", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if x < 0:\n        return get_row(lst, -x)\n    x = x % len(lst)\n    if x == 0:\n        return get_row(lst, -x)\n    if x > 0:\n        return get_row(lst, x)\n    x = x / len(lst)\n    return get_row(lst, x)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = []\n    for i in range(0, len(lst)):\n        row.append([])\n        for j in range(0, len(lst[i])):\n            row[i].append(lst[i][j])\n    row.sort(key=lambda x: (x[0], x[1]))\n    return row[x: x + 1]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Find the number of columns in the first row\n    # Note that the second row has only one column\n    # so the number of columns in the second row will be 1\n    # (the number of columns in the first row + 1)\n    cols = len(lst[0])\n    # Find the number of columns in the second row\n    # Note that the first row has only one column\n    # so the number of columns in the first row will be 1\n    # (the number of columns in the second row - 1)\n    rows = len(lst)\n    # If the number of rows is 1, then the list is empty\n    # so return an empty list\n    if rows == 1:\n        return []\n    # The number of columns in the first row will be less than the\n    # number of columns in the second row, so we can just start\n    # at the second row\n    return map(lambda (row, col): (row, col), range(rows))", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Initialize a list for the coordinate\n    coord_list = []\n    # Initialize a list for the row coordinate\n    row_coords = []\n    # Initialize a list for the column coordinate\n    col_coords = []\n    # Initialize a list to store the row index\n    row_idx = []\n    # Initialize a list to store the column index\n    col_idx = []\n    # Initialize a list to store the row count\n    row_count = []\n    # Initialize a list to store the column count\n    col_count = []\n    # Initialize a list to store the row index\n    row_idx = []\n    # Initialize a list to store the column index\n    col_idx = []\n    # Initialize a list to store the row count\n    row_count = []\n    # Initialize a list to store the column count\n    col_count = []\n    # Initialize a list to store the row index\n    row_idx = []\n    # Initialize a list to store the column index\n    col_idx = []\n    # Initialize a list to store the row count\n    row_count = []\n    # Initialize a list to store the column count\n    col_count = []\n    # Initialize a list to store the row index\n    row_idx = []\n    # Initialize a list to store the column index\n    col_idx = []\n    # Initialize", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x < 0:\n        raise ValueError('x must be greater than or equal to 0')\n    if x == 0:\n        return []\n    if x in lst:\n        return lst[x]\n    if x == len(lst):\n        return []\n    if x == 0:\n        return []\n    if x == 1:\n        return [(0, 0)]\n    if x == 2:\n        return [(0, 0), (1, 0)]\n    if x == 3:\n        return [(0, 0), (1, 0), (2, 0)]\n    if x == 4:\n        return [(0, 0), (1, 0), (2, 0), (3, 0)]\n    if x == 5:\n        return [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0)]\n    if x == 6:\n        return [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0)]\n    if x == 7:\n        return [(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0), (6, 0)]\n    if x == 8:\n        return [(0, 0), (1, 0), (", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = []\n    for row in lst:\n        if len(row) == 0:\n            continue\n        else:\n            rows.append(row)\n    rows = sorted(rows, key=lambda x: x[0])\n    return [(i, j) for i, j in enumerate(rows) if i == x]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows, cols = lst\n    i = 0\n    while i < len(rows):\n        row = rows[i]\n        for j in range(0, len(row)):\n            if row[j] == x:\n                return [(i, j)]\n            i += 1\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return [(x, x) for x in xrange(len(lst))] + [(x, x) for x in xrange(x)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # sort rows\n    rows = sorted(lst, key=lambda x: x[0])\n    # sort columns\n    cols = sorted(lst[row], key=lambda x: x[1])\n    # sort coordinates\n    return [(x[0], x[1]) for x in zip(rows, cols)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if len(lst) == 1:\n        return [(0, 0)]\n    else:\n        return sorted(get_row(lst[1:], x), key=lambda tup: tup[0] + tup[1])", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = lst.index(x)\n    if row == -1:\n        return []\n    row = row % len(lst)\n    col = (row / len(lst)) - 1\n    return [(x, lst[row][col]) for x in range(len(lst[row]))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = []\n    col = []\n    for i in xrange(len(lst)):\n        row.append(lst[i][0])\n        col.append(lst[i][1])\n    row.sort()\n    row.reverse()\n    col.sort()\n    col.reverse()\n    return row, col", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if x < 0:\n        return get_row(lst[-x:], -x)\n    lst = sorted(lst, key=lambda x: x[0])\n    return [(x, get_row(lst[1:], x)) for x in range(x, len(lst))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    x = x % len(lst)\n    if x == 0:\n        return lst\n    if x < 0 or x >= len(lst):\n        return []\n    if x == 1:\n        return [(0, 0)] + get_row(lst[1:], x - 1) + [(0, 0)]\n    if x == len(lst):\n        return get_row(lst[:-1], x - 1) + [(0, 0)]\n    if x < len(lst) - 1:\n        return get_row(lst[:x], x - 1) + get_row(lst[x + 1:], x - 1)\n    return get_row(lst[:x], x - 1) + get_row(lst[x + 1:], x - 1)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # return []\n    if len(lst) < 1:\n        return []\n    if x == 0:\n        return [(0, 0)]\n    if x == len(lst):\n        return [(x, len(lst))]\n    if x < 0:\n        return []\n    if x >= len(lst):\n        return []\n    if x < len(lst):\n        row = lst[x]\n        columns = x - 1\n        # sort rows by ascending order\n        rows = sorted([row])\n        # sort columns by descending order\n        columns = sorted([columns], reverse=True)\n        # return all coordinates\n        return [(row[x], columns)]\n    else:\n        return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = sorted(lst, key=lambda x: x[0])\n    return [(x[0] + 1, get_row(lst[x[1]], x[2])) for x in sorted(enumerate(lst), key=lambda x: x[1])]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return lst\n    if x == len(lst):\n        return [(x, 0)]\n    if x > len(lst):\n        return get_row(lst[:x], x)\n    if x < 0:\n        return get_row(lst[:-x], x)\n    if x == 0 and x == len(lst):\n        return [(x, 0)]\n    return get_row(lst[:x], x) + get_row(lst[x+1:], x)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    if x == len(lst):\n        return [(x, 0)]\n    row = 0\n    columns = 0\n    for i in range(x):\n        if i == 0:\n            row = i\n        else:\n            column = i - 1\n            if column > len(lst[row]):\n                column = len(lst[row]) - 1\n            if column < 0:\n                column = 0\n        if columns < len(lst[row]):\n            if column == 0:\n                return get_row(lst[row], x - 1) + get_row(lst[row + 1], x - 1)\n        else:\n            return get_row(lst[row], x - 1)\n    return [(x, 0)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    \n    # Convert to row list\n    row = []\n    for i in range(len(lst)):\n        row.append(lst[i])\n    \n    # Sort row list\n    row.sort(key=lambda x: x[0])\n    \n    # Sort row list of the row\n    row = sorted(row, key=lambda x: x[1])\n    \n    # Return the row coordinates\n    return row[:x] + [(x + 1, y) for y in row[x+1:]]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if len(lst) == 1:\n        return [(0, 0)]\n    if len(lst[0]) == 1:\n        return get_row(lst[1:], x - 1)\n    if x < 0:\n        return []\n    if x > len(lst):\n        return []\n    return get_row(lst[1:], x - 1) + get_row(lst[:x], x - 1)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if x == 0:\n        return [(x, x)]\n    if x == len(lst[0]):\n        return [(x, x)]\n    lst = sorted(lst, key=lambda x: x[0])\n    return [(get_row(lst, x-1), get_row(lst, x))] + \\\n        [(get_row(lst, x), get_row(lst, x+1))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = sorted(lst, key=lambda x: x[0])\n    row = x\n    cols = 0\n    row = 0\n    while row < len(lst):\n        if len(lst[row]) == cols:\n            cols += 1\n            yield (row, cols)\n            row += 1\n        else:\n            cols = 0\n            row += 1\n    yield (row, cols)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def get_tuple(i, j):\n        \"\"\"\n        Return (i, j) coordinate of the row.\n        \"\"\"\n        return (i, j)\n\n    def get_column(i, j):\n        \"\"\"\n        Return j coordinate of the column.\n        \"\"\"\n        return j\n\n    def get_row(i):\n        \"\"\"\n        Return i coordinate of the row.\n        \"\"\"\n        return i\n\n    def get_col(i):\n        \"\"\"\n        Return i coordinate of the column.\n        \"\"\"\n        return i\n\n    lst = sorted(lst, key=lambda x: x[0])\n    col = 0\n    row = 0\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if i == x and j == x:\n                return [(row, col)]\n            if i == x and j!= x:\n                return []\n            if j == x and i!= x:\n                return []\n            if col == x and i!= x:\n                return []\n            if col!= x and j!= x:\n                return []\n            if col!= x and i!= x:\n                return []\n            col += 1\n            row += 1\n        col += 1\n        row += 1\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if not isinstance(lst, list):\n        return get_row([[], [], []], x)\n    if len(lst) == 1:\n        return [(0, 0)]\n    if x < 0:\n        return get_row(lst, x + len(lst))\n    if x > len(lst):\n        return get_row(lst, x - len(lst))\n    if x == 0:\n        return get_row(lst, 0)\n    if x == len(lst):\n        return get_row(lst, len(lst))\n    return [(x - 1, y) for y in get_row(lst[:x], x - 1) for x in range(0, len(lst) - x)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Find coordinates\n    def get_tuple(row, columns):\n        return tuple([lst[row][column] for column in range(columns)])\n    # Sort by rows\n    for i, row in enumerate(lst):\n        for j, coord in enumerate(get_tuple(row, lst[row].count(None))):\n            if i == j:\n                continue\n            if coord < get_tuple(row, lst[row].count(None))[i]:\n                return [(i, j)]\n    # Sort by columns\n    for i, row in enumerate(lst):\n        for j, coord in enumerate(get_tuple(row, lst[row].count(None))):\n            if i == j:\n                continue\n            if coord < get_tuple(row, lst[row].count(None))[j]:\n                return [(i, j)]\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = 0\n    column = 0\n    return [(row, column) for row in range(len(lst)) for column in range(len(lst[row])) if lst[row][column] == x]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if x == 0:\n        return lst\n    if x == len(lst):\n        return [(0, 0)]\n    if x == len(lst[0]):\n        return []\n    if x == len(lst[0][0]):\n        return []\n    return [get_row(lst, x-1) + [(x, 0)]]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if x == 1:\n        return [(0, 0)]\n    if x == len(lst):\n        return [(x, x)]\n    x = int(x)\n    if x < 0:\n        return [(x + len(lst), x)]\n    if x == 0:\n        return [(0, x)]\n    if x == len(lst):\n        return [(x, x)]\n    x = x % len(lst)\n    if x == 0:\n        return [(x, x)]\n    return [(x, get_row(lst, x - 1))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    if x not in lst:\n        raise ValueError(\"Invalid coordinate: \" + str(x))\n    lst = lst[x]\n    if len(lst) == 1:\n        return [(0, 0)]\n    else:\n        lst = sorted(lst, key=lambda x: x[0])\n        return get_row(lst, x - 1)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def sort_by_col(a):\n        if a[0] == 0:\n            return a\n        else:\n            return [a, sort_by_col(a[1:])]\n    def sort_by_row(a):\n        if a[0] == 0:\n            return a\n        else:\n            return [a, sort_by_row(a[1:])]\n    def sort_by_col_row(a):\n        if a[0] == 0:\n            return a\n        else:\n            return [a, sort_by_col_row(a[1:])]\n    # Find a, b, c such that a[0] == b[0] == c[0] == 0\n    # and a[1] == b[1] == c[1] == x\n    # Sort coordinates by ascending order, starting with 0\n    # and then descending order of columns\n    a = sort_by_col(lst)\n    b = sort_by_row(a)\n    c = sort_by_col_row(b)\n    # Sort coordinates by ascending order of rows\n    # and then descending order of columns\n    d = sort_by_col(b)\n    e = sort_by_row(d)\n    f = sort_by_col_row(e)\n    # Return a, b, c, d, e, f\n    return [a, b, c, d, e, f]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    row = 0\n    col = 0\n    row_list = []\n    col_list = []\n    for i in range(len(lst)):\n        row_list.append(row)\n        col_list.append(col)\n        row += 1\n        if row == x:\n            break\n        col += 1\n    return row_list, col_list", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # if lst is empty, return an empty list\n    if not lst:\n        return []\n    # find the row index of x\n    row = lst.index(x)\n    # if row is None, then there is no such element\n    if row is None:\n        return []\n    # find the column index of x\n    col = 0\n    while col < len(lst[row]):\n        col += 1\n    # return the coordinates\n    return [(row, col) for col in range(len(lst[row]))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x = int(x)\n    if x == 1:\n        return lst\n    elif x == len(lst):\n        return [(0, 0)]\n    else:\n        lst = sorted(lst, key=lambda x: x[0])\n        res = []\n        for i in range(x):\n            res.append((0, 0))\n            for j in range(x):\n                res[-1] = (res[-1][0] + 1, res[-1][j] + 1)\n        return res", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x < len(lst):\n        return [(lst[x], lst[x])]\n    else:\n        return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    row = 0\n    col = 0\n    i = 0\n    row_size = len(lst[0])\n    while i < row_size:\n        if lst[i][col] == x:\n            return [(i, col)]\n        i += 1\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return [(x, y) for x, y in zip(xrange(len(lst)), lst[x]) if x!= x]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # check if the row is empty\n    if len(lst) == 0:\n        return []\n    \n    # check if the row is the first one\n    if x == 0:\n        return [(x, 0)]\n    \n    # find the first coordinate of the row\n    row = lst[x][0]\n    \n    # sort the coordinates by the row\n    row = sorted(row, key=lambda x: x[0])\n    \n    # find the first coordinate of the row\n    col = lst[x][1]\n    \n    # sort the coordinates by the column\n    col = sorted(col, key=lambda x: x[1])\n    \n    # find the index of the coordinates in the row\n    ind = [(x, y) for x, y in zip(row, col)]\n    \n    # find the coordinates in the row\n    row = [(x, y) for x, y in ind]\n    \n    # sort the coordinates in the row\n    row = sorted(row, key=lambda x: x[1])\n    \n    # return the coordinates\n    return row", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # initial sort of rows\n    x_ = sorted(x)\n    # sort of columns\n    y_ = sorted(lst[x])\n    # sort by rows\n    x_ = sorted(x_)\n    # sort by columns\n    y_ = sorted(y_)\n    # return\n    return [(x_[i], y_[i]) for i in range(len(x_))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # get all coordinates\n    coords = []\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            coords.append((i, j))\n    coords.sort()\n    # sort coordinates by rows\n    coords.sort(key=lambda x: x[0])\n    # get row numbers\n    row_nums = []\n    for i in range(len(coords)):\n        row_nums.append(coords[i][0])\n    # sort row numbers\n    row_nums.sort()\n    # return coordinates\n    return [x for x in coords if x[1] in row_nums]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if x not in lst:\n        return []\n    row = lst[x]\n    if not row:\n        return []\n    col = 0\n    for i in range(0, len(row)):\n        if row[i] == x:\n            return [(col, i)]\n        col += 1\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return [(x, lst[x].index(x)) for x in xrange(0, len(lst)) if x % x == 0]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # initialize a list of tuples\n    row_coords = []\n    # initialize a list of the row\n    row = []\n    # initialize a list of integers\n    row_int = []\n    # initialize a list of the column\n    col = []\n    # initialize a list of integers\n    col_int = []\n    # initialize a list of the row\n    row_int_list = []\n    # initialize a list of the column\n    col_int_list = []\n    # initialize a list of integers\n    col_int_list = []\n    # initialize a list of integers\n    col_int_list = []\n    # initialize a list of integers\n    col_int_list = []\n    # initialize a list of the row\n    row_int_list = []\n    # initialize a list of the column\n    col_int_list = []\n    # initialize a list of integers\n    col_int_list = []\n    # initialize a list of integers\n    col_int_list = []\n    # initialize a list of integers\n    col_int_list = []\n    # initialize a list of integers\n    col_int_list = []\n    # initialize a list of integers\n    col_int_list = []\n    # initialize a list of integers\n    col_int_list = []\n    # initialize a list of integers\n    col_int_list = []\n    # initialize a list of integers\n    col", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    \n    # Get sorted coordinates by rows in ascending order.\n    rows = sorted(lst, key=lambda x: x[0])\n    # Get sorted coordinates of the row by columns in descending order.\n    cols = sorted(rows[0], key=lambda x: x[1], reverse=True)\n    \n    # Return sorted coordinates.\n    return [(x[0], x[1]) for x in zip(cols, rows[1:])]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = sorted(lst)\n    rows = []\n    cols = []\n    for i in range(x):\n        rows.append(lst[i][0])\n        cols.append(lst[i][1])\n    rows = sorted(rows)\n    cols = sorted(cols)\n    return rows[x:], cols[x:]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x = x - 1\n    if x < 0:\n        return []\n    if x == 0:\n        return [(0, 0)]\n    if x == len(lst):\n        return [(x, 0)]\n    if x == len(lst[0]):\n        return get_row(lst[1:], x - 1)\n    return get_row(lst[:x], x - 1)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) <= x:\n        return []\n    row = []\n    for i in range(x):\n        if len(lst[i]) == 1:\n            row.append((i, 0))\n        else:\n            row.append((i, len(lst[i]) - 1))\n    row.sort(key=lambda x: x[0])\n    return row", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if x < 0:\n        return []\n    if x == 0:\n        return [(0, len(lst[0]))]\n    if x == len(lst[0]):\n        return [(x, len(lst[0]))]\n    if x < len(lst):\n        return [get_row(lst, x - 1), get_row(lst, x)]\n    else:\n        return [get_row(lst, x - 1), []]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # return sorted(lst, key=lambda x: x[0])\n    return sorted(lst, key=lambda x: (x[0], x[1]))", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = [lst[0]]\n    for i in range(x):\n        if len(row) == i:\n            return row\n        row.append(lst[i])\n    return row", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    x = x - 1\n    if x < 0:\n        x = 0\n    if x >= len(lst):\n        return []\n    row, col = lst[x]\n    if not col:\n        return [(0, 0)]\n    if not row:\n        return []\n    if not col:\n        return [(0, 0)]\n    if not row or not col:\n        return [(0, 0)]\n    row.sort(key=lambda x: x[1])\n    col.sort(key=lambda x: x[0])\n    return [(x[0], x[1]) for x in zip(row, col)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = sorted(lst, key=lambda x: x[0])\n    rows = []\n    cols = []\n    for row in lst:\n        rows.append(row[0])\n        for col in row:\n            cols.append(col[1])\n    rows = sorted(rows, key=lambda x: x)\n    cols = sorted(cols, key=lambda x: x)\n    return zip(rows, cols)[x:]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    x = x % len(lst)\n    if not x:\n        return get_row(lst, x + 1)\n    x = x - 1\n    return sorted([(i, j) for i, j in enumerate(lst) if j == x])", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 1:\n        return lst\n    x = x - 1\n    if x < 0:\n        return []\n    if x == 0:\n        return [(0, 0)]\n    if x == len(lst):\n        return [(0, len(lst))]\n    x, y = get_row(lst, x)\n    return [(x, y)] + get_row(lst, x - 1)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Sort the row in ascending order\n    row = sorted(lst, key=lambda x: x[0])\n    # Sort the column in descending order\n    col = sorted(row, key=lambda x: x[1])\n    # Sort the row by columns in descending order\n    row = sorted(row, key=lambda x: x[1])\n    # Return the coordinates\n    return [(x, y) for x, y in zip(col, row) if x!= 0]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    if x in lst:\n        return get_row(lst[x], x+1)\n    if x == len(lst)-1:\n        return get_row(lst[:x], x+1)\n    else:\n        return get_row(lst[:x+1], x+1)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = []\n    for i in range(x):\n        row.append([])\n    for i in range(len(lst)):\n        row[x].append(lst[i][x])\n    row[x].sort()\n    row.sort(key=lambda x: x[1])\n    return row\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if x < 0:\n        return get_row(lst, -x)\n    if x > len(lst):\n        return get_row(lst, x - len(lst) + 1)\n    # first find the number of columns in the row\n    col = 0\n    for i in range(x):\n        if lst[i][col]!= None:\n            col += 1\n        else:\n            break\n    # find the row indices\n    row = 0\n    for i in range(x):\n        if lst[i][col]!= None:\n            row += 1\n    # now return the tuples\n    return [[row, col] for col in range(x) for row in range(x - col + 1)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def get_row(lst, x):\n        \"\"\"\n        Function to find coordinates of the row starting from 0\n        \"\"\"\n        row_coords = []\n        col_coords = []\n        for i in range(0, len(lst)):\n            row_coords.append(i)\n            for j in range(0, len(lst[i])):\n                if j == x:\n                    col_coords.append(j)\n                    break\n        return row_coords, col_coords\n\n    # Find row coordinates of the row starting from 0\n    row_coords, col_coords = get_row(lst, x)\n    # Sort row coordinates in ascending order\n    row_coords.sort(key=lambda x: x[0])\n\n    # Find column coordinates of the row starting from 0\n    row_coords = sorted(row_coords, key=lambda x: x[0])\n    col_coords = sorted(col_coords, key=lambda x: x[1])\n\n    return row_coords", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if x not in range(len(lst)):\n        raise ValueError(\"Invalid argument\")\n    if x > len(lst):\n        raise ValueError(\"Invalid argument\")\n    if x < 0:\n        raise ValueError(\"Invalid argument\")\n    if x == 0:\n        return [(0, 0)]\n    if x == len(lst) - 1:\n        return [(x, len(lst))]\n    if x == len(lst):\n        return [(x, len(lst))]\n    else:\n        return [(get_row(lst, x - 1), get_row(lst, x))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0 or x < 0 or x >= len(lst):\n        return []\n    else:\n        col = x // len(lst[0])\n        row = x % len(lst[0])\n        return [(row, col) for col in range(len(lst)) for row in range(col + 1)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if x < 0:\n        return [(x, len(lst))]\n    else:\n        return [get_row(lst, x-x) for x in range(x, len(lst))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if len(lst) == 1:\n        return [(0, 0)]\n    if not x:\n        return lst\n    if x == 0:\n        return get_row(lst[1:], x - 1)\n    else:\n        return get_row(lst[:x - 1], x - 1) + get_row(lst[x - 1:], x - 1)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    r = []\n    for i in range(x):\n        r.append([])\n        for j in range(x):\n            if i == j:\n                r[i][j] = lst[i][j]\n            else:\n                r[i][j] = 0\n    r.sort(key=lambda x: x[0])\n    r = sorted(r, key=lambda x: x[1])\n    return r", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    if x == len(lst) - 1:\n        return [(0, x)]\n    if x < 0:\n        return []\n    if x >= len(lst):\n        return [(x, x)]\n    if x == 0:\n        return [(x, 0)]\n    if x == len(lst) - 1:\n        return [(x, len(lst) - 1)]\n    if x < 0:\n        return []\n    if x >= len(lst):\n        return [(x, len(lst) - 1)]\n    if x == 0:\n        return [(x, 0)]\n    if x == len(lst) - 1:\n        return [(x, len(lst) - 1)]\n    if x < 0:\n        return []\n    if x >= len(lst):\n        return [(x, len(lst) - 1)]\n    if x == 0:\n        return [(0, x)]\n    if x == len(lst) - 1:\n        return [(x, x)]\n    if x < 0:\n        return []\n    if x >= len(lst):\n        return [(x, x)]\n    if x == 0:", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x < 0:\n        return []\n    if x == 0:\n        return [(0, 0)]\n    if x == len(lst):\n        return [(x, x)]\n    if x == len(lst[0]):\n        return get_row(lst[1:], x - 1)\n    return get_row(lst[:x - 1], x - 1)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x < 0:\n        raise ValueError('get_row: x must be positive')\n    if x < len(lst):\n        return [(x, x)]\n    else:\n        return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = []\n    col = []\n    for i in range(x):\n        row.append(lst[0][i])\n        col.append(lst[1][i])\n    for i in range(x):\n        row.append(row[i])\n        col.append(col[i])\n    row.sort()\n    col.sort()\n    return [(i, j) for i, j in zip(row, col)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    if x == lst.shape[0]:\n        return lst\n    if x < 0:\n        x = x + lst.shape[0]\n    if x > lst.shape[0]:\n        x = x - lst.shape[0]\n    if x < 0:\n        x = 0\n    if x > lst.shape[0]:\n        x = 0\n    row = x / lst.shape[0]\n    col = x % lst.shape[0]\n    return [(row, col) for row in range(lst.shape[0])]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x < 0 or x > len(lst):\n        return []\n    if x == 0:\n        return [(0, 0)]\n    if x == len(lst):\n        return [(x, len(lst))]\n    if x < len(lst) - 1:\n        return get_row(lst, x + 1) + [(x, len(lst))]\n    return get_row(lst, x) + get_row(lst, x + 1)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = 0\n    col = 0\n    while row < len(lst):\n        if lst[row][x] == x:\n            return [(row, col) for col in range(len(lst[row]))]\n        row += 1\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Sort by rows\n    lst = sorted(lst, key=lambda x: (x[0], x[1]))\n    # Sort by columns\n    lst = sorted(lst, key=lambda x: (x[1], x[0]))\n    # Return\n    return [(x[0], x[1]) for x in lst[x:]]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    x = int(x)\n    if x < 0:\n        return get_row(lst[1:], x+1)\n    if x > len(lst):\n        return get_row(lst[:-1], x-1)\n    x = int(x)\n    if x < 0:\n        return get_row(lst[1:], x+1)\n    if x > len(lst):\n        return get_row(lst[:-1], x-1)\n    if x == 0:\n        return get_row(lst, 0)\n    if x == len(lst) - 1:\n        return get_row(lst, len(lst) - 1)\n    return get_row(lst[:x], x) + get_row(lst[x:], x-1)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return [(x, y) for x in range(0, len(lst)) for y in range(0, x)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return [(x, y) for (y, x) in zip(lst[x], xrange(len(lst[x])))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # sort by rows in ascending order\n    return sorted(map(lambda x: (x[0], x[1]), lst), key=lambda x: x[0])", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # create a list of tuples\n    res = []\n    # find the start coordinate\n    start = 0\n    for i in range(len(lst)):\n        if lst[i][x] == x:\n            res.append([start, i])\n            start += 1\n    # find the end coordinate\n    for i in range(len(lst)):\n        if lst[i][x]!= x:\n            res.append([start, i])\n            start += 1\n    # sort the list of tuples\n    res.sort(key=itemgetter(1))\n    # return the result\n    return res", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    if x < len(lst):\n        return [(x, get_row(lst, x-1))]\n    else:\n        return [(0, 0)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = []\n    col = []\n    for item in lst:\n        if x == item[0]:\n            row.append(item[1])\n        elif x == item[1]:\n            col.append(item[0])\n    row.sort(key=lambda x: x[0])\n    col.sort(key=lambda x: x[1])\n    return row, col", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if x >= len(lst):\n        return []\n    if x < 0:\n        return []\n    if x == 0:\n        return [(0, 0)]\n    if x == len(lst):\n        return [(x, x)]\n    if x == len(lst) - 1:\n        return [(x, x)]\n    return [(get_row(lst[:x], y) for y in range(x, len(lst)))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    if x == 1:\n        return [[lst[x]] for lst in lst]\n    if x == 2:\n        return [[lst[x], lst[x+1]] for lst in lst]\n    if x == 3:\n        return [[lst[x], lst[x+1], lst[x+2]] for lst in lst]\n    if x == 4:\n        return [[lst[x], lst[x+1], lst[x+2]] for lst in lst]\n    if x == 5:\n        return [[lst[x], lst[x+1], lst[x+2]] for lst in lst]\n    if x == 6:\n        return [[lst[x], lst[x+1], lst[x+2]] for lst in lst]\n    if x == 7:\n        return [[lst[x], lst[x+1], lst[x+2]] for lst in lst]\n    if x == 8:\n        return [[lst[x], lst[x+1], lst[x+2]] for lst in lst]\n    if x == 9:\n        return [[lst[x], lst[x+1], lst[x+2]] for lst in lst]\n    if x == 10:\n        return [[lst[x], lst[x+1], lst[x+2]] for lst in lst]\n    if x == 11:\n        return [[lst[x], lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row, col = 0, 0\n    lst.sort(key=lambda x: x[0])\n    lst.sort(key=lambda x: x[1])\n    rows = []\n    for lst in lst:\n        if row == x and col == x:\n            return rows\n        if row == x and col!= x:\n            row += 1\n        else:\n            col += 1\n        rows.append((row, col))\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x < len(lst):\n        return get_row(lst[x], x + 1)\n    else:\n        return [(0, 0)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x = x % len(lst)\n    # Get row\n    row = lst[row]\n    # Get column\n    col = x % len(row)\n    # Get coordinates\n    return row[col]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x < 0:\n        raise ValueError(\"index must be non-negative\")\n    if x >= len(lst):\n        raise ValueError(\"index is out of range\")\n    if not isinstance(lst[x], list):\n        raise TypeError(\"lst must be a list\")\n    if not len(lst[x]) == 1:\n        raise ValueError(\"lst must contain one element\")\n    row = x\n    columns = len(lst[x]) - 1\n    return [(row, columns)] + get_row(lst[x], x + 1)\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    r = []\n    for i in range(x):\n        r.append((i, 0))\n    for i in range(x):\n        for j in range(len(lst)):\n            if lst[i][j] == x:\n                r.append((j, i))\n    r.sort(key=lambda x: (x[0], x[1]))\n    r.sort(key=lambda x: (x[0], x[2]))\n    return r", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if len(lst) == 1:\n        return lst[0]\n    if x > len(lst):\n        raise ValueError(\"index out of range\")\n    if x < 0:\n        raise ValueError(\"index out of range\")\n    x = x % len(lst)\n    res = []\n    for i in range(x):\n        res.append(get_row(lst[i:], x - i - 1))\n    return res", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    lst.sort()\n    lst = list(map(lambda x: x[1], lst))\n    lst.sort(key=lambda x: x[0])\n    return [(x[0], x[1]) for x in lst[x:]]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    ret = []\n    for row in lst:\n        if x in row:\n            ret.append((x, len(row)))\n        else:\n            ret.append((0, len(row)))\n    ret.sort(key=lambda x: x[1], reverse=True)\n    ret.sort(key=lambda x: x[0], reverse=True)\n    return ret", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x < 0:\n        return None\n    row = x % len(lst)\n    columns = x / len(lst)\n    if not row in lst[row]:\n        return None\n    res = []\n    for i in range(len(lst[row])):\n        res.append(get_row(lst[row][i], columns))\n    res.sort(key=lambda x: x[0])\n    return res", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = sorted(lst, key=lambda x: x[0], reverse=True)\n    return [(x[0], get_row(lst, x[1])) for x in xrange(1, x+1)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if len(lst) == 1:\n        return [(0,0)]\n    sorted_row = sorted(lst[0], key=lambda x: x[0])\n    sorted_col = sorted(lst, key=lambda x: x[1])\n    sorted_row = sorted_row[:x]\n    sorted_col = sorted_col[:x]\n    sorted_row.sort(key=lambda x: x[0])\n    sorted_col.sort(key=lambda x: x[1])\n    return [(x, y) for (x, y) in zip(sorted_row, sorted_col)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 1:\n        return lst\n    if x == len(lst):\n        return [(0, 0)]\n    if x < 1:\n        raise ValueError('x must be greater than 0')\n    # make a list of tuples\n    coords = []\n    for i in range(len(lst)):\n        if x <= i:\n            break\n        for j in range(x - i + 1):\n            coords.append((i, j))\n    coords.sort()\n    # make a list of tuples\n    rows = []\n    for i in range(x):\n        rows.append((coords[i][0], coords[i][1]))\n    rows.sort()\n    # make a list of tuples\n    cols = []\n    for j in range(x):\n        cols.append((rows[j][0], j))\n    cols.sort()\n    # return a list of tuples\n    return [(row, col) for row, col in zip(rows, cols)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if x < 0:\n        raise ValueError(\"x must be >= 0\")\n    x = int(x)\n    if x == 0:\n        return [(0, 0)]\n    if x == len(lst):\n        return [(x, len(lst))]\n    if x == len(lst) - 1:\n        return [(x, len(lst))]\n    if x > len(lst) - 1:\n        return [(x, len(lst))]\n    return [(get_row(lst, x - 1), get_row(lst, x))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = []\n    column = 0\n    for i in range(len(lst)):\n        if lst[i][x] == x:\n            row.append((column, i))\n            column += 1\n        else:\n            row.append((column, i))\n            column = 0\n    row.sort(key=lambda x: x[1])\n    for i in row:\n        row.append((column, i))\n        column += 1\n    return row", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if x < 0:\n        return []\n    if x >= len(lst):\n        return []\n    rows = list(range(len(lst)))\n    rows.sort(reverse=True)\n    cols = list(range(len(lst[0])))\n    cols.sort(reverse=True)\n    if x == 0:\n        return [(0, 0)]\n    if x == len(lst[0]):\n        return [(len(lst) - 1, len(lst) - 1)]\n    if x == 1:\n        return [(0, 0), (1, len(lst) - 1)]\n    if x == len(lst):\n        return [(0, 0), (len(lst) - 1, len(lst) - 1)]\n    if x > 1:\n        return [(0, 0), (x - 1, len(lst) - 1)]\n    return [(0, 0), (0, 0)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x < 0:\n        raise ValueError(\"get_row(lst, x): x < 0\")\n    if x >= len(lst):\n        raise ValueError(\"get_row(lst, x): x >= len(lst)\")\n    row = x / len(lst)\n    col = x % len(lst)\n    return [(row, col) for row in lst[row]]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if x < 0:\n        raise ValueError('x must be >= 0')\n    if x == 0:\n        return [(0, 0)]\n    if x == len(lst):\n        return [(x, x)]\n    if x < len(lst) - 1:\n        lst = lst[:x] + [lst[x] + []] + lst[x + 1:]\n    x = 0\n    y = 0\n    row = 0\n    column = 0\n    # find all coordinates of the row\n    for i in range(x, len(lst)):\n        if lst[i]!= []:\n            row = i\n            break\n    # find all coordinates of the column\n    for j in range(y, len(lst[0])):\n        if lst[0][j]!= []:\n            column = j\n            break\n    # sort coordinates of the row in ascending order\n    for i in range(x, len(lst)):\n        if lst[i]!= []:\n            for j in range(y, len(lst[0])):\n                if lst[0][j]!= []:\n                    if i == j:\n                        continue\n                    if lst[i][j] < lst[0][j]:\n                        tmp = lst[i][j]\n                        lst[i][j] = lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    lst = sorted(lst, key=lambda x: x[0], reverse=True)\n    rows = []\n    for row in lst:\n        rows.append([])\n        for i in range(len(row)):\n            rows[-1].append(i)\n    rows.sort(key=lambda x: x[0], reverse=True)\n    for row in rows:\n        for i in range(len(row)):\n            for j in range(len(row[i])):\n                if row[i][j] == x:\n                    return [(i, j)]\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Initialize list of coordinates\n    coords = []\n    # Get row coordinates\n    for i in range(x):\n        coords.append([])\n        # Get column coordinates\n        for j in range(lst[i][j]):\n            coords[i].append(j)\n    # Sort coordinates by rows in ascending order\n    coords = sorted(coords, key=lambda x: x[0])\n    # Get column coordinates\n    for i in range(x):\n        coords[i] = sorted(coords[i], key=lambda x: x[1])\n    # Return coordinates\n    return coords", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) <= x:\n        return lst\n    else:\n        return [get_row(lst[:x], i) for i in range(len(lst))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x < 0:\n        raise ValueError(\"Argument must be non-negative.\")\n    if x >= len(lst):\n        raise ValueError(\"Argument must be less than or equal to \"\n                         \"the size of the list.\")\n    result = []\n    for i in range(0, x):\n        result.append([lst[i][0], lst[i][1]])\n    result.sort(key=lambda x: x[0])\n    for i in range(0, len(result)-1):\n        result[i][0], result[i][1] = result[i+1][0], result[i+1][1]\n    return result", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # find coordinate of the element\n    # if there is no element in the list, return None\n    if not lst:\n        return None\n\n    # sort the list by the row\n    # if the row is not sorted, sort it\n    if not lst[0].count(x):\n        lst.sort(key=lambda x: x[0])\n\n    # return the coordinates of the element\n    return [(x, y) for y, x in enumerate(lst) if x == x]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if x >= len(lst):\n        return []\n    if x < 0:\n        return []\n    if x == 0:\n        return lst[0]\n    if x == 1:\n        return [(0, 0)] + get_row(lst[1:], x-1)\n    if x == 2:\n        return [(0, 0)] + get_row(lst[1:], x-1) + [(1, 1)]\n    if x == 3:\n        return [(0, 0)] + get_row(lst[1:], x-1) + [(1, 1)] + get_row(lst[1:], x-2)\n    if x == 4:\n        return [(0, 0)] + get_row(lst[1:], x-1) + [(1, 1)] + get_row(lst[1:], x-2) + [(2, 2)]\n    if x == 5:\n        return [(0, 0)] + get_row(lst[1:], x-1) + [(1, 1)] + get_row(lst[1:], x-2) + [(2, 2)] + get_row(lst[1:], x-3)\n    if x == 6:\n        return [(0,", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if x == 0:\n        return [(0, 0)]\n    if x == len(lst[0]):\n        return [(x, 0)]\n    # sort row first\n    rows = sorted(lst, key=lambda x: x[0])\n    # sort column second\n    cols = sorted(rows, key=lambda x: x[1])\n    # return list of tuples\n    return [(x, y) for (x, y) in zip(cols, rows) if x <= xx]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def sort_rows(rows):\n        \"\"\"\n        Given a list of rows, sort them initially by rows in ascending order.\n        \"\"\"\n        rows.sort(key=lambda x: x[0])\n    def sort_cols(rows):\n        \"\"\"\n        Given a list of rows, sort them initially by columns in descending order.\n        \"\"\"\n        rows.sort(key=lambda x: x[1])\n    rows = []\n    for row in lst:\n        rows.append(get_row(row, x))\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return lst\n    if x > len(lst):\n        return []\n    if x < 0:\n        return []\n    row = 0\n    col = 0\n    while row < len(lst) and col < x:\n        if lst[row][col] == x:\n            return [(row, col)]\n        row += 1\n        col += 1\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Initial sorting\n    lst.sort(key=lambda x: (x[0], x[1]))\n    # Sorting by row, ascending\n    row_sorted = [(x[0], x[1]) for x in lst]\n    row_sorted.sort()\n    # Sorting by columns, descending\n    col_sorted = [(x[2], x[0]) for x in row_sorted]\n    col_sorted.sort()\n    # Resulting list of tuples\n    result = []\n    # For each row, create a list of coordinates\n    for row in row_sorted:\n        # For each column, create a list of coordinates\n        for col in col_sorted:\n            # Create a tuple of coordinates\n            result.append((row, col))\n    return result", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = sorted(lst, key=lambda x: x[0]) # Sort by rows in ascending order\n    rows = [(i, x[0]) for i, x in enumerate(lst) if x[0]!= 0]\n    rows = sorted(rows, key=lambda x: x[1], reverse=True) # Sort by columns in descending order\n    rows = [(x[1], i) for i, x in enumerate(rows) if x[1]!= 0]\n    return rows", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = sorted(lst, key=lambda x: x[0], reverse=True)\n    if x > len(rows):\n        return []\n    return [(rows[x][0], x - rows[x][0]) for x in range(rows[x][1], x + 1)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = [[] for i in range(x)]\n    for i in range(len(lst)):\n        for j in range(x):\n            if i in lst[i]:\n                row[j].append(i)\n    # Sort by rows\n    for i in range(len(row)):\n        row[i].sort()\n    # Sort by columns\n    for i in range(len(row)):\n        for j in range(len(row[i])):\n            row[i][j] = row[i][j] - 1\n    return row", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if not x in lst:\n        return []\n    if not x in lst[x]:\n        return []\n    lst = lst[x]\n    if len(lst) <= x:\n        return []\n    lst = lst[:x]\n    if not len(lst):\n        return []\n    lst = sorted(lst, key=lambda x: x[0])\n    return sorted(lst, key=lambda x: x[1], reverse=True)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    res = []\n    for i in range(0, len(lst)):\n        for j in range(0, len(lst[i])):\n            res.append((get_row(lst[i], x-1), get_row(lst[i][j], x-1)))\n    res.sort(key=lambda x: (x[0], x[1]))\n    res.sort(key=lambda x: (x[1], x[0]))\n    return res\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = sorted(lst, key=lambda x: x[0])\n    res = []\n    for i in range(len(lst)):\n        for j in range(i, len(lst)):\n            if i == j:\n                continue\n            res.append((lst[i][j], lst[j][i]))\n    res.sort()\n    res = sorted(res, key=lambda x: (x[0], x[1]))\n    return res", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if x < 0 or x >= len(lst):\n        raise ValueError(\"index out of bounds\")\n    if x == 0:\n        return [(0, 0)]\n    if x == len(lst):\n        return [(x, len(lst))]\n    if x == len(lst)-1:\n        return [(x, 0)]\n    if x == len(lst)-2:\n        return [(x, 1)]\n    if x == len(lst)-3:\n        return [(x, 2)]\n    if x == len(lst)-4:\n        return [(x, 3)]\n    if x == len(lst)-5:\n        return [(x, 4)]\n    if x == len(lst)-6:\n        return [(x, 5)]\n    if x == len(lst)-7:\n        return [(x, 6)]\n    if x == len(lst)-8:\n        return [(x, 7)]\n    if x == len(lst)-9:\n        return [(x, 8)]\n    if x == len(lst)-10:\n        return [(x, 9)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Initial sort\n    lst.sort(key=lambda x: x[0])\n    # Sorting by rows\n    res = []\n    for i in range(len(lst)):\n        res.append((i, get_row(lst[i], x)))\n\n    # Sorting by columns\n    res.sort(key=lambda x: x[1], reverse=True)\n    return res", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = []\n    for r in range(0, len(lst)):\n        row.append([x for x in lst[r] if x >= x])\n    return sorted(row, key=lambda x: x[0], reverse=True)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = 0\n    cols = 0\n    while row < len(lst):\n        if cols == x:\n            return [(row, cols)]\n        row += 1\n        if row == len(lst):\n            return []\n        cols += 1\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) <= x:\n        return []\n    row, col = lst[x]\n    if col > row and col > 0:\n        row, col = col, row\n    return [(row, col) for col in range(row+1)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return lst\n    if x == len(lst):\n        return []\n    if x == 1:\n        return [(0, 0)]\n    if x == len(lst[0]):\n        return [(x, 0)]\n    r = []\n    for i in range(0, len(lst[0])):\n        for j in range(0, len(lst)):\n            if lst[j][i] == x:\n                r.append((i, j))\n    return r", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = []\n    col = []\n    for i in range(len(lst)):\n        row.append(lst[i][0])\n        col.append(i)\n    sorted_row = sorted(row, key=lambda x: x)\n    sorted_col = sorted(col, key=lambda x: x)\n    return [(x, y) for x, y in zip(sorted_col, sorted_row)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # get row index\n    row = int(x) - 1\n    # get row coordinates\n    row_coords = []\n    for i in range(len(lst[row])):\n        row_coords.append(lst[row][i])\n    row_coords.sort()\n    # get column index\n    col = int(x) - 1\n    # get column coordinates\n    col_coords = []\n    for i in range(len(lst[row_coords[0]])):\n        col_coords.append(lst[row_coords[0]][i])\n    col_coords.sort()\n    return row_coords, col_coords", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    x = int(x)\n    x = range(len(lst))\n    for i in xrange(len(lst)):\n        for j in xrange(len(lst[i])):\n            if j == x:\n                return lst[i][j]\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = 0\n    col = 0\n    lst = sorted(lst, key=lambda x: (x[0], x[1]))\n    for i in range(len(lst)):\n        if i == x - 1:\n            return [(row, col) for row in range(0, len(lst[i])) for col in range(0, len(lst[i][row]))]\n        row += 1\n        col += 1\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    lst.sort(key=lambda x: x[0])\n    lst = [list(lst[x]) for x in range(x)]\n    if not lst:\n        return []\n    lst.sort(key=lambda x: x[1])\n    return lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = []\n    col = []\n    for i in range(len(lst)):\n        row.append(lst[i][0])\n        col.append(lst[i][1])\n        if i == x:\n            return [row, col]\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if len(lst) <= x:\n        return [(0, 0)]\n    row = 0\n    col = 0\n    while col < x:\n        if row < len(lst) and lst[row].count(col) > 0:\n            yield [row, col]\n        row += 1\n        col += 1\n    while row < len(lst):\n        if col < len(lst[row]):\n            yield [row, col]\n        col += 1\n        row += 1", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Get the start index\n    start = x * (len(lst) - 1)\n    # Get the end index\n    end = start + x\n    # Get the list of tuples\n    result = [lst[start:end]]\n    # Sort the tuples in the row\n    result.sort(key=lambda x: x[1])\n    # Sort the tuples in the column\n    result.sort(key=lambda x: x[0])\n    # Return the list of tuples\n    return result", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    if x == len(lst):\n        return lst\n    if x < 0:\n        x = len(lst) - x\n    # Sort coordinates initially by rows in ascending order.\n    sorted_coords = [(i, j) for i in range(0, len(lst)) for j in range(0, x)]\n    sorted_coords.sort(key=lambda x: x[1])\n    # Sort coordinates of the row by columns in descending order.\n    sorted_coords.sort(key=lambda x: x[0])\n    return sorted_coords", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # TODO - implement this properly\n    row = []\n    for i in range(x):\n        row.append([])\n    for i in range(len(lst)):\n        for j in range(x):\n            if i == 0 or j == 0:\n                row[0].append(lst[i][j])\n            else:\n                row[i].append(lst[i][j])\n    return row", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = []\n    cols = []\n    for i in range(len(lst)):\n        if len(lst[i]) == x:\n            rows.append(lst[i][0])\n            cols.append(lst[i][1])\n        else:\n            rows.append(0)\n            cols.append(0)\n    rows.sort(key=lambda x: x[0])\n    cols.sort(key=lambda x: x[1])\n    return [(i, j) for i, j in zip(rows, cols)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if len(lst) == 1:\n        return [(0, 0)]\n    if not x:\n        return get_row(lst, 0)\n    # find the first element in the row which is not 0\n    start = 0\n    for row in lst:\n        if row[start]!= 0:\n            return get_row(lst, start)\n    # if we reach here, all elements in the row are 0\n    return [(0, 0)]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    if x < 0:\n        raise ValueError('x must be non-negative')\n    if x in lst:\n        return lst[x]\n    if x == 0:\n        return []\n    if x in lst[0]:\n        return get_row(lst[1:], x-x%len(lst[0]))\n    return get_row(lst[1:], x-x%len(lst[0]))", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    if len(lst) == 0:\n        return []\n    if x == len(lst):\n        return [(0, 0)]\n    if x == 0:\n        return []\n    if x == len(lst[0]):\n        return [(0, 0)]\n    if x == len(lst[0][0]):\n        return [(0, 0)]\n    if x == len(lst[0][0][0]):\n        return []\n    if x == len(lst[0][0][0][0]):\n        return [(0, 0)]\n    if x == len(lst[0][0][0][0][0]):\n        return []\n    if x == len(lst[0][0][0][0][0][0]):\n        return []\n    if x == len(lst[0][0][0][0][0][0][0]):\n        return []\n    if x == len(lst[0][0][0][0][0][0][0][0]):\n        return []\n    if x == len(lst[0][0][0][0][0][0][0][0][0]):\n        return []\n    if x == len(lst[0][0][0][0][0][0][0][0][0][0]):\n        return []\n    if x == len(lst[0][0][0][0][0][0][0][0][0][0][0]):\n        return []\n    if x == len(lst[0][0][0][0][0][0][0][0][0][0][0][0]):\n        return []\n    if x == len(lst", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    return [(x, y) for x in xrange(0, len(lst)) for y in xrange(0, len(lst[x]))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # find the first element in the list\n    first = 0\n    for i in range(len(lst)):\n        if lst[i][0] == x:\n            first = i\n    # if the first element is not found, return empty list\n    if first == len(lst):\n        return []\n    # find the last element in the list\n    last = len(lst) - 1\n    for i in range(first, last):\n        if lst[i][0] == x:\n            break\n    # if the last element is not found, return empty list\n    if last == len(lst):\n        return []\n    # find the coordinates of the element in the list\n    row = lst[first][0]\n    columns = lst[first][1:]\n    # sort coordinates in ascending order\n    row.sort(key=lambda x: x[0])\n    columns.sort(key=lambda x: x[1])\n    # return the coordinates\n    return [(row, columns)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    return sorted([(i,j) for i,j in enumerate(lst) if i == x], key=lambda x: x[1], reverse=True)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if x < 0:\n        return []\n    x = max(x, 0)\n    row = x // len(lst[0])\n    col = x % len(lst[0])\n    return lst[row][col:]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = sorted(lst, key=lambda x: x[0], reverse=True)\n    x = int(x)\n    lst = [lst[i] for i in range(x)]\n    lst = sorted(lst, key=lambda x: x[1], reverse=True)\n    return [(x, y) for x, y in enumerate(lst)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    l = []\n    i = 0\n    for row in lst:\n        if x in row:\n            l.append((i, i))\n            i += 1\n    l.sort(key=lambda x: x[0])\n    for i in range(len(l) - 1):\n        for j in range(len(l[i]) - 1):\n            if l[i][j + 1] > l[i][j]:\n                l[i][j + 1], l[i][j] = l[i][j], l[i][j + 1]\n    return l", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    l = []\n    for i in range(len(lst)):\n        row = []\n        for j in range(len(lst[i])):\n            row.append(lst[i][j])\n        l.append(row)\n    l.sort(key=lambda x: x[0])\n    if len(l) > 0:\n        l = l[0]\n        for i in range(1, len(l)):\n            l[i] = (l[i][0], l[i][1] + 1)\n    l = sorted(l, key=lambda x: x[1])\n    return l", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    if x < 0:\n        return []\n    if x >= len(lst):\n        return []\n    row = x / len(lst)\n    col = x % len(lst)\n    return lst[row][col]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # sort rows in ascending order\n    lst.sort(key=lambda x: x[0])\n    # sort columns in descending order\n    lst.sort(key=lambda x: x[1])\n    # get row number and column number\n    row, column = lst[x]\n    return [(row, column)] + get_row(lst, x+1)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # initialize x, and sort by rows in ascending order\n    x = x * len(lst)\n    x.sort()\n    # initialize y, and sort by columns in descending order\n    y = [0] * len(lst[0])\n    for i in range(len(lst[0])):\n        y[i] = 0\n    for i in range(len(lst)):\n        for j in range(len(lst[0])):\n            if lst[i][j]!= x[i]:\n                break\n        else:\n            break\n    # convert to list of tuples\n    return [(x[i], y[i]) for i in range(len(lst[0]))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) <= x:\n        return [(0, 0)]\n    lst = sorted(lst, key=lambda x: x[0])\n    lst = sorted(lst, key=lambda x: x[1], reverse=True)\n    return [(x[0], x[1]) for x in lst[0: x]] + [(x[0], x[1]) for x in lst[x:]]\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if x == 0:\n        return []\n    if x < len(lst):\n        return [(x, i) for i in range(x)]\n    return [(0, 0)] + get_row(lst, x - len(lst))", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if len(lst) == 0:\n        return []\n    else:\n        # find the first element of lst, that is not equal to x\n        first_x = lst[0]\n        for i in range(1, len(lst)):\n            if lst[i]!= x:\n                first_x = lst[i]\n        # sort coordinates in ascending order\n        lst = sorted(lst, key=lambda x: x[0])\n        # find first coordinate that is equal to x\n        first_x = lst[0]\n        for i in range(1, len(lst)):\n            if lst[i][0] == x and lst[i][1] == x:\n                first_x = lst[i]\n                break\n        # sort coordinates of the row in descending order\n        lst = sorted(lst, key=lambda x: x[1])\n        # return list of tuples\n        return [(x, get_row(lst, x)) for x in range(1, len(lst))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = sorted(lst, key=lambda x: x[1])\n    lst = sorted(lst, key=lambda x: x[0])\n    return [(x[0], x[1]) for x in lst[x:]]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    row = []\n    for i in range(0, len(lst)):\n        if x in lst[i]:\n            row.append((i, x))\n    row.sort(key=lambda x: x[1])\n    return row", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Sort by rows in ascending order.\n    row = []\n    for i in range(len(lst)):\n        row.append([])\n        for j in range(len(lst[i])):\n            row[i].append(lst[i][j])\n    row.sort(key=lambda x: x[0])\n    # Sort by columns in descending order.\n    col = []\n    for i in range(len(row)):\n        col.append([])\n        for j in range(len(row[i])):\n            col[i].append(row[i][j])\n    col.sort(key=lambda x: x[1])\n    # Return tuples starting with 0.\n    return [row[x] for x in range(len(row))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # sort by columns\n    lst.sort(key=lambda x: x[x], reverse=True)\n    # sort by rows\n    lst.sort(key=lambda x: x[0], reverse=False)\n    # find row\n    row = 0\n    for x in range(x, len(lst)):\n        if lst[row].count(x) == 1:\n            row = x\n            break\n    # find columns\n    columns = 0\n    for y in range(row, len(lst)):\n        if lst[row][y].count(x) == 1:\n            columns = y\n            break\n    return [(x, y) for x in range(columns, len(lst)) for y in range(0, x)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    def get_col(lst, x):\n        \"\"\"\n        Get column with x-th element of the list.\n        \"\"\"\n        return [lst[x][0]]\n    def get_row(lst, x):\n        \"\"\"\n        Get row with x-th element of the list.\n        \"\"\"\n        return lst[x][1:]\n    def sort_coord(lst, x):\n        \"\"\"\n        Sort list of coordinates.\n        \"\"\"\n        lst.sort(key=lambda x: get_col(lst, x), reverse=True)\n        lst.sort(key=lambda x: get_row(lst, x), reverse=True)\n    def sort_coord_row(lst, x):\n        \"\"\"\n        Sort list of coordinates by rows.\n        \"\"\"\n        lst.sort(key=lambda x: get_row(lst, x), reverse=True)\n    # sort_coord(lst, x):\n    #    Sort the list of coordinates by x-th column.\n    #    Sort the list of coordinates by x-th row.\n    sort_coord(lst, x)\n    sort_coord_row(lst, x)\n    return lst[x][1:]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    lst = list(lst)\n    if x == 0:\n        return [(0, 0)]\n    if x == len(lst) - 1:\n        return [(len(lst) - 1, 0)]\n    if x == len(lst) - 2:\n        return [(0, 0), (len(lst) - 1, 0)]\n    if x == len(lst) - 3:\n        return [(0, 0), (len(lst) - 1, 0), (len(lst) - 2, 0)]\n    if x == len(lst) - 4:\n        return [(0, 0), (len(lst) - 1, 0), (len(lst) - 2, 0), (len(lst) - 3, 0)]\n    # print(lst)\n    # print(x)\n    # print(get_row(lst, x))\n    return [(x, get_row(lst, x + 1)) for x in range(x + 1, len(lst))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    if not lst:\n        return []\n    if x in lst[0]:\n        return get_row(lst[1:], x-1)\n    return get_row(lst[1:], x+1)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if not lst:\n        return []\n    if len(lst) == 1:\n        return [(x, y) for x in range(0, len(lst[0])) for y in range(0, len(lst[0][x]))]\n    sorted_rows = sorted([(x, y) for x in range(0, len(lst[0])) for y in range(0, len(lst[0][x]))])\n    sorted_columns = sorted([(x, y) for x in range(0, len(lst)) for y in range(0, len(lst[x]))])\n    row_indices = [(x, y) for x in range(0, len(sorted_rows)) for y in range(0, len(sorted_rows[x]))]\n    column_indices = [(x, y) for x in range(0, len(sorted_columns)) for y in range(0, len(sorted_columns[x]))]\n    return [(x, y) for x in range(0, len(sorted_rows)) for y in range(0, len(sorted_rows[x]))]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    rows = len(lst) - 1\n    cols = x\n    result = []\n    for i in range(rows):\n        for j in range(cols):\n            if i == 0 and j == 0:\n                result.append((i, j))\n            else:\n                result.append((get_row(lst, i - 1), get_row(lst, j - 1)))\n    result.sort()\n    return result", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # Find the first element of the row that is greater than x\n    lst = sorted(lst, key=lambda x: x[0])[:x]\n    # Find the first element of the row that is greater than x\n    # Get the first element of the row, and sort it by columns\n    lst = sorted(lst, key=lambda x: x[1])[:x]\n    # Get the first element of the row, and sort it by columns\n    lst = sorted(lst, key=lambda x: x[2])[:x]\n    # Sort the row by columns, and return the list of tuples\n    return sorted(lst, key=lambda x: (x[1], x[2]))[:x]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # sorted\n    sorted = sorted(lst, key=lambda x: x[0])\n    # find x in the sorted list\n    if x in lst:\n        return sorted[:x]\n    # if not, return empty list\n    return []", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    if x == len(lst):\n        return lst\n    if x > len(lst):\n        return []\n    x = int(x)\n    if x % 2 == 0:\n        # find row in lst that contains x\n        r = lst[x]\n        # find column in r that contains x\n        c = r[x]\n    else:\n        # find row in lst that contains x\n        r = lst[x]\n        # find column in r that contains x\n        c = r[-x]\n    return get_row(lst[r], c)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x < 0:\n        return []\n    lst = sorted(lst, key=lambda x: x[x])\n    if len(lst) < x:\n        return []\n    lst = sorted(lst[:x], key=lambda x: x[-1])\n    lst = sorted(lst, key=lambda x: x[0])\n    return [(x[0], x[1]) for x in lst]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # This is a recursive function.\n    # The inner loop checks if the given index is in the given row.\n    # If it is, the function returns the tuple of coordinates\n    # of the given index. Otherwise, it checks if the given index\n    # is in the list of coordinates of the given row.\n    # If it is, the function returns the tuple of coordinates\n    # of the given index. Otherwise, it checks if the given index\n    # is in the list of coordinates of the given row.\n    # If it is, the function returns the tuple of coordinates\n    # of the given index. Otherwise, it checks if the given index\n    # is in the list of coordinates of the given row.\n    # If it is, the function returns the tuple of coordinates\n    # of the given index. Otherwise, it checks if the given index\n    # is in the list of coordinates of the given row.\n    # If it is, the function returns the tuple of coordinates\n    # of the given index. Otherwise, it checks if the given index\n    # is in the list of coordinates of the given row.\n    # If it is, the function returns the tuple of coordinates\n    # of the given index. Otherwise, it checks if the given index\n    # is in the list", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # get first row\n    r = lst[0]\n    # get first column\n    c = r[0]\n    # get number of columns in the first row\n    n = len(r)\n    # get number of rows in the first column\n    m = len(r[0])\n    # get row with first column\n    r = lst[1:]\n    # get first column in the first row\n    c = r[0]\n    # get number of columns in the first row\n    n = len(r[0])\n    # get number of rows in the first column\n    m = len(r[0])\n    # return a list of tuples, [(x1, y1), (x2, y2)...]\n    # sort coordinates initially by rows in ascending order\n    # sort coordinates of the row by columns in descending order\n    return sorted([(x, y) for (x1, y1), (x2, y2) in get_row(r, c) for (x, y) in get_row(r, x) if x!= c], key=lambda x: x[1])", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    if x == len(lst):\n        return [(x, x)]\n    else:\n        return sorted([(get_row(lst, i), get_row(lst, j)) for i in range(x) for j in range(x)])\n</s>", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # We will use an array to store the values, and sort it first\n    # Then we will use this array to find the coordinates\n    # (row, columns)\n    # The initial sorting is by rows, so we will start with the first row\n    # and use the array to find the first column\n    # Then we will iterate through the rows, and find the next column\n    # Once we find a column, we will keep track of the row and column,\n    # and continue searching\n    # Once we find the first column, we will start looking for the next one\n    # in the same row\n    # Once we find the last column, we will continue searching in the next row\n    # (to find the last column)\n    # Once we find the last column, we will check to see if we have found the last row\n    # if so, we will return the list of tuples\n    # Otherwise, we will continue looking for the next row\n    \n    # Initially, we will make an array of all the rows\n    # This is to make sure that we can find the first row\n    # We will sort the array by rows\n    # Then we will use this array to find the first column\n    # and return the tuple, [(0, 0)]", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # sorted(lst, key=lambda x: x[0]) == sorted(lst, key=lambda x: x[0].index)\n    # sorted(lst, key=lambda x: x[0].index) == sorted(lst, key=lambda x: x[0].index.index)\n    # sorted(lst, key=lambda x: x[0].index.index) == sorted(lst, key=lambda x: x[0].index.index.index)\n    # sorted(lst, key=lambda x: x[0].index.index.index) == sorted(lst, key=lambda x: x[0].index.index.index.index)\n    # sorted(lst, key=lambda x: x[0].index.index.index.index) == sorted(lst, key=lambda x: x[0].index.index.index.index.index)\n    # sorted(lst, key=lambda x: x[0].index.index.index.index.index) == sorted(lst, key=lambda x: x[0].index.index.index.index.index.index)\n    # sorted(lst, key=lambda x: x[0].index.index.index.index.index.index) == sorted(lst, key=lambda x: x[0].index.index", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x in lst:\n        return [x[0]]\n    if x == 0:\n        return []\n    if x == len(lst) - 1:\n        return lst\n    return get_row(lst[:x], x - 1) + get_row(lst[x + 1:], x - 1)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    if x == 0:\n        return []\n    res = []\n    while lst:\n        res.append((lst[0][0], lst[0][1]))\n        lst = lst[1:]\n    if x < len(res):\n        res.sort(key=itemgetter(1), reverse=True)\n    else:\n        res.sort(key=itemgetter(0), reverse=True)\n    res = sorted(res, key=itemgetter(0), reverse=True)\n    return res", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    ret = []\n    for i in range(len(lst)):\n        if i == x:\n            ret.append((lst[i][0], i))\n        elif lst[i]:\n            ret.append((get_row(lst[i], x), i))\n    return ret", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    lst = sorted(lst, key=lambda x: x[0])\n    if len(lst) > x:\n        return get_row(lst[:x], x)\n    else:\n        return get_row(lst, x)", "def get_row(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    get_row([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    get_row([], 1) == []\n    get_row([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"    # initial sort by rows\n    lst_sort = sorted(lst, key=lambda x: x[0])\n    # initial sort by columns\n    lst_sort = sorted(lst_sort, key=lambda x: x[1])\n    # iterate over rows\n    for row in lst_sort:\n        # iterate over columns\n        for col in range(len(row)):\n            # check if the row is in the xth row\n            if row[col] == x:\n                # check if the column is in the xth column\n                if col == x:\n                    # return the row\n                    return [(row[col], col)]\n                # if not, then return the column\n                return [(col, row[col])]\n    # if the row is not in the xth row, then return None\n    return None"]]