[["from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Init list to store parsed result\n    nested_parens: List[int] = []\n    # Loop through each group of parentheses in input string\n    # Start with innermost group, store first level of nesting of parenthesis in nested_parens\n    for grouping in paren_string.split():\n        # For each group of parenthesis, parse it\n        if grouping.startswith('(') and grouping.endswith(')'):\n            # Parse nested parenthesis\n            nested_parens.append(int(grouping[1:-1]))\n        else:\n            # If no nested parenthesis found, add current grouping to output\n            nested_parens.append(0)\n    # Return the parsed result\n    return nested_parens\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    brackets = []\n    brackets.append(0)\n    brackets.append(0)\n    brackets.append(0)\n    brackets.append(0)\n    brackets.append(0)\n    brackets.append(0)\n    brackets.append(0)\n    brackets.append(0)\n    brackets.append(0)\n\n    current_level = 0\n    current_level += 1\n\n    for i in range(len(paren_string)):\n        paren = paren_string[i]\n        if paren == '(':\n            current_level += 1\n        elif paren == ')':\n            current_level -= 1\n        else:\n            if current_level > 0:\n                brackets[current_level - 1] += 1\n            else:\n                brackets[current_level - 1] = 0\n\n    return brackets", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return map(int, paren_string.split())", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    for cur_index, cur_char in enumerate(paren_string):\n        if cur_index == 0:\n            nested_parens.append(cur_char)\n        else:\n            if cur_char in ('(', ')'):\n                nested_parens.append(int(cur_char))\n            else:\n                nested_parens.append(int(cur_char))\n\n                # add depth to the top level and recurse\n                depth = 0\n                while cur_index < len(nested_parens) and nested_parens[cur_index] == 1:\n                    depth += 1\n                    cur_index += 1\n\n                nested_parens.append(depth)\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    level = 0\n    parenthesis = []\n\n    for group in paren_string.split(' '):\n        parenthesis.append(group)\n\n        for parenthesis_item in parenthesis:\n            if parenthesis_item:\n                if parenthesis_item[0] == '(':\n                    level += 1\n                    parenthesis.append([level, parenthesis_item[1]])\n                elif parenthesis_item[0] == ')':\n                    level -= 1\n                    parenthesis.pop()\n\n                if level < 0:\n                    break\n\n            elif parenthesis_item == ')':\n                break\n\n        if level == 0:\n            parenthesis.pop()\n    return parenthesis", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def parse_node(node: List[int]) -> List[int]:\n        if len(node) == 1:\n            return [node[0]]\n        else:\n            return parse_node(node[1:])\n\n    return parse_node(paren_string.split())", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nested_paren_list: List[List[int]] = []\n\n    for paren_string in paren_string.split():\n        nested_paren_list.append([])\n\n        if paren_string == ')':\n            nested_paren_list[-1].append(-1)\n\n        else:\n            nested_paren_list[-1].append(parse_nested_parens(paren_string))\n\n    return nested_paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # noinspection PyBroadException\n    try:\n        result = list(map(int, paren_string.strip().split(' ')))\n    except ValueError:\n        result = []\n    if len(result) < 1:\n        return []\n    result = [deepest(result) for deepest in result]\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n\n    for i in range(len(paren_string)):\n        if paren_string[i] == ')':\n            nested_parens.append(i)\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string.startswith('('):\n        group = [int(paren_string[1:].strip())]\n    elif paren_string.startswith('(') and paren_string.endswith(')'):\n        group = [int(paren_string[:-1].strip())]\n    else:\n        raise ValueError('Unrecognized input')\n\n    return group\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    n = 0\n    nesting = {}\n    groups = []\n    first = None\n\n    for token in paren_string.split():\n        if token in ('(', ')'):\n            if first is None:\n                first = n\n            elif first == n:\n                first = None\n        elif token in (' ', ')'):\n            n = n - 1\n        elif token not in ('(', ')',''):\n            nesting[token] = n\n            n += 1\n        elif token == '(':\n            n += 1\n        elif token == ')':\n            n -= 1\n        else:\n            groups.append([first, n, token])\n            nesting[token] = n\n\n    groups.sort(key=lambda x: x[1])\n    for tokens in groups:\n        nesting[tokens[0]] = nesting[tokens[1]]\n        n += 1\n\n    return nesting.keys()", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res: List[int] = []\n    for group in paren_string.split(' '):\n        if len(group):\n            res.append(len(group) - 1)\n    return res", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups: List[int] = []\n    group_size: int = 0\n\n    # we loop through the string in chunks of length 4\n    while group_size < len(paren_string):\n        index = paren_string.find('(', group_size)\n\n        if index < 0:\n            break\n\n        # we add the current index to the list of indexes where we store the number of nesting levels\n        groups.append(index)\n\n        group_size += 4\n\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # This is a stack of depth of nested parens, with the last one being the deepest.\n    stack = list()\n    parse_stack = list()\n\n    # The current paren group being processed.\n    current = 0\n\n    # Add the first paren group to stack.\n    stack.append(current)\n\n    # For each paren group, parse it and add to the stack of nested parens.\n    while current!= 0:\n        current = stack.pop()\n\n        # Add the paren group to parse_stack.\n        parse_stack.append(current)\n\n    # Start parsing from the bottom to the top of stack.\n    while parse_stack:\n        current = parse_stack.pop()\n        if current in stack:\n            # Decrement the depth of nesting.\n            stack.append(-1)\n\n        else:\n            # Increment the depth of nesting.\n            stack.append(1)\n\n    # Return the nested parens.\n    return stack", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    string_builder = []\n    for group in paren_string.split():\n        if len(group) > 0:\n            if '(' in group and ')' in group:\n                result.append(parse_nested_parens(group.split('(', 1)[1]))\n            else:\n                string_builder.append(group)\n    if len(string_builder) > 0:\n        result.append(parse_nested_parens(string_builder[-1]))\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting = 0\n    for paren in paren_string.split():\n        if paren == '(':\n            nesting += 1\n        elif paren == ')':\n            nesting -= 1\n    return nesting", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = list(paren_string.split())\n\n    res = []\n    for i, p in enumerate(parens):\n        if p.startswith('('):\n            res.append(i)\n            res.extend(parse_nested_parens(p.strip('()')))\n        elif p.startswith(')'):\n            res.append(i - 1)\n            res.extend(parse_nested_parens(p.strip('()')))\n        elif not p.strip():\n            res.append(i - 1)\n\n    return res", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nested_paren_list = []\n\n    for nested_paren_string in paren_string.split(' '):\n        if nested_paren_string.strip():\n            nested_paren_list.append(parse_nested_parens(nested_paren_string))\n\n    return nested_paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [int(i) for i in paren_string.split(' ') if i.strip()]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    paren_list = paren_string.split()\n    paren_dict = {}\n\n    for paren in paren_list:\n        if '(' in paren:\n            nesting = parse_nested_parens(paren)\n            paren_dict[nesting[0]] = nesting[1]\n            break\n        else:\n            paren_dict[paren] = 0\n\n    return paren_dict", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting_levels: List[int] = [-1] * len(paren_string)\n\n    nesting_levels[0] = 1\n    for nesting_level in range(1, len(paren_string)):\n        nesting_levels[nesting_level] += 1\n        paren_string = paren_string.replace('()', '()'* (nesting_level - 1))\n        paren_string = paren_string.replace('(', '('* (nesting_level - 1))\n        paren_string = paren_string.replace(')', ')'* (nesting_level - 1))\n        paren_string = paren_string.replace(')', ')'* (nesting_level - 1))\n        paren_string = paren_string.replace('(', '('* (nesting_level - 1))\n        paren_string = paren_string.replace('(', ')'* (nesting_level - 1))\n\n    return nesting_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for c in paren_string:\n        if c == '(':\n            result.append(1)\n        elif c == ')':\n            result.append(-1)\n        elif c == '(':\n            result.append(1)\n        elif c == ')':\n            result.append(-1)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = []\n    for group in paren_string.split(' '):\n        if group == '':\n            continue\n\n        group = group.replace(')', '')\n        if group[0] == '(':\n            paren_groups.append(1)\n        else:\n            paren_groups.append(0)\n        if group[-1] == ')':\n            paren_groups.append(-1)\n        else:\n            paren_groups.append(0)\n    return paren_groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = []\n    for char in paren_string:\n        if char == '(':\n            groups.append(0)\n        elif char == ')':\n            groups[-1] += 1\n        elif char =='' and groups[-1] > 0:\n            groups.append(groups[-1] - 1)\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    output = []\n    for i in range(0, len(paren_string), 2):\n        if paren_string[i] == '(':\n            output.append(1)\n        elif paren_string[i] == ')':\n            output.append(-1)\n        elif paren_string[i] =='' or paren_string[i] == '\\t' or paren_string[i] == '\\n':\n            # if a space was found then this is not the last iteration.\n            continue\n        else:\n            raise ValueError('Incorrect parse nested parenthesis.')\n\n    return output", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def _find_parenthesis(string: str, level: int, parenthesis: str) -> int:\n        parenthesis = parenthesis.split(' ')\n\n        if parenthesis[0] not in string[level + 1]:\n            return 0\n\n        parenthesis = parenthesis[0]\n        parenthesis = parenthesis.replace('(', '').replace(')', '')\n\n        return int(string[level + 1][ parenthesis ]) - 1\n\n    parenthesis = []\n\n    for parenthesis_string in paren_string.split(' '):\n        parenthesis.append(_find_parenthesis(string=''.join(parens.split(' ')), 0, parenthesis_string))\n\n    parenthesis.reverse()\n    return [level for level, parenthesis_string in enumerate(parens) if parenthesis_string!= '']", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n\n    nested_paren_count = 0\n    for group in paren_string.split():\n        if group[0] == '(':\n            nested_paren_count += 1\n            if nested_paren_count == 2:\n                result.append(1)\n            elif nested_paren_count == 3:\n                result.append(2)\n            else:\n                break\n        else:\n            if nested_paren_count > 2:\n                break\n    result.append(nested_paren_count - 1)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    brackets = 0\n    found_open = False\n    last_open_index = 0\n    opening_group = []\n    parenthesis_levels = []\n    parenthesis_levels_group = 0\n    paren_string = paren_string.strip()\n    for char in paren_string:\n        if char == '(' and not found_open:\n            brackets += 1\n            opening_group.append(char)\n        elif char == ')' and found_open:\n            parenthesis_levels_group += 1\n            parenthesis_levels.append(parenthesis_levels_group)\n            parenthesis_levels.append(brackets)\n            last_open_index = paren_string.find(char, last_open_index + 1)\n            if parenthesis_levels[1] == brackets:\n                parenthesis_levels.append(brackets)\n                parenthesis_levels_group = 0\n                brackets = 0\n                opening_group = []\n        elif char == '(' and found_open:\n            parenthesis_levels_group += 1\n            parenthesis_levels.append(brackets)\n            parenthesis_levels.append(parenthesis_levels_group)\n            parenthesis_levels.append(brackets)\n            opening_group.append(char)\n        elif char == ')' and parenthesis_levels_group:\n            parenthesis_levels_group += 1", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    # Input is a string with parentheses seperated by spaces.\n    # Parse the string into groups of parentheses.\n    # Groups are separated by spaces and no other character.\n    # Each group contains a single set of parentheses.\n\n    paren_groups: List[List[int]] = []\n    level: int = 0\n\n    for char in paren_string:\n        if char == ')':\n            level -= 1\n            if level < 0:\n                break\n\n            paren_groups.append([])\n        elif char == '(':\n            level += 1\n            paren_groups.append([])\n\n        paren_groups.append([])\n\n    return paren_groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return list(map(int, paren_string.split()))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # this is where we start\n    output = []\n\n    # Each group of parenthesis is represented by a tuple, containing the number of parenthesis before and after\n    # the outer group.\n    for outer_group, inner_group in zip(paren_string.split(), paren_string.split(' ')):\n        # If there is only one parenthesis group, append it to the list\n        if not inner_group:\n            output.append(outer_group)\n        else:\n            # Count the number of parenthesis groups\n            num_groups_before = len(parse_nested_parens(outer_group))\n            num_groups_after = len(parse_nested_parens(inner_group))\n\n            if num_groups_before < num_groups_after:\n                # Move all the parenthesis groups from the inner group to the outer group\n                output.extend(inner_group)\n\n            # Append the current outer group to the output\n            output.append(outer_group)\n\n    return output", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for level in range(len(paren_string)):\n        if paren_string[level] == '(':\n            result.append(level)\n            result.extend(parse_nested_parens(paren_string[level + 1:]))\n        else:\n            result.append(level)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    levels = [None] * len(paren_string)\n    for i, paren_string_part in enumerate(paren_string.split()):\n        if paren_string_part == ')':\n            if levels[i] is None:\n                levels[i] = 0\n            else:\n                levels[i] = levels[i] - 1\n        else:\n            levels[i] = levels[i] + 1\n\n    return levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens: List[int] = []\n    for paren_group in paren_string.split(' '):\n        group = []\n        level = 0\n        while paren_group:\n            group.append(paren_group[0])\n            paren_group = paren_group[1:]\n            if paren_group:\n                level += 1\n        if level > nested_parens[-1] + 1:\n            nested_parens.append(level)\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    groups = []\n    paren_count = 0\n    for group in paren_string.split():\n        if group in (\"(\", \")\"):\n            if paren_count == 0:\n                groups.append(paren_count)\n            paren_count += 1\n            continue\n        group = group.strip(\"() \")\n        if group in (\"(\", \")\"):\n            if paren_count == 0:\n                groups.append(paren_count)\n            paren_count += 1\n            continue\n        groups.append(group)\n        paren_count = 0\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n\n    for char in paren_string:\n        if char == '(':\n            nested_parens.append(0)\n        elif char == ')':\n            nested_parens.append(0)\n        elif char == '(':\n            nested_parens.append(1)\n        elif char == ')':\n            nested_parens.append(1)\n        elif char == '(':\n            nested_parens.append(2)\n        elif char == ')':\n            nested_parens.append(2)\n        elif char == ')':\n            nested_parens.append(3)\n        elif char == ')':\n            nested_parens.append(3)\n        else:\n            raise ValueError(\"Invalid character while parsing nesting level of parentheses\")\n\n    return nested_parens\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_level = 0\n\n    # input: (()())\n    #     ^\n    #     >\n    #     >\n    #     >\n    #     ^\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #     >\n    #", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depth = 0\n    paren_groups = list(paren_string.split())  # type: List[str]\n    for group in paren_groups:\n        if group == ')':\n            depth += 1\n        elif group == '(':\n            depth -= 1\n        else:\n            paren_groups.insert(0, group)\n            depth = 0\n    return depth", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parenthesis = (int(x) for x in paren_string.split() if x.isdigit())\n    nesting = {(x + 1, y) for x, y in parenthesis}\n    return [max(nesting.values()) for _, _ in parenthesis]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    seen = set()\n    levels = [stack]\n    for token in paren_string.split():\n        if token in seen:\n            continue\n        seen.add(token)\n        if token == ')':\n            if len(stack) > 0:\n                levels.pop()\n            else:\n                raise Exception('Unmatched parenthesis found')\n        elif token in ('(', ')') and len(stack) == 0:\n            levels.append(int(token))\n        else:\n            levels.append(1)\n    return levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for group in paren_string.split():\n        if group.startswith('('):\n            result.append(parse_nested_parens(group[1:]))\n        else:\n            result.append(int(group))\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [int(i) for i in paren_string.split(' ')]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def _count_inner(text: str) -> int:\n        return len(text.split()) - 1\n\n    def _parse_nested_parens(group_string: str) -> List[int]:\n        if len(group_string.split()) == 0:\n            return []\n\n        result = []\n        for group in group_string.split():\n            level = _count_inner(group)\n            if level >= 2:\n                result.append(level)\n                continue\n            result.append(_parse_nested_parens(group))\n\n        return result\n\n    return _parse_nested_parens(paren_string)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def push(paren_string: str) -> List[int]:\n        paren_list = []\n        for space_index in range(len(paren_string) - 1, -1, -1):\n            if paren_string[space_index] =='':\n                paren_list.append(1)\n                continue\n            elif paren_string[space_index] == '(':\n                paren_list.append(2)\n            elif paren_string[space_index] == ')':\n                paren_list.append(3)\n            else:\n                raise ValueError(\"Invalid paren string\")\n\n        return paren_list\n\n    return [list(stack) for stack in [push(paren_string) for paren_string in paren_string.split(' ')]]\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = [int(group) for group in paren_string.split() if group!= '']\n    return list(map(max, groups))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    # Note: This is a data structure that represents the maximum nesting depth of parentheses.\n    # e.g. Parenthesis[0] contains a list of all parenthesis whose depth is equal to 0\n    nested_parenthesis = {}\n\n    # Create a list to store all parenthesis in a single level\n    parentheses = []\n\n    # Get all parenthesis in a single level\n    for char in paren_string:\n        if char == '(':\n            parentheses.append(1)\n        elif char == ')':\n            parentheses.append(-1)\n        else:\n            parenthesis[-1] += 1\n\n    # Loop through each parenthesis\n    for i in range(0, len(parenthesis)):\n        for j in range(0, i):\n            # If a parenthesis has a depth greater than 1, it must contain a new level\n            if parenthesis[i] > 0 and parenthesis[j] > 0:\n                nested_parenthesis[parenthesis[i]].append(parenthesis[j])\n\n    return nested_parenthesis.values()", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if len(paren_string) == 0:\n        return []\n\n    # find first space\n    i = 0\n    while i < len(paren_string) and paren_string[i]!='':\n        i += 1\n\n    # find last space\n    j = len(paren_string) - 1\n    while j >= 0 and paren_string[j]!='':\n        j -= 1\n\n    # process groups\n    levels = []\n    while i < j:\n        # skip spaces between parentheses\n        while i < j and paren_string[i] =='':\n            i += 1\n\n        # find next opening parenthesis\n        while i < j and paren_string[i] == '(':\n            i += 1\n\n        # if next parenthesis is not matched, add current level to list\n        if i < j:\n            levels.append(int(paren_string[i]))\n\n        # skip spaces between parentheses\n        while i < j and paren_string[i] =='':\n            i += 1\n\n        # find next closing parenthesis\n        while i < j and paren_string[i] == ')':\n            i += 1\n\n        # if next parenthesis is not matched, add current level to list\n        if i < j:\n            levels.append(int(paren_string[i]))\n\n        # skip", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nesting_level = 0\n\n    paren_string = paren_string.strip()\n\n    nesting_level += 1\n    found_parens = False\n    sub_parens = 0\n\n    # Initially, find all the parenthesis\n    for paren in paren_string.split():\n        if paren.strip() == ')':\n            found_parens = True\n            sub_parens += 1\n            if sub_parens == 0:\n                return nesting_level\n\n    nesting_level += 1\n    parens_found = False\n    sub_parens = 0\n\n    # Now, for each parenthesis, find out if it is a group\n    for paren in paren_string.split():\n        if paren.strip() == '(':\n            parens_found = True\n            sub_parens += 1\n            if sub_parens == 0:\n                return nesting_level\n\n    return nesting_level", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    parenthesis_levels: List[int] = []\n    parenthesis = paren_string.split(' ')\n    for parenthesis in parenthesis:\n        parenthesis_levels.append(paren(paren_string, parenthesis))\n\n    return parenthesis_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    pattern = r'(\\s*)((?:\\s*\\(\\s*))?)|(\\s*)\\(\\s*((?:\\s*\\(\\s*))?)|(\\s*)\\(\\s*(\\(\\s*)\\s*))?|(\\s*)\\(\\s*(\\(\\s*)\\s*))?'\n    groups = []\n    for start, group, end in re.finditer(pattern, paren_string):\n        groups.append(int(end.group(0)) - int(start.group(0)))\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.strip()\n    paren_levels = []\n\n    # Get the first ( as a list to iterate over\n    paren_levels.append(1)\n\n    for string in paren_string.split(\" \"):\n        if string.isdigit():\n            paren_levels.append(int(string))\n        else:\n            if string.strip() == \"(\":\n                paren_levels.append(1)\n            elif string.strip() == \")\":\n                paren_levels.append(paren_levels[-1] - 1)\n\n    return paren_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for paren in paren_string.split(' '):\n        if ')' in paren:\n            result.append(paren.count(')'))\n        else:\n            result.append(1)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for char in paren_string:\n        if char == '(':\n            result.append(0)\n        elif char == ')':\n            result.append(1)\n        else:\n            result.append(2)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = []\n\n    for c in paren_string:\n        if c == '(':\n            groups.append(1)\n        elif c == ')':\n            groups.append(-1)\n        else:\n            groups.append(0)\n\n    groups.reverse()\n\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [int(x.rstrip()) for x in paren_string.split(' ') if x.isdigit()]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nested_parens = [int(paren_string.rfind(')'))]\n    for nested_parenthesis in nested_parens:\n        nested_parenthesis += 1\n        if nested_parenthesis > 1:\n            nested_parenthesis = parse_nested_parens(' '.join(nested_parens))\n            nested_parens = nested_parenthesis\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens: List[int] = []\n    for character in paren_string:\n        if character == '(':\n            nested_parens.append(1)\n        elif character == ')':\n            nested_parens.pop()\n        elif character == '(':\n            nested_parens.append(2)\n        elif character == ')':\n            nested_parens.pop()\n        elif character == '(':\n            nested_parens.append(3)\n        elif character == ')':\n            nested_parens.pop()\n        else:\n            return nested_parens\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace('(', '').replace(')', '')\n    paren_string = paren_string.split(' ')\n    paren_string = [int(paren_string[i]) for i in range(len(paren_string)) if paren_string[i]]\n    return paren_string", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.strip()\n    result = []\n    parent = 0\n    for char in paren_string:\n        if char == '(':\n            parent += 1\n        elif char == ')':\n            if parent > 0:\n                parent -= 1\n                result.append(parent)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [int(x) for x in paren_string.split(' ') if x]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [int(i) for i in paren_string.split(' ') if i.isdigit()]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace('(', '( ').replace(')', ') ')\n\n    def parse(paren_string: str, last_level: int) -> List[int]:\n        \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n        For each of the group, output the deepest level of nesting of parentheses.\n        E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n        >>> parse('(()()) ((())) () ((())()())', 2)\n        [2, 3, 1, 3]\n        \"\"\"\n        levels = []\n\n        level = 0\n        pos = 0\n        while pos < len(paren_string):\n            if paren_string[pos] == '(':\n                level += 1\n            elif paren_string[pos] == ')':\n                level -= 1\n\n            if level == 0:\n                break\n\n            pos += 1\n\n        if level > 0:\n            levels.append(level)\n\n        return levels\n\n    return parse(paren_string, -1)\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace('(', '').replace(')', '')\n    return [int(x) for x in paren_string.split() if x]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting_levels = []\n    while paren_string:\n        paren_string = paren_string.lstrip()\n        if paren_string.startswith('('):\n            nesting_levels.append(0)\n        elif paren_string.startswith(')'):\n            nesting_levels.append(-1)\n        else:\n            nesting_levels.append(1)\n        while paren_string and paren_string.startswith(' '):\n            paren_string = paren_string[1:]\n        if paren_string:\n            paren_string = paren_string.rstrip()\n        if paren_string.startswith('('):\n            nesting_levels.append(0)\n        elif paren_string.startswith(')'):\n            nesting_levels.append(-1)\n        else:\n            nesting_levels.append(1)\n    return nesting_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens: List[int] = []\n    depth: int = 0\n\n    for paren in paren_string:\n        if paren == ')':\n            depth -= 1\n\n        elif paren == '(':\n            depth += 1\n\n        elif depth == 0:\n            parens.append(depth)\n\n    return parens\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting_levels: List[int] = []\n    for token in paren_string.split(\" \"):\n        if token:\n            nesting_levels.append(parse_nested_parens(token))\n    return nesting_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_levels = 0\n    outer_levels = 0\n    for char in paren_string:\n        if char == '(':\n            nested_levels += 1\n            if nested_levels == 1:\n                outer_levels += 1\n            else:\n                outer_levels = 0\n        elif char == ')':\n            if nested_levels == 0:\n                return [outer_levels]\n            else:\n                nested_levels -= 1\n                if nested_levels == 0:\n                    return [outer_levels]\n    return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_string = paren_string.split(' ')\n    nested_string = nested_string[0]\n    nested_group = []\n    for nested_string in nested_string[1:]:\n        nested_group.append(int(nested_string))\n    return nested_group", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nested_parens = []\n    current_level = 0\n    paren_string = paren_string.strip()\n    while paren_string and not paren_string.isspace():\n        nested_parens.append(int(paren_string[current_level:current_level + 1]))\n        if paren_string[current_level] == '{':\n            current_level += 1\n            paren_string = paren_string[current_level:]\n        elif paren_string[current_level] == '}':\n            current_level -= 1\n        else:\n            raise Exception(f'Unknown group '{paren_string}' in nested_parens')\n        paren_string = paren_string[current_level:]\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    match_list = re.findall('(\\\\((\\\\S+)\\\\))', paren_string)\n    matches = [list(match) for match in match_list]\n\n    return [\n        max(\n            0,\n            sum(x for x in range(*matches[i]) if len(matches[i]) > len(matches[i + 1]) and x <= len(matches[i + 1]))\n    )\n        for i in range(len(matches) - 1)\n    ]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_levels = []\n    nesting = 0\n    group_count = 0\n    for char in paren_string:\n        if char == '(':\n            nested_levels.append(nesting)\n            nesting += 1\n            group_count += 1\n        elif char == ')':\n            nesting -= 1\n            if nesting == 0:\n                nested_levels.append(nesting)\n                group_count += 1\n        elif char =='':\n            if nesting == 0:\n                nested_levels.append(nesting)\n                group_count += 1\n    return nested_levels, group_count", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Start with 1 so we can add the current level to the sum\n    depth = 1\n\n    paren_string =''.join(paren_string.split())\n    for paren in paren_string.split():\n        if paren.startswith('(') and paren.endswith(')'):\n            depth += 1\n        elif paren.startswith('('):\n            depth += 1\n        elif paren.endswith(')'):\n            depth -= 1\n\n    return depth\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_groups = [int(x) for x in paren_string.split(' ')]\n\n    def get_parentheses(level: int) -> List[int]:\n        return [(i + 1) if i > 0 else 0 for i in paren_groups[level]]\n\n    return [max(get_parentheses(l), key=lambda x: x[0]) for l in paren_groups if len(get_parentheses(l)) > 0]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = {}\n    for level in range(len(paren_string)):\n        if not paren_string[level]:\n            break\n        elif paren_string[level] == '(':\n            nested_parens[level] += 1\n        elif paren_string[level] == ')':\n            nested_parens[level] -= 1\n        elif paren_string[level] in ('(', ')'):\n            pass\n        else:\n            raise ValueError('Unexpected parenthesis {} at level {}'.format(paren_string[level], level))\n\n    nested_parens.sort()\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    # Parse the input and convert to list\n    nested_list = []\n    for group in paren_string.split(\" \"):\n        group_list = group.split(\"(\")\n        nested_list.append(group_list[0].split(\")\")[1])\n\n    # Find the deepest level of nesting\n    nested_list = [item for item in nested_list if len(item) > 0]\n    return [item for item in nested_list if len(item) >= 2]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting = {}\n    i = 0\n    nested_parens = paren_string.strip('() ').split('() ')\n    if nested_parens[0] == '()':\n        nested_parens.pop(0)\n    nested_parens = [int(p) for p in nested_parens]\n    while nested_parens:\n        level = 0\n        p = nested_parens.pop(0)\n        if p not in nesting.keys():\n            nesting[p] = level\n        else:\n            nesting[p] = max(nesting[p], level + 1)\n        i += 1\n    return nesting.values()", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_levels = []\n    nested_level = 0\n    depth = 0\n    nested_match = False\n    for char in paren_string:\n        if char == '(':\n            nested_match = True\n        elif char == ')':\n            nested_match = False\n        elif nested_match:\n            depth += 1\n            nested_level = nested_levels[depth - 1]\n            nested_levels[depth - 1] += 1\n        elif depth == 0:\n            nested_levels.append(nested_level)\n        else:\n            nested_level = nested_levels[-1]\n            nested_levels[-1] += 1\n            depth = 0\n    return nested_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # First we need to get the list of inner parenthesis to the the right parenthesis.\n    parenthesis = [paren_string[i] for i in range(1, len(paren_string)) if paren_string[i] == '(']\n    parenthesis.reverse()  # just in case\n\n    # Next we need to get the level of nested parenthesis. We can do that by keeping track of the index of\n    # the last parenthesis encountered and then seeing how many more left parenthesis there are.\n    level = 0\n    last_index = -1\n    parenthesis.reverse()  # just in case\n\n    for i, paren in enumerate(parens):\n        if paren!= '(':\n            level += 1\n        elif last_index == -1:\n            level += 1\n            last_index = i\n        elif paren == '(':\n            level += 1\n        elif paren == ')':\n            level -= 1\n            if level <= 0:\n                return [level, last_index]  # since parenthesis are stacked, we only need to know the max level of nesting\n\n    return [level, last_index]\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [len([paren for paren in paren_string.split(' ') if paren]) for paren_string in paren_string.split(' ') if paren_string]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [[int(paren_string[i]) for i in range(0, len(paren_string))] for paren_string in paren_string.split(' ')]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [int(x) for x in paren_string.split(' ') if x]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.replace(')', '').replace('(', '')\n    return [int(p) for p in paren_string.split(' ') if p]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    paren_string_list = paren_string.split()\n    paren_string_list = list(map(str.strip, paren_string_list))\n    paren_string_list = list(map(str.lower, paren_string_list))\n    paren_string_list = list(map(str.capitalize, paren_string_list))\n    paren_string_list = list(map(str.upper, paren_string_list))\n    paren_string_list = list(map(str.replace, paren_string_list, '(', '(', 1, 0, 1))\n\n    if len(paren_string_list) == 0:\n        return [None]\n\n    if paren_string_list[0] in ('(', '('):\n        paren_string_list.pop(0)\n\n    nesting_levels = [None] * len(paren_string_list)\n\n    for index, paren_string in enumerate(paren_string_list):\n\n        if paren_string == '(':\n            nesting_levels[index] = 1\n\n        elif paren_string == ')':\n            nesting_levels[index] = -1\n\n        elif paren_string == '(':\n            nesting_levels[index] = 1\n\n        elif paren_string == ')':\n            nesting_levels[", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    parenthesis = [paren_string[0]]\n\n    # For each parenthesis\n    while parenthesis[0] not in \"()\":\n        parenthesis.append(paren_string[0])\n\n        # For each parenthesis group\n        parenthesis_string = parenthesis[0]\n        while parenthesis_string[0] not in \"()\":\n            parenthesis_string.pop(0)\n\n            # For each parenthesis group\n            parenthesis.append(parse_nested_parens(\" \" + parenthesis_string))\n\n        parenthesis.pop(0)\n\n    parenthesis = list(map(int, parenthesis))\n\n    parenthesis.reverse()\n\n    return parenthesis", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for char in paren_string:\n        if char in ('(', ')'):\n            result.append(1)\n        elif char == '(':\n            result.append(2)\n        elif char == ')':\n            result.append(3)\n        elif char == '(':\n            result.append(1)\n        elif char == ')':\n            result.append(3)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [int(i) for i in paren_string.split() if i]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Skip the first space\n    paren_string = paren_string[1:]\n\n    # Build a list of tuples with all the groups of parenthesis.\n    groups = []\n\n    while paren_string:\n        paren_group = []\n\n        # Break into single parenthesis\n        if paren_string.startswith('(') and paren_string.endswith(')'):\n            paren_group.append(int(paren_string[1:-1]))\n        else:\n            paren_group.append(int(paren_string))\n\n        # Append current group to list of all groups\n        groups.append(tuple(paren_group))\n\n        # Skip spaces in between parentheses\n        if paren_string.strip():\n            paren_string = paren_string[1:]\n\n    # Return nested parentheses\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parens = []\n    outer_paren_count = 0\n    for char in paren_string:\n        if char == ')':\n            outer_paren_count += 1\n            if outer_paren_count > 1:\n                parens.append(outer_paren_count)\n            parens.append(0)  # Variable names are not allowed to have parentheses.\n        elif char == '(':\n            outer_paren_count += 1\n            parens.append(outer_paren_count)\n    return parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n        return []\n    return [int(paren_string[x: x + 1].rstrip('()')) for x in range(0, len(paren_string)) if paren_string[x].isdigit()]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for group in paren_string.split():\n        if ')' in group:\n            result.append(int(group.split(')')[0].split('(')[0]))\n            result.append(int(group.split(')')[1].split('(')[0]))\n            break\n        else:\n            result.append(int(group.split('(')[0].split(')')[0]))\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_para_list = []\n    for para_string in paren_string.split():\n        if '(' not in para_string:\n            nested_para_list.append(para_string)\n        else:\n            nested_para_list.append(parse_nested_parens(para_string))\n    return nested_para_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    res = []\n    for string in paren_string.split(' '):\n        if '()' in string:\n            res.append(1)\n        elif '()' in string.upper():\n            res.append(2)\n        elif '(' in string.upper():\n            res.append(0)\n        elif '(' in string.upper():\n            res.append(0)\n        else:\n            res.append(0)\n\n    return res", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    out = []\n    for i in xrange(len(paren_string)):\n        if paren_string[i] == ')':\n            out.append(i)\n            break\n        elif paren_string[i] == '(':\n            out.append(i + 1)\n        elif paren_string[i] == '(':\n            out.append(i + 1)\n            out.append(i + 2)\n\n    return out", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return map(parse_nested_parens, paren_string.split(\" \"))\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    match = re.search(r'(\\(\\(\\(\\(\\(\\))*\\))*)', paren_string)\n    if not match:\n        return []\n\n    return [int(match.group(0))]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested = []\n    nested_parens = paren_string.split(' ')\n    nested_parens = map(int, nested_parens)\n\n    for nested_nest in nested_parens:\n        nested.append(int(nested_nest))\n\n    return nested", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = []\n    parsed = []\n    for index, item in enumerate(paren_string.split()):\n        if item == '(':\n            groups[index] = 1\n        elif item == ')':\n            groups[index] = 0\n        else:\n            parsed.append(item)\n    groups = list(map(int, groups))\n    result = []\n    for group in groups:\n        if group == 1:\n            result.append(len(parsed))\n        else:\n            result.append(len(parsed) - group)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.strip()\n    res = []\n    for i in range(0, len(paren_string)):\n        if paren_string[i] == '(':\n            res.append(1)\n        elif paren_string[i] == ')':\n            res.append(0)\n        elif paren_string[i] == '(':\n            res.append(1)\n        elif paren_string[i] == ')':\n            res.append(0)\n    return res", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_count: List[int] = []\n    depth = 0\n    for char in paren_string:\n        if char == '(':\n            paren_count.append(depth)\n            depth += 1\n        elif char == ')':\n            depth -= 1\n            paren_count.append(depth)\n    return paren_count", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = []\n    for group in paren_string.split():\n        if group == '':\n            continue\n        if group.startswith('(') and group.endswith(')'):\n            groups.append(int(group[1:]))\n            continue\n        if group.startswith('(') and not group.endswith(')'):\n            groups.append(int(group[1:]))\n        elif group.startswith(')'):\n            groups.pop()\n        else:\n            raise ValueError('Invalid group: {!r}'.format(group))\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Combine all groups into a list\n    groups = paren_string.split(' ')\n\n    # Examine every group in turn, building up a dictionary to store the level of nesting\n    nesting_map = dict()\n    for group in groups:\n        parts = group.split('()')\n        if parts[0] not in nesting_map:\n            nesting_map[parts[0]] = 0\n        nesting_map[parts[0]] += 1\n\n    # Find the deepest nesting level\n    max_depth = max(nesting_map.values())\n\n    return [max_depth - i for i in range(max_depth)]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = re.sub(r'(\\s*)(\\()(\\s*)', r'\\1 \\3', paren_string)\n    paren_string = re.sub(r'(\\s*)(\\(.*)', r'\\1 \\2', paren_string)\n    paren_string = re.sub(r'(\\s*)(\\(.*)\\)', r'\\1 \\1', paren_string)\n    paren_string = re.sub(r'\\(.*\\)', '()', paren_string)\n    paren_string = re.sub(r'\\(\\s*\\)', '()', paren_string)\n    return paren_string.split(' ')", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting_level = 0\n    result = []\n    for n in paren_string:\n        if n == '(':\n            nesting_level += 1\n            result.append(nesting_level)\n        elif n == ')':\n            nesting_level -= 1\n            result.append(nesting_level)\n        elif n =='':\n            # break loop and continue if n is space and nesting_level > 0\n            if nesting_level > 0:\n                break\n        else:\n            result.append(nesting_level)\n    return result\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups: List[str] = []\n    groups_len: List[int] = []\n    paren_count: List[int] = [0]\n    for char in paren_string:\n        if char in ['(', ')']:\n            if paren_count[0] == 0:\n                groups.append(char)\n                groups_len.append(len(char))\n            else:\n                paren_count[0] += 1\n        else:\n            paren_count[0] += 1\n            groups_len.append(1)\n    return groups, groups_len, paren_count", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    nested_level = 0\n    found = False\n    for character in paren_string:\n        if not found:\n            if character == '(':\n                nested_parens.append(0)\n                nested_level += 1\n            elif character == ')':\n                nested_parens.append(nested_level - 1)\n                nested_level -= 1\n            elif character == '(':\n                nested_parens.append(1)\n                nested_level += 1\n            elif character == ')':\n                nested_parens.append(nested_level - 1)\n                nested_level -= 1\n            elif character == '(' and nested_level > 0:\n                nested_level -= 1\n            elif character == ')' and nested_level < 0:\n                nested_level += 1\n            found = True\n        else:\n            if character == '(':\n                nested_parens.append(nested_level)\n            elif character == ')':\n                nested_parens.append(nested_level - 1)\n            nested_level += 1\n            found = True\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting = 0\n    # handle simple case\n    if paren_string == \"()\":\n        return []\n    # handle escaped case\n    elif paren_string[0] == \"(\":\n        nesting += 1\n        return parse_nested_parens(paren_string[1:-1])\n    # handle multiple level case\n    else:\n        paren_string = paren_string.replace(\" \", \"\").replace(\"(\", \"\").replace(\")\", \"\")\n        parentheses = paren_string.split()\n        if len(parentheses) == 0:\n            return []\n        elif len(parentheses) == 1:\n            return [parentheses[0]]\n        else:\n            # input has multiple levels of nesting\n            for level in range(1, len(parentheses)):\n                # need to remove the nesting level from the previous level\n                parentheses[level] = \"(\" + parentheses[level - 1] + \")\"\n                # we have reached the deepest level\n                if level == len(parentheses) - 1:\n                    return [parentheses[0]]\n                # nesting level goes up\n                nesting += 1\n                # add the parentheses to the existing list\n                return parse_nested_parens(", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parsed = []\n    regex = re.compile('\\s+')\n    while True:\n        pos = regex.search(paren_string, 0)\n        if pos is None:\n            break\n        parsed.append(pos.end())\n    return parsed", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return list(paren_string.split())", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nested_parens = []\n\n    for parenthesis in paren_string.split():\n        if parenthesis[0] == '(':\n            nested_parens.append(parse_nested_parens(parenstring.split()))\n            break\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parentheses: List[int] = []\n    for char in paren_string:\n        if char in '(()':\n            parentheses:\n                parentheses:\n                    parentheses:\n                        parentheses:\n                            parentheses:\n                                parentheses:\n                                    parentheses:\n                                        parentheses:\n                                            parentheses:\n                                                parentheses:\n                                                    parentheses:\n                                                        parentheses:\n                                                            parentheses:\n                                                                parentheses:\n                                                                    parentheses:\n                                                                      parentheses:\n                                                                        parentheses:\n                                                                          parentheses:\n                                                                           parentheses:\n                                                                            parentheses:\n                                                                             parentheses:\n                                                                                parentheses:\n                                                                                 parentheses:\n                                                                                   parentheses:\n                                                                                      parentheses:\n                                                                                     parentheses:\n                                                                                      parentheses:\n                                                                                      parentheses:\n                                                                                        parentheses:\n                                                                                        parentheses:\n                                                                                            parentheses:\n                                                                                            parentheses:\n                                                                                              parentheses:\n                                                                                               parentheses:\n                                                                                                parentheses:\n                                                                                                parentheses:\n                                                                                              parentheses:\n                                                                                                 parentheses:\n                                                                                                 parentheses:\n                                                                                               parentheses:\n                                                                                              parentheses:\n                                                                                            parentheses:\n                                                                                            parentheses:\n                                                                                              parentheses:\n                                                                                                         parentheses:\n                                                                                                         parentheses:\n                                                                                                        parentheses:\n                                                                                                        parentheses:\n                                                                                                                         parentheses:\n                                                                                                                         parentheses:\n                                                                                                                         parentheses:\n                                                                                                                         parentheses:\n                                                                                                                         parentheses:\n                                                                                                                                   parentheses:\n                                                                                                                         parentheses:\n                                                                                                                         parentheses:\n                                                                                                                         parentheses:\n                                                                                                                         parentheses:\n                                                                                                                         parentheses:\n                                                                                                                         parentheses:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nested_parens = []\n    for nested_level in range(0, len(paren_string) - 1):\n        if paren_string[nested_level] == '(':\n            nested_parens.append(nested_level)\n        else:\n            nested_parens.append(max(nested_parens) + 1)\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    brackets: List[str] = []\n\n    level = 0\n    for c in paren_string:\n        if c == '(':\n            level += 1\n        elif c == ')':\n            level -= 1\n        elif level == 0:\n            brackets.append(c)\n\n    return brackets", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string =''.join(paren_string.split())\n    nested_group: List[int] = []\n    for i in range(len(paren_string)):\n        nested_group.append(int(paren_string[i]))\n        if (paren_string[i] == '('):\n            nested_group.append(0)\n        elif (paren_string[i] == ')'):\n            nested_group.pop()\n        elif (paren_string[i] == '('):\n            nested_group.pop()\n\n    return nested_group", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nested_parens: List[int] = []\n\n    cur_nested_paren = 0\n    for index, char in enumerate(paren_string):\n        if char == '(':\n            nested_parens.append(cur_nested_paren)\n            cur_nested_paren += 1\n        elif char == ')':\n            nested_parens.append(cur_nested_paren)\n            cur_nested_paren -= 1\n        elif cur_nested_paren == 0:\n            if char == ')':\n                nested_parens.append(cur_nested_paren)\n                cur_nested_paren = 0\n            elif char == '(':\n                nested_parens.append(cur_nested_paren)\n                cur_nested_paren = 1\n        else:\n            raise ValueError('Unrecognized character ({!r})'.format(char))\n\n    return nested_parens\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    n = 1\n    result = []\n    for i in range(0, len(paren_string)):\n        if paren_string[i] == '(':\n            result.append(n)\n        elif paren_string[i] == ')':\n            if not result[n - 1] == 0:\n                result.append(n)\n            n -= 1\n        else:\n            result.append(n)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting = 0\n    nested_paren_level = 0\n    nested_paren_string = paren_string.replace(' ', '')\n    nested_paren_string = nested_paren_string.replace('(', '').replace(')', '').replace(') ', '')\n    nested_paren_string = nested_paren_string.replace('(', '').replace(')', '').replace('(', '').replace(')', '')\n    nested_paren_string = nested_paren_string.replace('(', '').replace(')', '').replace('(', '').replace(')', '')\n    nested_paren_string = nested_paren_string.replace('(', '').replace(')', '').replace('(', '').replace(')', '')\n    nested_paren_string = nested_paren_string.replace('(', '').replace(')', '').replace('(', '').replace(')', '')\n    nested_paren_string = nested_paren_string.replace", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def match_group(group_string: str) -> List[int]:\n        \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n        Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n        For each of the group, output the deepest level of nesting of parentheses.\n        E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n        >>> match_group('(()()) ((())) () ((())()())')\n        [2, 3, 1, 3]\n        \"\"\"\n        if group_string:\n            if len(group_string) == 1:\n                yield None\n            elif len(group_string) == 2:\n                yield 0\n            else:\n                for i in range(0, len(group_string) - 1):\n                    yield 0 if group_string[i] == ')' else 1 if group_string[i] == '(' else 2 if group_string[i] == '(' and group_string[i + 1] == '(' else 3 if group_string[i] == '(' and group_string[i + 1] == '(' and group_string[i + 2] == ')' else 4 if group_string[i] == '(' and group_string[i + 1] == '(' and group_string[i +", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    return parse_nested_parens_with_regex(paren_string, '(\\\\s*)\\\\s*(\\\\s*)').values()", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_count: List[int] = []\n    try:\n        paren_string = paren_string.replace(' ', '')\n        if paren_string[0] == '(':\n            paren_string = paren_string[1:]\n            paren_count.append(1)\n        elif paren_string[0] == '(':\n            paren_count.append(2)\n        elif paren_string[0] == ')':\n            paren_count.append(1 + paren_count[-1])\n        elif paren_string[0] == ')':\n            paren_count.append(2 + paren_count[-1])\n    except IndexError:\n        return paren_count\n    return parse_nested_parens(paren_string)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_count: List[int] = []\n    paren_level: List[int] = []\n    stack: List[int] = [(0, 0)]\n\n    for char in paren_string:\n        if char == '(':\n            stack.append((0, 0))\n        elif char == ')':\n            stack.pop()\n        elif char =='':\n            if stack[0][0] == 0:\n                paren_level.append(stack[0][0] + 1)\n                paren_count.append(stack[0][1])\n                stack[0] = (0, 0)\n            else:\n                paren_level.append(stack[0][0])\n                stack[0] = (stack[0][0] + 1, stack[0][1] + 1)\n        else:\n            paren_level.append(stack[0][0])\n            stack[0] = (stack[0][0] + 1, stack[0][1] + 1)\n\n    return paren_level, paren_count\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    parsed_list = []\n    for level in range(len(paren_string) - 1):\n        if paren_string[level] == '(':\n            parsed_list.append(level)\n        elif paren_string[level] == ')':\n            parsed_list.pop()\n\n    return parsed_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens: List[int] = []\n    paren_string = paren_string.replace(\" \", \"\")\n    for i in xrange(1, len(paren_string), 2):\n        nested = int(paren_string[i - 1])\n        nested_parens.append(nested)\n        if nested == 1:\n            return nested_parens\n    raise ValueError(\"More than two levels of nested parentheses in the string\")", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    for group in paren_string.split():\n        if group[0] == '(':\n            nested_parens.append(int(group[1:-1]))\n        elif group[0] == ')':\n            nested_parens.pop()\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if not paren_string:\n        return []\n\n    paren_string = paren_string.strip()\n    # We don't want to parse the first group, but instead we use the string that we want to parse\n    groups = paren_string[1:].split()\n\n    groups = [g for g in groups if g!= '()']\n    groups.reverse()\n    # Start by grouping all groups and then pop the group that is the last group. We will use the\n    # popped group to determine the level of nesting of the parentheses\n    level = 0\n    for group in groups:\n        if group in ('(', ')'):\n            level += 1\n        elif group == ')':\n            level -= 1\n        elif group == '(':\n            level = max(level, 0)\n        elif group == ')':\n            level = min(level, 3)\n\n    return level\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [int(group) for group in paren_string.split() if group]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return re.findall(\"\\s*(\\()(*)\", paren_string)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    paren_groups = paren_string.split()\n    for i, group in enumerate(paren_groups):\n        group = group.split()\n        if len(group) == 2:\n            result.append(i)\n        else:\n            paren_level = parse_nested_parens(group[0])\n            if paren_level is not None:\n                result.extend(paren_level)\n                result.append(i)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting = [0]\n    for group in paren_string.split(' '):\n        if '(' in group:\n            nesting[0] += 1\n        if ')' in group:\n            nesting[0] -= 1\n        if nesting[0] < 0:\n            return None\n\n    return nesting", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # First split by spaces\n    result = []\n    for s in paren_string.split(' '):\n        if not s:\n            continue\n\n        if '(' not in s:\n            continue\n\n        cur_level = 0\n        for l in s:\n            if l == '(':\n                cur_level += 1\n            elif l == ')':\n                cur_level -= 1\n            elif cur_level == 0:\n                result.append(int(l))\n\n        result.append(cur_level)\n\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    paren_string = paren_string.strip()\n    for group in paren_string.split(\" \"):\n        if group.startswith(\"(\") and group.endswith(\")\"):\n            stack.append(group.count(\"(\") - 1)\n        elif group.startswith(\"(\") and group.endswith(\")\"):\n            stack.append(group.count(\"(\") - 1)\n    return stack", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def parse(char) -> int:\n        if char == '(':\n            return 1\n        elif char == ')':\n            return 2\n        else:\n            return 3\n\n    return [parse(char) for char in paren_string.split()]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return _parse_nested_parens(paren_string)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    res: List[int] = []\n    for char in paren_string:\n        if char == '(':\n            res.append(0)\n        elif char == ')':\n            res.append(res[-1] + 1)\n        else:\n            res.append(1)\n    return res", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting_parens = []\n    nesting_level = 0\n    in_parenthesis = False\n\n    for char in paren_string:\n        if char == '(':\n            nesting_parens.append(nesting_level)\n            in_parenthesis = True\n        elif char == ')':\n            if in_parenthesis:\n                nesting_parens.pop()\n                in_parenthesis = False\n\n        elif in_parenthesis and char =='':\n            nesting_level += 1\n            in_parenthesis = False\n\n        elif not in_parenthesis and char == '(':\n            nesting_level -= 1\n            in_parenthesis = True\n\n    nesting_level = max(nesting_level, 0)\n\n    return [nesting_level]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nested_parens = []\n\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            nested_parens.append(i + 1)\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested = []\n    for level in range(0, len(paren_string)):\n        if paren_string[level] == '(':\n            nested.append(level)\n            continue\n        elif paren_string[level] == ')':\n            nested.append(nested[-2] + 1)\n        else:\n            break\n    return nested", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups: List[List[int]] = []\n    open_parens = []\n    num_open_parens = 0\n\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            num_open_parens += 1\n            open_parens.append(num_open_parens)\n        elif c == ')':\n            num_open_parens -= 1\n            open_parens.pop(0)\n\n    if num_open_parens > 0:\n        return []\n\n    for open_level in open_parens:\n        if num_open_parens < open_level:\n            return [open_level]\n\n    if num_open_parens == 0:\n        groups.append([])\n\n    for level in range(open_level + 1):\n        groups[level].append(0)\n\n    num_open_parens = 0\n\n    for i, c in enumerate(paren_string):\n        if c == '(':\n            num_open_parens += 1\n            groups[open_level - 1].append(num_open_parens)\n        elif c == ')':\n            num_open_parens -= 1\n            groups[open_level - 1].pop(0)\n\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups: List[int] = []\n    current_level = 0\n    for n in paren_string:\n        if n == '(':\n            current_level += 1\n        elif n == ')':\n            current_level -= 1\n        if current_level == 0:\n            groups.append(current_level)\n        elif current_level < 0:\n            groups.append(current_level)\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for sublist in paren_string.split(' '):\n        if sublist.startswith('('):\n            result.append(int(sublist[1:]))\n        elif sublist.startswith(')'):\n            result.append(int(sublist[1:]))\n        elif sublist.startswith(')'):\n            result.append(int(sublist[1:]))\n        else:\n            result.append(int(sublist))\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for paren in paren_string.split():\n        if len(paren) == 0:\n            continue\n        if paren[0] == '(':\n            result.append(1)\n        else:\n            result.append(len(result) - 1)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    match_string = '(' + paren_string + ')'\n\n    result = []\n    pattern = r'(' + match_string + r')'\n    return_replacement = r')'\n    re.sub(pattern, return_replacement, paren_string)\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.strip()\n    paren_string = paren_string.replace('(', '(')\n    paren_string = paren_string.replace(')', ')')\n    paren_string = paren_string.replace('(', '(')\n    paren_string = paren_string.replace(')', ')')\n    paren_string = paren_string.replace(')', ')')\n    paren_string = paren_string.replace('(', '(')\n    paren_string = paren_string.replace(')', ')')\n    paren_string = paren_string.replace(')', ')')\n    paren_string = paren_string.replace('(', '(')\n    paren_string = paren_string.replace(')', ')')\n    paren_string = paren_string.replace('(', '(')\n    paren_string = paren_string.replace(')', ')')\n    paren_string = paren_string.replace('(', '(')\n    paren_string = paren_string.replace('", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nesting = []\n    for group in paren_string.split(' '):\n        nesting.append(group[0].isupper() and int(group) - 1 or group)\n    return nesting", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_list = []\n    nest_level = 0\n    for char in paren_string:\n        if char == '(':\n            nest_level += 1\n        if char == ')':\n            nest_level -= 1\n        if nest_level == 0:\n            paren_list.append(int(char))\n    return paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting_level = 0\n    groups = list(paren_string.split(' '))\n    for group in groups:\n        if group.strip() == '()':\n            nesting_level += 1\n        elif group.strip() == ')':\n            nesting_level -= 1\n        else:\n            nesting_level = max(nesting_level, int(group.strip()))\n    return nesting_level\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return parse_nested_parens2(paren_string, [], [])", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    # this is a helper method to make parsing easier\n    def parse(paren_string: str) -> List[int]:\n        return [int(x) for x in paren_string.split(\" \") if x.isdigit()]\n\n    return parse(paren_string)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n\n    parenthesis = paren_string.split(' ')\n\n    # First find the nested parentheses in the first group\n    # For example: ((()()))\n    for parenthesis_group in parenthesis:\n        # For the parenthesis group, the parenthesis is not the only one\n        nested_group = parenthesis_group.split(')')\n        # Now try to find the nested parentheses in this parenthesis group\n        for nested_string in nested_group:\n            # For the nested parenthesis, it must be preceded by parenthesis\n            # For example: (())\n            if nested_string.startswith('(') and nested_string.endswith(')'):\n                # Check if there is any other parenthesis in this group\n                if nested_string!= parenthesis_group:\n                    nested_string = nested_string.split('(')\n                    # Now try to find the nested parentheses in this parenthesis group\n                    for nested_string2 in nested_string:\n                        # If this parenthesis is not the only one\n                        if nested_string2!= nested_string[0]:\n                            nested_parens.append(parse_nested_parens(nested_string2))\n\n    # Now return the result\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # TODO: simplify - remove whitespaces and shift the brackets to the start of the group\n    return [\n        int(i) - 1\n        for i in paren_string.split(' ')\n        if i.strip()\n    ]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    for c in paren_string:\n        if c == '(':\n            nested_parens.append(0)\n        elif c == ')':\n            nested_parens.append(len(nested_parens) - 1)\n        else:\n            nested_parens.append(1)\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    max_level = 0\n    for token in paren_string.split():\n        if token in (\"(\", \")\", \"[\", \"]\", \"{\", \"}\"):\n            if len(stack) == 0:\n                if token == \"(\":\n                    stack.append(0)\n                elif token == \")\":\n                    stack.pop()\n                elif token == \"{\":\n                    stack.append(0)\n                elif token == \"}\":\n                    stack.pop()\n                elif token == \"[\":\n                    stack.append(0)\n                elif token == \"]\":\n                    stack.pop()\n                elif token == \"(\":\n                    stack.append(1)\n                elif token == \")\":\n                    stack.pop()\n                elif token == \"{\":\n                    stack.append(1)\n                elif token == \"}\":\n                    stack.pop()\n                elif token == \"[\":\n                    stack.append(1)\n                elif token == \"]\":\n                    stack.pop()\n                elif token in (\"(\", \")\", \"[\", \"]\", \"{\", \"}\"):\n                    continue\n                else:\n                    raise ValueError(\"Invalid token in paren string {}\".format(paren_string))\n        elif token == \"(\":\n            stack.append(0)\n        elif", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = []\n    paren_level = 0\n    while True:\n        char = paren_string.index('(', paren_level) + 1\n        char1 = char + 1\n        while char1 < len(paren_string) and paren_string[char1] == '(':\n            paren_level += 1\n            char1 += 1\n        if char1 == len(paren_string):\n            if paren_string[char] == ')':\n                break\n            else:\n                raise ValueError(\"Invalid nesting\")\n        stack.append(paren_level)\n        char = paren_string.index('(', paren_level) + 1\n        char1 = char + 1\n        while char1 < len(paren_string) and paren_string[char1] == '(':\n            paren_level += 1\n            char1 += 1\n        if char1 == len(paren_string):\n            if paren_string[char] == ')':\n                break\n            else:\n                raise ValueError(\"Invalid nesting\")\n        if paren_level == 0:\n            if paren_string[char] == ')':\n                break\n            else:\n                raise ValueError(\"Invalid nesting\")\n        if paren_level == stack[-1]:\n            break\n        if char1 ==", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = [int(x) for x in paren_string.split(' ')]\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n\n    # parse the string and break it in lines\n    for line in paren_string.split('\\n'):\n        # split each line in groups of parentheses and store them in nested list\n        # the first line is considered a single group\n        paren_group = line.split()\n\n        # collect nested parentheses and check the depth\n        for i in range(len(paren_group)):\n            if paren_group[i][0] == '(':\n                nested_parens.append(i)\n            elif paren_group[i][0] == ')':\n                nested_parens.pop()\n            elif paren_group[i][0] == '(':\n                if paren_group[i][-1] == ')':\n                    nested_parens.pop()\n                else:\n                    nested_parens.pop()\n                    nested_parens.append(i - 1)\n            elif paren_group[i][0] == ')':\n                if paren_group[i][-1] == '(':\n                    nested_parens.pop()\n                else:\n                    nested_parens.pop()\n                    nested_parens.append(i - 1)\n\n    # return the deepest level of nesting\n    return nested_parens\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens: List[int] = []\n\n    # We ignore the spaces here because we want to keep a uniform and general approach.\n    for char in paren_string.split():\n        if char == '(':\n            nested_parens.append(1)\n        elif char == ')':\n            nested_parens.append(-1)\n        elif char == '(':\n            nested_parens.append(1)\n        elif char == ')':\n            nested_parens.append(-1)\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_paren_levels = [int(x) for x in paren_string.split()]\n    return list(filter(lambda x: x > 0, nested_paren_levels))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return parse_nested_parens_nested(paren_string, 0)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_groups = list(paren_string.split())\n    nested_group_count = 0\n    nested_group = [parens]\n    while nested_group_count < len(nested_groups):\n        nested_group_count += 1\n        nested_group.append([parens])\n        for parens in nested_group[-nested_group_count - 1]:\n            if parens == '{':\n                nested_group[-1].append(1)\n                continue\n            for c in parens:\n                if c == '{':\n                    nested_group[-1].append(1)\n                    continue\n                elif c == '(':\n                    nested_group[-1].append(1)\n                    continue\n                elif c == ')':\n                    nested_group.pop()\n                    continue\n                else:\n                    nested_group[-1].append(c)\n        nested_group.pop()\n    return nested_group", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    parens = paren_string.split()\n    for paren in parens:\n        if paren[0] == '(':\n            result.append(int(paren[1:]))\n            result.append(result[-1])\n        elif paren[0] == ')':\n            result[-1] = result[-2]\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_paren_string: List[str] = []\n    for paren_string in paren_string.split(' '):\n        if paren_string.startswith('('):\n            nested_paren_string.append(int(paren_string[1:]))\n        else:\n            nested_paren_string.append(1)\n    return nested_paren_string", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack: List[int] = []\n    stack.append(0)\n    start = 0\n    while True:\n        if paren_string[start] == '(':\n            stack.append(0)\n        elif paren_string[start] == ')':\n            if stack[0]:\n                stack.pop()\n        else:\n            return stack\n        start += 1\n\n    return stack", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_level: List[int] = []\n    for i, char in enumerate(paren_string):\n        if char == '(':\n            paren_level.append(i)\n            continue\n        elif char == ')':\n            if len(paren_level) == 0:\n                raise ValueError(\"Invalid input string\")\n            else:\n                paren_level.pop()\n        else:\n            raise ValueError(\"Invalid input string\")\n\n    return paren_level", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nested = []\n    nested_count = 0\n    nested_levels = 0\n\n    for i in range(0, len(paren_string)):\n        if paren_string[i] == ')':\n            nested.append(nested_count)\n            nested_levels += 1\n            nested_count = 0\n        elif paren_string[i] == '(':\n            nested_count += 1\n        elif paren_string[i] == ')':\n            if nested_levels == 0:\n                return nested\n\n    return nested", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Parsing the string of parenthesis\n    parenthesis = paren_string.split(' ')\n\n    # Parsing the string of parenthesis\n    parenthesis = parenthesis[0]\n\n    parenthesis = parenthesis.split(')')\n\n    parenthesis = parenthesis[0]\n\n    parenthesis = parenthesis.split(')')\n\n    parenthesis = parenthesis[0]\n\n    parenthesis = parenthesis.split(')')\n\n    parenthesis = parenthesis[0]\n\n    parenthesis = parenthesis.split(')')\n\n    parenthesis = parenthesis[0]\n\n    parenthesis = parenthesis.split(')')\n\n    parenthesis = parenthesis[0]\n\n    parenthesis = parenthesis.split(')')\n\n    parenthesis = parenthesis[0]\n\n    parenthesis = parenthesis.split(')')\n\n    parenthesis = parenthesis[0]\n\n    parenthesis = parenthesis.split(')')\n\n    parenthesis = parenthesis[0]\n\n    parenthesis = parenthesis.split(')')\n\n    parenthesis = parenthesis[0]\n\n    parenthesis = parenthesis.split(')')\n\n    parenthesis = parenthesis[0]\n\n    parenthesis = parenthesis.split(')')\n\n    parenthesis = parenthesis[0]\n\n    parenthesis = parenthesis.split('", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parentheses = list()\n    for group in paren_string.split(' '):\n        if group.startswith('('):\n            nested_parentheses.append(0)\n        if group.endswith(')'):\n            nested_parentheses.append(0)\n        else:\n            nested_parentheses.append(parse_nested_parens(group))\n    return nested_parentheses", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = []\n    for paren_string in paren_string.split():\n        groups.append(parse_nested_parens(paren_string))\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def group_nesting(group_string: str) -> int:\n        group_string = group_string.lower()\n        group_string = group_string.strip('()')\n        group_string = group_string.split(' ')\n        for index, group_string_item in enumerate(group_string):\n            if group_string_item.startswith('('):\n                group_string[index] = '('\n            elif group_string_item.startswith(')'):\n                group_string[index] = ')'\n        if group_string.count('(') > group_string.count(')'):\n            return 1\n        else:\n            return group_string.count(')') + 1\n\n    groups = group_nesting(paren_string)\n    for group in groups:\n        if group < 0:\n            groups.remove(group)\n            continue\n        groups.append(group)\n\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_level = 0\n\n    for i in range(len(paren_string) - 1):\n        nested_level += 1 if paren_string[i] == '(' else nested_level - 1\n        nested_level -= 1 if paren_string[i + 1] == ')' else nested_level\n\n    return nested_level", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    stack = [(0,) * 4 + ()]\n    nesting_level = 0\n    for c in paren_string:\n        if c == '(':\n            stack.append(tuple(map(int, stack[-1] + [nesting_level])))\n        elif c == ')':\n            stack.pop()\n            nesting_level -= 1\n        elif c == '(':\n            nesting_level += 1\n        elif c == ')':\n            nesting_level -= 1\n        else:\n            raise ValueError('Input is not a valid string for nested parentheses.')\n    return stack", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n    for group in paren_string.split():\n        group_count = 0\n        while group_count < len(group):\n            if group[group_count] == '(':\n                group_count += 1\n                result.append(group_count)\n            elif group[group_count] == ')':\n                group_count += 1\n                result.append(group_count)\n            else:\n                break\n        else:\n            break\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    groups = []\n    stack = [(0, [])]\n    for char in paren_string:\n        if char == '(':\n            stack.append((0, []))\n        elif char == ')':\n            if len(stack) > 0:\n                stack.pop()\n        elif char in ')[]{}':\n            if len(stack) > 0:\n                stack.pop()\n        elif char =='':\n            if stack[0][0] == 0:\n                stack.append((1, []))\n            else:\n                stack[0][1].append(stack[0][0])\n        elif char == '(':\n            stack[0][0] += 1\n        else:\n            if stack[0][0] == 0:\n                stack.append((1, []))\n            else:\n                stack[0][1].append(stack[0][0])\n        groups.append(stack[0][0])\n\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    if paren_string == '()':\n        return [0, 0]\n\n    paren_count = 0\n    unmatched = 0\n    nested_parens = []\n    current_parenthesis = []\n\n    # find the first non-space character and count them. Start with 1.\n    for char in paren_string:\n        if char!='':\n            paren_count += 1\n\n    # for each character found up to the last space, we need to figure out how many times\n    # it was used to group parentheses. If it was used more than once, we need to figure out\n    # which one it was used for.\n    for char in paren_string:\n        # we also need to stop counting when we found a space.\n        if char =='':\n            break\n\n        if char in '([{}]+)':\n            if char in current_parenthesis:\n                unmatched += 1\n                current_parenthesis.remove(char)\n\n            if char not in nested_parens:\n                nested_parens.append(char)\n            else:\n                nested_parens.append(nested_parens[-1] + 1)\n            current_parenthesis.append(char)\n\n        elif char in '()':\n            if char not in current_parenthesis:\n                unmatched += 1\n                current_parent", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def parse_group(group_string: str) -> List[int]:\n        \"\"\" Parse a group of nested parentheses\n\n        Input: group_string = group of parentheses separated by space\n\n        Output: the level of nesting of the group\n\n        E.g.: \"(\"\n        \"\"\"\n        nested_level = 0\n        while group_string:\n            if group_string[0] == '(' and group_string[-1] == ')':\n                nested_level += 1\n            elif group_string[0] == '(' and group_string[-1] == ')' and group_string[1] == '(':\n                nested_level += 2\n            elif group_string[0] == '(' and group_string[-1] == ')' and group_string[1] == '(':\n                nested_level += 3\n            else:\n                break\n\n            group_string = group_string[1:]\n\n        return nested_level\n\n    return [parse_group(group_string) for group_string in paren_string.split(' ')]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    result = []\n\n    for group_string in paren_string.split(' '):\n        group_string = group_string.strip()\n        for level in range(0, len(group_string) + 1):\n            group_string = group_string.split(')')\n            if len(group_string) == level + 1:\n                result.append(int(group_string[-1].strip()))\n\n    return result\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    def groups:\n        groups = []\n        while True:\n            char = paren_string.pop(0)\n            if char == '(':\n                groups.append(0)\n            elif char == ')':\n                groups.append(len(groups))\n            else:\n                break\n        return groups\n\n    return [group for group in groups for level in parse_nested_parens(paren_string)[group]]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens: List[int] = []\n    nested_parens.append(0)\n    nested_parens.append(0)\n    nested_parens.append(0)\n    nested_parens.append(0)\n\n    n = 0\n    while n < len(paren_string):\n        if paren_string[n] == '(':\n            nested_parens[n] += 1\n        elif paren_string[n] == ')':\n            nested_parens[n] -= 1\n        elif paren_string[n] == '(':\n            nested_parens[n] += 1\n        elif paren_string[n] == ')':\n            nested_parens[n] -= 1\n        elif paren_string[n] == ')':\n            nested_parens[n] += 1\n        elif paren_string[n] == '(':\n            nested_parens[n] -= 1\n        elif paren_string[n] == ')':\n            nested_parens[n] += 1\n\n        n += 1\n    nested_parens.append(len(paren_string))\n\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_list = []\n    nested_level = 0\n    for index, group in enumerate(paren_string.split()):\n        if group.startswith('('):\n            nested_level += 1\n        elif group.startswith(')') and nested_level > 0:\n            nested_level -= 1\n        nested_list.append(nested_level)\n    return nested_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_stack = [('', '')]\n\n    if paren_string[0] == '(':\n        paren_stack.append(('(', '('))\n        paren_stack.append((')', ')'))\n    elif paren_string[0] == ')':\n        paren_stack.append(('(', ')'))\n        paren_stack.append((')', '('))\n\n    nested_level = 0\n    while paren_string:\n        current_parenthesis = paren_stack[-1][1]\n\n        if paren_string[0] == '(':\n            if paren_stack[-1][2] == current_parenthesis:\n                nested_level += 1\n            else:\n                paren_stack.append(('(', current_parenthesis))\n                nested_level += 1\n        elif paren_string[0] == ')':\n            if paren_stack[-1][2] == current_parenthesis:\n                nested_level -= 1\n            else:\n                paren_stack.append((current_parenthesis, ')'))\n                nested_level -= 1\n\n        if paren_stack[-1][1]!= '(':\n            break\n\n        paren_string = paren_string[1:]\n\n    return [int(item[0]) for item in paren_stack]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    depth = 0\n    paren_list = [paren_string]\n    while paren_list:\n        current_depth = depth\n        for token in paren_list:\n            if token == '(':\n                depth += 1\n            elif token == ')':\n                depth -= 1\n            elif token =='':\n                # We have a space within a group\n                if depth == 0:\n                    # If we are at the top level, store it.\n                    paren_list.append(token)\n                elif depth == current_depth:\n                    # Recursively store it.\n                    paren_list += parse_nested_parens(token)\n                else:\n                    # This means we are in a group with more than one level of nesting\n                    paren_list.append(')')\n                # Reset the depth.\n                depth = 0\n    return paren_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_count = 0\n    nested_parens = []\n    for group in paren_string.split():\n        if group.isdigit():\n            paren_count += int(group)\n        elif group.startswith(\"(\") or group.startswith(\"([\"):\n            nested_parens.append(paren_count)\n        elif group.startswith(\")\") or group.startswith(\")[\"):\n            nested_parens.pop()\n        elif group.startswith(\"(\"):\n            paren_count += 1\n\n    nested_parens.reverse()\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # TODO Refactor this to use recursion\n    nested_parens = []\n    for char in paren_string:\n        if char == '(':\n            nested_parens.append(0)\n        elif char == ')':\n            nested_parens.append(0)\n        else:\n            nested_parens.append(1)\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split(' ')\n    nested_groups = [int(g) for g in groups if g.isdigit()]\n    return nested_groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = paren_string.split(' ')\n    result = []\n    for group in groups:\n        result.append(len(parse_nested_parens(group)))\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups = []\n    current_level = 0\n    paren = None\n    for char in paren_string:\n        if char == ')':\n            groups.append(current_level)\n            current_level = 0\n        elif char == '(':\n            current_level += 1\n        elif char =='':\n            if current_level == 0:\n                groups.append(current_level)\n                current_level = 0\n        elif char == ')':\n            current_level -= 1\n        elif char == ')':\n            groups.append(current_level)\n            current_level = 0\n        elif char == '(':\n            current_level += 1\n        elif char == '(':\n            current_level += 1\n        else:\n            groups.append(current_level)\n            current_level = 0\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    depth = 0\n    groups = paren_string.split(' ')\n    for group in groups:\n        if group == ')':\n            depth += 1\n            nested_parens.append(depth)\n        elif group == '(':\n            depth -= 1\n            if depth < 0:\n                nested_parens.append(depth)\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    nested_list: List[int] = []\n\n    for parenthesis_string in paren_string.split(' '):\n\n        parenthesis_string = parenthesis_string.strip()\n\n        parenthesis = parenthesis_string.split('(')\n\n        if parenthesis[0] == parenthesis_string:\n\n            parenthesis = parenthesis[1:]\n\n            if parenthesis[0] == parenthesis_string:\n\n                parenthesis = parenthesis[1:]\n\n                # `nested_list` is a list of the level of nesting\n                # `nested_list` is a list of the level of nesting\n                # `nested_list` is a list of the level of nesting\n                nested_list.append(len(nested_list))\n\n                nested_list.append(len(nested_list) + 1)\n\n    return nested_list\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [int(c) for c in paren_string.split()]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    paren_string = paren_string.lower()\n    start_index = 0\n    level = 1\n    while True:\n        end_index = paren_string.find(')', start_index)\n        if end_index == -1:\n            break\n        nesting_level = len(paren_string[start_index:end_index]) - 1\n        if nesting_level > level:\n            level = nesting_level\n        start_index = end_index + 1\n    return level + 1", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    match = re.match(r'^[(]*([^)]*)[)]$', paren_string)\n    if match is not None:\n        return [int(x) for x in match.groups()]\n    return [int(x) for x in paren_string.split(' ')]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups_list = []\n    current_level = 0\n    for char in paren_string:\n        if char == '(':\n            groups_list.append(current_level)\n        elif char == ')':\n            current_level = groups_list[-1][-1] + 1\n        else:\n            groups_list.append(current_level)\n    return groups_list", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # Start parsing at the start of the string and build the groups\n    groups = [paren_string]\n    while True:\n        # Get the next string in the group\n        group_string = groups[-1]\n        # Examine the string to see if it is an opening paren\n        if group_string[0] == '(':\n            groups[-1] = group_string[1:]\n            continue\n        # If the next string is a closing paren, the group is finished\n        if group_string[-1] == ')':\n            break\n        # If there are no more opening or closing parentheses, the group is finished\n        if group_string == '':\n            break\n        # Get the next group in the string and append to the current group\n        groups.append(group_string)\n    # If there are any unmatched closing parentheses, return the first level of nesting\n    if groups[-1][-1] == ')':\n        return [groups[0][0], 0] + list(filter(bool, groups))\n    # Return the group stack\n    return groups\n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    groups = [('', 0)]  # Lists that store the open and close parentheses\n\n    def is_in_parenthesis(word: str) -> bool:\n        return (not word or word[0] in '(')\n\n    def is_nested_parens(word: str) -> bool:\n        return is_in_parenthesis(word) and len(word) > 1\n\n    def is_first_nested_parens(word: str) -> bool:\n        return not is_in_parenthesis(word) and len(word) > 2\n\n    def is_last_nested_parens(word: str) -> bool:\n        return not is_in_parenthesis(word) and len(word) > 1\n\n    def get_parens_level(word: str) -> int:\n        if not is_in_parenthesis(word):\n            return 0\n        return 1 if is_nested_parens(word) else 2 if is_first_nested_parens(word) else 3 if is_last_nested_parens(word) else 0\n\n    def append_group(word: str, level: int) -> List[int]:\n        word_with_level = '(' + word + ')'\n        if is", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_parens = []\n    current_level = 0\n    for group in paren_string.split():\n        nested_parens.append(int(group))\n        if current_level > 0:\n            nested_parens.append(current_level)\n        if group == ')':\n            current_level -= 1\n    return nested_parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return list(map(int, paren_string.split(' ')))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [int(x) for x in paren_string.split() if x!= '()']", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nesting = 0\n    brackets = []\n    paren_string = paren_string.rstrip()\n    brackets.append(0)\n    for c in paren_string:\n        if c == '(':\n            brackets[0] += 1\n        elif c == ')':\n            brackets[0] -= 1\n        elif c == '(':\n            nesting += 1\n        elif c == ')':\n            nesting -= 1\n        elif c =='':\n            break\n        elif c == '(':\n            brackets.append(nesting)\n        elif c == ')':\n            brackets.pop()\n    result = []\n    for i in range(brackets.pop(0)):\n        result.append(i)\n    result.reverse()\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    # The second column is the level of nesting of parentheses.\n    result = [0] * len(paren_string)\n    stack = [(paren_string, 0)]\n    while stack:\n        cur = stack.pop()\n        level = len(cur[1])\n        while level:\n            cur = stack.pop()\n            level -= 1\n        result[cur[0]] += level\n    return result", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    nested_paren_levels = [int(x) for x in paren_string.split() if x.isdigit()]\n    if not nested_paren_levels:\n        return [None]\n    return nested_paren_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    groups_by_level = {}\n\n    def walk(string: str) -> List[int]:\n        level = 0\n        groups_by_level[level] = []\n        for char in string:\n            if char == '(':\n                level += 1\n                groups_by_level[level].append(level)\n            elif char == ')':\n                level -= 1\n                groups_by_level[level].append(level)\n            else:\n                groups_by_level[level].append(level)\n\n        return groups_by_level\n\n    walk(paren_string)\n    return groups_by_level", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n\n    result = []\n    seen = set()\n    nested = set()\n    nested_count = 0\n\n    # handle the first group\n    for char in paren_string:\n        if char == '(':\n            nested.add(seen)\n\n        elif char == ')':\n            nested.discard(seen)\n\n        seen.add(char)\n\n        result.append(nested)\n\n        # handle the next group\n        for char in paren_string:\n            if char == '(':\n                nested.add(seen)\n            elif char == ')':\n                nested.discard(seen)\n            elif char == ')':\n                nested.discard(seen)\n\n            seen.add(char)\n\n    for nested in nested_set:\n        result.append(nested_count + nested)\n\n    return result"]]