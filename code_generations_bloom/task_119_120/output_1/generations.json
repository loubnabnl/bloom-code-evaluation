[["def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0]!= '(':\n        return match_parens(lst[1:])\n    if lst[0][-1]!= ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(':\n        if lst[1] == ')':\n            return match_parens(lst[2:])\n        return match_parens(lst[1:])\n    if lst[0] == ')':\n        if lst[1] == '(':\n            return match_parens(lst[1:])\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        if lst[1] == '(' or lst[1] == ')':\n            return match_parens(lst[2:])\n        else:\n            return match_parens(lst[1:])\n    else:\n        if lst[1] == '(' or lst[1] == ')':\n            return match_parens(lst[1:])\n        else:\n            return match_parens(lst[2:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        elif lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    return match_parens(lst[1:])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[:1] + lst[2:])\n    return match_parens(lst[:1] + ['(', ')'] + lst[1:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    if lst[0][-2]!= lst[1][0]:\n        return 'No'\n    if lst[0][-3]!= lst[1][0]:\n        return 'No'\n    if lst[0][-4]!= lst[1][0]:\n        return 'No'\n    if lst[0][-5]!= lst[1][0]:\n        return 'No'\n    if lst[0][-6]!= lst[1][0]:\n        return 'No'\n    if lst[0][-7]!= lst[1][0]:\n        return 'No'\n    if lst[0][-8]!= lst[1][0]:\n        return 'No'\n    if lst[0][-9]!= lst[1][0]:\n        return 'No'\n    if lst[0][-10]!= lst[1][0]:\n        return 'No'\n    if lst[0][-11]!", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if len(lst) == 3:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(' and lst[2] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == ')' and lst[2] == ')", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[:1])\n    return match_parens([lst[0], lst[1]]) or match_parens([lst[1], lst[0]])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[:1])\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[2:])\n    return match_parens(lst[1:] + lst[:1])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[1][-1] == ')' and lst[0][0] == '(':\n        return match_parens(lst[:1])\n    if lst[0][-1] == ')' and lst[1][-1] == ')':\n        return match_parens(lst[1:])\n    if lst[1][-1] == ')' and lst[0][-1] == ')':\n        return match_parens(lst[:1])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1] == ')':\n        return match_parens(lst[1:])\n    if lst[1][0] == '(':\n        return match_parens(lst[2:])\n    return match_parens(lst[2:]) or match_parens(lst[1:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(':\n        return match_parens(lst[1:]) + '('\n    if lst[0] == ')':\n        return '(' + match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 3:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 4:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')' and lst[3] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 5:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')' and lst[3] == ')' and lst[4] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 6:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')' and lst[3] == ')' and lst[4] == ')' and lst[5] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == '(' or lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == ')' or lst[1] == ')':\n        return match_parens(lst[:-1])\n    return match_parens(lst[1:] + lst[:-1])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    if lst[0][-2]!= lst[1][0]:\n        return 'No'\n    if lst[0][-3]!= lst[1][0]:\n        return 'No'\n    if lst[0][-4]!= lst[1][0]:\n        return 'No'\n    if lst[0][-5]!= lst[1][0]:\n        return 'No'\n    if lst[0][-6]!= lst[1][0]:\n        return 'No'\n    if lst[0][-7]!= lst[1][0]:\n        return 'No'\n    if lst[0][-8]!= lst[1][0]:\n        return 'No'\n    if lst[0][-9]!= lst[1][0]:\n        return 'No'\n    if lst[0][-10]!= lst[1][0]:\n        return 'No'\n    if lst[0][-11]!", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if len(lst) == 3:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(' and lst[2] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == ')' and lst[2] == ')':\n            return 'Yes'\n        return 'No'\n    if len(lst) == 4:\n        if lst[0] == '(' and", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' or lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == ')' or lst[1] == ')':\n        return match_parens(lst[:-1])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 3:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 4:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')' and lst[3] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 5:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')' and lst[3] == ')' and lst[4] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 6:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')' and lst[3] == ')' and lst[4] == ')' and lst[5] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    return match_parens(lst[1:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:]) + '(' + match_parens(lst[1:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:]) + ')' + match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    if lst[0][-2]!= lst[1][0]:\n        return 'No'\n    if lst[0][-3]!= lst[1][0]:\n        return 'No'\n    if lst[0][-4]!= lst[1][0]:\n        return 'No'\n    if lst[0][-5]!= lst[1][0]:\n        return 'No'\n    if lst[0][-6]!= lst[1][0]:\n        return 'No'\n    if lst[0][-7]!= lst[1][0]:\n        return 'No'\n    if lst[0][-8]!= lst[1][0]:\n        return 'No'\n    if lst[0][-9]!= lst[1][0]:\n        return 'No'\n    if lst[0][-10]!= lst[1][0]:\n        return 'No'\n    if lst[0][-11]!", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1]!= ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1]!= ')' and lst[1][0]!= '(':\n        return 'Yes'\n    return match_parens(lst[1:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    if lst[0][-2]!= lst[1][-1]:\n        return 'No'\n    if lst[0][-3]!= lst[1][-2]:\n        return 'No'\n    if lst[0][-4]!= lst[1][-3]:\n        return 'No'\n    if lst[0][-5]!= lst[1][-4]:\n        return 'No'\n    if lst[0][-6]!= lst[1][-5]:\n        return 'No'\n    if lst[0][-7]!= lst[1][-6]:\n        return 'No'\n    if lst[0][-8]!= lst[1][-7]:\n        return 'No'\n    if lst[0][-9]!= lst[1][-8]:\n        return 'No'\n    if lst[0][-10]!= lst[1][-9]:\n        return 'No", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    if lst[0][-2]!= lst[1][0]:\n        return 'No'\n    if lst[0][-3]!= lst[1][0]:\n        return 'No'\n    if lst[0][-4]!= lst[1][0]:\n        return 'No'\n    if lst[0][-5]!= lst[1][0]:\n        return 'No'\n    if lst[0][-6]!= lst[1][0]:\n        return 'No'\n    if lst[0][-7]!= lst[1][0]:\n        return 'No'\n    if lst[0][-8]!= lst[1][0]:\n        return 'No'\n    if lst[0][-9]!= lst[1][0]:\n        return 'No'\n    if lst[0][-10]!= lst[1][0]:\n        return 'No'\n    if lst[0][-11]!", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(':\n        return match_parens(lst[1:] + [')'])\n    if lst[0] == ')':\n        return match_parens(lst[1:] + ['('])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0] == '(':\n        if lst[1] == ')':\n            return 'Yes'\n        else:\n            return match_parens(lst[1:])\n    if lst[1] == '(':\n        if lst[0] == ')':\n            return 'Yes'\n        else:\n            return match_parens(lst[2:])\n    return match_parens(lst[1:])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[:1] + lst[2:])\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][-1] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][-1] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][-1] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if len(stack) == 0:\n                    return False\n                else:\n                    stack.pop()\n        return len(stack) == 0\n\n    if len(lst) == 0:\n        return True\n    if len(lst) == 1:\n        return is_balanced(lst[0])\n    if is_balanced(lst[0]) and is_balanced(lst[1]):\n        return match_parens(lst[0] + lst[1])\n    return False", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[0] == lst[1]:\n        return match_parens(lst[2:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' or lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == ')' or lst[1] == ')':\n        return match_parens(lst[:-1])\n    return match_parens(lst[1:]) + match_parens(lst[:-1])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return match_parens(lst[1:])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][-1] == '(':\n        return match_parens(lst[:1] + lst[1:])\n    if lst[0][-1] == '(' and lst[1][-1] == ')':\n        return match_parens(lst[:1] + lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return match_parens(lst[1:] + lst[:1])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][-1] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][-1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        elif lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[:1] + lst[2:])\n    return match_parens(lst[:1] + lst[2:] + lst[3:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    return match_parens(lst[1:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    return match_parens(lst[1:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return match_parens(lst[1:])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    return match_parens(lst[1:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if len(lst) == 3:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 4:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(' and lst[3] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 5:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(' and lst[3] == ')' and lst[4] == '(':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 6:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(' and lst[3] == ')' and lst[4] == '(' and lst[5] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 7:\n        if lst[0] == '(' and lst[1] == ')' and lst", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        elif lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[:1] + lst[2:])\n    return match_parens(lst[:1] + lst[2:] + lst[3:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if len(lst[0]) == 1 or len(lst[1]) == 1:\n        return match_parens(lst[0] + lst[1].replace('(', '') + lst[0].replace(')', ''))\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[0] + lst[1].replace('(', '') + lst[0].replace(')', ''))\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[0].replace('(', '') + lst[1] + lst[0].replace(')', ''))\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[0].replace('(', '') + lst[1] + lst[0].replace(')', ''))\n    if lst[0][-1] == ')' and lst[1][0] == '(", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:]) + ')'\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:]) + '('\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[:1] + lst[2:])\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    return match_parens(lst[1:])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    if lst[0][-2]!= lst[1][0]:\n        return 'No'\n    if lst[0][-3]!= lst[1][0]:\n        return 'No'\n    if lst[0][-4]!= lst[1][0]:\n        return 'No'\n    if lst[0][-5]!= lst[1][0]:\n        return 'No'\n    if lst[0][-6]!= lst[1][0]:\n        return 'No'\n    if lst[0][-7]!= lst[1][0]:\n        return 'No'\n    if lst[0][-8]!= lst[1][0]:\n        return 'No'\n    if lst[0][-9]!= lst[1][0]:\n        return 'No'\n    if lst[0][-10]!= lst[1][0]:\n        return 'No'\n    if lst[0][-11]!", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        elif lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 3:\n        if lst[0] == '(' and lst[1] == '(' and lst[2] == ')':\n            return 'Yes'\n        elif lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        elif lst[0] == ')' and lst[1] == '(' and lst[2] == ')':\n            return 'Yes'\n        elif lst[0] == ')' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 4:\n        if lst[0] == '(' and lst[1] == '(' and lst[2] == '(' and lst[3] == ')':\n            return 'Yes'\n        elif lst[0] == '(' and lst[1] == '(' and lst[2] == ')' and lst[3]", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:]) + '('\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:]) + ')'\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append('(')\n            elif c == ')':\n                if len(stack) == 0:\n                    return False\n                else:\n                    stack.pop()\n        return len(stack) == 0\n\n    def match(s, t):\n        if is_balanced(s) and is_balanced(t):\n            return True\n        elif is_balanced(s):\n            return match(t, s)\n        elif is_balanced(t):\n            return match(s, t)\n        else:\n            return False\n\n    return match(lst[0], lst[1])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0]!= '(':\n        return match_parens(lst[1:])\n    if lst[0][-1]!= '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1]!= '(' and lst[1][0]!= '(':\n        return match_parens(lst[1:])\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:]) or match_parens(lst[2:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    return match_parens(lst[1:] + lst[:1])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return match_parens(lst[1:] + lst[:1])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[:1] + lst[2:])\n    return match_parens(lst[:1] + lst[1:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    if lst[0][-2] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-2] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[1][-1] == ')' and lst[0][0] == '(':\n        return match_parens(lst[0:1] + lst[1:])\n    if lst[0][-1] == ')' and lst[1][-1] == ')':\n        return match_parens(lst[0:1] + lst[2:])\n    if lst[0][-1] == ')' and lst[1][-1] == '(':\n        return match_parens(lst[0:1] + lst[2:] + lst[1:])\n    if lst[1][-1] == ')' and lst[0][-1] == '(':\n        return match_parens(lst[0:2] + lst[2:])\n    if lst[0][-1] == '(' and lst[1][-1] == ')':\n        return match_parens(lst[0:1] + lst[2:] + lst[1:])\n    if lst[1][-1] == '(' and lst[0][-1] == ')':\n        return match_parens(lst[0:2] + lst[2:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return match_parens(lst[1:])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[:1] + lst[2:])\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    if lst[0][-2]!= lst[1][0]:\n        return 'No'\n    if lst[0][-3]!= lst[1][0]:\n        return 'No'\n    if lst[0][-4]!= lst[1][0]:\n        return 'No'\n    if lst[0][-5]!= lst[1][0]:\n        return 'No'\n    if lst[0][-6]!= lst[1][0]:\n        return 'No'\n    if lst[0][-7]!= lst[1][0]:\n        return 'No'\n    if lst[0][-8]!= lst[1][0]:\n        return 'No'\n    if lst[0][-9]!= lst[1][0]:\n        return 'No'\n    if lst[0][-10]!= lst[1][0]:\n        return 'No'\n    if lst[0][-11]!", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        elif lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 3:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        elif lst[0] == '(' and lst[1] == ')' and lst[2] == ')':\n            return 'Yes'\n        elif lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        elif lst[0] == ')' and lst[1] == '(' and lst[2] == ')':\n            return 'Yes'\n        elif lst[0] == ')' and lst[1] == '(' and lst[2] == '(':\n            return 'Yes'\n        elif lst[0] == ')' and lst[1] == '(' and lst[2] == ')':\n            return 'Yes'\n        elif lst[0] == ')' and lst[1] == ')' and lst[2] ==", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if len(stack) == 0:\n                    return False\n                else:\n                    stack.pop()\n        return len(stack) == 0\n\n    def is_balanced2(s):\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if len(stack) == 0:\n                    return False\n                else:\n                    stack.pop()\n        return len(stack) == 0\n\n    def is_balanced3(s):\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if len(stack) == 0:\n                    return False\n                else:\n                    stack.pop()\n        return len(stack) == 0\n\n    def is_balanced4(s):\n        stack = []\n        for c in s:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if len(stack) == 0:\n                    return False\n                else:\n                    stack.pop()\n        return len(stack", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if len(lst) == 3:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(' and lst[2] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(' and lst[2] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(' and lst[2] == '(", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:]) + '(' + match_parens(lst[1:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:]) + ')' + match_parens(lst[2:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if len(lst) == 3:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 4:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(' and lst[3] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 5:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(' and lst[3] == ')' and lst[4] == '(':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 6:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(' and lst[3] == ')' and lst[4] == '(' and lst[5] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 7:\n        if lst[0] == '(' and lst[1] == ')' and lst", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    return match_parens(lst[1:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if len(lst) == 3:\n        return match_parens(lst[1:])\n    if len(lst) == 4:\n        if lst[1] == '(' and lst[3] == ')':\n            return match_parens(lst[2:])\n        if lst[1] == ')' and lst[3] == '(':\n            return match_parens(lst[2:])\n    if len(lst) == 5:\n        if lst[1] == '(' and lst[3] == ')' and lst[5] == '(':\n            return match_parens(lst[2:4])\n        if lst[1] == '(' and lst[3] == ')' and lst[5] == ')':\n            return match_parens(lst[2:4])\n        if lst[1] == '(' and lst[3] == ')' and lst[5] == ')':\n            return match_parens(lst[2:4])\n        if lst[1] == ')' and lst[3] == '(' and lst[5] == '(':\n            return match_parens(lst[2:4])\n        if lst[1] == ')' and lst[3] == '(' and lst[5] == ')", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    if lst[0][-2]!= lst[1][-1]:\n        return 'No'\n    if lst[0][-3]!= lst[1][-2]:\n        return 'No'\n    if lst[0][-4]!= lst[1][-3]:\n        return 'No'\n    if lst[0][-5]!= lst[1][-4]:\n        return 'No'\n    if lst[0][-6]!= lst[1][-5]:\n        return 'No'\n    if lst[0][-7]!= lst[1][-6]:\n        return 'No'\n    if lst[0][-8]!= lst[1][-7]:\n        return 'No'\n    if lst[0][-9]!= lst[1][-8]:\n        return 'No'\n    if lst[0][-10]!= lst[1][-9]:\n        return 'No'\n    if lst[0][-11]!= lst[1][-10", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    if lst[0][-2]!= lst[1][0]:\n        return 'No'\n    if lst[0][-3]!= lst[1][0]:\n        return 'No'\n    if lst[0][-4]!= lst[1][0]:\n        return 'No'\n    if lst[0][-5]!= lst[1][0]:\n        return 'No'\n    if lst[0][-6]!= lst[1][0]:\n        return 'No'\n    if lst[0][-7]!= lst[1][0]:\n        return 'No'\n    if lst[0][-8]!= lst[1][0]:\n        return 'No'\n    if lst[0][-9]!= lst[1][0]:\n        return 'No'\n    if lst[0][-10]!= lst[1][0]:\n        return 'No'\n    if lst[0][-11]!", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return match_parens(lst[1:])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][-1] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][-1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return match_parens(lst[1:])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 3:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 4:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')' and lst[3] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 5:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')' and lst[3] == ')' and lst[4] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 6:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')' and lst[3] == ')' and lst[4] == ')' and lst[5] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:] + lst[:1])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:] + lst[:1])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:] + lst[:1])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:] + lst[:1])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][-1] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][-1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return match_parens(lst[1:] + lst[:1])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    if match_parens(lst[0][:-1]) == 'No':\n        return 'No'\n    if match_parens(lst[1][1:]) == 'No':\n        return 'No'\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    if lst[0][-1]!= lst[1][-1]:\n        return 'No'\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' or lst[1] == '(':\n        if lst[0] == '(':\n            return match_parens(lst[1:])\n        else:\n            return match_parens(lst[:1] + lst[1:])\n    else:\n        if lst[0] == ')' or lst[1] == ')':\n            if lst[0] == ')':\n                return match_parens(lst[1:])\n            else:\n                return match_parens(lst[:1] + lst[1:])\n        else:\n            return match_parens(lst[:1] + lst[1:] + lst[1:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if len(lst) == 3:\n        return 'Yes' if lst[1] == ')' and lst[2] == '(' else 'No'\n    if len(lst) == 4:\n        return 'Yes' if lst[1] == ')' and lst[2] == '(' and lst[3] == ')' else 'No'\n    if len(lst) == 5:\n        return 'Yes' if lst[1] == ')' and lst[2] == '(' and lst[3] == ')' and lst[4] == '(' else 'No'\n    if len(lst) == 6:\n        return 'Yes' if lst[1] == ')' and lst[2] == '(' and lst[3] == ')' and lst[4] == '(' and lst[5] == ')' else 'No'\n    if len(lst) == 7:\n        return 'Yes' if lst[1] == ')' and lst[2] == '(' and lst[3] == ')' and lst[4] == '(' and lst[5] == ')' and lst[6] == '(' else 'No'\n    if len(lst) == 8:\n        return '", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return match_parens(lst[1:]) + ')' + match_parens(lst[:1])\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[:1])\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][-1] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][-1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[:1])\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[:1])\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(':\n        return match_parens(lst[1:])\n    if lst[1] == ')':\n        return match_parens(lst[:-1])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[:-1])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[:1])\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    if lst[0][-2]!= lst[1][0]:\n        return 'No'\n    if lst[0][-3]!= lst[1][0]:\n        return 'No'\n    if lst[0][-4]!= lst[1][0]:\n        return 'No'\n    if lst[0][-5]!= lst[1][0]:\n        return 'No'\n    if lst[0][-6]!= lst[1][0]:\n        return 'No'\n    if lst[0][-7]!= lst[1][0]:\n        return 'No'\n    if lst[0][-8]!= lst[1][0]:\n        return 'No'\n    if lst[0][-9]!= lst[1][0]:\n        return 'No'\n    if lst[0][-10]!= lst[1][0]:\n        return 'No'\n    if lst[0][-11]!", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if len(lst) == 3:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')':\n            return 'Yes'\n        if lst[0] == '(", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return match_parens(lst[1:])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    if lst[0][-2]!= lst[1][-1]:\n        return 'No'\n    if lst[0][-3]!= lst[1][-2]:\n        return 'No'\n    if lst[0][-4]!= lst[1][-3]:\n        return 'No'\n    if lst[0][-5]!= lst[1][-4]:\n        return 'No'\n    if lst[0][-6]!= lst[1][-5]:\n        return 'No'\n    if lst[0][-7]!= lst[1][-6]:\n        return 'No'\n    if lst[0][-8]!= lst[1][-7]:\n        return 'No'\n    if lst[0][-9]!= lst[1][-8]:\n        return 'No'\n    if lst[0][-10]!= lst[1][-9]:\n        return 'No'\n    if lst[0][-11]!= lst[1][-10", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if len(lst) == 3:\n        return match_parens(lst[1:])\n    if len(lst) == 4:\n        if lst[1] == '(' and lst[3] == ')':\n            return match_parens(lst[2:])\n        if lst[1] == ')' and lst[3] == '(':\n            return match_parens(lst[2:])\n        if lst[1] == '(' and lst[3] == ')':\n            return match_parens(lst[2:])\n        if lst[1] == ')' and lst[3] == '(':\n            return match_parens(lst[2:])\n    if len(lst) == 5:\n        if lst[1] == '(' and lst[3] == ')' and lst[5] == '(':\n            return match_parens(lst[2:4])\n        if lst[1] == '(' and lst[3] == ')' and lst[5] == ')':\n            return match_parens(lst[2:4])\n        if lst[1] == '(' and lst[3] == ')' and lst[5] == '(':\n            return match_parens(lst[2:4])\n        if lst", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if len(lst) == 3:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 4:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(' and lst[3] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 5:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(' and lst[3] == ')' and lst[4] == '(':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 6:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(' and lst[3] == ')' and lst[4] == '(' and lst[5] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 7:\n        if lst[0] == '(' and lst[1] == ')' and lst", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == ')' and lst[1]", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if len(lst) == 3:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(' and lst[2] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(' and lst[2] == '(':\n            return 'Yes'\n        return 'No'\n    if len(lst) == 4:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(' and lst[3] == ')':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')' and lst[3] == '(':", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:]) or match_parens(lst[2:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[:1])\n    return match_parens(lst[0] + lst[1])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if len(lst) == 3:\n        return match_parens([lst[0], lst[1], lst[2]])\n    if len(lst) == 4:\n        return match_parens([lst[0], lst[1], lst[2], lst[3]])\n    if len(lst) == 5:\n        return match_parens([lst[0], lst[1], lst[2], lst[3], lst[4]])\n    if len(lst) == 6:\n        return match_parens([lst[0], lst[1], lst[2], lst[3], lst[4], lst[5]])\n    if len(lst) == 7:\n        return match_parens([lst[0], lst[1], lst[2], lst[3], lst[4], lst[5], lst[6]])\n    if len(lst) == 8:\n        return match_parens([lst[0], lst[1], lst[2], lst[3], lst[4], lst[5], lst[6], lst[7]])\n    if len(lst) == 9:\n        return match_parens([lst[0], lst[1], lst[2], lst[3], lst[4], lst[5], lst[6], lst[7], lst[8]]", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 3:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 4:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(' and lst[3] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 5:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(' and lst[3] == ')' and lst[4] == '(':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 6:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(' and lst[3] == ')' and lst[4] == '(' and lst[5] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if len(lst) == 3:\n        return match_parens(lst[1:])\n    if len(lst) == 4:\n        if lst[1] == '(' and lst[2] == ')':\n            return match_parens(lst[3:])\n        elif lst[1] == ')' and lst[2] == '(':\n            return match_parens(lst[3:])\n        else:\n            return 'No'\n    if len(lst) == 5:\n        if lst[1] == '(' and lst[2] == ')' and lst[3] == '(' and lst[4] == ')':\n            return match_parens(lst[5:-1])\n        elif lst[1] == '(' and lst[2] == ')' and lst[3] == ')' and lst[4] == '(':\n            return match_parens(lst[5:-1])\n        elif lst[1] == '(' and lst[2] == ')' and lst[3] == '(' and lst[4] == ')':\n            return match_parens(lst[5:-1])\n        elif lst[1] == '(' and lst[2] == ')' and lst[3] == ')' and lst[4] ==", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == ')' and lst[1]", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(':\n        if lst[1] == '(':\n            if match_parens(lst[2:]) == 'Yes':\n                return 'Yes'\n            else:\n                return 'No'\n        else:\n            return match_parens(lst[1:])\n    else:\n        if lst[1] == '(':\n            return match_parens(lst[2:])\n        else:\n            return match_parens(lst[1:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        stack = []\n        for i in range(len(s)):\n            if s[i] == '(':\n                stack.append(i)\n            elif s[i] == ')':\n                if len(stack) == 0:\n                    return False\n                stack.pop()\n        return len(stack) == 0\n\n    def match(s1, s2):\n        if len(s1) == 0 or len(s2) == 0:\n            return False\n        if s1[-1]!= s2[0]:\n            return False\n        if is_balanced(s1) and is_balanced(s2):\n            return True\n        return match(s1[:-1], s2[1:]) or match(s1, s2[1:])\n\n    return match(lst[0], lst[1])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return match_parens(lst[1:])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[2:])\n    return match_parens(lst[1:])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    if lst[0][-2]!= lst[1][0]:\n        return 'No'\n    if lst[0][-3]!= lst[1][0]:\n        return 'No'\n    if lst[0][-4]!= lst[1][0]:\n        return 'No'\n    if lst[0][-5]!= lst[1][0]:\n        return 'No'\n    if lst[0][-6]!= lst[1][0]:\n        return 'No'\n    if lst[0][-7]!= lst[1][0]:\n        return 'No'\n    if lst[0][-8]!= lst[1][0]:\n        return 'No'\n    if lst[0][-9]!= lst[1][0]:\n        return 'No'\n    if lst[0][-10]!= lst[1][0]:\n        return 'No'\n    if lst[0][-11]!", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[:1])\n    return match_parens(lst[0] + lst[1])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' or lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == ')' or lst[1] == ')':\n        return match_parens(lst[:-1])\n    return match_parens(lst[1:] + lst[:-1])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[:1] + lst[2:])\n    return match_parens(lst[1:] + lst[:1])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:]) or match_parens(lst[2:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' or lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == ')' or lst[1] == ')':\n        return match_parens(lst[:-1])\n    return match_parens(lst[1:] + lst[:-1])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    return match_parens(lst[1:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if len(lst) == 3:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 4:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(' and lst[3] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 5:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(' and lst[3] == ')' and lst[4] == '(':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 6:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(' and lst[3] == ')' and lst[4] == '(' and lst[5] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) == 7:\n        if lst[0] == '(' and lst[1] == ')' and lst", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    if lst[0][-2]!= lst[1][0]:\n        return 'No'\n    if lst[0][-3]!= lst[1][0]:\n        return 'No'\n    if lst[0][-4]!= lst[1][0]:\n        return 'No'\n    if lst[0][-5]!= lst[1][0]:\n        return 'No'\n    if lst[0][-6]!= lst[1][0]:\n        return 'No'\n    if lst[0][-7]!= lst[1][0]:\n        return 'No'\n    if lst[0][-8]!= lst[1][0]:\n        return 'No'\n    if lst[0][-9]!= lst[1][0]:\n        return 'No'\n    if lst[0][-10]!= lst[1][0]:\n        return 'No'\n    if lst[0][-11]!", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        if lst[1] == '(' or lst[1] == ')':\n            return match_parens(lst[2:])\n        return 'No'\n    if lst[1] == '(' or lst[1] == ')':\n        if lst[0] == '(' or lst[0] == ')':\n            return match_parens(lst[1:])\n        return 'No'\n    return match_parens(lst[1:])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    if lst[0][-1]!= lst[1][-1]:\n        return 'No'\n    if lst[0][-1]!= lst[1][-2]:\n        return 'No'\n    if lst[0][-1]!= lst[1][-3]:\n        return 'No'\n    if lst[0][-1]!= lst[1][-4]:\n        return 'No'\n    if lst[0][-1]!= lst[1][-5]:\n        return 'No'\n    if lst[0][-1]!= lst[1][-6]:\n        return 'No'\n    if lst[0][-1]!= lst[1][-7]:\n        return 'No'\n    if lst[0][-1]!= lst[1][-8]:\n        return 'No'\n    if lst[0][-1]!= lst[1][-9]:\n        return 'No'\n    if lst[0][-1]!= lst[1][-10]:\n        return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == ')' and lst[1] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[:1] + lst[2:])\n    return match_parens(lst[1:] + lst[:1])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1] == ')':\n        return match_parens(lst[1:])\n    if lst[1][0] == '(':\n        return match_parens(lst[2:])\n    return match_parens(lst[1:] + lst[:2])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[0:1] + lst[2:])\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[0:1] + lst[2:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if len(lst) == 3:\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == ')':\n            return 'Yes'\n        if lst[0] == '(' and lst[1] == ')' and lst[2] == '(':\n            return 'Yes'\n        if lst[0] == '(", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][0]!= '(':\n        return 'No'\n    if lst[0][-1]!= ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1]!= ')' and lst[1][0]!= '(':\n        return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[:1] + lst[2:])\n    return match_parens(lst[:1] + [')'] + lst[1:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1] == ')' and lst[1][0] == '(':\n        return match_parens(lst[1:])\n    if lst[0][-1] == '(' and lst[1][0] == ')':\n        return match_parens(lst[1:])\n    if lst[0][-1] == ')' and lst[1][-1] == '(':\n        return match_parens(lst[:1] + lst[1:])\n    if lst[0][-1] == '(' and lst[1][-1] == ')':\n        return match_parens(lst[:1] + lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'No'\n    res = []\n    for i in range(len(lst[0])):\n        if lst[0][i] == '(' and lst[1][i] == ')':\n            res.append(')')\n        elif lst[0][i] == ')' and lst[1][i] == '(':\n            res.append('(')\n        else:\n            res.append(lst[0][i])\n    if res[-1] == ')' and lst[1][-1] == '(':\n        res.append('(')\n    if res[-1] == '(' and lst[1][-1] == ')':\n        res.append(')')\n    return match_parens(res)", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    if lst[0][-1]!= ')':\n        return 'No'\n    if lst[1][0]!= '(':\n        return 'No'\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n    if lst[0][-1]!= lst[1][0]:\n        return 'No'\n    return match_parens(lst[1:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:]) or match_parens(lst[2:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        if lst[0] == ')' and lst[1] == '(':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == '(' and lst[1] == '(':\n        return match_parens(lst[2:]) or match_parens(lst[1:])\n    if lst[0] == ')' and lst[1] == ')':\n        return match_parens(lst[1:]) or match_parens(lst[2:])\n    return 'No'"]]