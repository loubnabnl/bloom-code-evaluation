[["def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # Init\n    result = 'Yes'\n    stack = []\n    # Deal\n    for i, item in enumerate(lst):\n        # Push\n        if item == '(':\n            stack.append('(')\n        # Pop\n        elif item == ')':\n            while stack and stack[-1]!= '(':\n                stack.pop()\n        # None\n        else:\n            if not stack:\n                return 'No'\n            if stack[-1]!= '(':\n                stack.pop()\n                if not stack:\n                    return 'No'\n            stack.append(item)\n    # Check\n    if stack:\n        return 'No'\n    return result", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'No'\n    if len(lst[0]) == 0:\n        return match_parens(lst[1:])\n    if len(lst[1]) == 0:\n        return match_parens(lst[:1])\n    if len(lst[0])!= len(lst[1]):\n        return 'No'\n    if lst[0][0]!= lst[1][0]:\n        return match_parens(lst[0][1:] + lst[1])\n    for i in range(1, len(lst[0])):\n        if lst[0][i] == '(' and lst[0][i - 1] == ')':\n            return match_parens(lst[0][i:] + lst[1])\n        if lst[1][i] == '(' and lst[1][i - 1] == ')':\n            return match_parens(lst[0] + lst[1][i:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def paren_count(str):\n        '''\n        Count the number of parentheses in str.\n        '''\n        return sum(1 for c in str if c == '(' or c == ')')\n\n    def find_balanced(str1, str2):\n        '''\n        Return True if str1 and str2 are balanced, else return False.\n        '''\n        return paren_count(str1) == paren_count(str2) and \\\n            paren_count(str1) == paren_count(str2)\n\n    if len(lst)!= 2:\n        return 'No'\n    str1 = lst[0]\n    str2 = lst[1]\n    if not find_balanced(str1, str2):\n        return 'No'\n    if find_balanced(str1 + str2, str1):\n        return 'Yes'\n    if find_balanced(str1 + str2, str2):\n        return 'Yes'\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    stack = []\n\n    for i in lst:\n        if i == '(':\n            stack.append(i)\n        elif i == ')':\n            while stack and stack[-1]!= '(':\n                stack.pop()\n\n    if stack and stack[-1]!= '(':\n        return False\n    else:\n        return True", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if lst == [] or lst == [')'] or lst == ['(']:\n        return 'Yes'\n    elif lst == ['('] or lst == [')']:\n        return 'No'\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == ')' and lst[1] == '(':\n            return 'No'\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n    ret = match_parens(lst[1:])\n    if ret == 'No':\n        return 'No'\n    if ret == 'Yes':\n        return 'Yes'\n    if ret == 'Yes':\n        return 'Yes'\n    if lst[0] == '(':\n        ret = match_parens(lst[1:])\n        if ret == 'No':\n            return 'No'\n        if ret == 'Yes':\n            return ret\n        if ret == 'Yes':\n            return ret\n    if lst[0] == ')':\n        ret = match_parens(lst[1:])\n        if ret == 'No':\n            return 'No'\n        if ret == 'Yes':\n            return ret\n        if ret == 'Yes':\n            return ret\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return match_parens(lst[0])\n\n    stack = []\n    for i, c in enumerate(lst[0]):\n        if c == '(':\n            stack.append(i)\n        elif c == ')':\n            if stack and stack[-1] == i - 1:\n                stack.pop()\n            else:\n                return 'No'\n\n    return 'Yes' if stack else 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) <= 1:\n        return 'Yes'\n    res = '('\n    for i in lst:\n        res = res + i\n    res = res + ')'\n    lst = [res]\n    for i in range(len(lst) - 1, 0, -1):\n        if lst[i][-1] == '(':\n            lst[i] = lst[i][:-1] + lst[i - 1]\n        if lst[i][-1] == ')':\n            lst[i] = lst[i][:-1] + lst[i - 1] + '('\n        if not match_parens(lst):\n            break\n    return lst[0]", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if not lst:\n        return 'No'\n    elif lst[0] == '(':\n        return match_parens(lst[1:])\n    elif lst[-1] == ')':\n        return match_parens(lst[:-1])\n    else:\n        return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def match_parens_rec(lst):\n        if not lst:\n            return True\n        else:\n            result = False\n            left = lst[0]\n            right = lst[1]\n            if left == '(' and right == ')':\n                result = match_parens_rec(lst[2:])\n            elif left == ')' and right == '(':\n                result = match_parens_rec(lst[1:])\n            return result\n\n    return match_parens_rec(lst)\n\n\nlst = ['('] * 4\nlst.append(')')", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    result = []\n    for i in range(len(lst)):\n        result.append(lst[i])\n    r = []\n    for i in range(len(lst)):\n        if lst[i] == '(':\n            if not r or r[-1]!= '(':\n                r.append('(')\n        else:\n            if not r or r[-1]!= ')':\n                r.append(')')\n    if len(r)!= 0:\n        return 'No'\n    while len(result) > 0:\n        if result[0] == ')':\n            if result[1] == '(':\n                result.remove(result[0])\n                result.remove(result[1])\n                result.insert(1, ')')\n            else:\n                result.remove(result[0])\n                result.insert(1, '(')\n        elif result[0] == '(':\n            if result[1] == ')':\n                result.remove(result[0])\n                result.remove(result[1])\n                result.insert(1, ')')\n            else:\n                result.remove(result[0])\n                result.insert(1, '(')\n    if result == ['(', '('] or result == [')', ')']:\n        return 'No'\n    else:\n        return 'Yes", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def get_size(lst):\n        return len(lst[0]) + len(lst[1])\n    if get_size(lst) % 2!= 0:\n        return 'No'\n    stack = []\n    for i in range(0, get_size(lst), 2):\n        if lst[i] == '(' and lst[i + 1] == ')':\n            if stack and stack[-1] == ')':\n                stack.pop()\n            else:\n                return 'No'\n        stack.append(lst[i])\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def are_closed(string):\n        '''\n        Given a string, return a list of its balanced parentheses.\n        For example:\n        are_closed('()()') == []\n        are_closed('(())(') == [((), ())]\n        are_closed(')') == [()]\n        are_closed('') == []\n        '''\n        stack = []\n        for c in string:\n            if c == '(':\n                stack.append('(')\n            elif c == ')':\n                while True:\n                    if len(stack) == 0:\n                        return []\n                    top = stack.pop()\n                    if top == '(':\n                        continue\n                    else:\n                        stack.append(top)\n                        break\n        return stack\n\n    def are_balanced(stack):\n        '''\n        Given a stack of parentheses, return True if the parentheses are balanced,\n        return False otherwise.\n        '''\n        if len(stack) == 0:\n            return True\n        if len(stack) == 1:\n            return False\n        if stack[0] == '(':\n            return are_balanced(stack[1:])\n        if stack[-1] == ')':\n            return are_balanced(stack[:-1])\n\n    if len(lst)!= 2:\n        raise ValueError('length of", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    for i in range(len(lst)):\n        if lst[i] == '(':\n            for j in range(i+1, len(lst)):\n                if lst[j] == ')':\n                    return 'No'\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    stack = []\n    for x in lst:\n        if x == ')':\n            while len(stack) > 0 and stack[-1]!= '(':\n                stack.pop()\n        elif x == '(':\n            stack.append(x)\n    return len(stack) == 0", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) <= 1:\n        return 'No'\n    else:\n        stack = []\n        for e in lst:\n            stack.append(e)\n            if e == '(':\n                if len(stack) > 1:\n                    if stack[-2]!= ')':\n                        stack[-2] += e\n                        stack.append(e)\n                else:\n                    return 'No'\n            elif e == ')':\n                if len(stack) > 1:\n                    if stack[-1]!= '(':\n                        stack[-1] += e\n                        stack.append(e)\n                    else:\n                        stack.pop()\n                else:\n                    return 'No'\n        if len(stack)!= 0:\n            return 'No'\n        else:\n            return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    res = ''\n    for i in range(len(lst)):\n        if lst[i] == '(':\n            res += '('\n        elif lst[i] == ')':\n            res += ')'\n            if res[0]!= '(':\n                return 'Yes'\n        else:\n            return 'Yes'\n    return res\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    is_balanced = 0\n    concat = \"\"\n    for i in lst:\n        if i == '(':\n            concat += i\n            is_balanced += 1\n        elif i == ')':\n            is_balanced -= 1\n            if is_balanced < 0:\n                return False\n            else:\n                concat += i\n        else:\n            return False\n    return True\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    print('Enter a list of two strings:')\n    lst = []\n    for i in range(2):\n        lst.append(input())\n    lst = list(map(str, lst))\n    # filter out the left and right parentheses\n    print(lst)\n    for i in lst:\n        if i == '(':\n            lst[i] = '('\n        if i == ')':\n            lst[i] = ')'\n    # count the number of parentheses on left and right sides\n    left_count = 0\n    right_count = 0\n    for i in lst:\n        if i == '(':\n            left_count += 1\n        else:\n            right_count += 1\n    if left_count!= right_count:\n        return 'No'\n    else:\n        for i in range(len(lst) - 1):\n            if lst[i] == ')' and lst[i + 1] == '(':\n                lst[i] = '('\n            if lst[i] == '(' and lst[i + 1] == ')':\n                lst[i] = ')'\n        print(lst)\n        for i in lst:\n            if i == ')':\n                lst[i] = '('\n        return 'Yes'</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def match(s, t):\n        i = 0\n        while i < len(s) and i < len(t):\n            if s[i] == '(':\n                if t[i-1] == ')':\n                    i += 1\n                    continue\n                else:\n                    return False\n            elif s[i] == ')':\n                if t[i-1] == '(':\n                    i += 1\n                    continue\n                else:\n                    return False\n            else:\n                if s[i] == t[i]:\n                    i += 1\n                    continue\n                else:\n                    return False\n        if i == len(s):\n            return True\n        else:\n            return False\n\n    def add_parens(s, t):\n        if len(s) == 0:\n            return t\n        if s[0] == '(':\n            return s + add_parens(s[1:], t)\n        elif s[0] == ')':\n            return add_parens(s[:-1], t) + ')'\n        else:\n            return add_parens(s[:-1], t) + add_parens(s[1:], t)\n\n    res = add_parens(lst[0], lst[1])\n    if res == ')':\n        return 'No'\n    if res[0] == ')' and res[-1] == '(':\n        return res\n    if res", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def isGood(s):\n        # Returns true if s is a good string.\n        stack = []\n        for char in s:\n            if char == '(':\n                stack.append('(')\n            elif char == ')':\n                if len(stack) == 0:\n                    return False\n                else:\n                    stack.pop()\n        return len(stack) == 0\n\n    # Check whether the left string is a good string.\n    if not isGood(lst[0]):\n        return 'No'\n\n    # Check whether the right string is a good string.\n    if not isGood(lst[1]):\n        return 'No'\n\n    # The two strings are good. Now we try to concatenate them, and see\n    # if the result is a good string.\n    result = lst[0] + lst[1]\n    stack = []\n    for char in result:\n        if char == '(':\n            stack.append('(')\n        elif char == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                stack.pop()\n\n    return 'Yes' if len(stack) == 0 else 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    n = len(lst)\n    if n <= 2:\n        return 'No'\n    if n == 3:\n        if lst[0] == '(' and lst[1] == '(' and lst[2] == ')':\n            return 'Yes'\n        elif lst[1] == '(' and lst[0] == ')' and lst[2] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    elif n == 4:\n        if lst[0] == '(' and lst[1] == '(' and lst[2] == '(' and lst[3] == ')':\n            return 'Yes'\n        elif lst[0] == '(' and lst[1] == ')' and lst[2] == ')' and lst[3] == ')':\n            return 'Yes'\n        elif lst[0] == '(' and lst[1] == ')' and lst[2] == '(' and lst[3] == ')':\n            return 'Yes'\n        elif lst[0] == '(' and lst[1] == ')' and lst[2] == ')' and lst[3] == '(':\n            return 'Yes'\n        elif lst[0] == ')' and lst[1] == '(' and lst[2] == '(' and lst[3] == ')':\n            return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if not lst:\n        return False\n    if len(lst) == 1:\n        return True\n\n    if lst[0] == '(' and lst[-1] == ')':\n        return True\n\n    for i in range(len(lst) - 1):\n        if lst[i] == '(' and lst[i + 1] == ')':\n            return True\n    return False", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # TODO complete this function\n    if len(lst) < 2:\n        return 'No'\n    answer = ''\n    while len(lst)!= 0:\n        if len(lst) == 1:\n            return answer\n        if lst[0] == '(':\n            if answer[-1] == ')':\n                answer += lst[0]\n                lst.remove(lst[0])\n            else:\n                return 'No'\n        elif lst[0] == ')':\n            if answer[-1] == '(':\n                answer += lst[0]\n                lst.remove(lst[0])\n            else:\n                return 'No'\n\n    return answer", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def check(i, paren):\n        l = len(paren)\n        for j in range(i + 1, l + 1):\n            if paren[i] == paren[j] and paren[i] == '(' and paren[j] == ')':\n                return False\n        return True\n\n    res = []\n    for idx, paren in enumerate(lst):\n        res.append(paren)\n        if idx == 0:\n            if not check(0, paren):\n                res.pop(idx)\n            else:\n                res.pop(idx)\n    return 'Yes' if len(res) == 1 else 'No'</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def match_parens_helper(head, tail):\n        '''\n        If either string has a left most '(', try to match the leftmost pair.\n        Else, try to match the rightmost pair.\n        '''\n        if head[-1] == '(':\n            if tail[0] == ')':\n                return match_parens_helper(head[:-1], tail[1:])\n            else:\n                return False\n        elif tail[-1] == '(':\n            if head[0] == ')':\n                return match_parens_helper(head[1:], tail[:-1])\n            else:\n                return False\n        else:\n            return True\n\n    return match_parens_helper(lst[0], lst[1])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def balance(lst):\n        '''\n        Recursively call this function to check if a string contains\n        balanced parentheses.\n        '''\n        if not lst:\n            return True\n        elif len(lst) == 1 and lst[0] in ('(', ')'):\n            return True\n        elif lst[0] == '(' and balance(lst[1:]):\n            return True\n        else:\n            return False\n    if len(lst) == 2:\n        return balance(lst)\n    else:\n        return balance(lst[:-1]) and balance(lst[1:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    str1, str2 = lst\n    stack1 = []\n    stack2 = []\n    for i in str1:\n        if i == '(':\n            stack1.append('(')\n        elif i == ')':\n            if stack1[-1] == '(':\n                stack1.pop()\n            else:\n                return 'No'\n    for i in str2:\n        if i == '(':\n            stack2.append('(')\n        elif i == ')':\n            if stack2[-1] == '(':\n                stack2.pop()\n            else:\n                return 'No'\n    if stack1 or stack2:\n        return 'No'\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def helper(lst):\n        if len(lst) == 1:\n            return True\n        if len(lst) == 2:\n            if lst[0] == ')' and lst[1] == '(':\n                return True\n            if lst[1] == ')' and lst[0] == '(':\n                return True\n            if lst[0] == '(' and lst[1] == ')':\n                return True\n            return False\n        if lst[0] == ')' or lst[1] == ')':\n            return helper(lst[1:])\n        if lst[0] == '(' and lst[1] == ')':\n            return helper(lst[1:])\n        if lst[0] == '(' or lst[1] == '(':\n            return helper(lst[1:]) and helper(lst[2:])\n    return helper(lst)", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    stack = []\n    for el in lst:\n        if el == '(':\n            stack.append('(')\n        elif el == ')':\n            if not stack:\n                return 'No'\n            if stack[-1] == '(':\n                stack.pop()\n            else:\n                return 'No'\n    return 'Yes'</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    open_parens = len(lst[0])\n    close_parens = len(lst[1])\n    if open_parens == close_parens:\n        return 'Yes'\n\n    def can_be_continued(s, i):\n        if i >= len(s) - 1:\n            return False\n        ch1 = s[i]\n        ch2 = s[i+1]\n        if ch1 == '(' and ch2 == ')':\n            return True\n        if ch1 == ')' and ch2 == '(':\n            return True\n        if (ch1 == '(' and ch2 == ')') or (ch1 == ')' and ch2 == '('):\n            return False\n        return can_be_continued(s, i+1)\n\n    return can_be_continued(lst[0], 0) and can_be_continued(lst[1], 0)</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if not lst:\n        return False\n    if len(lst) == 1:\n        return lst[0] == '()'\n    stack = []\n    for i in lst:\n        if i == '(':\n            stack.append(i)\n        if i == ')':\n            if not stack:\n                return False\n            if not match_parens(stack):\n                return False\n            stack.pop()\n    return True", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def good(s):\n        for i in range(len(s)):\n            if s[i] == '(' and s[i - 1]!= ')':\n                return False\n        return True\n\n    def concat(s0, s1):\n        '''\n        Concatenate two strings in either order.\n\n        :param s0: The first string\n        :param s1: The second string\n        :return: The concatenated string, or None if one of the strings are empty.\n        '''\n        if not s0 or not s1:\n            return None\n        if s0[0] == '(' and s1[0] == '(':\n            return '(' + s1 + ')' + s0[1:]\n        elif s0[0] == '(' and s1[0] == ')':\n            return '(' + s0[1:] + ')' + s1\n        elif s0[0] == ')' and s1[0] == '(':\n            return ')' + s0[1:] + '(' + s1\n        elif s0[0] == ')' and s1[0] == ')':\n            return ')' + s1 + ')' + s0[1:]\n\n    res = None\n    for i in range(len(lst)):\n        res = concat(res, lst[i])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if not lst:\n        return 'Yes'\n    for i in range(1, len(lst) + 1):\n        res = match_parens(lst[i - 1:])\n        if res == 'Yes':\n            if i == len(lst):\n                return 'Yes'\n            if lst[i] == '(':\n                lst[i] = '('\n            else:\n                lst[i] = ')'\n            return match_parens(lst[:i - 1] + [lst[i]])\n    return 'No'\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    p, q = lst\n    if not q:\n        return match_parens(p)\n    if not p:\n        return match_parens(q)\n    if len(p) == 1 and len(q) == 1 and p[0] == q[0]:\n        return match_parens(q[1:] + p[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_good(str):\n        stack = [str[0]]\n        for c in str[1:]:\n            if c == '(':\n                stack.append(c)\n            elif c == ')':\n                if len(stack) == 0:\n                    return False\n                while stack[-1] == '(':\n                    stack.pop()\n                if stack[-1] == ')':\n                    stack.pop()\n            else:\n                return False\n        return len(stack) == 0\n\n    return is_good(''.join(lst))</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'No'\n    if lst[0][-1] == '(' and lst[1][-1] == ')':\n        return 'Yes'\n    for i in range(len(lst)):\n        for j in range(i + 1, len(lst)):\n            if match_parens(lst[i:] + lst[:j]) == 'Yes':\n                return 'Yes'\n            elif match_parens(lst[i:] + lst[j:]) == 'Yes':\n                return 'Yes'\n            elif match_parens(lst[i:][::-1] + lst[j:][::-1]) == 'Yes':\n                return 'Yes'\n            else:\n                pass\n    return 'No'\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n\n    if len(lst) == 2:\n        if lst[0][-1] == '(' and lst[1][0] == ')':\n            return 'No'\n        else:\n            return 'Yes'\n\n    if len(lst) == 3:\n        if lst[0][-1] == '(' and lst[1][-1] == '(' and lst[2][0] == ')':\n            return 'No'\n        else:\n            return 'Yes'\n\n    stack = []\n    parens = 0\n    for i in lst:\n        if i[-1] == '(':\n            stack.append(i[:-1])\n            parens += 1\n        elif i[0] == ')':\n            if parens == 0:\n                return 'Yes'\n            else:\n                stack.pop()\n                parens -= 1\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    left = ''\n    right = ''\n    i = 0\n    j = 0\n    k = 0\n    l = 0\n    while i < len(lst[0]) and j < len(lst[1]):\n        if lst[0][i] == '(' and lst[1][j] == ')':\n            i = i + 1\n            j = j + 1\n        elif lst[0][i] == ')' and lst[1][j] == '(':\n            i = i + 1\n            j = j + 1\n        elif lst[0][i] == '(' and lst[1][j] == '(':\n            left = left + lst[0][i]\n            right = right + lst[1][j]\n            k = k + 1\n            j = j + 1\n            i = i + 1\n        elif lst[0][i] == ')' and lst[1][j] == ')':\n            left = left + lst[0][i]\n            right = right + lst[1][j]\n            j = j + 1\n            i = i + 1\n        else:\n            i = i + 1\n            j = j + 1\n    if k == 0:\n        return 'No'\n    else:\n        return 'Yes'</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # IMPORTANT: I know this is not the best way to solve this problem, but I wanted to try making my own solution.\n\n    def make_string(lst):\n        string = \"\"\n        for x in lst:\n            if x == \"(\":\n                string += \"(\"\n            else:\n                string += \")\"\n\n        return string\n\n    if len(lst) <= 1:\n        return \"No\"\n\n    # this checks if the first string is already good\n    if match_parens(lst[0]) == \"Yes\":\n        if lst[0] == \"()\":\n            return \"Yes\"\n        return \"No\"\n\n    # this checks if the second string is already good\n    if match_parens(lst[1]) == \"Yes\":\n        if lst[1] == \"()\":\n            return \"Yes\"\n        return \"No\"\n\n    # if both strings are good, then the string made of them both will be good\n    if match_parens(lst[0]) == \"Yes\" and match_parens(lst[1]) == \"Yes\":\n        return \"Yes\"\n\n    # this checks if the first string is already bad\n    if match_parens(lst[0]) == \"No\":\n        if lst[0] == \"())\":\n            return \"Yes\"\n        return \"No\"\n\n    # this checks if the second string is already bad", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    start = 0\n    end = 0\n\n    for i in range(0, len(lst[0])):\n        if lst[0][i] == '(':\n            if not start:\n                start = i\n        if lst[0][i] == ')':\n            if start:\n                end = i\n        if start and end:\n            if end - start + 1 == len(lst[1]):\n                if lst[0][start:start + end - start + 1] == lst[1]:\n                    return 'Yes'\n                return 'No'\n            return 'No'\n    return 'No'</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # one string open, one string close\n    if len(lst) == 1:\n        return len(lst[0]) == 0\n    # just check if the first string is a valid string\n    if not lst[0]:\n        return match_parens(lst[1:])\n    # just check if the second string is a valid string\n    if not lst[1]:\n        return match_parens(lst[:1])\n    return match_parens(lst[1:]) or match_parens(lst[:1])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    assert len(lst) == 2\n\n    is_good = True\n    for i in range(len(lst[0])):\n        paren = lst[0][i]\n        assert paren in ['(', ')']\n        if is_good:\n            for j in range(len(lst[1])):\n                paren = lst[1][j]\n                assert paren in ['(', ')']\n                if paren == '(':\n                    if lst[0][i]!= lst[1][j]:\n                        is_good = False\n                        break\n                elif paren == ')':\n                    if lst[0][i]!= lst[1][j]:\n                        break\n                    if i == len(lst[0]) - 1 or j == len(lst[1]) - 1:\n                        is_good = False\n                        break\n        if not is_good:\n            break\n\n    return is_good\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def recurse(lst, n=0):\n        if n == len(lst):\n            return True\n\n        if lst[n] == '(':\n            if recurse(lst, n+1):\n                return True\n\n        return False\n\n    if len(lst) == 1:\n        return recurse(lst)\n    return recurse(lst[1:]) and recurse(lst[:1])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    # Solution 1\n    # ps1 and ps2 are lists of indices of '(' and ')' respectively,\n    # with ps1 and ps2 are good indices if they are in a pair.\n    ps1, ps2 = [], []\n    for i in lst[0]:\n        if i == '(':\n            ps1.append(i)\n        elif i == ')':\n            if ps1 and not ps1[-1]:\n                ps1.pop()\n            else:\n                ps2.append(i)\n\n    for i in lst[1]:\n        if i == '(':\n            if ps2:\n                if not ps2[-1]:\n                    ps2.pop()\n                else:\n                    ps1.append(i)\n            else:\n                ps1.append(i)\n        elif i == ')':\n            if ps1:\n                if not ps1[-1] and ps2 and not ps2[-1] and not ps2[0]:\n                    ps1.pop()\n                    ps2.pop()\n                elif not ps1[-1] and ps2 and not ps2[-1] and not ps2[0]:\n                    ps1.pop()\n                else:\n                    if ps1 and not ps1[-1]:\n                        ps1.pop()\n                    else:\n                        ps2.append(i)\n    return (ps1 or ps2)\n\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        return 'No'\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[1] == '(' and lst[0] == ')':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == '(':\n        return 'Yes'\n    if lst[1] == '(' and lst[0] == '(':\n        return 'Yes'\n    if lst[0] == '(' and lst[1] == ')' or lst[1] == '(' and lst[0] == ')' or lst[0] == '(' and lst[1] == '(' or lst[1] == '(' and lst[0] == '(':\n        return 'No'\n    if lst[0] == ')' or lst[1] == ')':\n        return match_parens(lst[1:])\n    if lst[0] == '(' or lst[1] == '(':\n        return match_parens(lst[2:])\n\nlst = ['()()', '(())']\nmatch_parens(lst)\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    new_lst = ['']\n    if lst[0] == '()':\n        new_lst.append(lst[1])\n        new_lst.append(lst[0])\n    else:\n        new_lst.append(lst[0])\n        new_lst.append(lst[1])\n\n    return match_parens(new_lst)", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    result = ['()']\n    current = ['(']\n    last = ''\n    for ch in lst[0]:\n        if ch == '(':\n            result.append(last)\n            result.append(current)\n            current.append(ch)\n            last = ''\n        else:\n            last += ch\n\n    if last!= '':\n        result.append(last)\n        result.append(current)\n        current.append(')')\n        last = ''\n\n    for ch in lst[1]:\n        if ch == '(':\n            result.append(last)\n            result.append(current)\n            current.append(ch)\n            last = ''\n        else:\n            last += ch\n\n    if last!= '':\n        result.append(last)\n        result.append(current)\n        current.append(')')\n        last = ''\n\n    for i in range(len(result) - 2):\n        if result[i] == '(' and result[i + 2] == ')':\n            return 'Yes'\n\n    return 'No'\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        return 'No'\n    if lst[0] == '(' or lst[1] == '(':\n        return match_parens(lst[1:])\n    if lst[0] == ')' or lst[1] == ')':\n        if lst[0] == ')':\n            return match_parens(lst[1:])\n        if lst[0] == '(':\n            return match_parens(lst[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    paren_count = 0\n    for i, word in enumerate(lst):\n        if word == '(':\n            paren_count += 1\n        else:\n            paren_count -= 1\n        if paren_count!= 0:\n            return 'No'\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    stack = []\n    for i in range(len(lst)):\n        if lst[i] == '(':\n            stack.append('(')\n        elif lst[i] == ')':\n            while True:\n                top = stack.pop()\n                if top == '(':\n                    break\n                else:\n                    stack.append(top)\n    if len(stack) == 0:\n        return 'Yes'\n    else:\n        return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'Yes'\n    else:\n        left, right = lst\n        if match_parens(left) == 'No':\n            return 'No'\n        elif match_parens(right) == 'No':\n            return 'No'\n        elif left[0]!= right[0]:\n            return 'No'\n        elif left[-1]!= right[-1]:\n            return 'No'\n        elif left.count(')') == right.count('('):\n            return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    assert len(lst) == 2\n    return match_parens_impl(lst[0], lst[1])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # Edge case, empty list\n    if len(lst) == 0:\n        return 'No'\n\n    # Return immediately if first string is empty\n    if len(lst[0]) == 0:\n        return 'No'\n\n    # Return immediately if first string is empty\n    if len(lst[1]) == 0:\n        return 'No'\n\n    # Create a string of brackets and parentheses (with the first string)\n    # The number of opening brackets must be same as number of closing brackets\n    s = str(lst[0]).replace('(', '[').replace(')', ']')\n\n    # Find the longest string with balanced parentheses\n    # Loop as long as we are able to find a valid string\n    while True:\n        # Find the longest string with balanced parentheses\n        # This string must not be longer than the length of the first string\n        index = len(lst[0])-1\n        length = 0\n        while index >= 0 and s[index]!= '[' and s[index]!= ']':\n            if s[index] == '(':\n                length += 1\n            else:\n                length -= 1\n            index -= 1\n        if length == 0:\n            return 'No'\n\n        # Remove the found string from the remaining strings\n        temp = []\n        for s in lst:\n            temp.append(", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def check_good(str):\n        i = 0\n        j = 0\n        k = 0\n        len_str = len(str)\n        while i < len_str:\n            if str[i] == '(':\n                j += 1\n            elif str[i] == ')':\n                k += 1\n            i += 1\n        if j == k:\n            return True\n        return False\n\n    def find(lst):\n        i = 0\n        j = 0\n        while i < len(lst):\n            if lst[i] == lst[j]:\n                if lst[i] == '(':\n                    j += 1\n                elif lst[i] == ')':\n                    j -= 1\n            elif lst[i] == '(':\n                j += 1\n            elif lst[i] == ')':\n                j -= 1\n            i += 1\n\n        if j == 0 and i < len(lst):\n            return lst[i]\n\n        return ''\n\n    def match_parens(lst, count):\n        if len(lst) == 2:\n            if check_good(lst[0]) == False or check_good(lst[1]) == False:\n                return 'No'\n            else:\n                return 'Yes'\n\n        new_lst = lst[2:]\n        new_lst.append(find(lst[1:]))\n        if match_parens", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    import re\n\n    lst = [x.strip() for x in lst]\n    if len(lst) == 0:\n        return 'No'\n\n    return 'Yes' if all(match_parens(lst) == 'Yes' for lst in zip(*[lst] * 2)) else 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    stack = []\n    for x in lst:\n        if x == '(':\n            stack.append(x)\n        elif x == ')':\n            if not stack:\n                return 'Yes'\n            else:\n                stack.pop()\n    return 'No'\n\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if not lst:\n        return 'No'\n\n    stack = []\n    for s in lst:\n        if s == '(':\n            stack.append('(')\n        elif s == ')':\n            if len(stack) > 0:\n                stack.pop()\n\n            if len(stack) == 0 and len(str(stack)) > 0:\n                return 'No'\n\n    return 'Yes'\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        open_brackets = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                open_brackets += 1\n            elif s[i] == ')':\n                open_brackets -= 1\n        return open_brackets == 0\n\n    def find_open_parens(s):\n        open_brackets = 0\n        for i in range(len(s)):\n            if s[i] == '(':\n                open_brackets += 1\n            elif s[i] == ')':\n                open_brackets -= 1\n        return open_brackets\n\n    def is_balanced_until(s, open_brackets, index):\n        if index == len(s):\n            return True\n        if s[index] == '(':\n            return is_balanced_until(s[index + 1:], open_brackets + 1, 0)\n        elif s[index] == ')':\n            return is_balanced_until(s[index + 1:], open_brackets - 1, 0)\n        else:\n            return open_brackets == 0\n\n    def move_to_close_parens(s, index):\n        if index == len(s):\n            return s\n        if s[index] == '(':\n            return", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def match(arr, idx, acc, temp):\n        if idx == 0:\n            return temp[len(acc):]\n        elif idx == len(arr):\n            return acc + temp[:-1]\n        else:\n            return match(arr, idx - 1, acc + arr[idx], temp[:-1])\n\n    if len(lst)!= 2:\n        return False\n\n    def is_balanced(str):\n        count = 0\n        for c in str:\n            if c == '(':\n                count += 1\n            elif c == ')':\n                count -= 1\n        return count == 0\n\n    return match(lst[0], 0, [], []) == 'Yes' and is_balanced(match(lst[1], 0, [], []))</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst)!= 2:\n        return False\n    open_ = lst[0]\n    close = lst[1]\n    temp = []\n    i = 0\n    while i < len(open_):\n        if open_[i]!= close[i]:\n            temp.append(open_[i])\n            temp.append(close[i])\n            i += 2\n        else:\n            i += 1\n    if (len(temp) + 1 == len(open_)) or (len(temp) + 1 == len(close)):\n        return True\n    return False", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # Your code here\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    result = ''\n    if len(lst) == 0:\n        return 'Yes'\n\n    if len(lst) == 1:\n        if lst[0] == '(':\n            return match_parens([')'])\n        else:\n            return match_parens(['('])\n\n    for i in range(len(lst) - 1):\n        if lst[i] == '(' and lst[i + 1] == ')':\n            result += lst[i]\n            lst.pop(i + 1)\n        elif lst[i] == '(' and lst[i + 1] == '(':\n            result += lst[i]\n            lst.pop(i + 1)\n            result += '(' + match_parens(lst) + ')'\n        elif lst[i] == ')' and lst[i + 1] == '(':\n            result += lst[i]\n            lst.pop(i + 1)\n            result += '(' + match_parens(lst)\n        elif lst[i] == ')' and lst[i + 1] == ')':\n            return 'Yes'\n\n    if lst == []:\n        return result\n    else:\n        return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if lst == []:\n        return 'no'\n    elif len(lst) == 1:\n        return match_parens(lst[0])\n    else:\n        str1 = lst[0]\n        str2 = lst[1]\n        for index in range(len(str1)):\n            if index >= len(str2):\n                return 'no'\n            elif str1[index] == '(' and str2[index] == ')':\n                return 'no'\n            elif str1[index] == '(' and str2[index] == '(':\n                if match_parens(str1[index:]) == 'yes':\n                    return 'no'\n                elif match_parens(str2[0:index+1]) == 'yes':\n                    return 'yes'\n                else:\n                    return 'no'\n            elif str1[index] == ')' and str2[index] == '(':\n                if match_parens(str2[0:index+1]) == 'yes':\n                    return 'yes'\n                else:\n                    return 'no'\n            else:\n                if str1[index] == ')' and str2[index] == ')':\n                    return 'no'\n                elif str1[index] == '(' and str2[index] == ')':\n                    return 'yes'\n                else:\n                    return 'no'\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_match(lst, pos):\n        '''\n        This function will check if pos can be matched\n        :param lst: string list\n        :param pos: current position of pos\n        :return: True if pos is matched, False otherwise\n        '''\n        if pos >= len(lst) - 1:\n            return True\n        if lst[pos] == '(' and lst[pos+1] == '(' or lst[pos] == ')' and lst[pos+1] == ')':\n            return True\n        else:\n            return False\n\n    # Optimization, try to match the first position first\n    if is_match(lst, 0):\n        return 'Yes'\n    if is_match(lst, 1):\n        return 'Yes'\n    # Now try to match at position 2, 3, 4,... n\n    for pos in range(2, len(lst)):\n        if is_match(lst, pos):\n            return 'Yes'\n\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    if len(lst) == 1:\n        return 'No'\n\n    if lst[0] == '(' and lst[1] == ')':\n        return 'Yes'\n    if lst[0] == '(':\n        return match_parens([lst[1], ')'])\n\n    if lst[1] == ')':\n        return match_parens([lst[0], '('])\n\n    if lst[0] == ')':\n        return match_parens(['(', lst[1]])\n\n    return match_parens(['(', lst[0], ')'])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if not lst:\n        return 'Yes'\n    left = lst[0]\n    right = lst[1]\n    if left[0]!= '(':\n        return 'No'\n    if right[-1]!= ')':\n        return 'No'\n    if left[-1]!= ')':\n        return 'No'\n    if left[1]!= right[0]:\n        return 'No'\n    left = left[2:-1]\n    right = right[1:]\n    if not match_parens(left):\n        return 'No'\n    if not match_parens(right):\n        return 'No'\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if lst[0] == '(':\n        if lst[1]!= '(':\n            return 'No'\n    elif lst[0] == ')':\n        if lst[1]!= ')':\n            return 'No'\n    else:\n        return 'Yes'\n    for i in range(2, len(lst)):\n        if match_parens(lst[1:i]) == 'No':\n            return 'No'\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[1]!= ')':\n            return 'No'\n        if lst[0][-1]!= ')':\n            return 'No'\n        return 'Yes'\n\n    head = []\n    for i in lst[0]:\n        if i == '(':\n            head.append('(')\n        elif i == ')':\n            if len(head) == 0:\n                return 'No'\n            head.append(')')\n\n    tail = []\n    for i in lst[1]:\n        if i == '(':\n            tail.append('(')\n        elif i == ')':\n            if len(tail) == 0:\n                return 'No'\n            tail.append(')')\n\n    match = match_parens(head)\n    if match == 'No':\n        return match\n    match = match_parens(tail)\n    if match == 'No':\n        return match\n    if match == 'Yes':\n        return match\n\n'''", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def f(left, right):\n        # there is a possibility to match\n        if left[-1] == right[0]:\n            return True\n        # we can't match\n        else:\n            return False\n\n    result = True\n    stack = []\n\n    for char in lst[0]:\n        if char == '(':\n            stack.append(char)\n        else:\n            if not f(stack, char):\n                result = False\n\n    for char in lst[1]:\n        if char == '(':\n            stack.append(char)\n        else:\n            if not f(stack, char):\n                result = False\n\n    if result is True:\n        print('Yes')\n    else:\n        print('No')\n\nmatch_parens(['()(', ')'])\nmatch_parens([')', ')'])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def match_parens_helper(start_index):\n        if not start_index or not lst[start_index]:\n            return lst[start_index] == ')'\n        if len(lst) < start_index + 1:\n            return False\n        if lst[start_index] == ')':\n            return match_parens_helper(start_index + 1)\n        if not lst[start_index + 1] or lst[start_index + 1] == ')':\n            return False\n        if lst[start_index + 1] == '(':\n            return match_parens_helper(start_index + 2)\n        return False\n\n    if len(lst) == 1:\n        return lst[0] == ')'\n    if len(lst) == 2:\n        return match_parens_helper(0)\n    if not lst[-1]:\n        return match_parens_helper(-1)\n    if not lst[-2]:\n        return match_parens_helper(-2)\n    return match_parens_helper(-1)", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_balanced(s):\n        n = 0\n        for i in range(len(s)):\n            if s[i] == ')':\n                n -= 1\n            if s[i] == '(':\n                n += 1\n        return n == 0\n\n    def is_good(s):\n        for i in range(len(s)):\n            if s[i] == '(':\n                if not is_balanced(s[i+1:]):\n                    return False\n            if s[i] == ')':\n                if is_balanced(s[i+1:]):\n                    return False\n        return True\n\n    if len(lst) == 2:\n        if is_good(lst[0]) and is_good(lst[1]):\n            return 'Yes'\n        return 'No'\n\n    result = []\n    for i in range(len(lst)):\n        tmp = []\n        for j in range(len(lst)):\n            if j == i:\n                tmp.append(lst[i])\n            else:\n                tmp.append(lst[j])\n        result.append(tmp)\n    for i in range(len(result)-1):\n        if match_parens(result[i]) == match_parens(result[i+1]):\n            return 'Yes'\n    return 'No", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def find_open(str):\n        '''\n        find open parentheses in str.\n        return open parentheses and index\n        '''\n        str_lst = str.split('(')\n        for i, l in enumerate(str_lst):\n            if len(l) > 1:\n                return l, i\n        return None, None\n\n    def find_close(str):\n        '''\n        find close parentheses in str.\n        return close parentheses and index\n        '''\n        str_lst = str.split(')')\n        for i, l in enumerate(str_lst):\n            if len(l) > 1:\n                return l, i\n        return None, None\n\n    def is_balanced(str):\n        '''\n        check if string is balanced.\n        return bool\n        '''\n        open_lst = []\n        close_lst = []\n        for l in str:\n            if l == '(':\n                open_lst.append(l)\n            elif l == ')':\n                if len(open_lst) == 0:\n                    return False\n                close_lst.append(l)\n                open_lst.pop()\n        return len(open_lst) == 0\n\n    def check(lst):\n        '''\n        check if it's possible to concatenate two strings in some order.", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def find_match(lst, i):\n        '''\n        Find all matches for the two strings.\n        The matches should be in the same order as the given strings.\n        '''\n        if i == len(lst) - 1:\n            return lst[i], ''\n        while lst[i] == lst[i + 1]:\n            i += 1\n        if lst[i] == '(':\n            m1, m2 = find_match(lst, i + 1)\n            m1 += '('\n            m2 += ')'\n        else:\n            m1, m2 = find_match(lst, i + 1)\n            m2 += ')'\n        if len(m1) == len(lst[i]) and len(m2) == len(lst[i + 1]):\n            return m1, m2\n        else:\n            return None\n\n    def check_balance(s):\n        '''\n        Check the balance of the string.\n        '''\n        i = 0\n        while i < len(s):\n            if s[i] == '(':\n                if i == len(s) - 1:\n                    return True\n                if s[i + 1] == ')':\n                    i += 1\n            else:\n                if s[i] == ')':\n                    if i == 0:\n                        return True\n                    if s[i - 1] == '(':\n                        i -= 1", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def helper(lst):\n        if len(lst) == 0:\n            return ''\n        if len(lst) == 1:\n            if lst[0] == ')':\n                return ''\n            else:\n                return lst[0]\n        if len(lst) == 2:\n            if lst[0] == ')' and lst[1] == ')':\n                return ''\n            else:\n                return lst[1]\n        if lst[0] == ')' and len(lst[1:]) > 0:\n            return helper(lst[1:])\n        if len(lst) > 2:\n            if lst[0] == ')' and len(lst[1:]) > 0:\n                return helper(lst[1:])\n            if lst[1] == ')' and len(lst[2:]) > 0:\n                return helper(lst[2:])\n            if lst[0] == ')' and lst[1] == ')' and len(lst[2:]) > 0:\n                return helper(lst[2:])\n\n    return helper(lst) == ''\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def has_open_paren(s):\n        return s[0] == '('\n\n    def has_close_paren(s):\n        return s[-1] == ')'\n\n    def is_good(s):\n        n_open = 0\n        n_close = 0\n        for i, c in enumerate(s):\n            if c == '(':\n                n_open += 1\n            if c == ')':\n                n_close += 1\n        return n_open == n_close\n\n    def good_match(s):\n        return s.replace('(', '').replace(')', '')\n\n    if len(lst) <= 1:\n        return 'No'\n\n    head = lst[0]\n    if not has_open_paren(head) and not has_close_paren(head):\n        return 'Yes'\n\n    tail = lst[1]\n    if not has_open_paren(tail) and not has_close_paren(tail):\n        return 'Yes'\n\n    if match_parens([head]) == 'Yes' or match_parens([tail]) == 'Yes':\n        return 'Yes'\n\n    if not is_good(head):\n        return 'No'\n\n    for h in head:\n        if h == '(':\n            if match", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    parens_list = [['('], [')'], ['(', ')'], ['(', '(']]\n    for parens in parens_list:\n        print(parens)\n\n    str_1 = input('Input a string 1: ')\n    str_2 = input('Input a string 2: ')\n    print(match_parens([str_1, str_2]))\n\n\nmatch_parens(['()(', ')'])\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) <= 1:\n        return 'No'\n\n    list1 = lst[0]\n    list2 = lst[1]\n    first = None\n    second = None\n    balance = 0\n    result = []\n    index1 = 0\n    index2 = 0\n\n    while index1 < len(list1) and index2 < len(list2):\n        if list1[index1] == '(':\n            balance += 1\n            index1 += 1\n        elif list1[index1] == ')':\n            balance -= 1\n            index1 += 1\n\n        if list2[index2] == '(':\n            balance += 1\n            index2 += 1\n        elif list2[index2] == ')':\n            balance -= 1\n            index2 += 1\n\n        if balance == 0:\n            if first is None:\n                first = index1 - index2\n            else:\n                second = index2 - index1\n\n            result = [first, second]\n            first = None\n            second = None\n            balance = 0\n\n        else:\n            if first is None:\n                first = index1 - index2\n            else:\n                second = index2 - index1\n            balance = 0\n\n    if first is not None:\n        if second is not None:\n            result = [first, second]\n        else:\n            result.append(first)\n\n    if balance!=", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    cnt = 0\n    for i in range(len(lst)):\n        if lst[i] == '(':\n            cnt += 1\n        elif lst[i] == ')':\n            cnt -= 1\n            if cnt < 0:\n                return 'No'\n    return 'Yes'\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n\n    if len(lst) == 2:\n        return 'Yes'\n\n    # In this function, all elements are only '(' or ')'\n    # The first element is '(', ')', '(' or ')'\n    # The second element is '(', ')', '(' or ')'\n    if lst[0] == '(':\n        if lst[1] == '(':\n            # If both are '(', then we can make a good string\n            return 'Yes'\n        elif lst[1] == ')':\n            # If the first is '(', and the second is ')',\n            # we can only make a good string, if the first string\n            # is '(())', and the second string is ')'.\n            if match_parens(lst[1:]) == 'Yes':\n                return 'Yes'\n            else:\n                return 'No'\n        else:\n            # If the first element is '(', and the second element\n            # is ')', we can only make a good string if the first string\n            # is '()' and the second string is '('.\n            if match_parens(lst", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def dfs(st, c):\n        if not c:\n            return True\n        else:\n            for i in range(len(st)):\n                if st[i] == '(':\n                    if not dfs(st[i+1:], st[i+1:].count('(')):\n                        return False\n                else:\n                    if not dfs(st[i+1:], st[i+1:].count(')')):\n                        return False\n            return True\n\n    if len(lst) == 2:\n        return dfs(lst[0], lst[1].count('('))\n    else:\n        return False", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'No'\n\n    for i in xrange(len(lst)):\n        if lst[i] == '(' and i+1 < len(lst) and lst[i+1] == ')':\n            continue\n\n        if lst[i] == ')' and i-1 >= 0 and lst[i-1] == '(':\n            continue\n\n        return 'No'\n\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    paren_counts = [0] * (2**len(lst))\n    for i, item in enumerate(lst):\n        paren_counts[item] += 1\n\n    res = 0\n    for i, item in enumerate(lst):\n        for j, item2 in enumerate(lst):\n            if item == '(' and item2 == ')':\n                res += 1\n            elif item == '(' and item2 == '(':\n                res -= 1\n            elif item == ')' and item2 == '(':\n                res += 1\n            elif item == ')' and item2 == ')':\n                res -= 1\n\n    return res >= 0\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if lst == []:\n        return 'No'\n    if len(lst) == 1:\n        return lst[0] == ')'\n    return (match_parens(lst[1:]) if lst[0] == '(' else match_parens(lst[1:])) or lst[0] == ')'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    n = len(lst)\n    if n == 0:\n        return 'No'\n    elif n == 1:\n        return 'Yes'\n    s1 = ''\n    s2 = ''\n    for i in range(n):\n        s1 = s1 + lst[i]\n        if lst[i] == '(':\n            s2 = s2 + ')'\n    return match_parens([s1, s2])\n\n\n\n\n'''\nI don't know how to do this. Can you give me some hints?\n\nA:\n\nYour function returns Yes if there's a way to make a good string, and return No otherwise. This can be done by making a recursive function. The function should return Yes if both strings are good, or the second one is ')' and the first one is good, or the second one is '(' and the first one is good. Else it should return No.", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    while True:\n        if not lst:\n            return 'No'\n        head = lst.pop()\n        if head == '(':\n            if not lst:\n                return 'No'\n            tail = lst.pop()\n            if tail == '(':\n                lst.append(head)\n                continue\n            elif tail == ')':\n                if not lst:\n                    return 'No'\n                tail = lst.pop()\n                if tail == ')':\n                    lst.append(head)\n                    continue\n                elif tail == '(':\n                    continue\n                else:\n                    lst.append(head)\n                    lst.append(tail)\n                    continue\n            else:\n                lst.append(head)\n                lst.append(tail)\n                continue\n        else:\n            lst.append(head)\n            lst.append(tail)\n            continue</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    ans = ''\n    stack = []\n    for char in lst[0]:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            while len(stack)!= 0:\n                if stack[-1] == '(':\n                    stack.pop()\n                    break\n                else:\n                    ans += stack.pop()\n                    break\n        else:\n            ans += char\n    for char in lst[1]:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            while len(stack)!= 0:\n                if stack[-1] == '(':\n                    stack.pop()\n                    break\n                else:\n                    ans += stack.pop()\n                    break\n        else:\n            ans += char\n\n    while len(stack)!= 0:\n        ans += stack.pop()\n\n    return ans == ''", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) <= 1:\n        return 'No'\n    if lst[0] == '(':\n        if lst[1] == '(':\n            if match_parens(lst[2:]) == 'Yes':\n                return 'Yes'\n            else:\n                return 'No'\n        else:\n            if match_parens(lst[1:]) == 'Yes':\n                return 'Yes'\n            else:\n                return 'No'\n    elif lst[-1] == ')':\n        if match_parens(lst[:-1]) == 'Yes':\n            return 'Yes'\n        else:\n            return 'No'\n    else:\n        return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    elif len(lst) == 2:\n        return 'Yes'\n    else:\n        # we assume the first element in list is a string with less parens.\n        # example: match_parens(['(', '(())'])\n        lst[0] = list(reversed(lst[0]))\n        # if both of them are full of parens, return no.\n        if lst[0] == ['(', ')'] or lst[1] == ['(', ')']:\n            return 'No'\n        for first in lst[0]:\n            for second in lst[1]:\n                # we got two non-paren char, try to match them.\n                if (first == ')' and second == '(') or (first == '(' and second == ')'):\n                    # since we match a paren, we should update the second\n                    # element of lst to be reversed.\n                    lst[1] = list(reversed(lst[1]))\n                    if match_parens(lst) == 'Yes':\n                        return 'Yes'\n                else:\n                    if match_parens([first, second]) == 'Yes':\n                        return 'Yes'\n        return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # TODO\n    pass", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    '''\n    # dict mapping each type of parenthesis to the number of that type\n    # of parenthesis in the string.\n    def gen_count_dict(str):\n        count_dict = dict()\n        for char in str:\n            count_dict[char] = str.count(char)\n        return count_dict\n\n    def is_parens_balanced(str):\n        # make a list of pairs [(open, close)]\n        pairs = []\n        for i, char in enumerate(str):\n            if char == '(':\n                pairs.append(('(', ')'))\n            elif char == ')':\n                pairs.append((')', '('))\n        # count the number of open parens and close parens\n        count = 0\n        for pair in pairs:\n            if pair[0] == '(':\n                count += 1\n            else:\n                count -= 1\n        return count == 0\n\n    def match_parens(str1, str2):\n        '''\n        :str1: the first string\n        :str2: the second string\n        :returns: 'Yes' if str1 and str2 can be combined to make a good string, and 'No' otherwise\n        '''\n\n        str1_count_dict = gen_count_dict(str1)\n        str", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return (lst[0] == '()')\n    if len(lst) == 2:\n        return (lst[0] == '(' and lst[1] == ')')\n    if len(lst) == 3:\n        if (lst[0] == '(' and lst[1] == ')') or (lst[0] == ')' and lst[1] == '('):\n            return (lst[2] == ')')\n        return (lst[2] == ')' and (lst[0] == '(' or lst[1] == '('))\n    if len(lst) > 3:\n        for i in range(3, len(lst)):\n            if (lst[i] == ')' and (lst[i - 1] == '(' or lst[i - 2] == '(')):\n                return (lst[i - 1] == ')')\n            if (lst[i] == '(' and (lst[i - 1] == ')' or lst[i - 2] == ')')):\n                return (lst[i - 1] == '(')\n        return (lst[0] == '(' and lst[-1] == ')')\n\n\n\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # Valid for the string '()'\n    # Valid for the string '(())'\n    # Valid for the string '((()))'\n    # Valid for the string '(((()()))'\n    # Valid for the string '(((((()())()())())())())'\n    # Invalid for the string '(())()'\n    # Invalid for the string '())'\n\n    # Recursive function\n    def check(lst, left, right):\n        if left == [] and right == []:\n            return True\n        elif left == [] or right == []:\n            return False\n        else:\n            return check(left, right, lst[right]) and check(left, lst[right], right)\n\n    if not lst:\n        return True\n\n    left = []\n    right = []\n    for i in lst:\n        if i == '(':\n            left.append(i)\n        elif i == ')':\n            right.append(i)\n    return check(left, right, right[0])\n\nmatch_parens(['()(', ')'])\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    result = []\n    # print lst\n    if len(lst) == 0:\n        return \"No\"\n    elif len(lst) == 1:\n        return \"No\"\n    # print lst\n    for i in range(0, len(lst[0])):\n        result = []\n        for j in range(0, len(lst)):\n            result.append(match_parens(lst[j]))\n        if result == \"Yes\":\n            return \"Yes\"\n        elif result == \"No\":\n            return \"No\"\n    return \"No\"", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return 'Yes'\n        else:\n            return 'No'\n    if len(lst) > 2:\n        if lst[0] == '(' and lst[1] == ')':\n            return match_parens(lst[2:]) + '(' + lst[0] + ')'\n        if lst[0] == '(':\n            return match_parens(lst[1:]) + '(' + lst[0]\n        if lst[1] == ')':\n            return match_parens(lst[:1]) + ')'\n    return 'No'\n\nmatch_parens(['()(', ')'])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    result = ''\n    for i, el in enumerate(lst):\n        if i == 0:\n            continue\n        if el == '(':\n            result = result + ')'\n        else:\n            result = result + '('\n    if result == '':\n        return 'Yes'\n    return result\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'Yes'\n\n    paren_dict = {}\n    stack = []\n    for item in lst:\n        if item == '(':\n            stack.append('(')\n        elif item == ')':\n            stack.pop()\n            if len(stack) == 0:\n                paren_dict[item] = 1\n            else:\n                paren_dict[stack[-1]] += 1\n\n    if paren_dict['(']!= paren_dict[')']:\n        return 'No'\n    else:\n        return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def check(parens, stack):\n        '''\n        check if the stack is valid or not\n        parens: is the input string\n        stack: the stack\n        return: True if it's good, False otherwise\n        '''\n        for c in parens:\n            if c == '(':\n                stack.append(c)\n                return check(parens, stack)\n            elif c == ')':\n                if not stack or stack[-1]!= '(':\n                    return False\n                stack.pop()\n                return check(parens, stack)\n        else:\n            return not stack\n    return check(lst[0], []) and check(lst[1], [])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # Write your code here\n    def isValid(str):\n        return all(ch=='(' or ch==')' for ch in str)\n\n    def f(a, b):\n        result = ''\n        while len(a)>0 and len(b)>0:\n            if a[0] == '(' and b[0] == ')':\n                a.pop(0)\n                b.pop(0)\n                result += ')'\n            elif a[0] == ')':\n                a.pop(0)\n                result += '('\n            else:\n                b.pop(0)\n                result += ')'\n        if not a or not b:\n            return isValid(result)\n        return 'No'\n    return f(lst[0], lst[1])\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    # init\n    stack = []\n    # find all parentheses, and store them to stack\n    for char in lst[0]:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            while len(stack) > 0 and stack[-1]!= '(':\n                stack.pop()\n        else:\n            pass\n    # if there are only '(', ')', return 'No'\n    if len(stack) == 2:\n        return 'No'\n    # remove all parentheses from stack\n    while len(stack) > 0:\n        stack.pop()\n    # if the stack is empty, return 'Yes'\n    if len(stack) == 0:\n        return 'Yes'\n    # traverse each character of the second string\n    for char in lst[1]:\n        # if current character in the second string matches a '(' in stack,\n        # remove it\n        if char == '(':\n            while len(stack) > 0 and stack[-1] == '(':\n                stack.pop()\n        # if current character in the second string matches a ')' in stack,\n        # add it\n        elif char == ')':\n            stack.append(char)\n        else:\n            pass\n    # return 'Yes' if there's no '(' left in the", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n    else:\n        str1, str2 = lst\n        if not str1 or not str2:\n            return 'No'\n        if str2[-1]!= '(':\n            return 'No'\n        lst1 = str1.split(')')\n        lst2 = str2.split('(')\n        for i in range(len(lst1)):\n            if lst1[i][-1]!= '(':\n                lst1[i] += '('\n        for i in range(len(lst2)):\n            if lst2[i][0]!= ')':\n                lst2[i] += ')'\n        for i in range(len(lst1)):\n            if lst1[i][-1] == '(':\n                lst2[i] = lst2[i][:-1] + '(' + lst1[i]\n        for i in range(len(lst2)):\n            if lst2[i][0] == ')':\n                lst1[i] = lst1[i][:-1] + ')' + lst2[i]\n        str1 = '(' + ')'.join(lst1)\n        str2 = '(' + ')'.join(lst2)\n        if str1 and str2 and", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    is_even = True\n    length = len(lst[0])\n    for i in range(length):\n        if lst[0][i] == '(':\n            is_even = not is_even\n    if is_even:\n        if len(lst[0]) >= len(lst[1]):\n            return match_parens(lst[0] + lst[1])\n        else:\n            return match_parens(lst[1] + lst[0])\n    else:\n        if len(lst[0]) >= len(lst[1]):\n            return match_parens(lst[0] + lst[1])\n        else:\n            return match_parens(lst[1] + lst[0])\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) <= 1:\n        return 'Yes'\n\n    if lst[0] == ')' and lst[1] == '(':\n        return match_parens(lst[2:])\n\n    if lst[0] == '(' and lst[1] == ')':\n        return match_parens(lst[2:])\n\n    if lst[0] == ')':\n        return match_parens(lst[1:])\n\n    if lst[0] == '(':\n        return match_parens(lst[1:])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    good = True\n\n    if len(lst) > 2:\n        for i in range(len(lst) - 1):\n            if lst[i] == ')' and lst[i + 1] == '(':\n                good = False\n\n    return good", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if lst == [] or len(lst) == 1:\n        return 'Yes'\n\n    left = []\n    right = []\n    for c in lst[0]:\n        if c == '(':\n            left.append(c)\n        elif c == ')':\n            right.append(c)\n    for c in lst[1]:\n        if c == '(':\n            right.append(c)\n        elif c == ')':\n            left.append(c)\n\n    if not left or not right:\n        return 'Yes'\n\n    level = 0\n    # nesting stack\n    # only for debugging\n    stack = []\n\n    for i in xrange(len(left)):\n        c = left[i]\n        if c == '(':\n            stack.append(i)\n        elif c == ')':\n            # pop a level\n            if len(stack) == 0 or stack[-1] == len(left) - i - 1:\n                stack.pop()\n            else:\n                return 'No'\n        else:\n            return 'No'\n\n    for i in xrange(len(right)):\n        c = right[i]\n        if c == '(':\n            stack.append(i)\n        elif c == ')':\n            # pop a level\n            if len(stack) == 0 or stack[-1] == len(right", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def _check(lst):\n        if lst == [')']:\n            return True\n        if lst == ['(']:\n            return False\n\n        if lst[0] == '(':\n            if _check(lst[1:]):\n                return True\n            else:\n                return False\n        else:\n            if _check(lst[1:]):\n                return True\n            else:\n                return False\n\n    return _check(lst)\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    stack = []\n    for i in range(len(lst)):\n        if lst[i] == '(':\n            stack.append('(')\n        else:\n            if stack[-1] == '(':\n                stack.append(')')\n            else:\n                return 'No'\n\n    while len(stack) > 1:\n        if stack[-1]!= '(':\n            return 'No'\n        stack.pop()\n        if stack[-1] == '(':\n            stack.append(')')\n\n    return 'Yes'\n\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst)!= 2:\n        return 'No'\n\n    if lst[0][-1]!= '(' or lst[1][0]!= ')':\n        return 'No'\n\n    result = []\n    for x in lst[0][1:-1] + lst[1]:\n        if x == '(' or x == ')':\n            result.append(x)\n        else:\n            result.append(x.replace('(', '').replace(')', ''))\n\n    return len(result) == 0 or all(len(d) == 0 for d in result)", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_good(s):\n        stack = []\n        for i, c in enumerate(s):\n            if c == '(':\n                stack.append(i)\n            elif c == ')':\n                if len(stack) > 0:\n                    if i == stack[-1]:\n                        stack.pop()\n                    else:\n                        return False\n        return len(stack) == 0\n\n    def is_balanced(s):\n        stack = []\n        for i, c in enumerate(s):\n            if c == '(':\n                stack.append(i)\n            elif c == ')':\n                if len(stack) > 0:\n                    if i == stack[-1]:\n                        stack.pop()\n                    else:\n                        return False\n        return True\n\n    def merge(s_1, s_2):\n        if s_1[-1]!= ')':\n            return s_1 + ')' + s_2\n        else:\n            return s_1 + s_2\n    if len(lst) == 1:\n        return is_balanced(lst[0])\n    if len(lst) == 0:\n        return True\n    return is_balanced(merge(lst[0], lst[1]))", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def find_open_parens(lst):\n        if not lst:\n            return 0\n        open_parens = lst[0][-1]\n        return open_parens + len(lst[0][:-1])\n\n    def find_close_parens(lst):\n        if not lst:\n            return 0\n        open_parens = lst[-1][0]\n        return open_parens - len(lst[-1][1:])\n\n    def match_parens_helper(lst, i, j):\n        open_parens_i = find_open_parens(lst[:i])\n        open_parens_j = find_open_parens(lst[:j])\n\n        if open_parens_i == open_parens_j:\n            return match_parens_helper(lst, i + 1, j + 1)\n        else:\n            close_parens_i = find_close_parens(lst[:i])\n            close_parens_j = find_close_parens(lst[:j])\n\n            if open_parens_i == close_parens_j:\n                return match_parens_helper(lst, i + 1, j)\n            elif close_parens_i == open_parens_j:\n                return match_parens_helper(lst, i, j + 1)\n            else:\n                return False\n\n    return match_parens_helper(lst, 0, len(lst) - 1)", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    result = []\n    stack = []\n    for s in lst:\n        if s == '(':\n            stack.append(s)\n        elif s == ')':\n            if stack == []:\n                print('No')\n                return\n            top = stack.pop()\n            if top!= '(':\n                print('No')\n                return\n            result.append(top)\n        else:\n            result.append(s)\n    return result", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # write your code here\n    if len(lst)<2:\n        return 'No'\n    len1=len(lst[0])\n    len2=len(lst[1])\n    if len1>len2:\n        return 'No'\n    if len2>=len1:\n        return match_parens(lst[::-1])\n    if '(' in lst[0] and ')' not in lst[0]:\n        return 'Yes'\n    if ')' in lst[0] and '(' not in lst[0]:\n        return 'Yes'\n    if '(' in lst[1] and ')' not in lst[1]:\n        return 'Yes'\n    if ')' in lst[1] and '(' not in lst[1]:\n        return 'Yes'\n    if '(' in lst[0] or '(' in lst[1]:\n        return 'Yes'\n    return 'No'</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def is_valid(lst):\n        lst.append(')')\n        for i in range(0, len(lst) - 1):\n            if lst[i] == '(' and lst[i + 1] == ')':\n                return False\n        return True\n\n    new_list = lst[1] + lst[0]\n    if is_valid(new_list):\n        return 'Yes'\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    return match_parens(lst[1:]) + lst[0] if lst[0] == '(' else 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(paren_str):\n        open_count = 0\n        for ch in paren_str:\n            if ch == '(':\n                open_count += 1\n            elif ch == ')':\n                open_count -= 1\n            if open_count < 0:\n                return False\n        return True\n\n    def is_valid(paren_str1, paren_str2):\n        if not paren_str1 or not paren_str2:\n            return False\n        if paren_str1[0]!= paren_str2[0]:\n            return False\n        if is_balanced(paren_str1) and is_balanced(paren_str2):\n            return True\n        return False\n\n    result = []\n    if not lst:\n        return \"No\"\n    for sub in lst:\n        if not sub:\n            continue\n        sub1 = sub[0]\n        sub2 = sub[1]\n        if is_valid(sub1, sub2):\n            result.append(sub1 + sub2)\n        else:\n            result.append(sub1 + sub2[0] + sub2[1:])\n    return result if result else \"No\"\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    return True", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # debug\n    # print(lst)\n    # find the number of parentheses in a string\n    def num_parens(s):\n        return sum(1 for c in s if c == '(' or c == ')')\n    # find the maximum number of parentheses\n    def max_num_parens(lst):\n        if not lst:\n            return 0\n        # debug\n        # print(lst)\n        return max(num_parens(s) for s in lst)\n    # get the string with the maximum number of parentheses\n    def max_num_str(lst):\n        return lst[max_num_parens(lst)]\n    # debug\n    # print(max_num_str(lst))\n    # get the length of the string with the maximum number of parentheses\n    def max_num_len(lst):\n        return len(max_num_str(lst))\n    # debug\n    # print(max_num_len(lst))\n    # get the string with the minimum number of parentheses\n    def min_num_str(lst):\n        return lst[min_num_parens(lst)]\n    # debug\n    # print(min_num_str(lst))\n    # get the length of the string with the minimum number of parentheses\n    def min_num_len(lst):\n        return len(min", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    global stack\n    global open_p, close_p\n\n    if len(lst) == 0:\n        return 'No'\n    if len(lst) == 1:\n        if lst[0] == '(':\n            stack = [lst[0]]\n            open_p += 1\n        elif lst[0] == ')':\n            stack.append(lst[0])\n            open_p -= 1\n            if open_p == 0:\n                return 'Yes'\n        return 'Yes'\n\n    if lst[1] == '(':\n        stack = [lst[1]]\n        open_p += 1\n    elif lst[1] == ')':\n        stack.append(lst[1])\n        open_p -= 1\n        if open_p == 0:\n            return match_parens(lst[2:])\n    return match_parens(lst[2:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def match_brackets(lst):\n        '''\n        You are given a list of two strings, both strings consist of open\n        brackets '(' or close brackets ')' only.\n        Your job is to check if it is possible to concatenate the two strings\n        in some order, that the resulting string will be good.\n        A string S is considered to be good if and only if all brackets in S\n        are balanced. For example: the string '()()()' is good, while the string\n        ')()()' is not.\n        Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n        Examples:\n        match_brackets(['(()', ')']) == 'Yes'\n        match_brackets([')', '()']) == 'No'\n        '''\n        if len(lst) == 1:\n            return 'Yes'\n        else:\n            lst = lst[1]\n            if lst.startswith('(') and lst.endswith(')'):\n                return 'Yes'\n        return 'No'\n    while len(lst) > 0:\n        if match_parens(lst) == 'No':\n            return 'No'\n        else:\n            tmp_lst = lst[:]\n            if match_brackets(", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def recurse(left, right):\n        '''\n        `left` and `right` are lists of characters, which are either '(' or ')'.\n        Return True if the concatenation of `left` and `right` is good, and\n        return False otherwise.\n        '''\n        if len(left) == 0 and len(right) == 0:\n            return True\n        if len(left) == 0:\n            return False\n        if len(right) == 0:\n            return False\n        left.pop(0)\n        right.pop(0)\n        return recurse(left, right + [left[0]]) and recurse(left + [right[0]], right)\n\n    return recurse(lst[0], lst[1])\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    n = len(lst)\n    if n < 2:\n        return \"No\"\n    mid = len(lst) // 2\n    left = match_parens(lst[:mid])\n    right = match_parens(lst[mid:])\n    if left == \"No\":\n        return right\n    if right == \"No\":\n        return left\n    if len(lst) == 2:\n        return \"Yes\"\n\n    # Determine the first and the last positions of the non-parenthesis characters.\n    lfirst = mid - 1\n    llast = mid\n    rfirst = mid\n    rlast = mid + 1\n    for i in range(mid):\n        if lst[i] == '(':\n            lfirst = i + 1\n        elif lst[i] == ')':\n            llast = i + 1\n        else:\n            rfirst = i\n            rlast = i\n\n    # left will be the substring from the (a + 1)th character to the bth character\n    # and right will be the substring from the (b + 1)th character to the (c + 1)th character.\n    left = lst[lfirst:llast + 1]\n    right = lst[rfirst:rlast + 1]\n    if left == '(' and right == ')':\n        return \"Yes\"\n    elif left", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if not lst:\n        return 'Yes'\n\n    stack = []\n    for i, s in enumerate(lst):\n        if s == '(':\n            stack.append('(')\n        elif s == ')':\n            if not stack:\n                return 'No'\n            if stack[-1] == '(':\n                stack.pop()\n            else:\n                return 'No'\n        else:\n            return 'No'\n\n    if len(stack)!= 0:\n        return 'No'\n\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def valid(s):\n        n = 0\n        for i, c in enumerate(s):\n            if c == '(':\n                n += 1\n            elif c == ')':\n                n -= 1\n            if n < 0:\n                return False\n        return True\n\n    def is_consonant(c):\n        return c in \"abcdefghijklmnopqrstuvwxyz\"\n\n    def check(a, b):\n        if a == b:\n            return True\n        elif a[-1] == ')' and is_consonant(b[0]):\n            b = b[1:]\n            return check(a[:-1], b)\n        elif b[-1] == '(' and is_consonant(a[0]):\n            a = a[1:]\n            return check(a, b[:-1])\n        else:\n            return False\n\n    # You are given two strings, check if they can be concatenated and form a good string\n    a = lst[0]\n    b = lst[1]\n    if not valid(a):\n        return False\n    if not valid(b):\n        return False\n\n    for i in range(len(a)):\n        if check(a[:i], b):\n            return True\n    return False", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    stack = []\n    for x, y in lst:\n        if x == '(':\n            stack.append('(')\n        elif x == ')':\n            if len(stack) == 0:\n                return 'No'\n            if stack[-1]!= '(':\n                return 'No'\n            stack.pop()\n    if len(stack) == 0:\n        return 'Yes'\n    return 'No'\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    # find all substrings from each list in the list\n    sub_list = [list(filter(None, re.split(r'(\\(|\\))', i))) for i in lst]\n    # print(sub_list)\n    # find the longest substring in all sub_lists\n    max_lst = max([len(x) for x in sub_list])\n    # print(max_lst)\n\n    # construct a matrix for the substrings\n    mtrx = [[0] * max_lst for _ in range(len(sub_list))]\n    for i in range(len(sub_list)):\n        for j in range(len(sub_list[0])):\n            mtrx[i][j] = sub_list[i][j]\n\n    # check all cells in the matrix\n    for i in range(len(sub_list)):\n        for j in range(len(sub_list[0])):\n            if (mtrx[i][j] == '(') or (mtrx[i][j] == ')'):\n                is_balanced = True\n                for k in range(i, len(sub_list)):\n                    for l in range(j, len(sub_list[0])):\n                        if (mtrx[k][l] == '(') and (mtrx[i][j]", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    n = len(lst)\n\n    if n <= 2:\n        return 'Yes' if n == 2 else 'No'\n\n    curr = lst[1]\n    lst = lst[2:]\n    is_balanced = True\n\n    while lst:\n        if curr[-1] == ')':\n            if curr[0] == '(':\n                curr = curr[1:]\n            else:\n                is_balanced = False\n                break\n        else:\n            if curr[0] == '(':\n                curr = curr[1:]\n            else:\n                is_balanced = False\n                break\n        lst = lst[1:]\n\n    return 'Yes' if is_balanced else 'No'\n\n\n'''\nRefer:\n\nhttps://leetcode.com/problems/match-parens/description/\n\nLeetcode link:\n\nhttps://leetcode.com/problems/match-parens/\n'''", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if not lst:\n        return 'Yes'\n    opentags, closetags = lst\n    ret = match_parens(opentags)\n    if ret == 'Yes':\n        if len(opentags) + len(closetags) == 0:\n            return 'Yes'\n        return ret + match_parens(closetags)\n    return ret", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    paren_str = []\n\n    for i in range(len(lst)):\n        if lst[i] == '(':\n            paren_str.append('(')\n        else:\n            paren_str.append(')')\n\n    if paren_str[0] == paren_str[-1]:\n        return False\n    else:\n        for i in range(len(paren_str)):\n            if paren_str[i] == '(' and paren_str[i]!= '(':\n                return False\n            elif paren_str[i] == ')' and paren_str[i]!= ')':\n                return False\n\n    for i in range(len(paren_str)):\n        if paren_str[i] == '(' and paren_str[i+1] == ')':\n            return False\n        elif paren_str[i] == ')' and paren_str[i+1] == '(':\n            return False\n\n    return True", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    stack = [['(', ')'], '']\n\n    while len(stack) > 1:\n        current = stack.pop(0)\n\n        if current[-1] == '(':\n            stack.append(current + ['('])\n        else:\n            stack.append(current + [')'])\n\n    return stack[0][-1] == '('", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    # dp dp dp dp dp dp dp\n    def memoize(func):\n        ''' https://stackoverflow.com/questions/8669092/memoization-in-python '''\n        memo = {}\n        def wrapper(*args):\n            if args in memo:\n                return memo[args]\n            else:\n                rv = func(*args)\n                memo[args] = rv\n                return rv\n        return wrapper\n\n    memoized = memoize(lambda s: sum(1 for char in s if char in '('))\n\n    def helper(lst):\n        return memoized(''.join(map(str, lst)))\n\n    def solve(lst):\n        if len(lst) == 1:\n            return True\n        elif len(lst) == 2:\n            return helper(lst) == 1\n\n        return solve(lst[:-1]) and solve(lst[1:])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    import itertools\n\n    def generate_possibilities(string1, string2):\n        for i in range(len(string1) - len(string2) + 1):\n            for j in range(len(string2)):\n                yield [string1[i:i + j] + string2[j]]\n\n    if len(lst) == 1:\n        if len(lst[0]) == 0:\n            return \"Yes\"\n        elif len(lst[0]) == 1:\n            return \"No\"\n\n    possibilities = list(generate_possibilities(lst[0], lst[1]))\n\n    for i in range(len(possibilities)):\n        if match_parens(possibilities[i]) == \"Yes\":\n            return \"Yes\"\n\n    return \"No\"</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    for _ in range(2):\n        if len(lst) == 0:\n            return 'No'\n        elif len(lst) == 1:\n            return 'Yes'\n        elif lst[0][-1] == lst[1][0]:\n            return match_parens(lst[1:])\n        elif lst[0][-1]!= lst[1][0]:\n            return 'No'\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) <= 1:\n        return 'No'\n    result = ''\n    for s in lst:\n        if s == '(':\n            result += '('\n        elif s == ')':\n            if not result[-1] == '(':\n                return 'No'\n            result += ')'\n    return 'Yes' if result[-1] == ')' else 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    lst = sorted(lst)\n    for i in range(len(lst[0]) + 1):\n        for j in range(len(lst[1]) + 1):\n            if lst[0][i:] + lst[1][j:]!= ')':\n                new_lst = lst[0][:i] + lst[1][j:] + lst[0][i + len(lst[1][j]):]\n                if match_parens(new_lst) == 'Yes':\n                    return 'Yes'\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    if len(lst) < 1:\n        return None\n\n    open_peices = []\n    close_peices = []\n    for i in lst:\n        if i == '(':\n            open_peices.append(i)\n        else:\n            close_peices.append(i)\n\n    if len(close_peices) < len(open_peices):\n        return None\n\n    return match_parens(open_peices) and match_parens(close_peices)", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if not lst:\n        return 'No'\n    stack = []\n    for char in lst[0]:\n        if char == '(':\n            stack.append(char)\n        elif char == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                stack.pop()\n    if len(stack)!= 0:\n        return 'No'\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    if not lst:\n        return 'No'\n\n    n = len(lst[0])\n\n    # give a temporary head to help\n    # find a good string, for example, '('\n\n    # init the first string, that is, '(', ')', or '('\n\n    head = '('\n    for i in range(n):\n        if lst[0][i] == '(':\n            head += '('\n        else:\n            head += ')'\n\n    # init the second string, that is, '(', ')', or '('\n\n    head2 = '('\n    for i in range(n):\n        if lst[1][i] == '(':\n            head2 += '('\n        else:\n            head2 += ')'\n\n    # build a good string, that is, a string that is\n    # '((()))('\n\n    stack = [head, head2]\n    res = head2\n    i = 0\n    while i < n:\n        if stack[0][i] == '(':\n            res += '('\n        else:\n            res += ')'\n\n        if stack[1][i] == '(':\n            res += '('\n        else:\n            res += ')'\n\n        i += 1\n        if", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    stack = []\n    for s in lst:\n        if s == '(':\n            stack.append('(')\n        else:\n            if stack and stack[-1] == '(':\n                stack[-1] = ')'\n            else:\n                return 'No'\n\n    if stack:\n        return 'No'\n\n    return 'Yes'\n\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        if lst[0] == ')' and lst[1] == '(':\n            return 'No'\n        if lst[0] == '(' and lst[1] == ')':\n            return 'No'\n        return 'Yes'\n    stack = []\n    for item in lst:\n        if item == '(':\n            stack.append(item)\n        elif item == ')':\n            while True:\n                if stack[0]!= '(':\n                    return 'No'\n                stack.pop()\n                if len(stack) == 0:\n                    return 'Yes'\n                if stack[0] == '(':\n                    stack.append(item)\n                    break", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    lst = lst.split(' ')\n    return match_parens_helper(lst)", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if lst[0] == '(' and lst[-1] == ')':\n        return 'Yes'\n    elif lst[0] == ')' and lst[-1] == '(':\n        return 'Yes'\n    elif lst[0] == ')' and lst[-1] == ')':\n        return 'No'\n    elif lst[0] == '(' and lst[-1] == '(':\n        return 'No'\n    return None", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    if len(lst) == 0:\n        return 'No'\n\n    for i in range(len(lst)-1):\n        if lst[i] == ')' and lst[i+1] == '(':\n            return match_parens(lst[:i] + [')'] + lst[i+1:])\n\n    if lst[0] == '(':\n        if lst[-1] == ')':\n            return match_parens(lst[:-1] + ['('])\n        else:\n            return 'No'\n    else:\n        return 'No'\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    open_parens = set('()')\n    close_parens = set('()')\n\n    check = set('()')\n\n    if len(lst)!= 2:\n        return 'Error'\n\n    for i in lst:\n        if i in close_parens:\n            check.remove(i)\n        elif i in open_parens:\n            check.remove(i)\n        else:\n            return 'Error'\n\n    if not check:\n        return 'Yes'\n    elif len(check) == 2:\n        return 'Error'\n\n    # If there are only two parens left, that's enough.\n    if len(check) == 2:\n        return 'Yes'\n\n    for i in lst:\n        for j in check:\n            check = set(check) - set('()')\n            check.add(i + j)\n            if not match_parens([lst[0] + i + j]):\n                return 'Error'\n            check = set(check) - set('()')\n            check.add(i + lst[1] + j)\n            if not match_parens([lst[1] + i + j]):\n                return 'Error'\n            check = set(check) - set('()')\n            check.add(i + j + lst[1]", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    open_paren = '('\n    close_paren = ')'\n    # Turn list into tuple to make sure the order of elements doesn't affect the answer.\n    lst = tuple(lst)\n    # The first element in the tuple will always be the left most string. The other\n    # string will always be the right most string.\n    left_string = lst[0]\n    right_string = lst[1]\n\n    def can_be_concat(left, right):\n        '''\n        Return True if the given strings can be concatenated to form a good string.\n        Return False otherwise.\n        '''\n        # Concatenate left and right strings.\n        temp_string = left_string + right_string\n        if not is_balanced(temp_string):\n            return False\n        else:\n            return True\n\n    if len(lst) == 1:\n        return can_be_concat(left_string, right_string)\n\n    # Break the given list into two sub lists, the left and the right.\n    left = lst[:-1]\n    right = lst[-1:]\n\n    # Process the left string.\n    if len(left) == 1:\n        # The left string consists of one element only. Check if the element is\n        # a '(' or a ')'.\n        if left_string == open_paren:\n            # The left string", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def traverse(node, lst):\n        if not node:\n            return True\n        if lst[0] == node[0]:\n            return traverse(node[1:], lst[1:])\n        return False\n\n    return traverse(lst[0], lst[1])\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    # Base case - if there is only one string\n    if len(lst) == 1:\n        if lst[0] == '':\n            return False\n        return True\n\n    # If first and last items are not ( or ) return false\n    if lst[0]!= '(' and lst[-1]!= ')':\n        return False\n\n    # If first and last items are not ( or ) return false\n    if lst[0]!= '(' and lst[-1]!= ')':\n        return False\n\n    # If first item is (), it will have to be closed first\n    if lst[0] == '(':\n        if match_parens(lst[1:]) == False:\n            return False\n\n    # If last item is (), it will have to be closed last\n    if lst[-1] == ')':\n        if match_parens(lst[:-1]) == False:\n            return False\n\n    # If there are multiple ( or ), one of them has to be closed first\n    if len(lst) > 2:\n        if lst[0] == '(' and lst[-1] == ')':\n            if match_parens(lst[1:-1]) == False:\n                return False\n        elif lst[0] == '(' and lst[-1]!= ')':\n            if match_parens(lst[1:])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'Yes'\n    if len(lst) == 2:\n        if lst[0][-1] == ')' and lst[1][0] == '(':\n            return 'Yes'\n        else:\n            return 'No'\n\n    first = lst[0]\n    second = lst[1]\n    if match_parens([first[1:-1], second[1:]]) == 'Yes':\n        return 'Yes'\n    elif match_parens([first, second[1:-1]]) == 'Yes':\n        return 'Yes'\n    else:\n        return 'No'\n\nmatch_parens(['()(', ')'])</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def _add_parens(lst):\n        if len(lst) == 1:\n            return lst[0]\n        if lst[1] == '(':\n            return _add_parens(lst[0]) + '(' + lst[1]\n        if lst[1] == ')':\n            return _add_parens(lst[0]) + lst[1]\n    lst = [_add_parens(lst), _add_parens(lst)]\n    if lst[0] == '()':\n        return 'Yes'\n    if lst[1] == '()':\n        return 'Yes'\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return lst[0] == lst[1]\n    if lst[0]!= lst[1]:\n        return 'No'\n    return match_parens(lst[0].split('(')) + match_parens(lst[1].split('('))", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    if not lst:\n        return 'No'\n    if len(lst) == 1:\n        return match_parens(lst[0].split(')'))\n\n    for i in range(len(lst)):\n        if len(lst[i].split('('))!= len(lst[i].split(')')):\n            return 'No'\n\n    result = []\n    for i in range(len(lst)):\n        result += lst[i].split('(')\n\n    result = match_parens(result)\n\n    for i in range(len(result)):\n        result[i] = '('.join(result[i].split(')'))\n\n    result = ''.join(result)\n\n    if result == '()':\n        return 'No'\n\n    if result.count('(') == result.count(')'):\n        return 'Yes'\n\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    lst = ['(']\n    while lst[0]!= ')':\n        if lst[0] == '(':\n            if lst[1] == '(':\n                lst = lst[2:] + lst[:2]\n            else:\n                lst = lst[1:]\n        else:\n            if lst[1] == '(':\n                lst = lst[2:] + lst[:2]\n            else:\n                lst = lst[1:]\n    if lst[0] == ')':\n        return 'Yes'\n    else:\n        return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    parens = len(lst[0])\n    if parens > len(lst[1]):\n        return 'No'\n    for i in range(parens):\n        if lst[0][i]!= '(' and lst[0][i]!= ')':\n            return 'No'\n    for i in range(len(lst[0])):\n        if lst[1][i]!= '(' and lst[1][i]!= ')':\n            return 'No'\n    for i in range(len(lst[1])):\n        if lst[0][i] == '(':\n            if lst[1][i] == '(':\n                if lst[0][parens - 1] == ')':\n                    if lst[1][parens - 1] == ')':\n                        return 'Yes'\n                else:\n                    return 'No'\n            else:\n                if lst[1][parens - 1] == ')':\n                    if lst[0][parens - 1] == ')':\n                        return 'Yes'\n                else:\n                    return 'No'\n        else:\n            if lst[1][parens - 1] == ')':\n                if lst[0][parens - 1] == ')':\n                    return 'Yes'\n            else:\n                return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # write your code here\n    pass\n\n'''\nmatch_parens(['()(', ')']) == 'Yes'\nmatch_parens([')', ')']) == 'No'\nmatch_parens(['(', '(']) == 'Yes'\nmatch_parens(['(', '(', '(']) == 'Yes'\nmatch_parens(['(', '(']) == 'No'\nmatch_parens([')', '(']) == 'No'\n'''", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # c = count of open parentheses\n    # o = offset of open parentheses\n    # return True if the concatenation is valid and false otherwise\n    c = 0\n    o = 0\n    for l in lst:\n        if l == '(':\n            c += 1\n        if l == ')':\n            o -= 1\n        if c == 0 and o == 0:\n            return True\n        if c == 0 and o!= 0:\n            return False\n        if o!= 0 and c!= 0:\n            return False\n    return False", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i][-1] == lst[j][-1]:\n                if lst[i][-1] == '(':\n                    if match_parens(lst[:i] + lst[j+1:]) == 'No':\n                        return 'No'\n                elif lst[i][-1] == ')':\n                    if match_parens(lst[:i] + lst[j+1:]) == 'No':\n                        return 'No'\n\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def match_parens_rec(lst, res):\n        if not lst:\n            return res\n\n        first, second = lst[0], lst[1]\n\n        if first == '(' and second == ')':\n            if res[-1] == '(':\n                return match_parens_rec(lst[1:], res + '(')\n            else:\n                return match_parens_rec(lst[1:], res + ')')\n\n        if first == '(' or second == '(':\n            return match_parens_rec(lst[1:], res + first)\n\n        if first == ')' or second == ')':\n            return match_parens_rec(lst[1:], res + second)\n\n        return None\n\n    res = ''\n    return match_parens_rec(lst, res)</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if not lst:\n        return 'Yes'\n\n    if not isinstance(lst[0], str) or not isinstance(lst[1], str):\n        return 'Yes'\n\n    if lst[0][-1]!= ')' or lst[1][0]!= '(':\n        return 'Yes'\n\n    for i in range(len(lst[0]) - 1):\n        if lst[0][i]!= ')':\n            return 'Yes'\n\n    for j in range(len(lst[1]) - 1):\n        if lst[1][j]!= '(':\n            return 'Yes'\n\n    for i in range(len(lst[0]) - 1):\n        if lst[0][i]!= ')':\n            for j in range(len(lst[1]) - 1):\n                if lst[1][j]!= '(':\n                    if match_parens(lst[0][:i + 1] + lst[1][:j] + lst[0][i + 1:] + lst[1][j + 1:]):\n                        return 'Yes'\n\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def count_parens(lst):\n        '''\n        :param lst: the given list\n        :return: the number of the parenthesis in the list\n        '''\n        count = 0\n        for item in lst:\n            if item == '(':\n                count += 1\n            elif item == ')':\n                count -= 1\n        return count\n\n    # if there are only one of the parentheses, return 'No'\n    if len(lst) == 1:\n        return 'No'\n\n    # at least one of the parentheses contains a comma, return 'No'\n    if any(char == ',' for char in lst[0]):\n        return 'No'\n\n    # if the first and second element of the list both are '(' or ')'\n    # return 'No'\n    if lst[0] == lst[1]:\n        return 'No'\n\n    # if there is a ')' in the first string\n    if lst[0][-1] == ')':\n        count = count_parens(lst)\n        if count % 2!= 0:\n            return 'No'\n\n    # if there is a '(' in the second string\n    if lst[1][0] == '(':\n        count = count_parens(lst)\n        if count % 2!= 0:\n            return 'No'\n\n    # if both the first and second", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    stack = []\n    for item in lst:\n        if item == '(':\n            stack.append('(')\n        elif item == ')':\n            while len(stack) > 0 and stack[-1]!= '(':\n                stack.pop()\n            if len(stack) == 0:\n                return 'No'\n            else:\n                stack.pop()\n\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def _match_parens(lst, i, j):\n        '''\n        The recursive method\n        '''\n        if i >= len(lst):\n            return j >= len(lst[0]) and True or False\n        if j >= len(lst[0]):\n            return True\n\n        # One of the parenthesis is already closed, so we can close the\n        # other one and return True\n        if lst[i][j] == ')':\n            return _match_parens(lst, i + 1, j + 1) and True or False\n\n        # If we see a '(', we should match it with the next '(' or ')'\n        if lst[i][j] == '(':\n            return _match_parens(lst, i + 1, j) or _match_parens(lst, i + 1, j + 1) and True or False\n\n        return False\n\n    return _match_parens(lst, 0, 0) and True or False\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n\n    stack = []\n    for i in range(len(lst)):\n        if lst[i] == '(':\n            stack.append(i)\n        elif lst[i] == ')':\n            if len(stack) == 0:\n                return 'No'\n            return 'Yes' if stack.pop() == (i - 1) else 'No'\n        else:\n            return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    # Trim trailing whitespaces\n    trim_list = [lst[0].rstrip(), lst[1].rstrip()]\n\n    # Check if there are open parentheses in both strings\n    if trim_list[0].count('(')!= trim_list[1].count('('):\n        return 'No'\n\n    # Perform the algorithm\n    left_string = trim_list[0]\n    right_string = trim_list[1]\n\n    # Make a copy of left string\n    result = [left_string]\n\n    # Count parentheses in left string\n    left_paren = 0\n\n    # Try to match parentheses in right string\n    while left_paren!= right_string.count('('):\n        # Pop a character from left string\n        left_char = left_string.pop(0)\n\n        # Check if there's an open parenthesis in left string\n        if left_char == '(':\n            left_paren += 1\n\n        # Check if there are matching parentheses in right string\n        elif left_char == ')':\n            if right_string.count('(') > left_paren:\n                return 'No'\n\n        # Check if there are matching parentheses in right string\n        else:\n            # Find matching pair of parentheses\n            right_paren = 0\n            while right_char == '(' or right_char", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    n = len(lst)\n    m = [0] * n\n    j = 0\n    for i in range(1, n):\n        if lst[i] == ')' and lst[i - 1]!= '(':\n            m[i] = 0\n        elif lst[i] == '(' and lst[i - 1]!= ')':\n            m[i] = 1\n        else:\n            j += 1\n            if j == 2:\n                return 'No'\n            j = 0\n    if j!= 0:\n        return 'No'\n    for i in range(n):\n        if m[i] == 1:\n            j = 0\n            for j in range(i + 1, n):\n                if m[j] == 1:\n                    m[j] = 0\n                    break\n            else:\n                return 'No'\n        elif m[i] == 0:\n            j = 0\n            for j in range(i, -1, -1):\n                if m[j] == 0:\n                    m[j] = 1\n                    break\n            else:\n                return 'No'\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if not lst:\n        return 'No'\n    if not isinstance(lst[0], str):\n        return 'No'\n    if len(lst) == 1:\n        return match_parens(lst[0].split(')'))\n    if lst[0].endswith(')') or lst[0].endswith('('):\n        return 'No'\n    if lst[0] == '(':\n        first, rest = lst[0], lst[1]\n    else:\n        first, rest = lst[1], lst[0]\n    if rest.startswith(')'):\n        return match_parens(rest.split(')'))\n    if rest.startswith('('):\n        if first == ')':\n            return match_parens([rest])\n        if rest.endswith(')'):\n            rest = rest[1:]\n            if rest.startswith('('):\n                return match_parens([rest])\n            return 'No'\n        else:\n            if rest.endswith('('):\n                rest = rest[1:]\n                return match_parens([rest])\n            else:\n                return 'No'\n    if first == '(':\n        return match_parens(rest.split(')'))\n    if first == ')", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # Return True if both strings are empty\n    if len(lst) == 0:\n        return True\n    # Get the length of the longest string\n    L = len(max(lst, key=len))\n\n    # Iterate through all possible combinations, return True if all\n    # combinations are good\n    for i in range(0, L + 1):\n        # Build up the start string, left most\n        if i == 0:\n            left = '(' * L\n            middle = ''\n        else:\n            left = ''\n            middle = '(' * (L - i - 1)\n        # Build up the end string, right most\n        if i == L:\n            right = ')' * L\n            middle = ''\n        else:\n            right = ''\n            middle = ')' * (L - i - 1)\n        for j in range(0, i + 1):\n            left += middle\n            right += middle\n            if match_parens([left, right]):\n                return True\n    return False", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # ############### Solution ##################\n    # We are given two strings, both strings consist of '(' and ')' only.\n    # Find the minimum open parentheses from the first string.\n    # Iterate the second string with open parentheses that is the same\n    # number as minimum open parentheses and find the minimum closed\n    # parentheses from the second string.\n    # Concatenate the two strings and find the number of open parentheses\n    # and closed parentheses.\n    # Compare the number of open and closed parentheses and return the result.\n    # ####################################################\n    # ############### Solution ##################\n    # We can use the following approach:\n    # 1. Create a dictionary where the keys are the open parentheses and the\n    # value is the number of open parentheses.\n    # 2. Create another dictionary where the keys are the closed parentheses\n    # and the value is the number of closed parentheses.\n    # 3. Get the minimum open parentheses from the first string.\n    # 4. Find the corresponding closed parentheses and find the minimum\n    # open parentheses from the second string.\n    # 5. Concatenate the two strings and find the number of open parentheses\n    # and closed parentheses.\n    # 6. Compare the number of open and closed parentheses and return the result.\n\n    # 1", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    else:\n        res = []\n        for i in lst:\n            if i == '(':\n                if '(' not in res:\n                    res.append('(')\n                else:\n                    res.append(')')\n            elif i == ')':\n                if ')' not in res:\n                    res.append(')')\n                else:\n                    res.append('(')\n        if '(' in res or ')' in res:\n            return 'No'\n        return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    n = len(lst)\n    m = n//2\n    i, j = 0, m\n    while i < j:\n        if lst[i] == lst[j]:\n            if lst[i] == '(':\n                i += 1\n            else:\n                j -= 1\n        elif lst[i] == ')' and lst[j] == '(':\n            i += 1\n            j -= 1\n        elif lst[i] == ')' and lst[j] == ')':\n            j -= 1\n        elif lst[i] == '(' and lst[j] == ')':\n            i += 1\n        else:\n            return 'No'\n        if i == m or j == 0:\n            return 'Yes'\n    return 'No'\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # Start typing your function below\n    # hint: use recursive\n\n    def match_parens_rec(lst, d):\n        if len(lst) == 0:\n            if d == 0:\n                return True\n            else:\n                return False\n        if lst[0] == '(':\n            if d == 0:\n                return match_parens_rec(lst[1:], d + 1)\n            else:\n                return match_parens_rec(lst[1:], d)\n        if lst[0] == ')':\n            if d == 0:\n                return match_parens_rec(lst[1:], d - 1)\n            else:\n                return match_parens_rec(lst[1:], d)\n\n    d = 0\n    return match_parens_rec(lst, d)\n\n'''", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    result = []\n    while lst:\n        while True:\n            result.append(lst.pop(0))\n            if not lst or result[-1] == lst[0]:\n                break\n        if result[-1] == '(':\n            result.append(')')\n            while result[-1] == '(':\n                result.append(')')\n        else:\n            while result[-1] == ')':\n                result.append('(')\n            result.append(')')\n    result = ''.join(result)\n    return result == '()' or not result", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def helper(left, right, stack):\n        while left and right:\n            if left[0] == '(' and right[0] == ')':\n                left.pop(0)\n                right.pop(0)\n                stack.append('(')\n                stack.append(')')\n            elif left[0] == ')' and right[0] == '(':\n                left.pop(0)\n                right.pop(0)\n                stack.append(')')\n                stack.append('(')\n            elif left[0] == '(' and right[0] == '(':\n                left.pop(0)\n                right.pop(0)\n                stack.append('(')\n                stack.append(')')\n                if len(left) == 0 and len(right) == 0:\n                    return 'Yes'\n            elif left[0] == ')' and right[0] == ')':\n                left.pop(0)\n                right.pop(0)\n                return 'No'\n            elif left[0] == '(' and right[0] == ')':\n                left.pop(0)\n                return 'No'\n            elif left[0] == ')' and right[0] == '(':\n                right.pop(0)\n                return 'No'\n            else:\n                return 'No'\n        if left and", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    return None", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'Yes'\n\n    if lst[1][-1]!= ')':\n        return 'No'\n    if lst[0][-1]!= '(':\n        return 'No'\n\n    stack = []\n    for s in lst:\n        if s[-1] == '(':\n            stack.append(s[-1:])\n        else:\n            if len(stack) == 0 or len(stack[-1])!= len(s):\n                return 'No'\n            stack.pop()\n\n    return 'Yes' if len(stack) == 0 else 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) <= 1:\n        return 'Yes'\n    parenth_open = ['(', '(']\n    parenth_close = [')', ')']\n    res = []\n    for i in range(len(lst)):\n        if lst[i] in parenth_open:\n            res.append(parenth_open[lst.index(lst[i])])\n        if lst[i] in parenth_close:\n            res.append(parenth_close[lst.index(lst[i])])\n        res.append(lst[i])\n\n    if not match_parens(res) == 'Yes':\n        return 'No'\n    else:\n        return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) <= 1:\n        return 'Yes'\n\n    stack = []\n    for i in range(len(lst)):\n        if lst[i] == '(':\n            stack.append(lst[i])\n        elif lst[i] == ')':\n            if len(stack) > 0 and stack[len(stack) - 1] == '(':\n                stack.pop()\n            else:\n                return 'No'\n\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # write your code here\n\n    # return  True if there is a match, else False\n    return True\n\n'''", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    res = []\n    if len(lst) == 1:\n        return True\n\n    for i in range(len(lst)):\n        if lst[i] == ')':\n            if res[-1] == '(':\n                res.pop()\n                res.append(')')\n            else:\n                res.append(')')\n        elif lst[i] == '(':\n            if res[-1] == '(':\n                res.pop()\n                res.append('(')\n            elif res[-1] == ')':\n                res.append('(')\n            else:\n                res.append('(')\n\n    return match_parens(res)", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def rec(start, lst1, lst2):\n        if len(lst1) == 0 and len(lst2) == 0:\n            return True\n        if len(lst1) == 0 or len(lst2) == 0:\n            return False\n\n        if start == lst1[0]:\n            if rec(start + 1, lst1[1:], lst2):\n                return True\n            return rec(start, lst1[1:], lst2)\n        if start == lst2[0]:\n            if rec(start + 1, lst1, lst2[1:]):\n                return True\n            return rec(start, lst1, lst2[1:])\n\n    def get_good_parens(str):\n        ans = []\n        stack = []\n        for c in str:\n            if c == '(':\n                stack.append(c)\n            else:\n                if len(stack) == 0:\n                    ans.append(c)\n                else:\n                    while stack[-1]!= '(':\n                        ans.append(stack.pop())\n\n        return ans\n\n    lst1 = get_good_parens(lst[0])\n    lst2 = get_good_parens(lst[1])\n\n    return rec(0, lst1, lst2)", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    res = []\n    op = ''\n    cl = ''\n    ch = ''\n    for i, item in enumerate(lst):\n        if item == '(':\n            op += item\n            res.append(op)\n        elif item == ')':\n            cl += item\n            if op:\n                res.append(op)\n                op = ''\n        elif op and ch:\n            res.append(ch)\n            ch = ''\n        else:\n            ch += item\n    if op:\n        res.append(op)\n    if op and cl:\n        print('Error')\n    return all([(op == op_balanced(res)) for op in op_balanced(res)])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return False\n\n    if len(lst) == 1:\n        return True\n\n    open_count = open_count_parens(lst[0])\n    close_count = close_count_parens(lst[1])\n\n    if open_count > close_count:\n        return False\n\n    result = match_parens(lst[:-1])\n    if result == 'Yes':\n        return match_parens(lst[1:])\n\n    return False", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def get_next_character(lst):\n        '''\n        This function returns the next character of the input string, or None\n        if the end of the string has been reached.\n        '''\n        # if no more chars\n        if len(lst) == 0:\n            return None\n\n        # get next char from lst\n        ret = lst[-1]\n\n        # remove the last char from the list and return it\n        lst = lst[:-1]\n        return ret\n\n    # initialize empty result list\n    result = []\n\n    # get the first char of each string\n    ch1 = get_next_character(lst[0])\n    ch2 = get_next_character(lst[1])\n\n    # for each char\n    while ch1 or ch2:\n        # if the current char is open parenthesis\n        if ch1 == '(':\n            # append the current char to the result list\n            result.append(ch1)\n\n            # get the next char from the second string\n            ch2 = get_next_character(lst[1])\n\n            # if the next char is not open parenthesis\n            if ch2!= '(':\n                # append the current char to the result list\n                result.append(ch2)\n\n        # if the current char is close parenthesis\n        elif ch1 == ')':\n            # get the", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def parse(s):\n        s = s.replace('(', '( ').replace(')',')')\n        sp = s.split()\n        ret = [sp[0]]\n        for c in sp[1:]:\n            if c == '(':\n                ret.append(parse(ret[-1]))\n            else:\n                ret[-1] += c\n        return ''.join(ret)\n\n    return parse(lst[0]) == parse(lst[1])", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    stack = []\n    for item in lst:\n        if item == '(':\n            stack.append(item)\n        elif item == ')':\n            if len(stack) == 0:\n                return 'No'\n            s = ''.join(stack)\n            if s[-1]!= '(':\n                return 'No'\n            stack.pop()\n        else:\n            return 'No'\n    return 'Yes'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return \"No\"\n    if lst[0] == '(' and lst[1] == ')':\n        return \"Yes\"\n    stack = []\n    last_char = \"\"\n    for char in lst:\n        if char == '(':\n            stack.append(last_char)\n            last_char = char\n        elif char == ')':\n            if last_char!= '(':\n                return \"No\"\n            last_char = char\n            while True:\n                if stack.pop() == '(':\n                    break\n                elif stack.pop() == '':\n                    break\n        elif char!= '(' and char!= ')':\n            last_char += char\n    return \"Yes\" if last_char == '' else \"No\"\n\n'''", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 0:\n        return 'No'\n    elif len(lst) == 1:\n        return 'Yes'\n    result = 'Yes'\n    for i in range(len(lst)):\n        pre_string = lst[:i+1]\n        post_string = lst[i+1:]\n        if match_parens(pre_string) == 'No':\n            result = 'No'\n            break\n        if match_parens(post_string) == 'No':\n            result = 'No'\n            break\n    return result\n\n'''", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    return", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    # dp is a dict which stores a set of the position of each opening and\n    # closing parens.\n    # dp[x] = set([(1, 1)]) means that the first closing paren is matched\n    # with the first opening paren.\n    dp = {}\n\n    for i in lst:\n        if i == '(':\n            dp[i] = set([(1, 1)])\n        elif i == ')':\n            dp[i] = set([(-1, -1)])\n\n    res = 'Yes'\n    for i in lst:\n        for j in lst:\n            if i == j:\n                continue\n            elif i == '(' and j == ')':\n                res = 'No'\n                break\n            elif j == '(' and i == ')':\n                res = 'No'\n                break\n\n            x = dp[i].intersection(dp[j])\n\n            if x == set([(1, 1), (-1, -1)]:\n                res = 'No'\n                break\n            elif x == set():\n                res = 'No'\n                break\n            else:\n                dp[i] = x\n                dp[j] = x\n\n    return res", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return \"Yes\"\n    if len(lst) == 2:\n        if lst[0][-1] == lst[1][0]:\n            return \"Yes\"\n        if lst[1][-1] == lst[0][0]:\n            return \"Yes\"\n        else:\n            return \"No\"\n    res = \"\"\n    left = len(lst[0])\n    right = len(lst[1])\n    i = 0\n    while i < left and i < right:\n        if lst[0][i] == \"(\":\n            res += lst[0][i]\n            i += 1\n        elif lst[1][i] == \"(\":\n            res += lst[1][i]\n            i += 1\n        elif lst[0][i] == \")\" and lst[1][i] == \")\":\n            res += lst[0][i]\n            i += 1\n        elif lst[1][i] == \")\" and lst[0][i] == \")\":\n            res += lst[1][i]\n            i += 1\n        else:\n            res += lst[0][i]\n            i += 1\n    return match_parens(res.split('(')[1:])\n\n'''\nSolution\n'''", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) == 1:\n        return 'No'\n    if len(lst) == 2:\n        return 'Yes'\n    stack = []\n    for element in lst:\n        if element == '(':\n            stack.append('(')\n        elif element == ')':\n            if len(stack) == 0:\n                return 'No'\n            while stack[-1]!= '(':\n                stack.pop()\n            if len(stack) == 0:\n                return 'Yes'\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) <= 1:\n        return 'Yes'\n    else:\n        first = lst[0]\n        rest = lst[1:]\n        if not match_parens(rest):\n            return 'No'\n        for index, char in enumerate(first):\n            if char == '(':\n                if not match_parens(rest[:index] + rest[index + 1:]):\n                    return 'No'\n            elif char == ')':\n                if match_parens(rest[:index] + rest[index + 1:]):\n                    return 'No'\n    return 'Yes'</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    stack = []\n    for i in range(len(lst)):\n        if lst[i] == '(':\n            stack.append('(')\n        else:\n            if stack[-1:] == ['(']:\n                stack.pop()\n            else:\n                return 'No'\n\n    return 'Yes' if stack == [] else 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    assert lst\n    assert len(lst) == 2\n\n    parens = lst[0]\n    opp = lst[1]\n\n    res = []\n    while parens:\n        if parens[-1] == '(':\n            op = parens.pop()\n            res.append(op)\n        elif parens[-1] == ')':\n            if not opp.startswith('('):\n                return 'Yes'\n            opp = opp[1:]\n            res.append('(')\n        else:\n            return 'Yes'\n    return 'Yes' if op == opp else 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    num_open = 0\n    for i in lst:\n        if i == '(':\n            num_open += 1\n        else:\n            num_open -= 1\n    if (num_open == 0):\n        return 'Yes'\n    else:\n        return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    def insert_new_bracket(lst, index, btype):\n        if len(lst) < index:\n            return False\n        elif lst[index] == btype:\n            return True\n        else:\n            return insert_new_bracket(lst, index + 1, btype)\n\n    if not lst or len(lst) <= 1:\n        return False\n\n    for i in range(1, len(lst)):\n        if insert_new_bracket(lst, i, '('):\n            if lst[i] == '(' and match_parens(lst[:i] + lst[i + 1:]) == 'Yes':\n                return True\n            elif lst[i] == '(' and match_parens(lst[:i] + lst[i + 1:]) == 'No':\n                pass\n            elif lst[i] == ')' and match_parens(lst[:i] + lst[i + 1:]) == 'No':\n                pass\n            elif lst[i] == ')' and match_parens(lst[:i] + lst[i + 1:]) == 'Yes':\n                return True\n            else:\n                return False\n\n    return False", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return \"No\"\n    if lst[0] == '(':\n        result = '(' + match_parens(lst[1:])\n    elif lst[0] == ')':\n        result = match_parens(lst[1:])\n    elif lst[0] == ')':\n        return 'No'\n    return result", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    stack = []\n    for item in lst:\n        if item == ')':\n            if len(stack) == 0:\n                return 'No'\n            else:\n                stack.pop()\n        elif item == '(':\n            stack.append(item)\n    if len(stack)!= 0:\n        return 'No'\n    return 'Yes'\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if len(lst) < 2:\n        return 'No'\n    s0, s1 = lst\n    if len(s0) == 0 and len(s1) == 0:\n        return 'No'\n    if len(s0) == 1 and len(s1) == 1:\n        if s0[0] == ')' and s1[0] == '(':\n            return 'Yes'\n        if s0[0] == '(' and s1[0] == ')':\n            return 'Yes'\n        return 'No'\n    if s0[0] == ')' and s1[0] == '(':\n        return match_parens(s0[1:] + s1 + s0)\n    if s0[0] == '(' and s1[0] == ')':\n        return match_parens(s1 + s0[1:])\n    return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def is_balanced(s):\n        stack = []\n        for ch in s:\n            if ch == '(':\n                stack.append(ch)\n            elif ch == ')':\n                if len(stack) == 0:\n                    return False\n                else:\n                    stack.pop()\n        return True if len(stack) == 0 else False\n\n    def is_good(s):\n        return is_balanced(s)\n\n    def check(s, t):\n        if is_good(s) and is_good(t):\n            return 'Yes'\n        else:\n            return 'No'\n\n    def match(l1, l2):\n        if len(l1) == 0 and len(l2) == 0:\n            return check('', '')\n        elif len(l1) == 0 or len(l2) == 0:\n            return check(l1, l2) if len(l1) == 0 else check(l2, l1)\n        elif len(l1) > len(l2):\n            return match(l1[1:], l2)\n        elif len(l1) < len(l2):\n            return match(l1, l2[1:])\n        else:\n            i = 0\n            while i <= len(l1) - len(l2):", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    if lst[0] == '(' or lst[0] == ')':\n        return match_parens(lst[1:])\n    if lst[1] == '(' or lst[1] == ')':\n        return match_parens(lst[2:])\n\n    for pos in range(2):\n        if lst[pos] == '(':\n            if lst[pos + 1] == '(':\n                if match_parens(lst[pos + 2:]) == 'Yes':\n                    return 'Yes'\n            else:\n                if match_parens(lst[pos + 1:]) == 'Yes':\n                    return 'Yes'\n        else:\n            if lst[pos + 1] == '(':\n                if match_parens(lst[pos + 2:]) == 'Yes':\n                    return 'Yes'\n            else:\n                if match_parens(lst[pos + 1:]) == 'Yes':\n                    return 'Yes'\n    return 'No'\n\nfor _ in range(int(input())):\n    L = [str(x) for x in list(map(int, input().split()))]\n    print(match_parens(L))\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    def balance(lst):\n        '''\n        Return 'Yes' if the input list is balanced and return 'No' otherwise.\n        '''\n        i = 0\n        j = 0\n        n = len(lst)\n        while i < n:\n            if lst[i] == '(':\n                j += 1\n            elif lst[i] == ')':\n                if j > 0:\n                    j -= 1\n            i += 1\n        return j == 0\n\n    if not lst:\n        return 'No'\n    if len(lst) == 1:\n        return balance(lst)\n    if balance(lst[0]) and balance(lst[1]):\n        return match_parens([lst[0] + ')', lst[1] + '('])\n    if not balance(lst[0]) and not balance(lst[1]):\n        return 'No'\n    return match_parens([lst[0] + ')', lst[1]])\n</s>", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n\n    count = 0\n    str = ''\n    for i in lst:\n        if i == '(':\n            count += 1\n        elif i == ')':\n            count -= 1\n        str += i\n    if count == 0:\n        return 'Yes'\n    else:\n        return 'No'", "def match_parens(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to check if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    match_parens(['()(', ')']) == 'Yes'\n    match_parens([')', ')']) == 'No'\n    '''\n    result = []\n    check = []\n    for i in lst[0]:\n        check.append([])\n        result.append([])\n        if i == '(':\n            check[0].append(0)\n        if i == ')':\n            check[0].append(1)\n\n    for j in lst[1]:\n        if j == '(':\n            check[1].append(0)\n        if j == ')':\n            check[1].append(1)\n\n    for i in range(len(lst[0])):\n        for j in range(len(lst[1])):\n            if check[0][i] == 0 and check[1][j] == 0:\n                result[i].append('(')\n            if check[0][i] == 1 and check[1][j] == 0:\n                result[i].append(')')\n            if check[0][i] == 0 and check[1][j] == 1:\n                result[i].append(')')\n            if check[0][i] == 1 and check[1][j] == 1:\n                result[i].append('(')\n\n    res = ''.join(result)\n    return res == '()'"]]