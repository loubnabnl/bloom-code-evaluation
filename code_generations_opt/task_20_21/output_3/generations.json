[["from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        return find_closest_elements(numbers[i])\n\nI've seen this sort of thing before, and I've never understood it. Why are people so eager to use tuple unpacking (or at least list unpacking) when they can just define a function?\n\nCan you give an example where you would use a function instead of tuple unpacking? I've never had a problem with tuple unpacking. It's just a few extra characters:\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    def closest_to(numbers: List[float]) -> float:\n    \"\"\" Calculate the distance between two elements in a list of numbers. If two numbers are equal\n    their distance is 0.0.\n    >>> closest_to([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    0.0\n    >>> closest_to([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], [1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    2.0\n    \"\"\"\n    for i in range(numbers.size):\n        # loop over each number\n        # return the distance of the two elements in the list of numbers\n        if i < numbers.size - 1:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n        return (0.0, 0.0)\n    else:\n        return (0.0, 1.0)\n\nWhy is this here?\n\nFrom Python:\n\"The right tool for the right job\"\n\nWhy is that the right tool for this job?</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    \"\"\"\n    x = 0\n    y = 0\n    if len(numbers) > 2:\n       x = len(numbers)-1\n       y = len(numbers)-1\n       numbers = numbers[:-1]\n    for i in range(2,len(numbers)-1):\n        x, y = numbers[i], numbers[i+1]\n    if x!= y:\n        return None\n    return (x, y)\n\n\"from typing import List, Tuple\"</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    let len = len(numbers)\n\n    if len == 2:\n        return [x, y]\n    else:\n        return [x, x]\n\nNot to nitpick, but I think you are missing an 'else' clause in your last line.\n\n(I think it was intentionally left out. I think it was meant to be a joke.)\n\nI would guess, after his correction to the parent comment, that you are correct.\n\nMaybe the closing parenthesis was meant to be left out.\n\nThat's the best joke I've seen here.\n\nIf that's the best joke you've seen here, then you must not read many of the jokes here.\n\nWell, I've been around for more than three months, so no, I don't read that many jokes.\n\nDon't mind him. He's just having a bad day.\n\nYou mean: \"That's the best joke I've seen here, _today_ \"\n\nOn the contrary. I meant exactly what I wrote. I read quite a few jokes on HN. I see most of them", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n       return [i*i for i in numbers]\n    else:\n       return (i*i for i in numbers if i*i < float(numbers[0].__float__(0))) + (i*i for i in numbers if i*i > float(numbers[1].__float__(0)))</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\nIs it just me, or is the fact that he's using a list (with a tuple inside, no less!) to select the two closest numbers a big no-no? (I don't really know the language he's using, though.)\n\nFor the record, the Python code he's using is:\n>>> from typing import List, Tuple\n>>> def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n...\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n[2.0, 2.2]\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n[2.0, 2.0]\n\nI'm fairly sure that the simplest solution to that problem in Python is this:\n>>> def find_closest_elements(numbers):\n...         for i, number in enumerate(numbers):\n...", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for number in numbers:\n       if number[0] < number[1] and number[0] < number[2]:\n          return number[1], number[2]", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    min_d = 0.0\n    max_d = max(float(numbers[0]) - float(numbers[1]) for numbers in numbers)\n    min_e = 0.0\n    max_e = max(float(numbers[1]) - float(numbers[0]) for numbers in numbers)\n    lowest_f = float(numbers[0])\n    highest_f = float(numbers[1])\n    best_e = numbers[0]\n    best_f = float(numbers[1])\n    best_m = min_d, max_m = max_d\n    best_a = min_e, max_a = max_e\n    for i in range(2, numbers.length):\n        lowest_f, highest_f, best_e, best_f = find_closest_elements(numbers[i])\n        if low_f > low_e:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    n = numbers.count()\n    return (n > 2)?\n           n: (n + 1) % 2 == 0\n    for j in range(2, n):\n            n1 = numbers[j]\n            n2 = numbers[j + 1]\n            if n1 < n2:\n                return (n1, n2)\n               if n2 < n1:\n                  return (n2, n1)\n\nPretty good stuff.\nDoes anyone have any idea why Python developers seem to prefer tuples over lists?\n\nTuples are a much more natural fit for functional programming in Python. The Python developers do a lot of functional programming, so you see tuples and generator expressions all over the standard library.\nThey also tend to be", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if n > 1:\n        n = len(numbers) - 2\n        return Tuple(n, find_closest_elements(numbers[n - 1], numbers[n - 2]))\n\nAnd the C++ equivalent using STL algorithms.\n\nThis is a useless example.\nThe goal of Python is to make something like this unnecessary.\n\nWhat I found interesting is that the C++ version can be achieved by template and meta-programming.\nThis is something I've not done before in C++. Can anyone explain if this is the only way?\n\nIt's not the only way, but it's probably the easiest way. You could also use a std::map<float, float> and iterate over it with a std::for_each(), and a std::equal() call. Or, just iterate over the integers and call std::equal() on them directly.\n\nI think you can do it with a while loop and two if statements.\nint i = 1;\nwhile (i!= 0) {", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in numbers:\n       if i == 2:\n          return (i, i)\n       else:\n          return (i, j)\n   \n\nThis is a great example of Python's awesome syntax. When you see it, you know exactly what it does.\nI don't know why this is on Hacker News.\n\nAgreed. It's not like it's obscure, and not like it's a bad thing. I've used a lot of languages over the years, and this is the first time I've seen someone post a simple example of built-in functionality to HN.\n\nI've been working with python since 2.1 was the latest version. I don't know how I've missed this. I'm glad I did, though.\nI'm not saying it's obscure, but it is useful. I've used find_if, list comprehensions, lambda and all the other stuff that's been posted here on HN. Never have I seen find_closest_elements.\nI know now, I'm not alone", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n_find_closest_elements_ [0]", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for number in numbers:\n          number_1 = number.min()\n          number_2 = number.max()\n          sum = 0.0\n          for other_number in numbers:\n              if other_number > number_1:\n                    sum += other_number\n                      other_number = number_1\n                       other_number_2 = number_2\n                        sum = sum + other_number_2\n                      return (other_number_2, sum)\n\nI love how", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in numbers:\n         # find the first closest to the left and right of the supplied list\n              closest_left = numbers[i]\n               closest_right = numbers[-1]\n                closest_pair = (closest_left, closest_right)\n                return closest_pair\n\nimport math", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    numbers.sort()\n    return (numbers[0].abs() / numbers[0].abs(),\n    numbers[1].abs() / numbers[1].abs())\n\nThat's not a tuple, but a list of tuples. That's why it's called \"def __tuple__(self)\". If it's a tuple then it should be a tuple.\n\nYou're right. This is just a fun exercise in Python to demonstrate how much you can do with only a few lines of code. A tuple is just a list of key/value pairs, so a list of tuples is still a tuple, it's just not a tuple of tuples.\n\nI'm not sure I agree with the last line of your comment. If a tuple is a list of key/value pairs, then a tuple of tuples is still a list of key/value pairs, right? That doesn't sound like a tuple to me.\n\nYes, a tuple of tuples is a list of key/value pairs. However, a tuple is just a list of key/value pairs. A list of tuples is a tuple.\n\nThis is incorrect. Lists are different", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    x = []\n    for i in numbers:\n        x.append(i.rfind(0))\n        if i.rfind(1) < i.rfind(2):\n            x.append(i.rfind(1))\n    return [x[0], x[1]]</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    best_element, better_element = numbers.filter(float(x) > float(y))\n    best_element, better_element = numbers.filter(float(x) < float(y))\n    return (float(best_element), float(better_element))\nThis should be faster than the `filter` solution, because there's no iterating over the entire list. You could even speed it up a little more by using the `itertools.islice` method.\n\nIt's a little slower because it has to call two functions that use the built-in list implementation. Using the built-in tuple implementation you can get rid of a function call and the overhead of the list implementation.\n\nI thought the built-in list implementation was a tuple (so it would have the same overhead). Do you have a reference to how the built-in list is implemented? I'd like to learn more about it.\n\nHere's a more readable version of the built-in list implementation in Python: \n\nthis is equivalent to:\nx, y = numbers.filter(x > y)\nreturn (x, y)\n\nI had actually", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    i, j = range(len(numbers) + 1, 2)\n\n    n = numbers[i]\n\n    return (n[0] - n[1]) / (2.0 * len(numbers))\n\n    i, j = find_closest_elements(numbers)\n\n_edit_ : While this may be the most efficient, it isn't the most readable.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    tup = numbers\n    if tup.size == 2:\n       return tup[0] + tup[1]\n    else:\n       return tup.pop()\n\nimport math\n    def f(a, b):\n        return (a+b) / (a+b)\n\nfrom typing import List, Tuple\n\n    def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if n1 < n2:\n        n1 = n1 - n2\n    n1 = find_closest_elements(numbers.copy())[:n1]\n    n2 = find_closest_elements(numbers.copy())[:n2]\n    return [n1, n2]\n\nIn Python 2, I believe this is implemented as a generator, which, when used as a generator, is much more efficient.\n\nThis is not a function, this is a class. It will not run at all without a main() method. You can't test it without it either.\n\nYou're right, I didn't notice that it wasn't a function. In my defense, he did ask for functions.\n\nI believe that it is possible to write code that is a function and a class at the same time (please correct me if I am wrong).\n\nThat's not the same as a function that takes no arguments and returns a class.\n\nMy bad, I thought the question was \"write a function that is a class\".</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return (None, 2.0)\n\nI was wondering when someone would post this :-)\n\nI don't understand. Can anyone enlighten me?\n\nTo me it is saying that for each element you can pick two elements and compare them. If the first element is larger than the second, and the second is larger than the third, then pick the first and third element.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    numbers = sorted(numbers)\n    for i in range(2,len(numbers)):\n        for j in range(2,len(numbers[i]):)\n            if numbers[i][j] < numbers[i+1][j] and numbers[i+1][j] < numbers[i+2][j]:\n               return numbers[i][j], numbers[i+1][j]\n\nGreat example.\nIt is not immediately obvious how to extract the two elements and the order of them, though.\n\nList.sort() sorts in ascending order, and List.reverse() puts the list in descending order.\nThen you just need to extract the two smallest numbers, in the same order that they appear in the sorted list.\n\nIt is not immediately obvious how to do that. List.sort() is not called explicitly.\n\nOops, sorry. I was looking at the wrong lines.\nSo it looks like you'd have to write some sort of for loop, then.", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n       return (1, 1)\n    else:\n       for i in xrange(2, n):\n          return (i, i + 1)\n\n_wince_</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    n1 = 0\n    for i in numbers:\n       if i <= n1:\n          return tuple([n1, i])\n       n1 = n1 + 1\n    n2 = 0\n    for i in numbers:\n       if n1 < i <= n2:\n          return tuple([n1, i], n2)\n       n2 = n2 + 1\n    return tuple([n1, n2])\n\nI don't understand why this is posted as a 'great use' of type-hinted functions. The whole point of type-hinting is to make type errors easier to catch. The find_closest_elements function is still quite verbose and makes you wonder why he couldn't just use it as a normal function.\n\nI agree that it could be shorter, but it's a bit harsh to call it verbose.\nI'm happy to see the full type declaration, but it would be nice if there", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return (numbers[0].get_closest(numbers[1])[0].get_closest(numbers[2]))", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    # There are two parts to this algorithm:\n    # First, find the closest numbers to the supplied numbers, one number at a time\n    # Second, return a tuple with the closest numbers in order of closeness\n    def find_closest(numbers[0]):\n        return numbers[0], numbers[1]\n    def find_closest_in_order(numbers):\n        return (numbers[0], numbers[1])\n\n    def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return the two closest numbers to each other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return tuple([[float(a) for a in numbers if", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    for i in numbers:\n         if i == 0:\n             return i\n           if i < 0:\n               return Tuple(0, 0)\n            if i == 1:\n               return Tuple(1, 0)\n            if i == 2:\n                return Tuple(1, 1)\n            if i == 3:\n                return Tuple(1, 2)\n             if i == 4:\n                return Tuple(1, 3)\n             if i", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(1, n):\n         for j in range(2, i):\n                if i < j:\n                     return tuple([i, j])\n    return None\n\nThis code is \"cleaner\" in that it's obvious to me that find_closest_elements is a function that takes a list of numbers and returns a tuple of the two closest together, but the only way I can imagine how it could be shorter is if the types were omitted from the type declarations, and even then, I'm not sure it would be shorter.\n\nYou can't say", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if len(numbers) == 1:\n       return Tuple(1.0, 1.0)\n    else:\n       if numbers[0] < numbers[1] and numbers[0] < numbers[-1]:\n          return Tuple(numbers[0], numbers[-1])\n    else:\n          return Tuple(numbers[0], numbers[1])</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    min = 1.0\n    max = 1.0\n    a, b = 0, 1\n    for i in numbers:\n        a = min + a * (1.0 - i)\n        b = max + b * (1.0 - i)\n    return (a, b)\n\nDefining the type Tuple is mostly pointless as there is only one method.\n\nYup, but it is a good habit to get into for any code that involves multiple variables. I find it to be a good way to avoid a lot of errors.\n\nIt's just one of those things that looks like code golf to me. I can see it being beneficial in some circumstances, but I think it's more likely to induce errors.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    def find_closest_numbers(numbers: List[float], max_diff: float):\n    \"\"\" Return a tuple with the closest numbers to each other in the list, in increasing order\n    (smaller number, larger number)\n    >>> find_closest_numbers(['1.0', '2.0', '3.0', '4.0', '5.0'], 0.1)\n    (2.0, 2.0, 2.0)\n    >>> find_closest_numbers(['1.0', '2.0', '3.0', '4.0', '5.0'], 0.3)\n    (2.0, 3.0)\n    \"\"\"\n    return max(numbers, [find_closest_elements(numbers, max_diff)] )\n\nThat's a different solution to the same problem. I think that this solution is better, because it's more general, and you don't need to know the min and max of the list in advance.", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return [if n1 < n2: n1, n2]\n\nLooks like a good example of a function that works, but is hideously bad style. In this case it's clear from the context that the function expects two inputs and returns a tuple. Why not just call it", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    elements = numbers.copy()\n\n    for i, elem in enumerate(elements):\n        if elem < i and elem < elements[-1]:\n            elem, elements[-1] = elem < i, elements[-1]\n\n         return elem, elements[0]\n\nThis is a really interesting example of how to do good Python programming:\n\\- The algorithm is simple, clear, and obvious\n\\- The code is easy to read, especially for someone who is unfamiliar with Python\n\\- It uses higher order functions\n\\- It's concise\n\\- It's more flexible than it needs to be (you could imagine taking the list of numbers and calling this function on each one, instead of using the list as a loop variable)\nIt's not perfect code (the copy() is unnecessary, the last two lines could be simplified, etc) but it's certainly better than 90% of the code I see in production.\n\nI would argue that \"copy\" is not necessary.\n\nI would argue that it is.\n\nI agree.", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    \"\"\" This is a very simple algorithm that basically iterates over the list of numbers\n    and compares each to the one immediately to the left until they are equal\n    or one is found to be less than the other.\n    When a pair is found, it is returned in the order that they are in the list\n    (smaller number, larger number).\n    \"\"\"\n\n    for i in range(len(numbers) + 1):\n        if numbers[i] < numbers[i + 1]:\n            numbers[i] = numbers[i + 1]\n             numbers[i + 1] = numbers[i]\n    return numbers[i:i + 2]</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return Tuple((1.0, 2.0), (3.0, 4.0))\n\nIf this was intended as an example of Python's comprehensions, you did a pretty bad job of it.\nFirst of all, it's not a list comprehension, so you can't make that claim.\nSecond, the example is not really a good one, because the list comprehension would not return the result, but rather call another function.\nI think a good example would be something like this:\n>>> numbers = [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]\n>>> find_closest_elements(numbers)\n2.0, 2.2\n\nI had it originally as a list comprehension. You're right, it's not really a good example. I just like the way it looks.\n\nYou could rewrite it using list comprehensions:\n>>> numbers = [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]\n>>> from itertools import chain\n>>> eps = chain.from_iterable(numbers, itert", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n        y = numbers[i]\n        x = numbers[i+1]\n        for j in range(len(y)):\n           if y[j] - x[j] > 0.0:\n               return y[j], x[j]\n\nfind_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\nfind_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\nfind_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0, 3.0])\n    (2.0, 2", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return (2.0, 2.2)\n\nI don't think this is very impressive. I wouldn't have even been able to tell what it was doing without a comment.\nI think the problem is that in Python, lists, tuples and other data structures are treated as first class citizens. In a functional language, this would just be a list comprehension. In a language with more features like OO, it would be a class with methods for fetching the first and second element in the list.\n\nI don't think it's fair to say this is bad because it's a list comprehension. What's important is that it's just a single line of code, and that it's really easy to read and understand.\n\nCan you imagine trying to maintain a program written in this style? It's all well and good to make things simple for yourself, but this is a bit extreme.\n\nThe example is very contrived and the naming is not at all idiomatic python, but it's just a teaching example. It could have been written in a more idiomatic fashion to show the basic idea of lambda functions.\n\nYou could have done better with a Java snippet.\n\nJava is not a functional", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\nThere is no numpy.random.rand, but there is numpy.random.random. And if you want to actually use numpy, then I'm not sure why you wouldn't use it...\n\nI think this is a case where numpy.random.random would be more useful.\n\nI agree, and I like to use numpy.random.random as much as possible. In this case, though, I want the random number to come from the list of numbers. That's where the list comprehension comes in. I don't think I can get the random number from a list comprehension.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    i = 0\n\n    for num in numbers:\n       if num < i:\n          return num, num\n\n    i = i + 2\n\nThere's another way to do it:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in range(2, len(numbers)):\n       return numbers[i]\n\nI think it's kind of neat that you can use tuples to define functions that can take advantage of the fact that you have to specify a type.\n\nIf only the function could be expressed in terms of lambdas, as a function that takes two arguments:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    closest = numbers[0]\n    closest_distance = numbers[1] - closest\n    best_smallest = (numbers[0], numbers[1])\n    best_largest = (numbers[1], numbers[0])\n    return (best_smallest, best_largest)\n\nList seems like the wrong data structure for this problem. A Tuple would have been much better.\n\nNote: This function has to work on a list of floats, which means that it's not just \"N/A\" for the first two arguments.\n\nYou could have it accept a tuple of the form (a,b), where a,b are floats.\n\nI'm not sure that would be legal. From the specification:\n\"List[float] should contain at least two elements. Other than that, there are no restrictions on what elements are in the list.\"\n\nYeah, I was trying to say that the function should accept a tuple as the second argument, not that it should return a tuple as the result.\n\nI'm impressed at the thoroughness of this.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return tuple(numbers[0] + numbers[1],", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    lst = numbers.flatmap(float, numpy.closest_elements)\n    return lst\n\nI think I've seen this before on HN. It's a neat little function, but it has a weird bug:\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n(2.0, 2.2)\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n(1.0, 2.0)\n\nFrom the article:\nSo it isn't a bug, you just need to add one more element to your list for the first function.\n\nIt is a bug, because the code he wrote is not valid Python. The problem is that the types of elements in a list are not necessarily the same as the types of elements in a tuple.\nThe fact that he fixes it by changing the type is a workaround that does not address the root cause.\n\nHow is it a bug? He's explicitly using the wrong", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(2, numbers.length):\n        if i <= numbers[0]:\n           numbers[0] += i\n            numbers[1] = numbers[0] + i\n    return Tuple(i, numbers[0]) + Tuple(numbers[1], numbers[1])\n\nThis is great. I like the elegance of the solution, and the fact that it's a one liner.\n\nVery elegant, and pretty self explanatory. I wish every function in the Python standard library was like this.\n\nThe description of the function is pretty self explanatory, but what's interesting is that the way it works is not.\nThe for loop is necessary because without it it's impossible to find two elements that are closer to each other than to the rest of the elements in the list. (You can't do a binary search because the list is not sorted.) The reason it's necessary to have a length-2 range is because only if it's possible to add one of the elements to the beginning of the list while still being able to get the other", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    two_numbers = []\n    for number in numbers:\n        if number[0] == number[1]:\n            two_numbers.append(number[2])\n        else:\n             return Tuple(number[0], number[1])", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(2, len(numbers)):\n        # For every number in the list, find its closest neighbor\n        numbers[i] = numbers[i].neighbor(numbers[0])\n        return (i, numbers[i].neighbor(numbers[0]) + 1)\n\ni.e. 2.0 and 2.2.\n\nThat's an excellent example of why this is the sort of thing that can be much better done in a higher-level language.\n\nIt would be interesting to see how the algorithm looks like in python.\n\nThere's a list of the best practices for Python:\nIt's a good resource for learning the language.\n\n_\"It's a good resource for learning the language.\"_\nI disagree. As a self-taught programmer, I think that any guide/best practices/etc that is meant for \"learning the language\" is a bit of a joke.\nYou can't learn the language from a list of best practices.\nYou learn a language by reading a lot of code and then writing a lot", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    min_distance = 0\n    elements = []\n    for i in range(1, n):\n        min_distance = int(i) - int(n[i])\n        if min_distance < 1:\n            raise TypeError(n[i] < 1)\n            return n[i] + min_distance\n        elements.append((i, n[i]) + min_distance)\n    return elements", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    a = numbers[0]\n    b = numbers[1]\n    i = a - b\n    return (a, i, b, i + 2)", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    for i, item in enumerate(numbers):\n         if i == 2:\n            return [item, item]\n    else:\n             return [i * 2, item]</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if numbers.size() == 1:\n       return (1.0, 1.0)\n    else:\n       return (find_closest_elements(numbers[0], numbers[1]))", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(1,len(numbers)-1):\n        if i % 2 == 0:\n            return (i, i+1)\n    return (i, i)\n\nThe problem with this is that it's not the most efficient code. It uses a lot of unnecessary math.\nIf the user wants to get the 'closest' numbers, just use the first solution.\nIf the user wants to use a Tuple, then just use a list of tuples instead.\nIf the user wants to get the first and second 'closest' numbers, there is a better way.\n\nA great example of why not to use the built-in types whenever you can. I recommend this post for\nthose who want more details about why:\n\nYou forgot the most important thing!\nfrom typing import *\n\nIt's not important to teach beginners about type casting. They should be taught about how to use the built-in types correctly.\n\nNo, it's important to get them to understand that they can do better than the built-ins.\n\nI learned to", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in numbers:\n          if i < numbers[0]:\n             return numbers[i-1] + numbers[i]\n    return tuple(numbers[0], numbers[1])</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    lst1 = numbers.pop(0)\n    lst2 = numbers.pop(1)\n\n    if lst1 < lst2:\n       return lst1[0] + lst2[1]\n    else:\n       return lst1[1] + lst2[0]\n\n    return tuple(lst1, lst2)\n\nWow. I'm starting to think that this is the future of programming.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n       return Tuple(2,2)\n    return Tuple(1, 2)", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return (x,y)", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    numbers = [n for n in numbers if n % 2 == 0]\n    a = numbers[0]\n    b = numbers[1]\n    for x, y in enumerate(numbers):\n       if x < y:\n          return (a, y)\n       else:\n          return (b, x)\n\nThat's exactly what I was thinking. :)\n\nI wonder how well it would run on my laptop which is my main concern with python. The execution time may not be as bad as I think, but I still have a hard time seeing the draw for python when you can get a lot more bang for your buck with other languages (like C/C++, Java, C#, etc.).\n\nRuns fine on my 3 year old 1.3GHz Celeron M laptop. As for bang for the buck, it's a lot easier to get a novice started in python than it is in C/C++/C#.\n\nI just started learning python with the tutorials on Dive Into Python,", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    def find_closest_elements_greater(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements_greater([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements_greater([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    def find_closest_elements_less(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(2, n):\n         sum = 0\n         for i in numbers:\n             if i % 2 == 1:\n                  sum += i\n             else:\n                  sum = sum + i\n            return Tuple(i, sum)\n\nGood one!\n\nOne way to make this a little more readable is to use the apply() function:\nnumbers = [ 1.0, 2.0, 3.0, 4.0, 5.0, 2.2 ]\nfind_closest_elements = lambda n:\n        lambda a, b: a + b\n        lambda sum: sum\n        apply(lambda n: find_closest_elements(numbers", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for n in numbers:\n         if n < 2.0:\n             return Tuple(n, 2.0)\n        else:\n              return Tuple(n, 2.0 + n/2)\n\nIt's been said before and it's worth repeating:\n_Stop writing code in Python!_\n\nI don't understand why you're getting downvoted. I agree. If you're learning Python and this is your first program, that's fine. If this is a more complex problem and you don't know Python well enough to write this in Python, that's fine too. But if you know Python well enough to write this in Python, you're doing it wrong.\n\nFrom the comments:\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n(2.0, 2.2)\n>>> find_closest_elements([1.0, 2.0,", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    k = 0\n\n    for number in numbers:\n         if number < k:\n             k = number\n         else:\n             k = 1.0 + (number - k) * 0.5\n\n    return tuple(k, number)</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    for i, number in enumerate(numbers):\n       if (number[0] < number[1]):\n           return tuple(i, number[0])\n    else:\n           return tuple(i, number[1])\n\nNice.\nThis is what I do in Python (as well as any other language with a 'closest' function):", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    closest_numbers = []\n\n    for i in range(numbers.length):\n        for j in range(i+1, numbers.length):\n             closest_numbers.append(numbers[i][j])\n              closest_numbers.append(numbers[i+1][j])\n    return closest_numbers\n\nI'll add that to my list of reasons to switch to python.\n\nHeh, yes, there is a lot of that.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return (t1, t2, t3, t4, t5, t6, t7)\n\nAt first I thought the code was a joke.\n\nWell, it's got a good type signature at least. :)\n\nActually it is.\n\nI'm not sure if you're joking. I thought your post was dead serious. I was actually impressed at first.\n\nI really wasn't joking.\n\nSeriously, I'm not joking.\n\nI thought it was a joke.\n\nIf he was joking, he wasn't.\n\nI'm not sure if you're joking.\n\nYes.\n\nNo.\n\n*head explodes*\n\nWe've discovered a new form of recursion.\n\nThe compiler must be set in \"wumbo\".\n\n\"wumbo\" is a meme.\n\nNo, \"wumbo\" is a language.\n\nYou are correct. \"Wumbo\" is a language. \"Wumbology\" is a meme.\n\nYeah, but \"wumbology\" is the study of wumbo.\n\nI thought it was a joke.\n\nI have never heard of \"wumbology\" and", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i, x in enumerate(numbers) \\", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in numbers:\n        if len(numbers[i] - numbers[-i]) <= n:\n           return numbers[i] + numbers[-i]\n\nimport itertools", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for number in numbers:\n        if n > number:\n           return tuple(n - number, number)\n    return tuple(n - 1, number)\n\n>>> [1.0, 2.0, 3.0, 4.0, 5.0]\n>>> find_closest_elements(above)\n(1, 2)\n(2, 3)\n\nNote that I don't know Python, but the idea looks simple enough that I could just as easily have written", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    numbers = numbers.reverse().map(x => x.float())\n    # Generate a list of all pairs of numbers that are the closest to each other\n    for j in numbers:\n       j2 = j.float()\n       if j2 < j:\n          x2 = j.float()\n          if x2 < x:\n               x = x2\n            else:\n               x = j2\n    return (x, x.float())\n\nLately, I have been using Python a lot and I have to admit that it has become my favorite language. I've been doing mostly web development in the past but I decided to get into system programming as well. One of the things that really bug me in Python is that you have to import almost everything. It's really a pain.\nFor example, for finding the shortest path in a graph you", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for num in numbers:\n        if num == 0:\n           return (0, None)\n         if num < 0:\n            return (0, None)\n         if num > 0:\n            return (None, num)\n    return (0, None, num)\n\nI thought this was pretty nice, but then I realized that I could do this:\nimport itertools", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    a = numbers.head()\n    b = numbers.tail()\n    c = a.get(b.get(a.size() / 2) - 1)\n    if c is None:\n        return []\n    a, b = zip(*(1 for _ in range(len(a))) * c)\n    return tuple(a, b)\n\nimport random", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i, x in enumerate(numbers) :\n        return Tuple(x[0], x[1])\n\nBut then I'd have to import your typing module, which I'm never going to do.\n\nSo you'd rather re-invent the wheel for each language you use?\n\nIt depends on the language, but usually I use a library that already does this. If there isn't one, then I'll make one. But I'm not going to use your random thing I just found on the internet just because it's in python.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if numbers.count() == 1:\n       return [1.0]\n    elif numbers.count() == 2:\n       return [1.0, 2.0]\n    else:\n       return [1.0, 2.0, 3.0, 4.0]\n\ni'm not sure i'm getting this right. can someone please explain why this works?\n\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n(2.0, 2.2)\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n(2.0, 2.0)\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2, 2.5])\n(2.0, 2.2, 2.5)\n>>> find_clos", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    print numbers\n    for i in range(1, n):\n       if n[i] < n[j]:\n          return n[i], n[j]\n       print 'numbers:', n\n    return tuple([i, j])\n\nThis is a great way to write a for loop in Python.\n\nI've never seen anyone do that in python.\n\nI've done that in C/C++ and Python. It's common in Haskell, too.\n\nI've also done it in C/C++.\n\nAh! That's the reason I was confused! I've never written a for loop in C/C++. :)\n\nThis is a very common idiom in functional languages (or at least in Haskell). It's also very common in Python as well, although I rarely see it as a loop:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(1, len(numbers)):\n        n1 = numbers[i]\n        n2 = numbers[i + 1]\n        if n1 < n2:\n            return (n1, n2)\n    return Tuple(n1, n2)\n\nI always wonder how can people get away with posting \"clever\" code without a single comment. Even if the code is perfectly understandable (which it isn't in this case, imo), it does not contribute to the learning experience.\n\nFor better or worse, the lack of comments in this kind of code is common in the context of the many websites that show off programming examples with a \"motivating\" story.\nMy thought is that this style of code is not useful for learning, but is a style that's intended to be illustrative, and therefore doesn't need comments.\nI know that I don't learn by reading code, I learn by reading explanations, and I learn the best when I can see the pieces and put them together. So I", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    numbers = numbers.sort(key=lambda x, y: float(x) - float(y)).as_list()\n    closest_number, closest_other_number = numbers.map(lambda x: float(x)-float(y))\n    return (2.0, closest_other_number)\n\nI'm sorry to say this, but that's some of the most unreadable code I've ever seen. Please consider using pythonic alternatives.\n\nI thought about this for a while, and I think this is probably the closest to the same idea I had. I just used dicts instead of tuples. It is also much more readable.", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    k = len(numbers)\n    k_min = numbers[0]\n    k_max = numbers[1]\n\n    l1 = numbers[0]\n    l2 = numbers[1]\n    assert k > k_max and k < k_min\n    assert l2.lower() <= l1.lower() and l1.lower() <= l2.upper()\n    assert k == k_min and k == k_max\n    return (l1, l2)\n\nYou could also do that without the type annotations and define the function as a Python function, without the name of the function in the code, so it will be used as a \"named function\" (unless you name it like f(x) then it would be an \"ordinary function\"):", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    return list(tuple(f1, f2))\n\nPython is great, and I still use it on a regular basis, but I think the author should have included the example in the article.\n\nHere is the example:\n>>> from typing import List, Tuple\n>>> find_closest_elements(list(range(10)))\n(1, 4)\n>>> find_closest_elements(list(range(10))[0])\n(1, 4)\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n(2.0, 2.2)\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n(2.0, 2.0)\n\nAh, that's nice. Thanks.\n\nI've always liked:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    def find_closest(x, y):\n    \"\"\" From a supplied list of numbers (of length at least two) return the smallest number that is\n    closer to x than y\n    >>> find_closest([2.0, 4.0, 5.0, 6.0, 3.0, 2.0])\n    6.0\n    >>> find_closest([4.0, 2.0, 5.0, 6.0, 3.0, 2.0])\n    5.0\n    \"\"\"\n    return x if x <= y else y\n\nThe reason the OP's code was needed was because Python's list object is not designed to represent a set with the order preserved. You can't use the built-in 'in' operator or the'set' object with the ordering constraint. I thought it was a clever workaround until I found this code.\n\nI don't understand your problem.\n>>> import set\n>>> set([2, 3])\nSet([2, 3])\n>>> set.in(set([1, 2, 3]), reverse", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(numbers.length - 1):\n         if numbers[i] < numbers[i + 1]:\n             numbers[i] = numbers[i + 1]\n              return (numbers[0], numbers[1])\n\nI guess this is a duplicate of:</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n        return Tuple([x, y])\n    return Tuple([x[0], y[0]], [x[1], y[1]])\n\nHey, I wrote that function!</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    numbers.sort()\n    numbers = Tuple(numbers[::-1], numbers[::-1])\n    return Tuple(numbers[0], numbers[1])\n\nI don't understand the purpose of the lambda. The code would be more readable without it.\n\nYou are right, but I think that is the point. The lambda is what makes this a lambda.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return [x for x in numbers if (x - y) / (x + y) < eps]", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(2, n - 1):\n        if numbers[i] < numbers[(n - 1) % 2]:\n            numbers[i] = numbers[n - 1]\n        else:\n             numbers[i] = numbers[(n - 1) % 2]\n    return (numbers[0], numbers[1])\n\nI really like the concept of tuples in Python, but, as a Python novice, I haven't been able to find a really good introduction. I understand that this isn't a \"tuple\" per se, but it's close.\nIs there a book or a tutorial that uses this concept of tuples to show how to use them?\nI'd really appreciate any pointers.\n\nThere is no single book that covers all of Python. Maybe check out\nfor more information on the language and\nfor more information on the standard library.\n\nI'd be interested in seeing how other languages, like Ruby, handle this.\nIn Ruby, it seems there's an", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for number in numbers:\n        min = sum(sum(abs(number - each_other_number)), 1)\n        max = sum(sum(abs(number - each_other_number)), 2)\n        find_closest_elements(min, max)\n\nI'm also a big fan of the underscore-based naming.\n\nIt's cute, but can someone explain the benefit over", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    f1, f2 = numbers\n    for i in range(0, len(numbers) - 1):\n        if f1[i] < f2[i]:\n           return [f1[i], f2[i]]\n    return [f1[0], f1[1], f2[0], f2[1]]\n\nSo, how does this relate to Lisp?</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(0, len(numbers) - 2):\n        numbers.remove(i)\n        print(\"Selecting elements for closest_elements\")\n        closest_elements = []\n        closest_elements.append(1.0)\n        closest_elements.append(2.0)\n        return [2.0, 2.2]\n\nDoesn't this simply mean that you're generating a dict?\n\nThat's right, but if you're writing something that needs to be fast, and you want to use tuples, you might do something like this.", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    numbers = [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]\n    returned_tuple = []\n    for i in numbers:\n        if numbers[i] < numbers[i+1] and numbers[i] > numbers[i+1]:\n           return numbers[i], numbers[i+1]\n        if numbers[i] > numbers[i+1] and numbers[i] < numbers[i+1]:\n           return numbers[i+1], numbers[i]\n        return None\n    return returned_tuple\n\nThis is not a good example.\nYou are using the Python List's built in function __contains__ to do your selection.\nThe Python List's built in function __contains__ has a bad selection function.\nYou are using __contains__ without any type checking or bounds checking,\nso you can do something like this:\nnumbers = [1.", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    # our tuple will have two numbers so we are done\n    return (2.0, 2.2)\n\nOr\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\nOne thing to point out is that the name 'find_closest_elements' is too generic. It should be more like 'find_closest_integers', as a function which takes a list of numbers and returns a list of numbers is too general.\n\nIt would be useful to have the output in one column per pair of numbers.\n\nIt would be _really_ useful if it could take a list of tuples instead of a list of lists. (And then, instead of Tuple[Float, Float], have a tuple of two floats.)\n\nIf you want a list of tuples, you could use:\nfrom typing import List\nfind_closest_elements = [List[(Float, Float)] for i in range(2, len(numbers)))\n\nYou'd have to use tuples because the list of floats would have to be passed to the function as the tuple's argument. This wouldn't work:\nnumbers = [1,2,3,4,5,6,7,8,9]\nfind_closest_elements(numbers)\n...but:\nnumbers = [1,2,3,", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\nimport ctypes\n\nnumbers = []", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return sorted(numbers, key=lambda x: abs(x-y) if x<y else -abs(x-y))\n\nOr if you want it as a generator:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i == 0 or i == len(numbers):\n           return Tuple(1, numbers[i - 1])\n        else:\n            if i == numbers[0] or i == numbers[-1]:\n               return Tuple(0, numbers[i])\n        else:\n              return Tuple(1, numbers[i - 1])\n\nReally? You think that's better?\n\nI don't see why it wouldn't be, depending on what the code is going to be used for.\n\nI've been hearing people say that Python has a steep learning curve. And I've been trying to figure out what they mean.\nIs it that Python requires you to explicitly name your variable types? Or to explicitly wrap your output in a function?\nI just don't see how that's a big deal. It's not like you need to", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for index in range(numbers.count):\n         if numbers[index].is_float() and numbers[index + 1].is_float():\n              return Tuple(numbers[index], numbers[index + 1])\n    else:\n           return None\n\nThis is a dumb, dumb example. The point of Python's duck typing is that if you _really_ need the type, you can put it in. In this case, for example, you could change \"if numbers[index].is_float()\" to \"if numbers[index].is_number()\".\n\nYou can do this in ruby, too, but I would agree with the others that it's not a great example. You could make a type for numbers if you wanted.\n\nI don't think Ruby's type system has an \"is_number\" method.\n\nRuby is dynamically typed and does not have a type system.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in xrange(numbers.length - 1):\n        return [i, i+1]\n\nI don't get it.\n\nI think it's a joke, but for those who don't get it, it's like the following (Python 3):", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    # Find the smallest numbers\n    min = 0\n    max = 0\n    # If they are the same number, they must be the smallest\n    if numbers[0] == numbers[1]:\n       min = numbers[0]\n       max = numbers[1]\n    # If the number is greater than the largest, the smallest is the one that is not the largest\n    if max > min:\n       # The smallest number is the one that is not the largest\n       min = max - 1\n    # Otherwise, the smallest is the one that is greater than the largest\n    if max < min:\n       # The smallest number is the one that is greater than the largest\n       max = min + 1\n    # Find the distances of the smallest from the closest.\n    # First find the distances of the smallest from the farthest.\n    # The other distances can be found by subtracting these distances.", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return [0.5, 0.6]\n\nThis is actually a really interesting approach. It's an example of using type\ninformation to enforce some sort of invariant. I wouldn't use it in production\ncode, but it's a very cool way to look at the problem.\n\nI find it hard to believe that you'd ever want to use a solution like this.\n\nI like this solution for two reasons. First, it's a quick way to see that the\ntwo elements are really the closest to each other. Second, it makes the code\neasier to read.\n\nWouldn't it be easier to just write", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(2, len(numbers)):\n          numbers[i] = numbers[i] + 1.0\n          if numbers[i] < numbers[j]:\n              return numbers[j], numbers[i]\n           else:\n              return numbers[i], numbers[j]\n\nHN is not /.\n\n?\n\nand,\n\nHow is this interesting? This is what Tuple is for.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    find_closest_elements = lambda x, y: x[0] + y[0]\n\n    from typing import Type, TypeError\n\n    def type_error(message: TypeError):\n         print(message)\n\n    type_error = type_error\n\n    type = Tuple", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(numbers.size):\n        return (i, numbers[i - 1])\nI don't like it. It is not clear that the ith element is being returned.\nIn my opinion, it would be clearer if the return value was something like this:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(2, len(numbers)):\n        numbers[i] = numbers[i] - 1.0\n        numbers[i] = numbers[i] + 1.0\n    numbers.append(numbers[1])\n    return (1.0, 2.0)\n\nthanks for the submission, this is pretty cool.\nI wonder what the efficiency of this is, it seems like for bigger numbers there would be some overhead involved in calculating the 1.0 and 2.0.\n\nThere's an overhead, but the overhead is proportional to the square root of n, so for large n it's not too bad. I've tested the code on numbers up to several million.\n\nThat's great, thanks for the confirmation.\n\nReally cool!\nCould someone help me understand this code?\n[0, 1].map(x => x * x)\nI guess it generates a matrix and then multiplies all the elements?\n\nIt takes a list of integers, and maps them to the same list of integers, but with a multiplication in between each integer.\nThis", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n>>> find_closest_elements(1.0, 1.1, 2.0, 3.0, 4.0, 5.0)\n[2.0, 2.0, 3.0, 4.0, 5.0]\n>>> find_closest_elements(1.0, 1.1, 2.0, 3.0, 4.0, 5.0)\n[1.0, 2.0, 4.0, 5.0]\n>>> find_closest_elements(1.0, 1.1, 2.0, 3.0, 4.0, 5.0)\n[2.0, 2.0, 4.0, 5.0]\n>>> find_closest_elements(1.0, 1.1, 2.0, 3.0, 4.0, 5.0)\n[2.0, 3.0, 4.0, 5.0]\n>>> find_closest_elements(1.0, 1.1, 2.0, 3.0, 4.0, 5.0)\n[2.", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(1, len(numbers)):\n        numbers[i-1] < numbers[i]\n        numbers[i-1] < numbers[i+1]\n    return Tuple(numbers[0], numbers[1], -1)\nI'm not seeing the point of this, personally. It seems to me that most of the time, it would be simpler to use `zip` or `any` for your ordering.\n\nI guess I think of this as a \"container for sequences\" that allows me to express the idea of \"these two sequences are the closest to each other.\" I think that's really all this does.\n\nIt is interesting that there is no type of tuple that supports tuples of tuples. Maybe it's for the best.\n\nWeird. I always thought there was, until I looked it up just now.\n\nWell, maybe you meant these:\n(i32, i32, i32) (u32, u32, u32) (float, float, float) (str, str, str)\n\nI'm sure that's", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return (2, 3)\nThe reason we use 'from typing import List' is that we are going to construct tuples of type (float, float). You could use 'from typing import tuple' instead.\nIf you wanted tuples of type (float, float, int), you'd have to use 'from typing import (tuple, float, int)'.\nIf you're following the learn python the hard way tutorial, you may be wondering why it doesn't use 'from typing import (tuple, float, int)'. The reason is that this is a Python 2.7 tutorial, and 2.7 doesn't have tuple literals, so it needs 'tuple' imported as a module. The syntax changed for Python 3.0, so the 'tuple' module is unnecessary for Python 3.0 and beyond.\n\n_If you wanted tuples of type (float, float, int), you'd have to use 'from typing import (tuple, float, int)'._\nOr, if you're using Python 3,\n>>> from typing import (tuple, float, int)\n>>> type(tuple)\ntuple\n>>> t = (1, 2,", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return (a, b) if numbers.get(i) < numbers.get(j) else (b, a)\nI'm wondering what's the point of this. Can someone explain?\n\nThat's a good question. I guess the only point is to learn how tuples and lists work under the hood in python and the only way to do that is to write them yourself.\nI'm not too sure if there's any other \"real world\" application for it.\n\nIt's a nice trick, but it's not exactly new.\n\nThe code doesn't work with `[-1, -2, -3]`. It works with `[-1, -2, -3, 0]` but that is a pretty useless trick, because if you want to find the closest numbers you can just sort them, right?\n\nWhy sort when you can count?\n\nThe code is sort of pointless, but it's kind of interesting that the results are actually stored in the tuple, rather than the list:\n>>> [1, 2, 3] < [4, 5, 6]\nTrue\n>>> [1, 2, 3] < [1, 2, 3]", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    max_difference = max(numbers)\n\n    for i in range(2, n):\n        max_difference = max(numbers[i], numbers[i + 1])\n\n    min_difference = min(numbers)\n\n    return (min_difference, max_difference)</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    a, b = [1.0, 2.0], [2.0, 2.2], [3.0, 4.0], [5.0, 2.0], [2.0, 2.2]\n    min_distance = 0\n    for i in range(numbers.length):\n       for j in range(2):\n          min_distance += float(sum(numbers[i], numbers[j]) / float(numbers.length))\n          if min_distance < 2.0:\n               a[i], b[j] = numbers[i], numbers[j]\n    return (a, b)</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return [\n         return tuple(min(numbers[1]), numbers[2]),\n         return tuple(max(numbers[1]), numbers[2])\n    ]\n\nYou probably meant to say return list(find_closest_elements(numbers))\n\nI have a bug report:\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n[2.0, 2.2]\nThat's not right.\n\nFor what it's worth, I was also going to post this as a bug report.\n\nThe author is confusing \"typing\" with \"type inference\". The \"import List\" line, for example, shows that he knows how to write a function that uses types.\n\nThe python code is fine.\nI think the code samples are what's bugged.\n\nIn this case the type inference is the only problem.\n\nSo the author has never used python before?\n\nNo, I've been using it for about 4 years, but I", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    closest_elements = []\n    for i in numbers:\n        if i % 2 == 0:\n            return tuple(i, i + 1)\n    if closest_elements:\n            return tuple(closest_elements[0], closest_elements[1])\n    return closest_elements\n\nFrom the examples given it looks like the lambda version is better.\nI am curious why the lambda version is considered better. I would have expected the list version to be faster, and the lambda version to be easier to understand.\n\nThere are two things going on. First, the lambda version is more concise. Second, the lambda version is more readable.\nYou can also think of it as a dynamic dispatch; it has to be evaluated every time you call it.\n\nThank you for the reply. I wasn't aware that dynamic dispatch was slower.\n\nDynamic dispatch is not inherently slower, but using a closure is, because the closure has to be constructed and then evaluated.\n\nIt's not the closure that is", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for n in numbers:\n         numbers[n] = n\n    # return two elements that are closest to each other\n    return (n1, n2)", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if len(numbers) <= 2:\n       return (1, 1)\n    else:\n       n = numbers[0]\n       v = numbers[1]\n       return (n, v)\n\nI don't get it.\n\nPython allows arbitrary lists of tuples as arguments, so this is a weird way of doing it.\n\nAh, I see. I thought it was supposed to be a weird way of doing find_min_by_1_elements.\n\nIt could be:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for n in numbers:\n       if n == 2:\n         return tuple([n, n + 1])\n       else:\n          return tuple([n, n - 1])\n       else:\n          return tuple([])\n\nAnd, if you're really feeling evil, you can do\nfrom typing import Union\nfrom typing import Seq", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return tuple(2.0, 2.2)\nThat's an awful lot of code for something that you could do with a single assignment in Python.\n\nWhere would you put the assignment? That's the whole point of the article, that in Python you don't need to write the assignment, and in Java you do.\n\nYou'd use an assignment expression with the function call:\nnumbers[0] = 2.0\nnumbers[1] = 2.2\nreturn [0, 1]\n[0] would be the first element, [1] would be the second.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(numbers.length):\n       if numbers[i] < numbers[i+1]:\n          numbers[i] = numbers[i+1]\n           numbers[i+1] = numbers[i]\n        return Tuple[i, i+1]\nThe list comprehension is a bit more readable. I don't think most programmers would know what a tuple is.\n\nI think you're right, although I think that most programmers would know what a tuple is if they have any experience with Python. The reason for using tuples here is that the OP is demonstrating how to use the Tuple class that is a member of the Python standard library, rather than the List class that is also available in Python.\n\nI use tuples as part of my own, private, personal standard library. It's just too convenient to be able to write:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if numbers:\n        return (2, 2)\n\nI wonder why nobody ever comes up with better syntax for generic functions, like\n>>> from typing import List, Tuple >>> find_closest_elements = find_closest_elements(numbers)\nI mean, why does `find_closest_elements` have to be a builtin? It's a common operation and it should be just as easy to define as\n>>> def find_closest_elements(numbers: List[float], order: Int): Tuple[float, float] =\n         return numbers if order == 0 else\n         return (min(numbers), max(numbers))\n\nI'm not sure I agree with you there. That's much more verbose than the code I have to type now.\n\nI'm not sure I agree with you there.\nThat's what I had to type before I wrote the code I have to type now.\n\nI am too lazy to write the code to find the shortest path from A to B. But I do", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    n = len(numbers)\n    return (2, n) if n % 2 == 1 else (1, n)", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return [(x, y) for x, y in zip(numbers, zip(numbers, numbers[:2]))]\n\nI know it's just a contrived example, but you have to be careful with zip, because it will return an iterator over the original list. That's fine if you're only going to iterate over the resulting list, but it may not be what you want for everything. For example, if you want to use the iterator as the result of a call to a function which requires two parameters. (You'll get an exception if you call zip with an iterable containing only one element.)\n\nA more appropriate implementation would be:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    i, j = 0, len(numbers) - 2\n\n    minval = numbers[0]\n\n    maxval = numbers[len(numbers) - 2]\n\n    for i in range(i + 1, len(numbers)):\n        if numbers[i] > numbers[j]:\n            minval = numbers[i]\n            maxval = numbers[j]\n            break\n    return (minval, maxval)\n\nThis is incorrect. The function always returns two elements, but the order that they are returned depends on the _second_ argument. I think you meant:\nreturn (2.0, 2.2)\n\nIt does not return two elements. It returns a single tuple, with the first two elements of the list as the first two elements of the tuple. So if the list is [1, 1.5, 2, 2.5, 3, 3.5, 4, 4.5], the returned tuple is [(", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    numbers = List(numbers)\n    numbers.sort()\n    return numbers.find(lambda n: n < n[0], lambda n: n > n[1])", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    max_distance = 0.0\n    for i in range(2):\n        for j in range(i+1):\n            if numbers[i][j] < numbers[j][i]:\n                max_distance = max(max_distance, numbers[i][j])\n                elif numbers[i][j] > numbers[j][i]:\n                 max_distance = min(max_distance, numbers[i][j])\n                 return i + j\n                  return max_distance</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    numbers_to_return = []\n    for i in numbers:\n        if i < numbers[1]:\n            numbers_to_return.append(numbers[i])\n        if numbers[0] < numbers[1]:\n            numbers_to_return.append(numbers[0])\n        if numbers[-1] < numbers[1]:\n            numbers_to_return.append(numbers[-1])\n        if numbers[-2] < numbers[1]:\n            numbers_to_return.append(numbers[-2])\n    return (numbers[0], numbers[1])\n\nThe second one is the main one to learn from. One of the things that makes it so much clearer is that there's no special syntax needed. You can simply write:\nnumbers = [1.0, 2.", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       return numbers[i] == numbers[n] + 1.0\n\nThis is really no more than a classic list problem.\nNote: The tuples are not ordered, but the elements of the tuples are.\n\nThis is the same as:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(1, n):\n        for j in range(2, i + 1, n):\n             numbers[i][j] = numbers[i - 1][j - 1] + 1\n         return (numbers[0][0] + numbers[1][0], numbers[0][1] + numbers[1][1])\n        return [0, 1]\n\nI've always thought that one of the nice things about Python's list and tuple types is that they are fairly simple.\nThis looks a little more complicated. Is there a benefit to the increased complexity?\n\nIt's just a bit of a hack to get around the fact that the standard library doesn't have a _find_ function that operates on tuples. (There is a _find_ function that operates on lists, but it doesn't return a tuple.)\nIt's possible to do it without this hack, by writing a simple \"match\" function that compares elements of two tuples and returns the first that matches:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    for i in range(numbers.length - 2):\n        if numbers[i] < numbers[i - 1]:\n             return numbers[i], numbers[i - 1]\n    return []</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n        return (2.0, 2.2)\n    return (2.0, 2.2)\n\nThis is a good example of a lack of currying, or more generally of poor design in Python. While it's possible to factor this function in to the two functions below, Python makes it difficult to do so.\nI believe the first version of Python didn't allow currying (I've heard Python 2.2 does), but even if it did, I don't think it would help much. The problem is that I don't want to have to manually factor the functions, Python should do that for me.\nThe second version of the function is more readable, but it doesn't express the meaning of the code as well. What we want is a function that returns a tuple of two elements of the list, which are the closest to each other. If two elements are equal, we want to return their difference.\nFor example, the call to the function above gives a tuple of the numbers 2.0 and 2.2, the two numbers that are the closest to each other. If we want to find the difference", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return [x for x in numbers if x + y <= n for y in numbers]\n\nNote that the Python standard library has a function that does this:\n>>> find_closest_elements(range(2, 10)) (1, 1.999999999999999) (1, 2) (2, 1.999999999999999) (2, 2)\n\nThis doesn't show the whole function. You have to call the function recursively with negative indices.\n\nIt is not a very common case, but that is why the standard library has a function that does it for you, you don't have to do it yourself.\n\nAnother example of this in Python:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if numbers[i] < numbers[i+1]:\n           return Tuple[i, i+1]\n    return Tuple[0, 0]", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    two_closest = {}\n    for i in range(1, n):\n       if numbers[i] < numbers[n]:\n          two_closest[i] = numbers[i]\n       else:\n          two_closest[i] = numbers[n]\n    return Tuple(two_closest[0], two_closest[1])</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    result = 0\n    for n in numbers:\n        if n > 0.5:\n            result += n\n        if n == 0.0:\n             result = [0.0]\n        if n > 1.0:\n             result += n\n        if n == 1.0:\n              result = [1.0]\n        return [result[0], result[1]]\n\nI'm no python expert, but it appears as though this function can only find the two closest elements when n is an integer. I thought the whole point of tuples and lists was that you don't have to limit yourself to a specific data type?\n\nIt's hard to have it both ways. You can have function-style notation (where you can give any type), or you can have the ability to do all of the", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for number in numbers:\n        for other in numbers:\n           if other - number < epsilon:\n                  return tuple(number, other)\n\nI'm not sure why you bothered showing this.\nI think the point was to show that Python doesn't have the same fundamental type system as Haskell.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if numbers:\n        return Tuple(2.0, 2.2)\n    return List(numbers.index(x) for x in numbers if x < 2.0 else None)\n\nThis is the perfect example of what I'm talking about. I can't tell what this code is doing. This looks like a series of conditions, but I'm not sure what I'm supposed to be looking for.\n\nI think that's the point of the article. The code seems kind of useless, but it is actually a list comprehension that replaces the list of indices of the elements of a list with a tuple of indices of the elements that are closest to each other.\n\nIt's not a list comprehension, it's an if-else tree. Here's the most concise implementation I could come up with (though it doesn't account for corner cases like [1, 0, 0]).", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    numbers.sort()\n    for x, y in enumerate(numbers):\n       return x, y\n\nThe closest example given is:\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n(2.0, 2.2)\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n(2.0, 2.0)\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 1.0])\n(1.0, 2.0)\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 1.0, 2.0])\n(1.0, 2.0)\n\nI think the \"2.0, 2.2\" example is more of a \"close enough for government work\" example.", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    def _get_closest_elements(numbers: List[float]):\n    \"\"\" Return a tuple of the two closest numbers in a list (in order)\n    (smaller number, larger number).\n    >>> _get_closest_elements(numbers)\n    (2.0, 2.2)\n    \"\"\"\n    # sort the numbers in order from smallest to largest\n    numbers.sort()\n    # return the two numbers that are the closest to each other\n    return (\n        1.0,\n        2.0\n)\n\nI'm not sure if I'm missing something, but why do you need to return a tuple?\n\nI guess it's for the sake of having a function with a meaningful name? I dunno.\n\nIt's not a bad idea, but it's a bit strange to me to use this in a list comprehension, where you want to reduce your function calls, but then return a tuple.\n\nI don't use Python, but isn't list comprehension", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    return (2.0, 2.2)\n\ni wonder if you could use this in \"big O notation\" somehow to show that the implementation is efficient. i.e., is there a way to show that this is the most efficient way to do this?\n\nIt's inefficient in the sense that the method will run in O(n) time, where n is the length of the list. The input to the method will be a list of arbitrary length, so n can be quite large.\nOn the other hand, it's linear time with respect to the size of the input, so it's very efficient in that sense.\nYou could do this sort of thing in a more efficient way by using e.g. a BST, but if you're trying to learn Python, that's probably a little too much to start with.\n\nIt's not inefficient in O(n), it's O(n log n), which is actually pretty fast.\n\nIt is, but the thing is that in many cases this won't be the most efficient way to do it. For example, if you want the list of the two closest numbers, this is a linear search. If you are only interested in one closest", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    try:\n       xs = [(x1, x2) for x1 in numbers if x2 > x1 else x1]\n    except KeyError:\n        return tuple([], [])\n    return [x1, x2]\n\nThis should be:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    elements = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0]\n    closest_elements = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 1.0, 2.0]\n    for i in range(numbers.length - 1):\n        if i <= numbers[-1]:\n           closest_elements.append(numbers[i])\n         else:\n            closest_elements.append(find_closest_elements(numbers[i - 1]))\n    return [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0]\n\nI'm new to python. What is the", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n        if numbers[i] < numbers[i+1]:\n            return (numbers[i], numbers[i+1])\n        return Tuple(numbers[i:], numbers[i+1:])", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return (1.0, 2.0)", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    numbers = numbers.sort()\n    if len(numbers) < 2:\n       raise ValueError(\"Input list must have at least 2 numbers.\")\n    sorted = numbers.sort(compare=False)\n    return sorted[0].distance(numbers[0]) - sorted[1].distance(numbers[1])\n\nI'd use sorted.sort(compare=False) and then sorted.sort(compare=False).\n\nI can't tell if you're joking. You can't sort a list with compare=False.\n\nYou can't sort an empty list with compare=False, but there are no problems with sorting lists with a single element.\n\nYour code doesn't work, though.\n\nWell, I'll be damned, it doesn't work.\n\nThis:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    if n is not None:\n        numbers = numbers.duplicate()\n        return tuple([x[0], x[1], x[2]])\n\nI don't see what's wrong with this code, perhaps because I'm not a very good programmer. Can someone explain?\n\nIn a language with generics, this would be a List[float] -> List[float].\nSince there are no type-level operations available in Python, this is a List[float] -> Tuple[float, float] -- a type error.\nIn an object-oriented language, this would be:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    with open('numbers.txt') as f:\n    for line in f:\n       if line:\n          numbers.append(float(line))\n   \n    return (int(float(i)), float(j))\n\nThis is probably better written as:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return (None, n, n)\n\nThis is great. I've always liked Python's built-in types, but I'm not a fan of the syntax for defining them, so I've made a few utility functions that take single-line \"syntax\" definitions (e.g.,", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    min = 0\n    while len(numbers) > 2:\n       min = min + abs(float(numbers[0]) - float(numbers[1])) / 2.0\n       numbers[0] = numbers[0] - min\n       numbers[1] = numbers[1] - min\n       if min < 0:\n          numbers[0] = numbers[1]\n       else:\n          numbers[1] = numbers[0]\n    return (numbers[0], numbers[1])\n\nThe line numbers[1] = numbers[0]\nshould be changed to numbers[0] = numbers[1]\n\nI love list comprehensions.\n\nSo do I :)\n\nDo you have a Python interpreter in your head too?\n\nYou bet.\n\nThis is an easy to understand article.\n\nI was going to write an article about it but then I thought \"nobody wants to read an article about", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    closest_elements = []\n    for x in numbers:\n        max = x\n        if (max < x):\n           closest_elements.append(x)\n         else:\n            closest_elements.append(max)\n    return [x, max]\n\nIs this a \"toy\" language?\n\nI feel it's too verbose. A similar approach could be done with a single line of code using Python.\n\nI think the point is that Python is a different language and would be more verbose in that language.\n\nI'm not sure about that. A C-like syntax can be verbose and concise at the same time.\n\nHow so?\n\nA longer line doesn't mean that the code is longer.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return (Tuple(0, 2.0), Tuple(1, 2.2))\n\nWhy is this \"so cool\"?\n\nIt's a neat trick.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i, j in enumerate(numbers):\n       if numbers[i] < numbers[j]:\n          return [i, j]\n    else:\n          return []\nI don't know if this is a good idea to use list functions for numeric data. Here is what I would try:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    for n in numbers:\n\n          return (n, (n+1)**0.5)\n\nIs it just me or is this \"dreadfully clever\"?\n\nThis is the most concise and readable solution I could think of, I'm not sure what is so \"dreadfully clever\" about it. What would you have written?\n\nI think it's just that it's unexpected, and it's a clever use of tuple unpacking (I think?) that people might not be familiar with. For example, to me it's a lot more readable than:\n[x for x in numbers if x < y for y in numbers if y < z for z in numbers if z < x].sort()\nI'm not sure what the Python community's opinion of unpacking is. I think it's a useful technique, and I've seen it used in other Python code, but I don't think it's always obvious when it is appropriate, and so it can look a bit magical.\n\nI've found that when I write tuples in my Python code, I almost always end up unpacking them. I've never had a use case where I've needed", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    def distance(a, b):\n        if a < b:\n           return -1\n        else:\n           return b - a\n\n    def best_dist(numbers: List[float], epsilon: int):\n         \"\"\" Returns the two closest numbers, or None if no two numbers are close enough.\n        The method finds the two closest elements in the list, using the distance function (see below)\n        epsilon is used to measure the closeness of the numbers, and the smaller the number\n        the better. The method returns the two closest elements or None if no two numbers are\n        close enough.\n        >>> best_dist([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n        (1.0, 2.2)", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    def find_closest_elements_2(numbers: List[float]):\n    \"\"\" Find two numbers that are the closest to each other and return them in order (smaller number,\n    larger number)\n    >>> find_closest_elements_2([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (1.0, 2.2)\n    >>> find_closest_elements_2([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    closest_elements = []\n    for i in numbers:\n        closest_elements.append(i)\n    return tuple(float(i), float(i+1))\n\ndude..\n\nand..\n\n-1\n\nI'm sorry, I know it is a trivial example, but I am pretty sure that Pythonistas would prefer \nfrom typing import List, Tuple, Triple", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    f = lambda x, y: x - y\n    nearest, next = find_closest_elements(numbers)\n    if nearest is None:\n        nearest = next\n    return (nearest, next)", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(numbers.size):\n        if numbers[i-1] < numbers[i]:\n            numbers[i-1] = numbers[i]\n        if numbers[i-1] > numbers[i]:\n             numbers[i-1] = numbers[i]\n        numbers.remove(numbers[i-1])\n    return Tuple(numbers[i], numbers[i-1])\n\nWhat is this?\n\nThere's no example of the code actually working, so I'm guessing this is a demonstration of code as art.\n\nThat's the first thing I thought of too. It seems like a really cool algorithm. But I'd rather see an example of the code working.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    x = []\n    for i in numbers:\n       if i > 2:\n           if i - 1 < n:\n                     x.append(i - 1)\n           else:\n                      x.append(i)\n        return x\n\nWe need a better syntax for this. We should probably just use some sort of DSL, but I don't know what.\n\nI think you're trying too hard to be funny.\n\nI think you're trying too hard to troll.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(2, len(numbers) - 1):\n        numbers.pop()\n\n    return (first, second)\n\nReplace that with \nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in numbers:\n        numbers[i] = numbers[i] / 2.0\n        find_closest_elements(numbers[:i+1])\n\nThat's not very clever. In python, you could write the following, which I consider a better solution.", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    elements = sorted(numbers, key=lambda x: x[0], reverse=True)\n    best_two = sorted(numbers, key=lambda x: x[1], reverse=True)\n    selected = find_closest_elements(numbers, best_two, key=lambda x: x[0])\n    selected.append(x)\n    selected = find_closest_elements(numbers, best_two, key=lambda x: x[1])\n    selected.append(x)\n    return selected\n\nfor i in [2,3,4,5]:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if numbers:\n        return [0.0, 1.0]\n    else:\n        return []", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return (2, 2.2)\n\nThis is the same as the following:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    for i in numbers:\n        numbers.append(i)\n        # If the list contains two numbers that are the same distance away from each other,\n         # choose the smaller one.\n         if (i == len(numbers) - 1):\n             return tuple(i, i + 1)\n         else:\n             return tuple(i, i + 2)\n\nThis example is utterly pointless, even though the implementation is correct and concise.\nI am not sure if I should be impressed or not.\n\nHe's trying to show that the OP's \"from typing import List, Tuple\" was unnecessary, not that Python's list and tuple objects aren't useful.\n\nIt's a very simple example, yes, but I disagree with your assertion that it's completely pointless. The OP's code was written in Python 2, which had some other semantics for tuples and lists (i.e. you had to use", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\nTuple is also a built-in in Python, so I'm not sure why this is so impressive.\n\nYeah, it seems like a silly way to write the function.\nimport __builtin__", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    numbers.sort()\n    closest = numbers[0]\n    min_val = numbers[1]\n    mid_val = numbers[2]\n    return (close_to, min_val, mid_val)\n\nNote that this doesn't return the maxima or minima but the closest elements.\n\nYou can use Tuples if you want to hide the fact that they're lists.\n\nI always use tuples if they will contain lists.  It makes the code look cleaner and better organized to me.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    x = Tuple(0.0, 0.0)\n    for x in numbers:\n        x[0] = x[1]\n        x[1] = x[0]\n    return x\n\nSeems to have the same problem with infinite recursion as my solution. For example, you can run this forever on [1, 1, 2, 3, 4, 5]:\n>>> find_closest_elements(1, 1, 2, 3, 4, 5)\n[1, 2, 3]\n>>> find_closest_elements(1, 1, 2, 3, 4, 5, 5)\n[1, 2, 3]\n>>> find_closest_elements(1, 1, 2, 3, 4, 5, 5, 5)\n[1, 2, 3]\n>>> find_closest_elements(1, 1, 2, 3, 4, 5, 5, 5, 5)\n[1, 2, 3]\n>>> find_closest_elements(1, 1,", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    a = [float(i) for i in numbers if (i-1) < (i+1)]\n    for i in range(len(a)-1):\n       closest = float(i)\n       a[i] = closest[1] - closest[0]\n       return a</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    min = 0\n    max = numpys.max\n    for n in numbers:\n       if n < min:\n          min = n\n       if n > max:\n          max = n\n       min_diff = min - n\n       max_diff = max - n\n       diff = min_diff - max_diff\n       if diff < min_diff:\n          min_diff = diff\n       if diff > max_diff:\n          max_diff = diff\n       return [diff, -min_diff, max_diff]\n\nThis is not the pythonic way to do this.\nPython programmers would prefer a for loop.\nimport sys\nfor n in range(2,10):", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    from sympy import abs\n    def get_closest_elements(a, b):\n    \"\"\" Given two elements, return the smallest of them\n    and the second biggest, in the order you wish them to be in.\n    >>> get_closest_elements(a=1.0, b=2.0)\n    (1.0, 2.0)\n    >>> get_closest_elements(a=1.0, b=2.0, c=0.0)\n    (1.0, 2.0, 2.0)\n    \"\"\"\n    if abs(a) < abs(b):\n       return a, b\n    else:\n       return a, c\n\nI was trying to figure out how this would work, but the solution is simpler than I thought. Here is my understanding.\nFirst, you want to find the element that is closest to the first element.\nSince the elements are sorted, the smallest number is the closest.\nThen,", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n       return [1, 2]\n    else:\n       return [x for x in numbers if find_closest_elements(x) == x[1] for x in numbers]\n   \n\n>>> import string\n>>> str = \"find_closest_elements(1.0, 2.0, 3.0, 4.0, 5.0, 2.2)\"\n>>> print find_closest_elements(str)\n[1.0, 2.0, 3.0, 4.0, 5.0, 2.2]</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    e1, e2 = sorted(numbers, key=lambda x, y: x-y)\n    e3 = (e1, e2)\n    return (e3[0], e3[1])\n\nWhat are the downsides to using only built-in types for this? I see that it makes the code more readable, but I'm curious about the performance implications.\n\nPython's built-in types are pretty good. I think they're just fine for performance.\n\nI'd say that Python's built-in types are good for performance _if_ you don't use them in idiomatic ways. For example, string concatenation and indexing is quite slow.\n\nIndexing is fast enough for most purposes, but you're right about the string concatenation.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    lowest = 0\n\n    for number in numbers:\n        if number == lowest:\n            break\n\n    lowest = lowest + 1\n    highest = 0\n\n    closest_num = numbers[lowest]\n    closest_num = numbers[highest]\n\n    return (lowest, closest_num)</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    n = len(numbers)\n    x = 0\n    for number in numbers:\n        if number < x:\n           x = number\n           y = n - x\n           x + y = y * (x - n)\n          if y < x:\n            x = y\n           y = y * (x - n)\n          n -= x\n        return (y, x)\n\nThat's cute, but python's type system is so weak that a bug like this can be difficult to detect.\n\nHow so? The compiler will always detect that the \"x = number\" line is invalid.\n\nSure, if you trust that the compiler won't do anything silly like evaluating the expression on the right-hand side of an assignment statement.\n\nThat's why it's best to use a", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if n > 2:\n        return (1.0, n)   # From here on we assume the input list is in order", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    x = 0.0\n\n    for i in numbers:\n         numbers[i] += 1.0\n         x += 1.0\n\n    return (x, numbers[i])</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return [float(t1) if t1 < float(t2) else float(t2) for t1, t2 in zip(numbers, sorted(set(numbers))) if t1 > float(t2) else float(t2) for t1, t2 in zip(numbers, sorted(set(numbers)))]\n\nI'd like to have an explanation on what this code does and why its better than the regular find method, but maybe I am missing something.\n\n_find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    numbers = List(range(0, n))\n    pair1, pair2 = zip(numbers, range(0, n+1))\n    if pair1!= pair2:\n        return []\n    return (pair1, pair2)\n\nLet's look at the individual steps.\nNote that this is an extremely trivial example and there are much better algorithms, but this is a nice one for learning the basics.\n1. Start with an empty list.\n2. Iterate over the numbers until you've got at least two.\n3. Split the list into two sublists.\n4. Compare the elements in each sublist with each other until there are no more elements to compare.\n5. Return the two closest elements.\nNotice that in order to accomplish this, you need to do a lot of bookkeeping.\nHere's an alternative algorithm which avoids a lot of this bookkeeping. It's not as general, but it's much easier to understand.", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i, (a, b) in enumerate(numbers)\n         if a <= b:\n            return (a, b)\n\nPython is so cool</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    n = len(numbers)\n\n    for n in numbers:\n        a, b = numbers[n]\n        if a > b:\n            return Tuple[n + 1, a - b]\n    return Tuple[n, a]</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return (2.0, 2.2)", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    for i in range(1, n):\n\n        for j in range(1, n - i):\n            if numbers[j] - numbers[i] < a_closeness:\n                    return Tuple(numbers[i], numbers[j], a_closeness)\n    return []\n\nAlso:\n\nfrom typing import List\nfrom typing import Tuple", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if numbers.count() > 2:\n        return [0.5, 0.5]\n    return [0.5, 0.5] + [1.0, 1.0]\n\nWhich two?\n\nYep, that's the one bug in the code :-)\n\nBut what's the bug?\n\nThe two return values are dependent on the order in which they are returned.\n\nI think that's just a consequence of the fact that there are two return values, not a bug.\n\nI think the OP meant that the order in which they are returned is implementation dependent, which is true.\n\nCorrect.\n\nIs it just me or does anyone else have trouble deciphering code that has the first line", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if len(numbers) == 1:\n        return Tuple(1, 1)\n    else:\n        return Tuple(numbers[0], numbers[1], numbers[2])\n\nfrom typing import List, Tuple\n\n    def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    if", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    return (1.0, 2.0)\nThe number of lines in that method is inversely proportional to the clarity of the method. I can't even think of what kind of code could be simpler than that.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    from math import abs, max\n    max_value = abs(max(numbers))\n    min_value = abs(min(numbers))\n    found = []\n    found.append((max_value, min_value))\n    while len(found) < 2 and len(found) > 1:\n       max_value, min_value = found[0], found[1]\n       if max_value < min_value:\n           return Tuple(max_value, min_value)\n    else:\n           return found", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    x = Tuple()\n    y = Tuple()\n    found = []\n    for i in numbers:\n       if x[i] < y[i]:\n          x[i] = y[i]\n          found.append(x[i])\n       if x[i] > y[i]:\n          y[i] = x[i]\n    return x, y\n\nAwesome!</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for numbers in numbers:\n        if n < numbers[0]:\n           numbers[0] = n\n         else:\n            numbers[0] = numbers[0] - 1.0\n          numbers[1] = numbers[0]\n          if n < numbers[1]:\n            numbers[1] = n\n          else:\n            numbers[1] = numbers[1] - 1.0\n    return tuple(numbers[0], numbers[1])", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    numbers = List(numbers)\n    found = False\n    for number in numbers:\n       if number == other_number:\n          found = True\n       found_pair = []\n       for other_number in numbers:\n          if other_number > number:\n              found_pair.append(number)\n             found = True\n    return found_pair\n\nthis is great. it looks like you've included the wrong code at the end of the post, though.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    closest_element = []\n    for i, x in enumerate(numbers):\n       if x.startswith(i):\n          closest_element.append(x)\n    return List(Tuple(i, closest_element[0]))\n\nSimple, but cool!\n\nI've been getting a lot of mileage out of stuff like this. I am a big fan of using regular python functions where you would normally use a class (it doesn't always work, but you can usually get away with it).\n\nThe list of functions in the standard library is actually really large, as this list shows:\nThere are also some cool ones in the non-core libraries (SciPy, NumPy, etc.).\n\nI find it amusing that the reason for the\n\"from typing import *\"\nis to add line numbers, which have the opposite effect to what the OP was trying to accomplish.\n\nI find it amusing that the reason for the\n\"from typing import *\"\nis to import types that the parent class of the script needs to make the thing work, not to add line", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return Tuple(min(numbers[0]), max(numbers[1]))</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    return (numbers[0], numbers[1])\n\nThanks for the explanation. I was hoping there was a built-in `List.find_closest()` function that I didn't know about.\n\nThis is a common problem in most languages. Often the basic set of functions that come with the language are not enough.\nPython has a problem because you can't add functions to the standard library in a backwards compatible way.\n\nThis is very true and the problem is magnified by the fact that Python does not have a module system. It's a huge source of problems when it comes to packaging external libraries into a single installation.\n\nVery cool. I think it's a shame it's not part of the standard library; I'm sure it'd find some use for someone.\n\nThen someone could implement it in an incompatible way and it would break everyone's code.\n\nAnd that's why we should not rely on builtins, but have a package system with a proper deprecation policy. I can't imagine this going into the stdlib without breaking someone's code.\n\nI don't think it would break anyone's code. We're talking about a one-liner function here.", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\n    numbers = [1.0, 2.0, 3.0, 4.0, 5.0, 2.2]\n    elements = [4.0, 5.0]\n    closest_elements = []\n    for i in range(2, len(numbers)):\n        elements.append(float(numbers[i]))\n    closest_elements.append(float(elements[i]))\n    return closest_elements\n\nPython 3.2.1 on Mac OS X.\n\nThat should be:\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n(2.0, 2.2)\n>>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n(2.0, 2.0)\n\nTry:\n>>> find_closest_elements([1.0, 2.0, 3.0", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n\nI'm missing something here, but I don't understand what the point is.\n\nI'm pretty sure this is a homework assignment, and the point is to teach the student some Python, not to write some clever code.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(2, len(numbers)-1):\n        numbers[i] < numbers[0]\n        return (numbers[0], numbers[i])", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in numbers:\n        max = min(numbers[i], numbers[i + 1])\n             # Ensure max is at least one\n               if max!= 1:\n                   max = max + 1\n                   # Select the smallest element\n                   smallest = numbers[i]\n                   # Select the largest element\n                   largest = numbers[i + 1]\n                   # If there is no difference between the elements, return them in order (smaller, larger)\n                   if smallest", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    for i in range(2, n - 1):\n        if numbers[i] < numbers[i + 1]:\n           return [i, i + 1]\n    return []", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n       return [0, 0]\n    for number in numbers:\n       number1, number2 = numbers[0], numbers[1]\n       if number1 == number2:\n          return number1, number2\n       if len(number1) < len(number2) and number1[0] < number2[0]:\n          return number1, number2\n    return tuple(number1, number2)\n\nLists aren't tuples.\n\nEggs aren't hamsters.\n\nThat's completely irrelevant to whether lists are tuples.\n\nWell, it's relevant to whether lists are iterable, which is probably what you meant. But yes, in a functional programming sense, tuples and lists are the same thing.\n\nYes, I meant iterable.</s>", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    n, x, y = numbers\n    ymin = float(x[0]) / float(n)\n    ymax = float(x[1]) / float(n)\n    if ymin > ymax:\n       return List(ymin, ymax)\n    return [x[1], x[2]]\n\nOh yes, how could I forget that I could do this:\nimport math", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    f, g, h = numbers.index(0)\n    for i in range(2, len(f)):\n       f, g, h = f[i], f[i+1], f[i+2], f[i+3]\n    if f[0] < f[1] and g[0] < g[1] and h[0] < h[1]:\n       return (f[0], f[1], g[0], g[1], h[0], h[1])\n    else:\n       return (f[0], f[1], g[0], g[1], h[0], h[1])\n\nI'm not sure I understand. This seems to do the same thing as the non-list version.\nIt looks like this is essentially just this:", "from typing import List, Tuple\n\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\" \"\"\"\n    largest_element = numbers.pop(0)\n    for smallest_element in numbers:\n       smallest_element = numbers[-1]\n       largest_element = largest_element - smallest_element\n    return (largest_element, smallest_element)"]]