[["from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i in range(0, len(paren_string)):\n        for j in range(0, len(paren_string[i]):\n           if paren_string[i][j] == '(':\n                if paren_string[i][j] == ')' and paren_string[i][j-1] == '(':", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for paren_string in paren_string.split():\n        if paren_string[0] == '(':\n             return paren_string[1:]\n       else:\n             return paren_string\n\nI don't think the 'else' in the last line is needed.\n\nYou're right, I didn't think about it. I just wanted to output the nested string.\n\nThat's not a bad idea.\nI don't know if you're familiar with the list comprehensions in Python, but I think this would be a good candidate for one:\nparse_nested_parens = lambda paren_string:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string:\n          if group.startswith('('):\n                return group.pop(1)\n          else:\n                return None\n    return List(group.pop(1))\n\nNow, that is interesting.\n\nHow is that interesting? I'm not trying to be a smart ass, I just don't see what's interesting about it.\n\nIt's interesting because you have a function that takes a string that is a nested list of parentheses, and returns a list of the deepest level of nesting of parentheses.\n\nI think the point is that you could write it like this:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    nested = []\n    for i in paren_string:\n        nested.append(i)\n    return nested\n\nThis is what I was looking for. Thanks.\n\nI'm glad you found it useful.\n\nI'm glad you're glad he found it useful.\n\nI'm glad you're glad he's glad he found it useful.\n\nI'm glad you're glad he's glad he's glad he found it useful.\n\nI'm glad you're glad he's glad he's glad he's glad he found it useful.\n\nI'm glad you're glad he's glad he's glad he's glad he's glad he found it useful.\n\nI'm glad you're glad he's glad he's glad he's glad he's glad he found it useful.\n\nI'm glad you're glad he's glad he's glad he's glad he's glad he found it useful.\n\nI'm glad you're glad he's glad he's glad he's glad he's glad he found it useful.\n\nI'm glad you're glad he's glad he's glad he's glad he's glad he found it useful.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string in ['('] and not paren_string in ['])':\n         return []\n    for i in range(len(paren_string) - 1):\n           if paren_string[i] == '(':\n                 return parse_nested_parens(paren_string[i - 1])\n                  else:\n                    return []\n\nI'm not sure I understand what this does.\n\nI think it's a Python implementation of the nested parentheses problem.\n\nAh, so the problem is a list of nested parentheses, and you have to parse the list to see how many levels of nesting there are?\n\nI guess so. I don't understand the problem either.\n\nIt's a question from the programming competition \"TopCoder\".\nIt's a nice problem because it's a simple problem with a relatively simple solution,", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    level = 0\n\n    while level < len(paren_string):\n        if paren_string[level] == '(':\n              level += 1\n        else:\n               level -= 1\n\n    return List(level)\n\nThis is a good example of a \"naive\" solution. The naive solution is the one that uses the least amount of code. It is also the one that is most likely to be wrong.\nThe problem with this solution is that it is not very robust. What if the string is '()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find('('):\n        return [0]\n    else:\n        return []\n    for i in range(len(paren_string)-1, -1, 0):\n        if paren_string[i] == '(':\n              return []\n                return parse_nested_parens(paren_string[i+1:])\n\nYou can also do this with regexes:\nfrom re import match", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string:\n        if group.startswith('('):\n            # get the deepest level of nesting\n                if group.endswith(')':\n                        return group.pop()\n    return []\n\n    return parse_nested_parens(paren_string)\n\nThis is a lot of work for a simple problem. I would just do this:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [i for i in paren_string if i not in parens_string]\n\nThis is the most useful thing I've read all week.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    p = List()\n    for ch in paren_string.split(' '):\n        if ch == '(':\n            p.append(ch)\n        else:\n            p.append(ch.strip())\n    return p\n\nThis is the sort of thing that I would expect to see in a \"Python for Dummies\" book.\n\nI love Python and I love the language. But the syntax is ugly as hell.\n\nI disagree. I think it's quite elegant.\n\nI think it's a matter of taste. I like it, but I can also see how someone might find it ugly.\n\nI think it's just that people aren't used to it yet. It's a bit like the first time you use a language with a colon as a statement terminator.\n\nI'm a Python fan, but I think this is a bad example of Python syntax.\nIt's hard to read and understand what the function does.\n\nIt's hard to read and understand because it's", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [0]\n\nI think it's more readable to use a dictionary:\n>>> parse_nested_parens('(()()) ((())) () ((())()())')\n['1', '3']\n>>> parse_nested_parens('(()()) ((())) () ((())()())')\n['2', '3']\n\nYou're right. I was not sure if the function should return a list or a dictionary.\n\nI'm going to go out on a limb and say that the author has a point.\nIn my experience, the main reason that Python is so popular among programmers is that it is easy to learn. This is due to a combination of factors, including the fact that Python is simple, and the fact that the language and standard library are well-designed.\nThe Python community is also very friendly.\nThe Python ecosystem is also very large and well-maintained.\n\nI'd say that the main reason Python is popular is because it is easy to learn.\n\nI'd say that the main reason Python is popular is because it is easy to learn, and the main reason it is easy to learn is because the language and standard library are well", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) > 0:\n        # The string has at least one group.\n        if len(paren_string) == 1:\n           return []\n         # The string has no groups.\n        return []\n    else:\n        # The string has at least two groups.\n        if len(paren_string) == 2:\n           return [0]\n         # The string has no groups.\n        return []\n    else:\n        # The string has at least three groups.\n        if len(paren_string) == 3:\n           return [1]\n         # The string has no groups.\n        return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for g in paren_string.split(' '):\n         if g == \"\":\n             return []\n         if g == \"(\":\n             if g!= \")\" and g!= \")\":\n                 return [g]\n         return []\n    return List(max(len(g))-1)</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    n = len(paren_string)\n    p = 0\n    for g in paren_string:\n        if g in ['(']:\n            p += 1\n        else:\n             p += 1\n    return [p, n - p]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string.groups():\n        if group[-1] == '(':\n            return group[-1]\n            else:\n             return parse_nested_parens(group[-1])\n    return []\n\nI love how the code is written in such a way that you don't need to know the language.\n\nI don't know. I know Python, but I don't know that particular function.\n\nI love how the code is written in such a way that you don't need to know the language.\n\nI don't know. I know Python, but I don't know that particular function.\n\nI love how the code is written in such a way that you don't need to know the language.\n\nI don't know. I know Python, but I don't know that particular function.\n\nI love how the code is written in such a way that you don't need to know the language.\n\nI don't know.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i, p in enumerate(paren_string):\n        if p not in [('(', i), ('()', i), (')', i), ('(', i), ('()', i), (')', i)]:\n            raise SyntaxError('Expected '+paren_string[i]+' to be a list of parens')\n             i = i + 1\n    return List(i)\n\nAnd then there's this:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [i for i in paren_string.split(' ')]\n\nI was expecting a list of parentheses, but this is still a pretty cool hack.\n\nIt's a neat hack, but it's not really any different than the original code.\n\nI think the point is that you can call it without the parentheses, and it will still work.\n\nYes, that is exactly the point.\n\nI prefer:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return paren_string.split(',')", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find('(') == 0:\n       return []\n    for i in range(len(paren_string)-1):\n       if paren_string.find('(') == i:\n          return parse_nested_parens(paren_string[i+1:])\n    return []\n\nThis is one of the best Python examples I've seen. I'll definitely be using it.\n\nI don't get it. Is it just a list of the nesting levels?\n\nYes.\n\nThis is a good example of using python as a DSL.\n\nYou should probably note that this is a bad idea in a language like Python that has a lot of metaprogramming facilities.\n\nWhy is this a bad idea?\n\nBecause it's easy to write a parser that parses your DSL into Python code.\n\nThis is why I don't like DSLs.\n\nThis is why I like them.\n\nIt's just a matter of taste.\n\nI'm not a big fan of DSLs because they usually mean", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return []\n\nfrom typing import List\n\n    def parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return []\n\nYou could do:\nfrom typing import List", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find('(')!= -1:\n        return []\n    return [nested_parens(paren_string.find('('), 0)]\n\nYou could probably make this a lot shorter by using regular expressions instead of a full parser.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    def get_level(paren_string, depth=0):\n        if paren_string == '(':\n            return []\n         if paren_string == ')':\n            return 1\n         if paren_string == ')' or paren_string == '(' or paren_string == ')'\n            return -1\n         return get_level(paren_string, depth-1)\n   \n    return [0 for _ in get_level(paren_string, 0)]\n\nI've seen this approach used a lot. Why not just use the standard library's list comprehension?\n\nIt's faster and doesn't require the user to know about list comprehensions.\n\n_It's faster_\nI doubt it.\n_and doesn't require the user to know about list comprehensions_\nWhy not?\n\nThe post is about parsing nested parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string.split():\n        if group == '(':\n             return group\n       else:\n             return parse_nested_parens(group.split())\n    return []</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i in range(1, len(paren_string)):\n        if paren_string[i] == '(' or paren_string[i] == ')':\n            return parse_nested_parens(paren_string[i - 1])\n        else:\n            return 0\n\nThis is a very bad code snippet.\n\nPlease explain why you think it's bad. I can't see anything obviously wrong with it, but I'm not an expert.\n\nI'm not an expert either, but I can think of a few reasons why it's bad.\n1\\. It's not idiomatic Python. It's a one-liner, and that's not the way Python is supposed to be used.\n2\\. It's not very readable. There are a lot of things going on in a small amount of code, and it's not clear what they all do.\n3\\. It's not very extensible. If you want to parse something slightly different, you'll have to go through the whole thing and change", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    input = paren_string.rstrip(' ')\n\n    return input.split(' ')", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) > 0:\n        return List(0, len(paren_string)-1)\n    else:\n        return []\n\nThis is a very common pattern, but it's a shame that the python standard library doesn't support it.\n\nThe \"standard library\" supports it. It's just not a built-in function.\n\nI think the point was that it's a shame that it's not a built-in function.\n\nI was hoping for a more interesting hack, like a parser that can parse nested parentheses and also handle different types of parentheses.\n\nI was hoping for a more interesting hack, like a parser that can parse nested parentheses and also handle different types of parentheses.\n\nI was hoping for a more interesting hack, like a parser that can parse nested parentheses and also handle different types of parentheses.\n\nI was hoping for a more interesting hack, like a parser that can parse nested parentheses and also handle different types of parentheses.\n\nI was hoping for a more interesting hack, like a parser that can parse nested parentheses and also handle different types of parentheses.\n\nI was", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find('(').startswith('('):\n        return []\n    if paren_string.find('(').endswith(')':\n        return []\n    if paren_string.find('(').endswith(')':\n        return []\n    if paren_string.find('(').endswith(')':\n        return []\n    if paren_string.find('(').endswith(')':\n        return []\n    if paren_string.find('(').endswith(')':\n        return []\n    if paren_string.find('(').endswith(')':\n        return []\n    return [0] + [len(paren_string.strip()) - 1] + [len(paren_string.strip()) - 1]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i, (g, s) in enumerate(paren_string):\n        if g == '(' and s == ')' and i < len(paren_string):\n            return i\n        else:\n            return parse_nested_parens(s)\n\nHow about:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for paren in paren_string.split():\n        if paren.find(':') == 1:\n           return paren.pop()\n        else:\n           return paren.pop()\n    return []\n\nA better solution is to use a regular expression to parse the string, and then use a stack to keep track of the nesting depth.\n\nNice.\n\nI'm a little confused by the use of `return []` in this code. It doesn't appear to do anything except make the code harder to read.\n\nThe whole point of the function is to return an empty list.\n\nI think it would be better to return a list of the nesting depths.\n\nThe whole point of the function is to return an empty list.\n\nI think it would be better to return a list of the nesting depths.\n\nI think it would be better to return a list of the nesting depths.\n\nI think it would be better to return a list of the nesting depths.\n\nI think it would be", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for paren_group in paren_string:\n        if paren_group.startswith('('):\n             return paren_group\n        else:\n             return List(parse_nested_parens(paren_group.rstrip(' '))[0])\n\nI'm not sure what the point of this is. It seems like a very contrived example.\n\nI think the point is that it's a contrived example that shows off the feature.\n\nI don't know python, but I think I get the gist of it.\nIt's a list comprehension with the result of the comprehension returned as a list of lists.\n\nIt's a list comprehension with a list of lists as the argument.\n\nI think the syntax is very intuitive.\n\nIt's more concise and readable than nested for loops, but it's not a new idea.\n\nI'm not sure what the point of this is. It seems like a very contrived example.\n\nI think the point is that it", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string:\n         if group is None:\n            return []\n          if group.startswith('('):\n               if group.endswith(')':\n                    return group", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find('(') == -1:\n       return []\n    for i in range(len(paren_string)-1, 2):\n        if paren_string[i] == '(' and paren_string[i+1] == ')':\n            if paren_string[i] == '(':\n                 return parse_nested_parens(paren_string[i+1:])\n                 else:\n                   return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for g in paren_string:\n        if g == '(':\n             return g\n        else:\n             return parse_nested_parens(g.split(' '))\n\nThis is a nice example of a function that's easy to read but difficult to write.\n\nHow do you mean? The code is pretty straightforward.\n\nIt's hard to write because it's hard to write code that looks easy to read.\n\nI find this code easy to read. I'm not sure why you would find it hard to read.\n\nI think you're taking the word \"hard\" too literally.\n\nThis is a really cool tool. It's like a regular expression for nested parentheses.\n\nI'm not sure if this is a joke or not, but I'm pretty sure that's what regular expressions are.\n\nThis is a joke, right?\n\nI know you are joking, but I would like to share my experience. I have been working on a project with a friend where we have to use", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    nested_level = 0\n    while len(paren_string):\n        if paren_string[-1] == '()':\n            nested_level = 1\n        else:\n             nested_level = len(paren_string)\n        if nested_level > 0:\n             output = []\n             for sub_string in paren_string[-1:]:\n                   if paren_string[-1] == '(' or paren_string[-1] == ')'", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    paren_string = '(' * len(paren_string) + ')'\n\n    for n in range(len(paren_string) - 1, -1, 0):\n        if n == 1:\n            return [n]\n           else:\n              return [paren_string[n:] for paren_string in paren_string.split()]\n    return [n]</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    result = []\n    while len(paren_string) > 0:\n       result.append(parse_nested_parens(paren_string[0]))\n       if len(result) == 1:\n          return result\n    else:\n          return result[0]\n\nOh, I get it. It's a joke about python.\n\nSo it's a joke about Python, but not a joke about Lisp?\n\nOh, I get it. It's a joke about Lisp.\n\nSo it's a joke about Lisp, but not a joke about Python?\n\nOh, I get it. It's a joke about both Python and Lisp.\n\nSo it's a joke about both Python and Lisp, but not a joke about Haskell?\n\nOh, I get it. It's a joke about Haskell.\n\nSo it's a joke about Haskell, but not a joke about Ruby?\n\nOh, I get it. It's a joke about Ruby.\n\nSo it's a joke about Ruby, but not", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 2:\n        return []\n    else:\n        return []\n    for group in paren_string.split():\n        if group.startswith('('):\n           return []\n        else:\n           return parse_nested_parens(group)\n    return List[int(len(parse_nested_parens(paren_string))))\n\nWhy not just use a list comprehension?\n\nI think the point is to show how to do it without a list comprehension.\n\nI think the point is to show how to do it without _any_ comprehension.\n\nI guess. I just don't see the point. It's not like list comprehensions are hard to write or anything.\n\nI think the point is to show how to do it without _any_ comprehension.\n\nI guess. I just don't see the point. It's not like list comprehensions are hard to write", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    l, _ = str.split()\n    if l:\n         if paren_string[l] == '(':\n                 return []\n                  else:\n                    return [paren_string[l] for paren_string in l]\n    return l\n\nA better approach is to use regular expressions and not split the string.\n\nOr, better yet, use the _regular_ string module.\n\nI like this. I've been wanting to write a function to do this for a while, but I was going to use regular expressions.\n\nThere's also this: \n\nThanks for the link. I did not know about this.\n\nIf you're looking for something like this that can be used with strings that are not ASCII (as in, you have to deal with the occasional \\uXXXX), then this is what I use:\nfrom unicodedata import ucs2", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    def get_nested_level(paren_string):\n        return len(paren_string) - 1\n    return [0] * get_nested_level(paren_string)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [i for i in parens if (i!= '(' and i!= ')')]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for line in open('parens.txt'):\n        line = line.strip()\n        for word in line.split():\n            if word in paren_string:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [int(len(paren_string[0])) for paren_string in paren_string.split(' ')]\n\nimport sys, math, time", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    input = paren_string.split()\n    for i in range(len(input)):\n        if input[i] == '(':\n             input[i] = input[i].strip()\n        else:\n              input[i] = input[i].strip()\n        input = input.split()\n        if input[0] == '(' and input[1] == ')' and input[2] == ')' and input[3] == ')' and input[4] == ')' and input[5] == ')' and input[6] == ')' and input[7] == ')' and input[8] == ')' and input[9] == ')' and input[10] == ')' and input[11] == ')' and input[12] == ')' and input[13] == ')' and input[14] == ')' and input[15] == ')':", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find('(')!= -1:\n        return []\n    p = paren_string.find('(')\n\n    for group in p:\n         if p.find('(')!= -1:\n             p.pop()\n             else:\n              p = p.find('(')\n               if p!= -1:\n                    p.pop()\n                   else:\n                     p.pop()\n                     p.pop()\n    return p\n\nI am not sure if this", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [p for p in paren_string.split() if p.startswith('(')]\n\nThis is a great example of why Python is so easy to read.\n\nI am not a Python programmer, but I have a few questions.\n1\\. Why is this code so much better than:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for paren_group in paren_string.split():\n        if paren_group not in []:\n           raise TypeError('invalid group')\n           for child in paren_group.split():\n              if child not in []:\n                 raise TypeError('invalid child')\n                 for child in child.split():\n                   if child not in []:\n                      raise TypeError('invalid child')\n                      for child in child.split():\n                       if child not in []:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.startswith('('):\n        return []\n    for paren_group in paren_string.split(' '):\n        if paren_group.startswith('('):\n             return []\n             if paren_group.endswith(')':", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for p in paren_string:\n        if p:\n            if p:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string in ('()'):\n         return []\n    else:\n         return parse_nested_parens(paren_string.rstrip())\n\nfrom typing import List", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [len(paren_string) - 1 for p in paren_string if p.strip()[-1]!='']\n\nThis is the only function I've ever seen that takes a list of nested parens as input.\n\nI'm not sure that I understand the point of this, but it's certainly a novel way of parsing it.\n\nIt's a toy function. I used to have a job where I had to write parsers for all kinds of different grammars. This is a very simple way of doing nested parens.\n\nI just wanted to say that I like this very much.\n\nReminds me of this:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) > 0:\n         return [0]\n    else:\n         return [0, len(paren_string)]\n\nI've been writing a lot of code lately that uses Python's list comprehensions to do things that are conceptually simple. I find that I have to write a lot of boilerplate code to make it look like the code is simple. I'm not sure if this is just because I'm new to Python or if it's a common thing for Python programmers.\n\nThe example you gave is a bit contrived, but I can see how it would be useful. In general, I don't like to use list comprehensions when there is a more straight-forward way to express the logic.\n\nI've been writing a lot of code lately that uses Python's list comprehensions to do things that are conceptually simple. I find that I have to write a lot of boilerplate code to make it look like the code is simple. I'm not sure if this is just because I'm new to Python or if it's a common thing for Python programmers.\n\nThe example you gave", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [0]*len(paren_string)\n\nThis is the Python equivalent of this:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string)!= 2:\n        return []\n    for group in paren_string.split(':'):\n        if group == '()':\n            return []\n         else:\n            if group == '())':\n               return []\n          else:\n               if group == '{':\n                   return []\n           else:\n                  if group == '(':\n                        return []\n           else:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [i for i in paren_string.split() if i.strip()[0] == '(']\n\nI'm not sure I get it.\n\nIt's a simple recursive parser for nested parentheses.\n\nI'm not sure that I understand the point of it, or why it's interesting.\n\nIt's not that interesting, but it is very simple and straightforward. I could see using it in a project where I'm parsing strings and need to handle nested parentheses.\n\nIt's interesting. I didn't know Python had a built-in function to parse nested parens.\n\nIt doesn't. This is a simple function that you can use to parse nested parens.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [0] * (len(paren_string) - 1) + 1\n\nI don't understand what the function is supposed to do. Is it supposed to output the deepest level of nesting of parentheses? If so, how does it know where the end of the string is?\n\nThe function takes a string (representing a set of parentheses) and returns the number of nested parentheses.\n\nOkay, I understand now.\nThe function takes a string (representing a set of parentheses) and returns the number of nested parentheses.\n\nI don't understand what the function is supposed to do. Is it supposed to output the deepest level of nesting of parentheses? If so, how does it know where the end of the string is?\n\nThe function takes a string (representing a set of parentheses) and returns the number of nested parentheses.\n\nOkay, I understand now.\nThe function takes a string (representing a set of parentheses) and returns the number of nested parentheses.\n\nI don't understand what the function is supposed to do. Is it supposed to output the deepest level of nesting of parentheses? If so, how does it know where the end of the string is?\n\nThe", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i in range(0, len(paren_string)-1):\n        i = i+1\n        if i == len(paren_string):\n           return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n             return []\n        if paren_string[i] == ')':\n             return []\n        if paren_string[i] == ')' or paren_string[i+1] == ')' or paren_string[i+1] == ')' or paren_string[i+1] == ')' or paren_string[i+1] == ')':\n              return []\n    return [i]\n\nI prefer this one:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    nested_parens = []\n    for i in range(len(paren_string)):\n        if len(paren_string[i]) == 1:\n            return nested_parens\n         else:\n             nested_parens.append(paren_string[i])\n    return nested_parens</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    def get_paren_levels(paren_string: str) -> int:\n    \"\"\" Output the maximum level of nesting of parentheses in a string.\n    >>> get_paren_levels('(()()) ((())) () ((())()())')\n    3\n    \"\"\"\n    return len(paren_string.split('')[0])\n\nI'm not sure why the code was posted, but I'd recommend something like this:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 1:\n        return []\n    else:\n        return parse_nested_parens(paren_string[:1])\n\nThis is a really neat idea, but the implementation seems to have some issues.\nFor example:\n>>> parse_nested_parens('(())((())())')\n[2, 3, 1, 3]\n>>> parse_nested_parens('(())(())')\n[2, 3, 1, 3]\n>>> parse_nested_parens('(())(())()')\n[2, 3, 1, 3]\n>>> parse_nested_parens('(())(())(())')\n[2, 3, 1, 3]\n>>> parse_nested_parens('(())(())(())(())')\n[2, 3, 1, 3]\n>>> parse_nested_parens('(())(())(())(())(())())')\n[2, 3, 1, 3]\n>>> parse_nested_parens('(())(())(", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string.split(' '):\n       if group.find('(') == 0:\n           return []\n          else:\n           return group.find(')')", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 1:\n        return List(1)\n    if len(paren_string) == 2:\n        return List(2)\n    if len(paren_string) == 3:\n        return List(3)\n    for group in paren_string:\n        if group.startswith('('):\n            return group.pop(0)\n            else:\n              return List(1)\n\nThis is a very simple, but very useful function. I've used it before, but I never saved it.\n\nI'm not sure why you need to do this:\nreturn group.pop(0)\ninstead of:\nreturn group\n\nThe first form returns a list with one element, the second returns a list with two elements.\n\nAh, that makes sense.\n\nI use the following method to get the depth of", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) > 1:\n         return [0]\n    if paren_string[0] == '(':\n         return [0]\n    if paren_string[0] == ')':\n         return [1]\n    if paren_string[0] == ')':\n         return [1]\n    else:\n         return [0]\n\nI've seen people use this, but I have no idea what it does. Does it just look for parentheses in a string, or is there something more to it?\n\nI use it to find the level of nesting of a string in parentheses.\n\nIs there a specific reason you don't use \"print\" and \"int\" instead?\n\nIt's an example of how you can use the `from typing import *` idiom.\n\nI understand that. But why use it for this specific case?\n\nBecause it's an example of how you can use the `", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    nested_level = 0\n    for character in paren_string:\n        if character == '(' or character == ')' or character == '{' or character == '}':\n            nested_level = 1\n        else:\n             return nested_level\n\nfrom typing import List", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [int(len(paren_string)) for _ in paren_string.split(' ')]\n\nI'm not sure I understand why this is a good idea.\n\nIt's not a good idea, it's just a _fun_ idea.\n\nI think it's a good idea. It's a simple idea, but it's a good idea.\n\nI don't think it's a good idea. It's a simple idea, but it's not a good idea.\n\nIt's a good idea, but it's not a simple idea.\n\nI think it's a simple idea, but it's not a good idea.\n\nIt's a good idea, and it's a simple idea.\n\nI think it's a simple idea, but it's not a good idea.\n\nIt's a good idea, but it's not a simple idea.\n\nI think it's a simple idea, but it's not a good idea.\n\nIt's a good idea, but it's not a simple idea.\n\nIt's a good idea, and it's a simple idea.\n\nI think it's a simple idea, but it's not a good", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for paren in paren_string:\n        if paren.find('.(') and paren.find('.)'):\n            return paren\n    return []\n\n    def parse_nested_parens(str: str) -> List[int]:\n    \"\"\" Parse nested parentheses in a string.\n    Input is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    for paren in str:\n        if paren.find('.(') and paren.find('.)'):\n            return paren\n    return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for paren_group in paren_string.split():\n        if paren_group.startswith('('):\n           return [paren_group[0] + 1 for paren_group in paren_group.split()]\n    return []\n\nThis is a good example of a problem that is easily solved in Python, but is a bit more difficult in Ruby.\n\nI don't see how it's more difficult.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i in range(1,len(paren_string)):\n         if i == 0:\n             return []\n         else:\n             if i == len(paren_string)-1:\n                 return parse_nested_parens(paren_string[i])\n          else:\n                  return parse_nested_parens(paren_string[i+1])\n    return list(parse_nested_parens(paren_string))\n\nThis is a good illustration of why you should always use a language with a decent module system.\n\nI think it's a good illustration of why you should always use a language with a decent _compiler_.\n\nI think it's a good illustration of why you should always use a language with a decent _compiler and a decent module system_.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string in ('('):\n        return [0]\n    else:\n        return [0]\n    if paren_string in (')' and len(paren_string) > 1:\n        return [0]\n    else:\n        return [0]\n    return [1]</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    a = 0\n    while not eof(paren_string):\n        a, child = parse_nested_parens(paren_string[a:])\n        if child:\n             a += 1\n    return [a]\n\nThis is a very useful snippet.\nI'm curious, what would you use this for?\n\nI've used it for parsing of nested parens in a grammar.\n\nThis is a nice example of the usefulness of Python's functional programming capabilities.\n\nI would have written it like this:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string in ('('):\n        return []\n    p = '('\n    while p:\n        if paren_string == p:\n           return p\n        p = paren_string\n        p = p + ')'\n        return []\n    return List(p)\n\nfrom typing import List", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    # Parse the string.\n    # This should be obvious.\n    for paren in paren_string:\n        if paren[1] == '(' and paren[0] == ')':\n            return paren[0]\n        else:\n            return None\n    return List(int(paren[0]))</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    start = 0\n    while paren_string:\n        if paren_string.find('(') == -1:\n             paren_string = paren_string.replace('(','')\n             start = paren_string.find('(')\n             if start == 0:\n                 return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) > 1:\n        paren_string = paren_string[0]\n    else:\n        paren_string = '('\n        for x in paren_string:\n            if x == '(':\n                     paren_string = paren_string[1]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 0:\n        return []\n    for group in paren_string:\n        if group == '':\n           return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 1:\n        return []\n    else:\n        input = paren_string.split(' ')\n        if len(input) == 1:\n           return []\n        else:\n             input = input.split(' ')\n             if len(input) == 1:\n               return []\n              else:\n                input = input.split(' ')\n                if len(input) == 1:\n                  return []\n                else:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return list(s.split(','))\n\nThat's not a bad idea. You could add a boolean argument to specify the number of levels of nesting.\n\nI'm not sure I understand. How does this differ from the's' module's'split' function?\n\nsplit returns a list of elements, whereas this function returns a single list of tuples.\n\n(()())()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [0] * len(paren_string) + 1", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    try:\n        return List(0, 0, 0, 0)\n    except ValueError:\n        return []\n    return List(0, 0, 0, 1)\n\nWhy not use list comprehensions?\n\nYou can use a list comprehension to parse a string like this:\n>>> parse_nested_parens('(()()) ((())) () ((())()())')\n[(0, 0, 0, 0), (0, 0, 0, 1)]\nBut you can't use list comprehensions to do something like this:\n>>> parse_nested_parens('(((())()())()()())()())')\n[(0, 0, 0, 0), (0, 0, 0, 1)]\n\nI think you can. The only difference is that you need to use the special syntax to access nested parentheses.\n\nThat's not how list comprehensions work. You can't access nested parentheses in a list comprehension. You can't even access the first element of a list comprehension.\n\nI think the point is that list comprehensions are not a very good way", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    nested_parens = []\n    while len(paren_string) > 0:\n        if paren_string[0] == '(':\n           nested_parens.append(parse_nested_parens(paren_string[1:]) + 1)\n        else:\n            nested_parens.append(parse_nested_parens(paren_string[1:]) + 1)\n        else:\n            nested_parens.append(parse_nested_parens(paren_string[1:]) + 1)\n    return nested_parens\n\nI'm not sure I understand this. Can someone explain?\n\nIt's a simple implementation of a parser for nested parentheses.\n\nAh, I see. Thanks.\n\nI don't see the point of this. Python already has a parser for nested parens. You can do it with regex, or you can do it with a", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 1:\n        return []\n    else:\n        for group in paren_string.split():\n            if group.startswith('('):\n                   return parse_nested_parens(group)\n         else:\n                   return []\n\nHow is this better than the following?\n\nfrom typing import List", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string:\n        # if the group is empty, just return it\n        if group == '()':\n           return []\n        # find the deepest level of nesting\n        if group == '(' and not group in []:\n            return [0]\n        # if it is not the deepest level of nesting, return it\n        if group in [1, 2]:\n            return [1]\n        # find the deepest level of nesting\n        if group == ')' and not group in []:\n            return [0]\n        # if it is not the deepest level of nesting, return it\n        if group in [1, 2]:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 1:\n        return []\n    else:\n        for i in range(len(paren_string)):\n           if paren_string[i] == '(' or paren_string[i] == ')' or paren_string[i] == ')':\n                 return parse_nested_parens(paren_string[i + 1])\n    return []\n\nI don't get it. I am not familiar with Python, but shouldn't that return [] for all input?\n\nI think it's the \"if len(paren_string) == 1:\" part. The author is checking to see if the input is a single group, and if it is, returns an empty list.\n\nYou're right, it should be an empty list for all input.\n\nI think that's the joke.\n\nI think it's a joke that the author is not aware that the code he wrote is wrong.\n\nI think it", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for paren in paren_string:\n         if paren_level == 0:\n             return []\n            else:\n              if paren_level == 1:\n                     return [paren]\n                   else:\n                        return [paren]\n    return []\n\nI would have expected this to be a list comprehension\n\nI think you're probably right. I was just trying to think of a way to do it without a for loop.\n\nI'd expect a for loop to be faster.\n\nI would have thought the same thing. But, when I tried it, it was about the same speed.\n\nI don't know Python, but why not just use a list comprehension?", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 0:\n        return []\n    for p in paren_string:\n        if p[0] == '(' and not p[1] == ')':\n             return []\n        else:\n              return p\n\nI'm not sure why this is an interesting submission. The code is pretty simple and the results are obvious.\n\nI agree. The code is pretty simple, but I think the result is interesting.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i in range(0, len(paren_string)):\n         p = paren_string[i]\n         if p == '(':\n             break\n               return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    i = 0\n\n    while i < len(paren_string):\n        if paren_string[i]:\n            i += 1\n\n    return [i]\n\nI think this is a nice example of why Python is a bad language for implementing parsers.\n\nIf you're going to say that, then you should explain why.\n\nBecause it's not a general purpose language.\n\nI think that the point is that this is a very simple example of a parser, so it's not really a good example of why Python is a bad language for implementing parsers.\n\nI think the point is that Python is not a general purpose language.\n\nI think the point is that this is a very simple example of a parser, so it's not really a good example of why Python is a bad language for implementing parsers.\n\nI think the point is that Python is not a general purpose language.\n\nI think the point is that this is a very simple example of a parser, so it's not really a good example of why Python is a bad language for implementing parsers.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i in range(len(paren_string)):\n        if i in paren_string:\n             return 0\n             if i not in paren_string:\n                     return 1\n    return 0\n\nI wonder if it would be possible to make this a little more efficient by using a binary search to find the first nesting level and then using that as a starting point for the search for the next level.\n\nThis is a really cool little trick, but it doesn't seem like it'd be all that useful.\n\nI'm not sure if I'd ever want to use it in production code, but it's a really fun way to learn how python's parser works.\n\nI was thinking that it might be useful for parsing code in comments, but then I realized that you could just use the parens as syntax highlighting and get the same effect.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    try:\n         list = []\n\n    for paren_group in paren_string:\n          list.append(1)\n\n    return list\n\nI'm pretty sure the author means \"from typing import list\" not \"from typing import List\"\n\nI'm pretty sure that's a joke.\n\nI'm pretty sure that's not a joke.\n\nI'm pretty sure that's not a joke.\n\nI'm pretty sure that's not a joke.\n\nI'm pretty sure that's not a joke.\n\nI'm pretty sure that's not a joke.\n\nI'm pretty sure that's not a joke.\n\nI'm pretty sure that's not a joke.\n\nI'm pretty sure that's not a joke.\n\nI'm pretty sure that's not a joke.\n\nI'm pretty sure that's not a joke.\n\nI'm pretty sure that's not a joke.\n\nI'm pretty sure that's not a joke.\n\nI'm pretty sure that's not a joke.\n\nI'm pretty sure that's not a joke.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 1:\n        return []\n    else:\n         return parse_nested_parens(paren_string[::-1])\n\nThis is a nice example of a Python \"one-liner\".\n\nIndeed, it's a _pythonic_ one-liner.\n\nIt's not a one-liner if it requires a library.\n\nI'm not sure that's a useful distinction. In some languages, \"one-liners\" are defined as programs that can be written on one line, but it's not clear that that's a useful definition.\n\nI think it is a useful distinction. One-liners are for example used in shell scripts, and in shell scripts you don't have access to a library.\n\nI think the best definition of a one-liner is a program that can be written on one line, but is not restricted to a specific language.\n\nI think the best definition of a one-liner is a program that can be written on one line, but is not restricted to a specific language.\n\nI think the best definition of a one-liner", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string[0] == '(':\n        return []\n    if paren_string[1] == ')':\n        return []\n    if paren_string[2] == ')' or paren_string[2] == ')':\n        return [0]\n    if paren_string[3] == ')' or paren_string[3] == ')':\n        return [1]\n    else:\n        return [2]\n\nI don't get it.\n\nYou can use nested parentheses to represent a tree structure, and the code is meant to parse a string into a tree structure.\n\nOr you could just use the built in list type.\n\nThis is just a silly example of how you could use the list type.\n\nI would have preferred the built-in list type.\n\nI'm not sure I understand. Are you saying you would have preferred a built-in list type? If so, why?", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) > 1:\n        return []\n    else:\n        return [0]\n\nThat's a really bad way of doing it.\n\nWould you mind elaborating on why?\n\nIt's not very efficient. It's not very readable. It's not very extensible.\n\nI'm not sure I agree with that. What's inefficient about it? It's pretty readable to me, and I don't see how it's not extensible.\n\nIt's inefficient because it's doing a lot of work to compute the maximum level of nesting. It's not extensible because it doesn't allow you to specify what the maximum level of nesting is.\n\nI don't see how it's doing any more work than a regular expression would.\n\nIf you don't see how it's doing any more work than a regular expression, then you should be able to write a regular expression that does the same thing.\n\nI'm pretty sure I can't, since I don't know the syntax of regular expressions.\n\nI have a feeling that you don't know the syntax of regular expressions.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string:\n        if group.find('('):\n           return group.pop()\n    return []\n\nThis is a nice little snippet.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string:\n        if group is not None:\n           return group\n    return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    result = []\n    for p in paren_string:\n       if p is None:\n          return []\n       if p is ():\n           result.append(0)\n       if p is ():\n           result.append(1)\n       if p is ():\n           result.append(2)\n    return result\n\nI am surprised that the author did not know about the built-in function 'list'.\n\nI'm not surprised, since I don't know it either.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string.split(', '):\n         if group == '()':\n              return []\n         else:\n              return [group]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 1:\n        return []\n    for group in paren_string.split(' '):\n        if group in paren_string:\n           return []\n        if group[1] in paren_string:\n           return [group[1]][0]\n        else:\n           return [group[1]]\n\nYou can do better.\n\nI'd love to see the better version!\n\nHeh, I was just being cheeky. I can't think of a way to do it better, either.\n\nI had a similar idea to this a while back, but I couldn't figure out how to represent the nesting.\n\nI don't understand why this is on the front page, it's a few lines of code that doesn't do anything interesting.\n\nI think this is pretty cool.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string.split(' '):\n        if group == '(':\n              return []\n         else:\n               return parse_nested_parens(group)\n\nI'm not sure what I'm supposed to be learning from this.\n\nIt's a simple solution to a simple problem. It's a nice example of how to use Python's syntax to express a solution.\n\nYeah, but the problem is not that simple. The number of parentheses is variable, and the nesting is not necessarily linear.\n\nYes, but the problem is simple enough to be solved with a simple solution.\n\nI think you're missing my point.\n\nI think you're missing my point.\n\nI think you're missing my point.\n\nI think you're missing my point.\n\nI think you're missing my point.\n\nI think you're missing my point.\n\nI think you're missing my point.\n\nI think you're missing my point.\n\nI", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) < 3:\n       return []\n    else:\n       return parse_nested_parens(paren_string[:-1])\n\nThis is a useful function. The more I think about it, the more I like it. It's like the Python equivalent of this:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i in range(len(paren_string)):\n        try:\n           if paren_string[i] == '(':\n                return parse_nested_parens(paren_string[i+1:])\n           except ValueError:\n                return []\n    return parse_nested_parens(paren_string)\n\nI wonder why he didn't use the built-in _s method, which does the same thing.\n\nBecause it's a bit buggy.\n\nI think it's just that the _s method is optimized for Python 2.x.\n\nI was going to ask why he didn't just use the built-in _s method, but then I read the comments and saw that it's been deprecated.\n\nIt's not deprecated, it's just not available in Python 3.\n\nOh, I thought it had been deprecated in Python 2.x.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if not paren_string.startswith('('):\n        return []\n    for paren_group in paren_string.split(' '):\n        if paren_group in paren_string[-1]:\n           return []\n        else:\n            if paren_group == '())':\n                return [0]\n         else:\n                return [paren_group]\n\nFor the first example, this would return [1, 2, 2] (counting the ()'s as level 0).\n\nfor i in range(0, len(parse_nested_parens( '()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) < 3:\n        return []\n    try:\n        for i in range(len(paren_string)-1, 2):\n            if i == len(paren_string):\n                return []\n                if paren_string[i] == '()':\n                   return parse_nested_parens(paren_string[i+1:])\n                   else:\n                      return parse_nested_parens(paren_string[i+1:])\n    except IndexError:\n        return []\n\nIt's not so much that it's \"incorrect\" as that it's a bit", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) < 1:\n        return []\n    l = 0\n    for i in range(len(paren_string) - 1, -1, 1):\n        if paren_string[i] == '(':\n           l += 1\n        else:\n           paren_string[i] = paren_string[i] + ')';\n    return l\n\nI like this.\n\nI don't understand it.\n\nIt's a function that takes a string of nested parentheses and returns a list of the maximum depth of nesting.\n\nI know what it is supposed to do, I just don't understand how it does it.\n\nIt looks like it just looks for a '(' and then checks the character after it. If it's a ')' it adds one to the counter.\n\nI guess I should have said \"I don't understand how it works.\"\n\nLooks like it just traverses the string, finding the", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    count = 0\n    while len(paren_string) > 0:\n        count += 1\n        p = re.findall(r'(', paren_string)\n        while p:\n           if p.find('('):\n                count = count + 1\n               if p.find(')':\n                    break\n                   return count\n\nThis is a bad example of this sort of thing. The problem is that the input string is not a valid Python expression, so you can't really parse it.\nHere's a better example:\n>>> parse_nested_parens('(foo) bar)\n[1, 2]\n>>> parse_nested_parens('(foo) bar (baz)')\n[1,", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    n = len(paren_string)\n    groups = []\n    for p in paren_string:\n        if p.startswith('('):\n            groups.append(n)\n        else:\n             groups.append(p)\n    return groups", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [len(paren_string.rstrip(' ')) for paren_string in paren_string.split() if paren_string.strip() == '(']\n\nfrom typing import *", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    try:\n         return []\n    except IndexError:\n         return [0]\n\nI really don't get it.\n\nI'm not sure if it's a joke or not, but I think the author is trying to say that the nested parentheses are being parsed as a list of numbers (0, 1, 2, 3).\n\nIt's not a joke, it's a joke.\n\nI think he's saying that nested parentheses are being parsed as a list of numbers.\n\nI think he's saying that nested parentheses are being parsed as a list of numbers.\n\nI think he's saying that nested parentheses are being parsed as a list of numbers.\n\nI think he's saying that nested parentheses are being parsed as a list of numbers.\n\nI think he's saying that nested parentheses are being parsed as a list of numbers.\n\nI think he's saying that nested parentheses are being parsed as a list of numbers.\n\nI think he's saying that nested parentheses are being parsed as a list of numbers.\n\nI think he's saying that nested parentheses are being parsed as a list of numbers.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if not paren_string.startswith('('):\n        return []\n    for paren_string in paren_string.split(' '):\n        if not paren_string.endswith(')':\n           if paren_string.endswith(')':\n               return []\n                  else:\n                     return [paren_string[0], paren_string[1], paren_string[2]].split(' ')\n    return list(parse_nested_parens(paren_string))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if not paren_string:\n        return []\n    for i, p in enumerate(paren_string):\n        if i == 0:\n           return []\n         else:\n            if p == '(':\n                 return []\n                 else:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 1:\n        return []\n    else:\n        return parse_nested_parens(paren_string[::-1])\n\nfrom typing import List", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string in ['()', '[]', '{', '}']:\n       return []\n    for group in paren_string.split(' '):\n        if group in ['(', ')', '{', '}']:\n            return [group[0], group[1], group[2]]\n    return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [int(i) for i, group in enumerate(paren_string) if group.startswith(paren_string[i]))\n\nIt's interesting that the same problem is solved in two completely different ways.\n\nI like the second solution better.\n\nThe second solution is a lot clearer, but I'm not sure it's as efficient. I'm not sure how the Python parser works, but I wouldn't be surprised if it had to create a stack for every subexpression, which would be a lot of work for the second solution.\n\nNot really. It's a list comprehension. The recursion is in the list comprehension, not in the parser.\n\nThe recursion is in the parser, because it has to parse the list comprehension.\n\nThe parser doesn't need to parse the list comprehension, it needs to parse the string.\n\nThe string is a list comprehension.\n\nThe string is a string. The parser doesn't care about the syntax, it just needs to know how to parse the string.\n\nAnd the string is a list comprehension. It's parsed the same way a list comprehension would be parsed.\n\nThe difference between the two solutions is that", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string.split():\n        level = parse_nested_parens(group)\n    if level > 0:\n        return [group.pop() for group in level]\n\nJust a note: this is a problem that has been solved for decades. The solution is called \"regular expression\" and it is used for parsing many things, not only nested parentheses.\n\nThis is a nice implementation. I like the fact that it is simple and easy to understand.\n\nIt's nice and simple, but not very fast.\n\nIt's not meant to be fast, it's meant to be simple.\n\nIt's not very simple, either.\n\nIt's not meant to be very simple either.\n\nSo what's it for?\n\nI'm sure the author knows what it's for.\n\nI'm sure he does, too.\n\nI'm sure you both do.\n\nI'm not sure why you're not sure.\n\nI'm not sure why you're not sure why he's not sure.\n\nI'm not sure why you're not sure why he", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 1:\n       return []\n    for i in range(1, len(paren_string)):\n       if paren_string[i] == '(':\n          paren_string[i] = ')'\n          paren_string[i] += 1\n          if paren_string[i] == ')'\n           paren_string[i] = ')'\n           paren_string[i] += 1\n    return List(len(paren_string))\n\nI'm not sure what's the point of the article, but it seems like a bad example.\nThe obvious solution is to just ignore the spaces in the string.\n\nI agree, the example is rather contrived.\n\nI don't understand how the author can claim that this is a \"more elegant\" solution than just using the built-in str.split() function.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    paren_levels = {}\n    for c in paren_string.split(', '):\n        if c == '(':\n           if c == ')' or c == '{':\n                 paren_levels[c] = 1\n             else:\n                 paren_levels[c] = 0\n                 else:\n                  paren_levels[c] = -1\n                   else:\n                   paren_levels[c] = 0\n                    paren_levels[c] = -1", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for paren_group in paren_string.split(' '):\n         if paren_group.startswith('('):\n               return []\n               else:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    nested_groups = []\n\n    for char in paren_string:\n        if char == '(':\n           nested_groups.append(1)\n        else:\n            nested_groups.append(0)\n\n    return nested_groups\n\nfrom typing import List, Set, Map, Setoid, Type, TypeError, TypeErrorSet\n\n    def parse_nested_parens_set(paren_string: str) -> Set[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens_set('(()()) ((())) () ((())()())')\n    {1: 2, 2: 3, 3: 1}\n    \"\"\"", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string.split(', '):\n        if group == '':\n           return []\n          if group in []:\n            return []\n           if group in [, ],:\n               return [group]\n              return []\n    return list(map(parse_nested_parens, group))\n\nfrom typing import List", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string == '(':\n        return []\n    if paren_string in ['(']:\n        return [0]\n    if paren_string in ['(', ')', '{', '}']:\n        return [0, 2]\n    if paren_string in ['(', ')']:\n        return [0]\n    if paren_string in ['(',')', '{', '}']:\n        return [1]\n    if paren_string in ['(',')', '{', '}']:\n        return [2]\n    return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string in ('('):\n        return [0]\n    else:\n        return [0, 0]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string == '':\n       return []\n    for g in paren_string.split(':'):\n       if g == '(':\n           return g\n       else:\n           return parse_nested_parens(g)\n\nI'm not sure that's much better.\n\nI think it's more readable, and it's more flexible. You can just call it without the string and it will work just fine.\n\nI prefer the original.\n\nI like the original as well, but the problem with the original is that the string needs to be quoted if it contains commas, which is a pain.\n\nYou could do:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return (list(paren_string.split(',')[0] for paren_string in paren_string.split(',')[1:]))</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 1:\n       return []\n    if len(paren_string) == 2:\n       return [0]\n    return [0] * parse_nested_parens(paren_string[1:] + ')']\n\nI love this. It's like a mini-language.\n\nIt's a bit like the \"structured programming\" languages that were popular in the '70s.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return list(set(paren_string.split(' '))[0] for paren_string in paren_string.split(' '))\n\nI would have expected it to be a list of tuples.\n\nWell, it is.\n\nI think the point was that the tuple is missing a key, since there is no way to distinguish between (()()) and ((())) in the above example.\n\nOh, I see. Thanks.\n\nI love it when people write code that is concise, elegant, and easy to read.\n\nIt would be even more elegant if the author had used a List comprehension instead of a loop.\n\nNot necessarily.\n\nIn this case, it would be.\n\nIt's also nice to see the list comprehension in action:\n\nI think this is a great example of a good use of list comprehensions.\n\nFor the uninitiated, list comprehensions are a way to write nested loops using Python.\nI like the explicit way of writing them in Python. I find that it's a good way to get a better understanding of the language.\n\nI don't really understand how you can write a nested loop using list comprehens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i in range(len(paren_string)):\n        if paren_string[i] == '()':\n           return [i]\n        else:\n           return [len(paren_string)-1]\n\nYou can just write:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(' or ')' or paren_string[i] == '(' or ')' or paren_string[i] == '(' or ')' or paren_string[i] == '(' or ')' or paren_string[i] == '(' or ')' or paren_string[i] == '(' or ')' or paren_string[i] == '(' or ')' or paren_string[i] == '(' or ')' or paren_string[i] == '(' or ')' or paren_string[i] == '(' or ')' or paren_string[i] == '(' or ')' or paren_string[i] == '(' or ')' or paren_string[i] == '(' or ')' or paren_string[i] == '(' or ')' or paren_string[i] == '(' or ')' or paren_string[i] == '(' or ')' or paren_string[i]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if not paren_string.endswith('('):\n        return []\n    for group in paren_string.split():\n        if group in paren_string.find('('):\n            return []\n             else:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.startswith('('):\n        return []\n    for l in paren_string.split():\n        if l.startswith('('):\n            return l\n            else:\n              if l.endswith(')':\n                 return l\n                else:\n                    return []\n\nThis is a good example of a very simple Python program that's very easy to read and understand. I think the one thing that makes it so easy to read is that the author didn't use any of the language's more advanced features.\n\nThere are other examples of \"simple Python\" that are not so easy to read:\n\nI was about to post that. I think the problem with the \"complex\" version is", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find('(')!= 0:\n        paren_string = paren_string[1:]\n        print \"Found %s\" % paren_string\n    return []\n    if paren_string.find('(') == 0:\n        return []\n    for x in paren_string:\n        if x.find('(') == 0:\n            print \"Found %s\" % x\n            return x\n\nI can't believe you actually wrote that.\n\nI can't believe you can't believe it.\n\nI can't believe you can't believe he can't believe it.\n\nI can't believe you can't believe he can't believe you can't believe it.\n\nI can't believe it's not butter.\n\nI can't believe you can't believe it's not butter.\n\nI can't believe you can't believe he can't believe it's not butter", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find(' ') == 0:\n        return []\n    for i in range(1, len(paren_string)):\n        if paren_string[i]!= '(':\n           if paren_string[i]!= ')' and paren_string[i+1]!= ')' and paren_string[i+1]!= ')':\n                 return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    # \"paren_string\" is a string of groups of parentheses, separated by spaces.\n    # \"result\" is the list of groups, where the last group contains the deepest level of\n    # nesting.\n    result = []\n    for group in paren_string:\n       if group.startswith('('):\n          result.append(group.pop())\n       else:\n          result.append('(')\n       else:\n          raise ValueError('Invalid group')\n\nI know this is supposed to be a joke, but this is a terrible idea. It is a very poor way to represent nested parentheses.\nFor example, if you have a nested parentheses with an indentation of 3, and you want to get the last level of nesting, you have to look at each level of nesting and see if the indentation is 3.\nIf you want to get the deepest level of nesting, you have to look at each level of nesting and see if", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [len(paren_string.rstrip(' ')) for p in paren_string if p.find('(')!= -1]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    n = 0\n    for i in range(len(paren_string) - 1):\n        n += 1\n    if paren_string[i] == '(':\n        return List(n)\n    return List(n - 1)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    paren_string = re.sub(r'(', '()'), paren_string)\n    for group in paren_string.split():\n        if group == '()':\n             return []\n         else:\n              p = group.split(' ')\n              if p == '()':", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    result = []\n    for char in paren_string:\n        if char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == '", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for p in paren_string:\n        if p in paren_string[0]:\n           return p\n        else:\n            return parse_nested_parens(paren_string[p:])\n\nThis is a cool idea, but I think it's a bit of a stretch to call this \"pythonic\".\n\nHow so?\n\nIt's a bit of a stretch to call anything \"pythonic\" :)\n\nI was going to say the same thing.\n\nIt's not Pythonic, but it is a great way to learn how to use a dictionary.\n\nOr how to use list comprehension.\n\nOr how to use a list comprehension to use a dictionary.\n\nDoesn't that kind of defeat the purpose of a dictionary?\n\nThe purpose of a dictionary is to store key/value pairs. If you want to store nested lists, you can do that in a dictionary.\n\nSure, but it's not a great way to learn how to use a dictionary. It's a great way to", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [len(paren_string), len(paren_string) - 1]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    paren_string = re.sub(r'(\\w+)\\s+(\\w+)\\s*', '', paren_string)\n\n    for group in paren_string:\n        if group.find('(') == -1:\n            return []\n        else:\n             deepest = 0\n             if group.find('(') > -1:\n                 deepest = deepest + 1\n                paren_string = group.sub(r'\\s+','')\n                  return List(deepest)\n\nI would recommend using a list comprehension.\n\nList comprehension is not supported in Python 2.\n\nOh, that's a shame.\n\nI'm not sure I understand what you're doing with the code", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find('(') == 0:\n        return []\n    else:\n        return parse_nested_parens(paren_string.substring(1, paren_string.length() - 1))\n    return []\n\nI like the idea of a string representation of a list of nested parentheses, but I'm not sure I understand the usefulness of the function.\n\nI think it's a good example of a recursive algorithm that can be easily implemented without recursion.\n\nYes, it's a good example of that, but I'm not sure it's a good example of a useful function.\n\nI guess it depends on what you're doing. If you're writing a parser for Lisp, then this is a great example of a function that can be used to parse nested parens. If you're not writing a parser for Lisp, then it's probably not useful.\n\nI see the recursion, but I don't see the recursion.\n\nThe recursion is in the definition of the function parse_nested_parens. It calls itself to parse the next", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i, (j, p) in enumerate(paren_string):\n        if i >= 0 and j >= 0:\n            return p\n    else:\n            return 0\n\nThis is a pretty cool idea, but the code is too verbose. I did this in Python:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            if paren_string[i-1] == ')' and paren_string[i-1] == '(':\n                   output i\n         else:\n                 output i + 1", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find('(').isnotNone:\n        return [0]\n    else:\n        return [1]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    max_depth = 0\n\n    for group in paren_string.split():\n        max_depth += 1\n\n    return max_depth</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 1:\n        return []\n    else:\n        for group in paren_string.split():\n           if group.startswith('('):\n                 return [group[0] for group in paren_string.split() if group[0] not in list]\n              else:\n                 return []\n\nThis is a good example of a common anti-pattern. If you find yourself writing a function that does something like this, then it's a sign that you have a design problem.\nThis function would be much better as a class method.\n\nI'd say that it's a sign that you're trying to use a hammer to pound in a screw.\n\nThis is a great example of a \"one-off\" script.\nI've written a few of these. They're really easy to write and really easy to read", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 1:\n        return []\n    for group in paren_string:\n        if group == '(':\n           return [group]\n        else:\n            return [group, group + 1]\n\nI think this is a little too clever. It's not hard to write a recursive version of this that is much more readable.\n\nI think that the point of the article is to show how to use the built-in types in Python to solve a problem.\n\nI think the point of the article is to show how to write an article that uses the built-in types in Python to solve a problem.\n\nI think the point of the article is to show how to write an article that uses the built-in types in Python to solve a problem by writing an article that uses the built-in types in Python to solve a problem.\n\nThis is a great little article. I love these kinds of posts. I've been reading a lot of them lately.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.startswith('('):\n        return []\n    for sub_string in paren_string.split(' '):\n        if sub_string.startswith('('):\n            return []\n             if sub_string.endswith(')':\n               return sub_string[1:]\n    return []\n\nI don't understand why this is a Python code snippet.\n\nBecause Python is the only language that can do this.\n\nThis is a very easy task. The only difficult part is parsing the string.\n\nI don't think you need to parse the string. You can just look at the characters and see if they're a paren or not.\n\nThe problem is that you can't just look at the characters. You have to know if you're looking at the start of a paren, the end of a paren, or the beginning of an open paren.\n\nI'm", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return []\n\nI'm not sure I understand the problem.\n\nIt's a variant of the Knuth up-arrow notation.\n\nI'm still not sure what the problem is.\n\nI'm not sure how I feel about this. It's a bit like a Pythonic version of the IO monad, but I'm not sure how useful that is.\n\nIn the IO monad, there is a clear separation between pure and impure code. This is very useful when you want to keep the code pure.\nIn this case, the code is already impure.\n\nI think you're misusing the term \"impure.\" In Python, everything is impure, including functions. It's just that some things are _less_ impure than others.\n\nI don't see how that is true. It's true that everything in Python is an object, but that doesn't make all functions impure.\n\nYou're right. I should have said \"everything is a function.\"\n\nThis is awesome! I'm going to have to play around with this.\n\nThis is cool. I'm going to have to play around with this.\n\nThis is awesome. I'm", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [0]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for p in paren_string:\n        if p.isalpha():\n            if p.isupper():", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for p in paren_string:\n        if p[0]!= '(' and p[1]!= ')' and p[2]!= ')':\n            return []\n    else:\n            return p\n\nI really like the python syntax, and I really like the fact that I can define functions that take a string and return a list. But I never really thought about it, but if I really think about it, it's a bit odd that a language which is so concerned with readability and readability only allows you to have nested parens in a string.\n\nHow about this:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    nested_nested = 0\n    for group in paren_string:\n       nested_nested += 1\n    return nested_nested</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    while len(paren_string) > 1:\n        if not isinstance(paren_string, str):\n           raise TypeError('Input string must be a string')\n           return []\n           if len(paren_string) == 1:\n            return []\n           if len(paren_string) == 2:\n             return List(0)\n            if len(paren_string) == 3:\n              return List(1)\n            if len(paren_string) == 4:\n              return List(2)\n             if len(paren_string) == 5:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 1:\n        return []\n    else:\n        for sub_string in paren_string:\n           if sub_string in ('('):\n                return sub_string\n          else:\n               return parse_nested_parens(sub_string)\n\nI would use a list comprehension instead.\n\nList comprehension is _not_ a replacement for list operations.\n\nI've seen people use list comprehensions to replace for loops, and I've seen people use them to replace comprehensions.\n\nI've seen people use for loops to replace for loops.\n\nI've seen people use comprehensions to replace comprehensions.\n\nI've seen people use comprehensions to replace comprehensions.\n\nI've seen people use for loops to replace for loops.\n\nI've seen people use comprehensions to replace comprehensions.\n\nI've seen people use for", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return []\n\nfrom typing import List", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    count = 0\n    for group in paren_string:\n        if group == '(':\n           count += 1\n        else:\n            count += 1\n    return List(count)\n\nNote that the above code is a little bit buggy. It doesn't handle empty groups correctly (it just adds 1 to the count).</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    input = str(paren_string)\n\n    if input.find(' ').count() == 0:\n        return []\n    else:\n        for paren_group in input:\n           if paren_group in paren_string:\n               return paren_group\n         else:\n               return []\n    return input.split(' ')", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for p in paren_string.split(\",\"):\n        if p in paren_string[1]:\n            return []\n        else:\n            return [p]\n\nSee also\n\nfrom typing import List", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n            return []\n        else:\n            return parse_nested_parens(paren_string[i + 1])\n    return List(len(paren_string))\n\nThis is a very nice and readable way to do this.\nHowever, it's a little bit too clever. It would be better to use a list comprehension instead.\n\nAgreed.\n\nDoesn't Python have some kind of built-in list comprehension syntax?\n\nNot built-in, but there is a library for it: \n\nThis is an example of a really neat way to solve a problem. I'm going to have to remember that.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    n = len(paren_string)\n\n    for group in paren_string:\n        for i in group:\n           if i == '(':\n                return []\n        else:\n                 return [i]\n\n    return list(n)\n\nThat's clever. I wonder how it compares to the list comprehensions in Python.\n\nThe Python version would be something like this:\n>>> parse_nested_parens('(()()) ((())) () ((())()())')\n[2, 3, 1, 3]\n\nI'm not sure that's right. Python has a list comprehension syntax, but it's not as concise as the Python example.\n\nYeah, I was just trying to make a list comprehension in Python using the OP's example. I wasn't trying to write a list comprehension in Python using the Python list comprehension syntax.\n\nI like how this is actually a \"typing\" module,", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for g in paren_string:\n        if g.startswith('('):\n           return g\n        else:\n            return g.pop()\n\nWow, this is a good example of why I hate the \"from typing import *\" idiom.\n\nThe problem with this is that you have to know what you want to do with a list before you can even begin to use it.\n\nYou're right. You have to know what you want to do with a list before you can even begin to use it.\n\nI'd say it's a matter of preference. I've found that when I have to write a large amount of code, I often want to use a list when I'm actually doing something else. The following is a contrived example, but I've found that it's much easier for me to write code this way.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [len(paren_string) - 1 for p in paren_string if p.startswith('(')]\n\nAnd the output:\n[2, 3, 1, 3]\n\nI don't understand why the author didn't use the Python list comprehension syntax. It's pretty clear and concise.\n\nBecause it's not a list comprehension. It's a generator.\n\nI think you're missing the point.\n\nI think you are. The point is that this is a generator. You can't use list comprehension syntax on generators.\n\nI was talking about the author's code, not the OP's.\n\nThis is not a list comprehension. It's a generator.\n\nI know. I was talking about the author's code, not the OP's.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    list = []\n\n    for item in paren_string:\n        if item.isdigit():\n            if item == '(':\n                 list.append(parse_nested_parens(item))\n                  else:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    nested_parens = []\n    for group in paren_string.split():\n        if group == '(':\n           nested_parens.append(0)\n        else:\n            nested_parens.append(group)\n    return nested_parens\n\nI don't get it.\n\nMy guess:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return []\n\nThis is a neat little code snippet, but I don't see the point.\n\nI think the point is that the code is written in Python.\n\nI think the point is that the code is written in Python.\n\nI think the point is that the code is written in Python.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i in range(len(paren_string)):\n        if i == 0:\n            return []\n       else:\n             if paren_string[i - 1] == '(':\n                  return paren_string[i - 1]\n         else:\n                   return [i - 1]\n\nI don't get it. Could you please explain?\n\nIt's a joke. The code is a list comprehension.\n\nOh, I get it now. Thanks!\n\nI'm going to start using this.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find('(') == 0:\n        return []\n    else:\n        return [p for p in paren_string if p.find('(') > 0]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 1:\n        return []\n    else:\n        return parse_nested_parens(paren_string[:-1])\n\nSo you are saying that the code is broken because it doesn't work with the following string:\n((()))()\n\nNo, it's broken because it doesn't work with:\n(()()))()\n\nI'm sorry, but that's just wrong.\n\nNo, it's not wrong. In the first case the first group is () and the second is ()(). In the second case the first group is () and the second is ()()()()().\n\nYes, it is. If you have a function that accepts a string, and that string is a valid string, then it's wrong to say that it's broken.\n\nI think we're talking past each other. When I said \"it's broken\" I didn't mean \"it's wrong\". I meant \"it doesn't work\".\n\nBut it does work.\n\nI think you're right. I was confused by the fact that the string you showed was accepted by the", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    input_string = input_string.replace(' ','')\n    return input_string.split(' ')\n\nThis is a great example of how to write a recursive function in Python.\n\nI'm not sure what you're getting at here.\n\nI'm not sure what I was getting at there.\n\nI've never been a fan of nested parentheses, but I think it's a bit unfair to compare the nested parens in Lisp to the nested parens in Python.\nFor one thing, Lisp's nested parens are used to indicate the nesting of functions. In Python, they're used for a completely different purpose, and so they're bound to be a bit more verbose.\nFor another, Lisp's nested parens are a part of the language itself. In Python, they're just a convention. And so, as with all conventions, they're bound to be a bit more verbose.\n\nThis is very true.\nHowever, the function is recursive, and I don't think that nested parens are the only way to express a recursive function.\n\nTrue, and I agree. But, as I said, Lisp's nested p", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string:\n        if group.find('(') == None:\n            return []\n        else:\n            return group.find(')')\n    return []\n\nI find the explanation to be not very clear. The code is very simple and straightforward, and I don't see what's wrong with it.\n\nI guess I could have been clearer. The problem is that the output doesn't match the input.\n\nI'm not sure what you mean. The output does match the input. The input is a string with nested parentheses separated by spaces, and the output is a list of groups with nested parentheses.\n\nThe input is a string with nested parentheses separated by spaces, and the output is a list of groups with nested parentheses.\nRight. The input is (()()()) and the output is [2, 3, 1, 3]\n\nYes, that's exactly right.\n\nI can't see how it's possible to parse nested parens without using a stack.\n\nThat's", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find('('):\n        return [0]\n    for i in range(len(paren_string)-1):\n        if paren_string[i] == ')' and paren_string[i+1] == ')':\n            return [i]\n    return []\n\nThis is a nice little snippet, but the example is a bit contrived. I would have liked to see how it handles more realistic examples, like this:\n(()())\n(()))\n((()))\n(()))\n((())))\nI would guess that it would output [1, 2, 3, 3].\n\nI would guess it would output [1, 2, 3].\n\nWhy?\n\nThe example you posted has () at level 2, () at level 1, and () at level 3.\n\nI see.\n\nI'm not sure I understand the point of this. You can just call the function in the example without importing it.\n\nBecause it's a single line of code, so it's", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i in range(len(paren_string)):\n        if paren_string[i] == '(':\n           return []\n        else:\n           return parse_nested_parens(paren_string[i+1])\n    return List(i)\n\nIs there a reason why this doesn't use the builtin parse.parse?\n\nBecause it's a toy example and parse.parse is a function of the standard library.\n\nThis is a toy example, but I think it's a good example of why you should always use the builtin parsers where possible.\n\nI agree. I didn't realize parse.parse existed until I read your comment. I had to look it up.\n\nYou might want to check out this:\n\nI'm surprised there are no comments on this. I thought it was pretty interesting.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [int(i) for i in paren_string.split() if i in paren_string.split()]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    while len(paren_string) < 3:\n        p = parse_nested_parens(paren_string[0:1])\n        if p == 0:\n            return List(0)\n        else:\n             return List(p)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    l = []\n    l.append(0)\n    for i in range(len(paren_string)):\n        if i == 0:\n           return l\n        else:\n            if paren_string[i] == '()' or paren_string[i] == ')':\n                if paren_string[i+1] == '()':\n                    l.append(i+1)\n                   else:\n                     l.append(0)\n                     return l", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string:\n        if group == '()':\n            return []\n        else:\n             group = group.split(' ')\n            for item in group:\n                 if item == ')' or item == ')'':\n                       return []\n                 else:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for g in paren_string:\n        for p in g:\n           if p.startswith('('):\n                 output = []\n                output.append(0)\n                for i in range(2):\n                   output.append(p.pop(i))\n                  return output", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    from itertools import islice\n\n    for char in paren_string:\n       if char == '(':\n          return []\n       else:\n           return islice(parse_nested_parens(char), 1)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string:\n        if group.find('(') == -1:\n            return []\n            group = group.find('(')\n             return group.find(')')\n    return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [len(paren_string.split(' ')) for paren_string in paren_string.split(' ')]\n\nfrom typing import List", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find('(') == -1:\n        return []\n    for g in paren_string.split(' '):\n        if g == '(':\n            if g == paren_string.find(')':\n                  return paren_string.pop(1)\n                   else:\n                     return []\n    return [g[0], g[1]]\n\nThis is a bad example, since it's trivial to get the answer with just a single recursive call.\n\nWell, the point is that you can't just write a recursive function and assume it will always work, because you can easily run into stack overflows. This code shows how to handle the problem of nested parentheses.\n\nNo, the point is that you can't write a recursive function and assume it will always", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    # Group 1: ((()))\n    # Group 2: ()\n    for p in paren_string.split(' '):\n        if p.startswith('('):\n           return p\n        else:\n            return []\n\nThis is a very nice solution, but the code is a bit harder to read than the original.\n\nI think that's the point.\n\nIt's an interesting exercise, but it's hard to imagine anyone wanting to use it in real code.\n\nIt's just a simple exercise, but I do like how it illustrates the concept.\n\nThat's a lot of nesting!\n\nI know! I was expecting it to be a lot easier to parse, but I guess there is a lot of ambiguity in the grammar.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) < 2:\n       return []\n    for sub_string in paren_string:\n        if sub_string.find('(')!= -1:\n            return sub_string\n             else:\n              return []\n    return [len(paren_string) - 1, len(paren_string) - 1]\n\nI have no idea why this is so funny.\n\nI'm laughing so hard I can't even type.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    start = 0\n    while len(paren_string) > 1:\n        if paren_string[start]!= '(' or paren_string[start]!= ')':\n            start += 1\n           else:\n             start += 1\n            if start == len(paren_string):\n              return []\n             if paren_string[start] == '(':\n                 return [start]\n               if paren_string[start] == ')':\n                  return [start]\n    return [start]\n\nI know this is a joke, but it doesn't seem to be very funny.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    # if the string is not in the given format, return None\n    if paren_string not in ('(', ')', ')':\n        return None\n    # if the string is in the given format, split it into a list of strings\n    strings = paren_string.split(' ')\n    # if the string is not empty, return the list of strings\n    if len(strings) > 0:\n        return strings", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string:\n        if group.endswith('('):\n           if group.endswith(')':\n                output = []\n                   for level in group.split(' '):\n                           output.append(level)\n                             return output\n\nfrom typing import List", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    i = 0\n    while paren_string:\n       if i == len(paren_string):\n          return []\n          if paren_string[i] == ')' and paren_string[i]!= ')':\n             i = i + 1\n            return paren_string[i]\n\nI wonder if this would be a good way to implement a parser for a language that uses a lot of parentheses, like Lisp.\n\nThat's an interesting idea. I'd be curious to see what the performance of such a parser would be.\n\nI'm sure it's not the most efficient way to do it, but it's easy to write, and it's a lot easier to read than a parser that's written in a traditional way.\n\nI agree it is easier to read than a parser written in a traditional way.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find('(') == -1:\n       return []\n    for i in range(1, len(paren_string)):\n       if paren_string[i] == ')':\n           return i\n    return [i]\n\nThis is the Python 2.5 syntax, not Python 3.3.\n\nI'm not sure how this is Python 3.3 syntax. I've never seen it before, and it doesn't look like it's documented in the Python 3.3 documentation.\n\nI think he's saying the code is Python 3.3 syntax, not the example.\n\nOh, OK. I thought he meant the example was Python 3.3 syntax.\n\nIt's a nice little piece of code, but I don't think it's a good example of the language. There are several pieces of functionality in there that are not part of the language, but rather part of the standard library.\nFor example, the code is using the \"list\" module, which is part of the standard library. But Python has no notion", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [len(paren_string.split(',')[0]) + 1 for paren_string in list(paren_string.split(','))]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for _, (i, group) in enumerate(paren_string):\n         if group == '()':\n              return [0]\n          else:\n               return parse_nested_parens(group)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    nested_parens = []\n    for char in paren_string:\n        if char == '(' or char == ')' or char == '(' or char == ')' or char == '(' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or char == ')' or", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [len(paren_string) - 1 for paren_string in paren_string.split()]\n\nfrom typing import List", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.startswith('('):\n        return []\n    for paren_string in paren_string.split():\n        if paren_string.startswith('('):\n            return paren_string[1:]\n        else:\n            return []\n    return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for p in paren_string:\n        for i in range(1, len(paren_string)-1):\n           if i == len(paren_string)-1:\n               return []\n                p = p + i\n                paren_string = paren_string.replace(i,'')\n                if paren_string.startswith('('):\n                  return paren_string\n                 p = p + 1\n    return List(p)\n\nI think this would be better as a generator expression:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    i = 0\n    while paren_string:\n        if paren_string in ('('):\n            i += 1\n        else:\n             return []\n    return List(i)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.startswith('('):\n        return []\n    for i in range(len(paren_string)-1, -1, -1):\n        if paren_string[i] == ')':\n             return paren_string[i]\n    return []\n\nI don't get it. What is the point of this?\n\nI wrote this when I was learning python. I was trying to see how to parse nested parentheses. It took me a while to figure it out.\n\nI'm not a python programmer, but I don't see how this is a better solution than:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return paren_string.split(' ')\n\nThat's not much better.\n\nI don't get it. What's wrong with it?\n\nIt's not a list of integers, it's a list of strings.\n\nIt's a list of integers. It's just that it's a list of integers that happens to be represented as a list of strings.\n\nNo, it's a list of strings.\n\nIt's a list of integers. It's just that it's a list of integers that happens to be represented as a list of strings.\n\nNo, it's a list of strings.\n\nIt's a list of integers. It's just that it's a list of integers that happens to be represented as a list of strings.\n\nNo, it's a list of strings.\n\nIt's a list of integers. It's just that it's a list of integers that happens to be represented as a list of strings.\n\nNo, it's a list of strings.\n\nIt's a list of integers. It's just that it's a list of integers that happens to be represented as a list of strings.\n\nNo, it's a list of", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for _ in range(1, len(paren_string)):\n        for char in paren_string:\n            if char == '(':\n                 return []\n         else:\n                  return parse_nested_parens(char)\n\nI'm not sure if it's just me, but the code doesn't work on Firefox (3.5.9)\n\nWorks on Safari, Chrome, and IE.\n\nIt works in Firefox 3.6.\n\nWorks in Firefox 3.6.3 for me.\n\nWorks in Firefox 3.6.8, but not 3.5.9.\n\nWorks in Firefox 3.6.9\n\nWorks in Firefox 3.6.10.\n\nWorks in Firefox 3.6.11\n\nWorks in Firefox 3.6.12\n\nWorks in Firefox 3.6.13\n\nWorks in Firefox 3.6.14\n\nWorks in", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    nested = 0\n    for i in range(len(paren_string)):\n        if i in paren_string:\n            nested += 1\n    return nested\n\nThe article is about parsing nested parens, not just nesting. You can't parse nested parens without parsing the parens themselves, and it's not easy to parse nested parens.\n\nI think you missed the point of the article.\nThe point is that you can parse nested parens without the use of a list comprehension.\nI have never seen a nested parens in the wild, so I don't really know what the problem is.\n\nI think you missed the point of the article.\nThe point is that you can parse nested parens without the use of a list comprehension.\nI have never seen a nested parens in the wild, so I don't really know what the problem is.\n\nI think you missed the point of the article.\nThe point is that you can parse nested parens without the use of a list comprehension.\nI have never seen a", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 0:\n        return []\n    else:\n        p = str.find('(')\n        for i in range(len(paren_string)):\n            if p == paren_string[i]:\n                break\n                  p = str.find(')')\n                  if p == paren_string[len(paren_string) - 1]:\n                   break\n                    p = str.find(')')\n                    if p == paren_string[len(paren_string) - 2]:"]]