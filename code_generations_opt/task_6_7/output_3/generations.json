[["from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i in range(0,len(paren_string)):\n        a = list(paren_string[i].split())\n        if a.startswith('('):\n            # Single level\n             if len(a.split()) == 1:\n                   return a.pop()\n                    else:\n                      return []\n    return List(i)\n\nPrinting the parser is useful. \n\nInteresting, but it would be nice to see some sample input. (I see no documentation either.)\n\nCheck out the source of \n\nThanks, I didn't realize that was there.\n\nNice, but seems kind of slow. (I'm guessing the time per input is the time to parse the next line, not the number of", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for character in paren_string:\n        if character == '(':\n           return paren_string[character - 1]\n        if character == ')':\n           return paren_string[character - 1]\n       else:\n           return 0\n\ninteresting, but I prefer the version in the post above:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    def expand_nested_parens(parsed_string: str) -> List[int]:\n    \"\"\" Expand parentheses in a nested string.\n    The parsed string is a list of group where the deepest level is represented by a single () or ().\n    For example, the following input would have 4 groups of parentheses:\n    (()())\n    >>> expand_nested_parens('(()())')\n    [1, 2, 4]\n    >>> expand_nested_parens('(()())')\n    [1, 2, 4]\n    >>> expand_nested_parens('()')\n    []\n    \"\"\"\n    def list_parsing_function(sep_char: str) -> List[int]:\n    \"\"\" Function to convert a string representing groups of parentheses separated by a single space into a list of ints.\n    Example input:\n    >>> list_parsing_function('(()())')\n    [2, 3, 1, 3]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    len = len(paren_string)\n\n    n = 0\n\n    for i in range(len-1, len+1):\n\n        if paren_string[i-1] == ')' and paren_string[i-1]!= '()':\n           n = n + 1\n        else:\n           n = n + 1\n        if paren_string[i-1] == ')':\n           n = 0\n        else:\n           n = 0\n        return n\n\nNow we can write it as a function.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    data = List()\n    for i in range(len(paren_string)):\n       data.append(i)\n    for g in paren_string.split(', '):\n       data[len(data) - 1].append(g.group(0))\n    return data\n\nI've never understood why people write code like this.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return paren_string.split(' ').get_deeper(3)\n\nfrom typing import List", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    paren_string = str.rstrip('\\n')\n    for p in paren_string:\n        if p.find('(') == 0:\n           return []\n          else:\n            deepest = -1\n           for i in range(1,len(p)):\n               if p[i] == '(':\n                  deepest += 1\n                 else:\n                  deepest = p[i]\n                   if deepest == 0:\n                     return [p.find('(') + 1]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string:\n        return []\n    for s in paren_string:\n        if s == '(':\n          return [0]\n           if s == ')':\n            return [1]\n            if s == ')' or s == '{':\n               return [2]\n               if s == '}':\n                  return [3]\n    else:\n        return []\n\nThis is exactly the same thing that appears in the first chapter of Effective Python. If I was grading assignments, I'd give it zero points.\n\nthis is a very cool exercise. i'm gonna make one with other languages.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n\n    if paren_string == \"\" or paren_string.find(\"(\") or paren_string.find(\"))\":\n        return []\n\n    paren_string = re.sub(r'^(()|)$', r'', paren_string)\n\n    return paren_string.split(\"\\n\")[-1].findall(lambda s: s == \")\")\n\nSee also:</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [int(len(paren_string))]</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    c = 0\n    while len(paren_string) > 0:\n        if paren_string[-1]!= '(':\n             c = parse_nested_parens(paren_string[-1:])\n          else:\n              c = parse_nested_parens(paren_string[:])\n          if c > 0:\n              parens = c - 1\n             return List(parens)\n\nc = 0\n\nfor paren_string in '('':\n\np = parse_nested_parens(paren_string)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [len(paren_string) - 1 for p in list(paren_string)]\n\nI think it would have been better to use the new function called `isinstance`\n(which will become a part of Python 3.2) and use it to test that the given\nstring is a string representation of a paren group. This way you could\neliminate the list comprehension and the recursive call.\n\nFor example, your function would look like this:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for g in paren_string:\n        if len(g) > 1 and g[0] == '(':\n           return g[1]\n        else:\n           return None\n\n    return List(int(len(g)))\n\nI was going to say that this function should be named is_nested_parens, but, looking at the Python documentation, it already is.\n\nI like to call it \"lispy_parsing\" myself.\n\nWhat's wrong with the author's \"lispy_parsing\"?\n\nIt's not Lispy.\n\nI use this regularly in my projects. It's a nice and flexible way to look for deep nesting.\n\nI use it all the time when I'm working on scientific code. It's a fantastic way to be able to easily parse and count the number of nested matrices, vectors, etc.\n\nIn Python I use:\nimport re", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string == '()':\n        return []\n    return [len(paren_string) - 1 for paren_string in list(paren_string)]\n\nNote that Python 3.0+ will have a built-in function with the same name:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string == '':\n        return []\n    try:\n        l = []\n        l.append(paren_string)\n        for i in range(len(paren_string)):\n           if paren_string.find(i).startswith('('):\n               paren_string[i] = paren_string[i].replace('(','(').replace(')','(').replace(')','(')).replace('))','))\n             l.append(i)\n         return l\n\nWell, the code is more complicated than it needs to be. This is because you are trying to be clever. The key here is to be lazy.\nLet's think about this for a moment. We want to parse nested parentheses. This means that our input will be a string which looks like:\n(()())", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i, p in enumerate(paren_string):\n        if i == 0:\n           return []\n        if i < p:\n            return [p - 1] + parse_nested_parens(paren_string[i - 1]) + [p]\n    return [i + 1] + parse_nested_parens(paren_string[i + 1]) + [i]\n\nThanks, I knew it was some sort of \"for\" loop, but I've never seen \"enumerate\" used before.\n\nIt's not a for loop. Python doesn't really have for loops.\nFor loops and enumerate are both looping constructs, and it's nice to know how to use both. I find enumerate very useful in many cases.\n\nPython 3 does have for loops.\n\nI know it has a for loop, I said Python doesn't have for loops.\n\n\"I said Python doesn't have for loops.\"\nThis is not Python.\n\nI have not heard", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [0]*len(paren_string)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n\n    return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    i = 0\n\n    while i < len(paren_string):\n        if paren_string[i]!= '':\n            if paren_string[i - 1]!= '':\n                i += 1\n         else:\n               i -= 1\n\n         if paren_string[i] == '' and paren_string[i - 1] == '':\n               i = 0\n\n    if i < len(paren_string) - 1:\n         return paren_string\n    else:\n         return [i]\n\nI don't quite understand what this is for. Could someone give an example of a use case for this?\n\nIt's for parsing lists of nested parentheses like this:\n(()()()()())()", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string == '(':\n        if paren_string.find('(') == 0:\n            return []\n        else:\n             return [paren_string.find('(') + 1]\n        else:\n             return [paren_string.find('(') + 2]\n        else:\n             return [paren_string.find('(') + 3]\n        else:\n             return [paren_string.find('(') + 4]\n        else:\n             return [paren_string.find('(') + 5]\n    return []\n\n`from typing import List`\n`def parse_nested_paren", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n\n    return nested_parens_list.get_nested_items()", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    start_parens = \"\"\n    while paren_string:\n        if paren_string.startswith('('):\n             p = parse_nested_parens(paren_string.pop(), []).pop()\n              start_parens += p.level\n             else:\n              start_parens += paren_string\n              # Current level of nesting is maximum of previous level and current level of nesting\n    return List(start_parens.pop())\n\nClickable:</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for symbol, i in paren_string:\n        i = i.replace(\" \", \"\")\n        i = i.replace(\"\\n\", \"\")\n        i = i.replace(\"\\r\", \"\")\n        i = i.replace(\"\\t\", \"\")\n        i = i.replace(\" \",\"\")\n        i = i.replace(\"(\", \")\")\n        i = i.replace(\")\",\"\")\n        i = i.replace(\")\", \"\")\n        i = i.replace(\")\", \"\")\n        if i.isdigit():\n           # If there is an open parenthesis, then it is a grouping\n           i = i.replace(\"(\", \")\" + i.replace(\"\"),\"\")\n           if", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    paren_strings = []\n\n    for paren_string in paren_string.split(' '):\n        paren_string_parts = paren_string.split(\",\")\n        try:\n            if paren_string_parts[-1] == ')' or paren_string_parts[-1] == ')':\n                   paren_string = paren_string_parts[-1] + paren_string_parts[-2:]\n                    paren_strings.append(paren_string)\n         except IndexError:\n             paren_string_parts = paren_string.split(\",\")\n                  paren_string = paren_string_parts[-1]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return []\n\nThere are two other key parts of this:\n1\\. import _", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    input = paren_string\n    p = 0\n    while p > 0:\n        if int(input[p:]) > int(input[p + 1:]) * 2:\n            p = int(input[p:])\n        else:\n            p += 1\n    return [input[1:] for input in input if p > 0]\n\nand the actual code:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    nested_parentheses_list = []\n    for i in range(0, len(paren_string)):\n        if paren_string[i] == '(' or paren_string[i] == ')':\n           nested_parentheses_list.append(i)\n    return nested_parentheses_list</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return list(set([i for i in paren_string if i not in paren_string for p in paren_string])\n    if i not in paren_string else []))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find(' ') == 0:\n        return []\n    else:\n        return paren_string.sub(1, 1).find(' ')\n\nparse_nested_parens('(()()) ((())) () ((())()())')\n[2, 3, 1, 3]\n\nI like this implementation much better than the Python one.\n\nit's not as if that function is hard to write in python:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    input = (\n        (list(str.strip(' '))) +\n       '' + str.strip(' ') +\n        (list(str.strip(' '))) +\n       '' + str.strip(' ') +\n        (list(str.strip(' '))) +\n       '' + str.strip(' '))\n        return [int(input[0]) + int(input[1])) for input in input]\n\nSo much for that.\n\nWow.\n\nThe code here is very cool. It's the kind of thing I think of when I think about programming.\nHowever, there's a couple of things to note.\n1\\. It's very fast.\n2\\. It's very slow.\n3\\. It's very hard to read.\nSo what's wrong with it?\nYou don't have to be a mathematician to understand that something like this, once you parse out the basic structure, is actually fairly trivial. The problem is", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    level = 0\n\n    while paren_string:\n        level += 1\n\n    return [level - 1 for p in paren_string if p not in [] for x in p.split()]\n\nand then you go on to have an interesting discussion about how the amount of nesting affects the code readability, that it's more difficult to read nested parens than indentation.\nBut the last part of your program (and the part I'm actually interested in) is the part that's supposed to show how code readability is better with parens than indentation.\nBut it doesn't. It's the same.\nTo me, the difference between having to read through two levels of nested parens and the same amount of indentation (which can be 2, 3, 4, 5 or 6 levels) is negligible, and so is the difference between having to read through three levels of nested parens and the same amount of indentation (which can also be 2, 3, 4, 5 or 6 levels).\nSo, my question to you is: what am I missing?\n\nI think it is just a case of reading more", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    l = []\n    for p in paren_string.split():\n        if isinstance(p, type(p).lower()):\n           l.append(p.split())\n    return l</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    try:\n         return [str[i:i+1] for i in range(len(paren_string) - 1)]\n    except ValueError:\n         raise ValueError('unable to parse nested parens')\n\nThat's a perfect example of the \"magic\" problem. It works for nested parens\nin this particular case because parens in Python are the same type as list\nitems. But what if your syntax had a more complicated type, e.g.\n\"regular expression\"?\n\nWhy would a regular expression have a more complicated type? It's a string...\n\nI don't know if this is the case, but if you use a regular expression, and\nyou want to parse it in a more complex manner, you might want to have the\npattern on the left hand side, not in the middle.\nFor example, given the string 'abc' \\+ 'ab' \\+ 'c', with a regexp that\nmatched 'ab' and 'c', you might want to output the string 'abc'.\n\nAh, I see what you're saying. I", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n\n    nested_levels = []\n\n    for i, group in enumerate(paren_string):\n        if i == 0:\n            nested_levels.append(group)\n\n    return nested_levels", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    output = []\n    for i in range(len(paren_string)):\n        if i == 0:\n            output.append(0)\n         else:\n            if paren_string[i] == '(':\n               output.append(i - 1)\n              output.append(i + 1)\n    return output</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for char in paren_string:\n         if is_space(char):\n             return []\n          else:\n              if char == '(':\n                    return [1]\n                else:\n                            if char == ')' or\n                               char == ')':\n                                           return [0]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return List()", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    Nested_level = 0\n\n    while len(paren_string) > 1 and len(paren_string[1:]):\n        if not paren_string[0]:\n           break\n        paren_string = paren_string[0:]\n        Nested_level += 1\n\n    return [len(paren_string) - 1 for paren in paren_string[1:]:]\n\nAnd a slightly faster version, that uses the binary operator \"and\":", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    # input can be a string\n    # or a tuple of form (n_levels, paren_string)\n    if paren_string is not None:\n       # input has one group of parentheses\n       paren_string = ('(' * n_levels) + paren_string)\n    else:\n       # input has multiple groups\n       paren_string = ('(' * n_levels) + paren_string for i in range(len(paren_string) - n_levels) if i < n_levels)\n    # first get the first group\n    # of level one\n    if i == 1:\n       return len(paren_string - i - 1)\n    # repeat the above for subsequent groups of level one\n    for j in range(len(paren_string) - n_levels - 1):\n       if i!= j:\n          return i", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    nested = 0\n    if len(paren_string) > 1:\n       if paren_string[0]!= '(':\n          nested += 1\n       paren_string = paren_string[1:]\n    else:\n          nested = 1\n    else:\n           print(\"This is a single parenthesis\")\n    return nested\n\nThat's pretty cool. I wonder if there's an equivalent for HTML? I'd like to see it for the <td> and <th> tags.\n\nThis is probably most of what you need:\nimport itertools", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    new_list = []\n\n    for i in range(0, paren_string.len() - 1):\n        new_list.append(i)\n    paren_string = paren_string[i:]\n\n    return new_list</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [len(paren_string.split(' ') + 1) for p in paren_string.split()]\n\nI use this in a similar way (after extracting the nested lists) to parse some nested log statements from some JSON logs.\nI have a function to parse nested JSON, but it doesn't handle non-nested objects, so I use the method above to parse out the nested lists of objects before using the normal method to parse the JSON.\n\nI do something very similar, but I use a regular expression to extract the nested lists. This makes it easier to treat strings of the form '(a[1])' and '((a[1]) b[2])' as two distinct cases.\n\nYeah, I'm sure there are better ways to do it, this is pretty hacky. I just didn't want to spend a lot of time on it since I only use it in one place, and this is good enough for me :)</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n\nI know some people don't like the nested parentheses, but I find them quite useful.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    words = list(map(str.strip, paren_string))\n    if len(words) == 1:\n        return []\n    for i in xrange(0, len(words) - 1):\n        if i == 1:\n           return parse_nested_parens(words[i-1:])\n         else:\n           return parse_nested_parens(words[i])\n\nwtf\n\nMost people who see this would think it's more WTF-worthy.\n\nHey, there's nothing wrong with nesting. It's just the way the list is handled that's the problem.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in parse_nested_parens(paren_string):\n        if group[0] == '()':\n            return group\n    return [group[1:] if group[0] == '/' else list(group[1:]))\n    >>> parse_nested_parens('(())) ((())) () ((())())())\n    [1, 2, 3, 4]</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    max_nesting = None\n    list = []\n    for group in paren_string.groups():\n        if group.startswith('('):\n            if group.endswith(')':\n                  return max_nesting\n                   else:\n                      list.append(parse_nested_parens(group))\n                       if group.endswith(')':\n                        list.append(max_nesting)\n                        if group.startswith(')' and max_nesting is not None:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    result = []\n    for i in range(0, len(paren_string)):\n        if paren_string.find(\" \"):\n           result.append(i)\n        else:\n           if paren_string.find(\"{}\").isdigit():\n                result.append(paren_string.substring(i+1, paren_string.find(\" \"))[1:-1])\n        else:\n                result.append(paren_string.substring(i+1, paren_string.find(\" \"))[1:-len(paren_string)-1])\n    return result\n\nGreat. But I hate how you have to read the doc comments to learn what the function does.\nI'm still very much a beginner in Python, but I think that might be because it's just not easy to get that", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.startswith('()') or paren_string.startswith(')'\n          return []\n          return List(len(paren_string.split('()')), len(paren_string.split('(')))]\n\nYes, it is a shame they don't teach you about recursion in schools.\n\nI use this function all the time. I've been looking for a way to abstract it out and make it a decorator so that it doesn't always have to be called as a separate function.\n\nWhy?\n\nBecause you can build the same function that way and it is easier to read.\n\nOr just use the built-in list comprehension:\n[(len(parentheses_string) if (parentheses_string in ('', '(')) else 1 for _ in list(parentheses_string))) for _ in list(parentheses_string)]\n\nIn a similar vein, I wrote a function that turns nested lists into nested dictionaries, so you can walk over a list and use normal for and in statements without worrying about having to type out multiple", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n      if paren_string.find('('):\n        return [2]\n      else:\n        return [3]\n\nI'm a bit curious what you're using this for. Is it not quicker just to use list comprehension?\n\nIt is quicker to use list comprehension. This is a joke.\n\nOn a more serious note, I think the reason Python doesn't have an \"if\" statement is because it's not really needed.\nFor example, if you want to test something then you can just use a list comprehension.\n\nInteresting. I guess you can use nested list comprehensions if you don't need to handle more than one condition.\n\nThis is an interesting one. A few months ago I wrote a library called libnest (github:  ) to parse nested list comprehensions. It was mainly for a side-project, but I've been thinking about porting it to Python.\n\nI wrote something similar a while ago.\n\nI remember using this a while back as well.\n\nI'd be wary of using this code as it has a potential XSS vulnerability, the", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    # Split the string at the first parentheses.\n    # The parentheses are always separated by spaces.\n    split_string = str.split(space)\n    # Note that the parentheses are in different order in the two strings.\n    # Therefore, we have to reverse the order of the two strings to compare them.\n    reverse_string = reverse(split_string)\n    # Compare the two strings. If the strings are not the same, there are more\n    # levels of nesting.\n    if reverse_string!= reverse(paren_string):\n        # Output the deepest level.\n    for i in range(len(reverse_string)):\n        # If this is not the deepest level, go one level deeper.\n    if i > 1:\n        # If the depth is the same as the input string, print the input string.\n        print(\"{0} ({1})\".format(i, reverse_string))\n    else:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string:\n        if group is a sequence:\n           return group\n        if group[-1] in (',', ')':\n           return group[-2]\n    return []\n\nNested parentheses are hard to parse.\nFor example:\n(((x = 1)))\n\nI had to pause and think about that one for a bit.\n\n(x = 1)\n\nI think it's interesting that the author went to the trouble of using Python instead of writing a parser in a lower-level language.\n\nAnd you know, python is quite handy for quick-and-dirty one-offs like this.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    try:\n         while paren_string.find('()')!= -1:\n              deepest_level = -1\n\n                for group in paren_string.split(' '):\n                      deepest_level = parse_nested_parens(group)\n\n                    if group == '()':\n                             deepest_level = 0\n\n                      return deepest_level\n\n    except Exception as e:\n           raise e\n\n    return List(deepest_level)\n\nGreat. But this is a terrible example, since (()()) doesn't have any nested parens", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [0] * len(paren_string)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    def is_parseable(s):\n         return '('.join(str.split(s.index(' '))) == s\n         return False\n\n    def top_level(s):\n         if is_parseable(s):\n            return s\n\n    if is_parseable(s):\n             return s.split(' ')\n        else:\n            return is_parseable(s.split(' ')))\n    return top_level\n\n    def recurse(s: str):\n         top_level(s.split(' ')) == s\n         return s", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    let highest_level = 0\n\n    return [highest_level, parse_nested_parens(paren_string + 1)]\n\nThat's a fun little exercise.\nBut I'd be wary of putting a function like this in my real code. I'd make it a bit more robust.\ne.g. Make it return a list of string indices, so you could get the level at the end of the string:\nparse_nested_parens('(()()()) ((())) () ((())()())')\n\nTrue, but he did say he was doing this for the fun of it. He wasn't advocating this as a real implementation.\n\nI'm not sure I like the idea of a string containing nested parentheses in the first place. I always put parentheses around a function call; I don't care if it's nested in a string.\n\n_\"It's a comment\"_ is a good excuse though\n\nI don't know what you mean by that, but I think you're missing the point. In Python, you put parentheses around a function call. If the parentheses are inside a string, then you've messed up. That's not a comment.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string.split(\"\\n\")[::-1]:\n        if group.lower() == \"(\" and group.lower() == \")\":\n            return group.pop()\n        else:\n            return []\n\n    return list(nesting_level for nesting_level, group for group in group)</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    while paren_string.find('(') > 0 and paren_string.find(')' > 0):\n        level = paren_string.find('(').find(')')\n        level2 = paren_string.find(')').find(')'\n        for i in level + 1:\n           level = level + 1\n           level2 = paren_string.find('(').find(')')\n           if level > level2:\n                 return level\n    return List(1, level + 1)\n\nfrom typing import List", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if isinstance(paren_string, str) else None:\n    l = len(paren_string)\n    if len(paren_string) < 1 else None:\n       if l == 0:\n          return []\n        else:\n          return [1]\n       while l > 1:\n          if l == 0:\n             return [l]\n             l -= 1\n             if isinstance(paren_string[l], str):\n                 return [l]\n                l -= 1\n        return []\n\nI really like your parser.\n\nThanks. I put in the example as I think it was missing from the OP.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 1:\n        return []\n    else:\n        return [len(paren_string)-1] + List(parse_nested_parens(paren_string[-1])).append(0)\n\nSlightly better (in my opinion) version:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    input_list = List()\n    for paren in paren_string:\n       input_list.append(paren)\n    return input_list\n\nI wonder why they didn't just use the string module?\n\nI'd guess they want to support more than two levels of nesting.\n\nThe string module (in Python 2) supports arbitrarily deep nesting, and supports nested lists, tuples, and dictionaries, too.\n\nThis is in the Python 2.7 docstring.\nI don't think the parser supports nested lists, tuples or dictionaries though. It might be something you have to implement yourself.\n\nIt looks like the parser can be adapted to support nested lists, tuples, and dictionaries, but the documentation doesn't mention it.\n\nIs this useful? I always found that you can read this stuff easier with indentation (it's \"pretty print\" anyway).\n\nYou can't always indent it, and even if you could, that doesn't help you see what it looks like to a parser.\n\nI'll give you the indentation part, but I don't really understand the second. What do", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 1:\n        return []\n    else:\n        return parse_nested_parens(paren_string[1])\n\nAm I missing something obvious or is the title of this submission completely wrong?\n\nI think the submission is just wrong. There is no way to \"parse\" nested parentheses into lists.\nThis is a case of \"Hacker News's most famous algorithm.\"\n\nDoesn't this assume that the nesting is always one level?\n\nThat's not what I got from the description, but it's not clear how it handles nested parentheses that are not of the same depth.\n\nIt should handle nested parentheses of different depths by returning an array of arrays where the first array is a list of the parents of a group, and each element in the second array is a list of the children of that group.\n\nIt does not handle parentheses of different depths. You'll get an incorrect result if you have a non-trivial expression.\n\nAha. I figured it was a case of \"programmer tries to be clever and fails\".\n\nWow...I can", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    nlevels = 0\n    while paren_string!= '\n         for x in paren_string:\n              nlevels += 1\n          if nlevels > 1:\n              return [int(x)] + [int(x + 1)]\n          else:\n              return [int(x)]\n    return [int(nlevels)]\n\nI'm sorry, I just don't get it. The comments don't explain anything. What does the above code do, in English?\n\nInstead of doing:\nwhile (x) {... }\nYou do:\nwhile (x == '\\n') {... }\n\nThe code seems to be saying that it takes a string and tries to match newlines in the string against a newline character.\nIf it finds one, it adds one to a counter, and if the counter ever equals '\\n' it returns the accumulated", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for c in paren_string:\n        for g in paren_string[c]:\n           if g == '()' or g == ')' or g == ')':\n               break\n               if g in paren_string[c]:\n                     print g\n                   else:\n                       print g\n    return List()</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find('(') > 0:\n         return [0]\n    return [1]\n\nThat is so, so nice.\n\nThat's so bad, so bad.\n\nWhy? The number of parenthesized operators should be at most 2, so you can always just ignore the leading (0).\n\nI've never worked on a system that would only allow the leading (0) in a list. I've worked on many systems where a leading (0) is a legal operator.\n\nYeah, but that's not the point. If you're writing code that assumes parens, and you're getting this, you are almost certainly doing something wrong. And if you're not, it's a pretty trivial fix to handle it.\nI don't understand why people think this is so \"horrible\". There's all sorts of things that can go wrong with code, so why obsess over one particular corner case when there are so many other things that can go wrong?\n\nMostly because it breaks the abstraction that a list is a list.\n\nIf you consider the \"inner\" parentheses to be a string, it", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) > 1:\n        parse_parens(paren_string)\n    else:\n        return []\n\nWhy not use the standard library?\n\nBecause the standard library is not a very good module.\n\nSee, the standard library does not do what this module does. It does do some similar things, but not exactly what this does.\n\nHow does this compare to\n\nI've been using pydoc.py for parsing paren-heavy blocks and strings for a while, but it is not that well documented and I was looking for something simpler and more portable. I may well switch to this.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string)!= 3:\n        return []\n\n        if paren_string.find('('):\n            return [p for p in paren_string.split(' ')]\n        elif paren_string.find(')':\n            return [p for p in paren_string.split(' ')]\n    else:\n            return [p for p in paren_string]\n\nNice one. In the same vein, but without the Python import:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n\n    parser = dict()\n\n    for i in range(0, len(paren_string)):\n        parser[i] = 0\n\n    for k, g in enumerate(paren_string.split(' ')):\n        parser[i] += parse_nested_parens(g)\n\n    return parser.items()\n\nOh, the nested parentheses horror...</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    input = paren_string\n    if input[len(input)-1] == '(':\n       output = []\n    elif input[len(input)-1] == ')':\n       output.append(1)\n    elif input[len(input)-1] == ')' :\n       output.append(2)\n    else :\n       print \"Invalid input\"\n    return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [i for i in paren_string if i not in paren_string[-1]]</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [str.split(' ') for str in paren_string.split(' ')]\n\nNote that the lambda function:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    try:\n        for pair in paren_string.split():\n            if not pair:\n                 break\n        if pair == ')' or not pair == '}':\n                  return None\n                     else:\n                        for sub in paren_string.split(1):\n                                         if sub.isalpha():", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    n = len(paren_string)\n\n    return {\n         result: List(n),\n         max_nesting: len(paren_string) - n,\n         max_level: 0,\n          nested_value: 0\n    }", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for parent in list(paren_string):\n       for group in parent:\n          if group[1] in parent:\n             output_level = 1\n         else:\n              output_level = 0\n    return List(output_level)\n\nIt's not (as) bad as it looks. A lot of the syntactic sugar is just list comprehensions.\n\nI've always been a big fan of writing parsers and lexers. It's a great way to really understand language and how things work.\n\nIt also really helps to understand how parsers and lexers work, if you're building one.\n\nAnd when you're building one, you start to get this feeling, when you're writing your recursive descent parser, that this is the way the human brain works.\n\nI have a very similar feeling with writing compilers.\n\nI agree that compilers and parsers are very similar to the human brain. In fact, I think that in the future", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 0:\n        return List()\n    if len(paren_string) == 1:\n        return List(1)\n    if len(paren_string) < 2:\n        return List(0)\n    else:\n        return parse_nested_parens(paren_string.split())\n\nI think this could be better expressed as a recursive function with a local variable to track the depth of nesting and a maximum nesting level to output. The nesting level variable could be a tuple or list of tuples to track the nesting level of the individual groups.\n\nI thought it would be easy enough to be read easily by someone who isn't a programmer, so I didn't write a recursive function. Also I don't know the language.\n\nI like the idea, but it seems a little _too_ simple. (I'm thinking about the days of writing Pascal on the BBC Micro - where you had to literally worry about bytes and characters in the memory! On one level, it was nice to have a", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for subgroup in paren_string.find(r'(', ')') +\n    paren_string.find(r'(', ')', ')' +\n    paren_string.find(r'(', ')', ')' +\n    paren_string.find(r'(', ')', '))\n       subgroup.pop()\n    if subgroup is None:\n       subgroup = []\n    return subgroup\n\nI would probably use `parsetext` from the standard library:\n>>> parse_nested_parens = parse_text(r'(())())\n[2, 2, 3, 3]\n>>>\n>>> parse_nested_parens = parse_text(r'(())() ())\n[2, 3]\n>>>\n>>> parse_nested_parens = parse_text(r'(())() (())())\n[3, 3]</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    try:\n        p = int(paren_string.strip())\n        while len(paren_string):\n            if len(paren_string) < 3:\n                return [0]\n                p = parse_nested_parens(paren_string)\n                return [1, p]\n    except:\n        return [0]\n\nLooks nice, but it's not clear to me if you're using it as a programming-style tool or something that actually adds to the functionality of the program.\n\nNested parens are a real pain to read.\nI have used a similar one before, but it also allowed for escaping the nesting. e.g. (()()()) would be written as (()()).\n\nI don't think nested parens are a real pain to read, but in any case this", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) == 1:\n        return []\n    elif len(paren_string) == 2:\n        return [1]\n    else:\n        return [0]\n\nThe author of this library is not really a python expert - he's more of a machine learning expert (from his bio on the site).\nThis is an example of why there is a need for better/more documentation for python. It is not enough to just have the code - you also need to understand what you are reading and how it works.\nThis module also suffers from'magic numbers' which are never good for a general purpose library.\n\nI'm curious about your use of \"magic numbers\" here. Could you expand a bit?\n\nI think it means a variable that is never explained. Here, len(paren_string) is used, but what does that mean? len(...)? len(..., encoding='utf-8')? len(..., encoding='utf-16')? And what does it do?\n\nPython's \"magic numbers\" are often very", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    nested_parens = []\n\n    for group in paren_string.split(' '):\n\n        # Take the sub-string representing the group.\n        p = group.rstrip(' ').lower()\n        if p in nested_parens:\n           nested_parens.append(p)\n\n        else:\n           nested_parens.append(Group(p))\n\n    return nested_parens\n\nfrom typing import List, tuple, with\n\n    def parse_nested_list(list_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested list separated by spaces.\n    For each of the group, output the deepest level of nesting of list.\n    E.g. [(())) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_list('((())) [(()))", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return List(paren_level for paren_string in paren_string.split())\n\nI can't believe you just did that!\n\nIf I'm not mistaken, this is also a prime candidate for memoization (as long as the cost of the function is dependent on the number of parenthesis, and not their nesting level).\n\nHeh, I think you're right. I was originally going to mention that, but I wasn't sure if the average user of Python would know what memoization is.\n\nI'm not even sure the average Python programmer knows what memoization is. I've only been working on Python for a little over a year and it was a pretty big lightbulb moment for me.\n\nDoes this work with Ruby?\n\nTheoretically, you could adapt it to work with Ruby (and I guess with other languages). I'm not familiar with Ruby, though, so I'm not sure how you'd define \"paren_string\" in Ruby.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    n = len(paren_string)\n    for i in range(1, n - 1, 0):\n        n = n - 1\n        while paren_string[i]!= '()':\n            p = paren_string[i - 1]\n            if p:\n                 if p not in ['(']:\n                      p = paren_string[i]\n                       else:\n                         p = parse_nested_parens(paren_string[i - 1])\n                             n = n -", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    while not x:\n          p = parse_paren_group(paren_string)\n          x = p.find(',')\n          y = p.find('(')\n           max = 0\n          if (x!= y) or (x.find(',')!= y.find(',')):\n              max = max + 1\n             p.append(max)\n    return p", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    def nested_parens(left: str, right: str):\n        if not (left.find(',').isdigit()):\n           return List(0)\n        if not (right.find(',').isdigit()):\n           return List(1)\n        if (left.find('(').isdigit()):\n           left = left.substring(0,1)\n          return nested_parens(left, right)\n    return nested_parens()\n\nThis is what I was looking for, thank you.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string == '()' or paren_string == '()' or paren_string == '()' or paren_string == '()':\n        return []\n    return [] + [] + [] + [] + []\n\nWhat is the point of doing this? A variable like \"nesting\" would be more useful, and faster.\n\nThis is Python code, not C, so it doesn't need to be faster.\nThe point is that it's a nice, readable way to write a function which can take a complex string that might be nested arbitrarily deeply. And it's a small example of how Python can be a good choice for writing simple utility code.\n\nIt does need to be faster, as long as python is used as a scripting language.\n\nWhy? Python is only rarely used in a \"scripting\" context these days; even then, if it's executing a bit slowly, who cares? The script will still finish before the user has finished inputting the data it's parsing.\n\nYes, but that is what this post is about.\nThe point is to show that Python has some nice tricks to make some", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n\n    start = 0\n\n    if paren_string == \"[\":\n       start = 0\n\n    if paren_string == \"(\":\n       start += 1\n\n    if paren_string in [\":\", \"]\":\n       start = 0\n\n    while start < len(paren_string):\n        while paren_string not in [\":\", \"] and paren_string not in paren_string:\n           start = 0\n\n        if paren_string in [\":\", \"] and paren_string not in paren_string:\n            start = 0\n\n        else:\n            start += 1\n\n    return parens = [start]\n\nThis is the kind of stuff I would've loved to see in my first programming class. It's so simple, yet it gives you such an insight into the way the language", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    # no-op - no parentheses in the string\n    return []\n    # loop through the string\n    for char in paren_string:\n        if char == '(':\n           depth = 0\n         else:\n            depth += 1\n         # if first group is not empty, keep its value\n        if depth == 1:\n            max_depth = int(char)\n            return max_depth\n    # if group has depth > 0, add its nested groups\n    if depth > 0:\n         for group in group_string:\n              group_string = '(' + group + ') '\n              group_string += group_string", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [ (paren_string[0] - '()'), (paren_string[1] - '()) ],\n    (paren_string[2] - ')' ]\n\nfrom typing import List\n\n      def parse_nested_parens(paren_string: str) -> List[int]:\n           \"\"\"Input to this function is a string represented multiple groups for nested parentheses separated by spaces. For each of the group, output the deepest level of nesting of parentheses.\n             E.g. (()()) has maximum two levels of nesting while ((())) has three.\n            \"\"\"\n           return [ (paren_string[0] - '()'), (paren_string[1] - '()) ],\n            (paren_string[2] - ')' ]\n\nfrom typing import List\n\n     def parse_nested_parens(paren_string: str) -> List[int]:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    try:\n       for sub_paren in paren_string:\n          level = sub_paren.find('(').next()\n           sub_level = level.find(')'\n           sub_level.append(level.find(')')\n           sub_paren = sub_level.pop(')')\n           level.append(')')\n           return level, sub_level\n    except:\n           return [], []\n\nI'm not sure I'm following this. How does it actually work?\n\nIt first splits the string into '(' and ')'. Then it makes a level 0 list with only the first level of parenthesis. It recursively calls itself on each level until it gets the ']'s. Then it makes a level 1 list with just the last level of parenthesis.\n\nThe only problem is that it requires the", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for item in paren_string:\n        if item == '()' or item == ')' or item in (''):\n           return []\n    else:\n            if item == '(':\n                output = []\n                recursion = 0\n                 if recursion == 0:\n                    output.append(1)\n                  recursion = recursion + 1\n                  if recursion == len(item):\n                    output.append(')')", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    try:\n         return []\n    except IndexError:\n         return List(1)\n\nIs this a joke?\n\nThe way I read it, the author is trying to demonstrate that you can't use raw string parsing to do arbitrary string processing.\n\nHe didn't need to demonstrate that with a contrived example.\n\nThis is one of those cases where the language isn't really the problem.\nAny language which is relatively strict on its syntax will have a hard time with this. But the real problem is that parsing is hard.\nYou can't really do any reasonable parsing without a parser generator.\n\nYou can do reasonable parsing without a parser generator.\n\nNo you can't. You need to be able to handle and skip bad tokens, and there are many ways to do this. You can't do this with a regex. You can't do this with a string. You can't do this with a language that has few and simple grammar rules.\nThe only thing that can do this is a parser generator.\n\nThat is a semantic issue, not a parsing issue.\nFor example, in python, if", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find(\"(\") == 0:\n        return []\n    if paren_string.find(\")\") == 1:\n        return []\n    if paren_string.find(\")\")!= 2:\n        return [1]\n    if paren_string.find(\")\")!= 1:\n        return [0]\n    if paren_string.find(\")\")!= 0:\n        return [3]\n    if paren_string.find(\")\")!= 1:\n        return [0]\n    return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    count = 0\n    for char in paren_string:\n         count = count + 1\n         if count == len(paren_string):\n             break\n            if char == '(':\n                 count += 1\n               if count == 3:\n                   break\n                 if char == ')':\n                    count += 1\n                  if count == 3:\n                     break\n    return count\n\nThis has some issues. I can't think of a way to solve", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [len(paren_string) for p in paren_string.split(',')]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for g in paren_string:\n        max_level = None\n        for sub_list in g:\n           if sub_list.startswith('('):\n                max_level = sub_list.startswith(')')\n               if sub_list.startswith(')':\n                 max_level = sub_list.endswith(')'\n                 if sub_list.endswith(')' and max_level < 3:\n                    max_level = sub_list.endswith(')'\n                   return max_level\n\nI wonder if this could be sped up if the function could assume that the starting", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    def outer():\n         return 0\n    for p in paren_string:\n         p = p.rstrip(' ')\n         if p[1:]!= \"\":\n            outer = outer + 1\n    return outer\n\nInteresting, but not particularly useful.\n\nIt seems to work in practice though.\n\nAn interesting approach, but the solution is still brittle. What happens when the nesting gets really deep?\n\nIt looks like it falls apart. I would guess that it doesn't handle balanced parentheses very well either.\n\nInteresting idea, but too brittle to be of much use.\n\nInteresting, but brittle.\n\nThe approach is very nice, but it's brittle.\n\nFrom a mathematical point of view, that's a fun hack. From a practical point of view, if you have to write code to handle an \"unusual\" syntax like that, you probably should be using an editor that will tell you about it and provide you with an easy way to refactor it.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    try:\n        parse_nested_parens = lambda str: []\n    except ValueError as err:\n        try:\n           parse_nested_parens = lambda str: [str]\n        except ValueError:\n           print 'Unable to parse nested parentheses.'+ str\n    return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    nested_count = 0\n    nested_level = 0\n    group_count = 0\n    parent_count = 0\n    start_len = len(paren_string) - 2\n    while len(paren_string) > 0 and not (len(paren_string) == start_len):\n        group = list(paren_string)\n        group_count += 1\n        for _ in group:\n            nested_level += 1\n             parent_count += 1\n             nested_count = (nested_level + 1) * (parent_count + 1)\n             if nested_count == (len(paren_string) - 1):\n                 return nested_count\n    else:\n        nested_count =", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    def get_level_of_parentheses(group: str) -> int:\n    \"\"\" Get the level of nesting of a group of parentheses.\n    If group is a single group, return 1.\n    If group has only one element, return that element.\n    If group has only one opening parenthesis, and no nested groups, return 0.\n    If group has only one closing parenthesis, and no nested groups, return 0.\n    If group has only one opening parenthesis, and one nested group, return 1.\n    If group has only one opening parenthesis, one nested group, and one closing parenthesis, return 2.\n    \"\"\"\n    if group[0] == '(':\n       return 0\n    if group[0]!= '(':\n       return 1\n    if group[1] == ')':\n       return 0\n    if group[1]!= ')' or group[1] == '{' or group[1] == '}':", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    counter = 0\n    for i in range(len(paren_string)):\n       counter += 1\n    if not paren_string[i] in '(' or ')' or i == len(paren_string):\n       return []\n    if paren_string[i] in paren_string[i + 1]:\n       return [counter]\n    counter = counter + 1", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [int(c.index('(')) + 1)]\n\nIf you want to be able to handle other types of brackets, e.g., square brackets, you can add an extra line:\nfrom typing import List, Char\n\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [int(c.index('(')) + 1)] or Char(c.index('[')) + 1]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    l, h, j, l_n, h_n, j_n = paren_string.split(' ')\n\n    if j == 0:\n        j_n = 0\n    else:\n        j_n = parse_nested_parens(h[j:]) + 1\n\n    if j_n == 0:\n        return list(l)\n\n    if h_n == 0:\n        return l_n\n    else:\n        return l + l_n + h_n</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    # Extract the list of groups.\n    groups = []\n    # Build the list of nested parentheses.\n    current_level = 0\n    for group in paren_string.split(' '):\n        group = group.split(' ')\n        if group == '(':\n           # Start a new group.\n           if '(' in group:\n                # Parenthesis.\n                # If there is a matching ')' in the current group, make it the", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find('('):\n        return paren_string[1:]\n    else:\n        return paren_string\n\nWhat's the point? Is this a joke?\n\nNope.\n(()()) has two levels of nesting.\n((())) has three levels of nesting.\n\nBut how does this help me as a Python programmer?\n\nFrom the documentation:\n\n\"You can use this function to extract the deepest level of nesting of parentheses\nfrom a string. The maximum level of nesting is 3.\"\n\nSo it's useful for parsing nested parentheses?\n\nIt's a hack, but yeah it's useful in some cases.\n\nThe find function is so much more elegant.\n\nOnly if the string you are looking for is a number.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    len_deepest = len(paren_string)\n    lst_group = []\n    while len_deepest > 1:\n         lst_group.append(len(paren_string))\n         lst_group.append(parse_nested_parens(paren_string))\n         len_deepest -= 1\n    return lst_group", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string) >= 3:\n        return [0]\n    else:\n        if paren_string[0] in ('('):\n            return [1]\n        else:\n            return [2]\n    return [3]</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    val p_level = 0\n    while paren_string.find('('):\n       p_level = int(paren_string.find(')').rstrip().decode('utf-8')\n       if p_level < 0:\n          break\n    return [int(p_level)]\n\nNice! You've got a typo in the second to last line, though:\nreturn [int(p_level)]\nShould be:\nreturn [int(p_level)]\n\nWhoops, thanks. Fixed.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for paren_char in paren_string:\n        if paren_char not in '(' or ')' or paren_char not in '{':\n           return []\n           else:\n            if paren_char in '(' or ')' or paren_char in '{':\n                  return [int(paren_char) + 1]\n              else:\n                  return []\n    return List(max_level+1)\n\nThis is cool, but I think it needs to be called listparse, because it doesn't even have a dependency on the `list` module.\n\nThanks for the suggestion. I have renamed it to listparse.\n\nIs there a way to get the order of the elements? i.e. I want to be able to do something like", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for x in range(len(paren_string)):\n         try:\n             return len(paren_string[x]) - 1\n         except:\n             return 0\n\nUncle Bob would be proud.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n\nparse_nested_parens = lambda s:\n    \"\"\" Given a string represented multiple groups for nested parentheses separated by spaces,\n    return the depth of the nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return (s.index(',') > 0) + (len(s) - len(s.split(',')[0]) + 1)</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n\n    for p in paren_string:\n         for nested in p:\n             if nested:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if '(' in paren_string:\n       return []\n    nested = []\n    for i in range(len(paren_string)-1, paren_string[i]+1):\n       if '(' in paren_string[i+1]:\n          nested.append(i+1)\n       else:\n          nested.append(paren_string[i] +'' + paren_string[i+1])\n    return nested</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    k = 0\n    for i in range(len(paren_string)):\n       if paren_string[i] in paren_string[k]:\n          p = paren_string[k+1:]\n           if paren_string[k+1] in paren_string[k]:\n                    p = paren_string[k]\n                    if paren_string[k] not in paren_string[i]:\n                           k = k + 1\n                       p = paren_string[i]\n                    if p in k:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    int_group = 0\n    for character in paren_string:\n        for space in '(' * space + ')':\n            if space not in '(' * space + ')':\n               break\n                if space not in ')' * space + '):\n                     break\n                    if character == ')' and int_group < 3:\n                         break\n                       if int_group >= 0:\n                             int_group = int_group + 1", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for m in paren_string.split(''):\n       if m not in [()()]:\n           return []\n       if m == []:\n           return []\n       if len(parens, m) == 0:\n           return []\n       if m[0] == ')':\n           return [0]\n       for i in range(len(parens)-1):\n            m[i] = i + 1\n    return m\n\nthe code is posted here:\n\nThat's nice, but how is it useful? I guess there could be a use case in parsing parenthesis-heavy code.\n\nIt's useful for writing code that parses parenthesis-heavy code. ;)\n\nOh, of course.\n\nThe translation is one-to-one; no need to parse and then translate.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string[1] == \"(\" or paren_string[1] == \")\" or paren_string[2] == \")\" or\n     paren_string[2] == \")\" or paren_string[2] == \")\":\n       return []\n    # We are at the outermost level of the brackets.\n    return []\n    # Level 1\n    for i in range(len(paren_string)-1):\n       if i == 0:\n           return []\n       else:\n            return parse_nested_parens(paren_string[i+1])\n    # Level 2\n    return []\n\nSee also:\nfrom typing import List", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    parser = parse(paren_string)\n    while parser:\n        group_string = parser.group()\n        if group_string in '()' or group_string in '(':\n             parse_nested_parens(group_string)\n         else:\n             parse_nested_parens(group_string)\n\nI think it'd be better as:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for paren in paren_string.split():\n        if not paren:\n           return []\n           if paren.startswith('('):\n                return (paren.count() - 1)\n                 else:\n                    return []\n        return (paren.count() - 1)\n\n> from typing import List\n>\n> def parse_nested_parens(paren_string: str) -> List[int]:\n>    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n>    For each of the group, output the deepest level of nesting of parentheses.\n>    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n>\n> >>> parse_nested_", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    deepest_level = None\n\n    if len(paren_string) == 0:\n        deepest_level = 0\n\n    if len(paren_string) > 1:\n        for i in range(2, len(paren_string) - 1):\n           deepest_level = parse_nested_parens(paren_string[i], 1)\n           deepest_level\n           break\n\nreturn deepest_level", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for p in paren_string:\n       if p not in List:\n          raise SyntaxError('Parentheses must be nested')\n          return [p]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string == '(' or ')':\n        return []\n    return [len(paren_string[0:len(paren_string)-2]) + 1 for paren_string in paren_string]</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [nested_parens(paren_string) for p in parens]\n\nThis is a pretty good solution.\n\nYeah, I was kind of surprised no one had said this yet.\n\nYeah, I was surprised too. This is a very obvious way to solve this problem.\n\nLooks like the problem is solved.\n\nI am reminded of the Python module 'itertools' with the 'groupby' function.\n\nI was reminded of this: \n\nAnother solution:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n\n    result = []\n\n    for i in paren_string:\n         if parens[i-1].startswith('('):\n             result.append(i)\n\n          result.append(0)\n\n    return result</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n\n    def child_group(group: List[int]) -> int:\n    \"\"\" Finds the deepest level of nesting of parens in the group\n    The idea is to use recursion to iterate over the group while we\n    keep track of the deepest level of nesting.\n    Since this will be a tail recursive function, we need to manually\n    unwind the stack. Also, we need to keep track of how many levels we\n    have gone down. We'll return the number of levels of nesting we find.\n    If we cannot find any nesting, we'll return -1.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, -1]\n    \"\"\"\n\n    deepest_level = 0\n\n    if group == List[None] or group == List[(None, None)] or group == List[(None, None, None)] or group == List", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    l = []\n    for c in paren_string:\n       if c == '(':\n         if c == ')':\n             l.append(0)\n         else:\n             l.append(c)\n    return l\n\nThat's pretty cool. Does it handle arbitrary nesting, or is it just limited to certain delimiters?\n\nIt handles arbitrary nesting.\nThe trick is to maintain a stack of the current level of nesting. When a paren is encountered, the current level is set to 0 and the level of the paren encountered is added to the stack.\nE.g.\n(()()()())()()\n(())()\n()()\n(())()\n()\n\nI'm writing some code in python to do a little parsing of some data files. I have to deal with nested comments and strings, and since I've never done any parsing in python before, I decided to try this out. It's working great so far", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for _ in range(len(paren_string)):\n         if paren_string.find(',').count() > 0:\n             return paren_string.find(',').slice(0, len(paren_string) - 1)\n    return []\n\nIt's also possible to avoid the temporary variable and nested for loop by using Python's apply() function:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find('(') == 0:\n        return []\n    paren_string.rstrip(' ')\n    return [p for p in paren_string if not p.find('(') and not p.find(')')]</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    val list_of_groups = []\n    while paren_string:\n        val group = paren_string.group(1)\n        val parent = paren_string.parent(group)\n        if parent is None:\n              list_of_groups.append(parent.group(2))\n         else:\n               parent.parent(parent.group(3))\n    return list_of_groups\n\nThis is a great example of why typing is often an unnecessary burden.\n\nI didn't think it was too bad, I expected something like:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for indx, group in enumerate(paren_string):\n        if group.startswith('('):\n           # the group starts with a single group of parentheses\n             # start counting the nesting of the group\n             # loop until we reach the end of the group\n             # then output the count\n             if group.endswith(')':\n                # the group is complete\n                # output the count\n           else:\n                # the group is not complete\n                # output the count", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    parens = []\n    while paren_string:\n       if paren_string.find('('):\n           parens.append(0)\n       else:\n           raise StopIteration\n        else:\n           raise StopIteration\n    return parens</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    inner = []\n    for s in paren_string:\n       if s!= '':\n          inner.append(s)\n          if inner.count() > 1:\n              inner.reverse()\n    return inner", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for subseq in paren_string:\n        if paren_string[subseq] == '(':\n               return (None, None)\n        else:\n               return (None, subseq)", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    number_of_levels = len(paren_string) - len(paren_string[0])\n    for i in range(0, number_of_levels):\n       for g in paren_string[i]:\n          if len(g)!= 0:\n              if g.index(0)!= 1:\n                   break\n                 else:\n                     i = i + 1\n                     g = g[i:]\n                    if g.index(0)!= 0:\n                         break", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return (nested_nesting_level, parens)\n\nWhat's a \"list\" in this context?</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    # at the top level, the strings are empty\n    if paren_string.startswith('('):\n         return []\n    # initializing the parens\n    for n, c in enumerate(paren_string):\n         if c == '':\n             break\n           parens.append(n)\n          # now we have the top level parens\n    return parens\n\nThis isn't a particularly useful example, but it's a simple way to illustrate this technique, which is often used to implement the _parse_* functions in standard library modules.\n\nThis is absolutely fantastic. I had never seen this sort of nested recursion before and am really looking forward to reading the whole thing.\n\nIt is one of the standard libraries of Python.\n\nI find this fascinating. It is easy enough to understand, but the language is so expressive that it is possible to express a lot in a single statement. This", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for symbol in parens:\n        if isinstance(symbol, str):\n           return parse_nested_parens(symbol)\n        return []\n\nThat's a pretty cool example of recursive Python.\nI've found that the most readable way to write recursive code is to use a function with a default argument, and a list comprehension.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    nested_paren_levels = 0\n    for _, group in enumerate(paren_string):\n        if isinstance(group, list):\n           nested_paren_levels = nested_paren_levels + 1\n    return List(nested_paren_levels)</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for paren_level in range(1, len(paren_string) - 1):\n        return List(0, 0) if paren_level < 0 else paren_level - 1\n\nGuess what this does.\n\nYou're right! It's the Python equivalent of the C++ standard library function:\nstd::getline(std::cin, std::endl, \"abc\\ndef\\nghi\", std::npos, std::size_t);\n\nI don't see why this is a new language feature. I'm a newcomer to Python, so correct me if I'm wrong, but couldn't you just use this?", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return list(map(int, int.parseInt(paren_string, 10)))\n\ntry:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for g in paren_string:\n        if g.startswith('('):\n             return g\n         elif g.startswith('(':\n               return List(1)\n         else:\n              return g\n\nSo the nested parentheses are optional and might be empty, but if there are any, they have to be balanced.\n\nCan someone explain why the author didn't just use an existing library like Numba for this?\n\nNumba is for Python code.\n\nYes, but it is specifically designed for optimization of numerical code.\n\nThere are other cases where you want to parse some other kind of string and optimize it, for example a parser for a configuration file, etc.\n\nYeah, I don't have a good reason. I guess I just wanted to do it myself.\n\nGood job, it's fun to do it yourself :)\n\nDoing it yourself is always", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    # Accept only valid strings\n    if re.match('([|]{})' in paren_string):\n        raise ValueError(\"Invalid input\")\n    # Grab group with maximal nesting level\n    for nesting in re.finditer(paren_string, lambda group: group[1]):\n        output = [int(group[1])]\n    # Number of nested parentheses\n    # Return nested level of first group\n    return max(output)\n\nIt would be interesting to see a comparison to clojure.core/parse-nested-form\n\nDo you have any idea how many cycles this would run in python? (I know Python isn't know for its speed)\n\nI haven't run it, but I'd expect it to be slow. A quick and dirty\nparser written in python looks like it would be around 10x slower\nthan Clojure's built-in form parsing (  ).\n\nInterestingly, it's about the same speed as Python's built-in format, and much faster than the built-in parse() function (which would be", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    paren_string = par_string.rstrip(' ').split('( ')\n    # to strip all non-space characters\n    nested_string = paren_string[0:1] + '(' + paren_string[1:1] + ')'\n    # split into a list of lists\n    for i, n in enumerate(nested_string.split(')').items():\n          if n[1]!= ')':\n              break\n               # when parentheses are not nested (i.e. when n[1] == ')')\n               # output the first level of nesting (nested_string[0])\n               # and stop\n               nested_string[0] = int(n[1])\n    return nested_string", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    input = input.strip()\n    for group in paren_string.split(' '):\n       if group == '':\n          return []\n       nested_levels = 0\n\n    if group in input:\n          nested_levels += 1\n       else:\n          return []\n    output = []\n    for group in group_level_parse(input):\n       output.append(group)\n\n    return [len(output),]\n\nThis function is a good example of something that should be done in the parse function but is moved out to its own function in the style of the current answer. I don't think the style in the current answer is ideal, so I'll do this differently.\nThe problem is this function is very likely to change (it's very common to have nested parentheses and having a function like this is not very flexible). There's no real structure or cohesion to the code. In this way, it's not", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [int(next(paren_string)) for next in paren_string.split() if paren_string in ('(', ')')]\n\nThis is very close to the function that the article suggests:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for _, (g, end_) in enumerate(paren_string):\n        if g not in paren_string:\n           break\n        else:\n           p = end_ + 1\n           g = parse_nested_parens(g)\n           if g not in paren_string:\n              break\n         else:\n              p = p + 1\n             g = parse_nested_parens(g)\n            if g not in paren_string:\n               break\n         else:\n              p = p +", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    words = []\n    for paren_string_end in paren_string.rstrip('\n\n'):\n        if paren_string_end in list(paren_string.split()):\n           words.append(len(paren_string_end))\n    words.append(int(math.floor(parse_nested_parens(paren_string_end)) / float(len(paren_string_end))))\n    return words", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    result = []\n    for group in paren_string.split(' '):\n        # If there is a single parenthesis, it is the lowest level of nesting.\n         if group == \"(\":\n            result.append(group.pop())\n           break\n         else:\n            if group == \")\"':\n              result.append(group.pop())\n            else:\n              result.append(group.pop())\n            # If the parenthesis is at the highest level of nesting.\n          if group == \"):\n             result.append(group.pop())\n    return result\n\nThis is my favorite.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    d = 0\n    for group in paren_string.groups():\n       d = (d + 1) % list(list(group))\n    return d.list()\n\nUsing a list comprehension will be more efficient:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [1 for i, l in paren_string.split(' ')]\n\n>>> parse_nested_parens(list(parse_nested_parens('(()()) ((())) () ((())()())')))\n[1, 2, 3]\n\nfrom typing import List", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    groups = []\n\n    for char in paren_string:\n       if char in (('('), ')') or char in (''):\n          groups.append(1)\n\n    return groups</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n\n    val levels = 0\n\n    while len(paren_string) > 1:\n        if paren_string.find(':')!= -1:\n\n            level = parse_nested_parens(paren_string)\n            if paren_string.find(':')!= -1:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    p = 0\n    for i in range(len(paren_string)):\n        if paren_string.find('(') > 0):\n             p += 1\n    return p\n\nimport itertools", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    text = \"\"\n\n    for j in range(1, len(paren_string)):\n\n        text += paren_string[j:j+1]\n        if j!= 0:\n            text += paren_string[j] + \"(\" + paren_string[j+1] + \")\"\n\n    return [text[0] for text in sorted(list(text), key=lambda str: str.find(\"(\"), reverse=True)])]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    level = 0\n    while len(paren_string):\n        while len(parens[level][0]):\n           if parens[level][1] == '(':\n               if level > 0:\n                    return parse_nested_parens(parens[level-1][0])\n                else:\n                     level += 1\n                    else:\n                      level = 0\n                     parens[level][1] = ')'", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    assert len(paren_string) == 2\n      for group in paren_string.split():\n         if group == '(':\n             return []\n             return group\n    return [group[0] for group in parse_nested_parens(paren_string) if group]</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i in range(0, paren_string.length):\n        if paren_string[i] == '(':\n            return List(i)\n        else:\n            return List(0)\n\n>>>\n\nThis is a good example of a function that's easy to write, but hard to read. It has too many cases and is not easy to generalize to new types of groups.\n\nThe problem can be fixed by using a discriminated union type. If we represent a group as a tuple of nested parentheses, we can write a general parser.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    first, rest = paren_string.split(' ')\n\n    output = []\n\n    for i in range(1, rest.count(1)):\n         output.append(first[i])\n\n    return output\n\nCan't beat the old string-splitting regex to get a list of nested parentheses.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if len(paren_string)!= 2:\n        raise ValueError, \"parsing nested parens with more than 2 levels\"\n    for s in paren_string:\n        for g in s:\n           if g.find('. ') == -1:\n               break\n               if g.find('(') > -1:\n                   raise NestedParens, parse_nested_parens(g)\n               else:\n                      print(g, \" \")\n   \n\nSome questions:\n\\- I'd prefer to do this with regexes. Is there a reason you went with a string -> list here?\n\\- What is the size of the input string", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [0]*len(paren_string)-1\n\nYour solution works, but it's a bit brittle.\nI like this one:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return map(lambdax: parse_nested_parens(x))\n\nDon't use the `from typing import *` idiom. It is much better to import modules explicitly, and also to avoid the `import` statement in your own module. The latter is a matter of taste, but the former is a good practice for readability.\n\nI don't understand. How is this better? Wouldn't this mean that you have to import all the modules that are used in your function into your own module?\n\nIf your code is compartmentalized in modules, you _should_ import all modules used by a function into the function.\nThe only reason to not do this is if your functions are a mess, in which case readability is probably the least of your concerns.\n\nThanks for the clarification. I've been following this practice all along, and I'm not sure what OP's problem is.\n\nI'm not sure what the OP's problem is either, but you _shouldn't_ import all modules used in a function. If you have a function that only uses a single module, and you import that module, you are effectively importing the entire stdlib.\n\nThat's", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n\nfor nesting_level in range(1, max(depth, nesting_level):\n    # max() returns max value in range\n    if (parenthesis_string.find('(') == 0) or (paren_string.find(')') == 0):\n       # output the group\n       parenthesis_string = parenthesis_string.replace('(','(').replace(')',')')\n       nesting_level = max(depth, nesting_level) + 1\n    else:\n       # output nothing\n       parenthesis_string = parenthesis_string.replace('(','(').replace(')',')')\n\nreturn nesting_level, parenthesis_string</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [str(len(paren_string)) for p in paren_string if p.startswith('(') and p.endswith(')' and len(paren_string) > 0]", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    p = \"\"\n\n    for group in paren_string:\n       p += '('\n\n    return [len(p) for p in parse_nested_parens(p)]</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string:\n       if group in paren_string:\n          return []\n    return group.pop(1)\n\nWhy is this interesting?\n\nThe pattern matching is quite elegant.</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string.split():\n        if group.startswith('('):\n           return List()\n        else:\n           return paren_string.get(group, 1)\n    return List(group)\n\nI think this is actually a pretty good illustration of why this is a bad idea. Using list comprehension this way is more complicated than writing a function from scratch. If it's for a homework assignment, I can't see why you shouldn't just do it the way the professor asks.\n\nSo, after reading the OP's post, I thought that I could do it with list comprehensions, and I was able to.\nI then realized that the answer was obvious, because the OP didn't give the whole answer.\nThe OP said:\n>>> paren_string = '((())) ((())()) (())'\nThis doesn't have the expected result. What about\n>>> paren_string = '((())) ((())()) (())'\nWhat about\n>>> paren_string = '", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    let depth = 0\n    while len(paren_string):\n        if paren_string.find(' ') == 0:\n            depth += 1\n    else:\n             depth -= 1\n    if len(paren_string) == 0:\n        depth = 0\n    else:\n        depth += 1\n    return List(depth)\n\nYour code (and the OP's) are broken. You are missing the parenthesis in your recursive call, so it will never return.\n\nI was missing the parenthesis as well but it was simply a missing space.\n\nMaybe you should run the code before you post it.\n\nSorry, I meant the parenthesis in the function itself.\n\nI love how people are having to download a python package to do this:\nimport pprint; pprint.pprintln(\"(()))\"\n\nI love how this simple little thing is making some people very angry.\n\nNo.", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find('(')!= -1:\n        return parens.pop(0) + 1\n    elif paren_string.find(')')!= -1:\n        return parens.pop(1) + 1\n    elif paren_string.find('()'):\n        return parens.pop(2) + 1\n    else:\n        raise ValueError(\"Unknown level of nesting: {}\"", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string.find('(').length > 0):\n        # The group contains at least one nested parentheses.\n        # Output the nested parentheses.\n        for i in paren_string.split('('):\n            output = parse_nested_parens(i)\n    return output\n\nfrom typing import List", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for p in paren_string:\n         if isinstance(p, (list, tuple)):\n             if isinstance(p, str) and isinstance(p[1], str):\n                 return p[1].pop(0)\n    else:\n               return []", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for paren_group in paren_string:\n        if paren_group == '()':\n             nested = parse_nested_parens(paren_group)\n        else:\n              nested = parse_nested_parens(paren_group)\n        if nested:\n              return nested\n    return []</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    lines = []\n    for group in paren_string:\n       line = []\n       while group!= '(' and group!= ')':\n          line.append(0)\n          if parens[group][0] is None:\n             break\n           if parens[group][1] is None:\n              break\n            if parens[group][0] is '(':\n               lines.append(0)\n             if parens[group][1] is ')':\n                lines.append(1)\n              if parens[group][0] is '", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    nested = 0\n    for char in paren_string:\n        if char == '(':\n           nested = nested + 1\n           # remove empty levels\n           for j in range(3):\n              if nested == 0:\n                   break\n                   if j % 2 == 0:\n                       break\n                      if paren_string[j] == ')':\n                      nested = nested + 1\n                     # remove empty", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    try:\n       input = input_string(paren_string)\n       return parse(input, token_list=list(\n           \" ( ) \"\n           \" () \"\n          \" (( ) \"\n          \" () \"\n          \" ((())) \"\n          \" () \"\n          \" (()) \"\n          \" (()) \"\n          \" () \"\n          \" (()) \"\n          \" () \"\n          \" (()) \"\n          \" () \"\n          \" () \"\n          \" () \"", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for group in paren_string.split(':'):\n         if group[0] == '(':\n             return group[1]\n    else:\n             return list(group.split(' '))\n    return list(parse_nested_parens(paren_string))</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for i, p in enumerate(paren_string):\n       if i == 0:\n          return []\n       else:\n          return [parse_nested_parens(p) for p in p]\n\nNice, but there's no reason to parse nested parentheses by hand. Just use the Python parser:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    levels = {}\n    for i in range(1, len(paren_string)):\n       if paren_string[i] == '(':\n          if paren_string[i+1] == ')' and i + 1 >= len(paren_string):\n               if len(paren_string) == 0:\n                   return []\n             else:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    level_nesting = 0\n    current_level = 0\n    while paren_string:\n        current_level = parse_nested_parens(paren_string)\n        if current_level == 0:\n              return []\n              else:\n                 current_level = parse_nested_parens(paren_string)\n                 if current_level >= level_nesting:\n                                  return []\n                     else:\n                                    current", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    p = parse_nested_parens_helper(paren_string)\n    return p\n\nfrom typing import Object", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    l1 = 0\n    l2 = 0\n    l3 = 0\n    for n in range(len(paren_string)):\n        if n not in l1:\n             if n not in l2:\n                 l1 = l3 = n\n                 l2 = n\n                 l3 = l1\n                 if l2 == l3:\n                    break\n                   l2 = n\n                   l1 = n\n                   l3 = l", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    # Keep a stack of nesting levels for the current group\n    stack = []\n    for char in paren_string:\n        if char is '(':\n             # Keep a counter of the nesting level of current group\n               stack.append(1)\n         # Keep a counter of the total nesting level of all groups\n              stack.append(len(paren_string))\n        # Output the current nesting level\n        if stack:\n              stack.pop()\n              return stack[0]\n    return []\n\nThis is a common idiom:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    level = 0\n\n    while paren_string:\n         level, group = parse_nested_parens(paren_string)\n\n          if level == 1:\n              group = parse_nested_parens(group.right())\n              level = level + 1\n\n    return List[int]()", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    while paren_string:\n        if paren_string[0] == '(':\n            nested = 0\n        else:\n            nested = paren_string[0]\n        else:\n             nested = paren_string[1]\n        while nested <= (nested + 1):\n             if paren_string[0] == ')' and paren_string[1] == ')' and\n                 nested > 0:\n                 nested -= 1\n               else:\n                 nested += 1\n             return nested</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return [ (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (4, 0), (4, 1), (4, 2), (4, 3), (4, 4), (5, 0), (5, 1), (5, 2), (5, 3), (5, 4), (6, 0), (6, 1), (6, 2), (6, 3), (6, 4), (7, 0), (7, 1), (7, 2), (7, 3), (7, 4), (8, 0), (8, 1), (8, 2), (8, 3), (8, 4), (9, 0), (9, 1), (9, 2), (9, 3), (9, 4), (10, 0), (10, 1), (10, 2), (10, 3), (10, 4),", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    d = 0\n\n    for level in paren_string.split():\n         if level.startswith('('):\n             if level.endswith(':'):\n                 d += 1\n                 if level.endswith(')'):\n                     d += 2\n                    else:\n                      d += 1\n\n    if d > 0:\n         return [int(d)]\n\nYou can use the comma operator to ignore the first level of nesting:\n>>> parse_nested_parens('((())) () ((())()())')\n[1, 3]\nYou can also use the triple quote operator to ignore the", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    start = len(paren_string) - 1\n\n    while start > 0:\n        next_level = 1\n\n        if start > 0:\n              if parens_in_current_level(next_level):\n                      next_level = next_level - 1\n\n                    if parens_in_current_level(next_level):\n                          next_level = next_level - 1\n\n                     else:\n                        next_level = 0\n\n            if parens_in_current_level(next_", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string in ('('):\n       return []\n    try:\n        chars = str.split(' ')\n        for c in chars:\n            if c == '(':\n                 break\n                    if '(' in chars:\n                        break\n                         paren_string = list(char)\n                         continue\n                        else:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    max_level = 0\n\n    for each_group_line in paren_string:\n        max_level = 0\n\n    for next_group in each_group_line:\n        if next_group.startswith('('):\n           max_level = next_group.count( '(' )\n\n           for next_group in next_group:\n               if next_group.startswith(')':\n                   max_level += next_group.count(')')\n\n    return max_level.values()</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    return tuple([(i,j) for i,j in paren_string.split(',') if i!= j] + []).append(parsed_parens)</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n\n    if len(paren_string) == 0:\n        return []\n\n    start = 0\n\n    for p in paren_string:\n\n        if start >= p.length:\n             break\n             start += 1\n\n          if p.startswith('('):\n               start += 1\n              if p.endswith(')':\n                start += 1\n               return []\n        else:\n               if p.startswith('('):\n                 start += 1\n                 return", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for line in paren_string:\n        if line.startswith('('):\n            # Look for the start of a group.\n            if not line.strip()[0] is None:\n                   # If it is None, there is no group.\n                         # If there is a group, go down the next level.\n                             # If there is no group, no nesting.\n                                # If the group is empty, no nesting.\n                                #", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    input = paren_string.split()\n\n    for group in input.split(' '):\n        if paren_string in group:\n             return (group[-1], group[-2])\n    else:\n             return (None, None)\n\nI would prefer something a bit more general, like this:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    for g in paren_string.split():\n       if g.find('(') == -1:\n          return []\n       if len(g) == 1:\n          return g.rstrip(' ')\n       # Get the deepest level of nesting from the group\n          if g == '(') or g == ')(':\n            return g\n    else:\n            # If the group is not a group of parentheses, return it.\n            if g.find('(') == -1:\n              return g\n            # Get the deepest level of nesting from the group\n            if g == '())':", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    l = \"\"\n\n    while len(paren_string) > 1:\n        l += (s[1] + \"\\ \" + s[0])\n\n        # `s` is the string to be parsed.\n\n        # Extract the nested parentheses from the string.\n        l = l.split(\" \")\n\n        # Remove the leading `()`.\n        if l.startswith(\"()\"):\n           # We have an empty string.\n           # Need to make sure that we don't have a string of only `()`.\n           l = \"\"\n\n        # `l` is a list with the deepest level of nesting of parentheses.\n        return l</s>", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    from itertools import islice\n    a_level = 0\n    nested_depth = 0\n    b = 1\n    while a_level <= b:\n        if (paren_string == '[(' and b == 1):\n             a_level = b\n             nested_depth = 0\n        else:\n              a_level = a_level + 1\n              nested_depth = 0\n         if a_level == b:\n               break\n        if nested_depth <= 1:\n              nested_depth = 1\n        else:\n               nested_depth = 2", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    def group_groups(a, c):\n        if isinstance(a, str):\n            return a.group(c)\n\n        return [group_groups(a, c) for c in a.group(c)]\n\n    def group_levels(a, c):\n        if isinstance(a, str):\n            return a.group(c)\n\n        return [group_levels(a, c) for c in a.group(c)]\n\n    def group_levels_of_paren(a, c):\n        if isinstance(a, str):\n            return a.group(c)\n\n        return [group_levels_of_paren(a, c) for c in a.group(c)]\n\n    def group_nested_parens(a, c):", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    if paren_string:\n         if len(paren_string) == 1:\n            return []\n         else:\n            for i, group in enumerate(paren_string):\n                if group == '()':\n                    if i in group:\n                           return group\n                        else:\n                            return 0\n    return List(0)\n\nThis is also useful for reversing nested parentheses in order to print them:", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    level_1 = 0\n\n    for group in paren_string.groups():\n        level_1 = parse_nested_parens(group)\n        if level_1 == -1:\n             break\n        else:\n              level_2 = parse_nested_parens(group + 1)\n         if level_2 == -1:\n              break\n        else:\n              level_3 = parse_nested_parens(group + 2)\n         if level_3 == -1:\n              break\n        else:\n              return level_1 + level_2 + level_3", "from typing import List\n\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\" \"\"\"\n    while not par_is_empty(paren_string):\n        if n_levels(paren_string[i]):\n            print(\"level %d\"% n_levels(paren_string[i]))\n            return []\n    return List(n_levels(paren_string))\n\nI like the fact that this is a well-known idiom to Python programmers.\n\nI don't know Python and this still seems like the most obvious way to do it. Does Python have some other, better way to parse this kind of thing?\n\nYes, it does. Python has a very robust regular expression engine (regular expressions being more powerful and versatile than the nested-parens parsing logic in the submission).\n\nNo it doesn't. Python has a _very_ limited regular expression engine (regular expressions are a PITA to use in Python, unless you like writing \"automake\" files).</s>"]]