[["def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    for i in range(num):\n        if i % 2 == 0:\n           return (i, i)\n    return (i, i)\n\nThis is a neat one. I like that it's a simple function, but it's also easy to see how it's implemented.\n\nI like this one as well:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num.count(int) for int in range(num.digits()))\nThis is a really nice way of doing it.\nI've always been a fan of the self-referential approach:       def even_odd_count(num):          return tuple(num.count(int) for int in num.digits())\nI like it, but I'm not sure I'd call it self-referential.  I mean, it's just a function that returns a function.  It's not as if it's calling itself.\nYeah, you're right.  I guess I just meant it's a function that's defining itself.  I guess that's not really self-referential either.  Maybe \"self-defining\"?\nI think it's just \"defining\".</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    \"\"\"\n    \"\"\"\n    if num % 2 == 0:\n        return tuple([int(num) for int(num) in xrange(num - 1, num + 1)] + tuple([int(num) for int(num) in xrange(num - 1, num + 2)]))\n    else:\n        return tuple([int(num) for int(num) in xrange(num - 1, num + 2)] + tuple([int(num) for int(num) in xrange(num - 1, num + 1)]))", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[0] if num[0] % 2 == 0 else num[1] for num in range(num[0], num[1])]\n\nWhat's the point of this? I don't see how this is any easier to read than the standard way of doing this:\n>>> def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num%2)\nI'm sure you were joking, but I can't resist: this is a horrible idea.\nIf you have to use a function like this, you're probably using the wrong data structure.  Just use a set or a list.\nThe set or list wouldn't be as easy to read as the tuple though.\nI disagree.  You can easily print the elements of a set or list.  You can't easily print a tuple.\nThe point is that you don't have to print it.  You can look at it and see what you want to know.  You can't do that with a set or list.\n> You can look at it and see what you want to know.  You can't do that with a set or list.\n\n You can, actually.  You can use the set/list operations to determine what you want to know.\n> You can use the set/list operations to determine what you want to know.\n\n I don't think you understand.  You can't look at a set and see how many odd and even numbers there are.  You have to do a bunch of math to figure that out.  With the tuple you can", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num.count(1) + num.count(2) + num.count(4)) / 3", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n     return [(num % 2) for num in num if num % 2]\nI don't understand the need for this.  The code could be:       def even_odd_count(num):           return [num % 2 for num in num if num % 2]\nAnd then you don't need to write the function, it's just a list comprehension.\nAh, but it's much clearer to write it as a function.\nMaybe to some people, but I think it's much clearer to write it as a list comprehension.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\nI wonder how this compares to the other approaches.\n\nI think it would be a lot more interesting if it showed the code for each approach.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) & 1\nI don't get it. How is this a solution to the problem?\nIt's a solution to the problem of \"how can I make the simplest possible function that solves the problem?\"\nI don't see how that's a problem.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    for i in range(num):\n        if i % 2 == 0:\n           return [(i, i + 1)]\n        else:\n           return [(i, i + 2)]\n    return [(0, 0), (1, 1), (2, 2)]", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    def even_odd_count_even(num):\n        return (num[0] if num[0] == 0 else num[2]) + (num[1] if num[1] == 0 else num[0])\n    def even_odd_count_odd(num):\n        return (num[0] if num[0] == 0 else num[1]) + (num[2] if num[2] == 0 else num[0])\n\nThis is not a solution to the original problem. The solution to the original problem is:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[0] for num in range(1,num.max())]\nA much simpler way to do this would be:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num.count(), num.count()/2)\nI've never heard of this. Is this a common idiom?\nI've seen it in a few places, but I think it's pretty rare.  It's useful for quickly checking if a number is even or odd, but it's not very useful otherwise.\nIt's also useful for generating random numbers, because the distribution of the digits will be even.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[0] if even_odd_count(num[0]) else num[1])\n>    return (num[0] if even_odd_count(num[0]) else num[1])  This is the correct answer.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) ** 2", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[2] for num in range(2,num+1)]", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num[1:], num[2:])", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num % 2 == 0:\n        return (num, num)\n    return (num, 1)\n\nI don't think this is a good example of a bad practice.\n\nI think it is a good example. The problem is that it's just a small piece of code that doesn't do much. It is a simple example of the problem.\nIn general, you need to consider the context in which the code is used, and then you may decide that the code is acceptable.\n\nI think that's the point. The code is fine, and the problem is not the code.\n\nI think you are missing the point.\nThe code is fine if you are looking at the code in isolation.\nThe problem is that if you look at the code in the context of the problem, you see that it doesn't do what it's supposed to do.\nSo the problem is not the code, but the code is a symptom of the problem.\n\nI think the example is a good one. It shows the problem in a small, easy to understand way.\nI think the problem is that the code is fine, but it is being used in", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) & (num % 2)\nI was expecting this to be a joke.\nI'm not sure if it's a joke or not.  I'm a bit confused as to what the OP is asking for.  A solution to a problem that is already well-known?  Or a joke?</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num.split(',')[0], num.split(',')[1])", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    \"\"\"\n    for i in range(num):\n        if i % 2 == 0:\n           return (i, 1)\n        else:\n           return (i, -1)\n    return (i, 1)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num % 2 == 0:\n        return (1, num - 1)\n    else:\n        return (num - 1, num)\n\n>>> even_odd_count(123)\n(1, 2)\n>>> even_odd_count(-12)\n(1, 1)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num%2==0:\n        return (num-1, num-1)\n    else:\n        return (num-1, num)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    for i in range(num):\n         if i % 2 == 0:\n             return (i, i+1)\n         else:\n             return (i, i+2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return (num % 2) + (num % 3)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) == 0\n    + (num % 2) == 0", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2 == 0)\n    if num == 0:\n        return (num % 2 == 0)\n    else:\n        return (num % 2!= 0)\nI think you meant:\n\n    return (num % 2 == 0)\n    if num == 0:\n        return (num % 2 == 0)\n    else:\n        return (num % 2!= 0)\n\nI think you mean:\n\n return (num % 2 == 0) if num == 0 else (num % 2!= 0)\n\nI think you mean:\nreturn (num % 2 == 0) if num == 0 else (num % 2!= 0)\n\nThe problem with this is that if num == 0, it will never return (num % 2!= 0).\n\nYou're right, I read his code too quickly and thought that he was saying that if num is 0, then (num % 2!= 0).\n\nI think the OP's code is better than the alternatives, but it has a subtle bug", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num.count(0) for num in num if num.count(0) % 2 == 0 else num.count(1) for num in num)\nI don't know about Python, but in Ruby you can just do `even_odd_count(123)`.\nBut that's not Pythonic.\nHow is it not Pythonic?\nI was being sarcastic.  In Python, you'd have to do `even_odd_count(123)`.  It's not Pythonic to have a shorter, more readable version.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num.count(1) + num.count(2) + num.count(3)) / 3", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2 == 0)\nThis is a neat trick.  It's a little like the Fibonacci sequence, but instead of the number of terms, you're counting the number of digits.  I'm not sure I've ever seen this before.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [(num % 2) for num in num if num % 2 == 1 else num]\nI like that. It's simple and elegant.\nThat's a nice idea, but it's a bit too simple. It doesn't work for negative numbers, for instance.\nIt's not intended to. You can't just add a negative number of evens to a number and get a positive number of evens.\nRight, but then you could just as well use the regular `even_even_count` function.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[0]*2 + num[1]*2)%2 == 0", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    \"\"\"return (num[::-1] + 1) * 2 + num[::-1] - 1\"\"\"\n\nI've been seeing a lot of these sorts of things lately, and I think they're a sign that Python is becoming a \"real\" language. (It's about time, I know.)\n\nI've been seeing a lot of these sorts of things lately, and I think they're a sign that Python is becoming a \"real\" language. (It's about time, I know.)\n\nI've been seeing a lot of these sorts of things lately, and I think they're a sign that Python is becoming a \"real\" language. (It's about time, I know.)\n\nI've been seeing a lot of these sorts of things lately, and I think they're a sign that Python is becoming a \"real\" language. (It's about time, I know.)\n\nI've been seeing a lot of these sorts of things lately, and I think they're a sign that Python is becoming a \"real\" language. (It's about time, I know.)\n\nI've been seeing a lot of these sorts of things lately, and I think they're a sign", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\nThis is much more readable.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    result = []\n    for i in range(num):\n         if i % 2 == 1:\n             result.append((i, i))\n    return result\n\nThis is a function that will take an integer and return a tuple of the number of even and odd digits.", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    # Count odd digits\n    odd_count = 0\n    # Count even digits\n    even_count = 0\n    for x in num:\n        if x % 2 == 0:\n           odd_count += 1\n           even_count += 1\n    return (odd_count, even_count)\n\nI've always wondered, what's the point of using a tuple when you can use an array?\n\nTuple is a struct, so it is immutable. You can't change the number of elements in it.\nArray is an object, so it is mutable. You can change the number of elements in it.\n\nYou can't change the number of elements in a tuple? What happens when you try?\n\nIt's not that you can't change the number of elements in a tuple, it's that the number of elements in a tuple is immutable.\n\nYou can still change the number of elements in a tuple. The number of elements in a tuple is not immutable.\n\nOh, I see. So", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num.even % 2) + (num.odd % 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[0] if even else num[1] for num in range(num.max())]\nI think it's pretty clear that this function is not a \"one liner\".\nIt's only one line, but it's not a one-liner.\nIt's a one-line function.\nA one-liner is a one-line program.\nIt's a one-line function that returns a tuple.\nA one-liner is a one-line program that returns a single value.\nThis is not a one-liner.\nThis is not a one-liner.\nIt's a one-line function.\nA one-liner is a one-line program.\nIt's a one-line function that returns a tuple.\nA one-liner is a one-line program that returns a single value.\nThis is not a one-liner.\nThis is not a one-liner.\nIt's a one-line function.\nA one-liner is a one-line program.\nIt's a one-line function that returns a tuple.\nA one-liner is a one-line program that returns a single value.\nThis is not a one-", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [(num % 2) for num in range(2, num)]\n`\nThanks, I don't know why I didn't think of that.\nI guess it's a bit of a trick question.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num % 2 == 0:\n        return (num, 2)\n    else:\n        return (num, num + 1)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[0] for num in range(2) if num%2 == 0]\nYou can use the built in range() function instead of the range(2)\n\nNice! I just updated it to use range() instead of range(2).\n\nI don't think I'd use this. It's a little bit too much for me. I'm also not sure why you would want to use this over a simple loop.\n\nIt's a nice function to have if you are using it in a list comprehension.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\n\nEven_odd_count(123) ==> (1, 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    num = int(num)\n    return (num % 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\n\nThis is a really bad way to do this. The following is much faster:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2)\nThis works for positive numbers only.\n> return (num % 2)\n>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num[0], num[1:] + num[2:] - 1)\n> def even_odd_count(num):\n> \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n>\n> Example:\n>\n> even_odd_count(-12) ==> (1, 1)\n> even_odd_count(123) ==> (1, 2)\n>\n> \"\"\"\n> return tuple(num[0], num[1:] + num[2:] - 1)\nI guess I don't understand the point of this.\n\nIt's a nice exercise in functional programming.\n\nI don't see the point in that either.\n\nI guess it's just a matter of taste.\nI find that I learn a lot about programming by trying to solve problems in different ways.\n\nI don't understand why this is on HN.\n\nBecause it's an interesting programming exercise.\n\nI'm still not sure I see the point of this.\n\nIt's an interesting programming exercise.\n\nI still don't understand.\n\nIt's an interesting programming exercise.\n\nI still", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return tuple(num.split(',')[0], num.split(',')[1])", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num.is_even() + num.is_odd() + 1)\nI don't think it's right to call the function \"even_odd_count\" when it doesn't count the even and odd digits, but rather the even and odd numbers.\nI see what you mean. I'm not sure what to call it.\neven_odd_numbers</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    for i in range(num):\n         if i % 2 == 0:\n             return tuple([i, i/2])\n    else:\n            return tuple([i, i])\n    return tuple\nI'm not sure why you would have a function that does this.  It's a trivial problem.  You could just do this in your head.\n\nI have to agree with you, but I was trying to demonstrate a possible way of thinking about the problem.\nIn my mind, I have a list of integers and I want to know how many of them are odd. I can think of a few ways to go about doing that.\n1\\. Think of all the integers as a list.\n2\\. Think of each integer as a list.\n3\\. Think of each digit of each integer as a list.\n4\\. Think of each digit of each integer as a list of lists.\n\nI think you can get away with \"Think of each integer as a list\" and \"Think of each digit of each integer as a list\".", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\n\nThis is a good example of why you should use named arguments when defining functions.\n\nI'm not sure why you think that would be an improvement.\n\nThe problem with this code is that it's hard to tell what it does without looking at the documentation. It doesn't even have a single comment.\n\nI think it's pretty clear what it does.\n\nI don't think so. I think it's pretty obvious that it's for counting the number of even and odd digits in an integer, but I don't think it's obvious that it returns a tuple of the two numbers.\n\nI think it's pretty clear that it returns a tuple of the two numbers.\n\nI think it's pretty clear that it returns a tuple of the two numbers.\n\nI think it's pretty clear that it returns a tuple of the two numbers.\n\nI think it's pretty clear that it returns a tuple of the two numbers.\n\nI think it's pretty clear that it returns a tuple of the two numbers.\n\nI think it's pretty clear that it returns a tuple of the two numbers.\n\nI think it's pretty clear that it returns", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num % 2 == 0:\n       return (num % 2, num % 2)\n    else:\n       return (num % 2, num % 2)\n\nI don't know if I've been in the industry too long or what, but I found this to be one of the most readable, elegant and effective Python solutions I've ever seen.\n\nI would have called it \"num_even_odd\" and then it would be clear that it returns a tuple.\n\nIt's not clear that it returns a tuple at all, since you don't know whether it's a function or a class.\n\nIt would be a good exercise for someone to write a class that looked like a function.\n\nI believe this has been done:\n\nThis is a nice, clean solution. I'm still partial to my own Python solution though:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) == 0", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) ** 2\nI'm not sure if you're aware of this, but if you're writing code that deals with numbers, you should be using the number module.  It's already in Python, and it's a lot more efficient than rolling your own.\nI'm aware of that, but I didn't want to use it in this case because I wanted to understand what was happening.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num.count(1), num.count(2))", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) == 0", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\nI guess I'm missing something.  I would expect this to return 1, not 2.  Am I missing something?\nYou're right, I'm an idiot.  I was thinking of the number of digits, not the number of digits that are even or odd.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num.count(i) for i in range(num.digits()))[::-1]\n    def even_odd_count_2(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count_2(-12) ==> (1, 1)\n        even_odd_count_2(123) ==> (1, 2)\n    \"\"\"\n    return (num.count(i) for i in range(num.digits()))[::-1]\n    def even_odd_count_3(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count_3(-12) ==> (1, 1)\n        even_odd_count_3(123) ==> (1, 2)\n    \"\"\"", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num.rstrip('0'))", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2)\nI like this one.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\n\nI know this is a joke, but I've always found this kind of thing to be a good litmus test. If a programmer can write a function like this and it actually works, then they're probably competent. If they can't, then they probably aren't.\n\nI'd add a few more tests, like if it works for a string or if it works with a list of integers.\n\nI'm not sure about a list of integers. I think that's an edge case, and if someone can't code a function to handle an edge case, then they probably aren't competent.\n\nI'd also add a test for the case where the number is zero.\n\nI think that's also an edge case.\n\nI think it's a good litmus test for a new programmer, but I'd argue that it's not a good litmus test for a good programmer.\n\nI'd say that a good programmer is someone who can write a function that does what it's supposed to do, and can do so in a way that's not confusing. If you can't do that, then you probably aren't a good programmer.\n\nI think", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) == 0\nThis is a really good idea.  I think I'm going to steal it.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\n\nI think you meant to say \"return (num % 2) + 1\".\n\nGood catch! Fixed.\n\nThe article mentions that the reason why this is faster than the naive way is because you're avoiding the function call overhead. However, the article doesn't mention that in Python, the built-in function is built-in. The built-in function is implemented using a generator, which is a function that yields values instead of returning them. It is implemented as a generator so that it can be called multiple times, avoiding the function call overhead.\n\nGood point. I didn't know about the built-in generator. I'll add that to the post.\n\nThis is a really great example of the difference between python and C. The python version is much more readable and easier to reason about. It also has the advantage that you can easily change it to a generator if you want to.\n\nI think it's a great example of the difference between Python and C.\nPython:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2)\n\nThis is not the shortest way to do it.\n\nIt's also not the most readable way to do it.\n\nIt's also not the most efficient way to do it.\n\nIt's also not the most concise way to do it.\n\nIt's also not the most readable way to do it.\n\nIt's also not the most concise way to do it.\n\nIt's also not the most efficient way to do it.\n\nIt's also not the most concise way to do it.\n\nIt's also not the most efficient way to do it.\n\nIt's also not the most concise way to do it.\n\nIt's also not the most efficient way to do it.\n\nIt's also not the most concise way to do it.\n\nIt's also not the most efficient way to do it.\n\nIt's also not the most concise way to do it.\n\nIt's also not the most efficient way to do it.\n\nIt's also not the most concise way to do it.\n\nIt's also not the most efficient way to do it.\n\nIt's also not the most concise way", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num[0], num[1:] + 1)\n\nThis is a really bad example, because this code doesn't even work for negative numbers.\n\nI don't think it's meant to work for negative numbers.\n\nIt is not. It's meant to illustrate the concept of a tuple.\n\nIt doesn't illustrate the concept of a tuple, it illustrates the concept of a tuple with a value of 1, and a value of 1.\n\nThat is the concept of a tuple.\n\nNo, that is the concept of a tuple with a value of 1, and a value of 1.\n\nNo, that is the concept of a tuple.\n\nNo, that is the concept of a tuple with a value of 1, and a value of 1.\n\nNo, that is the concept of a tuple.\n\nNo, that is the concept of a tuple with a value of 1, and a value of 1.\n\nNo, that is the concept of a tuple.\n\nNo, that is the concept of a tuple with a value of 1, and a value of 1.\n\nNo, that is the concept of a tuple.\n\nNo, that", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num % 2 == 0:\n        return (num, 0)\n    else:\n        return (num, 1)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + (num % 3)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1 if num % 2 == 0 else (num % 2) + 1\n\nThe above is really a classic, but I'm not sure it's the best.", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) & 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    num_evens = int(num.pow(2,2))\n    num_odds = int(num.pow(2,2))\n    return (num_evens, num_odds)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    num = int(num)\n    evens = int(num % 2)\n    odds = int(num % 2)\n    return (evens, odds)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2)\nThis is the best solution, though I would write it as:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    \"\"\"\n    return (num[0] % 2) + num[1]", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[0] for num in range(2, num.max())]\nYou're using range(2, num.max()), but you're using a max() that returns an int.\n> This is the correct answer. I was just lazy and didn't want to write the function.\nThen you should have asked for a correct implementation, not for a correct answer.\n\nI don't see what the problem is. The max function returns an int.\n\nThe problem is that you're using a function that returns an int, but you're using it on a range that will give you a tuple.\n\nOk, I understand what you are saying, but I still don't see the problem. What is the difference between using the max function and using the range function?\n\nThe problem is that the range function will give you a tuple, but you're using a function that expects an int.\n\nOh ok, I see what you are saying. I wasn't aware that the range function would return a tuple. I thought it would return an int as well.\n\nPython does not have a max() function, it has a max() builtin which returns an int. You're using", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\n\nI know this is a joke, but it's worth noting that this is a perfectly valid idiom in Python (and probably other languages).\n\nI have a similar idiom for C#.\n\nThis is the classic \"how many red balls do you have\" problem:\n\nI've heard this called the \"numbers in a telephone number\" problem.\n\nThat's the problem with the telephone numbers. There are 10 kinds of people: those that understand binary and those that don't.\n\nI am surprised that the author didn't mention the most obvious way to solve this problem: use a hash table.\n\nThe problem is not finding the solution, the problem is getting the interviewer to stop thinking about it.\n\nI've heard this called the \"numbers in a telephone number\" problem.\n\nI've heard it called the \"numbers in a telephone number\" problem.\n\nI've heard it called the \"numbers in a telephone number\" problem.\n\nI've heard it called the \"numbers in a telephone number\" problem.\n\nI've heard it called the \"numbers in a telephone number\" problem.", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    # Check if the number is even or odd.\n    if num % 2 == 0:\n        return (1, 1)\n    else:\n        return (1, 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(int(num[1]), int(num[2]))", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[0] % 2 == 0) or (num[1] % 2 == 0) or (num[2] % 2 == 0)\n    or (num[0] == 0) or (num[1] == 0) or (num[2] == 0)\n    or (num[0] == 1) or (num[1] == 1) or (num[2] == 1)\n    or (num[0] == 2) or (num[1] == 2) or (num[2] == 2)\n    or (num[0] == 3) or (num[1] == 3) or (num[2] == 3)\n    or (num[0] == 4) or (num[1] == 4) or (num[2] == 4)\n    or (num[0] == 5) or (num[1] == 5) or (num[2] == 5)\n    or (num[0] == 6) or (num[1] == 6) or (num[2] == 6)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[0] for num in range(num.digits) if num[0] % 2 == 0]\nThis is a great example of a one-liner that is actually better to be written in a few lines.\nYou can't write it in a few lines because you have to use a lambda expression.\nI don't understand why this is a problem.\nBecause you can't do it in a few lines.\nI don't understand why that's a problem.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple([(num[0] % 2) + 1 for num in range(1, num)])\nI prefer the more terse:       def even_odd_count(num):", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2)\nYou're missing an 'else' clause.\nAah. I'm ashamed of myself.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    #", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num == 0:\n       return (1, 0)\n    else:\n       return (1, num - 1) + (num - 1, num)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num == 0:\n        return (1, 0)\n    elif num == 1:\n        return (0, 1)\n    elif num == 2:\n        return (0, 2)\n    elif num == 3:\n        return (1, 2)\n    elif num == 4:\n        return (1, 2, 0)\n    elif num == 5:\n        return (0, 1, 2)\n    elif num == 6:\n        return (1, 2, 3)\n    elif num == 7:\n        return (1, 2, 3, 0)\n    elif num == 8:\n        return (1, 2, 3, 4)\n    elif num == 9:\n        return (1, 2, 3, 4", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[i] for i in range(num.digits())]", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    result = []\n    for i in range(num):\n        if i % 2 == 0:\n            result.append(i)\n    return result\n\nThis is a really bad example because it doesn't actually do anything.\nIt just returns a list of numbers, not the number of even and odd digits.\n\nAh, I think I see what you mean. The above code is just an example of how you might implement the method.\n\nI think the OP meant the actual implementation.\n\nI'm not sure what you mean. The OP's code is the actual implementation.\n\nI think you should be able to read that code and immediately get what it does.\n\nI think it's easy to read, but it's also easy to misread.\n\nThis is really a bad example.\nThe code doesn't even do anything.\nIt just returns a list of numbers, not the number of even and odd digits.\n\nI'm not sure what you mean. The above code is just an example of how you might implement the method.\n\nI think the OP meant the actual", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num == 0:\n        return (1, 1)\n    else:\n        return (num % 2 for num in [0, 1, 2])", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n     return tuple(int(num), int(num) - 1)\n\nThat's not even the right solution.\n\nIt's the right solution for this problem.\n\nI'm not sure how it's the right solution, if you have a number that is\nnot divisible by 2 you will get an error, and if you have a number that\nis not divisible by 3 you will get an error.\nI would expect it to return (1, 1) if the number is divisible by 2 and\n(0, 1) if the number is divisible by 3.\n\nYou're right. I didn't think it through.\n\nI think this is a good illustration of why some people prefer to use\nlanguages with static type systems.\n\nI don't think this is a good illustration of that at all. This is a good illustration of why people prefer to use languages with _strong_ type systems.\n\nI think it's a good illustration of why people prefer to use languages with _any_ type system.\n\nI think it's a good illustration of why people prefer to use languages with _strong_ type systems.\n\nI think it's a good illustration of", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple([num[0] for num in range(1, num) if num % 2 == 0])\n\nI was going to write something like this, but you beat me to it.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num[::2], num[::2])", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    def even_odd_count_impl(num):\n    \"\"\"Given an integer. Return a tuple that has the number of even and odd digits respectively.", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) == 0\n    if num > 0:\n        return (num % 2) == 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num % 2, num % 2)\nI don't think that's what he meant.\nI'm not sure what you mean, but I meant that I think he was looking for a function that would return the number of digits in the number that are even or odd.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[i] for i in range(len(num) - 1)]", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[0] % 2 for num in range(num) if num[0] % 2 == 0]\nI was wondering if anyone had a better way of doing this.\nI don't think it's a good idea to do the range check twice.\nI don't think it's a good idea to use `%` in a boolean expression.\nI don't think it's a good idea to use `==` on strings.\nI don't think it's a good idea to use `%` in a boolean expression.\nI don't think it's a good idea to use `==` on strings.\nI don't think it's a good idea to use `%` in a boolean expression.\nI don't think it's a good idea to use `==` on strings.\nI don't think it's a good idea to use `%` in a boolean expression.\nI don't think it's a good idea to use `==` on strings.\nI don't think it's a good idea to use `%` in a boolean expression.\nI don't think it's a good idea to use `==` on strings.\nI don't think it", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return (num % 2) + 1\n\n    def even_odd_count_int(num):\n    \"\"\"Given an int. return a tuple that has the number of even and odd digits respectively.\n\n        Example:\n        even_odd_count_int(123) ==> (1, 2)\n        even_odd_count_int(456) ==> (1, 0)\n    \"\"\"\n\n    return (num % 2) + 1\n\n    def even_odd_count_float(num):\n    \"\"\"Given a float. return a tuple that has the number of even and odd digits respectively.\n\n        Example:\n        even_odd_count_float(123.456) ==> (1, 2)\n        even_odd_count_float(456.6666666666667) ==> (1, 0)\n    \"\"\"\n\n    return (num % 2.0) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) ** 2 + 1\n\nEven_odd_count is a function that returns a tuple that has the number of even and odd digits respectively.\n\nExample:\n\n>>> even_odd_count(-12) ==> (1, 1)\n>>> even_odd_count(123) ==> (1, 2)\n\nSee also\nEven_odd_pair\n\nReferences\n\nExternal links\n\nPython documentation</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1 if num % 2 == 0 else (num % 2) + 2", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    num_even = 0\n    num_odd = 0\n\n    for i in range(num):\n        if num % 2 == 0:\n           num_even = num_even + 1\n          num_odd = num_odd + 1\n          return (num_even, num_odd)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2 == 0)\n\nI don't see how this is a problem.\n\nThe problem is that it is a hack.\n\nI don't see how this is a problem.\n\nI do.\n\nI don't see how this is a problem.\n\nI do.\n\nI don't see how this is a problem.\n\nI do.\n\nI don't see how this is a problem.\n\nI do.\n\nI don't see how this is a problem.\n\nI do.\n\nI don't see how this is a problem.\n\nI do.\n\nI don't see how this is a problem.\n\nI do.\n\nI don't see how this is a problem.\n\nI do.\n\nI don't see how this is a problem.\n\nI do.\n\nI don't see how this is a problem.\n\nI do.\n\nI don't see how this is a problem.\n\nI do.\n\nI don't see how this is a problem.\n\nI do.\n\nI don't see how this is a problem.\n\nI do.", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\nThis is a very bad solution.\nIt's not even a solution. It's a joke.\n\nThe \"solution\" was a joke, but the idea behind it is not. The idea is that if you need to write a function to determine whether or not a number is even or odd, you should just use modulus.\n\nI agree, but I was replying to the OP.\n\nI don't think the author understands the difference between a joke and a serious answer.\n\nI don't think the author understands the difference between a joke and a\nserious answer.\nI think you're right.\n\nI think you're right.\n\nI think you're right.\n\nI think you're right.\n\nI think you're right.\n\nI think you're right.\n\nI think you're right.\n\nI think you're right.\n\nI think you're right.\n\nI think you're right.\n\nI think you're right.\n\nI think you're right.\n\nI think you're right.\n\nI think you're right.\n\nI think you're right.", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[0] % 2) + (num[1] % 2)\n\n    def even_odd_count_with_remainder(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    for i in range(num):\n       if i % 2 == 1:\n           return [i, i]\n      else:\n           return [i]\n    return [i, i]\n\nI'm not sure why you're returning a tuple. What's the benefit?\n\nI am returning a tuple because I am passing a tuple to the function. It's a function I wrote for a project that I'm working on.\n\nI'm not sure what you mean.\n\nI'm not sure what you mean.\n\nI'm not sure what you mean.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[1:] if num[1] == 0 else 1 for _ in range(num[0])) +\n    (num[2:] if num[2] == 0 else 2 for _ in range(num[1]))", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[0] % 2) + (num[1] % 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num, 2)\nThis is correct.  It's a shame the teacher didn't mention tuples.  The use of a tuple is the standard way to do this in python.  You should get extra credit for using the standard library.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2 == 0? 1 : (num % 2) + 1) + (num % 2)\n\nThat's actually quite elegant.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    # Even Digits\n    return [num[1:], num[2:]]\n    # Odd Digits\n    return [num[3:], num[4:]]", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num == 0:\n        return (1, 1)\n    else:\n        return (num - 1, num - 1)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(2, 2)\nThis is a really bad example.  You should be using the `int` type instead of `int32`.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [(num % 2) for num in range(num,2)]\nI'd use a list comprehension.\nEven though it's not always the case, it's good practice to use list comprehensions when you can.  Especially when it's a one-liner.\nI would say it's good practice to use a list comprehension when you can't use a for loop.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n     return (num[0] + num[1] + num[2]) % 2\n\nFor those who prefer the Python version:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) == 0? (num + 1, num - 1) : (num + 1, num - 2)\nI'm not sure I understand the purpose of this.\nIt's a programming exercise, not something useful.  It's about teaching the mechanics of programming, not the utility of programming.\nAh, I thought it was a real-world application.  In that case, it's pretty pointless.  It's not teaching the mechanics of programming, it's teaching a specific method for doing something you can easily do in a different way.  It's a very contrived example.\nIt's teaching the mechanics of recursion.\nYes, it's teaching a specific way of doing recursion.  It's a very contrived example.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[i] for i in range(2) if i % 2 == 0] + [num[i+1] for i in range(2) if i % 2 == 0]\nSo simple and so elegant!\nI'm not sure why you would use this function over the built-in `sum` though.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\n\nI don't see how this is an improvement over the built-in __str__.\n\nIt doesn't require a built-in function.\n\nThat's true, but it's not a big advantage in this case.\n\nThis is a nice exercise, but it's really not a good solution to the problem.\n\nThis is a very nice exercise. I have done similar things myself, and it's quite interesting to see how other people approach the same problem.\n\nNice one.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\n    def even_odd_count_even(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count_even(-12) ==> (1, 1)\n        even_odd_count_even(123) ==> (1, 2)\n    \"\"\"\n    return (num % 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num == 0:\n       return [1]\n    else:\n       return [num - 1 for i in range(2)]", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2)\n    + (num % 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num == 0:\n        return (1, 1)\n    else:\n        return (num - 1, num - 1)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num.split('.')[0], num.split('.')[1])\nI'm not sure what I'm missing here.  It's just a simple regex that splits the string on the period, then calls split() on the resulting list.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num == 0:\n       return (1, 1)\n    else:\n       return (num - 2, num - 1)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num - 1) * 2\n    + (num - 1) * 2\n    + (num - 1) * 2\n    + (num - 1) * 2\n    + (num - 1) * 2", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return (num % 2) == 0\n\nI'm not sure what you're trying to do, but you can try this:\n>>> from itertools import cycle\n>>>\n>>> for n in range(3):\n>>>    print(cycle(even_odd_count(n)))\n>>>\n>>> for n in range(3):\n>>>    print(cycle(odd_even_count(n)))\n>>>\n>>>\n>>> for n in range(3):\n>>>    print(cycle(even_odd_count(-n)))\n>>>\n>>> for n in range(3):\n>>>    print(cycle(odd_even_count(-n)))\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>\n>>>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[0] if num[0] % 2 == 0 else 0) + (num[1] if num[1] % 2 == 0 else 0)\n    # Note the use of the \"else 0\" clause to make it easier to read\n\nYou're missing the point. You can't just add the digits and get the number of evens and odds. You have to sum the digits and then check if the result is even or odd.\n\nI'm pretty sure that was the point.\n\nI'm pretty sure that was the point too.\n\nI don't know, it looks like the point to me.\n\nI'm pretty sure that was the point.\n\nI'm pretty sure that was the point.\n\nI'm pretty sure that was the point.\n\nI'm pretty sure that was the point.\n\nI'm pretty sure that was the point.\n\nI'm pretty sure that was the point.\n\nI'm pretty sure that was the point.\n\nI'm pretty sure that was the point.\n\nI'm pretty sure that was the point.\n\nI'm pretty sure that was the point.\n\nI'm pretty", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num == 0:\n        return (1, 0)\n    else:\n        return (num - 1, num)\nI would write it this way:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n         return (num.count(i) for i in range(0, num.count(1)) if i%2 == 0 else num.count(1))\n        # even_odd_count(12) ==> (1, 1)\n        # even_odd_count(123) ==> (1, 2)\n        # even_odd_count(-12) ==> (1, 2)\n        # even_odd_count(123) ==> (1, 2)\n        # even_odd_count(-12) ==> (1, 2)\n        # even_odd_count(123) ==> (1, 2)\n        # even_odd_count(-12) ==> (1, 2)\n        # even_odd_count(123) ==> (1, 2)\n        # even_odd_count(-12) ==> (1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[::-1] + num[::-1]) % 2", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[i] for i in range(num.size())]", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\nI would be interested to know how this is more useful than `len(num)`.\nIt's not more useful. It's just a way to write `len(num)` in python.\nI think you've missed the point of the thread.\nI think I've missed the point of the thread.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num[:i], num[i+1:] - num[i+2:] - num[i+3:] for i in range(0, num.digits))\nYou should probably use the new keyword for that, since it's a new function.\nYou're right.  I will do that.  Thanks for the feedback.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[0]*2 + num[1]*2) / 2\n    + num[2]\nThis is incorrect.  The correct answer is (num[0] + num[1] + num[2]) / 2.  I know this because it is the only way I know to make this code compile.  Please fix.\nI'm pretty sure that this is the right answer. I don't understand why it doesn't compile for you.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    num_even = 0\n    num_odd = 0\n    while num_even < num:\n        if num_even == 0:\n           num_even = num\n          num_odd = 1\n        else:\n           num_even = num - 1\n           num_odd = num + 1\n        return (num_even, num_odd)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[1] for num in num if num[1] % 2 == 0]\nI've always been partial to using the function `is_odd` for this.\nis_odd(num) == num % 2 == 0\nThe same with is_even.\nis_even(num) == num % 2 == 1\n\nI think this is the most elegant solution.\n\nThis is a nice way to get the first N even numbers, but if you want the first M, then you need to do something like this:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return (num % 2) + 1 if num % 2 == 0 else (num % 2) - 1\n\nThe article is right. Python is not C.\n\nThe article is wrong. The code is not Python.\n\nI don't know why the author of the article thinks that this is Python. It's just C.\n\nI think you missed the point. The author of the article is saying that the C code is not Python, and that the C code is too complex for what it does.\n\nThe author of the article is saying that the C code is not Python, and that the C code is too complex for what it does.\nI think you missed the point. The author of the article is saying that the C code is not Python, and that the C code is too complex for what it does.\n\nThe author of the article is saying that the C code is not Python, and that the C code is too complex for what it does.\nI think you missed the point. The author of the article is saying that the C code is not Python, and that the C code is too complex for what it does.\n\nThe author of the article is saying that the C code", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + (num % 3)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num % 2 == 0:\n        return tuple(num)\n    return tuple(num / 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num % 2, num % 2)\nI was expecting something like this.  I would have made the number of digits that are even or odd be the first two elements of the tuple.\nI'd have just used the modulus operator.", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num == 0:\n        return (1, 1)\n    elif num == 1:\n        return (1, 1)\n    elif num == 2:\n        return (2, 2)\n    elif num == 3:\n        return (1, 1)\n    elif num == 4:\n        return (2, 2)\n    elif num == 5:\n        return (1, 1)\n    elif num == 6:\n        return (2, 2)\n    elif num == 7:\n        return (1, 1)\n    elif num == 8:\n        return (2, 2)\n    elif num == 9:\n        return (1, 1)\n    elif num == 10:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num%2==0:\n        return (1, 1)\n    else:\n        return (1, 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    def even_odd_digits(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_digits(-12) ==> (0, 0)\n        even_odd_digits(123) ==> (2, 2)\n    \"\"\"\n    return (num % 2)\n\nThe author didn't do any math.  He just wrote the code.  Look at the two examples.  The first one is (1, 1) and the second is (2, 2).  He doesn't even know the correct result.  And why did he use a division operator?  He should have used a modulus operator.\n\nThe author of the article is the author of the code.\n\nOops.  I thought I was reading a blog post.  I didn't notice the author's name.\n\nThe author of the blog post is the author of the code.\n\nI don't understand why he didn't use a modulus operator.\n\nHe didn't do", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num / 2) + (num % 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[i] for i in range(2,num.count(1)) if i % 2 == 0]\nI think you meant `num.count(1)`\nYou're right, I did.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) == 0\n\nThat's an example of how not to write Python.\n\nWhy not?\n\nI wouldn't write it that way because it's ugly, but it's a perfectly valid way to write it.\n\nIt's not valid, it's a syntax error.\n\nIt's not a syntax error, it's an _error_, but it's perfectly valid.\n\nIt's a syntax error.\n\nIt's not a syntax error.\n\nIt's a syntax error.\n\nIt's not a syntax error.\n\nIt's not a syntax error.\n\nIt's not a syntax error.\n\nIt's a syntax error.\n\nIt's not a syntax error.\n\nIt's a syntax error.\n\nIt's not a syntax error.\n\nIt's a syntax error.\n\nIt's not a syntax error.\n\nIt's a syntax error.\n\nIt's not a syntax error.\n\nIt's a syntax error.\n\nIt's not a syntax error.\n\nIt's a syntax error.\n\nIt's not a syntax error.\n\nIt's a syntax error.\n\nIt's", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[0] if num[0] == 0 else num[1]) + (num[1] if num[1] == 0 else num[0])\n    + (num[2] if num[2] == 0 else num[1]) + (num[3] if num[3] == 0 else num[2])\n    + (num[4] if num[4] == 0 else num[3]) + (num[5] if num[5] == 0 else num[4])\n    + (num[6] if num[6] == 0 else num[5])", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) == 0", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + (num % 2) + (num % 2)\n    if num%2==0:\n        return (num%2==1)\n    else:\n        return (num%2==0)\nThis is pretty much a standard algorithm, you can find it in most programming textbooks.\n\nYes, I know it's not a very sophisticated algorithm. But I don't know how to implement it in Python, which is what I'm trying to do.\n\nFor a start, you should read the docs for the built-in itertools module.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num % 2, num % 2)\nThis is a bad example because of the way that division works on floats.  Try this instead:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[::2] for num in range(2, num.length - 1)]\nI think this one is a little easier to understand.\nI'm not sure what the advantage of the first one is.\n\nI agree that the first one is easier to understand.\nThe second one is more general (it works for any kind of tuple), but the first one is easier to understand and is usually sufficient.\n\nThe first one is more general (it works for any kind of tuple)\nNot really, since you could just as easily write:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num > 0:\n        return (num + 1) % 2\n    else:\n        return (num - 1) % 2\n\nThis is a good example of a simple, but useful utility function.  I don't think it would be a good fit for a module.\nI'd like to see a library of useful functions like this.  It would be really easy to implement, and could be a good way to get people started with Python.\n\nI think the best way to get people started with Python is to have them write useful Python programs.\n\nI agree.  I'm just thinking that this would be a good way to get people started on writing useful Python programs.\n\nI think that's what the standard library is for.\n\nI think it would be a mistake to put this in the standard library.\n\nWhy?\n\nBecause it's not a standard library function.\n\nI don't think that's a good enough reason.\n\nYou're right.  It's not a good enough reason.\nIt's not a good reason at all.\n\nI'm curious, why would you not", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2)\n    + (num % 2)\n    + (num % 2)\nThis is the same as:\n\n    return (num % 2) + (num % 2)\n    + (num % 2)\n\nIt's not, because the second version is not guaranteed to terminate.\n\nThis is true. The second version is not guaranteed to terminate, and is also O(n^2) (whereas the first version is O(n)).\n\nActually, this is not true.\nYour code is correct if you assume that the number is in base 2, but in the general case, the second version is not correct.\n\nThe first version is not correct either. If you have an odd number, the first version will give you a tuple with two 1's, which is not correct.\n\nI was referring to the first version of the code, not the first version of the comment.\n\nThe second version of the code is not correct. If you have a number that is not in base 2, the second version will give you a tuple with two 1's, which is not correct.\n\nThe first version of", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) == 0", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\nI'm not sure what you're trying to achieve, but this seems to do it.\nI am trying to achieve the same thing as in the link, but without having to write a loop.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\n    + (num % 2)\n    + (num % 2)\n    + (num % 2)\n    + (num % 2)\n    + (num % 2)\n    + (num % 2)\n    + (num % 2)\n\nI like this, because it's a very easy way to make a function that's both readable and is obvious how it works.\n\nI like that it's a recursive function that's easy to read.\n\nI like that it's a recursive function that's easy to read.\n\nI like that it's a recursive function that's easy to read.\n\nI like that it's a recursive function that's easy to read.\n\nI like that it's a recursive function that's easy to read.\n\nI like that it's a recursive function that's easy to read.\n\nI like that it's a recursive function that's easy to read.\n\nI like that it's a recursive function that's easy to read.\n\nI like that it's a recursive function that's easy to read.", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    result = []\n    for i in range(num):\n        if i % 2 == 0:\n            result.append(i)\n        else:\n            result.append(i)\n    return result", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + (num % 4)\nI don't know if this is what you're looking for, but I have a feeling it is.\nIt is.  I had to add a little bit to it, but it's working great.  Thanks!\nGlad I could help!</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) == 0\nThis is not correct.  The number of even and odd digits is the same.  The number of digits is even, so you need to subtract one to get the number of even digits.  The number of digits is odd, so you need to add one to get the number of odd digits.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num.count(1) + num.count(2)) / 2\nThis is a neat way to do it, but I think a more obvious way is to use the power operator.\nreturn (num.count(1) + num.count(2)) % 2\nThat doesn't work for negative numbers, though.\nSure it does.  Just use the negative power operator.  I'd recommend using the signed integer type, but that's just me.\nI was under the impression that negative power is the same as subtraction, and that it would yield a negative number.\nIn this case, you're not subtracting.  You're just adding the values of two variables.  You could do it in one line with:      return (num.count(1) + num.count(2)) & 1\nI think you missed the point.  I was saying that `num.count(1) + num.count(2)` wouldn't work for negative numbers, not that `num.count(1) + num.count(2) - 1` wouldn't work.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n    return (num % 2) + 1\n\nIf you're using Python 3.x, you should use `mod` instead of `%`.\n\nThat's probably why the author chose to use %2 instead of %2.\n\nI think it's more likely that the author is familiar with the C standard library and its functions, which use %.\n\nWell, mod is the same thing as % in C, it's just a built-in function in Python.\n\nI think you mean % is the same thing as mod in C.\n\nNo, I don't. Mod is the same thing as % in C.\n\nPython 2.x:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2 == 0)\n    if num % 2 == 0:\n         return (num % 2)\n    return (num % 2)\nI have been using this for a while and it works great.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num[0], num[1])\nI'd probably do something like that, but I'd also check the number of digits and return a tuple with the number of even and odd digits.   It's a little more complicated but it's also a little more flexible.\nI don't think there's any reason to check the number of digits. If you don't know how many digits are in the number you're probably doing something wrong.\nYou're probably right. I just figured that it was the simplest way to do it.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\nThis is not a good example, since it's not even correct. It should be:\nreturn (num % 2) + 1\n\nThis is not a good example, since it's not even correct. It should be:\nreturn (num % 2) + 1\n\nFixed.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num % 2 == 0:\n       return tuple([1, 1])\n    else:\n       return tuple([1, 2])\n\nThis will return 1,2 for 123, and 1,1 for -12.\n\nIf you want the number of even digits and the number of odd digits, just do:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    def even_odd_digits(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n     Example:\n        even_odd_digits(-12) ==> (1, 1)\n        even_odd_digits(123) ==> (1, 2)\n    \"\"\"\n    return (num[0], num[1])", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num.count(1) for num in range(num.digits()))\n\nI've never understood this \"return tuple\" thing. It looks like a hack. What's the point?\n\nTuple is a Pythonic way to return multiple values from a function.\n\nI know what a tuple is. I just don't understand what the point is in making a function return a tuple.\n\nIt's a way to return multiple values from a function.\n\nI get that, but what's the point?\n\nIt's a way to return multiple values from a function.\n\nI'm sorry, but that's not an answer.\n\nIt's a way to return multiple values from a function.\n\nOk, I'm sorry, but I'm still not getting it. What's the point of returning multiple values?\n\nIt's a way to return multiple values from a function.\n\nIs there some sort of benefit?\n\nIt's a way to return multiple values from a function.\n\nIs there some sort of benefit?\n\nIt's a way to return multiple values from a function.\n\nIs there some sort of benefit?\n\nIt's", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return (num % 2) == 1\n\nThis is one of the reasons I prefer Python.  The language is so much more expressive.\n\nI think the more expressive language is the one that you are more comfortable with. I think that if you were to give me a week to learn python, I would find it just as expressive as ruby.\n\nI disagree. I think that Python is more expressive than Ruby because Python allows you to write concise code that is still readable.\n\nI'd love to see an example of the code you are referring to.\n\nI'd love to see an example of a concise and readable ruby code.\n\nI'd love to see an example of a concise and readable python code.\n\nThe example I posted is concise and readable.\n\nI still don't see how this is more concise than the ruby version.\n\nI think that the ruby version is more concise, but I find it harder to read.\n\nI find the opposite.\n\nI'm not sure how this is a surprise to anyone.\n\nDoesn't look like a surprise to me. It looks like a helpful reminder.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\nThis is a horrible solution, because you can't just do `even_odd_count(123)` and expect the result.  You have to do `even_odd_count(123) % 2`.\nYeah, I should have made it a little more obvious that the % 2 was part of the return value.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return (num % 2) + (num % 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num % 2 == 0:\n        return (num, 2)\n    else:\n        return (num, num)\nThat's one way to do it.  Another way is:       def even_odd_count(num):\n         return num % 2 == 0\n\nThis is a bit silly. The first one is clearly better.\n\nI agree that it's silly to have a function that simply calls itself, but I think that the version that calls itself is more readable.\n\nI have to disagree. I think the version with the conditional is much more readable. I can easily see what it's doing.\n\nI like the version that calls itself. It's easier to see what it's doing, and it's easier to read the code. I can read the code in my head as \"if num is even, return num, if not, return num, num\"\n\nI think you can read the version with the conditional the same way. It's easier to see what it's doing, and it's easier to read the code.\n\nI agree", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num == 0:\n        return tuple([])\n    else:\n        return tuple([(num - 1) % 2 for num in range(2, num - 1)])\n\nThere's also a pythonic version of the above function:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n     return (num % 2)\n     def even_odd_count_with_comparison(num, other):\n     \"\"\"Given an integer and another integer. return a tuple that has the number of even and odd digits respectively.\n     Example:\n        even_odd_count_with_comparison(-12, -23) ==> (1, 0)\n        even_odd_count_with_comparison(123, -123) ==> (1, 2)\n     \"\"\"\n     return (num % 2)\n     def even_odd_count_with_comparison_with_name(num, other):\n     \"\"\"Given an integer and another integer. return a tuple that has the number of even and odd digits respectively.\n     Example:\n        even_odd_count_with_comparison_with_name(-12, -23) ==> (1, 0)\n        even_odd_", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[0] if num[0] % 2 == 0 else num[1] for num in nums]\nDoesn't this just check if the number is divisible by 2?\nIt is, but it does it in a way that gives you the number of even and odd digits.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\nThat's pretty good, but I'd also like to see the reverse: given an integer, return the number of even and odd digits.", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[::-1] + 1) % 2", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    # return tuple with count of even and odd digits\n    return tuple(0, num.count(odd) + num.count(even))\nThat's the way I would do it too, but it seems like the author is trying to do something different.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num.is_even(), num.is_odd())\nThis is probably the best answer.  It's not exactly the same as the solution in the book, but it is very close.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return [(num % 2) for num in nums if num % 2]\n\nIf you want to do it with a single function, you can use the 'if' statement.\n\nThis is a good example of how to write a function that is both readable and fast.\n\nThe if-statement is not very readable, but it's definitely fast.\n\nYeah, I've been using Python for a few years now and it's still hard for me to read this.\n\nThe if statement is a bit messy, but it's not hard to read.\n\nI think the if statement is a bit clearer if you know that the expression is\nthe remainder of the division by 2.\n\nI like the ternary operator, but I don't think it's a good idea to use it for the first argument.\n\nThe ternary operator is a really bad idea. It's a great way to write code that is hard to read.\n\nI don't know.\nI think it's a very good idea to use it for the first argument, but not the second.\n\nI agree. In the example, the ternary operator is used for the second argument, and it", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[i] for i in range(num.length)]", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[0] + num[1] + num[2]) / 2", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return tuple(num.split(\",\")[0], num.split(\",\")[1])", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    num_even = num % 2\n    num_odd = num % 2\n    return (num_even, num_odd)\n\n>>> even_odd_count(123)\n(1, 2)\n>>>\n\nA better way to do this is to use the Python modulo operator.\n>>> even_odd_count(123)\n(1, 2)\n>>>\n\nThis is much more efficient since the modulo operator is implemented in hardware.\n\nThis is a great example of premature optimization.\n\nI'm not sure that I agree. In Python, the modulo operator is implemented in software.\n\nI think the parent meant that the modulo operator is implemented in hardware for the specific processor the Python interpreter is running on.\n\nThat's what I meant.\n\nI don't think you know what the word \"premature\" means.\n\nIt's not premature if the code is running on a platform that has hardware support for the modulo operator.\n\nThat's the point of the article.\n\nI think that's a bad example.\nI think that it's more important to optimize for a program that will be running for a long", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return tuple(num % 2 for num in range(2,num))\n\nIf you have a range of numbers, why not use an iterator?\nfor num in range(2,num)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + (num % 2)\n\nThat's not really the same thing. It's just a way to count the number of even and odd digits.</s>"]]