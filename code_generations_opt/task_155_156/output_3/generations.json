[["def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    for i in range(num):\n        if i % 2 == 0:\n           return tuple(i, 1)\n       else:\n           return tuple(i, 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    for i in range(num):\n        if i % 2 == 0:\n            return (i, 1)\n        else:\n            return (i, 2)\n\nI was writing a test program, and I realized that I could just use `return` to return the value from the function. I think this is a lot clearer than the second example. Is it valid python?\n\nThe expression of the return value will be evaluated before the function is called, so it's somewhat equivalent to:\nreturn i * 2\n\nPython is a language that seems to be built on top of several (smallish) languages.\nThere is the obvious string/list/set/dict/etc, and then there is the fact that a list can be an attribute of a class, a dict can be an attribute of a class, etc.\nThen you add in a module system (which I think is a really great thing) and some macros, and the ability to add built-ins (which are just functions with some special syntax), and you get a language", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    result = [num[::-1] for num in nums]\n    for n in result:\n        if n in [0, 2, 4, 6, 8, 10]:\n            return [n]\n        else:\n            return []\n    return result\nIt's not very pythonic, but it's very succinct.\nThis is very interesting. This is a good way to express this in python. The only thing I wish python had was a way to break the list into lists automatically.\n\n It would be cool if there was a way to specify the number of elements in a list. I.e.      for i,j in enumerate(my_list):\n\nPython already has a very simple way to do that, and it's called a generator.\n\nWhen I was learning C#, I was introduced to a lot of neat features of the language. One of the most useful things was the foreach loop, which allows you to iterate over the contents of an array without having", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num < 2:\n        return {}, 0\n    else:\n        return {}, num % 2\n\nPython</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    num = int(num)\n    return (int(num) * 2) + (int(num) % 2)\n\n    for num in range(1, 2):\n        print odd_count(num)\n        print even_count(num)\n\nThis is a good example of a language feature that's nice in principle, but in practice can be a real pain in the ass.\n\nThe language feature is for list comprehensions, which IMO are a good idea. I'd argue that this is a bad example because it's not very clear what the code is doing.\nHowever, that's the real problem. The problem is that list comprehensions, while a good idea in principle, can be abused.\n\nIt's a bad example because it's pretty much equivalent to a for loop.\nAnd yes, they are a good idea. I wish Ruby had them. And I wish Python had them, too, although it has list comprehension notation, which is _almost_ the same thing.\n\n_It's a bad example because it's pretty much equivalent to a for loop._\nAs I said, it", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[0] for num in range(2)]\nYou're missing the for-loop.\nI think they meant to write that it returns a tuple with 1 and 1.\nThe return type isn't specified so it could return a set of tuples.\nAgreed. It could return a set, but I thought it was obvious from context that it was returning a tuple.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) == 0", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    \"\"\"\n    \"\"\"\n    return (int(num), int(num) - 1) + 1\n\nI don't know what languages you use, but the C-style one line comment in Python is actually a bit nicer:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n     odd_count = 0\n\n     while num!= 0:\n          odd_count += 1\n          even_count += 1\n          return (odd_count, even_count)\n\nI'm a little confused, did you just use a for loop and a random number generator to get the solution? If so, you could have used the same algorithm as the one shown in the post, and gotten a faster execution time.\n\nI don't think this is intended to be a real-world solution, but rather a demonstration of the algorithm's correctness.\n\nCorrect. I meant to show that it is a _sound_ algorithm, not a performant one.\n\n(2012)</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    # Take the integer as an argument.\n    if num == 0:\n        return tuple(1, 1)\n    else:\n        return tuple(num - 1, tuple(num - 2, tuple(num - 3)))\n\nWhat's the point of writing the function this way? In the first line you can just write\nreturn tuple(1, tuple(1, 1))\nand in the second line\nreturn tuple(num - 1, tuple(num - 2, tuple(num - 3)))\n\nThis is Python. It's OK to be a little verbose, especially when your code is more readable.\n\nIf your code is more readable, it's more readable to omit the first line. In Python, there's no difference between\nreturn tuple(1, 1)\nand\nreturn tuple(1, tuple(1, 1))\n\nHow does your code handle a negative number, for example -12?\n\nit returns a tuple with two elements, the first being 1, the second being the number of evens.\n\nThe first poster is right. I read the first version as:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num[1:]*(num[1:]+1), num[2:]*(num[2:]+1))\nAh, the old Haskell switcheroo...  I'm guessing this is supposed to be some sort of `is_odd` function or something, but it's very poorly named.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num, len(num))\nSeems like a poor choice of name.\nagreed, but you are missing the point.\nI'm not missing the point at all.  I just think it's funny.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    if num % 2 == 0:\n         return (num - 1, num - 2)\n    else:\n         return (num - 1, num - 3)\n\nI actually created a module for this in my python source code.  I also added a negative argument because I wanted to have a return of 0 when the number was evenly divisible by 2, 3, 4, or 6.  This function works for positive, negative, and even numbers.  I also added an optional argument for specifying the number of leading zeroes, because I needed this for some programming problems.  This is how my function works:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple([1, -1])\nAh, so it's less trivial than it seems.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    for x in num:\n       if x % 2 == 0:\n          return (x, x + 1)\n    return None", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[i] % 2) + 1\nEven that's a bit too verbose, you could probably do it a bit more compactly.\nIt's just one line of code, but the line is 8 characters long.  How would you shorten it?\nI would say      return (num[i] % 2) + 1  It's just one less character.  If you're doing other things, that could turn into quite a few less characters.\nThat's a one line difference, not eight. I was asking how you would shorten it even more.\nOh, sorry.  I guess I don't know.  I'd probably use a loop so it'd be even shorter, but I was wondering if there was a shorter way without the loop.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return tuple(num)  #tuple for default python implementation\n    if num % 2 == 0:\n          return tuple(num - 1)  #if not even, take half\n          return tuple(num + 1)  #if not odd, take half\n          return tuple(num)\n\nIt's a bit ugly.\n\nI'm not sure that it's very beautiful either:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num + num % 2) + (num % 2)\n\nI'm not sure why you need to pass the parameter as a function.        def even_odd_count(num):", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    n = int(num)\n\n    evens, odds = 0, len(num) - 1\n\n    for i in range(len(num)):\n        if n % i == 0:\n            odds = n % i\n\n            evens = i\n\n    return (evens, odds)\n\nEven and Odd numbers have different definitions depending on the base. I think you mean to write your function like this:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    for i in range(num):\n         if i % 2 == 1:\n            return [i, 1]\n         else:\n            return [i, 2]", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num % 2] + num", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n     return (num > 0)? even_odd_count(num-1): even_odd_count(num+1)\n\nYay! You beat me to it. I was trying to write something like this as a python module that would take a floating point number and return a tuple of evens and odds.\n\nThis is like a mind-hack, as it makes me think about it.\nGood job, I like it.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[0] for num in range(1, num*2, 2)]\nI have not tested this.\nDid you?  Can you tell me why you think this is the best solution?\nI had a similar problem in C and Python, where I needed to find the number of even and odd numbers in a list of integers, and this was the solution I used. I haven't tested it in Python, but it worked for C.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num%2 for num in range(0,1,2))\nThe range() function is pretty neat. I've been using it more and more recently. It's often the right thing to do when you are counting things.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    for i in range(num):\n        if i % 2 == 0:\n           return {even:i, odd:i+1}\n\nThis is not a function that anyone would ever write, and if you see it in code, you should probably run away.\n\nIt's a very reasonable way to check if a number is odd, and I don't see why you should \"run away\".\n\nIt's not clear to me what this comment is a response to. \"Why would you write this?\" is a very reasonable question.\n\nI don't see what's not clear. The comment says this is not a function anyone would write, and that if you see it in code you should probably run away. I was disagreeing with both of those statements.\n\nI was trying to be funny, but I'll be more explicit:\n>>> import odd_even_count\n>>> odd_even_count(-12)\n<type 'function'>\n>>> odd_even_count(123)\n<type 'function'>\n>>> odd_even_count()\n<type 'function'>\n>>> odd_even_", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[0] + 2 ** (num[1] - 1) for _ in range(2))\n\nThat's not idiomatic python. The nice thing about python is that idiomatic python is also idiomatic java, php, perl, etc.\n\nWell, it's not idiomatic in the sense that the language designers didn't do it. It's idiomatic in the sense that lots of python programmers use it, and even more have used it in the past.\n\nThis is one of the reasons that I like Python. It makes it easier to write idiomatic code in other languages because of the shared syntax.\n\nSo I've started writing an awful lot of Python. I'm now getting into writing Python extensions. I'm not happy with the current state of this code, but I've heard many people praise the elegance of Python. Can anyone tell me why this code is not considered idiomatic? Thanks!\n\nThis code is beautiful because of its simplicity. The ability to define class members and methods in a single line makes it so easy to work with classes.\nOf course, python has a lot more to offer than just classes, so it's best to start with the basics (which you", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    def count(x):\n         return x**2\n    return (x**2, 0)\nWow, I'm so glad that I had the foresight to stay away from Python.\nHow can a programmer not know how to write a simple function like this?\nI just write it on the spot when I need it.\nYou can write it in your head, or just write it out.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return tuple(num)\nAs a point of fact, this only works for positive integers.    (I know you probably know this, but just in case someone is reading this thread who doesn't.)\nYes, I was going to mention that, but then I got lazy. :P</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    a, b = int(num)\n    return tuple(a + b for a in range(2, b))\n\nThe easier to read and type version is:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    result = {0: even_odd_count(num), 1: odd_even_count(num)}\n    return (result, num)\nI feel that a lot of python code is obfuscated.\nThat is because it was written by a mathematician.\n\n And, I don't mean that as a slur.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) == 0? 'even' : 'odd'\n\nI'm not an experienced developer but something about this just seems wrong.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num < 0:\n        return (0, 0)\n    else:\n        return (num % 2, num % 2)\n\nfor a challenge:</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return ([num[0] for num in range(2, num) if num[0] == 1 else 0])\nI thought I read somewhere that the range function was slow.\nI haven't heard anything about that.  If it's in the docs, that's good enough for me.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (sum(r), sum(s))\nYou really should have said this was python (or in the title of the post).\nEven if he did, most people here will know that if it's code, it's not Java.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    def count_even_digits(num):\n    \"\"\"Given an integer. Return the number of even digits.\n\n        Example:\n        count_even_digits(-12) ==> 6\n    \"\"\"\n    return num%2 == 0\n    def count_odd_digits(num):\n    \"\"\"Given an integer. Return the number of odd digits.\n\n        Example:\n        count_odd_digits(-12) ==> 6\n    \"\"\"\n    return num%2 == 1\n\n    return (count_even_digits, count_odd_digits)\n    class Bignum:\n    \"\"\"A class to represent large integers. An integer in this class can\n    have at most 53 bits. The integer can have 53 bits of precision or\n    52 bits and a sign bit. It is a type of integer, not a type of\n    bignum. \"\"\"\n    def __init__(", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    \"\"\"Generate a random number between 0 and 9\n    return sum(odd_digits(rand())) + sum(even_digits(rand()))\nI can't help but think this is the most Pythonic way of doing this.\nYeah, this is a pretty clear case of the Pythonic way being the most readable way, even if the implementation is a bit wonky.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    from collections import Counter\n    def even_odd_tuple(num):\n        x = Counter()\n\n        for i in range(num):\n           if i%2 == 0:\n               x.add(i)\n              x.set_value(i)\n            else:\n               x.add(i)\n\n        return Counter(x)\n    return even_odd_tuple\nYour example is missing a step: \"for i in range(num):\" and \"if i%2 == 0:\"\n\nFixed. Thanks!\n\n_An Oddly Satisfying Programming Problem_\nI don't think it's odd.\n\nI just love that the article's title is \"An Oddly Satisfying Problem\" and the top comment is \"I don't think it's odd.\"", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) == 0\nI don't get it. What's the purpose of this function?\nI'm guessing it's a joke on people who are too lazy to learn to properly use the % operator to make sure they are dividing by 2.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + (num % 2) + num\nThis only works if you've first implemented a num % 2 function.\nYeah, it's called modulus.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) == 0\nThis is less elegant, but equally readable in my opinion.\nAlso, I'd prefer to be able to use the '%' operator without the parentheses, as it's common enough that it's easily recognizable as a language operator.\nHow would you do that? (I'd be interested in hearing how, because I can't think of a way to do that without getting rid of the parentheses and turning it into a function call.)</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return (num.isin(0,2)? 2 : 1) + (num.isin(2,0)? 1 : 0)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num % 2 == 0:\n        return (num, len(num))\n    else:\n        return (num, 1)\nCan't you just return it as a tuple or list?\nI think the point is to show that a method doesn't need to be recursive in order to be useful.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [(str(num) % 2) for i in range(num.intValue)]\nThis is far better than my solution for the same problem.\nMy version was:      def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n          Example:\n            even_odd_count(-12) ==> (1, 1)\n            even_odd_count(123) ==> (1, 2)\n    \"\"\"\n    return [(num.intValue % 2 for i in range(num.intValue)]\nIs there some way I can get rid of the indentation?\n\nI would recommend using the string formatting operators to avoid the indentation. For example:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[0] for num in range(num.__digits)] + 1\nWhy not use is_odd_number?\nI'm learning programming and I don't know a lot of stuff, I don't know what's the difference between is_odd_number() and even_odd_count().\nis_odd_number is a built in function of the python language and returns True if the input number is odd or False if it is even.  is_odd_number is faster to execute than this method and is more correct.  that's why they're saying to use is_odd_number instead of this function.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple([num.count(int(x) for x in xrange(num.digits())))\nThis doesn't work with negative numbers or with floats.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n         return tuple(num.count(even), num.count(odd))\n\nThis is the solution I went with in the end. Simple and efficient. Thanks guys.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2 for num in range(num + 1, 1) if num % 2 == 1 else 0)\nI like the elegance of this one.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num % 2 == 0:\n        return (num % 2)\n    else:\n        return (num % 2) + 1\n    print(even_odd_count(123)) # (1, 2)\nAnd I was just wondering how long it would take for someone to post this.\nI was looking for the comment that would be like \"you should post this to /r/ProgrammerHumor\".</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) == 0\nYou're missing the first \"return\".</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    print(\"input: \")\n\n    digits = int(input(\"enter a number: \"))\n\n    even_count = 0\n\n    for digit in digits:\n\n         even_count += 1\n\n         if (digit % 2 == 0):\n             odd_count = 0\n             else:\n              odd_count = even_count\n\n          return(\n             (odd_count, even_count)\n             )", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    def __len__(self):\n        return len(self.even_digits) + len(self.odd_digits)\n    if num > 0:\n        return (self.even_digits, self.odd_digits)\n    return (None, None)\n\nCan't you just say it's a function that takes an int and returns a tuple of (int, int)?\n\nYou can, but then you've just documented a function, not a data type.\n\nTrue, but there isn't much value in documenting a data type in this way. I'd say it's better to document the function as a function with one argument and two return values, and then just point out that it's also a type that can be treated like a tuple or list.\n\nGreat read, I'll be sure to use some of these tips in future.\n\nI've never heard of this site, but that article was the most useful I've read in months.\n\nis also very good</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num == 0 or 1:\n        return (1,1)\n    else:\n        return (2,1)\n    return (2,2)\n\nWith Python 3 you can also use `itertools.count` to iterate over the digits of a number, and return a tuple of tuples.", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    result = []\n    for i in num:\n         if i%2 == 0:\n             result.append(i)\n             result.append(i+1)\n    return result\n    This returns an empty tuple.  Just a warning.\nBut I think you can fix it by doing this:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2)\nWhy not just use the built-in int() function?</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num == 0:\n        return [0]\n    else:\n        return [num]\nThe number of even and odd digits doesn't depend on the base used.  For example, in base 2, the number -12 has one even digit (1) and one odd digit (1), and in base 16, it has one even digit (1) and two odd digits (1, 1).</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 2\n    def even_even_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and even digits respectively.\n\n     Example:\n        even_even_count(-12) ==> (1, 2)\n        even_even_count(123) ==> (2, 2)\n    \"\"\"\n    return (num % 2)\n\nOutput:\n\n(1,1)\n(2,2)\n\nIn python it would be:\n>>> def even_odd_count(num):\n...    return (num % 2) + 2\n...    def even_even_count(num):\n...    return (num % 2)\n...\n>>> even_odd_count(-12)\n(1, 1)\n>>> even_even_count(-12)\n(2, 2)\n\nThis is basically how the `%` operator works, so in Python:\n>>> %(-12)\n(1, 1)\n>>>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return (str(num).count('*') == 2)\nOdd_count is a better name, IMHO.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    for i in range(num):\n        if i % 2 == 1:\n           yield i, i%2\n         else:\n            yield 0, i\n    return (i, i%2)\n\nIt doesn't use any fancy O(n) stuff, and doesn't use the fact that the number is an integer.\nIt also doesn't use any of the language features of Python, like functional programming, and lexically scoped variables.\nIt's also not an algorithm, since it doesn't perform any computation.\nIt's also not a function, since it doesn't return a value.\nIt's also not a class, since it doesn't have a __call__ method.\n\nIt's also not a sentence, because it lacks a subject, a predicate and a predicate complement.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\n\nI suppose this was in response to this question?\n\nThat was it. \n\nI'm sorry, but I had to comment. My guess is that the reason you were down-voted is not because of the nature of your post, but rather because you only shared half the code. Perhaps in the future you could share the code and then the solution that you derived from the code.\n\nYes, that was my assumption too. I just couldn't be bothered to write it out in full to be honest.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num == 0 || num == 1)\n\nYou seem to have a bug in your code. I tested this on my machine, and it returned 0 on all inputs.\n\nIt's a feature: it only works for even numbers.\n\nThis is the most interesting thing I've seen on HN in a long time. Very well done, and interesting application. I see two things that could be added.\nFirst, it would be interesting to see how many digits can be added before the probability of being even or odd becomes a 1/2 chance of either.\nSecond, it would be interesting to see how the distribution of the number of digits added affects the probability of an even or odd number. For example, does the distribution of the number of digits added to a number that is evenly divisible (ie, evenly divisible by 2, 3, 4, 6, 8, 12, etc...) always remain even or odd? Or does it tend towards a 50/50 chance of being even or odd.\n\n>It's a feature: it only works for even numbers.\n\nThis made me chuckle a bit.\n\nI like how you've phrased the problem here. I also like the brute", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    even_odd_count = lambda num: 2 ** (3 ** num % 2)\n\nThe other option is to use bitwise operations.", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num, even_digits=num.count(1) - num.count(0), odd_digits=num.count(1) + num.count(0))\nThis is what I would have done.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n     def even_even_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n        Example:\n        even_even_count(-12) ==> (1, 1)\n        even_even_count(123) ==> (1, 2)\n    \"\"\"\n\n     return (num[::-1] + 1) * 2\n\nI had a project that required me to write a lot of even/odd counting code, and I settled on this for odd counting.  I could never find a way to get the same level of performance with your solution as I could with mine.  (I had a lot of code that did a lot of stuff with integers and memory, and in the end, I had to go with the faster, less memory efficient method.)\n\nEven/odd counting is such a common problem. I'd be interested in how you did it.\n\nI like to use a for loop:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return num % 2 == 0", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    def even_odd_digits(num):\n    \"\"\"Return a tuple that has the number of even and odd digits in it.\n        Even = 1, Odd = 0\n        Example:\n        even_odd_digits(123) ==> (1, 2)\n    \"\"\"\n    return [num[0] if num[0] in [0,2] else 1 for num in num.split()]\n        def total_digits(num):\n    \"\"\"Return the number of digits in a number.\n        Total = num.split()\n        Example:\n        total_digits(123) ==> 6\n    \"\"\"\n    return [total_digits(num) for num in num.split()]", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[1:] for num in [0, num] if num[1] % 2 == 0 else num[0] for num in [0, num] if num[1] % 2 == 0 else num[1] for num in [1, num]]\n... What? The version that works has an extra comma that doesn't change the semantics at all. Also, I think this could be done with one line of code if you want to use tuples.\nI don't know anything about python, but I could see that first line being a syntax error.  The second line will produce a tuple if the first line is valid, otherwise it will try to use a list.  This prevents the program from doing anything with invalid input.  I think it's also safe to assume that tuples are one-line in python, but I don't know for sure.\n>I think it's also safe to assume that tuples are one-line in python, but I don't know for sure.    They are.  It would be better to just use tuples for everything.  The list syntax is necessary for compatibility with older versions of python, though.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[0] if num[0] % 2 == 1 else num[1] for num in numrange(0, num.maxdigits())]\nthis is the most pythonic solution.  it also means you can do stuff like this:\n\n    even_odd_count(123)\n    if even_odd_count(1234) == 1:\n        print \"all even numbers are palindromes\"\n        print \"all odd numbers are palindromes\"\n    else:\n        print \"both even and odd numbers can be palindromes\"\n> this is the most pythonic solution.  it also means you can do stuff like this:\n\n That is a ridiculous example.\n> this is the most pythonic solution.  it also means you can do stuff like this:\n\n That is a ridiculous example.\n> this is the most pythonic solution.  it also means you can do stuff like this:\n\n That is a ridiculous example.\n> this is the most pythonic solution.  it also means you can do stuff", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num / 2) == 0", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) ** 2", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return tuple(int(num), int(num) - int(num % 2))\n\n    print(even_odd_count(12))\n    print(even_odd_count(123))\nI don't really understand.  What are you trying to do?</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    for i in range(num):\n         if num % i == 0:\n            return i\n    return tuple(num - i for i in range(num) if i % num == 0)\n\nI am not sure what the point of this post is.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    def even_odd_digits(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_digits(-12) ==> (1, 1)\n        even_odd_digits(123) ==> (1, 2)\n    \"\"\"\n    def even_odd_digits(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_digits(-12) ==> (1, 1)\n        even_odd_digits(123) ==> (1, 2)\n    \"\"\"\n    return (num % 2) == 0\n    for i in range(len(num)-1):\n         if num % 2 == 0:\n             # even digit", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return (num.count(1) + num.count(2) + num.count(3)) / 3\n\n    # The three ways of writing the same code\n    def even_odd_count(num):\n    return (num.count(1) + num.count(2) + num.count(3)) / 3\n    def even_odd_count(num):\n    return num.count(1) + num.count(2) + num.count(3)\n    def even_odd_count(num):\n    return (num.count(1) + num.count(2) + num.count(3)) / 3\n    def even_odd_count(num):\n    return num.count(1) + num.count(2) + num.count(3)\n   \n\nPython 2.4 (r77:59033, Oct 2 2003, 09:01:04)\n[GCC 3.3 20030206 (prerelease) (Debian 4.0.3-1)] on linux2\nType", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return (num % 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    \"\"\"\n    count = 0\n    for n in num:\n        if n % 2 == 0:\n            count += 1\n        elif n % 2 == 1:\n            count += 1\n        else:\n            count += 1\n    return (\n          count,\n                 (n / 2)\n         )\n\nOutput:\n\n0 1\n1 2\n2 3\n3 4\n\nEven-Odd number is the number which has an equal amount of odd and even digits.\n\nFor example:\n\nodd_count(123) == 1, because 123 has an odd number of digits\neven_count(123) == 3, because 123 has an even number of digits\n\nHere are some numbers and their even-odd count:\n\nInput", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    for i in range(2, num):\n         return (i*2 if i%2 == 0 else 0) + (num%2)\nThe problem with this is that if you have a negative number, the result will not be a tuple.  There are a few ways to fix it, but since you're just learning Python you should just take the hint that you shouldn't do that.\nThanks for the hint.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\n\nThe _Python_ version of this is:\n>>> def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n      Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n    return (num % 2) + 1\n\nSo, what's the difference?\n\nIt's already explained in the article: Python is whitespace sensitive.\n\nI think what he's trying to ask is, why does Python need a new function just to do this?\n\nBecause it allows for code to be read in a more natural way.\n\nThe syntax is different, but if you are familiar with Ruby, the pattern is very familiar:\nputs(\"Even: #{__even?(5)}, Odd: #{__odd?(5)}\" if odd?(5) else \"\")\n\nThis reminds me of the", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return num == 0? (num - 1) : (num % 2)\nPython doesn't have. or %, so that wouldn't work.  However, you could use `difference`.\nYep, you're right.  Good catch.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    for i in range(num):\n       if i % 2 == 0:\n          return (i+1, i-1)\n    else:\n          return (i-1, i+1)\n\nThe point of this exercise is to give a simple example of a recursive solution to a problem.  It is not intended to provide an efficient solution to the problem.  The code above is an obvious inefficiency and would be a better use of time to rewrite it using a for loop and a loop variable.  However, the example is intended to demonstrate that the function should be recursive.\n\nSee also\n Y-combinator\n\nExternal links\n Y-Combinator\n Y-Combinator at Wikibooks\n Y-Combinator at Scripting.com\n Y-Combinator at DMOZ\n Y-Combinator at eHow</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return [num[1] for num in range(1,num.length-1)]\nI can't figure out why this would work.  Could you explain?\nIt's not very clear, but it's trying to return a tuple of lists, one list of length 1 containing the number 1, and another list of length 2 containing the number 2.\nI see.  It does require a little bit of mental effort.  Thanks.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num.even(), num.odd()]", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    n = num / 2\n    return (n, n-1)\nWhile I agree with the spirit of your post, the code you've given is completely useless. The same code can be written as:       def even_odd_count(num):          return (num % 2, (num - 1))  which is pretty much the same thing. And that's not even counting that, from a practical standpoint, this is just a stupid problem to solve.\nI think you're missing the point of the exercise. It's to illustrate that the same problems don't have to be solved the same way every time.\nI'm not missing the point of the exercise. I'm just pointing out that the example given by the OP is, as I said, useless.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    for i in range(num):\n        if num % i == 0:\n           return tuple(i, 2)\n    return tuple(i, 1)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [(num % 2) + 1 for even in range(num)]\nI'm sorry if this is a stupid question but why is this better than something like this:      def even_odd_count(num):\n    return 1 if num % 2 == 0 else num/2\nThat's not even close to as concise or easy to read as the comment you just gave.\nI was giving a sample implementation of the algorithm described by the above code.  It's not really supposed to be any shorter.  The comment I gave is meant to illustrate that the algorithm is not quite as obvious as it may first appear.\nHehe, yeah, I realize that now.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [x*2 for x in num if x % 2 == 0]\nI love Python.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    result = []\n    #take the number and convert it to a string\n    result.append('0')\n    #find the position of the first digit\n    starting_pos = ord(num)\n    #take the first digit\n    result.append(starting_pos[0])\n    #find the position of the last digit\n    ending_pos = ord(num) - 2\n    #take the last digit\n    result.append(ending_pos[-1])\n    #return tuple with count\n    return '{0:%d,1:%d}'.format(\n    result.count(),\n    starting_pos,\n    ending_pos)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num / 2) + (num % 2)\n\nYou can just use a list comprehension for this:\n[(num % 2) + (num / 2)]  #for nonnegative values\n[(num % 2) + (num/2)]  #for negative values\n\nThis is why I prefer Python.\n\nPython is a lot of fun, but what do you mean?\n\nI don't think Python has a 'for' statement.\n\nIt doesn't. It has a 'for' loop which behaves differently. I was being pedantic by pointing out that this is not the reason Python is better than Perl, but rather a trivial thing that Perl could have.\n\n\"Python is better than Perl.\"\nThat's your personal opinion. I use Perl for all my system administration stuff and I am quite happy with it.\n\nthe sentiment is not uncommon on HN.\n\nI have to admit, I'm still impressed by Python every time I see code like this. It's really concise and elegant.\n\nThat's not really Python's fault though, that's the problem with Perl.\n\nWhat do you mean?\n\nI'm sure there are many,", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [(num.isdigit() & 1) | (num.isdigit() & 2)]", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2)\nThat's not a helpful answer.  Yes, it works but it is not a valid Python program.  It is a list comprehension, and list comprehensions do not execute code.\nAlthough it is true that in this case it is not python code, it is possible to write a program that will evaluate something like this.  For example:      def test(x):           return x == 0                                    return x == 1                               return x == 2  In this case the answer is just 1, but it shows how you can convert a list comprehension to an actual function call.  It is sort of useless to have a function that returns a list comprehension though, but I've seen it done before.\nThe problem with your function is that you are returning the count of odd and even numbers, but this is exactly the same as the", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    result = []\n    for i in range(num):\n        if i % 2 == 0:\n            result.append(1)\n    else:\n            result.append(0)\n    return result\nThis code works fine, but it's not really idiomatic python. In the first loop iteration, you're setting i to 1 instead of 0. Also, the code is inconsistent with the way python handles 0. In the second loop iteration, i is set to 0, which is the expected behavior, but then in the next line, you're setting it to 1 instead.\nI suggest using this instead:\nimport itertools", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    num_even_digits = 0\n    num_odd_digits = 0\n    while num < 2:\n        num_even_digits = num%2\n        num_odd_digits = num%2\n\n    return (num_even_digits, num_odd_digits)\nI don't know what language this is in, but if it's Python, then this would just result in a TypeError.  In Python, strings are immutable, so you can't change them while iterating through them.\nAgreed. Python is a nice language, but when it comes to low-level stuff, it becomes a mess.\nI don't think you can really call Python a low-level language.\nIt's not a low-level language.  I was referring to the `while` loop in the example I replied to.\nActually, it's a decent example of a low-level language.  The `while` loop is exactly the sort of thing that you have to do in C when you're trying to process one character at a time.  It's also the sort", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    for x in range(num):\n        if x % 2 == 0:\n           return (x, x)\n    else:\n          return (x, x + 1)\n    return (x, x + 1)\n\nThis is a variation on a theme of mine from a while back.\n\nFor those curious, this is the same as the Python-to-Python version, except that it generates the \"fizzbuzz\" string, whereas the Python-to-Ruby version generates the \"fizz\" string.\n\nThe following Ruby code will generate the \"fizz\" string, which it does by using the first odd digit, followed by all the even digits:\nodd_even_count(3) ==> \"fizz\"\nodd_even_count(124) ==> \"fizz\"\nodd_even_count(123456789) ==> \"fizz\"\nodd_even_count(-1234) ==> \"fizz\"\nodd_even_count(-1234.0) ==> \"fizz", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    count = 0\n    for i in range(num):\n       if (num % i == 0):\n          count += 1\n    return (count, count % 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return num % 2 == 0\n    and num % 2 == 1\n    and num % 2 == 2\n    and num % 2 == 3\n    and num % 2 == 4\n    and num % 2 == 5\n    and num % 2 == 6", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num.count(0) + num.count(1) + num.count(2) + num.count(3) + num.count(4) + num.count(5) + num.count(6) + num.count(7)) & 1\n\nA problem with this code is that it makes the assumption that an integer is divisible by 2.  That is not true of negative numbers.  If we're going to be consistent, the code would have to check for divisibility by 4, 3, 2, and 1.\n\nYes, that's a problem. In python 2.7 you can use __nonzero__ instead of __divisible__, which works in case of negative numbers.\n\n\"one of the most important features in python\"\nNope, the most important feature is the community and the fact that it is open source, which makes it possible to extend the language to your needs (or write an alternative implementation).\n\nI think the \"one of the\" is warranted. It's not as important as the community, but it is definitely important.\n\nIt's one of the most important features of Python, but it's not even the", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    a = 0\n    for i in range(num):\n        if i % 2 == 0:\n           a = a + 1\n    return (a, a)\nThat's horrible. What if it's a negative number?</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num % 2:\n        return (num % 2) + (num % 2)\n    return (num % 2)\n\nThis is fine if you only ever want to add/subtract 2.\n\nFor all else you can use a function that can be easily extended to handle other cases.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[1] % 2) + (num[2] % 2)\n\n    def divisible(num):\n    \"\"\"Given an integer. returns True if and only if the integer is divisible by 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) == 0 and not num % 2 == 0\n\nTo all the people who thought this was a real programming language:\n\nThis is a fake programming language. It's not even real Ruby code.\n\nIt's certainly real Ruby code, just not idiomatic. For instance, it's a bad idea to do math in strings, but it's perfectly valid.\n\nI'm pretty sure it's fake Ruby code. I'm pretty sure that's a syntax error.\n\nI believe it's fake because of the square brackets.\n\nIsn't Ruby a bit too dynamic to make a joke like this?\n\nMatz claims that Ruby is actually static.\n\nI've heard that claim many times, but I never understood what exactly it means. The fact that you can override methods dynamically makes it much less static than C, and it allows you to create new methods dynamically. The fact that you can do instance_eval at all means that it's not completely static.\nThe only thing that could make it relatively static are its method lookup rules, but I've never heard anyone claim that those were the reason that Ruby is considered static. I think most people who make that claim are thinking of", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[0] if num[0] < 2 else num[0] + 1 for num in range(1, 10)]\nWhat would you expect that to do?\nIt should have returned a tuple with 2 elements. But it didn't.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num%2 for num in range(0, num*2))\nThat's not what I'd call readable. It's not Pythonic either.   It's not very good code even for a one-off.\nCan you write a more readable implementation? I'd like to see it!</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[1:] for num in range(num.value)]\nit is not a very good code but it works for me.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[::-1] + num[::-2]) % 2\nTo me the above code seems a little clearer.\n\nThis is correct. There is no need to allocate memory for a temporary variable.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) == 1\n\nI am pretty sure the intended functionality is actually this:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) * 2", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2 for num in range(1,num))", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return (num % 2) + (num % 3)\n\n    return tuple(even_odd_count(num))", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    #make a function to turn a number into a string\n    #return the string (the number) plus a space followed by a space\n    def space(num):\n        return num + \" \"\n    #if the number is positive, add a space before it\n    def even_odd_count(num):\n        return space(num) + even_odd_count(num-1)\n\nThe `space` function is surprisingly easy to get wrong.\n\nNo, you missed the point.\nThe function takes a number as input and returns a string.\nBut it can be hard to get it right because the function is expected to fail\nwhen the number is something other than an integer.\nFor example:\n>>> space(5)\n'5'\n>>> space(4)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: invalid literal for int() with base 10: '5'\n>>> space(4)\nTraceback (most recent call last):\nFile \"<stdin>\",", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[0] if is_even(num) else num[1] for num in nums if num % 2 == 0 else nums[0])\nAh, but what if the number is irrational, like pi or e?</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num % 2 == 0:\n        return (1, num % 2)\n    else:\n        return (2, num % 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num%2 == 0:\n        return (num, num/2)\n    else:\n        return (num, 1)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num == 0:\n        return tuple(0)\n    else:\n        return tuple(num - 1) + tuple(num)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num % 2 == 0:\n        return (num - 1) / 2\n    else:\n        return sum(even_digits(num)) + sum(odd_digits(num))\n    def even_digits(num):\n    \"\"\"Given an integer, return an array of integers that represent the number of even digits in the number.\n\n        Return:\n            array of integers with the number of even digits in the number.\n         Example:\n                  even_digits(123) ==> (1, 1, 2, 2, 1, 1)\n    \"\"\"\n    num_evens = 0\n    for n in num:\n        num_evens += n % 2\n    return num_evens\n    def odd_digits(num):\n    \"\"\"Given an integer, return an", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return 2, (num % 2)\nThis is kind of dirty, since it has to do integer division by 2 before it returns the sum of the two parts.\n\n    def even_odd_count_2(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively. This is the same as the previous function, but with a more accurate result.\n        Example:\n        even_odd_count_2(-12) ==> (1, 1)\n        even_odd_count_2(123) ==> (1, 2)\n    \"\"\"\n    return 2, (num % 2)\nThis is better than the previous function, since it does integer division by 2 once, but it doesn't work in all cases.\n\nThose two functions fail when the divisor is even. I think a better version would be:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    # manually fix the leading zeros\n    return tuple([str(num).count(str(num)) for str in range(num, 2 + int(num%2))])\nI dunno, I'm always willing to learn new tricks, but I prefer this to the other code. It's a bit easier to read and understand.\n\nOne more:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num == 0:\n        return (1, 0)\n    else:\n        return (num - 1, num)\n\nx = [1, 2, 3, 4, 5, 6]", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple([even_digits(num) for even_digits in num])\n\nThis looks like the right thing to do, but it fails. Here's the output:\n>>> print(even_odd_count(123))\n(1, 2)\n\nHave you tried calling it with -1?\n\nYes, and it says:\n>>> print(even_odd_count(123))\n-1\n>>>\n\nHow about:\n>>> print(even_odd_count(-1))\n(1, 1)\n\nNot sure what you mean by 'won't print the last digit'...\n\nI guess I should've said \"won't print the last character\". If I call the function with a number that has more than 7 characters in the last digit, I get a \"TypeError: invalid literal for int() with base 10: '\\0'\" error.\n\nYour code is not giving the last digit, but the number of digits in the last digit.\n\nThanks. I think I've figured out the problem.\n\nI'm not sure what \"last character\" means in this case. To me, \"last digit\" means \"the digit that comes", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[2] == 0) or (num[3] == 0)\nThis is a prime example of a poor coding habit.\nThis is a prime example of a poor coding habit.  FTFY</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return (num % 2)\n\nThis is the naive solution and it is correct.\n\nThe problem is not really about recursion. A better question is how do you get the correct result, given that you are only told that the result is wrong and the number you are trying to check.\n\nThis is about recursion.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    def find_even_and_odd_digits(num):\n    \"\"\"Given an integer return a tuple with the number of even and odd digits respectively.\n    Example:\n        find_even_and_odd_digits(123) ==> (1, 1, 1)\n    \"\"\"\n    return [(int(num[2]) & 1 for i in range(num[1]) if i%2 == 0] + [(int(num[1]) & 1 for i in range(num[0]) if i%2 == 0]\n\nYou could probably avoid the second function by using a list comprehension:\n\n(list(int(num[2]) & 1 for i in range(num[1])) + (list(int(num[1])))\n\nThe last line of your odd function is unnecessary. You can just use the definition you wrote for the even function:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[2], num[3], num[4]\n            if num[0] > 0 else [num[0], num[2], num[4]]\n            for i in range(num.length-1)]\n\nReminds me of \n\nthis is similar to, which was discussed on HN about a month ago.\n\nThat one's easier to read, but it's missing two of the four even/odd pairs. It also appears to be broken on my machine, because it gives me an error message about the first element not being a number. (Error on a single number is a bug.)\n\nInteresting. Does your machine have a 64-bit processor?\n\nYou could have just returned the total number of digits and let the user do the rest.\n\nI've never really understood the use of tuples for this. I mean, there are a few cases where it makes sense, but this one really doesn't.\n\nI just came across this python function:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    a,b = 0,0\n    d = num % 2\n    return (a+b, d)\n\nThe example of  will give the same result as the example of  (since the numbers 12 and 123 have exactly two even digits and exactly two odd digits). This is nice, but it's not how the article's example is supposed to work.\n\nIndeed, that's what I get with the example in the article too.\nI would suggest that it's because the article's code is wrong, not the one I posted.\n\nThe numbers can't have more than one even digit, so the even and odd numbers are exactly the same.\n\nRight. I figured that out as I was reading the article. I also figured out that I hadn't been reading the article closely enough. I'm going to try again...</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) == 0", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num, len(num) - 1)\nI don't know why you're being downvoted. You didn't present your solution as a replacement for OP's, but instead you offered an alternative that might be more readable, or more intuitive.\nI don't know either, it's not like I was a jerk about it.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return num % 2 == 0 # Checks for odd numbers first\n    or\n    return num % 2 == 1 # Checks for even numbers first", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    number_of_even = 0\n    number_of_odd = 0\n    for i in range(num):\n        if i % 2 == 0:\n            number_of_even += 1\n           number_of_odd += 1\n    return number_of_even, number_of_odd\n\nThe even_odd_count() function computes the number of even and odd digits in a number.  The return value is a tuple, the first member of which is the number of even digits, and the second the number of odd digits.\n\nFor example, the following code prints \"0,0\" because -12 has no even digits:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) & 1\n\n(sorted lists are easy in python, but if you must, google for \"python sort\" and you'll find a nice way to do it in 2 lines of code)\n\nThat's not O(n), it's O(n log n).\n\nHere's a better one, O(n^2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return num % 2", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    def odd_even_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of odd and even digits respectively.\n\n     Example:\n        odd_even_count(123) ==> (1, 2, 3)\n        odd_even_count(456) ==> (1, 4, 5)\"\"\"\n\n    return tuple(odd_even_count(num))", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    def __str__(self):\n    return \"n\"+str(num)+\" \\n\\n\"+str(odd_count(num))+str(even_count(num))\n    if __name__ == \"__main__\":\n        print(even_odd_count(-12))\n        print(even_odd_count(123))\n\nHere's the solution. The first time it is run, the program prints nn1 and nn2, and the next time it prints n1 and n2. The program takes advantage of the following properties of the output of the Python interpreter:\n\n 1. a newline is not output if the string has fewer than three characters.\n 2. a newline is not output if the string has fewer than seven characters.\n 3. the last item is not printed if the string has fewer than four characters.\n\nSo for example, if the number -12 is entered, the string \"nn1\" is output. If the number 123 is entered, the string \"nn2\" is output, because the number 123 has fewer than three characters. The string", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    num = int(num)\n    return tuple(num/2)\nThat's it, but I think you could do it more concisely.\nI have a feeling there are people who don't know how to properly factor a number.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    evens = [1]\n    odds = [1]\n    for i in range(num):\n        if i % 2 == 0:\n            evens.append(i)\n           odds.append(i)\n    return (evens, odds)\n\nIt doesn't always work.\n>>> even_odd_count(-12)\n[1, 1]\n>>> even_odd_count(-12)\nTraceback (most recent call last):\nFile \"C:\\python27\\lib\\site-packages\\python-2.7.3-py2.py\", line 10, in?\nraise ValueError(msg, (value, traceback)\nTraceback (most recent call last):\nFile \"C:\\python27\\lib\\site-packages\\python-2.7.3-py2.py\", line 10, in?\nraise ValueError(msg, (value, traceback)\nValueError: Unsupported operand type(s) for -: 'int' and '", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    a, b = []\n    for n in range(num):\n       if n % 2 == 0:\n          a.append(n)\n          b.append(n%2)\n        else:\n          a.append(n)\n          b.append(n%2)\n    return a, b\n\nIn python, you could just do:\n\nimport itertools", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    def even_odd_count(num):\n    if num == 0:\n       return {0:1}\n    if num == 1:\n       return {0:0}\n    if num == 2:\n       return {1:0}\n    return {1:1}\nThis is another implementation of the same idea, but it uses Python's for loop rather than a while loop, and it returns a tuple, rather than a list.\n\nI'm not sure how the for loop really helps here.\n\nIt allows you to treat the two halves of the problem as two different expressions.\n\nBecause of the way that the increment operator is used to compute the right-hand side of the expression, it's possible for the compiler to optimize it to O(1).\n\nI'm pretty sure I can make it O(1) in C without using a for loop.\n\nUsing C's increment operator you would have to write something like this (I'm not sure how to get it to compile, though):\nint even_odd_count(int num) {", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n     if num == 0:\n         return (1, 1)\n     else:\n         return (2, 1)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    # If the number is odd, return the number of even digits\n    return sum(set(num) for set in num if set[0] == 0)\n    # If the number is even, return the number of odd digits\n    return sum(set(num) for set in num if set[1] == 0)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    num_even = 2  # 2 is the minimum number of digits required for the\n    evens\n    num_odd = 2  # 2 is the minimum number of digits required for the odds\n    # Compute the digit sums for even and odds.\n    total_sum = 0\n    for i in range(0, len(num)):\n        if num[i] % 2 == 0:\n            total_sum += num[i]\n            return total_sum", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (\n           [0] if odd_count(num) == 0 else [1] if even_count(num) == 0 else []\n           for num in nums\n    )\n> def even_odd_count(num):\n> \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n>\n> Example:\n>\n> even_odd_count(-12) ==> (1, 1)\n> even_odd_count(123) ==> (1, 2)\n> \"\"\"\n> return (\n> [0] if odd_count(num) == 0 else [1] if even_count(num) == 0 else []\n> for num in nums\nThat is a very good idea, but it's still wrong.\n>     return (\n>           [0] if odd_count(num) == 0 else [1] if even_count(num) == 0 else []\n>           for", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return (num[1:] + num[0] - 1)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\nThis is a classic example of code that looks simple, but is actually a bit tricky.  The reason is that there are two ways of looking at it, and it depends on your point of view.\nIf you think of it as the sum of the even and odd numbers, then it's clear.  But if you think of it as the number of even and odd numbers, then it's not so clear.  You have to do math with the division operator, which can get pretty hairy.\nThis code is simple, but it's not clear.\n\nYes I agree, that it is a bit tricky to understand, but I don't see that as the main problem of the code snippet.\nThe main problem I have with it is that it is not readable. My first attempt to read that code snippet was a failure. When I read a piece of code, I expect that I should be able to understand what it is doing, in a reasonable amount of time. When I am reading code, I am not looking for how clever the author was to write it in a tricky way. I am looking for a practical solution to a problem, and the code should be written in such", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num % 2 == 0:\n        return tuple(1, num % 2)\n    else:\n        return tuple(num % 2, -num % 2)\n\nSo, if you feed the function negative numbers, it returns the same thing as the `abs` function?</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num[0] for num in range(1, num + 2) if num % 2 == 0]\nI hate the Python syntax.\nYeah, the Python syntax is horrible.  That's why I program in Javascript.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [(num - 1) % 2 for i in range(len(num) - 1)]\nThis can be simplified to the following:       return sum([(num - 1) % 2 for i in range(len(num) - 1)]\nI was thinking about that when I wrote it, but the problem is that with this method, you may get an extra even or odd number when you try to count the number of even and odd numbers in the number.\nAnd yes, this is meant to be pythonic. :)\nThe number of even and odd numbers in a number doesn't change, so you are guaranteed to get the same output.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    n = int(num)\n    return [int(mod(n,2)) for mod in range(2,n)]", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (len(num) % 2, len(num) - 2)\nWouldn't it be easier to just pass in a list?", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [num % 2 for num in range(1, len(num) - 1)]\nThis is so wrong. It's not even funny.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    # split up the number\n    print \"enter a number: \"\n    num = int(input(\"Enter number: \"))\n    n = int(int(num))\n    if n == 0:\n        # n == 0 means the number is all zero\n        return (1, 1)\n    else:\n        return ((n-1)/2, n/2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return (num % 2) + 1 + (num % 4) + (num % 8) + (num % 16) + (num % 32) +\n    (num % 64) + (num % 128)\nI don't understand why it's not (num % 4) + (num % 8) + (num % 16) + (num % 32) +\n(num % 64) + (num % 128). Is there a reason for that, or am I overlooking something?\n\nIf you're using an odd base, it doesn't matter. If you're using an even base, the result is always positive.\n\nThe ternary operator in Python is also known as the \"if else\" statement.\nIt seems like you can't write in Python without using it.\n\nI rarely use the ternary operator, and always find myself regretting it when I do use it.\nI still think it's a good example of a high-level language feature that makes low-level programming more difficult.\n\nI use it, but I'm not a fan.\nI'm with you on the difficulty of low level programming, but I disagree on the ternary", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num:\n        return (num.is_even() + num.is_odd()) & (num.is_even() - num.is_odd())\nThis is a neat way to do it, thanks for the idea!\nCan you tell me the proper way to code this?  How do I use the is_even() & is_odd() functions?  I've looked in the docs but didn't see anything.\nThe module `is_even` and `is_odd` are in the standard library.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    num = int(num)\n    count = 0\n\n    for x in num:\n       if num[x]!= 0:\n          count += 1\n\n    return (num[0], count)\n\nThis is not so much code golf as it is using a common idiom (reduce/fold) in an unusual context.\n\nIt's not entirely clear to me what the \"unusual context\" is. Sure, it's not a good algorithm for this problem, but I wouldn't call it an \"idiom\". What I see is a definition of an algorithm, a single example of its use and an explanation of the example.\n\nThe unusual context is the golfing. A golfed solution is a solution that uses the fewest possible characters. Your solution uses a lot of characters for something that isn't even necessary for the problem.\n\nOK, so golfing is being used as a metric of quality. Sorry, I guess I was thrown off by the initial comment that it wasn't a good algorithm for the problem.\n\nI think you've misunderstood me. I never said it wasn't a", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    even_odd_count = lambda n:\n        (str(n) % 2) + 1\n        - if n % 2 == 0:\n             return (n)\n        else:\n            return (n - 1)\n\n    print(even_odd_count(12))\n    print(even_odd_count(123))", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num[0] + num[1]) % 2\nThat's a really ugly way to do it.  The wikipedia page for \"odd\" and \"even\" states:  > For integers k and n, an integer x is odd if x is divisible by k\u00a0+\u00a01; otherwise, x is even.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num & 0x7F) | (num >> 8)\nCan someone explain the above? I've been looking at it for about 10 minutes and I don't understand it.\nIt's \"get the even numbers as a tuple, and the odd numbers as a tuple\".  The & 0x7F & (num >> 8) is a bit mask to test for the evenness of numbers.\nI see. I'm not used to bitwise operations and that was throwing me off. Thanks.\nIt's not really a bitwise operation. The number is being turned into an unsigned integer, so the result is essentially \"is the number even or odd?\".  In this case the result is 0 for even, 1 for odd.\nYeah, I've since figured that out. It was more of a matter of me not being familiar with the syntax.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(int(num), int(num) - 1)\nI think the point of this exercise is to write it without using the built-in type functions.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple([str(num) for _ in range(num) if num % 2 == 0])\n\nThe + and - operators are bitwise in python. The bitwise logical AND of -12 with -12 is 12.\nSo -12 and 12 are equal, which is false for the if statement. You have to use the python operator - for bitwise negation.\n\nthanks i will try it\n\nWhen writing code to work with money, it's usually good to use exact numbers.\nYou've written the following:\n>>> even_odd_count(-12) ==> (1, 1)\nWhen you have a negative number, it should always be interpreted as a signed number. If I enter\n>>> even_odd_count(-12) ==> (1, 2)\nI get a ValueError.\n\ntotally correct, we should always use exact numbers but in this problem I'm not storing or anything i am only comparing if the number is even or odd. But i will update that.\n\nYou're storing the output of a comparison operation. You're also, if I remember correctly, using Python 2, which uses 2's complement for signed numbers.\n\nyou are", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    def count(s):\n        return [s[0], s[1:] if s[0] % 2 else s[0], s[2:] if s[1] % 2 else s[1:] for s in s.split()]\n    return [count(num) for num in num % 2]", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num == 0:\n       return (0, 1)\n    return (num - 1, num)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    try:\n       return (sum(int(num)) for int(num) in even_odd_count(num))\n    except:\n       return (0, 0)\nAww, the first example didn't work for me. :(</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    def count_even_digits(num):\n    return num % 2\n    def count_odd_digits(num):\n    return num % 3\n    return (count_even_digits, count_odd_digits)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    \"\"\"This is probably the best way to do this. In python 3.0 this was\n    made considerably easier by the introduction of the function\n    range.range(min, max, step = 0.5). It is a really nifty function.\n    \"\"\"\n    if num < 2:\n        return (1, 1)\n    else:\n        return (odd_count(num), num)\n\nThis might work for integers, but it fails for floating point numbers. Here is my solution:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return tuple(num % 2, num % 2)\nThis is Python, you can just do `return [num % 2 for num in range(2)]`.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    for i in range(num):\n         if i % 2 == 1:\n             return i * 2 + 1\n    return [i for i in range(num) if i % 2 == 1]\n\nThe \"while\" loop isn't needed if you're using Python 2.x, since Python 2.x has a built-in list comprehension.\n\nBut it's in Python 3.\n\nIt is? Huh, I guess I never noticed.\n\nI like to think that, at least for the cases where it's not completely obvious, code should be clear enough to work for more than one implementation of the language.\n\nI agree with you. This is why I always use 'x' and 'y' for names of variables, not 'x' and 'y'. Just in case I ever switch to a language that uses 'y' and 'z'.\n\nI like this little trick I learned, which makes the loop comprehensible and a little faster:\nfor i in range(n):", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [0,1]\nHaha, yeah. That's what it does.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    \"\"\"i = 0\n    while i < num:\n        i = i + 2\n        if i % 2 == 0:\n           return [(i, i)]\n        elif i % 2 == 1:\n           return [(i-1, i-1)]\n    \"\"\"\n\nI think this would be a bit clearer as:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (int(num) - int(num % 2)) * 2\nThe first statement should read:       return (int(num) - int(num % 2))</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2 for _ in range(num - 1))\n\nThat's so bad it's not even wrong.\n\nThat's my point. The author of the article had obviously never heard of xrange, but thought the logic was sound.\n\nIt's not obvious to me at all that the author had never heard of xrange. His code was ridiculously trivial and it's not clear why he would even need to use it. (Where's the rest of the program?) I'm pretty sure he just didn't think to use it.\n\nA little bit more helpful version of the above:", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    # concatenate the numbers\n    even_odd_digits = []\n    # look for a pattern of numbers in each half\n    even_count = 0\n    odd_count = 0\n    # keep track of how many of each kind we've seen\n    even_count_prev = 0\n    odd_count_prev = 0\n    # keep track of the current digit we're looking at\n    digit_to_look_at = 0\n    # if the current digit is even, add one\n    if current_digit % 2 == 0:\n        even_count = even_count_prev + 1\n    # if the current digit is odd, add one\n    else:\n        odd_count = odd_count_prev + 1\n    # if the current digit is even, add one\n    if current_digit % 2 == 0:\n        odd_count = odd_count_prev + 1\n    #", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\n\nPython has this builtin, with a different return type:\n>>> from itertools import islice\n>>> islice(12, 2)\n(1, 1)\n>>> islice(123, 2)\n(1, 2)\n\nIf anyone else doesn't know what islice does, it returns the first two elements of a list in sorted order.\n\nC# has it too:\nint count = (int)((int)Math.Floor(Math.Floor(a / 2), 2));\n\nFor a more approachable definition of floor(), see\n\nThat's not a more approachable definition of floor, it's a more approachable definition of the floor function that floor is defined to. It's not a different definition of floor.\n\nWhat's wrong with just using floor?\nint num = floor(num / 2);\n\nYou can't do that for negative numbers, so you would have to write a more complicated function to handle negative numbers.\n\nWhy would you want to do that for negative numbers?\n\nBecause sometimes you'd like to count the number of even-divisible numbers", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return 2*(str(num)[::-1]) + 1\nI would have named it `count_even_odd` instead.\nThat's a good name, too!</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num / 2 ** (num % 2)) % 2\nThis is a better way of doing it, if you want to understand the operation.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    num = int(num)\n    return tuple(\n        [num[2] if num[0]==0 else num[0]*2 for num in range(2, num.digits+1)]\n    )", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num == 0:\n        return (1, 1)\n    elif num == 1:\n        return (2, 2)\n    elif num == 2:\n        return (1, 2)\n    elif num == 3:\n        return (1, 2, 1)\n    elif num == 4:\n        return (2, 2, 1)\n    elif num == 5:\n        return (2, 2, 1, 0)\n    elif num == 6:\n        return (1, 1, 2, 1, 0)\n    elif num == 7:\n        return (1, 1, 2, 1, 0, 0)\n    elif num == 8:\n        return (1, 1, 2, 1, 0, 0, 0)\n    elif num == 9", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return (num % 2) + (num % 2)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    \"\"\" # return tuple of (even, odd) digits\n    def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n\n    \"\"\" # return tuple of (even, odd) digits\n    def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\"\n\n    \"\"\" # return tuple of (even, odd) digits\n    def even_odd_count(num):\n    \"\"\"Given an integer. return", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    if num == 0:\n         return [1, 0]\n    if num > 0:\n         return [(num % 2), 0]\n    else:\n         return [(num % 2), 1]\n\nDon't forget about the 11 and 12 case.\n\nYou are right! Adding that case is so easy I'm ashamed of myself.\n\nI'm ashamed of you as well. How are you going to let that ugly little bug in your code get by you. I'm ashamed of you.</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n\"\"\"Start counting from the first odd number.", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return [int(num % 2) for num in range(num, num + 1)]\nA much simpler solution, which gets to the heart of the problem, is:       def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n     a = int(num)\n     return [a[0:2], a[3:] for a in range(num)]\nCan you explain why this is better than the stdlib's _even_?\nit doesn't use the `int` function, so it's a little faster</s>", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2 == 0) and (num % 3 == 0)", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n\n    return (num % 2) + 1", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    return (num % 2) + 1\nThis is a neat solution. It's obvious, but it's also concise and straightforward.\nHow would you write this in Python?  I don't know Python well enough to do it in my head, but I suspect it involves some set operations.\nI don't know python very well either, but I believe this is correct:\n\n    def even_odd_count(num):\n       return num / 2", "def even_odd_count(num):\n    \"\"\"Given an integer. return a tuple that has the number of even and odd digits respectively.\n\n     Example:\n        even_odd_count(-12) ==> (1, 1)\n        even_odd_count(123) ==> (1, 2)\n    \"\"\" \"\"\"\n    count = 0\n    if num == 0:\n        return (0, 0)\n    count = count + 1\n    return (count % 2, count % 2)"]]