[["from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    for i in strings:\n        return Optional(i[0])\n    return None</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) < 3:\n        return None\n    for s in strings:\n        if s not in 'a'...'z':\n            return s\n    if len(s) == len(strings):\n        return None\n    return len(s)\n\nfrom typing import List, Optional\n\n    def longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    if len(strings) < 3:\n        return None", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    longest(strings.pop()) if strings.size == 1 else None\n\nThat's not the same as the article. The article is about the lack of \"import *\" in Python.\n\nI don't think the article is really about imports, at all. It's about having a single module, and not having to worry about an entire class of bugs.\nThere's no reason you couldn't do this in Python, but you'd need to make sure your module was never imported more than once, as you can't import a module more than once.\n\n\"import *\" _is_ about imports. I understand that the blog post was about the benefits of duck typing and how it might result in fewer bugs. But you can't have a discussion about imports without talking about imports. If I write a program with \"import *\" and later need to change the name of some function, I have to change all uses of the function. If I had instead imported a module with \"from foo import bar\", then I would only have to change one occurrence of the name. I would say that this results in fewer bugs, but maybe the author of the blog post prefers to work in a different way.\n\nWhen I see", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings == [] or len(strings) == 0:\n        return None\n    if len(strings) < 2:\n        return len(strings)-1\n    return strings[0] if strings else None\n\nFrom the PEP:\nThe optional type is intended to be used in cases where you have a value that might be missing, but that you want to avoid exceptions and/or the need to check the value of the value for each use. For example, you might have a function that takes a parameter of type Optional[A]. The parameter might be missing, but the function will still work as intended.\nThe idea is that you will use the optional type when the return value is something you will usually want to have, but that you will sometimes want to avoid having.\n\nAnd if you're using optional you should know about the following Pythonic shorthand:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    list_of = []\n    for s in strings:\n        if len(s) > 0 and s[0] == 'a':\n            return s\n        list_of.append(s)\n        longest(list_of)\n\nYou can also do it using only built-in functions, and no special type annotations:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    for item in strings:\n        if len(item) == 1:\n           return item\n         if len(item) == 2:\n            return None\n         return longest(item)\n         return None", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n        return None\n    return strings[0]", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n       return strings[0]\n    return Optional(strings.pop(0))\n\nI guess the problem with this one is that there's no way to remove the None at the end if you don't want it.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    for s in strings:\n       longest(s) = s\n    if len(s) == len(strings):\n       return None\n\nNow what happens when the function gets the following input:\nlongest([])\nWhich is the empty list? Is it None or is it None?\nThe Python interpreter runs into a \"TypeError\" exception and you get the following stack trace:\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'NoneType' object is not iterable\n\nIt's not surprising that it's not iterable.\n\nMy point is that the type of the input is not List, but Optional[str], i.e. the function is expected to return None, and not raise an exception.\n\nHow is that related to the question?\n\nThe question is asking for the type of the longest function, which returns an Optional[str], not a List.\n\nI believe that a better version of this type signature would be:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    out = []\n    i, j = 0, len(strings)\n    while strings:\n        for s in strings:\n           if len(s) == j and len(s) == i:\n                break\n                   else:\n                                out.append(s)\n                                   i += 1\n    return out\n\nSo, what does the optional type add to this code? It can't be that much.\nThis seems like a very interesting example, but the article doesn't explain much about it.\n\nIt's an example of type safety. By defining your own type and using it as the argument to the function, you are able to", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings == []:\n        return None\n    for string in strings:\n        if string[0] == 'a':\n           return string\n        else:\n            if string[0] == 'b':\n                return string[1]\n         else:\n                return None\n\nimport collections", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n       return strings[0]\n    else:\n       longest_common = longest(strings)\n       if longest_common is not None:\n         return longest_common\n    else:\n        return None\n\nSee also: \n\n_foo is in the standard library, which makes it easier to pick up.\n\nIn the same vein, I suggest you check out:\n\nI have to say that I'm pleasantly surprised that I didn't have to use a lot of those methods. Granted, I've only used Python for a few months, but I'm still pleased.\n\nI guess this is a fun little exercise, but I think it's a stretch to say that these methods are particularly \"Pythonic\". A lot of these methods have equivalents in Java or C# (though I'm not sure about the last one, I guess it's pretty close to the String.IndexOf method).\nI'm still waiting for someone to come up with a great one-liner using the `pass` function", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n       return strings[0]\n    else:\n       return Optional(strings[0])\n\nPython has a _built-in_ function for that:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    for s in strings:\n        if len(s) == len(strings):\n           return s\n    return None\n\nWhat exactly is the use case for this? I don't think you can do anything with Optional[str] that you couldn't do with a list of str.\n\nI think they're mostly useful for (still experimental) coroutines:\nThe first example in that page is:\nx = coroutine.yield(some_function())\nx.await()\nx.yield(some_other_function())\nI think it's a little easier to write and read than the equivalent x = coroutine.Yield(some_function()) x.await() x.Yield(some_other_function())\n\nOk, I guess that makes sense. I've never really used coroutines in python.\n\nIt's also useful for generators.\nYou can't yield from a generator, but you can wrap a generator in an optional. Then you can yield from the optional:\n>>> list = list(range(10)) >>> list(Optional(list(range", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings: length == 1: return 'a'\n    if strings: length > 1:\n       return 'b'\n    else:\n       return Optional[len(strings)]\n\nSo, this is a method to get the longest string, but it only works with a single string.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return longest_one(strings)\n\nfrom typing import OrderedDict", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings:\n       return strings[0]\n    else:\n       return None</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings: List[str] == [] or strings: List[str] == None:\n    return None\n    len = len(strings)\n    if len > 1:\n       if strings[0] == str:\n          return str\n       else:\n          return longest(strings[1:])\n\nI'm not sure if the author knows what \"Optional\" means.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings == []:\n       return None\n    longest_s = 0\n    return longest(strings[1]) if strings else longest_s\n\nthe article is a link to:</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n        return None\n    longest_string = {}\n    for i in strings:\n        if len(strings[i]) == 0:\n           longest_string[i] = strings[i]\n           if len(strings) > 1:\n              longest_string.add(strings[-1])\n    return longest_string\n\nI'd like to have a shorter example.\n\nI like to have code that's easy to read and understand, and I think this is an example of that.\n\nthis is the _opposite_ of easy to read and understand.\nit's verbose, it's tautological, it's unnecessarily repetitive, and it's not at all intuitive.\nit's a great example of what not to do.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    longest = lambda s: len(s)\n    if len(s) == 1:\n       return s\n    else:\n       return None\n\n    return longest(strings)\n\n    print(longest('abccc'))\n    print(longest('abcabc'))\n\nfrom typing import List, Optional", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return strings.pop()\n\nPythonistas and other language lovers, what's the benefit of this style over the usual", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return len(strings)\n\nHow about using the built-in __len__?</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    out = [x for x in strings if len(x) > len(strings)]\n    return out.get(0)", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\n    if strings:\n        return Optional(strings.get(0))\n    return None\n\n    def best_of_lengths(s: List[str], k: int):\n        \"\"\"\n          Given a list of strings, return the longest string of the given length. Return\n          None in case there is not enough information available.\n          >>> best_of_lengths([1, 2, 3], 1)\n\n           >>> best_of_lengths(['abc', 'def', 'ghi', 'ijkl','mno', 'pqr', 'rrrs'], 2)\n           >>> best_of_lengths(['abc', 'def', 'ghi', 'ijkl','mno', 'pqr', 'rrrs'], 3)\n           >>> best_of_lengths(['abc', 'def',", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) < 1:\n       return None\n    # Return the longest string, which is the first in this case\n    return strings[0]\n\nI do not understand why it is possible to return None or [0] in this case. The function is supposed to return the longest string.\n\nThe point is not the code, but the thought process. The code is a cute illustration.\n\nI don't think it's a good illustration. The type of the function is\n\"longest(strings: List[str]) -> Optional[str]\".\nThe function's type signature says it must return a string, and it's supposed to return the longest one. I don't think it's a good idea to return None in this case, and I don't think it's a good idea to return [0] in this case either. The function should return one of the strings, or None, if there is no longest string.\n\n\"a string\" vs. \"the longest string\" is a contrived distinction. The code is a cute illustration of the problems that come with type systems that don't let you return None.\n\nIt", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings:\n        return None\n    len = 0\n    for s in strings:\n        len += s.length()\n    return len == len(strings) or len(strings) > len(strings[-1])\n\nOf course, you can always go even further with functions like this:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return sum([len(x) for x in strings if len(x) > 0])", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) < 2:\n        return None\n        return strings[0]\n\nNot sure if you are trolling or just don't understand python lists.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n       return None\n    for i, string in enumerate(strings):\n       if string == None:\n          return None\n          return string\n\nThis is not really a Pythonic way of doing it.\nYou can create a list with your three strings and return the first one.\nThis is usually the idiomatic way of doing it:\n>>> longest('a', 'b', 'c')\n'a'\n>>> longest(['a', 'bb', 'ccc'])\n'ccc'\n\nSorry if it's not a pythonic way of doing it, but I really like the feature of returning None in the case of an empty list.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return longest(strings) if strings else None\n\nfrom typing import List, Optional", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return Optional(len(strings)-1)\nNice! Can we have a version that returns the longest string *that is also present*?</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    longest_sum = 0\n    for s in strings:\n       longest_sum += len(s)\n    if longest_sum >= len(strings):\n       return None\n    return len(longest_sum)\n\nfor item in list:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\n    return sorted(strings, key=lambda item: len(item))", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n        return str\n    if strings:\n         return None\n    longest = []\n    for i in strings:\n         if len(strings[i]) == len(longest):\n            longest.append(strings[i])\n            return longest\n    return None\n\nSo... it's syntactic sugar for a function that already exists?\n>>> from collections import OrderedDict >>> longest('a', 'a')\n'a' >>> longest('a', 'a')\n'a' >>> longest('a', 'b')\nNone\n\nYeah, I'm not sure why that's on the front page.\n\nBecause it's a humorous observation of how Python imports are often used. It's also a good illustration of how you can use an optional type to enforce the return of the first element when the list is empty.\n\nBecause it's a humorous observation of how Python imports are often used. It's also", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return len(strings) > 0\n\nThis is a fairly common pattern, but it's worth pointing out that it's not idiomatically idiomatic.\n\nThe idiom would be", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n       return None\n    longest = [x for x in strings if x[1] > x[0]]\n    return longest.get(0)\n\nYou could improve this by using a dictionary.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    longest_len = len(strings)\n\n    if strings[0] == '_':\n        return None\n    for s in strings:\n        longest_len = len(s)\n        if s.rstrip() == '_' and longest_len == len(s):\n           return s\n           return longest_len\n\nSeems like a no-op to me - both _len() and _.rstrip() are O(1).\n\nMy thought exactly. What's the point?\n\nI would have preferred to see an explanation of what makes this \"clever\".\n\nI'm pretty sure it's because Python only has the \"len\" method, so this way you can use any string-based function you want to find the longest string.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return len(strings).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0).get(0)\n\nThe author may consider renaming to shortest.\n\n...or should that be shortestest?\n\nI would think that shortestest would be the shortest of the shortest.\n\nThe shortestest (which is obviously the shortestest) would be the shortest, since the shortest can only be one character.\n\nAha. I like the way you think!\n\nI think it's easier to understand with this in mind:\nshortest is the shortest of the shortest, not the shortest of all strings.\n\nI think that's a matter of perspective. To some, shortest means shortest of all strings. To others, it means shortest of the shortest.\n\nHaha, yeah. That's why you have to specify it.\n\nI wonder if this will replace the standard built-in function len, which always returns a tuple.\n\nIf you use this, you're essentially wrapping each of the string", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    for s in strings:\n       if len(s) > 1:\n         return Optional(s)\n    else:\n         return None\n\nNo, if the list is empty, then this will _not_ return None.\nYou'll need to add a newline:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) > 1:\n        longest_string = strings[0]\n        return longest_string\n    else:\n        return None\n\nI'm not sure what is so important about this. It seems like a useless function to me.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    val longest = getattr(List, 'longest')\n\n    return longest(strings)\n\nWhy not use Enum.findLongest()?\n\n_Why not use Enum._\nList.findLongest() does what Enum.findLongest does, but with a more flexible type.\n\nNeat. I like it a lot more than Python's builtin function.\n\nI don't see the benefit of it being a function. I've never had to pass it as a function, only as an argument.\n\nI guess that's a matter of preference.\nTo me, a function is more easily understood, compared to a Python builtin or C++ template. Also, it's more flexible, since it can be applied to arbitrary data structures, such as Lists, Sets, Sets of Sets, and so on.\n\nExactly. Sometimes, you can't fit everything you want into the type, and it's nice to be able to say, \"okay, it's a List of these things, so I'll just use 'findLongest'\".\n\nWow, I have been doing this in Ruby for years... I never knew it was possible in python!", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n        return None\n    return longest(strings[0])\n\nIs there a reason you'd do this as a function instead of a method? In the vast majority of cases, you'd have to provide a docstring anyway, and an actual method would be more explicit about what it does.\n\nI just wrote that to get the gist of it.\n\nI would probably have written that as", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    l = len(strings)\n    for s in strings:\n       if s.startswith('A'):\n          return s\n       elif s.startswith('B'):\n          return s\n       else:\n          return None\n\nOptional[str] is a type error, right?\n\nYes, it is.\n\nIt's still an interesting example of how to do typing in Python (and I don't mean dynamic typing). I wonder if there's a way to turn it into a non-type error in Python 2.x?</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n       return None\n    return strings.index(None)</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    result: None\n    for string in strings:\n        result = len(string)\n        if result == len(strings):\n            return None\n    if result is not None:\n            return result\n\nThis is a cool trick, but why? It seems like you're doing a lot of work to produce something you could do with a single line of code.\n\nThe \"trick\" is to be able to produce a well-typed, type-safe, functional, and efficient list without writing much code. That's a big win.\n\nA list comprehension would be a big win.\n\nWhy would you use list comprehension here? The only thing you're trying to do is find the longest string.\n\nbecause list comprehension can be written in one line of code.\n\nOh, right. I forgot to type the line that was necessary to get a well-typed, type-safe, functional, and efficient list.\n\nFor some reason that I haven't been able to figure out, list comprehensions", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings:\n       return strings.head()\n    else:\n       return Optional(strings.pop(0))\n\nI don't know about python but in ruby you can do this:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return len(strings) == len(strings[0])\n\nWhat is the point of the return type \"List[str]\"?\n\nBecause there's nothing in the language that stops me from doing that.\n\nThe question was why you are returning a List, not why you are returning something.\n\n\"List[str]\" is an interesting type, because it means that the list can contain str objects, but also items of other types that can be coerced to str (like \"int\"s).\nI guess there are situations where that matters.\n\nWell, you can coerce an int to a string too.\n\nYou're just asking for a return type of \"list\", where list is a generic list type that can be instantiated to a list of ints, strings, whatever.\n\nWell, there is a type called list that is a list of any type.\n\nI don't understand the point of the first line.\nimport typing\nimport lists\n\ntyping is not a keyword in python.\n\nI don't understand the point of the first line.\nimport typing\nimport lists\n\ntyping is not a keyword in python.\n\nYeah, I think it", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return len(strings) > 0\n\nI like the def syntax better than the from syntax for this. (I think the def syntax is ugly too.)\n\nI like the def syntax better than the from syntax for all cases except the few that the from syntax is meant to fix.\n\nI'm not sure I get the reason for the def syntax. How does it differ from the from syntax? I see that you can return None with def, but it's hardly a compelling argument.\n\nBecause in the case of calling a function, you could have a case where you don't want to bother with the optional argument. In the case of a function definition you can just remove it.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    strings = strings.sort()\n    return longest(strings)\nThis can't work:\n>>> longest([])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: list index is out of bounds\n>>> longest(['a', 'b', 'c'])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: list index is out of bounds\n>>> longest(['a', 'bb', 'ccc'])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: list index is out of bounds\n\nIt's not a typo, it's an early draft of the code. You can see that from the fact that it's called \"longest\" rather than \"findLongest\" or something.\n\nI don't see anything wrong with my code.\n\nThis is a joke, right?\n\nWhy would it be a joke?\n\nBecause the code is broken and it's just being pointed out.\n\nYour code doesn't compile,", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings:\n        return None\n    longest = []\n\n    for s in strings:\n        longest.append(s)\n\n    return longest.get(0)\n\nThat's not really a Pythonic way of doing it.\nYou can use this:\nfrom typing import List, Optional\nlongest = lambda s: len(s) if len(s): return s if s == '': return None\n\nThat's not pythonic either. The longest() method already does the len() check for you and returns the first one that satisfies the condition. You can leave it out and it will do the right thing.\n\nI disagree.\nLongest() is a method. You can't call it without an argument.\nHow would you implement your lambda in that case?\n\nWith a lambda.\n\nLongest() is a method. You can't call it without an argument.\nHow would you implement your lambda in that case?\n\nI don't know how to call a method without an argument?\nIf you mean how would you implement the lambda:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n       return None\n    def longest_in_list(string_list: List[str], len: int, start: str):\n    \"\"\" Return the longest string in the list. Return None if the list is empty.\n    >>> longest_in_list([], 2, 'a')\n    'a'\n    >>> longest_in_list(['a', 'b', 'c'], 3, 'b')\n    'c'\n    \"\"\"\n    return longest(strings, len)", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    l = strings\n    if len(l) == 0:\n       return None\n    longest = []\n    for i in range(len(l) - 1, 0, -1):\n       if l[i] == l[-1]:\n          l[i] = l[-1]\n          longest.append(l[i])\n    return longest\n\nIf I were going to use this, I would write:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return len(strings) > 0\n\nI don't think this code is meant to be taken literally, rather it is a parable about what type of people you should avoid in real life.\n\nIt is like in a old book about the bible in Israel: the bible was the first software written in a distant land and most of the programming language of the time was different.\nSo you have things like:\nIn the beginning, the Lord created the heaven and the earth.\nAnd on the first day, he created the heaven and the earth.\nAnd on the second day, he created the heaven and the earth.\nAnd on the third day, he created the heaven and the earth.\nAnd on the fourth day, he created the heaven and the earth.\nAnd on the fifth day, he created the heaven and the earth.\nAnd on the sixth day, he created the heaven and the earth.\nAnd on the seventh day, he created the heaven and the earth.\nAnd on the eighth day, he rested.\n\nFrom the first day of the creation, there is a rest of one day.\n\nThat's an infinite loop, surely?\n\nThe funny thing is, this is a", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return strings.index(strings.remove(0))\n\nI know people have their own ways of doing things, but that is the most absurd thing I've seen in a while.\n\nI've never seen the \"from typing import List, Optional\" convention before.\n\nSeen it before. It's common to see in Python code.\n\nThe problem is, its unnecessary in Python. Every object has a length property, and you can get a list's length as a list comprehension:\nlengths = [x.__len__ for x in my_list]\n\nThere are a couple things to note about that:\n1) The length property of a list is not necessarily the same length as the length of its contents.\n2) Lengths will return a list, not a single integer.\n3) If you are doing something like counting the number of times a word appears in a document, you probably don't want to generate the entire document each time you need the length.\n\nI'd rather use a dictionary than a list here, since it makes the function more flexible.\nlengs = {0: len(a) for a in l}\n\nI'd rather use a", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return len(strings)\n\nSo you're getting downvoted because you wrote two lines of code, but they are wrong?\n\nNo, I'm getting downvoted because of a typo. I'll edit it. Thanks for pointing it out.\n\nI am also getting downvoted because of a typo.\n\nYou could have edited your post.\n\nHere's another one:\nfrom itertools import islice, groupby, permutations", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    for s in strings:\n        if len(s) > len(strings):\n           return s\n    return None\n\nThe point being that if you know what you're doing, you don't have to import modules you don't need (like typing) and it makes your code easier to read and maintain.\n\nYou need the typing module for the built in types, so I'm not sure what the point is here. You might as well say that you don't need to import string in a Python program.\n\nI agree. The list type is a builtin type in python, which the optional type is not.\nIn a language with multiple types (like Java or C#), you would have a separate type for lists, tuples, maps, etc. In python, all of these are built into the language.\n\nIf you don't know what your doing, you're going to have a hard time reading any code, as there are a large number of things you don't know.\nI don't see any reason to not import optional. If it's a common enough use case, it's easier to import it", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    sorted = [0]\n    for string in strings:\n        if string in sorted:\n            return sorted[string]\n    if len(sorted) == 0:\n            return None", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\n    if len(strings) == 0:\n        return None\n    else:\n        longest(strings[0])\n\n... What?\n\nSurely the title should be \"from typing import optional\"?</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n        return None\n    return strings[0]\n\n>>> longest(['a', 'b', 'c'])\n'a'\n>>> longest(['a', 'bb', 'ccc'])\n'ccc'\n>>> longest([])\n>>> longest([])\nNone\n\nNice</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    longest_match = {k: v for k, v in zip(strings, strings) if v > k}\n\n    if len(longest_match) == 0:\n        return None\n    else:\n        return longest_match[0]\n\nThe only thing I like better in Python is that you can use lambdas to make the function more terse:\n>>> longest( [], None ) == None True\n>>> longest( 'a', [ 'a', 'bb', 'ccc' ] ) == 'ccc' True\n>>> longest( [ 'a', 'bb', 'ccc' ], None ) == None True\n>>> longest( 'a', 'bb', 'ccc' ) == 'ccc' False\n\nI personally don't like it for python because it doesn't read at a glance (at least to me) and it is a good bit longer.\nFor some things, I love using lambdas in Python and really wish they could be used in other languages without having to compile to c/c++.\n\nI don't think it's the terse aspect", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    for i in strings:\n        if longest(i):\n          return i\n    return None\n\nI like this one. \n\nNeat.\n\nThis is really neat!\n\nlooks really cool\n\nNice!\n\nawesome</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return strings.get(0).get()\n\nYou can always use the String type as a fallback:\nfrom typing import List, Optional", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings == []:\n        return None\n    longest = []\n    for string in strings:\n        if longest == None and longest[string]!= None:\n            longest.append(string)\n    return longest\n\nThat is a really nice one. I think I will use it as a go-to example of how to implement Optional in Python.\n\nIt is funny because I was really annoyed when I saw the original post (because I had seen it before) until I saw this comment and re-read the post.\nI think my biggest issue with the post is that is uses the word 'longest' as a function and not a description of what the function returns. If the function returned 'a', it would still be called longest.\n\nWhat's the big deal? He's not the first and won't be the last to call a function to describe the results.\n\nDon't get me wrong, it is still a nice example. I just think there is a better example out there.\n\nTo be fair, though, he's making a", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n        return string\n    elif len(strings) == 2:\n        return string[0]\n    elif len(strings) == 3:\n        return string[1]\n    elif len(strings) == 4:\n        return string[2]\n    else:\n        return None\n\nI must be missing something. It is a nice, minimal and probably useful function. What is wrong with it?\n\nThe input could have been a list of any length. The only case it handles is the empty list.\nIt could have been written like this:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) > 1:\n        longest(strings[0])\n    return Optional(None)\n\nThis is a case where you can be both syntactic and sematic correct.\n\nI'm not sure I understand what you're saying. Do you mean that the problem is not a problem because one can solve it either way?\nI would say that this is exactly the kind of problem where you _can't_ solve it either way. To illustrate, look at this function:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings.size == 1:\n       return strings[0]\n    else:\n       return strings.pop(0)\n\nThe fact that your \"if strings.size == 1:\" condition is checked at the end makes your code pretty slow.\n\nI'm not sure I follow you. Isn't it called \"shortest\" because it returns the first?\n\nI think the other commenters were thinking about this:\n>>> longest([])\n[None]\n>>> longest(['a', 'b', 'c'])\n'a'\n...where in the general case you'd want to take the last element:\n>>> longest([])\n[None]\n>>> longest(['a', 'bb', 'ccc'])\n'ccc'\n\nIt's a trade off between time and memory. If the empty string is the last in the list then it's fast but requires more memory. If the empty string is the first in the list then it's slower but requires less memory.\n\nI haven't looked at the implementation but my guess is that it just iterates over the list once, so the memory usage is constant", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n       return len(strings)\n   \n\nPretty sure you can just do that:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return len(strings) > 0\n\nI love Python.\n\nPython's built-in comprehensions, while great, aren't nearly as powerful as Lisp's.\n\nIn particular, lists and comprehensions in Python don't support arbitrarily complex types as values.\n\nPython isn't as good as LISP in that respect but it is still a nice language to work with.\n\nI'm not saying it's not a nice language. The fact that it's a nice language and that it is used in so many different contexts is a testament to how well it is designed.\nPython's type system is weak because it makes it easy to mix object and functional programming styles. But this is a matter of trade-off. For instance, I've not seen any language that lets you write code like this:\nfor i in xrange(0,99):\nyield i+1\n\nYou can do that in perl, for example:\nfor (1..99) {", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    list_of = ['a', 'b', 'c']\n    longest = {}\n    for s in strings:\n        if s.startswith('a'):\n              longest[0] = s\n              return None\n    if list_of:\n              return longest.get(0)\n    return None\n\nOn further consideration, this doesn't seem to be particularly useful.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings is not None:\n        return strings.get(0).length()\n    return None\n\nFrom the description, it seems like `Optional` is just a wrapper around `str` to make a string optional.\n\nYou could use this with list comprehensions to make a list of all strings in a list optional.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n       return None\n       return strings[0]\n\nIt's great to have optional types in Python, but this implementation is a bit misleading. It is completely safe for optional types to have more than one possible return value.\nFor example, take the following code:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings: List[str] is not None:\n       return longest(strings)\n    return None\n\nThis is the correct answer.\n\nVery nice. I also made a toy of it. It is much slower than yours.\n\nIn python,", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n       return len(strings)\n    else:\n       longest = strings.remove(0)\n       return longest.strip().rstrip()", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return len(strings) > 1\n\nThat is not even slightly readable. I don't want to see that in my code.\n\nIt is terse, but it is readable (and I'm an FP-newbie).\n\nThe _only_ thing in that snippet which is clear is the definition of len(). I have no idea what len() is, and I have no idea why it's called len() in the first place. I don't know what the \"str\" parameter is supposed to be (or, for that matter, what the other three parameters are). I don't know how long the two string variables are supposed to be (is \"a\" an integer? a string? a list of strings? or what?).\nI don't know what the underscore means. I don't know what the return value is supposed to be. And I don't know what the \"optional\" syntax means.\nI don't think this is particularly terse. The terse version would be something like:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    for _ in strings:\n        return str.get(0).length() if str is not None else str\n\nPersonally, I would use type annotations to make the return type more obvious, but that's just me.\n\nYes, I would like to see the type annotation, too, but I get why the author chose not to.\n\nFrom the title, I thought this was going to be a discussion on learning type inference in Python (since it doesn't support it).\n\nI thought the same, but it's a nice article nonetheless.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return strings.take(len(strings) - 1)\n    if strings.has_key('b') and len(strings) == 3:\n        return strings[0]\n    else:\n        return strings.pop(0)\n\nI'm sorry but I fail to see how this is pythonic at all. This is classic perl/awk/sed one liner idiocy.\nThis is a classic case of pythonic idiocy being mistaken for pythonic syntax.\nFor one, _lists_ are not a pythonic data type. They should be avoided if possible.\nSecondly, this is not even idiomatic python, this is idiomatic C. It's been a while since I've seen the syntax for optional[something] but I'm quite certain it's not a pythonism.\n\nWell, lists are arguably the best data type there is. They are powerful, easy to use, and simple to understand. And they are very pythonic.\nAs for this particular example, you are right, it isn't that pythonic, although the syntax is. I agree with you that the logic is a bit flawed,", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    for s in strings:\n       if s.startswith('a'):\n          return s\n       if len(s) > 2:\n          return None\n\nThe word \"List\" in the first line has to be changed to \"Optional\", and also the \"return None\" is unnecessary.\n\nI got the point but thanks for the feedback.\n\nThis is the best one-liner yet.\n\nBut it's not a one liner.\n\nIn other news, Python 3 is out.\n\nI find it odd that Python's new default argument syntax is \"anonymous\".\n\nWhy is it odd?\nIn python you don't have to explicitly assign names to variables and arguments, so they don't need names.\n\nI'm not saying it's wrong, I'm saying it's odd.\n\nI really don't understand the downvotes. I'm not saying anything negative, just that I don't understand.\n\nIt comes across as the sort of comment which is basically just trolling.\n\nI'm really not trying to troll, I'm", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    while strings:\n        if len(strings) == 0:\n           return None\n        longest(strings)", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n        return None\n    return strings[0] if strings[0]!= '\\0' else strings[1:]\n\nThe author says:\n\"The two operations to create new instances of two common data types, List and Optional are completely different, but the code that uses them is exactly the same. This is because Python has a lot of built in functions that allow you to do this.\"\nHe then lists two different ways to create a list from a sequence.\nI would have thought it more interesting to compare the two \"duplicates\" from the first example, and look at how to do the same thing without functions.\n\"The way you create an empty list in Python is quite interesting. It is a sequence with a length of 0. So if you want to create an empty list, all you need to do is return the first element of a sequence and then set the length to 0.\"\n\nIf you want to try it out yourself, I've got a page of snippets like this:\nIt's what I do when I'm having trouble figuring out how to do something in Python, or just want to learn some new", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    longest = lambda l: l.length() > 0\n    if strings:\n        return longest(strings)\n    else:\n        return None\n\nI don't understand. It seems like this function always returns the same value.\n\nRead it again, starting with \"from typing import List, Optional\"\n\nOh, my bad. I didn't think that \"List\" applied to the strings and that it was just a list of strings. Thanks.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\nList.filter(s: strings) -> Optional[s].", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return strings.get(0)[0]", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    result = \"\"\n\n    return longest(strings if len(strings) > 0 else 0)\n\nList.from_iterable doesn't really fit into python's spirit.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n        return None\n    longest_string = \"\"\n    for sublist in strings:\n        longest_string += sublist.split()[0].rstrip()\n    if longest_string == strings:\n        return longest_string\n    return None\n\nThe article doesn't say anything about \"import\". Just that the author would like optional typing.\n\nI would personally prefer no typing at all. I'd rather use a text editor than a build system.\n\nI'll add that to my list of reasons to switch to using a text editor for programming.\n\nI would love to see optional typing in Python. I write Python for a living, and I wish I could use it in more places.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    longest = []\n    for name in strings:\n        if len(strings) == 1:\n           longest.append(name)\n           return longest\n    return None\n\nYou don't need `import List, Optional` for that - it's just syntax sugar.\n(And you _do_ need an ending curly brace on that one line.)\n\nI don't think that's true, at least for Python 3.\n>>> longest([]) <nothing>\n>>> longest('a') 'a'\n>>> longest('a', 'bb', 'ccc') 'ccc'\n>>> longest([], 'bb', 'ccc') <nothing>\n\nYou are right, it's python 2.6 behavior (according to ) and I am using python 3.5.\n\nThe python 3 way is much cleaner\n>>> longest([]) <itertools.product([('a', 'b', 'c'), ('bb', 'ccc')])>\n>>> longest('a') 'a'\n>>> longest('a', 'bb', 'cc", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return strings.max()\n\nYou're the person who wrote that?\nI think it's a really great example of how to do \"little\" things in a little language that can still have a big impact in a large codebase.\nIt's not really an example of anything, but it's very easy to read and it makes you think \"Hey, why can't I do this in my language?\"\n\nIt's very important to have readable code in Python, because the best way to find out how it works is to read it.\n\nThe real problem is that the code you find out there is usually not well documented.\n\nI agree, and that's a big problem.\n\nI like this too, but it's just one of a number of similar examples.\nThe other thing I like about Python is how it doesn't try to be clever. It's just a straightforward programming language.\n\nI think that's really one of the best things about Python, it's not trying to be clever. It's not trying to be cool. It's just there, and it's a really nice tool to use.\n\nPython is a _fantastic_ language. When I started learning it,", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return strings[0]", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return len(strings)\n\nI'd rather go with:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) < 3:\n       return None\n    for i in range(len(strings)):\n       if strings[i] == strings[i+1]:\n          return None\n    return strings[-1]\n\nThis is a typical example of 'bad python'.\nNot a big deal if it's just a single file, but if you write code like this, you might want to reconsider your development workflow.\n\nWhy do you think that's bad python?\n\nIt's not.\n\nIt's not great python either.\n\nWhy not?\n\nIt looks like a lot of noise is being created. I'd rather see something like:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\n    if len(strings)!= 1:\n        return strings[0]\n    else:\n        longest = None\n\n    longest_length = len(strings)\n\n    for s in strings:\n        longest = None\n\n    if longest == None:\n        longest = longest_length\n        longest_length = len(strings)\n        return longest\n\n    return None\n\nThis looks like some kind of tongue-in-cheek joke.\n\nLOL, no. It's real.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n        return None\n    else:\n        return strings[0]\n\nActually, I've seen code like this in the wild.\n\nThat's how I figured it out too, actually.\n\nThis is definitely an interesting example.\n\nAha, I found the solution!", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) < 2:\n        return Optional(strings[0])\n    if len(strings) == 2:\n        return strings[0]\n    if len(strings) == 1:\n        return strings[0]\n    else:\n        return None\n\nThis isn't bad, except that if you want to return the second longest string, you have to manually change it from  to  in the code. The code doesn't account for the fact that you could have omitted the first element.\nInstead, how about:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    length = len(strings)\n    if len(strings) == 0:\n        return None\n    longest = None\n    for string in strings:\n        if string.find('a') == 0:\n            longest = string\n        else:\n            longest = string.find('a')\n        else:\n            longest = string.find('b')\n        else:\n            longest = string.find('c')\n    return longest</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\n    return strings", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n       return strings[0]\n    return None\n\nI've never understood this kind of thing. As a Python programmer, you should know about Python's _list_ and _tuple_ types. Why are you using the _List_ and _Optional_ types in your own code?</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    longest_string = len(strings)\n    return longest_string.find(l => l[0])\n    if len(strings) == 1: return strings[0]\n\nI don't like it. It's not a bad idea, but it's a bad idea for the module stdlib.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return strings", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings == []:\n       return None\n\n    for i in range(0, len(strings)):\n       if strings[i] == 'a':\n         return i\n       else:\n         return longest(strings[i])\n    return None\n\nThis is really nice code. But what happens if you pass strings to the function?\n>>> longest([])\n>>> longest('a')\n>>> longest(['a', 'bb', 'ccc'])\n>>> longest(['ab', 'ba', 'bbb', 'cccc'])\n>>> longest(['a', 'bbb', 'cccc'])\n\nI like the code too, but I think it's easier to understand with the following two changes:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\n    return longest(strings) if strings else None\n\nI'm not sure about this, but to me it looks like a code smell. Why not do:\nreturn longest(strings) if strings else 'None'\n\nPython 2.6 had both of those. It was one of the things that made Python 2.6 so nice.\n\nPEP 3100: \"Named arguments in Python\"\n\nWhat would a list comprehension look like?\n\nIs there any way to use \"import <module> as <name>\"?\n\nNot yet. Here's the PEP: \n\nAwaiting the obligatory \"why not use a dict?\" comment\n\nWhy not use a dict?\n\nSee\n\nLongest common substring is not quite the same as longest, for those who don't know.\nlongest(list) will return the longest element in a list, regardless of how many strings there are. The common substring will only return a substring if the list of strings is longer than one string.\nSo, for example:\nlongest('a', 'aa') == 'aa'\ncommon('aaa') == 'aa'\ncommon('aaa', 'bbbb", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings is not None:\n        return strings.get(0).length\n    else:\n        return None\n\nCan someone with more experience in python tell me why this is a bad idea? It seems to me that this is a more concise way of doing it than the normal way.\n\nI think the idea of an optional type is great. I don't think it's great to have it as a language construct.\nI'd much rather have a type system and a compiler that can detect when I am accessing a variable without using the optional type. In that way I'd still get the benefit of the type system, but if I make a mistake, the compiler will catch it.\n\nI feel like the proposed \"optional types\" are something you could already do with some trickery with typing.py and the type hints.\n\nthis is what happens when a language doesn't have sum types.\n\nI think the problem of not having sum types is very overrated. I'm yet to see a case where sum types would make code clearer.\n\nHow about the example given in the article?\n>>> longest([])\nTrace", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    k, v = strings.split()\n\n    if v is not None:\n        longest(v.split())\n    return None\n\n    return k if len(v) == len(k) else v\n\nTheoretically, you could achieve the same result with\nreturn v if len(v) == len(k) else k\n\nNo, you couldn't. That's not the same as the given solution.\n\n_Theoretically, you could achieve the same result with_\nI said _theoretically_, not that it's a good idea to do so.\n\nSorry, I was mistaken. My bad.\n\nThis is really an implementation detail. Python's typing system is, at its core, a function that takes a type as input and returns either \"bool\" (true) or \"str\" (not a type error).\nSo if you implement your own type system, all you have to do is translate between types and function parameters, and return the type that you think you should.\nThe problem is that it's an incredibly poor type system, and the built-in types don't line up well with", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    l = strings.pop()\n    if l == None:\n        return None\n    else:\n         return len(l)\n\nYou're not going to need Optional. This code could be cleaner:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) > 1:\n       return strings[0]\n    elif len(strings) == 1:\n       return None\n\nNot sure if it's just me, but if I'm seeing a code snippet like this, I expect to be able to click it and see the whole thing, with comments and examples.\nIs there a reason not to do it this way?\n\nI believe the reason is to maximize the number of bytes downloaded. If they provide a link to the entire file, you are downloading the entire file even if you only care about the snippet.\n\nAt the same time, people are more likely to read the entire file if they don't have to download it first.\n\nI always thought one of the beauties of Python was the fact that you could \"just\" read the entire file.\n\nFrom what I've seen, people seem to complain the most about Python when the code is the most complicated, with a lot of dependencies, classes, and other things that aren't Python's fault, but rather the programmer's fault.\n\nYes, but I've seen the same complaint with people who have written in", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    longest = function(strings: List[str]) -> None\n\n    return longest(strings)\n\nfrom typing import Optional\n\n    def find_longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> find_longest([])\n\n    >>> find_longest(['a', 'b', 'c'])\n    'c'\n    >>> find_longest(['a', 'bb', 'ccc'])\n    None\n    \"\"\"\n    find_longest = function(strings: List[str]) -> None\n\n    return find_longest(strings)\n\nfrom typing import List, Optional\n\n    def shortest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the shortest one. Return the first one in case of multiple\n    strings of the same length.", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    n = len(strings)\n    for i in strings:\n       longest = 0\n       if strings[i] > longest:\n          longest = strings[i]\n    return longest", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    longest = {'a': len('a'), 'bb': len('bb'), 'ccc': len('ccc')}\n\n    return longest(strings)\n\nI don't get it. It returns None when the list is empty, but if the list contains a single element, it returns that element?\n\nIt returns the first element if the list is not empty.\n\nI see, it's the first element or None. I thought it was the first element or the empty list.\n\nSome people prefer the terse style, but I always prefer a bit more verbosity.", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    for i in strings:\n       if strings[i] == None:\n           return None\n           i = strings[i]\n           if strings[i] > longest(strings[i+1]):\n               return strings[i]\n    return None\n\nI assume that the question is about the function's name. I'd say it's because the whole thing is about optional arguments. The result of the function is optional, and the function itself is optional.\n\nOne more:\nfrom typing import Optional\nfrom type import *", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\nNo! Why is it that every time I see this, the author doesn't just write:\n\"Out of list of strings, return the longest one, or None if there is no longest one.\"\n\nI agree. I always ask people \"what do you think the value of None is?\" when they write code like this. I don't think they've ever had a good answer.\n\nThey probably have a vague idea about its role in the language, but it's one of those things that's so pervasive that it's easy to overlook. When I started programming I had to think about it, but nowadays I always have to remind myself.\nI think the reason is that, in general, people don't think about _what_ code is doing, but _how_ it's doing it. The general idea of None is that it's the absence of a value, and it's implicit in the concept of values. That's why you get so much confusion and bad code when trying to do things with None: people simply don't know how to do it.\n\nI don't think people don't know how to do it, I think people don't know what the result should be.\nI think if you say to people", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings:\n        return None\n    longest = (len(strings) > 0) &\n        (len(strings) == len(strings[0])) &\n        (len(strings) > 0) &\n        (len(strings) == len(strings[-1])) &\n        (len(strings) > 0) &\n        (len(strings) == len(strings[-2])) &\n        (len(strings) > 0) &\n        (len(strings) == len(strings[-3])) &\n        (len(strings) > 0) &\n        (len(strings) == len(strings[-4])) &\n        (len(strings) > 0) &\n        (len(strings) == len(strings[-5])) &", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return strings.most_common(strings.most_common(strings))\n\nI would say this is a pretty good example of what not to do with type annotations. What does optional[str] even mean? At the very least it means str, but it could also mean string, str[], string[] or string[]. I think it is actually more appropriate to use type annotations, but not for the reasons the author wants.\nInstead of", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n       return strings[0]\n    else:\n       return len(strings) - 1\n    return None\n\nSee also\n\nPython\n\nPython</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return strings[0]", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) > 1:\n       return strings[0]\n    else:\n       return None\n\nOne thing to point out is that the Optional class only has one method:\nOptional[str] get()\nIf you try to call one of the two method you mention, you will get a TypeError. The reason is that the class is \"closed\" as in there is no way to define new methods.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    for x in strings:\n        if len(x) > len(strings):\n           return x\n    return None\n\nThis is not a good example for two reasons:\n1\\. It's trivial to modify the \"list of strings\" by appending a '\\0' to the end, and then the loop will do nothing.\n2\\. The function doesn't return anything, which means you have to call it every time you want to see the result of the computation.\nI think it would be better if it returned a string representation of the longest string.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings is not None:\n       return longest(strings.get(0))\n    if strings.get(0) == 'a':\n       return strings.get(1)\n    if strings.get(1) == 'b':\n       return strings.get(2)\n    if strings.get(2) == 'c':\n       return None\n\nThis is a perfectly fine function to use in your code.\n\nYou may wish to rephrase the function signature, though. The way that it is phrased, the function does not return None if the list is empty.\n\nBy the way, I should have asked this question on stackoverflow.com but I wanted to know what HN's thought about this is.\n\nIt's fine. I use this all the time. It's kind of like a'min' function. The only problem is if you have a list of multiple items of the same length, it will return the first.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\nOptional's interface is a bit too complicated for my taste.\n\nThey're trying to bring back type-erasure to the mainstream.\n\nI can't help but feel that Guido van Rossum, the creator of Python, and Alex Martelli, the creator of Ruby, have been trying to bring type-erasure into the mainstream for many years now.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    for s in strings:\n       if len(s) > len(strings):\n          return s\n       else:\n          return None\n\nLooks like a great way to write a lot of boilerplate and still get it wrong.\n\nYou're right, but it's easier to read and more explicit than something like the following:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return len(strings)\n        # [None, ['a', 'b', 'c']]\n   \n\nI'm sure you meant:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    kwlist = strings.map(str.split())\n    if len(kwlist) == 0:\n       return None\n    if kwlist[0] == 'a':\n       return kwlist[1]\n    else:\n       return longest(kwlist)\n\nI'm not trying to be facetious here, but what's the difference between this and:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    length = len(strings)\n    return length > 0? strings[length] : None\n\n    def shortest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the shortest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> shortest([])\n\n    >>> shortest(['a', 'b', 'c'])\n    None\n    >>> shortest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    length = len(strings)\n    return length < 0? strings[0] : None\n\n    def longest_common(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest common one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest_common([])\n\n    >>> longest_common", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    def longest_one(s: Optional[str], rest: List[str]) -> None:\n    \"\"\" Out of a list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest_one(['a', 'b', 'c'], rest)\n    'c'\n    >>> longest_one(['a', 'bb', 'ccc'], rest)\n    'ccc'\n    \"\"\"\n\nNot sure what you are trying to accomplish here.\n\n\"Don't use general purpose languages to implement specific tasks\".\n\nPython is a general purpose language, and implementing the above list operations in Python is neither difficult or time-consuming.\n\nNote to self:  when posting to HN, think long and hard about how any given bit of info may be taken.  This post was meant as a joke.  The OP did not say anything about it being difficult to implement in Python.  He said, \"not sure what you are trying to accomplish here\".  My post was meant", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return sorted(strings.values(), key=lambda s: len(s)), None", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    l1 = len(strings)\n\n    if l1:\n       return strings[l1]\n\n    return None\n\nfrom typing import List, Optional", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\nreturn longest(strings) if strings else None\n\nWhat's wrong with this code?\n\nI'm not very familiar with Python, but that looks like a list comprehension, which is a way of expressing a set of nested for loops. What the OP has done is written code that the interpreter cannot interpret, and that's very bad.\n\nI am not a python programmer, but I think it has to do with the fact that the if statement looks like the beginning of a list comprehension and that the colon is missing.\nThe code should be\nreturn longest(strings) if strings:\nbut it should probably be\nreturn longest(strings) or None\n\nI am not a python programmer either, but I believe it is just missing the \"else\" statement, which is required.\n\nYes.\n\nPython has a very nice optional type that can be used in place of null to represent absence of something. It is described in more detail at:\n\nFrom the article:\n_Python is a language for people who like to use parentheses. The list\ncomprehension is a very nice feature, but the syntax is a little weird._\nThat's a fairly accurate description of most of Python, which is why I", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    for s in strings:\n        return s if len(s) > 0 else None\n\n>>> longest([])\nNone\n>>> longest(['a', 'b', 'c'])\n'c'\n>>> longest(['a', 'bb', 'ccc'])\n'ccc'\n\nI'm not sure I understand what this is supposed to do.\n\nI don't either. I'm pretty sure it should be something like:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return strings[0].strip().rstrip()\n\nLet's get something straight. There's an argument to be made for keeping the imports short, but this is not the way to do it.\nThe reason the imports are indented is to indicate to the reader the scope they're in. I can't remember which Googler made this point, but someone on the Go team noted that if you have to look up what a module does before you can read the code, it's not a good module.\nWith that in mind, it's clear that this is a bad idea. If a reader has to look up the definition of _import_ in order to know what this means, it's not a good import.\n\nI feel like the \"import\" keyword has a different meaning for people who are only familiar with Python. It does not necessarily indicate the module scope.\nIt's not like Haskell where imports are supposed to have a particular structure and you can't just \"import foo\".\n\nI think the import keyword in python is like the static keyword in C. It could be used for importing functions or for importing modules. It's still import that is being used either way.\n\nstatic in C is more", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return longest(strings)\n\nNice! The functional programming equivalent of \"hello world\".", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\nWhy don't you use a list comprehension?\n[x for x in strings if length(x) > len(strings)]\n\nHow is the \"for\" more readable than \"if length\"?</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n        return len(strings)\n    else:\n        longest = []\n    for s in strings:\n        if s.isinstance(str, unicode):\n           longest.append(s)\n        else:\n           longest.append(s)\n    return longest", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings:\n        return None\n    else:\n        longest = []\n    for i in strings:\n        if len(strings[i]) > len(longest):\n            longest.append(strings[i])\n        else:\n            return strings[i]", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    n = len(strings)\n\n    if len(strings) == 0:\n        return None\n\n    for i in range(n):\n        if strings[i]!= '\\0':\n            return strings[i]\n\n    return None\n\nWhy wouldn't you just use a `map`?\n\nMap is for mapping different types (e.g. Key to Value).\nIf you have a list of numbers, map() will return a list of keys and values, not a single number (unless your list is already sorted).\nIf you have a list of strings, map() will return a list of keys and strings.\nSo map() would not help here.\n\nmap is for mapping any object to any other object.\nIt doesn't have to be different types, though it's often used that way.\n\nmap() returns another list of objects with the same type.\n\nThere are no restrictions on the types of objects that are used in a map() function.\nThe output type is determined by the mapping function.\n\nmap() returns", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    len = len(strings)\n    return strings[len:]\n\nfinally, one of the reasons why python is so successful is because it is easy to read.\n\nThe biggest one is its syntax, which is very clear. It took me a week or so to get used to it, but now I write Python almost exclusively.\n\nAnd if I had a nickel for every time I had to explain to someone that \"import\" is NOT a function, I'd be rich.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) > 0:\n        return strings[0]\n    else:\n        return None\n\nI use this pattern too. I often see (bad) code that looks like:\nreturn None\nor something similar. This is a bit more verbose, but it's easy to read.\n\nI agree. I find that explicit coding gives me more confidence in the correctness of my code. For the same reason, I try to avoid using \"is\".\n\nI think there's a bit of a gray area where some uses of \"is\" are good and some are bad, but the gray area is so big that people who are just learning to program feel like they can't use \"is\" at all.\n\nI think that the problem with \"is\" is that it doesn't convey a lot of information. So people try to use it to convey more information, which is where the problems come in.\n\nI find \"is\" to be the most succinct and readable way to express an assignment operation.\nx = y is more readable than x = y.\n\nOn the other hand, the assignment operator is most", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\n    if strings is None:\n       return None\n    return longest(strings)\n\nTo be a little more Pythonic, you could do:\nreturn str(strings)\nIn this case, you don't need to return None in case of empty input list.\n\nNot really, in Python (as opposed to other languages) empty strings are only strings of length 0, which in this case doesn't really solve the problem.\n\nWhich is why I wrote \"doesn't really solve the problem\".\n\nI don't understand the benefit of the return None statement, in the case of the empty list.", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    try:\n       return len(strings)\n    except IndexError:\n       return None\n\n    def longest(words: List[str]) -> Optional[str]:\n    \"\"\" Out of list of words, return the longest one. Return the first one in case of multiple\n    words of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    try:\n       return len(words)\n    except IndexError:\n       return None\n\nYou can achieve the same results using generators, because of how generators work.\n\nVery nice. I'll add it to the todo list.\n\nFor performance issues, you may want to also write a version that returns a generator.\n\nWhat is the benefit of that?", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n        return strings[0]\n    else:\n        return len(strings) == 2 else:\n        return None\n\nMakes sense. They're using the List type, which represents mutable lists, but the function takes only an Optional, which is immutable. The function could be re-written to take the List type, but you can't have your cake and eat it too.\n\nI know nothing about Python, but if it's a list of strings, couldn't it be mutable?\n\nIt could be a list of strings but Python doesn't have mutable strings.\n\nIt could be a list of strings but Python doesn't have mutable _values_ in general.\nIt can mutate variable objects (like lists), though.\n\nCan we just stop writing languages where it's possible to accidentally do something like this?\n\nWhat would the alternative be?\n\nUse option types with no default value.\n\nSo what if you want a list of Options with no default values?\n\nUse a list of lists of options with no default", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\n    while len(strings) > 0:\n       if strings[0]!= '\\0':\n          return strings[0]\n    else:\n          return strings[0]\n\nThat's the wrong way to do it. Just use xrange's _contains_ function, which is similar to the longest function, but with a more appropriate name.\n>>> longest([]).contains\nFalse\n>>> longest('aaa').contains\nTrue\n>>> longest('aaa', 'bbb').contains\nTrue\n\nYou might want to read up on the rationale behind xrange.contains vs. xrange.range.contains.\n\nI think it is pretty clear that xrange.range.contains is what he was looking for, but why is xrange.contains the wrong way to do it?\n\nThe only justification I've seen is \"it's not explicit\" (aka, I didn't read the documentation).\n\nI think you'll find that the documentation for xrange.contains is fairly explicit about what it does and does not do:\n>>>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings:\n        return strings.pop()\n    else:\n        return Optional.empty()\n\nType hints in Python are awesome.\nBut the real question is, why are you using a list for this?\n\nIt seems that Python was not designed for types, it was designed for readability.\n\nI don't think that's true. Python has much more precise types than most languages that are designed for types. For example, you can tell the difference between a string and a byte string at compile time. You can also define your own types.\n\nI think they meant that Python was designed to be readable, not designed to be typesafe.\n\nThat's what I meant, thanks.\n\nI used to use a lot of typing modules in Python, but lately I've come to the conclusion that they just don't add much value.\nI think a lot of Python's success comes from its emphasis on readability over semantics. I'm not convinced that having a type system is a benefit.\n\nI like it for function return types.", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n        return strings[0]\n    if len(strings) > 1 and strings[0] not in strings:\n        return None\n        return strings[1]\n\nWithout exception, the single most useful python feature I've used is list comprehensions. I don't really miss any of the above, but I do miss comprehensions.\n\nAgreed. This is a perfect example of a language feature that is useless until you actually need it.\n\n...and is then used in every single line of your code.\n\nThis is a perfectly valid use of the language. When you see somebody use 'if', for example, you don't think that's valid python.\n\nThe list comprehension syntax makes sense, but I can't see any reason to use it.\nWhy not just:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings:len(strings) == 1:\n       return strings[0]\n    else:\n       return Optional(None)\n\nIt's quite nice to see that Python is getting some nice features from Javascript.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return len(strings) if strings else None\n\nI think this is a good example of how to write Python that is readable and straightforward. I think the alternative would have been to use the \"from typing import *\" and then iterate over the types that can be used as type annotations for functions.\nBut, it doesn't seem like such a good idea to me, because you would then need to do", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n       return None\n    longest_prefix = 'a'  # return the first string that has a prefix equal to 'a'\n    for s in strings:\n        if s[0] in longest_prefix:\n           return s\n\nThese are all really helpful comments. I think that the new title is good. Thanks to all for their feedback.\n\nI am just going to rewrite the post to make it more clear.\n\nYou didn't explain why you are using a List of strings instead of an array of strings. If you do want to use a List, I would suggest you use a generator to avoid the need for an else block in the longest() function.\n\nI'll rewrite the post to make this clearer. Thanks for your feedback!\n\nGood writeup, but I'm confused about your use of List. Would you mind explaining what your motivation was behind that?\n\nI wanted to use list because of the ability to do iteration over it.\n\npython 2.7.6 (default, Nov 23 2011, 22", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n        return Optional(None)\n    else:\n         return longest(strings.get(0))\n\nmy biggest problem with python is that sometimes it's too easy to write bad code.\n\nPython will teach you bad practices if you don't use it properly. It's certainly very easy to write really bad Python.\n\nYeah, I like to think of it as a toolbox. It has some really useful tools, but if you start making furniture without following proper safety procedures you are going to get hurt.\n\nI'm happy to see optional and keyword arguments officially supported.\n\nI'm not a Python dev, but I've been really impressed with the work in 3.x.\n\nThe best part is: when you do find a bug, the bug is usually fixed in the next release, and the bug report gets closed.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return strings.get(0).length() > 1\n\nI find it more readable to use 'len' instead of 'length'.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n        return None\n    for a in strings:\n        if len(a) == 1:\n           return a\n           else:\n             return strings[len(a)]\n\nI like this example. It's simple enough to understand how it works, yet it illustrates one of Python's strengths: the readability of the code. I don't think you could write a simpler and more readable version in any other language.\n\nWhy would you ever want to write a \"simpler and more readable version\" of code that does exactly the same thing as the original?\nThat seems like the opposite of a strength to me.\n\nPython's ease of _reading_ and _maintaining_ code, not writing code.\n\nI think you're responding to the wrong person, but I don't see why that was a distinction worth making.\n\nI think the OP's point was that, even though the example code doesn't have any \"elegant", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return optional(len(strings))\n\nAs a Python developer I'm curious what the practical use is for this. I can see its value as a learning exercise but is there really a need for this? I've been programming in Python for a few years and this is the first time I've ever seen something like this.\n\nI agree. I have a feeling that this is a troll.\n\nThe python core devs are pretty good at separating the language from the implementation. I'm sure that this little thing will make it into the standard library sooner or later.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n        return None\n    longest = []\n    for strings in strings:\n        longest.append(strings.get(0))\n    return longest\n\n>>> longest([])\n>>> longest([a, b, c])\n>>> longest([a, b, c, d])\n>>> longest([a, b, c, d, e])\n>>> longest([a, b, c, d, e, f])\n>>> longest([a, b, c, d, e, f, g])\n>>> longest([a, b, c, d, e, f, g, h])\n>>> longest([a, b, c, d, e, f, g, h, i])\n>>> longest([a, b, c, d, e, f, g, h, i, j])\n>>> longest([a, b, c, d, e, f, g, h, i, j, k])\n>>> longest([a, b, c, d, e, f, g, h, i, j, k,", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) < 2:\n        return strings[0]\n    return longest(strings)\n\nfrom typing import List, Optional\n\n\tdef longest(strings: List[str]) -> Optional[str]:\n\t\tif len(strings) < 2:\n\t\t\treturn strings[0]\n\t\treturn longest(strings)\n\nfrom typing import List, Optional", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\n>>> longest([])\nFalse\n>>> longest(['a', 'bb', 'ccc'])\n'ccc'\n>>> longest(['a', 'bb', 'cc', 'ddd']).get()\n'cc'\n\nI'm not sure if it's a typo, but if you want to return a list you need to return a tuple, otherwise you're returning None. I get the feeling this is an example of bad Python.\nIn this case it's not actually a bug, because None is what you want in the case of an empty list, but you need to be very careful when you use None, because it's often a valid value for a class.\n\nI think this is just a typo.\n\nA typo in the \"example usage\" section, but not in the actual code.\n\nThanks, but the example is correct, it is a list. I guess you are thinking of this part:\n\"return the first one in case of multiple strings of the same length.\"\nThis is not really a bug, since in this case, if there are multiple strings of the same length, it is only possible to return one of them.\nYou might be confusing it with this part", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return strings.get(0).isnotnull()\n\nThis returns None when the input is an empty list and \"a\" when the input is a list with a single string.\n\nFixed (thanks)!\n\nYou're welcome. I'd love to see a follow-up post to show how it works with your modifications.\n\nThat's a great idea. I'll have to look into the best way to do that.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    longest = lambda s: List(s.split(' '))\n    if len(s) == 1:\n        return s\n    if len(s) > 1:\n        return s.filter(s.startswith('a'))\n    return None\n\nSomething similar for a dictionary:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\n    result = []\n    for i in strings:\n        result.append(i)\n    return result\n\nThis is the worst way to do this. This is the correct way. I'm an optimist.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return strings[:len(strings)+1]", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n        return None\n    if len(strings) == 1:\n        return strings[0]\n    return longest(strings)\n\nIt's a bit odd to use strings and then use strings.index. Can't you just use strings.list?\n\nI'm not sure what you are saying. This is a test (not real code).\n\n`strings.list` returns a list of strings in order, sorted by length.\n`strings.index` returns the index of a string in `strings`.\n\nI know. But strings.list doesn't seem to be part of the standard library. This is a test.\n\nYou're right, I missed that. Sorry.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings is None:\n        return None\n    elif len(strings) == 1:\n        return strings[0]\n    elif len(strings) == 2:\n        return strings[1]\n    else:\n        return strings[0].split(',')\n\nI'm glad that so many people read my tutorial! :)\n\nShouldn't the title be:\n\"from typing import List, Optional\"\n\nNo, because you still need to import the base type.\n\nGood point. I guess my brain \"skipped over\" that import.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings is not None:\n       return len(strings) > len(string_to_return)\n    else:\n       return None\n\nMore pythonic version:\nlongest = len(strings) > len(string_to_return)\n\nHow is this pythonic? It's harder to read and less informative.\n\nReadability is subjective, but in my opinion this is more readable. I'd bet on a code review that it's also easier to understand.\n>>> len(strings)\n[',', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n        return None\n    return longest(strings)</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    max_length = len(strings)\n    return max_length == len(strings) and\n        longest(strings[0])       or\n        longest(strings[-1])       or\n        longest(strings[-2:]):\n\nA better solution would be to use a generator expression:\n>>> longest(strings)\nOut[4]:\n'a'\n>>> longest(strings.next())\nOut[5]:\n'b'\n>>> longest(strings.next(len(strings)))\nOut[6]:\n'c'\n\nOne nice thing about this is that it's not just a Python idiom; it's also idiomatic Ruby and Javascript.\n\nAnd Erlang.\n\nOr Perl (although they call it \"while\"):\n\nOr Smalltalk</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    for s in strings:\n        return s.length()", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return strings.get(0).length() > len(strings)? strings[0].strip() : strings.get(0)\n\nNice idea.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    result = strings.pop(0).get()\n    if result is not None:\n       if strings.size() == 1:\n          return result\n         return None", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return strings.get(0).lengthest()\n\nThis is a list comprehension, not a list.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings.is_empty():\n        return None\n    longest_string = \"\"\n\n    for i in range(len(strings)):\n        longest_string += strings[i]\n    if strings[i] == strings[-1]:\n        longest_string = strings[i]\n    return longest_string</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    for s in strings:\n        if len(s) == 1:\n           return s\n        else:\n            return Optional(len(s))\n\nI understand that this is a really good way to learn the language, but I have to ask:\nDid this really save any time over just typing in the above snippet yourself?\n\nIf you're just learning the language, you might be more likely to play around with it instead of doing something immediately useful.\n\nThat's what I assumed, but I'm still curious. How much time does it save to type the import line, type the class name, and then the function name?\nIs it the difference between a minute and a minute and a half? Maybe it takes you a few minutes to think about what you want to do?\nI've been using python on and off for about 6 years now, so my thought process is probably a lot different than someone who is just learning the language.\n\nI've been using Python for 2 years now, and while I haven't used the optional module, I", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\n    if len(strings) == 0:\n       return None\n    longest_length = len(strings)\n\n    if len(strings) > longest_length:\n        return strings[0]\n\n    else:\n        return strings[0]\n\nSo how long would that take to type?</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    var len = 0\n\n    while len <= len(strings):\n        if len(strings) == len(strings[0]):\n            return strings[0]\n        else:\n            if strings[len]!= None and len(strings) == len(strings[len]):\n              return len(strings[len])\n        else:\n             return len(strings)\n\nI'm not sure I get it. What's the advantage over the other method that's commonly used to get the longest string in a list (e.g. Python's string.split() or Ruby's split())?\n\nUsing a list comprehension to do this (or the split function) is a little bit of a misnomer. If you're really getting the longest string, then you're assuming that you're going to have a list of strings and you want to get the longest one.\nIf you want", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return len(strings)\n\nI know this is really more of a Python question, but the lack of lists in the standard library is what I'm most surprised about in Go. This library is nice, but is there any plan to change the stdlib to include lists?\n\nIt's not a lack of lists, it's a lack of mutable pointers.\n\nThat's not quite right. Go doesn't have mutable pointers, so it's not surprising there's no mutable lists. But it also doesn't have immutable pointers, so it's not clear why there's no immutable lists.\n\n\"immutable lists\" is a bit of a misnomer, because it's not just the pointers that are immutable. The underlying data structures are as well. Lists are implemented as a series of nodes, with pointers to each node in the list.\n\n_Go has no generics, and only one way to pass function parameters, which is by value_\nYeah, that's pretty much a deal breaker for me.\n\nIn other words, you have no idea what you're missing.\n\nThis has been my experience in the past. I've been forced to use Java generics. They've caused", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n       return None\n    if len(strings) == 1:\n       return strings[0]\n    longest_string = ''\n    for string in strings:\n       if string.find('a') == -1:\n          longest_string = string.find('b')\n          if longest_string == -1:\n                return None", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    longest = lambda x: x[2:]\n    return longest(strings)", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return (None, strings.pop(0))\n\nIsn't this a premature optimization?\n\nNot if you're in an environment with limited memory.\n\nI would like to see a thread about the most premature optimizations that ever happened.\n\nIt would be full of things that should never have been premature optimizations, but then became to be because people want to _avoid_ premature optimization.\n\nI've seen people using 'Optional' to represent an empty list. I've also seen people using 'Optional' to represent a singleton.\nThese are just two of my personal pet peeves.\n\nAlso, `Optional` and `Nullable` are not interchangeable, even though they look similar.\n\nI'm not sure how someone would actually use a nullable object in Python. Is it a pure \"just in case\" thing, or is there a reason to actually set it to null?\n\nIt's useful for unit testing. The alternative is to have a 'default' value (e.g. an empty list), but the problem is that there is no way to _know_ that the default value was never set.\n\nThis is one of the rare cases where unit testing is useful, but", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings.is_empty():\n        return None\n    longest = []\n    for string in strings:\n        longest.append(string.upper())\n    return longest\n\nThis doesn't seem to work, since you can't construct a list of strings with only one element, and if you try to call the function with an empty list of strings, it will fail to convert to an optional.\n\nI'm still not sure I understand the point of this post.\n\nRead the footnote.\n\nI did. I still don't get the point.\n\nI think it's a bit of a rant against how easy it is to write simple code that's hard to understand (for example, the longest function in this post). But I agree, it's not clear what the point is supposed to be.\n\nI think the point is that this is a step towards a really simple language, and if you're going to do that, the first step is to drop all the weird stuff from the existing languages.\n\nI had a conversation about this with my former manager a few years ago. I was arguing for a", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return optional(strings.pop(0)).find(u'\\w+')\n\nI really like this style of \"batteries included\" library. Instead of creating a list of functions for each common case, just provide the bare bones function for the common case and let the user write their own code for more complex cases.\n\nThis is called the \"batteries included\" style. \n\nThis is an easy to understand illustration of a fundamental difference between OO and FP. An OO programmer would say \"If I need it I'll create it.\" An FP programmer says \"If I need it, I'll put it in a library.\" The question is, \"Which approach is better?\"\n\nI think it's a bit more complicated than that.\nThe OO programmer would likely just create a list of objects and call it a day, not really using the object capabilities, and not really using the FP capabilities.\n\nI'm not sure what you mean by \"the object capabilities\" but I think you're right about the \"not really using the FP capabilities\" part.\n\nI agree with you. And the funny thing is that the same OO programmer would likely complain about the functional approach in", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings.len() == 0:\n        return None\n    return strings[0]", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return None\n\nI think this is a nice example of the cost of making small API additions.\nList() is such a tiny function that it's quite easy to understand what it does, and it takes no more than a moment to write (I actually wrote it in my head just now, and it took longer to type it than it did to think about it).\nMeanwhile, I have to read this new function to figure out what it does. That's not good. I know that it's trying to be clear, but it's not. It's extremely simple to misunderstand the intention of a function, especially in a language like Python that doesn't use types.\nIf you look at it carefully, you can see that it does a few things. It returns None if the list is empty, it returns the first item if there are multiple items of the same length, and it returns the second item if there's an item of the same length, but the first item is None.\nI think the first part is easy to understand. The second part is easy to understand, but not really obvious - I had to go back and look at the code again to understand that. If I hadn't already seen it, I'd probably have", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings:\n       return Optional[None]\n    if len(strings) == 0:\n       return Optional[0]\n    longest(strings[0])", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return len(strings)\n\nIt seems to me that the one-liner version should be\nlongest(strings)", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n        return None\n\n    longest = strings.any()\n\n    if longest is None:\n        return None\n\n    return longest.pop()\n\nWhy not just:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\nYou could have used tuples instead of lists to avoid the name clash:\n>>> longest([])\n'a'\n>>> longest(['a', 'bb', 'ccc'])\n'ccc'\n>>> longest(['a', 'bb', 'ccc', 'ddd'])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"/home/eric/python/lib/python2.6/site-packages/typing.py\", line 19, in longest\nreturn first(strs)\nTypeError: 'NoneType' object is not callable\n>>> longest(['a', 'bb', 'ccc', 'ddd']).get()\n'ccc'</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    first_one = Optional()\n\n    for i in strings:\n        first_one.setdefault(strings[i].length)\n\n    return first_one if strings:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if strings is None:\n       return None\n    elif len(strings) == 1:\n       return strings[0]\n    elif len(strings) > 1:\n       return strings[len(strings)-1]\n\nI haven't looked at the list comprehensions in a long time but isn't that an expression that should be split into 2?\n\nHere's the source:\n\"def longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    if strings is None:\n       return None\n    elif len(", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    longest_ = List.max(strings).get()\n    if longest_ is not None:\n        longest_.get()\n        return longest_\n\nA bit unclear what this method does from the docstring.\n\nHow can one write a method with a clear docstring and still have a good design?\n\nYou can't.\nI've seen several attempts to write a cleanly written, clear and easy to understand method only to have a very confused client.\nThe client didn't see how this method was useful to them. They just wanted to use it.\nI think this is a failure of the client, not the method, but I'm not sure how to overcome this problem.\nI've also seen a few classes with well written and useful method that the client was able to learn how to use very quickly.\nThat's what I try to do with the methods I write. I try to make the method's name give away what the method does. So, I guess, in a way, I agree with the OP, but I don't think the solution is to remove the docstring. It's to find a way to", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return strings.get(0).get(0).get(0).get(0)\n\nThis is a very interesting example of the \"invert the problem\" programming paradigm, where you turn a complex problem that's hard to solve with a traditional approach into a simple problem that's easy to solve.\n\nI agree that it is a good way to start thinking about problems, but I don't think it is a good way to end up coding.\nThe example of optional typing is a good way to end up with a good program. If you turn that into a list comprehension instead of an if statement you would end up with something a lot more flexible and less error-prone.\nFor the program above:\n>>> l=list('a', 'b', 'c')\n>>> l.get(0)\n'a'\n>>> l.get(0).get(0)\n'b'\n>>> l.get(0).get(0).get(0).get(0)\n'c'\n>>> l\n['a', 'b', 'c']\n>>> l.get(0)\n'a'\n>>> l.get(0)\n'b'\n>>>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return strings.pop(0).get()\n\nOptional isn't like Python's `None`; it's a type that can have a value or be empty. It's a good idea to use `None` for empty results, and `Optional[str]` for results that might be present.\n\nI'm a big fan of Optional. One of the most common uses in my code is for creating a \"maybe\" object. For example:", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return len(strings) > 0\n\nlxml.html5lib.HtmlTokenizer has no need of list, but it _does_ require optional, so you have to write it.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\n    return strings[0].len() == len(strings)\n\n    if len(strings) == 1:\n       return strings[0]\n    return None\n\nI would have used a dictionary instead.\n\nWhat's the advantage over the list?\n\nThe advantage is that the solution is well suited for both 1 and 2 string cases.\n\nI don't see how it's any better than a list in those cases.\n\nIs it just me or does Python 3 have a terrible lack of real utility methods and OO features?\n\nIs it just me or does Python 3 have a terrible lack of real utility methods and OO features?\nNo, it doesn't. I find that in many cases I have the opposite impression -- that Python 3 has a surplus of _useless_ features.\n\nOne of the nice things about Python is that you can always just ignore features you don't like.\n\nOne of the nice things about Python is that you can always just ignore features you don't like.\nOnly if you have the ability to completely ignore them. For example, if I make a Python 2 library and somebody else makes a Python 3 library using", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n       return strings[0]\n    else:\n       longest = strings.get(0)\n       if longest is None:\n          return None\n       else:\n          return longest\n\nA function that returns a tuple (a list) that can be of a finite or infinite length in a language that has the concept of \"infinity\".\nI see nothing wrong here.\n\nI have to admit, I was expecting something of the form:\n[x for x in longest(strings) if len(strings) == 0]\n\nThat's a neat way of doing it.\n\nI think there are two reasons to prefer the comprehension:\n1\\. It's a much nicer syntax.\n2\\. It's also more readable, especially when there are more than two elements in the list.\n\nThe nice syntax makes the code a lot less readable to a person who does not know Python.\nIt's a function that takes a list of strings and return the longest one,", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return [x for x in strings if x.length > 0]\nThe list comprehension works fine. Why did you use the non-list-comprehension version?\n\nBecause the author used the non-list-comprehension version in his examples, and the author probably didn't want to keep typing the syntax for list comprehensions, so the author implemented an optional version of the comprehension instead.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n        return None\n    longest_list = []\n    for s in strings:\n        longest_list.append(s)\n    return longest_list\n\nI just love languages that have optional typing.\n\nThis is one of my favorite features of Haskell. I think that it's an important skill for programmers to have, and in my experience, the only way to get better at it is to practice.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n       return strings[0]\n    else:\n       if len(strings) > 1:\n         return strings[0].split(\".\")[0].split(\".\")[0]\n        else:\n         return len(strings)\n\nI don't like this example. The result of [0] is a copy of the original input, so it's not the same as \"return len(strings)\", which is what the code actually does.\nThis is a problem with the Python 3 string implementation, though. It's not possible to have a shared-string implementation that behaves the same way as the old one.\n\nNice.\nI've been using this:\nimport sys\nfrom typing import List, Optional", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return len(strings)\n\nfrom typing import List, Optional\n\n    def longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    return len(strings)\n\nfrom typing import List, Optional\n\n    def longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    if len(strings) > 0:\n       return strings[0]\n    if strings:\n        return len(strings)\n    return None\n\nIsn't this a common anti-pattern?\n\nThe question is: why is it a common anti-pattern? I don't really understand why people discourage this kind of thing.\n\nIf you have a List of strings, why would you want an Optional?\nIf you have a List of strings and want an optional, why not just use an Optional?\nIf you have a list of strings and want the longest, and you can't use Optional for some reason, why not just use len() and find the first one?\nI guess the only case it would make sense is if you're trying to deal with a list of strings that you know have the same length, but don't want to make that assumption.\n\nThe question is: why is it a common anti-pattern?\nIf you have a List of strings, why would you want an Optional?\nBecause it's much clearer what you can do with it:\n>>> longest([]) <code>None</code>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    l = 0\n    for _ in strings:\n        if len(strings) > 1:\n           l = len(strings)\n           return strings[l]\n    return None\n\nIt's been a long time since I've done some serious Python, but isn't this a prime candidate for a generator function?\nI'm not sure how it would translate in a language with less functional features than Python, but in Python at least, it seems to me that a generator function would have been more idiomatic.\nAlso, I don't see where in the above code you would return None, unless I'm missing something. I would think that the list would be empty when the function is invoked and never needs to return None.\n\nThe value of the function is the length of the longest string in the list.\nSo you could return it if you wanted to.\n\nI've always been more of a fan of the oo approach for this sort of thing.\nfrom string import split", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    while strings:\n        return strings[-1]\n        if len(strings) == 1:\n            return strings\n             else:\n              return None\n\nVery cool. I had a similar idea a while back (I called it optionals), but didn't have the gumption to implement it. It's really simple and straightforward, and it's a great example of how the Pythonic way can make for more readable code. I'm definitely going to steal this trick.\n\nJust to let you know that this is not an original idea of mine. It was taken from python-ideas mailing list. \n\nThanks for the link. I've been trying to find a good source of ideas for Python. I'll have to check that out.</s>", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n\n    for x in strings:\n        if x.length == len(strings):\n           return len(strings)\n         else:\n            longest(x)\n\nYes, but you can do the same thing with\nlist(sorted(x))\nso what's the point?\n\nHow about this:\nlist(map(x, map(x, map(x, [len(x) for x in string])))\n\nThat is not really a valid solution. It doesn't handle the case of no elements in the list.\n\nSure it does. The last element of the list is the length of the list.\n\nWhat is the point of this? It's a shame there's no explanation of why this is useful.\n\nWhen you have a list of items that might be there or not, and you want to know the longest one if it is there.\nI've seen this problem come up in lots of contexts, for example when parsing a CSV file: sometimes you don't know in advance how many items there are,", "from typing import List, Optional\n\n\ndef longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\" \"\"\"\n    return len(strings) == 0 and len(strings):"]]