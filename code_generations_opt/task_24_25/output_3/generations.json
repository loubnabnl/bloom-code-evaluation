[["def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    for i in range(2, n + 1):\n       if n % i == 0:\n          return i\n    return 0\nAs a side note, I recently heard a talk by one of the creators of Python (might have been Guido himself, not sure), who was very much against this style of programming. He didn't like the implicit \"if i == n then return i\" type of logic. He said it's better to be explicit by saying something like:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n % n\nWow, that's pretty easy.  I was expecting something more complicated.  Like recursive, or something.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n % (n / n ** 2)", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return floor(n/2)\nIs that because floor(n/2) is guaranteed to be a whole number? (assuming n isn't a fraction of course)\nYes, n/2 is guaranteed to be a whole number, so there are only finitely many whole numbers that divide n evenly (assuming n is a positive integer).</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n > 1:\n         return n\n    else:\n         return n - 1\nSince you're returning an integer, you could use a while loop to find the largest number that's smaller than or equal to n.\nwhile n > 1:\n    if n <= x:\n         return x\n    n -= 1\n    return n\nI like this solution.  It's definitely an interesting exercise to try to figure out if there's a better way.  It seems unlikely that you could do it in a more compact form though.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n == 1? 1 : largest_divisor(n - 1)\nYou may want to be careful that your function does not have any side effects and is pure, so that you can use it in a different thread. You may want to look into using a monad.  Edit:  The above is not technically true.  As mentioned in comments, the function is pure.\nI don't think you need a monad for this.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n\n    # Use a divide and conquer algorithm\n    for i in range(1, n):\n        if n % i == 0:\n            return i\n       else:\n            return largest_divisor(n - i)", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return max(0, xrange(n, 1))\n    # same as min(xrange(n, 1), n)\nIsn't there a better way to solve this? I'm having trouble understanding why the solution is the answer.\n>Isn't there a better way to solve this?      No.  There are two possible solutions to this problem.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_divisor(n: int):\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n == 0:\n        return 0\n    return n if n % 2 == 0:\n        return n / 2\n    return largest_divisor(n-1)\n    # This is the most naive implementation of largest_divisor\n\nLet's go through the individual steps:\n1\\. Find if n is even. If so, return the second largest divisor.\n2\\. If n is odd, find the largest divisor.\n3\\. If n is even and n % 2 == 0, return n / 2.\n4\\. Return the largest divisor of the previous step.\nAs you can see, the last step is unnecessary. This is the most naive implementation of the largest divisor function.", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return min(n, 2 ** (n - 1));", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n % 2", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_even_divisor(n: int) -> int:\n    \"\"\" Find the largest number that divides n evenly, smaller than n\n    >>> largest_even_divisor(15)\n    5\n    \"\"\"\n    def largest_divisible_number(n: int) -> None:\n    \"\"\" For a given number n, find the largest number that is evenly divisible by n\n    >>> largest_divisible_number(15)\n    10\n    \"\"\"\n\nA simple test suite might look something like this:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_divisor(n: int) -> None:\n    \"\"\" For a given number n, find the largest number that divides n evenly, larger than n\n    >>> largest_divisor(15)\n    None\n    \"\"\"\n\nUhm, I don't understand the point of this. The first one will return the same result as the second one?\n\nIt can be very useful for Python 2.7 code.\n\nI've never seen this. I can't imagine a scenario where I would prefer this over the slightly longer but more readable version.\n\nIf I would write this, it would be in a snippet file in a git repository somewhere. Then, I could quickly paste it into any Python program without having to think about it.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n\n    \"\"\" Defined in <builtins.py>\n    >>> from decimal import largest_divisor as ddivisor\n    >>> ddivisor(15)\n    5\n    \"\"\"\n\n    def largest_prime(n: int) -> int:\n    \"\"\" For a given number n, return the largest prime factor of n that is smaller than n\n    >>> largest_prime(15)\n    5\n    \"\"\"\n\n    def largest_prime_factors(n: int) -> int:\n    \"\"\" For a given number n, return all the prime factors of n that are smaller than n\n    >>> largest_prime_factors(15)\n    [2, 3, 5]\n    \"\"\"\n\n    def largest_prime_num(n: int) -> int:\n    \"\"\" For a given number n, return the largest prime number that is smaller than n\n    >>> largest_prime_num(15)\n    7\n    \"\"\"\n\n    def largest_p", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def divisor(n: int, i: int):\n    \"\"\" For a given number n, find the smallest number that divides n evenly, larger than n\n    >>> divisor(15, 1)\n    5\n    \"\"\"\n    if i == 0:\n       return n\n    return n / i\nThis solution is more elegant than the OP's, but the difference is negligible.\n\nFor a given number n, find the largest number that divides n evenly, larger than n\nThat's not correct. The divisor function is the _last_ number that divides n evenly.\n\nNot necessarily, the smallest divisor could be the largest, or the other way around.\n\nNo, that's not correct. The smallest divisor will always be the first number that divides n evenly.\nLet's say you have a number n. Then the smallest number that divides n evenly is 1, because 1 divides n evenly and no other number does.\n\nYour statement is true for all integers greater than 1. It's only a corollary that it's true for 1.\n\nYou", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    n = n / 2\n    while n / 2 == 1:\n       if n % 2 == 1:\n          return n\n       n = n / 2\n       if n == 0:\n          return 1\n       else:\n          return n / 2", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n / (n ** 2 + 1)\n\nfor n in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]:\n    print largest_divisor(n)\n\nPython is not a functional language, so it's hard to make a real comparison. Even if you try to force it into functional idioms, it's still not a functional language.\nIt's like trying to compare an apple to a pear. Sure, they have a lot of similarities. They're both fruits. They both grow on trees. But they're still completely different.\nFunctional programming is a paradigm. It's a way of thinking about programming. It's a way to organize your code to promote simplicity, composability, and reuse. It's a way to structure your programs to better separate pure and stateful code.\nBut Python doesn't give you a choice. You can't just choose to use some functional-like features. It's all or nothing. Python is just", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n\nHere's the real code:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def __call__(self, n: int) -> int:\n    \"\"\"Return the largest divisor of n, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n < 1:\n       raise ValueError(\"n must be a positive integer\")\n    largest_divisor(n - 1) + 1\n\nI believe it's better to write the function like this:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n / (n ** 1) + 1", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 0:\n       return 0\n    while n < 1:\n        if n % 2 == 0:\n           return n\n        else:\n           return n\n\nI did something similar in Python but used the modulo operator to determine whether to continue or not:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n\n    def largest_even_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_even_divisor(15)\n    15\n    \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return len(list(int(x for x in range(n)))[::-1])\nWat?\nIt finds the biggest divisor that is smaller than the number passed in.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    for d in range(n):\n       if n % d == 0:\n          return d\n    return n\nBut wouldn't that be more efficient if you just return the list of values that are smaller than n?\n[0,1,2,3,4,5,6,7,8,9]\n[1,2,3,4,5,6,7,8,9]\n[1,2,3,4,5,6,7,8,9,10]\n\nNot on a modern computer, since it's O(n) to return that list. It's O(1) to calculate a division.\n\nNot necessarily. If you use a sorting algorithm, you could return the list in O(n) time.\n\nI'd be interested in seeing a proof of that. I can't see how you could return the list in O(n) time unless you have an O(n) algorithm for finding the smallest element of a list.\n\nI think the parent means O(n) constant time, not O(n) _polynomial time_.", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n <= 1:\n        return n\n    n = n/2\n    while n > 0:\n        if n % n == 0:\n           return n\n          n = n % n\n        return largest_divisor(n - 1)\n\nNow let's try this with the standard library:\n>>> def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n <= 1:\n        return n\n    n = n/2\n    while n > 0:\n        if n % n == 0:\n           return n\n          n = n % n", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n\nI would disagree with your comment. If you are familiar with Python and read Python code all the time, it's not terribly hard to figure out what the code is doing, what the variables are and what they mean.\nBut if you are a new programmer, or you are looking at a piece of Python code for the first time, I would say it's not a very good example of code. It's not hard to understand, but it's not easy either. And there's no reason it should be hard.\n\nYeah, I think I agree with that. The syntax is simple, but the semantics aren't. And that's where it gets hard for new people.\nI think a lot of the time it's not just the syntax that's simple, but the semantics as well.\n\nI agree with the author, a lot of times I find that Python's syntax can be frustrating and confusing. I've been programming in Python for 5 years now, and while I certainly could keep doing it in Python, I've found the same thing that the author found, that there are some really nice concepts in functional languages. It's definitely a matter of taste.\n\nI think the key is to not get hung up on the syntax of", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    assert n > 0\n    assert n > 1\n    return n\n    def largest_remainder(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that remains when dividing n evenly, smaller than n\n    >>> largest_remainder(15)\n    7\n    \"\"\"\n    assert n > 0\n    assert n > 1\n    return n\n\nThis should be true for the `largest_remainder` method, but not the `largest_divisor` method. The latter is not tail-recursive:\n>>> largest_divisor(15)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"src/testing/testing_examples/testing_iterative.py\", line 2, in main\nassert n > 0\nAssertionError: 15 > 0\n\nSorry, you're right. I'll fix the article.\n\nWhat about using a while loop instead?", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return (n % (n - 1))\nHow is this more concise than       n = int(n)\nor       n = int(n - 1)  Not trying to be a dick, just want to understand why this is more concise.\nIt's not, the title was meant to be a bit of sarcasm.\nIt's less characters, so it is.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n == 0? 1 : largest_divisor(n-1)\nWhy not use the fact that the modulus operator gives you the remainder if the number is divisible by the other number?      largest_divisor(n) = n % n\nBecause that wouldn't work on the integers.\nIt would if you check the value of n after you divide it by n (ie. is n > 0).   This is a trick I used in a project once to do a lot of long division very efficiently.   Edit: The problem is that you have to do it a bit smarter than that.\nI don't think so. You're dividing by zero at that point, so you're getting an infinite result.\nDude, I just coded this in a couple minutes. You don't have to believe me, but it works.\nNo, I don't believe you. Show me the code.\nIt's already there in the gist...</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n       if n == 0:\n          return 1\n       else:\n          if n == 1:\n             return n\n          else:\n             return max(1, largest_divisor(n - 1))\nWouldn't it be:  return (n % 2) == 0?\n\nI haven't looked at the source code, but I'm sure this version would be more performant.\n\nNot really. It's only a few more opcodes to check for 1 and n == 0. The algorithm above may be a bit slower since it has to check more conditions.\n\nI have to agree with you and melius.\nIn any case, I wouldn't think that the performance of this would be very significant.\n\nThis is interesting for an interview question (if I ever do one again) but I wouldn't really use it in a real project. It's easy to implement and fast but I have no idea what the performance", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n >= 1:\n       return n\n    else:\n       return n == 1\n            if n == 2:\n               return 2\n   \n\nWhat if the original number is 13? That would throw an error.\n\n`def largest_divisor(n: int) -> int:`\nI guess he wants a function that works for any number, not just numbers of the form `int` or `int[]`.\n\nYes that is correct. I should have put this in the header.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n == 1\n\nBecause the method does not return a value, there is nothing to bind the method to.  If you are trying to print the method call:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    n = n * 10\n    if n == 0:\n        return n\n    return n * 10", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def divisor(a, b: int) -> int:\n    \"\"\" Returns the number of times a divides b\n    >>> divisor(7, 3)\n    3\n    \"\"\"\n    return b / a\n    for a in range(1, n):\n        if divisor(a, n) == 0:\n           return n\n        else:\n           return a\n\nIt may be that I am missing something, but isn't this the same as just doing the \"largest_divisor\" function recursively?\n\nIf n=5, then the function will return 2 as the largest number that divides n evenly.\nHowever, the maximum value returned by this function will be 4.\n\nMy comment still stands.\n\nYou're right, it would be simpler to just use recursion. The point of this post was to show how to use lambda functions.\n\nI see the point of using lambda functions, but this is still pretty awful.", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    assert n in range(2, 101)\n    return n % 2\n    def largest_divisor_no_zero(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor_no_zero(15)\n    5\n    \"\"\"\n    assert n in range(2, 101)\n    return n % 2\n    def largest_divisor_no_zero_no_negative_zero(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor_no_zero_no_negative_zero(15)\n    None\n    \"\"\"\n    assert n in range(2, 101)\n    return n % 2", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return 2**n-1\n\nIt's also possible to do this with a simple recursive algorithm:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n/n + 1\n\nI'm not getting the joke here.\n\nI think the joke is that there is no largest_divisor function in python.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    x: int = 1\n    if n < 1:\n       return 1\n    x += n\n    if n == 0:\n       return x\n    return x == 0", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n.to_f() % n.to_f()", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return (n >>> 1)\nI thought of this as soon as I saw the headline. One of the more popular \"dirty little hacks\" in C is the following:\nsizeof(struct sockaddr_in) == sizeof(struct sockaddr_in * sizeof(struct sockaddr_in));\n\n_One of the more popular \"dirty little hacks\" in C is the following:_\nThe problem with that one is that it's so easy to get wrong. A more correct way to write it is to use sizeof(struct sockaddr_in * sizeof(struct sockaddr_in) * sizeof(struct sockaddr_in)).\n\nIf you are working in the C/C++ world, I think the \"hack\" label isn't a good thing. I think of it more like \"common practice\".\n\nCorrect. The correct way to write that is with a macro, and that's what is used in the Linux kernel:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n\n    def largest_multiple(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that is a multiple of n, smaller than n\n    >>> largest_multiple(15)\n    5\n    \"\"\"\n\n    def largest_absolute_value(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that is greater than or equal to n, smaller than n\n    >>> largest_absolute_value(15)\n    5\n    \"\"\"\n\n    def largest_factorial(n: int) -> int:\n    \"\"\" For a given number n, find the largest factorial of n, smaller than n\n    >>> largest_factorial(15)\n    120\n    \"\"\"\n\n    def largest_absolute_value(n: int) -> int:\n    \"\"\" For a given number n, find the largest absolute value of n, smaller than n\n    >>> largest_absolute_value(15)\n    15\n    \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_divisor(n: int):\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n == 0:\n       return n\n    return n / 2\n\nYou can simplify this by using the well-known fact that 5/2=2.5.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n == 1? 1 : n / n", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    n = 0\n    if n > 0:\n       n += 2\n    else:\n       n = -1\n    while n > -1 and n!= 0:\n       if n % 2 == 0:\n          if n == 1 or n == -1:\n              return n\n           else:\n             return largest_divisor(n - 1)\n\nI was going to post this as well.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    n = n\n    for x in n:\n       if x % n == 0:\n          return x\n       n /= x\n    return n", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 0:\n        return 1\n    if n < 0:\n        return -1\n    if n == 0 or n < 0:\n        return -1\n    largest_divisor = n\n    while n!= 0:\n        if n < largest_divisor:\n           largest_divisor = n\n        return largest_divisor\n\nI'm not sure how many languages this is valid Python, but it's not valid Python 3.\n\nWhat's the difference between n == 0 and n < 0? Is the former a one-time error and the latter a continuing condition?\n\nThe first is a value (the number 0), the second is an operator (the < symbol).\n\nI thought it was a type error, where the former was a boolean and the latter was a numeric?\n\nI think this was an unintended consequence of trying to provide a 2-valued logic in a language that doesn't really support it", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    for n in range(1, 20):\n       return largest_divisor(n)\nOh look, this is great! I've been looking for a way to do this for a while now.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n < 0:\n        return 1\n    else:\n        return n", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 0:\n       return 0\n    else:\n       if n % 2 == 0:\n          return n\n       else:\n          return n % (n - 1)\nThis is nice, but I think it's important to note that this is the _maximum_ number. It's not necessarily the largest number that divides evenly. For example, let's say n = 25. The largest number that divides evenly is 5, but the largest number is 6.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n % n\nYou can do this much more efficiently.", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(10)\n    5\n    \"\"\"\n    divisor = 1\n    while divisor <= n:\n       if divisor % n == 0:\n          divisor = n / divisor\n          return divisor\n    return divisor\nis a function that doesn't return anything.  It would be better to write it as:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    result = 0\n    while n <= (n % 2) + 1:\n       result = result * n\n       if result < n:\n          result = n\n    return result\n\nThis will never return 5.\n\nI think you're right. The version I had been using included the condition that the result is odd. If you change it to", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 0 or n == 1:\n       return 1\n    if n == 2:\n       return 2\n    if n == 3:\n       return 3\n    if n == 4:\n       return 4\n    if n == 5:\n       return 5\n    return n\n\nYou know, if you just want to get it over with, you could do this:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 1:\n       return 1\n    if n == 0:\n       return 0\n    if n == 3:\n       return 3\n    else:\n       return max(int(n // 2), int(n // 3))", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 1:\n       return 1\n    else:\n       for x in range(2,n+1):\n          if n%x == 0:\n             return x\n       return -1\n\nOops!\n> def largest_divisor(n: int) -> int:\n>    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n> >>> largest_divisor(15)\n>    5\n>    \"\"\"\n>    if n == 1:\n>       return 1\n>    else:\n>       for x in range(2,n+1):\n>          if n%x == 0:\n>             return x\n>       return -1\n\nI think the problem is in the range. You want", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    while n < x**2:\n        return x**2-n\nYou should probably use a loop.\nThis is not C, or Python.\nSome things can be done in a while-loop, while others can not. If you want to do a while-loop in Python, you need to define a function that takes one argument.   That said, I would agree that a loop is probably the way to go.\nWell, you can do a while-loop in a while-loop, it's just a little tricky.   You can't do a while-loop in a for-loop, though, so you're right.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 1 or n == 0:\n       return 0\n    if n%2 == 1:\n       return n\n    return 1", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 0:\n       return 1\n    return n if n % n == 1 else largest_divisor(n - 1)\n\nAhh, so it's just n-1, thanks.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n % (2**n)\nIt's a bad idea to use division by an integer greater than 2.  The answer will be different from what you expect.\nYeah, I was going to suggest that he should have used \"**\" instead of \"*\", but I didn't want to start an argument over how to implement the function.\nThat's not an argument, it's a correction.\nThat's not a correction, it's a nitpick.\nIt's not a nitpick. It's a core function in the language.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n\n    if n == 0:\n        return 0\n    else:\n        return n", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return 1.0 * floor(n/floor(log(n)))\nJust use xrange.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    n = int(input(\"Enter a number to check, e.g. 15:\")  )\n    if n >= 0:\n        return n\n    else:\n        return None\n\nSo we're looking at the condition in the else clause and the if statement looks like it will never be true.\n\nCan someone explain how this code works?\n\nAll of these are equivalent:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return (n % 2)\nThe code is also in the Python standard library, since 2.3.0 I think.  It does add a tiny runtime overhead, but I'm guessing the compiler would optimize this away.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_even_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_even_divisor(15)\n    5\n    \"\"\"\n    return largest_divisor(n / 2)\nI think it's kind of stupid to call this function largest_divisor when it's not actually a divisor.   Edit: I'm an idiot.\nIt's not. It's called largest_even_divisor, not largest_divisor.\nAnd here I am thinking I know something about python.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 0:\n       return n\n    else:\n       return n * max(0, x for x in range(n))\nAwesome, you just wrote the naive version of Knuth's up-arrow algorithm.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return max(n**2 for n in range(1, n**2 - 1))\nI am not sure what this is. Is it a special case of Quicksort?</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n\n    return n / (n % 2)\n\n    def largest_divisor_divided(n: int) -> int:\n    \"\"\" Finds the largest number that divides n evenly, smaller than n, by finding the largest number that divides n evenly, smaller than n, and then subtracting one from it.\n    >>> largest_divisor_divided(15)\n    5\n    >>> largest_divisor_divided(15, 2)\n    4\n    >>> largest_divisor_divided(15, 3)\n    1\n    \"\"\"\n\n    return largest_divisor(n) - 1\n\n    def largest_divisor_divided_by(n: int) -> int:\n    \"\"\" Finds the largest number that divides n evenly, smaller than n, by finding the largest number that divides n evenly, smaller than n, and then subtracting one from it.\n    >>> largest_divisor_divided_by(15)\n    5\n    >>> largest_div", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_divisor_fast(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor_fast(15)\n    5\n    \"\"\"\n    if n < 1:\n       return n\n    if n == 1:\n       return 1\n    if n == 0:\n       return n\n    def largest_divisor_slow(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor_slow(15)\n    30\n    \"\"\"\n    if n < 1:\n       return n\n    if n == 1:\n       return 1\n    if n == 0:\n       return n\n    n = n/10000000000000", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n < 2:\n       return n\n    else:\n       return n % n\nIt's so simple.\n\nIt has the problem that if n is a prime, the answer is zero.\n\nGood point, but I think that's a problem with the function's name and not the function itself. It should probably be called \"largest_prime_divisor\" or something.\n\nWell, it's not a problem for the function, it's a problem for the programmer, really.\n\nI don't know what you're talking about, there's only two problems with the function and the programmer:\n1) That the function is named incorrectly.\n2) That the function is named incorrectly.\n\nI don't think it's a problem with the function. The function does exactly what it says it does. The programmer, however, is the one who chooses the name for the function.\n\nThe function does exactly what it says it does. If you tell it to find the largest integer that divides n evenly then it should return the largest integer that divides n evenly. If you give it a value that is not an integer then the", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def divisors(n: int):\n    \"\"\" Returns the list of divisors of number n\n    >>> divisors(15)\n    [5, 3, 1, 1, 1, 1]\n    \"\"\"\n    def max_divisor(n: int, i: int):\n    \"\"\" Find the largest number divisible by number n that is smaller than n\n    >>> max_divisor(15, 4)\n    3\n    \"\"\"\n    for i in divisors(n):\n       if i == n:\n          return i\n       if n == i:\n          return i\n       if i is not in range(0, n - 1):\n          return n\n    return i\n\nThis code is a nightmare to work with. I prefer a simpler solution:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n == 0\nI'm a little confused. It's basically saying \"if the number is 0, then return the number that divides it evenly\". Isn't that what the original function is doing?\nYou're probably right. I'm not sure exactly what the original function is supposed to be doing, but the new one would probably do the same thing.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return 0\nWell, yeah, but that's not the question.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    \"\"\"\n    largest_divisor = n * 3\n    if n * 3 is even:\n        return n * 3\n    else:\n        return largest_divisor(n * 4)\nThis is kind of a false statement.\nThe recursive solution is identical, but the recursive solution is slower in both runtime and space.\n\nIn my experience the recursive solution is actually faster in both runtime and space.\n\nHow about a mutable implementation where n is passed in as a reference? I think that will make a difference.\n\nIt shouldn't be that different. The recursive version is a lot like a list, so I don't expect it to be faster.\n\nIt's the difference between a pointer and a list. The recursive version is like a pointer, and the iterative version is like a list.\n\nThis is an interesting, but perhaps unsurprising, result. For this particular example, you could get a very similar result using the Dict construction in Python:\n>>> def largest_divisor(n):\n...         if n == 0:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n\n    from operator import *\n    def divisor(n: int, d: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, greater than n\n    >>> divisor(15, 15)\n    45\n    \"\"\"\n\n    return n == n // d\n\n    def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    return divisor(n, 0)\n\nAh, python, how I love thee.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n == 0 else n /= 2\nI don't know what language this is in, but if it's C++, it should be:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return (int(n) / 2) + 1\nThis is more effective if you have a default value for divisors that is a power of 2. (e.g. 5 for 15).\n\nOne of the reasons for using Python is to avoid using explicit division.\n\nI am not sure if you're saying that because you don't like implicit conversions or because you prefer integer division to floating point. But Python is not a language that was created just to please you.\n\nI like it for both reasons, but I don't think either was what they were getting at.\nThe question is whether you want to type the code that does the implicit conversion or the code that does the explicit conversion.\nA great example of why not to do the implicit conversion is \n\nYou can do implicit division with zero\n(3 / 0.5) == (3 / 0.0) == 3\nSo the division is done without the division operator. That is explicit.\n\nYou are correct but the implication is that a division operator is the same as an implicit conversion operator. It's not.\n\nWhy not? It has the same result, the same precedence, and the same precedence of operator precedence.", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return min(n%largest_divisor(n-1), n/largest_divisor(n-1))\nWhat's the point of this?</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 0:\n        return 1\n    return n\nI'm not sure I'm convinced that this is a good method for getting the largest factor of n (no pun intended). It only considers numbers from 1 to n, and the largest factor could be a number that's not evenly divisible by n.\nI've never really thought about how to solve this problem, though, so maybe I'm wrong.\n\nThis is usually the kind of problem for which a dynamic programming algorithm is useful.\n\nThis is one of the problems I have been looking for an answer to. I have a dynamic programming algorithm that is horribly slow, however (for large values of n).\n\nWhy not use a greedy algorithm?\n\nI'm not sure that's the right approach either. The value of a divisor isn't necessarily monotonically increasing (it's an integer, but not a natural number).\n\nSee also:\n\nFor those wondering, the Python implementation is very readable:\nimport functools\nimport itertools", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n < 2:\n       return n\n    else:\n       if n % 2 == 1:\n          return n\n          if n % 3 == 0:\n              return n\n            if n % 5 == 0:\n                return n\n             if n % 7 == 0:\n                return n\n              if n % 11 == 0:\n                 return n\n              return largest_divisor(n - 1) + 1\n\nWhat's the purpose of this function? It just returns the answer. If you're not doing anything else with the answer, why not just pass", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for i in range(2, n - 1):\n       if n == i:\n         return i\n    return n", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    n = floor(n)\n    while n <= 1:\n       if n % 2 == 1:\n          return n\n          break\n       return 1", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n <= 2:\n        return n\n    else:\n        largest = 1\n        while n > largest:\n           largest = n\n           if largest > n:\n               return largest\n        return n\nSo Python?\nI'm not familiar with python's syntax, but the logic is the same.\nNope, this is JavaScript.\nYou guys are great. I don't know any other language that will return the n+1 with such a code.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 1:\n       return n\n    return n / n\nIf you want to make it a little more efficient, you should use a binary search for that.\nfor i in range(2, n):", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n\nOk, this is silly. The largest number that divides 15 evenly is 5, regardless of whether you are using Python or Matlab.\nAnd if the number of people who would really do this is greater than 0, they must be using Python for extremely trivial things, since there are simpler ways to do this in Matlab than to write a whole function.\n\nThe `def` statement is a red herring. To me, the interesting thing is that this is a 3-liner in Python and a 5-liner in Matlab.\nI'm not sure if there is a simpler way to do this in Matlab, but I'm positive there's a more elegant way to do it in Python.\n\nI don't know about Matlab, but this can be done in a single line of code in Ruby.\n\nSo what's the difference between this and:\nx = 15 / (1.0 / n)\n?\n\nIt's a little more readable.\n\nOh, I thought you were suggesting that it was somehow more efficient. In that case, I agree that it's more readable.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n if n < 1 else n if n < n.__divide_size() else n.__divide_size()\nWhy is that a useful method?\nMostly because it's easy to remember and it doesn't have a whole lot of code.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n ** (n - 1)\nNot sure if this is it, but doesn't the halting problem mean that this is undefined?\nActually, I don't think so.  My guess is that if you give a halting problem to a computer, and ask it to find the largest number that divides n evenly, the computer will halt.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    largest_divisor_ = lambda n:\n        if n > 0:\n           return n\n    else:\n           return largest_divisor_(n - 1)\n        return largest_divisor_", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return (n & 1).max()\nThis is not a good example to give. If n is a prime, the largest divisor is 2.\nTheoretically, yes. In Python it doesn't work like that.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n\nPython has some issues with formatting.\n\nThis is one of the reasons I think Python is a terrible language for teaching.\nThere's a ton of really weird things about it that make it a bad choice.\n\nI can't wait for Python 4.0 with default typing.\n\nThe GIL is a dealbreaker for me.\n\nIt's not a deal breaker for most people, including those who write the standard library. I'd say the GIL is a much bigger deal breaker than the lack of default typing.\n\nAre you saying most people writing libraries for Python are OK with the GIL? I find that difficult to believe.\n\nI think he meant most people using Python are ok with the GIL.\n\nSure, that makes sense.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 1:\n       return 1\n    return n if n % n == 0 else n/largest_divisor(n-1)\nlolwat  There's literally no reason for this to exist. This is the equivalent of having a function named \"bignumber.get_biggest_number_less_than_other_biggest_number()\".\nI have a feeling they just wrote the entire python interpreter in Python and it's now a recursive function that calls itself\nIf I was that clever I would have been a billionaire by now.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 0:\n       return n\n    if n == 1:\n       return 1\n    if n == 2:\n       return 2\n    if n == 3:\n       return 3\n    if n == 4:\n       return 4\n    if n == 5:\n       return 5\n    if n == 6:\n       return 6\n    if n == 7:\n       return 7\n    if n == 8:\n       return 8\n    if n == 9:\n       return 9\n    if n == 10:\n       return 10\n    if n == 11:\n       return 11\n    if n == 12:\n       return 12\n    if n == 13:\n       return 13", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    n = n", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n\n    #self.n must be a known constant\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return self.n\n\nWhy does the function returns the value that it is called? I can see it's useful for debugging, but is that the only purpose of this?\n\nProbably for a more human-readable failure message.\nAlso, it can be used to test the contract of your functions. If your function returns a wrong result, you know you have some bugs to fix.\n\nI usually start with the contract of the function in the comment block. Then, if something's wrong, the compiler can point me to the exact place.\n\n_\"Don't use comments for contract. You can't be sure people will actually read them, and they tend to get out of date.\"_\n\nIn addition to that, with the advent of linters, having your comments automatically checked is very nice.\n\nIf you're interested in a really cool discussion of Python's \"lesser-known\" (as if anyone on HN hasn't used these) features, check out:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    x = n // 2\n    while x > n:\n        if x % n == 0:\n            return x\n         x /= n\n    return -1\n>largest_divisor(15)", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n if n is not None else n / largest_number\nI don't think this works as stated. What if n is 16? I think it would always return 5.\nI think it should return -1 or n/2, whichever is larger.\n16 is the largest number that divides 16 evenly, so it would return -1.\nI think it should return -1 or 5/2, whichever is larger.\nWhy would it return 5/2?   It's the largest number that divides 15 evenly, which is 5.\nIf n = 16, the statement `n is not None` is true and the function returns the value n.  Since n is 16 and not None, the function returns 16/5 which is -1.  I should have been more clear in that the function needs to return an integer rather than boolean.  If n is not None and n is an integer, then the function should return the integer with the largest value.\nBut this is returning the largest number that divides the number n evenly. It should return 16/5.\nExactly.  I think you are misunderstanding what I'm saying.  I agree that if n is 16, the function should return 16", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    n = n * 10\n    while n > 0:\n       if n % 2 == 0:\n          return n\n    else:\n          return n\n    return n\nI would replace this with:\nn = n * 10\nwhile n > 0:\nn /= 2\nn = n/2\nreturn n\nThere's no reason not to use integers in Python, and it is safer than floating-point arithmetic.\n\nA similar question asked in the previous edition (using Python 2.6):\nhttps://news.ycombinator.com/item?id=1442066\n\nI like this:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_even_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_even_divisor(15)\n    3\n    \"\"\"\n\nThis will only work for positive integers, not negative integers.\nYou'll need to explicitly specify the sign of the integer returned by largest_divisor.\n\nThere is also a problem with the way the methods are named. Both methods have a similar name, but with different semantics. The names are ambiguous.\n\nI see that as a feature. A feature that would help improve the test coverage of the code.\n\nThat's true. I had in mind a different situation though.\n\nI'm not sure if this is the intended behavior, but the method on the right always returns the largest number divisible by n, whereas the method on the left returns the largest number that is evenly divisible by n. In the example, the method on the right returns 5 whereas the method on the left returns 3.\n\nThe example is misleading. It's not the same method.\n\nI think", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    return n\n\nIsn't that a bit of a silly example? 15 is divisible by 5.\n\nYes, but 5 is the largest number that divides 15 evenly, smaller than n\n\nIf I were to write that, I'd use 'less' rather than'smaller than':", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n\n    return n % n", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n > 1:\n        return 1\n    return largest_divisor(n - 1) + 1", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n % n\nI think I'll add this to the list of reasons why it's bad to write code while you're hungry.\nI just lol'ed at this.\nYou just lol'ed at a programmer joke?  I'm not surprised.\nYou are an idiot.\nYou are a programmer.\nWhat's wrong with that?\nNothing, just was returning your argument back at you.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n%2\nNote that for numbers less than 9, you get the wrong answer.\nIf you want a better algorithm, you need a different question.\nThis question is meaningless.\n\nThank you very much!\n\nI just did some minor edits to that code, which should fix the issue with negative numbers (I used the modulus operator instead of division because you don't care about the remainder). I would recommend that you post a new question (don't delete this one) and include the fix in your question.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def __lt__(l: int, r: int):\n    \"\"\" Compare two numbers for equality.\n    >>> l < r\n    True\n    >>> l == r\n    False\n    \"\"\"\n    if l == 0:\n       return 0\n    else:\n       return 1\n    def __ge__(l: int, r: int):\n    \"\"\" Compare two numbers for equality.\n    >>> l < r\n    True\n    >>> l > r\n    True\n    >>> l == r\n    False\n    \"\"\"\n    if l == 0:\n       return 0\n    else:\n       return 1\n    def __gt__(l: int, r: int):\n    \"\"\" Compare two numbers for inequality.\n    >>> l < r\n    True\n    >>> l > r\n    True\n    >>>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 1:\n       return 1\n    if n == 2:\n       return 2\n    if n == 3:\n       return 3\n    if n > 2:\n       return n * 2\n\nI don't think it's so bad. I mean, the comments are a bit verbose, and maybe the return values could be more informative, but it's pretty clear what the code does.\n\nI don't think it's so bad, either. I would add a comment about which cases it handles, though.\n\nI don't see how it's so hard. The code is well formatted, self-explanatory and I can easily read the purpose of each function.\nI don't care if the code is not idiomatic, as long as I understand the purpose and can easily follow the code.\n\nI can't imagine that most people would have trouble understanding that code.\n\nIt's not that I can't understand it. It's that I find the code to be very unappealing.\n\nI find it interesting that some of the most", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return 1\nEvenly divide 15 by 5?\n\nIt's not a division by 5, it's a division by the largest number that divides n evenly. In this case, it's 5.\n\nHeh, thanks. My brain was not working there.\n\nI like the _NoIO_ implementation of this, which is a macro that can be defined in each module that has an IO context, as necessary:\n\nI tried that and couldn't get it to work in my code. Any chance you could post an example?\n\nI'm not the parent, but in my code I just use a global _NoIO_ function, like so:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_divisor(n: int):\n    if n == 0:\n       return 0\n    if n < 0:\n       return -1\n    if n == 1:\n       return 1\n    return n / largest_divisor(n - 1)\n\nThis will stop working for larger n.\n\nGood point! Thanks for the catch.\n\nI think the best way to do it is to find the greatest common divisor, if it exists, using Euclid's algorithm:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n < 0:\n        return -n\n    return n == 0? n : n * 2", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    result = 0\n    for _ in range(n):\n        if n % 2 == 0:\n            result += 1\n         else:\n            result += n\n    return result\nThat's not a good algorithm, and the version in the article is correct.\n>>> largest_divisor(15)\n5\nIt's the same algorithm, but with a pre-calculated array and using a little more RAM.\n>>> from __future__ import division\n>>> largest_divisor(15)\n(5, 6, 10, 15)\n\nThe second version has a bug: it will always say that 15 divides 15, which is false. If you care about this bug, the right way is:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n < 0:\n        return 0\n    else:\n        return n\nAm I missing something, or is this just inefficient?\nHow can it be slower than the naive solution (using the mod operator)?\n\nThe algorithm is in-place.\n\nYeah, it seems to me that in-place is the only sensible way to implement this algorithm. If you pass the input as an argument, you have to copy the input into a new array that is smaller than the original array. If you pass the input as a tuple, you have to copy the input into a new tuple, which is smaller than the original tuple.\nThe only way to avoid copying is to pass a function as an argument, but then the algorithm is in-place.\n\nI'm surprised by the popularity of in-place algorithms on HN. It's like most of the people here only ever program in Python or something.\n\nIn-place algorithms are just a natural consequence of functional programming. You don't have to make any copies or copy any state. It's just the way functions work.\n\nNo, it's not.\n\nHave you programmed", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 0:\n       return 1\n    else:\n       if n % 2 == 0:\n          return n\n       else:\n          return (n - 1)\n       return n\n\nI've implemented that in Python:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n\nI hate to say it, but this is a very poor example of how to do it in Python. As a concrete example, consider how it would look if the function had to be used with a parameter of type int. The last example would probably look something like this:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 1:\n       return 1\n    else:\n       return n % n\n\nThe sad thing is that you actually had to explain what it did.\n\nBut isn't that the point of all the other comments?\n\nNo, I think the point of those comments is to point out a weakness in the original code, and then to make a joke out of it.\n\nI'm not sure the original code is really all that bad. I mean, it's not elegant, but it seems to do what it's supposed to do. I'd rather see someone use this code to solve a problem rather than some kind of generic and useless for loop.\n\nI have this feeling that it was written in a hurry (because of the lack of comments).\nMaybe it's good enough for some cases, but I would never use it.\n\nAlso, the comment should be inside the loop, not at the top.\n\nThe funny thing is that there's a bug in this code.\nn = 5\nn / n\nShould return 0, but instead it returns 1.\n\nI've been programming professionally for a long time,", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 0:\n        return n\n    if n == 1:\n        return 1\n    n = n / 2\n    while n / 2 > 0:\n        if n == 1:\n           return n\n        n = n % 2\n    if n % 2 == 0:\n           return n\n    else:\n        return n\n\nSee also\n Divisor number\n Greatest common divisor\n Greatest common divisor (algorithms)\n Greatest common divisor (geometry)\n Greatest common divisor (modular arithmetic)\n Greatest common divisor (notation)\n Greatest common divisor (set theory)\n Greatest common divisor (wedge)\n Greatest common divisor (mathematics)\n Greatest common divisor (probability)\n Greatest common divisor (programming)\n Greatest common divisor (set theory)", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return max(1, n / (n - 1))\nEven though it's a single line it's still a terrible code snippet, in that it does not explain what the function does and requires external context to be able to understand. I would much rather see the following, even if it were only two lines long:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n is not None:\n       if n!= 0:\n          return n\n       else:\n          return largest_divisor(n - 1)", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n == n % 2\nNow, explain why this is not a good algorithm.  If your explanation is not relevant, but your code is, you've wasted everyone's time.\nDoesn't work for non-integers.  Also doesn't work for numbers that are larger than the limit of the integer type.\nThat's because it's a joke.  Look up the maximum value of an int.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n\nI think you should return 2.  Or you could return n/2 and say that's the largest even divisor.  But that's not the point.  The point is, this is not the way to solve that problem.  You need to find the smallest multiple of two that's greater than or equal to n.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n / len(n)\nI'm trying to understand why len(n) is used in the division.  Wouldn't n / n be just as accurate as n / len(n)?\nYes, but then you can't prove that your answer is correct.\nAh, of course.  I can see why that would be desirable.\nIt's also useful to know the actual number of digits in the input.\nYes, that makes sense too.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    a = 0\n    while a < n:\n        if n%a == 0:\n           a = a / n\n    return a\nHow would you write it if you wanted to limit it to positive numbers?\n\nThat's an interesting question, but I'm not sure what the answer is. I'm not entirely sure how to do a negative number without using some magic.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    for i in range(n):\n       if i % n == 0:\n          return i\n    return -1\nYou can use the is_odd() function to check if a number is odd or not, if you are finding the largest divisor of n.\nYou can also use is_odd() to test if a number is an odd number or not, if you are finding the largest non-divisible number of n.\n\nBut these are not problems with the code given.\n\nI'm pretty sure the code given will always return -1 if the number is a perfect square.\n\n>>> largest_divisor(20)\n-1\n>>> largest_divisor(10)\n-1\n>>> largest_divisor(5)\n-1\n>>> largest_divisor(15)\n-1\n\nI'm not sure what the \"p\" in \"largest_divisor(n: int) -> int\" means.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_even_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, and is not less than n.\n    >>> largest_even_divisor(15)\n    5\n    \"\"\"\n    return largest_divisor(n) - 1\n\nI'd have the following syntax sugar (I think it's valid Python):", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def __iter__(self):\n    \"\"\" Iterate over this function.\n    >>> for n in range(3, 17):\n       print(largest_divisor(n))\n    >>> largest_divisor(3)\n    5\n    >>> largest_divisor(10)\n    3\n    >>> largest_divisor(2)\n    4\n    \"\"\"\n    def __next__(self, index: int):\n    \"\"\" Return the next largest number\n    >>> largest_divisor(2)\n    4\n    \"\"\"\n    return self.__next__(0)\n    def __next__(self, n: int):\n    \"\"\" Return the next largest number\n    >>> for n in range(10):\n       print(largest_divisor(n))\n    >>> largest_divisor(5)\n    3\n    \"\"\"\n    return self", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n > 1:\n        return n\n    else:\n        return n % 2 == 0\nWhat happens if n is exactly 1?\nIt will return 1.\nWhat if n is zero?</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n < 2:\n       return 0\n    if n == 2:\n       return 1\n    if n == 3:\n       return 2\n    return largest_divisor(n - 1) + 1\n\nThis is literally the worst python I've ever seen.\n\nThis is a terrible way to do it.\n\nIt's not terrible, but it's not the most efficient or readable way. I don't know of any way to make it more efficient, but it could be made more readable.", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    largest_divisor(n) = 0\n    while n > 0:\n         n /= 2\n         if n == 1:\n            return n\n         largest_divisor(n - 1)", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_divisor(n: int):\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    for x in range(n):\n       if x == n:\n          return x\n       if x / n == n:\n          return x\n    return -1\n\nI think it's a good start for a humorous post, but the code could be cleaned up a bit.\n\nI like this one:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 0:\n       return 1\n    else:\n       if n % 2 == 1:\n         return n\n       else:\n         return n + 1\nI'm not saying the answer is wrong, but this doesn't seem very efficient.\n\nIt's certainly a bad algorithm, but the question didn't ask for the fastest, or the most efficient, it asked for the simplest.\n\nIt's not clear to me why it's a bad algorithm. It's the naive way to do it, and I'd say it's far from bad.\n\nNaive is always bad. Naive is the sort of thing you do in kindergarten and then learn how to do it properly later.\n\nYou're saying that there's a simple algorithm that always finds the largest common factor in a list of numbers?\n\nThat's not what GP said. They said that the naive algorithm of iterating through all the numbers to find the smallest multiple of the divisor was a naive algorithm.\n\nYeah, I'm confused by his claim that \"na", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 0:\n        return n\n    else:\n        if n % 2 == 0:\n           return n/2\n        else:\n           return n - 1\n        if n % 3 == 0:\n           return n/3\n        else:\n           return n - 2\n    else:\n        return n", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    largest_divisor = divmod(n, 1)\n\nThe last time I checked, this was the most upvoted comment on that page. I agree with the other comments, this is a terrible idea.\n\nIs there any rationale behind this being a terrible idea? I have yet to come across any serious programmer who doesn't use the same method of finding the largest number in a range.\n\nBecause a good strategy for writing code is to take advantage of what the language offers you. If you're writing code that will run in Python, then you're better off using the built-in divmod function to find the largest element in a range than to write your own function that does essentially the same thing.\n\nNo.\n\nI don't know what's more annoying: that this is a single line of code with three comments, or that it's a single line of code with three comments that's been posted to Hacker News.\n\nI don't know why you'd call it annoying. I'd call it a good example of a _correct_ way to write python.\n\nI'm guessing you're being sarcastic. If you're not, let me explain why I find this code annoying.", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n\n    n = int(input(\"Enter the number of the divisor: \"))\n\n    while n > 1:\n        d = 0\n\n        while n % d == 0:\n           d = d + 1\n\n    return d\n\nI don't think it's right to call it \"def\". Python doesn't have \"def\". But the method you have here is basically the same as Python's \"def\".\n\nHm, what is the equivalent for Python? I know that you can't define an \"empty function\", so I just called it \"def\".\n\n_Hm, what is the equivalent for Python?_\nPerhaps you'd better ask in the Python forum.\n\nThe thread about this was deleted from the Python forum\n\nSorry to be off topic, but I just wanted to say, in all my years of programming, I've never seen a more beautiful definition of \"for\".\n\n\"for\" is one of the things I always thought could have been done better. I really like the new syntax:\nfor x in range(1, 100): print", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return largest(n)\nNote the lack of tests, documentation, docstring, and probably a lot more.\n\nA lot of times you will see things like this in someones code when they have just had a quick fix to make it work and forgot to go back and refactor it.\n\nWhy is it that everyone who has ever written production code has experienced the same phenomenon?\n\nAlso, this is a classic case of the \"don't test your module's output\" rule.\n\nI think the problem here is that the program is being run in the shell. It should be run in a test environment.\n\nSome of my coworkers don't do this and it drives me up the wall.\n\nWhy do you want to test your shell scripts? What is the point of test-driving your shell script?\n\nFirst, it's an indication that you're testing the script itself, not just the final product of running the script.\nSecond, it makes it clear that you're testing the script, because it has a test script.\nThird, you can write the script to throw an error if it's not being run in a test environment.\n\nThis reminds me of the blog post \"The", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def __call__(self, n: int):\n    \"\"\" Return the largest number that evenly divides n.\n    >>> largest_divisor(15)\n    5\n    \"\"\"\n    if n == 1:\n        return n\n    else:\n        if n % 2 == 0:\n           return n\n          if n % 2!= 0 and n % 3 == 0:\n            return n\n           return n + 1\n\nHow are you supposed to write tests for this function? The article is about how to write good tests and this function breaks a lot of the rules that the article covers.\n\nFor me the biggest question was why the function is named largest_divisor and not largest_even_divisor, and the answer to that question, at least to me, seems to be that the author has a background in mathematics. I have no idea if that is true or not,", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return 1\nYeah, I like that one too. I'm surprised it's not a standard function already.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 0:\n       return n\n    return largest_number(n, n)\n\nfrom itertools import repeat, zip, count", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return min(n div n for n in range(1, n+1))\nThis is the only proper answer, because it's the only one which is guaranteed to run in constant time.  *edit: I take it back, the solution by /u/pfavio123 is also guaranteed to be constant time.\nIt's not.  The runtime complexity is O(n).  It only works for numbers that are divisible by n.  The naive solution O(1).  It's O(n^2) if you implement it as a recursive algorithm (assuming it always terminates).\nI've found the O(n) solutions to be the most common. I've worked on projects where we had to prove our code was correct, and the simplest code tends to be the most common.\nIt's all about the edge cases.  If you have to add a requirement, like the number must be divisible by n, the solution is no longer constant time.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    # Add a print statement to be able to see the results\n    return (n >>> 1)\nI wish I had thought of that solution. It is as simple as this one, and more readable.  If you're interested in the optimal solution, see my answer below.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n >= 0:\n       return n\n    else:\n       return 2*n\nIt's supposed to be Pythonic and readable\nIt's not.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n % (n - 1)", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return (n % i for i in range(1, n - 1))\n>>> max = largest_divisor(15)\n>>> max\n15\n>>> largest_divisor(16)\n16\n>>> max = largest_divisor(16)\n>>> max\n16\n>>> largest_divisor(17)\n13\n>>> max = largest_divisor(17)\n>>> max\n13\n>>> largest_divisor(18)\n11\n>>> max = largest_divisor(18)\n>>> max\n11\n>>>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 0:\n        return 1\n    return n", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    n = int(input(\"Enter n: \"))\n    if n < 0:\n        raise ValueError, \"n must be positive\"\n    while n > 0:\n        if n % 2 == 0:\n           return n\n          return largest_divisor(n - 1) + 1\n\nI don't think this will work - if n is 15, it will never return anything, since 15 is the only number that will divide it evenly.\n\nI think you're right. Maybe the input parameter could be an upper bound.", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n < 2:\n       n = 2\n       return n\nI'm not sure what the point of this is.  The correct way to do this is to use a recurrence relation like\nmax = max(max(n))", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_divisor_recursive(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor_recursive(15)\n    25\n    \"\"\"\n    # n - 1 is the largest divisor that is smaller than n\n    return 1 if n == 0\n    n = n - 1\n    for i in range(n):\n        if n % i == 0:\n           n = n % i\n       else:\n           n += i\n\nWithout exception, the top comment on every post on Reddit is some sort of ad hominem attack on the poster. It doesn't matter how good, bad or ugly the post is. It's the same. It's predictable.\n\nI'm sure that's true but I think the parent comment is more an observation than an attack. It's not very interesting to point out a common pattern in a", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n / (n >> 2)\nNot sure why this was downvoted...</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n < 2:\n       return n\n    else:\n       if n == 2:\n          return 1\n       else:\n           return n % 2\nIt's quite easy to write that function by hand, but not so easy to implement it algorithmically. That's why it's not idiomatic.  The idiomatic way to write that function is by using the pre-processor directive __divmod__.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return 1 if n % n == 0 else n\nIn python, the check is redundant:  > largest_divisor(15)\nTraceback (most recent call last):\nFile \"/usr/lib/python2.5/site-packages/math/bigint.py\", line 149, in __div__\nreturn (n / n)\nValueError: negative division  (negative): division by zero\nThat is, a zero division is valid in Python, but an invalid division by zero will raise a TypeError.  I guess it's because division is not commutative.\n\nYeah, that is a good point.\nIt looks like C code, so it would be a compiler error.\n\nIt's actually from the Python source.\n\nI'd expect this from Lisp but not Python.\n\nI actually thought the question was a bit too easy.\nI thought about the problem for a couple of seconds and thought that the answer would be something like:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n > 0\nI would also change the name to smallest_divisor (unless it's suppose to be a recursive function that works for any number).", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    \"\"\"\n    if n in range(0, infinity):\n        return 1\n    return 2\nDoesn't that return 1 because it will always be 1 or 2?</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    largest_divisor = 0\n    for i in range(n):\n        largest_divisor += i\n    return largest_divisor", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_even_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_even_divisor(15)\n    10\n    \"\"\"\n    def largest_even_divisor_from_left(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_even_divisor_from_left(15)\n    3\n    \"\"\"\n    def largest_even_divisor_from_right(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_even_divisor_from_right(15)\n    3\n    \"\"\"\n    def largest_divisor(n: int, divisors: int[], right_divisor: int) -> int:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n - 1\nNote that this is not a special case for numbers in the range 1..n, but any number. The requirement that it be smaller than n is implied.\nAnd that's O(n^2), if anybody's wondering.\nIn the worst case, it's O(n) in both time and space, but that's not very likely.\n\nI'd say it's O(n) in time and space.\n\nIf we don't talk about the time complexity, then it's O(n^2) in space.\n\nI'm not sure if I understand this. If you assume that all numbers are stored in a hash table, then you're looking up the number and only the number in the table. In that case, the space complexity is the same as the hash table complexity.\n\nIn the worst case (i.e. one in which n is very large), you have to iterate through all numbers.\n\nI think you're right.\n\nI think there's a bug in the code, it outputs the same value for all n.\n\nThe output is the same for all inputs, yes, but that is not a bug. The input is", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n\nWhat if the answer is 0?\n\nIf a function call is made in a void context, Python will automatically provide an answer for you if one is given.\n\nPython provides a special syntax to get a list of values in a given range:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n <= 0:\n        return 0\n    n = n * n / 2\n    if n % 2 == 0:\n        return n\n    return n + 1", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 0:\n       return n\n    if n == 1:\n       return n\n    if n == 2:\n       return n\n    if n == 3:\n       return n\n    if n == 4:\n       return n\n    if n == 5:\n       return n\n    if n == 6:\n       return n\n    if n == 7:\n       return n\n    if n == 8:\n       return n\n    if n == 9:\n       return n\n    return 1", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n / (n % n)", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 0:\n       return 0\n    else:\n       return n == 0? 1 : largest_divisor(n - 1) + 1</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n <= 1:\n       return n\n    else:\n       largest_divisor_divisor = None\n    while largest_divisor_divisor is None:\n       if largest_divisor_divisor is not None:\n          largest_divisor_divisor = n\n          return largest_divisor_divisor", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n\n> largest_divisor(15)\n\nTrue\n\nIt doesn't seem to be correct.  (15 / 5 == 3)</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n == 1", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return 2**n\nI don't think it's possible to do this efficiently in Python.\nThe best we can do is to have a function to calculate the largest divisor of a number less than 10^6.", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n < 2:\n       return n\n    else:\n       return n % (n - 1)\nI think that's pretty good.\n\nYou should learn the rule of nines and use it to make your solution smaller and more elegant.\n\nYou're right. I should. But that's not the point of this exercise.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n % n == 0\nI like how the author doesn't tell you what the function does without looking at the source.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n\n    def divisors(n: int) -> [int]:\n    \"\"\" For a given number n, find all numbers that divide n evenly, larger than n\n    >>> divisors(20)\n    [0, 5, 10, 15, 20, 25]\n    \"\"\"\n    return [n if n in divisors(n) else 0 for n in range(n+1, n+1) if n in divisors(n+1)]\n    n *= 2\n    while n:\n       if n /= 0:\n          return divisors(n - 1)\n       else:\n          return largest_divisor(n)\n       n /= 2\n   \n\nLet's also take a look at some of the more exotic algorithms, starting with the classic quick sort.\n\n    def quick_sort(array: List[int]) -> List[int]:\n    \"\"\" For a given list", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    for n in range(1, n - 1):\n        if n % n == 0:\n           return n\n        return -1\n\nThis is a good example of how the -1 is an important part of the syntax.\nIf the language didn't have a way to express \"return a negative number\" then it would be impossible to write this function.\n\nI think I would have to write something like:", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    if n == 0 or n == 1:\n        return 0\n    else:\n        return n\n\nThat's a prime number, not a divisor.\n\nIt is the largest divisor of 15.\n\nNo, the largest divisor of 15 is 5, which is a prime.\n\nNo, the largest divisor of 15 is 15.\n\nNot if you are just looking for the largest divisor, not the only divisor.\n\nMy point is that the function is not returning the largest divisor of 15, it is returning the largest divisor of 15, a prime number, which is a totally different thing.\n\nCan you code the first function in a function-ish way (where the block is inside a function)?\nfunction x():", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    largest_divisor = (n == 0)? 1 : (n == 1)? 1 : (n == 2)? 1 : (n == 3)? 1 : (n == 4)? 1 : (n == 5)? 1 : (n == 6)? 1 : (n == 7)? 1 : (n == 8)? 1 : (n == 9)? 1 : (n == 10)? 1 : (n == 11)? 1 : (n == 12)? 1 : (n == 13)? 1 : (n == 14)? 1 : (n == 15)? 1 : (n == 16)? 1 : (n == 17)? 1 : (n == 18)? 1 : (n == 19)? 1 : (n == 20)? 1 : (n == 21)? 1 : (n == 22)? 1 : (n == 23)? 1 : (n == 24)? 1 : (n == 25)? 1 : (n == 26)? 1 : (n == 27)? 1 : (n == 28)? 1 : (n == 29)? 1 : (n == 30)?", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_divisor_of(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor_of(15)\n    15\n    \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_divisor(n: int):\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    >>> largest_divisor(n)\n    5\n    \"\"\"\n    if n == 0:\n       return 1\n    else:\n       if n % 1 == 0:\n          return n\n       else:\n          return n - largest_divisor(n - 1)\n    return n\nWhat's wrong with this?  Is it a valid Python idiom?\nI know I can't return True or False because of the \"if\" but I'm not sure what the better alternative would be.\n\nI think it's just an indentation problem; when you're on a line all by itself, you have to hit enter twice to make the next line start at a new indentation level. Try typing it again and hitting enter a couple", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n - 1", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_divisor(n: int, out_divisor: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, larger than n\n    >>> largest_divisor(15, out_divisor = 5)\n    10\n    \"\"\"\n    return n ** out_divisor\n    def largest_divisor(n: int, out_divisor: int, factor: int):\n    \"\"\" For a given number n, find the largest number that divides n evenly, factor of n\n    >>> largest_divisor(15, out_divisor = 5, factor = 2)\n    8\n    \"\"\"\n    return n ** (out_divisor - factor)\n\nSee also\nArithmetic of divisors (an article on the arithmetic of divisors)\n\nExternal links\nLargest Divisors, by Mark A. Dvoretsky</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return (n % 2 == 1) or (n % 3 == 1)\nI'm missing something fundamental about python here, but shouldn't this return 1 since 15 can be divided by 2 and 3?\n\nIt's Python 2.7, so the largest_divisor() function is defined in terms of the % operator. See https://docs.python.org/2/library/division.html\n\nI'm also missing something fundamental about the `%` operator.\nIf I have a list of numbers, can I use a % operator to see if any of the numbers are equal to each other?\n\nI don't know the specifics of the % operator, but if I have a list of numbers, I can certainly use the == operator to see if two numbers are equal.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    n = int(n)\n    while n!= 0:\n       if n % 2 == 0:\n          return n\n       n = n / 2\n    return n\nThat's a slow algorithm, but one that is known to be good.  If you want the fastest possible, try this instead:  (I'm assuming a C-like language here)      if n % 2 == 0:\n          return n\n       else:\n          return n // 2\nI'm not sure how it can be any faster.\n\nThis is essentially what the article says.\n\nI was trying to explain it, not point out that it was wrong.\n\nWell the author of the article could learn from you.</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    def largest_even_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_even_divisor(15)\n    5\n    \"\"\"\n    def largest_even_divisor(n: int, prune=True) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_even_divisor(15, prune=True)\n    5\n    \"\"\"\n    def largest_even_divisor(n: int, min_n=0) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_even_divisor(15, min_n=0)\n    5\n    \"\"\"\n    def largest_even_divisor(n: int, min_n=0, prune=True) -> int", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return (n%2 == 1 and n%2 == 1)\n    else:\n    print 'Divisor not found'\n    raise ValueError, 'Divisor not found'</s>", "def largest_divisor(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> largest_divisor(15)\n    5\n    \"\"\" \"\"\"\n    return n == 0? 1 : (n/n**(n-1)) % n\nAs a python newbie I am still learning the language. It took me a few minutes to understand this one.\nCan someone explain why it is written this way?\n\nPython doesn't have a return value.\n\nI don't really understand. If it doesn't have a return value, what does it return?\n\nIn Python, functions are first-class objects. So when you have a function like this, you are returning a function (called the \"result function\"), which returns an integer.\nHere's a simple example:\n>>> def f(x):\n...     return x * x\n>>> f(5)\n10\n>>> f(6)\n100\n>>> f()\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: f() takes exactly 1 argument (0 given)\n\nI really love the way Python works. In the Ruby world we are still trying to figure out how to get rid of return values so our DSLs can be more declarative.\n\nI like to think that"]]