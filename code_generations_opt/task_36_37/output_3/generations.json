[["def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    for i in range(0, n):\n        return i % 11 and i % 13\n    print(fizz_buzz(50))\nI wish someone would do this in real life.\n\nDoes anyone have a reason why they would use that instead of:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    for i in range(1, n+2):\n        if n%11 == 0:\n           return n%13\n         else:\n           return 1\n    if n>0:\n       return n\n\nReferences</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\nHow did you write that? Python? Haskell?\n\nPHP, actually.\n\nI'm surprised at how many of those I've heard of (or seen), and how few of the people I work with use any of them.\n\nI'm surprised that they are surprised at that.\n\nNo one is surprised; they are just sharing a little bit of their own experience.\n\nI'm surprised at how many of those I've heard of (or seen), and how few of the people I work with use any of them.\n\nI'm surprised that they are surprised at that.\n\nNo one is surprised; they are just sharing a little bit of their own experience.\n\nI'm surprised at how many of those I've heard of (or seen), and how few of the people I work with use any of them.\n\nI'm surprised that they are surprised at that.\n\nNo one is surprised; they are just sharing a little bit of their own experience.\n\nI'm surprised at how many of those I've heard of (or seen), and how few of the people I work with use any of them.\n\nI'm surprised that they are surprised at that.\n\nNo one", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    from collections import OrderedDict\n    from string import format\n    from string import gsub\n    def fizz_buzz_fast(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz_fast(50)\n    2\n    >>> fizz_buzz_fast(78)\n    1\n    >>> fizz_buzz_fast(79)\n    1\n    \"\"\"\n    if n < 11:\n        return n\n    else:\n        return n % 11 == 0 or n % 13 == 0\n\nThe example is somewhat misleading:\n>>> fizz_buzz(50)\n0\n>>> fizz_buzz(78)\n2\n>>> fizz_buzz(79)\n3\nThis is probably the intended behavior, but I think it would be better to have:\n>>> fizz_buzz(50)", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def bizz_fizz(n: int):\n    \"\"\"Return the number of times the digit 3 appears in integers less than n which are divisible by 11 or 13.\n    >>> bizz_fizz(79)\n    1\n    >>> bizz_fizz(79)\n    2\n    >>> bizz_fizz(79)\n    3\n    \"\"\"\n    def fizz_bizz(n: int):\n    \"\"\"Return the number of times the digit 5 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_bizz(50)\n    0\n    >>> fizz_bizz(78)\n    2\n    >>> fizz_bizz(79)\n    3\n    \"\"\"\n\nfor i in range(0,n):\n    return (i div 11 == 0? i div 13 == 0 : 0) & fizz_bizz(i - 1) & bizz_fizz(i - 1", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return [n for n in range(n) if n % 11 == 0 else n % 13]\nor", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def solution(n):\n    \"\"\"Return the solution to the puzzle (the number of times 7 appears in integers less than n).\n    >>> solution(n = 79)\n    7\n    >>> solution(n = 78)\n    7\n    \"\"\"\n    if n%11:\n    return 7\n    if n%13:\n    return 7\n    return None\n    return solution(n)\n\nI don't see any advantage to this over a simple Python for loop.\n\nThis is intended as a thought exercise for learning Python.\n\nSo is the solution to the \"puzzle\" then the number of times 7 occurs in integers less than 79, or the number of integers less than 79?\n\nThat is the puzzle.\n\nThen what is the value returned from the function?\n\nNone.\n\nSo then what are we supposed to do with it?\n\nI'm afraid I don't understand what you are asking.\n\nI think you might be missing my point. There's no real value in a solution to a puzzle that doesn't have a", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    result = 0\n    for i in range(n):\n        if i % 11 == 0 or i % 13 == 0:\n            result = i\n    return result\nI know you're just trying to illustrate a point, but this would be a terrible implementation of `fizzbuzz` since it would produce the wrong result for all non-prime numbers.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def sub_n_div(n: int, a: int, b: int, c: int):\n    \"\"\"Return the number of times the digit a appears in integers less than n which are divisible by 11 or 13.\n    >>> sub_n_div(50, 7, 10, 13)\n    0\n    >>> sub_n_div(50, 7, 10, 11)\n    2\n    >>> sub_n_div(50, 7, 10, 12)\n    1\n    \"\"\"\n    if b == n and a == n:\n    return n\n    return sub_n_div(n, a, b, c)", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\nIs that the correct Python 2.7 syntax for function definition?\n\nNo, it's not. It looks a lot like it, but it's not.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n < 1:\n        return 0\n    if n < 2:\n        return 1\n    if n < 3:\n        return 2\n    if n < 4:\n        return 3\n    if n < 5:\n        return 4\n    if n < 6:\n        return 5\n    if n < 7:\n        return 6\n    if n < 8:\n        return 7\n    return fizz_buzz(n-1)\n\nI see no problem with this. This is pretty readable, as it's a single line. You can also easily break it into multiple lines if you want to break up the code a little.\n\nC++", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\n    return [n % 11 for n in xrange(n)]\n\nShouldn't it be 0, 1, 1, 1?\n\nThe value of this function is the number of digits in the input. E.g.\ninput: 6\noutput: 6\ninput: 75\noutput: 6\ninput: 78\noutput: 6\ninput: 79\noutput: 6\n\nYes.\n\nThis is the classic first assignment to a CS 101 course. The point of the assignment is to get you writing code that is reasonably \"idiomatic\" (meaning, a lot like real code you would see in the wild).\nFor example, this:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n        if n == 0 or n == 1:\n          return 0\n        return sum(filter(lambda x: x % 11 == 1, range(1, n+1)))\n\nYou can do better.\n\nThat's a fairly contrived example.\n\nWow, that's amazing. It's not a problem I've ever had the need to solve, but it's so elegant and simple.\n\nIt's a good thing it's so elegant, because the Python code is so horribly verbose.\n\nI thought that it was a bit verbose, but it's shorter than the equivalent Perl. I've grown to appreciate the brevity of Python's syntax, especially when working with iterators.\n\nI haven't been able to make myself like Python's syntax, though that's not to say that there aren't some nice things about it.\n\nI think a few years ago I would have been in a similar position. I had spent a lot of time with Perl and really felt that it was the best language for the job. In the last few years, though, I've spent a lot of time working with", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n * (n % 11 == 0) + n * (n % 13 == 0)\n\nI like the idea, but why not remove the parameter?\n\nI was thinking about that, but I wanted it to be a function that accepted any integer, not just integers divisible by 11 or 13.\n\nI can see that, but I think that you can simply name it fizz_buzz and let it be clear that it works for any int.\n\nI've been trying to come up with a better way to do this for a while. I think I found it.", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    try:\n    return 1 if n == 0 or n == 1 or n == 2\n    except ZeroDivisionError:\n    return 0\n    return fizz_buzz(n % 11) + fizz_buzz(n % 13)\n\nWell, that's cute and all, but why would someone want to write this? Why not just use:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    n = int(input(\"Enter the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13: \"))\n    while n <= 1:\n        n += 1\n        if n % 11 == 0 or n % 13 == 0:\n           print(\"{}\".format(n))\n\nYou could simplify that quite a bit.", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    return n\nIsn't this the same as ?\n\nI thought the \"trick\" was to use a faster but more complex algorithm.\n\nI did some \"fizz-buzz\" programming with my kids this weekend (they were bored and I needed to make sure they were still breathing).\nI was very surprised to learn that many people just see the function as a simple puzzle, when in fact it's a wonderful way to introduce some fundamental programming concepts.\nI think they get the most out of it when they see the patterns emerging, and that's not something you'd get just by writing an answer.\n\nWhile I agree that fizzbuzz is a great puzzle, I have to say that even simple", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def check(n: int):\n    \"\"\"Check if n is a valid input for fizz_buzz.\n    >>> check(50)\n    <function check of <type 'function'> object at 0x7f9b7a4c1b28>\n    <param name=\"n\" type=\"int\" required=\"true\"/>\n    <returns type=\"bool\">true</returns>\n    >>> check(49)\n    <function check of <type 'function'> object at 0x7f9b7a4c1b28>\n    <param name=\"n\" type=\"int\" required=\"true\"/>\n    <returns type=\"bool\">false</returns>\n    >>> check(78)\n    <function check of <type 'function'> object at 0x7f9b7a4c1b28>\n    <param name=\"n\" type=\"int\" required=\"true\"/>\n    <returns type=\"bool\">true</returns>\n    >>> check(79)", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def main():\n    \"\"\"main()\n    def fizz_buzz(n):\n    return n*11 if n%11 == 0 else n*13 if n%13 == 0 else 1\n    return fizz_buzz(15)\n    \"\"\"\n    for n in range(1, 100000):\n    main()\n   \nHere is my FizzBuzz implementation in C++11:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    for i in range(n):\n         if i % 11 == 0:\n            return i\n         if i % 13 == 0:\n            return i\n    return 0</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    for i in range(2, n+1):\n        if n % 11 == 0 or n % 13 == 0:\n           return i\n    return 0\n`CODE_PASTE`</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    \"\"\"\n    def fizz_buzz_two(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz_two(50)\n    0\n    >>> fizz_buzz_two(78)\n    1\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    def fizz_buzz_three(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz_three(50)\n    0\n    >>> fizz_buzz_three(78)\n    1\n    \"\"\"\n    \"\"\"\n    def fizz_buzz_five(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> f", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n - (n % 11) + (n % 13)\nI can't tell you how many hours of my life I've spent writing and rewriting and testing for a bug in that one line of code.\n\nCould you elaborate? You're subtracting 11 or 13 from the input, then adding it back?\n\nThat's what I was wondering. The poster might have meant n-1\n\nYup. I think you have to subtract the ones that aren't divisible by 11 or 13.\n\nI'm actually not sure you need the subtraction at all. It's just a list of all numbers divisible by 11 and 13.\n\nNot sure if it's a bug, but it seems like the wrong logic is being used here:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n\n\n>>> a = fizz_buzz(11)\n>>> a\n0\n>>> a\n0\n>>> b = fizz_buzz(13)\n>>> b\n2\n\nHere is another example:\n>>> fizz_buzz(15)\n2\n>>> fizz_buzz(15)\n2\n>>> fizz_buzz(14)\n3\n>>> fizz_buzz(16)\n5\n>>> fizz_buzz(17)\n7\n>>> fizz_buzz(18)\n9\n>>> fizz_buzz(19)\n11", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n       if n == 0:\n          return 1\n       else if n < 11:\n           return fizz_buzz(n - 1) + fizz_buzz(n - 2)\n       else:\n           return fizz_buzz(n - 1) + fizz_buzz(n) + fizz_buzz(n - 2)\n    return n\nI feel like this would be the most commented line in the code. I would want it to be the first line but I'm not sure that's allowed?\nThere are no rules on the first line, but the best practice is to use it to indicate what the program is doing. I don't think most people would say that's what this program is doing.\nWhat would you put in its place? I'm a beginner\nfizz_buzz(int n) ->\n            if n == 0:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\nI think this is really cool. I'm an old (and boring) dinosaur, and I actually like the fact that the OP is able to produce this. I imagine that is how some people feel about the games you see with a ton of programming behind them.\n\nI'm not sure what you're referring to as boring - it's an assignment that's pretty straight forward and using the built-in classes is the obvious way to do it.\nI think if you're in your 20s you probably came to Python after learning how to program in something else, so you've seen how to do this kind of stuff before. But it's still an interesting exercise for a beginner because it shows how you can use the built-in classes to solve a very specific problem.\n\nI was referring to myself as boring. The OPs code was clean and well written. My code, on the other hand, is full of messy strings and for loops, and is generally an ugly hack. I'm not sure what it says about me that I find the OPs code boring, but I think it says something about how far I am from being a decent programmer. I'm ok with it.\n\nI see.\nI actually don't think you", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    if n%11 == 0:\n        return fizz_buzz(n%11)\n    else:\n        return fizz_buzz(n%13)\n\nIn python3 this works fine:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n == 0:\n         return 0\n    else:\n         return n * fizz_buzz(n - 2) + fizz_buzz(n - 3)\n\nSo, this seems like an interesting exercise to me.\nIn a non-pythonic way, you could write it as a recursive function that generates the result on the fly (instead of hardcoding the values of 'n' and 'fizz_buzz').\n\nNot sure what you mean, but it doesn't look recursive to me.\n\nIn fact it is. It's similar to the following function, which is recursive:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return [n-1, n-1, n-1, n-1, n-1]", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\nP.S. For a really \"meta\" take on this, look at the program itself. :)\n\nPython has a few of these.\nfizzbuzz:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return len(range(0, n+1) / (n+1))", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def __call__(self, n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(n)\n    50\n    >>> fizz_buzz(n + 1)\n    51\n    \"\"\"\n    for i in range(n):\n       if i % 11 == 0:\n          return i\n       else:\n          return i % 13 == 0\n    return i\n\nI would say it is not a good code.\nThis one is much simpler:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def fizz_buzz_n(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz_n(50)\n    0\n    >>> fizz_buzz_n(78)\n    2\n    >>> fizz_buzz_n(79)\n    3\n    \"\"\"\n    def fizz_buzz_m(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz_m(50)\n    0\n    >>> fizz_buzz_m(78)\n    2\n    >>> fizz_buzz_m(79)\n    3\n    \"\"\"\n    return 1\n\nI'm getting a syntax error. This is my python 2.7.11:\n>>> import fizz_buzz\n>>> f", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n         if n < 6:\n            return 0\n         else:\n            return n*(n+1)/11\nI understand this is somewhat of a joke, but if you are going to write an article on programming languages, please use the language for which you are writing the article.\nI can't take an article seriously if the author can't even be bothered to do so themselves.\n\nI think this might be useful for beginners. Writing your first interpreter for a small language is a good way to get your head around things. It also makes for a nice introduction to the REPL, since you can write some code and hit return to try it out.\n\nI think you can get more out of it if you make it a bit more realistic. I like to make a language for a simple game and write a basic interpreter. Then you can try it out and see what happens. You also get a much better understanding of the language when you do this.\n\nThe first time I looked at a language specification was for my first interpreter. I wanted to see how it", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return int(str(n).find(\"7\")).ceil\nThe Python approach is more efficient and safer, IMHO.\n\nIt's not more efficient, but it is safer, and arguably more readable.\n\nI'd argue the Python code is more readable. You can see exactly what it does without having to run it.\nThe Perl one is more efficient, though.\n\nI like how readable this is:\nsub fizzbuzz(@ARGV) {", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def number_of_times(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> number_of_times(78)\n    2\n    \"\"\"\n    a: int\n    b: int\n    while n >= 0:\n       if n % 11 == 0:\n          return a + fizz_buzz(n - 11)\n       else:\n          return b + fizz_buzz(n - 11)\n    n -= 2\n    return number_of_times(n - 1)\n\nPython implementation", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return sum(range(n, 2) % 11) + sum(range(n, 2) % 13)\nI don't get it. Am I missing something?</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\n>>> fizz_buzz(100)\n    3\n>>> fizz_buzz(100000)\n    50\n>>> fizz_buzz(1000001)\n    49\n\nYou can use `fizz_buzz` in Python 3.5+:\n>>> fizz_buzz(100)\n    3\n>>> fizz_buzz(10000)\n    49\n\nA simpler version is available in Python 3.3+:\n>>> fizz_buzz(n)\n          if n > 0:\n             return n * 11\n          else:\n            return n % 13\n\nThis is not an issue with the language but with the interpreter. This can be achieved in any language.\n\nHere is a javascript implementation:\nfunction fizzBuzz(n) {", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\nThis is cool, but it's not hard to write a brute force solution (with a for loop, it takes about 13 seconds on my MacBook Pro)", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for i in range(n+2):\n        if n % 11 == 0:\n           count += 1\n          else:\n            count += 1\n    return count\nI might be missing something here, but I think the answer is zero. If you divide a number by 11, you get a remainder of 0. If you divide that number by 13, you get a remainder of 0. There is no way to get a remainder of 7.\n\nAnd, if you divide a number by 13, you get a remainder of 1.\nI think it should be:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_b", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n &lt; 4:\n       return 0\n    else:\n       return len(set(n, 0, 11, 13))\n\nhaha. i like this one.", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return n - 2\nIn Python, the semicolon at the end of the line is not optional.  It is an operator which terminates the statement.  You are not doing anything with the value of n, so you don't need it.\n\nSemicolons are optional in Python, just not for statements (this is the convention, but it's not enforced).\n\nIt is a matter of style but it is not a convention. You can look up the PEP that discusses it.\n\nTruly. The best style for python is to use semicolons in all your code. If you want a python style that is in any way portable or reusable, use semicolons.\n\nI would argue that the best style for Python is one that is easy to read and maintain by other people.\nSemicolons make code harder to read and maintain by other people.\n\nI would argue that the best style for Python is one that is easy to write and maintain by you.\nSemicolons make code easier to write and maintain by you", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\nIf you look at the code, it uses division by 11 to compute the number of occurrences of 7. But then it uses multiplication by 11 to find the number of occurrences of 7. Is that a typo?\n\nThis was in the \"Why is FizzBuzz so popular?\" article from a couple weeks back. My guess is that the author is using a bit-twiddling approach, where division by 11 is a shift-right-by-11 and multiplication by 11 is a shift-left-by-11.\n\nThe question was more directed at why the multiplication is being used, instead of a shift. If you look at the code, it seems like the programmer is taking the modulus of the result and multiplying by 11.\n\nHere's another fizzbuzz program: \n\nI'm also writing one. There's a lot of room for improving the trivial one, and I will probably post it when I have it.\n\nThat's a bit of an unfair criticism, fizzbuzz is not a \"real world\" problem. It is meant to be a silly interview question, and a way to sort out people who don't know what they are talking about. It's not something you would use in production", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def fizz_buzz(n):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    if n & 1:\n       return 0\n    for i in range(0, 11):\n       for j in range(0, 13):\n         if i mod 11 == 0 and i mod 13 == 0:\n             return i\n    else:\n             return 0\n\nThis is beautiful and should be part of a regular fizz buzz question, though it would be more fun to read if it was done in python.\n\nThis is the best example of the multiple interpretation of \"idiomatic\" I've seen", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n*(7*11+7*13)\nMore to the point, a function like this is usually going to be used in an environment where you have access to a `stdlib.h` (or some other std library) which already has a `fmod()`.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    n = int(input('Enter a positive integer: '))\n    for i in range(1, 10):\n       n -= i\n    if n == 0 or n == n - 1:\n       return 0\n    if n % 11 == 0 or n % 13 == 0:\n       return n\n\nThe other option is to use a dictionary.\n\nPython is a wonderful tool, but it's a tool, and it's not always the right tool.\n\nThis is nice for a couple of reasons. The first is that it gives you a full suite of tools for making an algorithm that is potentially more readable than one implemented in code. This is important because the goal in algorithms isn't to write the most concise code, it's to write the most readable code.\nThe second is that it lets you write your algorithm with the help of your code. It's very common to get to the end of an algorithm and realize you forgot something. It's much easier to go back and modify the algorithm using the code as a reference than to modify the code using the algorithm as a reference.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n         return n % 11\n         return n % 13\nAs a programmer, I don't think I've ever written a string of code as unappealing to me as that. I could do it, but I certainly don't want to.\n\nThere is a nugget of a good idea in there, though. The \"numbers less than\" is a great way of forcing a problem into a specific form. It's a shame it's wrapped in so much hideous code.\n\nI was going to say, \"so you'll have to write the same code once, and then it'll be reusable everywhere.\"\nWhich is basically what you said.\n\nRight.\n\nInteresting. One of the things that I really like about the Haskell language is the built in ability to define functions recursively. So instead of writing a function that defines a function that defines a function, I'd be able to do this:\nfizz_buzz :: ( Int, Int ) -> Int\nfizz_buzz n = n `mod` 11\nfizz_buzz n = n `mod` 13\n\nI am in no way a Haskell", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n == 0? 1 : n == 1? 0 : n == 2? 1 : n == 3? 2 : n == 4? 3 : n == 5? 4 : n == 6? 5 : n == 7", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n % (11 * 11) + 13\n    print fizz_buzz(1)\n    print fizz_buzz(2)\n    print fizz_buzz(3)\n\nThe Python equivalent:\n>>> def fizz_buzz(n):\n        return n % (11 * 11 + 13)\n        print fizz_buzz(1)\n        print fizz_buzz(2)\n        print fizz_buzz(3)\n>>> fizz_buzz(2)\n3\n>>> fizz_buzz(3)\n3\n>>> fizz_buzz(4)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: division by zero\n>>>\n\nThe Ruby version:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return sum(xrange(n) for x in (0,11,13)[::-1])\n    %\n    def palindrome(n: int):\n    \"\"\"Return True if n is a palindrome.\n    >>> palindrome(78)\n    True\n    >>> palindrome(25)\n    False\n    >>> palindrome(94)\n    False\n    >>> palindrome(85)\n    True\n    \"\"\"\n    return n % 2 == 0\n    %\n    def is_prime(n: int):\n    \"\"\"Return True if n is prime.\n    >>> is_prime(14)\n    True\n    >>> is_prime(89)\n    False\n    >>> is_prime(99)\n    True\n    >>> is_prime(99)\n    False\n    >>> is_prime(98)\n    True\n    >>> is_prime", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def divisible(n: int):\n    \"\"\"Return True if n is a multiple of 11 or 13.\"\"\"\n    return n % 11 == 0 || n % 13 == 0\n    def is_divisible(n: int):\n    \"\"\"Return True if n is divisible by 11 or 13.\"\"\"\n    return n % 11 == 0 || n % 13 == 0\n    def fizz_buzz(n: int):\n    \"\"\"Return True if n is divisible by 11 or 13.\"\"\"\n    return divisible(n) or is_divisible(n)\nYou've never had to interview anyone for a programming job, have you?</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return int(if(n % 11!= 0): n else: fizz_buzz(n - 10)) + int(if(n % 13!= 0): n else: fizz_buzz(n - 9))\nWhat's the point of the 2nd if statement?\nWhat's the point of the first if statement?\nThe first one is for the first n.  The second is for the second n.  The second is there because the first n is divisible by 11 or 13 and the second n is not.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    n, err = (n, '', \"no solution\")\n    if n <= 0:\n         return 0\n    if n <= 1:\n         return 1\n    if n <= 2:\n         return 2\n    if n <= 3:\n         return 3\n    if n <= 4:\n         return 4\n    if n <= 5:\n         return 5\n    if n <= 6:\n         return 6\n    if n <= 7:\n         return 7\n    return n\n\nI have to say I am not a fan of this solution. It is inelegant, it's hard to read, and it's not very clear what the intent of the code is. It's also needlessly verbose:\nfizz_buzz = lambda n:\n    if n <= 0:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    return [0, 1, 2, 3]\n    if n % 11 == 0\n    else\n    return [0, 1, 2, 3]\n    else\n    return [0, 1, 2, 4]\n    def fizz(n: int):\n    \"\"\"Return the number of times the digit 3 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz(49)\n    2\n    >>> fizz(74)\n    5\n    >>> fizz(77)\n    6\n    \"\"\"\n    return [0, 1, 2]\n    if n % 11 == 0\n    else\n    return [0, 1, 2]\n    else\n    return [0, 1, 2, 3]\n    def buzz(n: int):\n    \"\"\"Return the number of times the digit 11 appears in integers less than n which are divisible by 11 or 13.", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return 0 if n > 1 else 1 if n % 2 == 0 else fizz_buzz(n - 2)\nI don't think this is in the spirit of the question. This is just a re-write of the same logic the OP has already implemented.\nIt's not intended as a fix for his problem. He's implemented the logic for the input cases he's tested, but he's asking if there's a way to handle the cases he didn't test.  It's a hint that he should try testing the same logic on inputs he didn't test.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def fizz_buzz_choose(n: int):\n    \"\"\"Return a list of three numbers which contain the correct digit counts.\n    >>> fizz_buzz_choose(3)\n    [ 0, 1, 2 ]\n    >>> fizz_buzz_choose(4)\n    [ 1, 2, 3 ]\n    >>> fizz_buzz_choose(5)\n    [ 1, 3, 7 ]\n    \"\"\"\n    def fizz_buzz_map(n: int, result: list[int]):\n    \"\"\"Return a list of the digits 0-9, with the correct counts for fizz buzz.\n    >>> fizz_buzz_map(3, [1, 0, 2])\n    [ 1, 0, 2 ]\n    \"\"\"\n    def fizz_buzz_split(n: int):\n    \"\"\"Return a list of lists, which correspond to the digits 0-9.\n    >>> fizz_buzz_", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\nfizz_buzz(n: int) -> int", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    for i in range(n):\n       if i % 11 == 0 or i % 13 == 0:\n          return i\n    return 0", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n%2 == 0:\n       n = int(n) / 2\n    return n", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    for i in xrange(n):\n         if i % 11 == 0:\n            return i\n          if i % 13 == 0:\n             return i\n    return 0\n\nOne case where Python is _much_ better than Perl:\n\nPerl may be able to do this in a few more lines of code, but Python is also a lot easier to maintain.\nI wouldn't write code like the Perl solution, but the fact that it can be done doesn't mean much to me.\n\nWell, you still have to maintain the docstring. You can even write this in one line in Perl:\nsub fizz_buzz {\n($a,$b) = (@_);\n($a % 11 == 0) and ($a % 13 == 0)\nor ($a =~ /7/);\nreturn $a if $a eq 11;\nreturn $b if $a eq 13;\n}\nOr, a little shorter:\nsub fizz_buzz {\n($", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    for d in range(0, n):\n    if d % 11 == 0 or d % 13 == 0:\n       return d\n    else:\n       return -d\nThis code is part of the python standard library.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return sum(zip(*0.1 for _ in range(0,n-1) if n%11 == 0 else 0 end for _ in range(n-1,11)) for _ in range(n,11))\nThis is exactly what I needed. Thank you.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    n, a, b = int(input(\"Enter a positive integer: \"))\n    if n == 0:\n        print(\"That number isn't divisible by 11 or 13\")\n    else:\n        for i in range(1, n):\n          if a % i == 0 and b % i == 0:\n             return a\n    else:\n          return a\n    print(\"\\nFizzbuzz for \", n, \"is \", fizz_buzz(n))\nThat's an awful lot of ifs for something so trivial.\n\nI've seen this joke around for a while, but I've never seen the python implementation. I've always wondered how much performance one could get back by making a recursive version of it, and using a lookup table for the number of times each digit appears.\n\nI've done it in Common Lisp, if you're interested.\n\nWell, yes, I'm interested! Link please :)\n\nHere", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n <= 1:\n       return 0\n    return int(ord(n) % 11) + int(ord(n) % 13)\n    print fizz_buzz(50)\n\nI was going to write something like this, but you beat me to it :)\n\nI love python, but this is such a cool way to approach the problem.\n\nI'm not sure why people are upvoting this. It's a joke, not a code example. The answer is trivial.\n\nA lot of the answers are trivial. The point is to show that you can write the solutions in the language.\n\nI'm not sure how I feel about this. It's an obvious joke. And I know a lot of people are going to take it seriously and upvote it to the top.\n\nI thought it was amusing. It's a joke. If people upvote it, they're upvoting a joke.\n\nI like the idea of this joke, but I feel that it should have been more carefully executed. For example, by using an integer literal instead of a variable:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n - 11\n\nAs a CS grad, I have to admit, this was the first time I had seen the difference between __int__ and __str__.\n\nI don't really understand the difference. Can someone explain it to me?\n\nint(x) looks up the value of x in an int table.\nstr(x) looks up the value of x in a string table.\n\nOk, I understand that. I guess the reason I don't understand is because I didn't realize that string tables are a thing. Thanks for the response.\n\nThey are not a thing, it is just a joke.\n\nPython has this in the standard library as the fizzbuzz function:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n <= 0:\n        return 0\n    if n > 1:\n        return n - 1\n    return 1 if n % 11 == 0 and n % 13 == 0 else return 0\n\nNow I've never learned C but I'm assuming this is not idiomatic C.\nIt was written by someone who has never read the C specification and doesn't know about templates or rtti.\n\nIt's a total mess, that's what it is.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def main():\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> main()\n    0\n    >>> main()\n    2\n    >>> main()\n    3\n    \"\"\"\n\nThis is a function that takes a number n, and returns the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\nNote that this function is not a complete solution to the fizz buzz problem, which is a subset of this problem (which is why it's okay to return a value of 0). Also note that this function is not a complete solution to the main problem, which is the problem of fizz buzz.\n\n    def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return num if n % 11 else return n % 13\nNot sure what this is trying to say.  Could you try again?\nn is the integer you want to check.  So if you want to check if n is divisible by 11 or 13, and you want to know if there is a 7 in that number, you use this function.  It returns the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\nI think it was supposed to be a joke?</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\n    def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n\n           return(n/11 + n/13)\n\nWhich language/environment is that?\n\nThe language is Python. I think that's the standard library.\n\nPython is indeed the standard library.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\nIn Python 3, the following is faster:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n <= 1 or n == 2:\n        return 0\n    return fizz_buzz(n - 1) + fizz_buzz(n % 11) + fizz_buzz(n % 13)\n\nIt's not that hard to make this a one-liner.\n\nThis was my first Python program, so I wasn't sure how to do that. I changed it though!\n\nOne-liners aren't a very useful skill when you're starting out. The trick is that you can't put a single line of code on a single line.\n\nThe original is a one liner.", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return int(n * 11 + 0) / 13\n\nI'm not seeing it.\n\nIt makes it a little more obvious when you add the fact that the function is named after a common programming interview question.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n <= 0:\n        return 0\n    else:\n        return int(n) % 11 + int(n) % 13\n\nThere's a reason that kind of stuff has been written in the past: it's much more readable.\n\nSure, but that's only one advantage. For example, fizzbuzz also works when the input is a float, and it also deals with a lot more edge cases.\n\nThe best solution to this problem is to convert to an int and use built-in modulo arithmetic.\n\nI think this is the best solution, since it's a standard approach that's very well tested. But the point of the post was that it's not the only approach.\n\nThe point of the post was to show the nice things you can do with generators.\n\nI don't agree. The article's title is \"How to write a program in one line\", and the article itself talks about the problem in terms of programming.\n\nThe main point of the post was to show the nice things you can do with generators, and I think it was well done.\n\nIf your criteria for", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\n Not a \"little known fact\" in my book.\nYeah, this is well-known, and is taught in many (most?) introductory programming classes.\nIf fizz buzz is so well-known, why is it so uncommon to find someone who can do it?</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n < 10:\n       return 0\n    return 1 if n % 11 == 0 else 1 + (n % 11) * fizz_buzz(n - 10)\nI really should stop posting when I'm drunk.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    # fizz_buzz.py\n    from __future__ import print_function\n    from __future__ import division\n    from itertools import islice, izip, dropwhile\n    from random import randint\n    from collections import OrderedDict\n    from random import randint\n    from random import randint\n    # The OrderedDict class\n    class OrderedDict(object):\n    \"\"\"\n        a collection of ordered objects that can be sorted", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n%11 + n%13\nYou can also have it return just the first time it finds a number that is divisible by 11 or 13, but I like the way this one returns the total number of times.\n\nThis is the correct answer. I would add that it's easy to understand when you do it this way:\nfizz_buzz(11) == 11\nfizz_buzz(13) == 12\nfizz_buzz(16) == 0\nfizz_buzz(20) == 1\nfizz_buzz(21) == 2\nfizz_buzz(22) == 3\nfizz_buzz(23) == 4\nfizz_buzz(24) == 5\nfizz_buzz(25) == 6\nfizz_buzz(26) == 7\n\nIt's even easier to understand if you think about how it works.\nfizz_buzz(11) == 11\nfizz_buzz(13) == 11+1 = 12\nfizz_buzz(16) == 11+1+1 = 12+1 = 13\nfizz_buzz(20)", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\nThat's not \"fizzbuzz\", it's \"fizzbuzz_n\".\n\nWhat's the difference?\n\nTo put it simply: The title is \"fizzbuzz\".\nThe name of the function in the article is \"fizzbuzz_n\".\nThere's a subtle difference there.\n\nYou are right. You could say that there is no difference. But the way I interpret \"fizzbuzz_n\" is that you are doing this same logic for a _n_ value between 0 and n-1 and you are asking for the result of that.\n\nThe difference between \"fizzbuzz\" and \"fizzbuzz_n\" is not whether or not you are doing it for a range of values, but rather whether or not it's the first number of a sequence of functions, and whether or not you are doing it for every n.\nThere's a subtle difference there.\n\nNow that you mention it, that's the difference between \"fizzbuzz\" and \"fizzbuzz_n\".\n\nIsn't this a bit of a fizzbuzz of fizzbuzz?\n\nNo, because fizzbuzz is", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n >= 11? 1 : 0\nI'm guessing the 1 vs 0 is due to Python's interpretation of `n >= 11`, which returns 1. In that case, you might want to change the function to return `(n+1)` instead.\n\nThanks!\n\n_a = [1,2,3,4,5,6,7,8,9,10]", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    for i in range(0, n+1):\n       if n%11 == 0 or n%13 == 0:\n          return n\n    return 0\nNice! I would probably put some commenting to explain what it does, but it's a bit hard to explain without explaining the code.\n\nAdded some comments...thanks!</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\nReferences\n\nExternal links\n Part of the documentation for the \"Python Quiz\" by Bruce Eckel</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    n=n-1\n       return n*(n%11)+(n%13)\nI understand the code but what is the use case?\nThis is one of the most common interview questions. If you are interviewing for a Python job you need to know this.\nWhat's the advantage of using n*(n%11)+(n%13) over n?\nIt's a programming-for-python interview question, not a python-for-programming interview question. The goal is to solve the problem in python (hence the \"def fizz_buzz\" function), not to use python to solve the problem.\nBy that reasoning, an interview question that requires you to build a linked list with your own implementation from scratch is a linked-list-for-python interview question, not a linked-list-for-programming interview question.\nNot really, in this case, you're expected to use the built-in operator syntax and do all the bookkeeping yourself. The advantage of using n*(n%11)+(n%13) is that it's a bit more self-contained.  The problem itself is not particularly Python-related, it", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def pyth(p: int) -> int:\n    \"\"\"Return the number of digits in p.\n    >>> pyth(99)\n    99\n    >>> pyth(99, 3)\n    99\n    >>> pyth(99, 3, 2)\n    99\n    >>> pyth(99, 3, 2, 2)\n    99\n    \"\"\"\n    def solve(n: int, p: int, divisor: int) -> int:\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> solve(50, pyth(99), 11)\n    0\n    >>> solve(50, pyth(99), 13)\n    2\n    \"\"\"\n    n = int(input(\"Enter number of times to check: \"))\n    p = pyth(n)\n    divisor = divisor or 3\n    pyth(p)", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    >>> fizz_buzz(78)\n    5\n    >>> fizz_buzz(79)\n    4\n    \"\"\"\n    return n / (n % 11) + (n % 13)\n\nfor loop and recursion are very similar but not the same. I would call this a recursive function because it calls itself (which is a requirement of recursion).\nFor example, fizz_buzz is a for loop, while factorial is a recursive function.\n\nI'd call this a for loop because the implementation is in a for loop, and not a function.\n\nThis is a very good question, but it's been asked a lot of times before. Maybe you can search for it.\n\nThe reason that is true is that a computer", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\n    return n - (n % 11) + (n % 13)\n\nI don't see how that is an improvement over the fizzbuzz function in the standard library.\n\nAh, I guess the point is that the standard library's version is implemented in C, so it might be slower than a Python function?\n\nGood point. My response was meant to be tongue-in-cheek, but since you mention it, I'm going to try to write a version that's faster than the standard library's.\n\nThe standard library's version is only ~400 lines long. I'm not sure it can be written much faster than that.\n\nI've never looked at the code, but I figured the usual rule of thumb for Python was \"for anything vaguely complex, it's probably possible to write it faster in C.\" I hope I'm right.\n\nYou might be right. I've never tried it, so I don't know.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def fizz_buzz(n):\n    if n % 11 == 0:\n       return n\n    if n % 13 == 0:\n       return n\n    return fizz_buzz(n - 1) + fizz_buzz(n - 2) + fizz_buzz(n - 3)\n\nFor more examples of FizzBuzz, see here: \n\nThis is a good example of a coding challenge. It is very simple, but does test certain skills.\n\nIt also highlights the need for a good testing environment when coding challenges are used as an interview.\n\nWhy? All he had to do was run the code on an input of 50 or whatever number he was supposed to use.\nI mean I think it's fine to test an applicant's code to a certain extent. I don't see the problem with asking them to write a simple program like this, then testing it to make sure they didn't accidentally leave out some important logic.\n\nI didn't mean to say that this would necessarily cause a problem, I meant to say that it highlights the need for a good testing", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def __init__(self, n: int):\n    \"\"\"Create a new Fizz Buzz object.\n    >>> fizz_buzz = fizz_buzz(25)\n    >>> fizz_buzz(25)\n    0\n    >>> fizz_buzz(25)\n    1\n    >>> fizz_buzz(25)\n    2\n    \"\"\"\n    self.n = n\n    def next(self):\n    \"\"\"Return the next integer that is divisible by 11 or 13.\n    >>> next(fizz_buzz)\n    13\n    \"\"\"\n    if self.n % 11 == 0:\n        return self.n\n    if self.n % 13 == 0:\n        return self.n\n    return self.n / 11\n\nPython version:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\n        def fizz_buzz(n: int):\n           return n == 0? True : n == 1? True : n == 2? True : n == 3? True : n == 4? True : n == 5? True : n == 6? True : n == 7? True : n == 8? True : n == 9? True : n == 10? True : n == 11? True : n == 12? True : n == 13? True : n == 14? True : n == 15? True : n == 16? True : n == 17? True : n == 18? True : n == 19? True : n == 20? True : n == 21? True : n == 22? True : n == 23? True : n == 24? True : n == 25? True : n == 26? True : n == 27? True : n == 28? True : n == 29? True : n == 30? True : n == 31? True : n == 32? True : n == 33? True : n == 34? True : n == 35? True : n == 36? True : n == 37", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    n_times = int(input(\"enter a number: \"))\n    if n <= 1:\n       return 0\n    else:\n       return n_times * (n%11) + (n%13)\n\n>>> fizz_buzz(78)\n2\n>>> fizz_buzz(79)\n3\n>>> fizz_buzz(80)\n4</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n\nIf fizz_buzz(50) returns 0, then 49 is a divisor of 11 or 13.\n\nNo, that's not the problem. The problem is that fizz_buzz(n) could return something other than 0 (or 1), which is not a divisor of 11 or 13.\n\nYour solution to the problem says that fizz_buzz(n) always returns 0 or 1, so you can't have a non-zero value.\n\nThe problem doesn't say that fizz_buzz always returns 0 or 1. The problem says that fizz_buzz returns the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n\nIf fizz_buzz(50) returns 0, then 49 is a divisor of 11 or 13.\n\nIf fizz_buzz(50) returns 2, then 49 is not a divisor of 11 or 13.\n\nIn fact, fizz_buzz(50) could return any integer, regardless of whether 49 is a divisor of 11 or 13.\n\nThe problem is that fizz_buzz", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def fizz_buzz_tuple(n: int):\n    \"\"\"Return the tuple of fizz_buzz numbers.\n    >>> fizz_buzz_tuple(n=50)\n    ('0', '2', '3')\n    >>> fizz_buzz_tuple(n=78)\n    ('2', '3', '3')\n    >>> fizz_buzz_tuple(n=79)\n    ('3', '3', '3')\n    >>> fizz_buzz_tuple(n=100)\n    ('0', '2', '3', '3')\n    \"\"\"\n    def fizz_buzz_as_numbers(n: int):\n    \"\"\"Return the list of fizz_buzz numbers.\n    >>> fizz_buzz_as_numbers(50)\n    ('0', '2', '3')\n    >>> fizz_buzz_as_numbers(78)\n    ('", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n == 0? 0 : n % 11 == 0 || n % 13 == 0\n    @param n: The number of integers in the range 1 to n.\n    @return: The number of integers in the range 1 to n which are divisible by 11 or 13.", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\nI assume that you want to test the code?", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    for i in range(1, n+1):\n        if n % 11 == 0 or n % 13 == 0:\n           return i\n    return 0\nThis is why I don't do programming competitions.\nBecause you need to learn to do things without a computer?\nBecause it's a waste of time.\nUnless you enjoy it.\nI don't. I much prefer working on real projects.\nDon't be so presumptuous. I enjoy competing.\nI said \"I\". I didn't say \"nobody\". You're the one being presumptuous.\nYou were still being presumptuous. You made a sweeping statement, I made a sweeping statement.\nOkay, so how about I rephrase: \"I much prefer working on real projects *and don't enjoy* programming competitions\".</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n - 11 if n < 0 or n - 13 if n > 0\nI don't think it's possible to create a function with a name that's more of a buzzkill than fizz_buzz.\n\nI think it's meant to be a test to see if someone actually knows what a fizz buzz is. It's not a good test, but it's a test.\n\nIf you want to know if someone is familiar with the concept of FizzBuzz, just ask them what the first four numbers are in the Fibonacci sequence.\n\nI wouldn't. I don't remember and I'm not willing to Google it.\n\nThen why on earth should anyone want to hire you?\n\nYou are forgetting that he's probably already hired.\n\nFizzBuzz is the first code-test I give all my interviewees. I try to make them solve it while talking to me. If they can solve it in a few minutes, we're done.\n\n\"If I can't solve it in under a minute, I'm not taking the job.\"\n\nFizzBuzz is a good test for people who know how to think algorithmically, but you need to test for more", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n<=0:\n        return 0\n    return n%11 if n%11==0 else n%13\nI'm not a python programmer (I use it for some of my work, but I'm still learning the basics) but shouldn't that return 1? The first two values are 0, and the third is 3.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return int(num / 11) + int(num / 13)\nNice. I usually do it the other way around though, so I'll use that now.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\nI don't get it. What does the program do?\n\nIt will print the numbers 0, 2, and 3, and it will print them in the reverse order.\n\nOkay. I figured that out, but I didn't see how that could be described as 'fun'.\n\nIt's not supposed to be.\nI could make it be more fun by making it print out the fibonacci numbers, but that's not the point.\nI could also make it print out the first digit of the Fibonacci numbers, which would be more fun.\nIt's just a toy example that I use to show people how to do functional programming.\n\nI didn't know that it was your example. Sorry.\n\nI wrote a Python version of this a while back. It's almost identical, but also has a silly feature of always returning \"fizz\" when passed a 0.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def fizz_buzz_all(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz_all(50)\n    0\n    >>> fizz_buzz_all(78)\n    2\n    >>> fizz_buzz_all(79)\n    3\n    \"\"\"\n    def fizz_buzz_odd(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz_odd(50)\n    0\n    >>> fizz_buzz_odd(78)\n    2\n    >>> fizz_buzz_odd(79)\n    3\n    \"\"\"\n    def fizz_buzz_even(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    n = int(input(\"Enter a number to test: \"))\n    for n in range(1, 50):\n        if n % 11 == 0:\n            return n\n         if n % 13 == 0:\n            return n\n    return 0\nIn Python 3, use      n = int(input(\"Enter a number to test: \"))\n\nWas about to say the same.\nA better version would be:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    for i in xrange(n+1):\n        return i == 7\n    return 0\nfizzbuzz.py</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    # This function is equivalent to n*11 + (n/2)*13\n    for c in range(n):\n        if c%11 == 0:\n           return n*11 + (n/2)*13\n         else:\n           return fizz_buzz(c/10)\nThat is not a pythonic solution.  It is not equivalent to n*11 + (n/2)*13.  It is equivalent to n*11 + n/2.  That is, if n is 50 then the function is equivalent to n*11 + 50 and if n is 78 then the function is equivalent to n*11 + 78.\nThis is not a problem with fizz buzz.  It is a problem with range.  The range operator is the same as \"for i in range(1, n):\".  In other words, it is like writing \"for i in range(1, i):\".\nIt is quite easy to write a pythonic solution.  See the answer given by kyubey", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    for i in range(n):\n       if n % 11 == 0 or n % 13 == 0:\n          return i\n\nIt returns the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n      def div_by_11(n: int):\n         return n % 11\n         def div_by_13(n: int):\n          return n % 13\n          def fizz_buzz(n: int):\n          if div_by_11(n) or div_by_13(n):\n              return 1\n            else:\n               return n\n    return fizz_buzz(n)\n\nThis function is used to see if a string is a palindrome:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n == 2? 1 : n % 11 + 1 % 13\n\nI prefer the version that uses C++11 (and not C99) arithmetic:\nint main() {\n  std::string s = \"fizz\";\n  int n = s.size();\n  auto fizz_buzz = std::min(s.find(cx), n - 11, n - 13);\n  return fizz_buzz();\n}\n\nYes, it's less code and using C++11 makes sense.\n\nI think the example is wrong.\nint main(int argc, char** argv) {\n    fizz_buzz(argv[1]);\n}\nThis is only true if fizz_buzz is a function pointer.\nI would expect the following to be true:\nint main(int argc, char** argv) {\n    fizz_buzz(argv[1]);", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n >= 0 and n <= 10:\n        return n / 11 + n / 13\n    else:\n        return n / 11 - n / 13\n\nAlways one of the top answers in these kinds of questions, which makes me wonder how much sense it makes to teach fizzbuzz to new programmers at all. I mean, there's a reason the first \"programming assignment\" you get in a CS class is fizzbuzz. It's a nice little warmup that gets you used to the syntax and the flow of programming, but there's not a lot of new stuff to learn.\nTo me, it makes a lot more sense to have the first programming assignment be something that teaches a new concept. In particular, a \"for loop\" is a lot more interesting and useful than a \"while loop\" (even if that's what you're using most of the time).\n\nIt's really about learning to code for the sake of coding, not for the sake of learning a new language. When I was a freshman I had to take a Java class, and I remember being bored by the fact that we had to spend the first", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def fizz_buzz(n: int):\n    if n < 10:\n        return fizz_buzz(n - 1)\n    else:\n        return fizz_buzz(n - 2) + fizz_buzz(n - 3)\n    return n\nI see you don't have the same sense of humour as me</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n == 1:\n        return n\n    else:\n        if n % 2 == 0:\n            return n\n        else:\n            return sum(fizz_buzz(n/2))\nThe \"return n\" in the first case is a bug, right?\n\nNo, since you could make a function that does what the author wants:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def _parse(input: string):\n    \"\"\"Return an integer between 0 and 99.\n    >>> input = \"98\"\n    >>> _parse(input)\n    99\n    >>> input = \"5\"\n    >>> _parse(input)\n    55\n    \"\"\"\n    return _parse(str(input)) % 11 == 0\n\nIt is interesting that there is no const involved in that example.\n\nThat's because in Python there is no such thing as \"const\" (except with specific syntax from the `__future__` module). Everything is mutable by default.\n\nThat is a common misconception.\nThere are other ways to make things immutable in python without having to resort to type annotations.\n\nI'm not sure what you're trying to say here. The truth is, there is no way to make something immutable in Python without using one of the __future__ imports. None of the _normal_ ways to make things immutable (using a `final` attribute, or creating a class from a function) work.\n\nYou can use 'def' to define immutable variables. You", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n > 0:\n        return n\n    else:\n        return 0\n    return 1\nI like this code because it's the only one I could think of that's equally easy to read and write.\n\nI hate this code because it's basically useless, if it even does what it says it does.\nIt doesn't even take into account the case of a multiple of 11 or 13, which means it's just wrong.\nIt should be returning the number of cases where the first digit is a 7 in each of those cases, which is the number of times the second digit is a 1, so you end up with either 2 or 3.\n\nThe cases where the first digit is 7 in each of those cases is the number of times the second digit is a 2, so you end up with either 1 or 3.\n\nYou're right, my bad. That's what I get for trying to do a math problem after not having done math for 10 years.\n\nThe canonical example of this is the _Fizz Buzz_ puzzle, which people are posting in various forms to illustrate the point. The _Fizz", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def fizz(i: int):\n       return i % 11 == 0 or i % 13 == 0 or i % 15 == 0\n    def buzz(i: int):\n       return fizz(i + 11) + fizz(i + 13) + fizz(i + 15)\n\nThis is more or less a \"purity\" test. This is a function that returns a value (that is, a function that implements an interface), but it doesn't do anything interesting.\n\nIt doesn't produce a result that is useful in any way.\n\nIt doesn't really do anything at all.\n\nThe \"is\" operator:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return sum(map(int, range(n)) % 11 | 13)\nWhat language is this?\nProbably python.\nYes, it's python, sorry I forgot to add the comment.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\n    \"\"\"Tested on Python 2.7.3, 2.7.4, 3.3.3 and 3.4.2.\n    \"\"\"\n\n    def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n\n    def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n\n    def fizz_buzz(n: int", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    try:\n        return (fizzbuzz(n - 1) * 11 + fizzbuzz(n - 2) * 13)\n    except:\n        return 0\nThis is the correct answer. The author of the question is a dick.\nThere is a lot of this kind of crap in technical interviews. The attitude seems to be that the interviewee should be able to read the interviewer's mind, and the interviewer doesn't feel any obligation to explain the problem to the interviewee.\n\nI am a little bit ashamed that I spent so much time wondering why this would be a problem in the first place. I am not proud of myself right now.\n\nI was not sure at first whether the program's result would be 0, or an exception, but I assumed that the result would be 0 because it would be very silly to return an exception for such a trivial problem.\n\nI assume it's a kind of trick question. You get to the point where you're printing the output, then the interviewer tells you that you had a bug. The real fizzbuzz solution is supposed to be:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\nI've always wondered how other people got around this. I think my solution is slightly more efficient, but it's still not a great way to solve it.\n\nIsn't the fastest way to do this to write a generator that just counts to the maximum of the division?\n\nThe problem is that the inputs are not divisible by 11 or 13, they just have a digit that happens to be 7.\n\nI think the GP meant to say that the generator would generate the values such that the divisor was 11 or 13.\n\nYour right, my bad.\n\nSee also: \n\nI can't help but think that this is a strawman interview question.\n\nThis is not a strawman question. This is a famous algorithm that is used in many real world problems.\n\nHow is this better than brute force?</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def __str__(self):\n    \"\"\"Return a human-readable string representation of this object.\n    >>> fizz_buzz('ZZ')\n    \"\"\"\n    return \"FizzBuzz\"\n    return fizz_buzz\nThis is cool because it's easy to understand and easy to modify to print the numbers in a different order, without needing to understand any details about how it works. I think this is a good example of what a \"Pythonic\" solution to a problem looks like.\n\nThat's just a small piece of the code.\nYou need to know what \"modulo\" means.\nYou need to understand what \"divisible by 11 or 13\" means.\nYou need to know what the \"double dot\" operator does.\nYou need to understand the __str__ function.\nYou need to understand how to pass parameters to functions.\nYou need to understand how to use the ternary operator.\nYou need to understand how to use the \"return\" keyword in a function.\nYou need to understand how to use the \"if\" statement.\nYou need to understand how to use the \"for\" statement.", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return len(set(n) % 11 | set(n) % 13)\n\nI don't think this one is terribly useful for interview questions. I think it would be better to use a real-world problem like:\n\nSee also:\n\nFor the lazy:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n < 2:\n        return 0\n    else:\n        return int(n**2) - int(n%11) + int(n%13)\n\nThe error in this one is that the author didn't do his homework. It's very simple to write a version of this that works correctly, and it doesn't require any special knowledge of the library or language:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\n    #", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n\nThat's a good one.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n%11 + (n%13 == 0? 0 : 1)\n    n = n // 11\n\nOther implementations (all in Python 3):\n\nThe article doesn't mention it, but I think that's by design. This code is just an illustration of the iterator pattern, and that's not a very good way to implement fizzbuzz.\n\nIn which case, why is it that the article doesn't give any alternatives?\n\nAuthor here: If you want more alternatives (and some of the discussion here suggests that you do), here are some more:\n\nI don't know why people are so frustrated by this article. This is a very good example of how to write idiomatic Python, IMO.\nIn Python, it's much easier to write good idiomatic code than to write bad idiomatic code. Python will even help you write good idiomatic code, by helping you write idiomatic idioms. If you're frustrated with this, you should be frustrated with the language itself.\n\nIn my opinion, this is an excellent", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n % 11 == 0:\n       return n\n    else:\n       return n - 1\n    return 0\nI wonder how many people actually read the code before looking at the comments, thinking \"what the hell, this is useless\", then click to the comments to see how people are praising it.\n\nI read the code and thought \"that's a pretty stupid comment, why not just use a for loop?\"\n\nfor loops are for suckers.\n\nI'm genuinely curious - why not?</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def main():\n    \"\"\"Return the value of fizz_buzz(20)\"\"\"\n    try:\n       fizz_buzz(20)\n       print(fizz_buzz(20))\n       except Exception as e:\n       print(\"FizzBuzz Not Implemented\")\n    return", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n % 11 == 0:\n        return len(list(str(x) for x in xrange(0, 10)) if x == '7')\n    else:\n        return len(list(str(x) for x in xrange(n - 1, 10) if x == '7') - 1)\n\nHere's a minor nitpick:\nxrange(n, 10) is basically just a Pythonic way of writing n.map(x => x % 10). The output from this map is what's used in the loop.\nn % 11 is also unnecessary in the loop.\n\nYou're absolutely right, I'm not sure why you are being downvoted. The % operator is _completely_ redundant. I think the author may have been trying to use the % operator to return the remainder after dividing by 11.\nI'd also point out that I found the code more difficult to read than the traditional implementation.\n\nHow does the definition of fizz_buzz relate to the implementation? I feel like I'm missing something.\n\nIt's a pretty standard textbook example of recursion.", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\n    return n == 0? 1 : ((n mod 11) + (n mod 13) - (n mod 11)))\n\nIf you can't figure out the solution in a minute or so, you might not be the right person to hire.\n\nNot really. I'm a programmer, I didn't get it at first. It's a little misleading in that it doesn't give you the actual size of the numbers you're working with.\n\nI'm a programmer too, and I got it immediately.\nYou might not be a good programmer.\n\nI'm a good programmer and I got it immediately.\nYou might not be a good judge of other programmers.\n\nI'm a good judge of other programmers, and I didn't get it immediately.\nYou might not be a good programmer.\n\nI'm a good judge of other programmers, and I got it immediately.\nYou might not be a good judge of other judges of other programmers.\n\nAnd we have a winner!\n\nI'm a good judge of other judges of other programmers, and I got it immediately.\nYou might not be a good judge of good judges of other programmers.\n\nI'm a good judge of good judges", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n == 0:\n       return 0\n    else:\n       return 1 if n%11 == 0 else n%13 == 0\nI think this would be a bit clearer as", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    n = n or 1\n    if n >= 0:\n        return (n mod 11) + (n mod 13)", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def test_fizz_buzz(n, expected_results):\n    \"\"\" Test whether the function fizz_buzz returns the correct result for different values of n.\n    >>> import random\n    >>> test_fizz_buzz(10, expected_results = {0: 0, 1: 1, 2: 2, 3: 3})\n    Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    TypeError: fizz_buzz() takes exactly 2 arguments (n, expected_results)\n    >>> test_fizz_buzz(100, expected_results = {0: 0, 1: 1, 2: 2, 3: 3})\n    Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    TypeError: fizz_buzz() takes exactly 2 arguments (n, expected_results)\n    >>> test_fizz_buzz(101, expected_results = {0: 0, 1: 1,", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\nJust yesterday I was looking at a bit of code that had something like this:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n*11 + n*13\n\nHow would you write the fizz buzz equivalent of (for example) 15?\n\nI think I'd do it with a list comprehension:\n[1 for x in range(3) if x % 3 == 0]\n\nMe too. Maybe with the optional argument as part of the list comprehension so that you don't have to pass it to the function:\n[if x % 3 == 0 for x in range(3)]\n\nIt's worth pointing out that this is a toy problem. The point is to get people to write code that you can tell is Python, not to get people to write good or elegant code.\n\nA little more detail on the exercise:\n\nThis is a bit of a joke.\nI'm in the middle of a Python coding challenge, and one of the challenges is to write the \"classic\" fizzbuzz program. This is a very simple program that takes a number as an argument, and returns a single digit.\nThe challenge is to not use the built in print function, but to instead come up with your own implementation. The idea is that if you can't come up with a simple, one-liner,", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    from math import floor\n    def fizz_buzz_div(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz_div(50)\n    1\n    >>> fizz_buzz_div(78)\n    3\n    \"\"\"\n    return floor(fizz_buzz(n))\n\nThis is awesome.\nIf you don't mind, I'd like to add a couple things to it (if that's ok):\n1\\. I'd like to call the original function fizz_buzz instead of fizz_buzz_div. 2\\. I'd like to add support for 7 and 9.\n\nYou are welcome to use it however you like.\n1\\. I would love to have the original function named fizz_buzz, but for historical reasons, it was named fizz_buzz_div and I didn't want to break existing usage.\n2\\. I'm also not sure how to handle 9 and 7. Perhaps for 9, it", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\nSee also\n FizzBuzz\n\nReferences\n\nExternal links\n A recursive implementation of the FizzBuzz problem (Java)\n Another recursive implementation of the FizzBuzz problem (Java)</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n > 0:\n        return n*2\n    if n % 11 == 0:\n        return n*2\n    if n % 13 == 0:\n        return n*2\n    return 0\n\nSome edits:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    # Returns the digit 7 of an integer.\n    def get_7_digit(n: int):\n    \"\"\"Return the digit 7 of an integer.\"\"\"\n    return n % 11\n    # Return the number of occurrences of 7 in integers less than n which are divisible by 11 or 13.\n    def fizz_buzz_digit_count(n: int):\n    \"\"\"Return the number of occurrences of 7 in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz_digit_count(49)\n    3\n    >>> fizz_buzz_digit_count(45)\n    6\n    >>> fizz_buzz_digit_count(47)\n    9\n    \"\"\"\n    return get_7_digit(fizz_buzz(n-11)) + get_7_digit(fizz_buzz(n-13))\n\nThe following code uses two helper functions to evaluate the fizzbuzz function:\n\n    def fizz_", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n == 0? 1 : (n * 11) + (n * 13)\n\nThat's much better than the original.\n\nI read that as fizz buzz: number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\nI have no idea if it would compile and run in any language I know, but it certainly sounds like the kind of thing you'd see in Haskell.\n\nMy guess is that you're reading it as \"fizz_buzz(n: int):\" and not as \"def fizz_buzz(n: int):\".\n\nI guess I missed that. The arrow pointing to the function name usually gets my attention.\n\nThere's only one way to write a test, any other method is a waste of time.\n1\\. write the test 2\\. run it 3\\. make it pass\nI'm always amazed at people who think unit tests are going to take time, if you spend more than a minute writing one, you're not doing it right.\n\nWriting tests takes time, but the reason people think they take more time than they should is because they start writing test before they start thinking about what the", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n == 0:\n       return 0\n    else:\n       if n % 11 == 0:\n          return n / 11\n       else:\n          return n / 13\n    return n\nfizz_buzz_is_cool(100)\n\nThis is clever, but it's not the solution to the original question.\n\nI know, but it's more fun.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n%11 == 0\n    | n%13 == 0\n    | n%33 == 0\n    | n%44 == 0\n    | n%55 == 0\n    | n%66 == 0\n    | n%77 == 0\n    | n%88 == 0\n    | n%99 == 0\n\nI don't get it.\n\nThis version implements the \"puzzle\" (and has no return value, but it's a common practice in Python). I think the original post was meant as a tongue-in-cheek response to people complaining about the Python-is-too-high-level-so-you-have-to-reinvent-the-wheel problem.\n\nNot quite. I've done fizz buzz in a few languages, and all the versions I've seen (except the original) have return values of true or false. I'm curious why.\n\nIt's a way of obfuscating the fact that they're a simple implementation of a trivial problem. In a sense, it's a clever way to show off how good you are at writing a trivial function", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    n = int(input('Enter n: {0-9}'))\n    result = 0\n    while n > 0:\n        if n % 11 == 0 or n % 13 == 0:\n           result += n\n           if n % 11 == 1:\n              result += 2\n            if n % 13 == 1:\n               result += 3\n    return result\nThe function is quite simple, but I thought it was pretty clever to think of doing that (never seen it done before).\n\nI got this one from the same website:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def __init__(self, n: int):\n        self.n = n\n    def fizz(self):\n         return self.n\n    def buzz(self):\n         if n % 11 == 0:\n            return self.n\n         else:\n            if n % 13 == 0:\n              return self.n\n         else:\n             return 0\n    def fizz_buzz(self):\n         if self.n % 11 == 0:\n             return self.fizz(self.n - 1) + self.buzz(self.n - 1)\n         else:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n    def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_b", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    n = int(input(\"Enter the number of times the digit 7 appears in integers less than \"))\n    if n > 0:\n       if n % 11 == 0 or n % 13 == 0:\n          return n\n    else:\n          return 0\n\nThe left-hand side of the == operator is zero, so you need to return n rather than 0.\n\n\"Use parentheses when calling a function that is more than one line.\"\n\"Use parentheses when calling a function that is more than one line.\"\n\"Use parentheses when calling a function that is more than one line.\"\n\"Use parentheses when calling a function that is more than one line.\"\n\"Use parentheses when calling a function that is more than one line.\"\n\"Use parentheses when calling a function that is more than one line.\"\n\"Use parentheses when calling a function that is more than one line.\"\n\"Use parentheses when calling a function that is more than one line.\"\n\"Use parentheses when calling a function that is more than one line.\"\n\"Use parentheses when calling a function that is more than", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return len(int(int(int(n)))%11)%13\nI don't really get this one. Care to explain what it does?\nI think it's supposed to be:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def __call__(self):\n    return lambda x: self.fizz_buzz(x % 11)\n\nHere's a simple interpreter for it:\n\nimport itertools", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    import re\n    fizz_buzz = lambda x: re.sub(r'\\d{7}', x, 11)\n    fizz_buzz = lambda x: re.sub(r'\\d{7}', x, 13)\n\n    def main():\n        for i in range(4):\n           print(fizz_buzz(i))\n           print(fizz_buzz(i + 1))\n           print(fizz_buzz(i + 2))\n           print(fizz_buzz(i + 3))\n           print(fizz_buzz(i + 4))\n           print(fizz_buzz(i + 5))\n           print(fizz_buzz(i + 6))\n\nThe 3rd argument to fizz_b", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return 0 if n <= 0, 1 if n < 2, fizz_buzz(n - 1) if n == 2 and n < 11, fizz_buzz(n - 2) if n == 2 and n < 13\nI've heard that this is one of the hardest problems to solve.\n\nit's not that hard.", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n <= 10?\n    0 :\n    n - 10 % 11 == 0 ||\n    n - 10 % 13 == 0\n\nIsn't the space required by the function name a dead giveaway that it's not a real function?\n\nI'm not sure what you mean by \"real function\". Obviously it does something. And it's not like you're going to write this function by hand. It's just a test.\n\nIt's not a real function in the sense that it's not a real piece of code that you would use in production. For example, it doesn't have a docstring.\n\nI suppose, if you're doing TDD, you'd write the docstring after the fact. But I still don't see how that's a problem.\n\nThe documentation for a function is not a comment you write after the fact.\n\nWhat if I told you that fizz_buzz() is an example that I wrote to illustrate the problem that the author is describing?\n\nWhat if I told you that fizz_buzz() is an example that I wrote to illustrate the problem that the author is describing?\n\nThe point of the article", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def __str__(self):\n    \"\"\"String representation of fizz_buzz.\n    >>> fizz_buzz()\n    'fizz_buzz(2)\n    >>> fizz_buzz()\n    'fizz_buzz(3)\n    >>> fizz_buzz(79)\n    'fizz_buzz(3)\n    >>> fizz_buzz()\n    'fizz_buzz(79)\n    \"\"\"\n    return \"FizzBuzz(%d)\" % self.n", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def __main__():\n    \"\"\"Main\n    >>> import this\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n\nfizz_buzz(50)\n0\nfizz_buzz(78)\n2\nfizz_buzz(79)\n3\n\nI really need to get around to fixing that.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    print \"FizzBuzz\\n\"\n    for i in range(1,100):\n        print(i)\n        if i%11 == 0:\n            print(i)\n            fizz_buzz(i)\n            else:\n             print(i)\n              fizz_buzz(i)\n\nfizz_buzz is a name-mangled function from the Python standard library module standardlib.standardfunctions.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\n fizz_buzz = lambda n:\n    if n > 2:\n        return (n / 11) + 1\n    else:\n        return n / 13\n\nThe first case is the one we want, where the number is divisible by 11.\nThe second case is the interesting one.\nIt is a Python generator function, so you can use it as:\n    def fizz_buzz(n):\n        for i in range(n):\n             yield i * 11\n        return n\n\nThis will print out the numbers 0 through 100.  The key is in the yield i * 11\nstatement.  The generator function is equivalent to:\n    for i in range(n):\n        if i % 11 == 0:\n              yield i\n            else:\n              return", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\n    \"\"\"\n    def divide(x: int, y: int):\n        if x % y == 0:\n           return x\n        return y\n   \n    def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\n\n    \"\"\"\n    def fizz_buzz_in_radix_2(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz_in_radix_2(78)\n    7\n    >>> fizz_buzz_in", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return floor(log(n / 11) * log(n / 13))\nI have never worked with these log functions before.  But I like the use of the floor function to get rid of the decimal part, so that the answer is correct to the nearest integer.  Very nice.\nI like it too, I was just wondering if there was a way to remove the decimal part from the log function too.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def fizz_buzz(n: int):\n    if n<3:\n       print(\"No problem, easy\")\n    return n\n    if n<11:\n       n = n / 11\n    return n\n    if n<13:\n       n = n / 13\n    return n\n    if n >= 13:\n       n = int(n)\n    return 0\n\nOr you can do this with a one-liner:\nimport itertools\nn = int(itertools.combinations([n for n in range(3, 11, 13) if n % 11 == 0 and n % 13 == 0])\n\nWhat's the benefit of a one-liner?\n\n1. It is faster.\n2. It is harder to write wrong\n3. It is easier to understand\n4. It is easier to debug\n5. It is easier to learn\n6. It is easier to understand what the program is doing\n7. It is a better habit", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\n    def fizz_buzz_small(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz_small(50)\n    0\n    >>> fizz_buzz_small(78)\n    2\n    >>> fizz_buzz_small(79)\n    3\n    \"\"\"\n\n    def fizz_buzz_big(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz_big(50)\n    0\n    >>> fizz_buzz_big(78)\n    2\n    >>> fizz_buzz_big(79)\n    3\n    \"\"\"\n\n    def fizz_buzz_larger(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def divisibleBy11(n: int) = n % 11:\n    \"\"\"Return True if n is divisible by 11\n    >>> divisibleBy11(50)\n    True\n    >>> divisibleBy11(78)\n    False\n    \"\"\"\n    def divisibleBy13(n: int) = n % 13:\n    \"\"\"Return True if n is divisible by 13\n    >>> divisibleBy13(50)\n    True\n    >>> divisibleBy13(78)\n    False\n    \"\"\"\n    n = n * divisibleBy11(n) + divisibleBy13(n)\n    return n\n\nOne of the biggest problems with this code is that it has been used in a blog post.\n\nI'm not sure why you're being downvoted. I've seen this exact implementation of fizz buzz in a blog post before. It was one of the first google results for \"python fizz buzz\".\n\nIt's a funny one. I know it's been written in a blog", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n           return i\n    return 0\nThis is probably going to be a stupid question, but how did you get the dots in the post? I thought they were reserved for code.\n\nTry clicking the \"formatting help\" link next to the comment box.\n\nThanks.</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    count = 0\n    while n > 0:\n        if n % 11 == 0:\n            count += 1\n        else:\n            count += 1\n        count /= 11\n    if n % 13 == 0:\n            count += 1\n        else:\n            count += 1\n    return count\n\nI see you left out the comments.\n\nReminds me of an old joke:\nQ: How do you tell if a mathematician is lying?\nA: His lips are moving.\n\nThat's funny. The best I can do is:\nQ: How do you tell if a mathematician is lying?\nA: He's got a proof for his statement.\n\nQ: How do you tell when a physicist is lying?\nA: His lips are moving.\n\nQ: How do you tell when an engineer is lying?", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n / 11.0 + n / 13.0\n\nThanks for the quick response! I've never written a for loop before. I'm not sure how to apply that to this situation though. Could you explain what I would need to do to get the number of times 7 appears in integers less than 50?</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    return n == 0? 1 : n == 1? 1 : n == 2? 1 : n == 3? 1 : n == 4? 1 : n == 5? 1 : n == 6? 1 : n == 7\nThe for loop is still there, it just doesn't show up in the gist.\n\nYes, but you're missing the point. The for loop is unnecessary.\n\nI guess I'm missing the point. What does the for loop do that the comprehension does not?\n\nIt is unnecessary because the comprehension is essentially equivalent, but you can only put one line of code inside a comprehension.\n\nWould the comprehension allow you to add more code? I'm confused.\n\nIt would allow you to write it as one line, but not as zero lines. You can't do:\n[1, 2, 3].filter(n>=4)\nbecause the filter function is in the comprehension, not the for loop.\n\nWhat is so bad about a for loop in this case?\n\nIt's a sign of bad code.\n\nIt's a sign of laziness. Laziness is bad.\n\nThat may be, but my point was that the comprehension is not", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def fizz_buzz_2(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz_2(50)\n    0\n    >>> fizz_buzz_2(78)\n    2\n    >>> fizz_buzz_2(79)\n    3\n    \"\"\"\n    def fizz_buzz_3(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz_3(50)\n    0\n    >>> fizz_buzz_3(78)\n    2\n    >>> fizz_buzz_3(79)\n    3\n    \"\"\"\n    def fizz_buzz_4(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    result = 0\n    if n == 0:\n        return result\n    else if n == 1:\n        return result\n    else:\n        if n % 11 == 0:\n            return fizz_buzz(n - 1)", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\nSo the author could have written the article like this:\nfizz_buzz = \"def fizz_buzz(n: int):\"\nfizz_buzz = \"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\"\nfizz_buzz = \" >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\"\nNow we just need to make an editor that does this. I think this is a great idea!</s>", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    if n < 1:\n        return 0\n    for i in range(n+1, 2):\n        if n % i == 0:\n           return i\n    return 1\n\nI would be surprised if this didn't turn up in the first 20 results for a Google search for \"python fizz buzz\"\n\nIf you're trying to learn Python, this is a nice problem to do.\nIf you're trying to find a job, just get someone to write you an actual program. (It's not hard, and it's not a good use of your time.)\n\nIf you're trying to learn Python, and can't write this, then I suggest you spend more time learning Python, and less time writing blog posts about Python.\n\nI don't agree with you, but I _do_ agree with the title of your post: \"fizzbuzz is a test, not a job interview question\"\n\nI'm trying to write a job interview question in Python that actually makes use of the language, rather than being trivial, and still is a good interview question", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def fizz(i):\n    if i % 2 == 0:\n        return 1\n    else:\n        return 2\n    return fizz(n)\n\nSo, I take it the OP's joke is that there's no actual logic involved in solving a fizz buzz problem?\n\nThe joke is that all solutions to fizzbuzz are exactly the same (and in this case a bit of a tongue-in-cheek nod to Dijkstra).\n\nI see. I'm not sure I can appreciate it as the humor is probably only recognizable to people who have read Dijkstra's original paper.\n\nAnd?\n\nAnd, I thought that there was a lot of pop-culture references in the programming community that one might be able to understand without having read the original paper.\nFor instance, it's possible that the OP's joke was a reference to the \"SparkFun Fizz Buzz\" (https://www.youtube.com/watch?v=9vTVrRgPt2Q) video, which is a pretty obvious reference to Dijkstra's paper,", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    number = 0\n    while n < n:\n       number += if n % 11 == 0: (11*n + number)\n       else: (n*3 + number)\n       if n % 13 == 0: (13*n + number)\n    return number\n    def main():\n    \"\"\"Return the fizz_buzz of numbers up to 100.\n    >>> import math\n    >>> x = 0\n    >>> y = 0\n    >>> main()\n    >>> print x\n    0\n    >>> print y\n    0\n    >>> print fizz_buzz(x, y)\n    0 0 0\n    0 1 1\n    0 1 2\n    0 1 3\n    0 2 3\n    0 3 4\n    0 4 5\n    0 5 6\n    0 6 7\n    0 7 8\n    0 8 9", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n\nI don't understand this code.\n\nIt's a very simple fizzbuzz.\nn is the input number.", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    # divide by 11 and 13 to get 10 and 9, respectively, as the largest non-zero digits in the answer\n    for i in range(1, 10):\n        if n % 11 == 0 and n % 13 == 0:\n           n = n / 10 + i\n        else:\n           n = n / 10\n    return n\nI think it's a great exercise to convert this to Python.\nHere's my first try:", "def fizz_buzz(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz(50)\n    0\n    >>> fizz_buzz(78)\n    2\n    >>> fizz_buzz(79)\n    3\n    \"\"\" \"\"\"\n    def fizz(x: int):\n    \"\"\"Return the digit 1 if x is even, or the digit 3 otherwise.\n    >>> fizz(8)\n    1\n    >>> fizz(1)\n    1\n    >>> fizz(3)\n    3\n    \"\"\"\n    def buzz(x: int):\n    \"\"\"Return the digit 1 if x is even, or the digit 3 otherwise.\n    >>> buzz(8)\n    1\n    >>> buzz(1)\n    1\n    >>> buzz(3)\n    3\n    \"\"\"\n    for n in range(0, 10):\n       if n % 11 == 0:\n          return fizz(n)\n       if n % 13 == 0:\n          return buzz(n)\n       n = n % 11\n       return n\n\nThis"]]