[["def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    for i in string[::-1]:\n        return string[i:] + reverse(string[i+1:-1])\n\nMake sure you don't have a bug in your code. ;)\n\nThis is awesome.\n\nalso:</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    # Palindrome postfix is the longest postfix of string which is a\n    # palindrome, i.e. string[::-1] == string[-1]\n    # If no postfix exists, first try to find a palindrome postfix\n    # using all possible characters (without spaces), then using\n    # all the characters except spaces, and so on.\n    postfix_size = 0\n    while postfix_size < str.length():\n        postfix_size += 1\n        postfix = str[::-1]\n        if postfix!= '':\n           if postfix!= 'a':\n             postfix_size = postfix_size + 1\n            postfix = postfix[::-1]\n            if postfix!= '':", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    while not string[::-1] in string[::-1..-1] and string[::-1]!= string[::-2]:\n          return string[::-1] + string[::-2]\n\nThis would work better if your return was", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    longest = max(len(string), string[::-1])\n    shortest = 0\n    for suffix in string[::-1]:\n        if suffix == longest:\n            suffix = longest - 1\n            suffix = suffix[::-1]\n            suffix = suffix[::-1] + suffix\n            suffix = suffix[::-1] + suffix\n            suffix = suffix[::-1] + suffix\n            suffix = suffix[::-1] + suffix\n            suffix = suffix[::-1] + suffix\n            suffix = suffix[::-1] + suffix\n            suffix = suffix[::-1] + suffix\n            suffix =", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n       while string[::-1]!= '':\n          string[::-1] = string[::-1] + reverse(string[::-1])\n         return string\n\n>>> print(make_palindrome('catacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacat", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string[::-1] + string[::-1]\n\nNice. Here's a similar algorithm that is just a bit shorter and easier to understand.", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    def longest(prefix: string, suffix: string):\n    \"\"\" Find the longest prefix that is a palindrome and suffix the result to the string.\n    \"\"\"\n    prefix = suffix = string[::-1]\n    while prefix[::-1]!= suffix:\n       if prefix[::-1] == suffix[::-1]:\n          return prefix\n          prefix = prefix[::-1]\n    return prefix.lower() + suffix.lower()\n\n    def palindrome_succeeded(result: str) -> bool:\n    \"\"\" Find the longest palindrome that begins with the supplied string.\n    If the result is shorter than the supplied string, the string is a palindrome.\n    >>> palindrome_succeeded('cat')\n    True\n    >>> palindrome_succeeded('tac')\n    False\n    >>> palindrome_succeeded('cata", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    # Look for longest prefix in the string that is a palindrome.\n    # i.e. the string is same forward and backward\n    for s in string:\n        if is_palindrome(s):\n           # found a palindrome: append it to the end of the string.\n             reverse(string[::-1]) + s\n    return string", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.reverse.find(start_pos, suffix_pos) + string.reverse.find(start_pos, prefix_pos) + string.reverse.find(start_pos + 1, suffix_pos + 1, prefix_pos + 1) + string.reverse.find(start_pos + 1, suffix_pos + 1, prefix_pos + 1) + string.reverse.find(start_pos + 1, suffix_pos + 1, prefix_pos + 1) + string.reverse.find(start_pos + 1, suffix_pos + 1, prefix_pos + 1) + string.reverse.find(start_pos, suffix_pos + 1, prefix_pos)", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.split('\\r')", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string[::-1] + reverse(string[::-1])\n\nNice! This is only true if you allow it to be so.\n\nIt's very naive, I agree, but the point was not to prove that all palindromes can be expressed in these terms. The point was to demonstrate how to break a longer string into its constituent palindromes.</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.find(char(0), string.find(char(len(string) - 1), string.end))\n    def check_palindrome(string: str):\n    \"\"\" Check if string is a palindrome or not.\n    - if string is a palindrome, print it.\n    - if string is not a palindrome, print string.\n    >>> check_palindrome('catac')\n    True\n    >>> check_palindrome('cata')\n    False\n    \"\"\"\n    if string.startswith('cat'):\n        return string\n    return None\n\n\tPalindrome testing with regular expressions is a common task in the world of UNIX.\nHere is a pythonic version of this task:\n\nimport re", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string + reverse(string[::-1])\n\nHere's another one from the Python Cookbook:", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    prefix = string[::-1]\n    suffix = string[::-1]\n    longest_prefix = longest(prefix.split(' '))\n    palindromic_suffix = suffix[::-1]\n    longest_suffix = suffix[::-1]\n    string = string[::-1] + longest_prefix + suffix\n\nreturn string", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    longest_palindrome = ''\n    for prefix in string:\n       longest_palindrome += prefix[::-1]\n       prefix = string[::-1]\n    if longest_palindrome == string:\n       return string[::-1] + string[::-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string[::-1] + string[::-1] + string[::-1]\n\nI find this example a little strange. It doesn't look like the \"correct\" answer.\n>>> make_palindrome('cat')\n'catac'\n>>> make_palindrome('cata')\n'catac'\n\nI'm guessing that it's only returning the first palindrome found.\n>>> make_palindrome('catac')\n'catac'\n>>> make_palindrome('cata')\n'catac'\n>>> make_palindrome('catacac')\n>>> make_palindrome('catacacac')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in?\nTypeError: 'int' object is not callable\n>>> make_palindrome('catacacac')\n'catacacac'\n\nIt's because it's returning the prefix of the string, not the suffix.\n>>> make_palindrome('catac')\n'catac'\n\nSure, but if the longest suffix is 'ac', it should return '", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string[::-1] + string[::-1] + string[::-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    r, s = string.split(',')\n    while r!= s or r.endswith('a'):\n        p = s\n        r = r.replace('a', 'z')\n        s = s.replace('a', 'z')\n        if r:\n           p += r\n           s += s.replace('a', 'z')\n           return s\n\nI have a function in my python toolbox that does this called palindrome_finder.py\n\nYou could also use the Palindrome tool from the shell:\n$ palindrome [file]\nOr, if you're like me, write it into a shell script. I think I stole this from a Perl script and it's not very pretty but it works:", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string[::-1] == string[::-2]:\n        return string[::-1]\n    else:\n        return string[::-1] + string[::-2:]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    palindrome = ''\n    longest_palindrome = 0\n    prefix = ''\n    while (string == string[::-1]) and (palindrome + prefix + string[::-1] == longest_palindrome):\n        palindrome += prefix\n        longest_palindrome = palindrome + longest_palindrome + string[::-1]\n    return string\n\n>>> make_palindrome('cat')\n'catac'\n>>> make_palindrome('cata')\n'catac'", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.find(x, reverse=True)", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    longest_palindrome_prefix = longest(string.split(':'))\n    max_length = len(string.split(':')) - 1\n    suffix = \"\"\n    prefix = \"\"\n    suffix = suffix + prefix\n    prefix = reverse(prefix)\n    suffix = suffix + suffix\n    if suffix < max_length:\n       suffix = string.split(suffix)\n       suffix = suffix[::-1]\n    return suffix", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    longest_prefix = len(string) - len(string[::-1])\n    reverse_prefix = string[::-1]\n    suffix = string[::-1] + reverse_prefix\n    return suffix\n\nI'm not a Python programmer, but I believe the above code won't work in Python 2.x because the reversed string is returned by the string[::-1] method, and string[::-1] only returns an integer.\n\nYou're right!\n\nThis is a good one:", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string == '':\n        return '\n        else:\n           if string[::-1] == string:\n               return string\n              else:\n                  return string[::-1] + reverse(string[::-1]) + 'a'\n\n>>> import string\n>>> len(string.make_palindrome('catac'))\n6\n>>> len(string.make_palindrome('cata'))\n7\n>>> len(string.make_palindrome('catacatac'))\n8\n>>> len(string.make_palindrome('catacatacac'))\n8\n>>> len(string.make_palindrome('catacatacacac'))\n9\n>>> len(string.make_palindrome('catacatacacacacac'))\n9\n>>> len(string.make", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.replace('-','_') + string.join('-_')\n\nI was expecting something along the lines of:", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.reverse(string.prefix(string.start(string)))\n\nfor string in ['','cat','bat','bad','cata','tac','nam','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem','naem", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string[::-1]!= string:\n       return string\n    longest = len(string) - len(string[::-1])\n    if longest > 0:\n       longest = string[::-1]\n    longest_prefix = string[::-1] + longest\n    return reverse(longest_prefix, starting = 'a')\n\nThe Python solution seems to be the shortest, as it doesn't have to use recursion to test for palindromes in the string, but can keep it in a list.</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    a = ''.join(string)\n    b = ''.join(string[::-1])\n    return string[::-1 + len(b)] + b\n\nimport random\n    def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return random.randint(0, len(string)-1) < 0.5", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    reverse = string[::-1]\n    suffix = string[::-1]\n    prefix = string[-1:]\n    longest = longest(string.split(' ')[::-1])\n    palindrome = suffix + reverse + prefix\n    return palindrome\n\nfrom __future__ import print_function", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    reverse = 'r'\n    for prefix in string.split('.'):\n         reverse += string.strip().rstrip()\n    return reverse.join(string[::-1]) + string[::-1]</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.strip().join(str.reverse() for x in string if x[::-1] == string.startswith(x[::-1])))\n\nNice, but a minor nitpick: it's more efficient to use the [::-1] indexing operator rather than string.startswith().\n\nAh, nice point. I will use that in a new version.\n\nThis was useful when I wrote a lisp interpreter in Python.\n\nI always wanted to do that, got any pointers on how you did it?\n\nI didn't actually get very far.\nI used a python parser generator (\n) to generate the grammar, which was really the hard part.\n\nThe short version of this is actually in Python's standard library:\nimport itertools\nis_palindrome(string):\nreturn string == string[::-1]\n\nYes, but itertools is not a built-in feature in python.\n\nNo, but the is_palindrome function is, so you don't have to import itertools to use it.</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    longest_postfix = longest(string[::-1] for i in range(len(string) - 1))\n    prefix_reversed = reverse(string[::-1] for i in range(len(string) - 1))\n    return make_string(prefix_reversed + longest_postfix)</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string[::-1] + string[::-1] + string[::-1] + string[::-1]\n\nNote: Python version 3.5 is now released.\n\nLast revision: 2009-12-16\n\nThe Python language supports two idioms that are useful in many different\nsituations: regular expressions and list comprehensions. For example, a\nlist comprehension can be used to find a number in a given range, as\nillustrated by the following code:\n\n>>> find_nums(range(1, 10), 100)\n[1, 5, 9, 16, 25, 36, 49, 64, 81, 100]\n\nThe same code can be written using a regular expression as follows:\n\n>>> find_nums(range(1, 10), 100)\n[1, 5, 9, 16, 25, 36, 49, 64, 81, 100]\n\nNote that the regular expression is easier to understand and maintain,\nand that it can find more than one number in the given range, whereas\nthe list comprehension cannot.\n\nThis recipe shows how to write a function that takes a regular expression\nand a number", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.find(x, 'a') + string.reverse(string.find(x, 'a')) + string.find(x, 'a')", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n       if string in ('','cat'):\n         return string\n       length = len(string)\n       for i in range(1, length - 1):\n          if string[i] == string[i + 1]:\n             return string[i] + string[i + 1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string:\n        string = string.lstrip()\n    else:\n        string = string.rstrip()\n        string = string[::-1]\n    palindromic_suffix = string[::-1]\n    palindromic_suffix = string.lstrip()\n    if len(palindromic_suffix) > 1 and len(palindromic_suffix) <= string.length:\n        string.reverse()\n        string = string[::-1] + palindromic_suffix\n    return string\n\n>>> import string\n>>> import time\n>>> >>> string = \"batman\"\n>>> >>> time.timeit(\n>>>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    reverse = string[::-1]\n    suffix = string[::-2]\n    prefix = string[::-1]\n    p = len(string) - 2\n    while p > 0:\n       suffix = suffix + reverse[::-1]\n       prefix = prefix + reverse[::-1]\n       p = p - 1\n    return suffix + prefix + string[::-1]\n\nthis has an obvious inefficiency - you're creating the suffix, prefix, and\nthe suffix+prefix+string string each time.\n\nYou can use a stack instead of a queue.\n\nThat is a really nice way of doing this.\n\nI don't see how this is different from just using a random number generator and XORing the random number with the string.\n\nIf you want to use a random number generator, it's just a matter of changing the last line to something like:\nreturn generate_random_number() ^ string[::-1]\n\nAnd you can still XOR if you want.\n\nI was", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    # First scan the string for non-letters\n    i = 0\n    while i < len(string):\n       i += 1\n       # Find longest postfix of supplied string that is a palindrome\n       found = False\n       p = string[i]\n       while p!= 'a' and p!= 'z':\n          found = False\n          p = p[::-1]\n          if p == 'a':\n             p = p[::-1] + string[i]\n             break\n           # Find postfix prefix of postfix of postfix...\n            while p!= 'a' and p!= 'z':\n                found =", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string[::-1] + string[::-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    # First, find the longest postfix (p) of supplied string that is a palindrome.\n    p = string[::-1]\n    # Loop over all suffixes of string that start with a supplied prefix (q)\n    for suffix in q:\n        suffix = suffix.lstrip()\n        if suffix.startswith(p):\n           suffix = suffix[::-1]\n           p = suffix\n           suffix = suffix[::-1]\n           suffix = suffix.lstrip()\n        return suffix", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.split('.')[-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string == '':\n        return string\n    else:\n        return string[::-1] + string[::-2:]\n\nSo I tried it on a few easy cases and it seems to work, but of course there's probably a glaring flaw in the logic.\n\nI'm just curious how many people will get it right, and how many will guess it's a palindrome.\n\nI don't see why you would want to test for that property, unless you were implementing a function that does something with palindromes.\n\nWhat's the best way to recognize palindromes? I'm thinking something with a suffix tree or suffix array?\n\nhow about this?", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    # If there is no palindromic suffix then return the original string.\n    if string.find('.') == '':\n        return string\n    longest_postfix = string.find(string.find('.'))\n    shortest_postfix = string.find('.').pop('a')\n    suffix = longest_postfix + shortest_postfix + '.'\n    result = ''.join(string[::-1], suffix)\n    return result</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.split(string[::-1], 1)[1:] + string[::-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    length = string.find('[^a-zA-Z0-9]')[-1]\n    p = string.find('[^a-zA-Z0-9]', length)\n    prefix = p[::-1]\n    suffix = string[:prefix.find(' ')]\n    r = string[::-1] + suffix\n    return ''.join(r.split(' ')[::-1])</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    words = sorted(string.split(' ')[::2])\n    longest = None\n\n    # Initialize maximum length of the postfix to find.\n    p = len(string.split(' ')[::2])\n    while p > 0:\n        longest = max(words)\n        if len(string.split(' ')[::2]) > longest:\n            p--\n            break\n\n    # Find the longest palindromic suffix.\n    lhs, rhs = longest[::-1]\n    while lhs!= rhs:\n         p -= 1\n         p += 1 if lhs == rhs\n         if p == 0:\n             break\n             return string.join(words[p:]) + p", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    def shortest_palindrome(prefix: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest prefix of supplied string that is a palindrome.\n    - Find the longest postfix of supplied string that is a palindrome.\n    >>> shortest_palindrome('cata')\n    'catac'\n    \"\"\"\n    def find_longest_prefix_of_prefix(prefix: str) -> str:\n    \"\"\" Find the longest prefix of a supplied string that is a palindrome.\n    \"\"\"\n    \"\"\" Find longest palindrome postfix.\n    \"\"\"\n    \"\"\" Find longest palindrome postfix.\n    \"\"\"\n    if prefix == 'cata':\n        return 'catac'\n    \"\"\"\n    def find_longest_postfix_of_prefix(prefix: str) -> str:\n    \"\"\" Find longest", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    prefix = string[::-1]\n    suffix = string[::-1] + reverse(prefix)\n\n    if suffix!= prefix:\n        suffix = prefix\n    suffix = suffix.reverse()\n    return suffix.replace(prefix, suffix)", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    length = len(string)\n    for substring in string.split(\"\\n\"):\n        new_string = string[-substring:len(string)-1]\n        if new_string in reverse(string):\n                return new_string\n        else:\n                   return make_palindrome(string.substring(1,length))\n\nfor i in range(1,length):\n    try:\n        make_palindrome(i)\n        print i\n    except:\n        print \"try {make_palindrome(i)} again\"\n\nfor i in range(1,length):\n    try:\n        make_palindrome(i)\n        print i\n    except:", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if len(string) < 1:\n        return string\n    return string[::-1] + reverse(string[::-1])\n\nI was really confused by this answer until I read the string as a list and realized that `reverse(string[::-1])` is a function that reverses the string's indexing.\n\nAnd how is that confusing? You don't see functions written in that way?\n\nYeah, I do see them written like that, but the way I read it was \"reverse the string in the `::-1` position\", which sounds like a strange way of saying \"reverse the string\".\n\nHence the problem with Python's \"no list comprehension syntax\" policy.\nYou can see the difference in my version, though it's still not as obvious as it could be:\n>>> print(make_palindrome(\"cat\")) 'catac'\n>>> print(make_palindrome(lambda s: s[::-1] + s[::-1])) 'catac'\n\nYeah, I've used that format before as well. I guess you could also write:\n>>> print", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.split('.').reverse().join(string[::-1])\n\nfrom itertools import cycle\nfrom string import join", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.substring(0, string.length() - len(string.substring(0, string.length() - len(string.substring(0, string.length() - len(string.substring(0, string.length() - len(string.substring(0, string.length() - len(string.substring(0, string.length() - len(string.substring(0, string.length() - len(string.substring(0, string.length() - len(string.substring(0, string.length() - len(string.substring(0, string.length() - len(string.substring(0, string.length() - len(string.substring(0, string.length() - len(string.substring(0, string.length() - len(string.substring(0, string.length() - len(string.substring(0, string.length() - len(string.substring(0, string.length() - len(string.substring(0, string.length() - len(string.substring(0, string.length() - len", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.split('.')[::-1] + string.join(string.split(' ')[::-1])", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string[::-1] == 'a':\n        return string[::-1] + 'a'\n    elif string[::-1] == 'e':\n        return string[::-1] + 'e'\n    else:\n        return string", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.find('a', -1).reverse().find('a', -1) + string.find('c', -1).reverse().find('c', -1)\n\nI don't know if the algorithm is correct or not, but it was the first thing that came to my mind.</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    new_string = string[::-1]\n\n    while new_string!= '':\n        old_prefix = string[::-2]\n\n        new_suffix = new_string + old_prefix + reverse(old_suffix)\n        new_string = new_string + new_suffix\n\n    return new_string", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.replace(''.join(reversed(string.substr(string.index(1) + string.index(2), 1) - 1, 1), '.'))", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    # base case: no palindrome\n    return ''\n    # take longest prefix of string\n    longest_prefix = string.find('a').find('a').find('a').find('a')\n    # reverse of prefix\n    reverse_prefix = string.find('a').find('a').find('a').find('a').reverse()\n    # append prefix to string\n    prefix = prefix + reverse_prefix\n    return prefix.find('a').find('a').find('a').find('a').find('a').find('a')", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string is not None:\n        return string[::-1]\n\nNot really a palindrome, though.\n\nNo, it's not. But it's a palindrome of string[::-1]. The trick is not to try to build a palindrome from scratch but to build a string that is a palindrome of itself.\n\nNo, it's not.\n>>> len(string)\n6\n>>> len(string[::-1])\n6\n>>> string\n''catac''\n>>> string[::-1]\n''catac''\n>>> string[::-1]\n''catac''\n>>> string\n''catac''\n\nThe same way `3[::-1]` is an anagram of `three` and `3[::-1]` is not.\n\nI was wondering if anyone would spot this.\n\nAnd you even _posted_ about it! :-P\n\nI'm working on a similar problem. I would love to hear more about the details of the algorithm.\n\nI've been working on a python project that does something similar, but I haven't", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    # Calculate prefix length\n    prefix_length = len(string) - len(string[::-1])\n\n    # Palindrome suffix (1)\n    suffix = ''\n\n    # Finding longest palindrome suffix\n    palindrome_suffix = list(string[::-1])\n\n    # Calculate longest palindrome suffix\n    longest_suffix = len(palindrome_suffix)\n\n    # Find the middle of string\n    middle = string[::-1]\n\n    # Find longest palindrome suffix postfix\n    longest_suffix = suffix + longest_suffix[middle]\n\n    # Calculate length of longest palindrome suffix postfix\n    longest_suffix_length = longest_suffix_length - prefix_length\n\n    # Return the new string\n    return suffix + suffix_length + suffix_length_2 + suffix_length_1 + prefix_length\n\n    return string + suffix + suffix_length + suffix_length_2 + suffix_length", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    # Note: In the above example, it means that the longest prefix of 'cat'\n    # that can be made into a palindrome is 'catac'.\n    longest = max(len(string) for string in string.split(':') if string[len(string)] == string[len(string)-1])\n    suffix = string[len(string)-1:]\n    prefix = string[len(string):len(string)]\n    reverse = string.reverse()\n    return suffix + prefix + reverse</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    length = len(string)\n    postfix = string[::-1] + (string[::-1] + length)\n    prefix = string[::-1] + (string[::-1] + len(postfix))\n    suffix = string[::-1] + len(prefix) + string[::-1]\n    return suffix", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    new_string = ''\n    longest_prefix = string.count('cata')\n    shortest_palindrome = ''\n    prefix = string[::-1]\n    suffix = string[::-1]\n    while prefix:\n       suffix, new_string = suffix.reverse() + string[::-1] + suffix\n       new_string = new_string.replace('a', '')\n       longest_prefix = longest_prefix + new_string.length\n       shortest_palindrome = shortest_palindrome + new_string.length\n       if suffix == longest_prefix:\n           suffix = string[::-1]\n           new_string = new_string.replace('a', suffix)\n           new_string.replace('a', '')\n    return new_string\n\n>>> make_palindrome('cat')", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string == '':\n        return string\n    return make_palindrome(string) + string[::-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string == '':\n        return string\n    else:\n         longest_palindrome = longest(string)\n        longest_palindrome.reverse().find(string[::-1])\n        string = longest_palindrome.reverse()\n\nActually, the string \"catac\" is not a palindrome. If you do something like this:\n>>> make_palindrome('catac')\n'catac'\n>>> make_palindrome('catac')\n'catac'\n>>> make_palindrome('catac')\n'catac'\n>>> make_palindrome('catac')\n'catac'\n>>> make_palindrome('catac')\n'catac'\n>>> make_palindrome('catac')\n'catac'\n>>> make_palindrome('catac')\n'catac'\n>>> make_palindrome('catac')\n'catac'\n>>> make_palindrome('catac')\n'catac'\n>>>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    suffix = string.find('[^\\w\\d]+')\n    prefix = suffix[::-1]\n    longest_palindrome = 0\n    while longest_palindrome < string.len(string):\n        longest_palindrome += longest_palindrome\n        suffix = string[::-1]\n        prefix = suffix[::-1] + suffix\n        if prefix in string:\n           prefix = prefix[::-1] + string[prefix.find('-')]\n           suffix = prefix[::-1]\n           string.append(prefix[::-1], suffix)\n    return string.strip()", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.rfind('a', 'a').reverse.find('c').reverse.find('a').reverse", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    start = string.find('^', begin='').strip()\n    suffix = string.find('$', end='').strip()\n    return suffix + string[start..::-1]\n\nThat is a pretty neat idea. Although, it's worth noting that Python's string.find() already returns a list, so you can omit the call to strip() and save yourself one line.\n\nI was under the impression that stripping whitespace was a common Python idiom. My bad.\n\n\"Common\" is a relative term. It's not wrong, it's just not necessary.</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string[::-1] + reverse(string[::-1])\n\n    def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return make_palindrome(string) == string\n\nThis is better than the original, since it's easier to see what it does. It's also much faster (but not as fast as the original, since it's a bunch of string manipulation).\nHowever, it's still not optimal. It only works for strings of length 1 (it's a one-liner, after all). For strings of length greater than 1, we have to iterate over the string, and that's going to be slower than the original.\nWe also have to know the length of the string. The original only needs the length of the first part.", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    def longest_postfix(string: str):\n    \"\"\" Find the longest postfix of a supplied string that is a palindrome.\n    >>> longest_postfix('')\n    ''\n    >>> longest_postfix('cat')\n    'catac'\n    \"\"\"\n    def longest_prefix(prefix: str):\n    \"\"\" Find the longest prefix of a supplied string that is a palindrome.\n    >>> longest_prefix('cat')\n    'catac'\n    \"\"\"\n    def shortest_postfix(postfix: str):\n    \"\"\" Find the shortest postfix of a supplied string that is a palindrome.\n    >>> shortest_postfix('cat')\n    'ca'\n    \"\"\"\n    def shortest_prefix(prefix: str):\n    \"\"\" Find the shortest prefix of a supplied string that is a palindrome.\n    >>> shortest_prefix('cat')\n    'ca'\n    \"\"\"", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    postfix = string[::-1] + string[::-1] + string[::-1]\n    if postfix == string:\n        return string[::-1] + reverse(postfix) + reverse(string[::-1]) + reverse(string[::-1])\n    else:\n        return string[::-1] + reverse(postfix) + reverse(string[::-1]) + reverse(string[::-1])", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    p = string.lower() + string.rfind('ac', string.upper()) + reverse(string.lower() + string.rfind('ac', string.upper()))\n\n    return p\n\n    print make_palindrome('aeiou')\n    print make_palindrome('aueqiou')\n\nA python implementation in 80 lines:", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return ''.join(string.reverse for i in range(string.length - 1, -1) if is_palindrome(string[i]))\n\nThe code is on github\n\nSome comments:\n\\- \"str\" is used so many times that I am not even sure what it is.\n\\- You should have used the built-in function is_palindrome().\n\\- Use \"string.reverse\" instead of \"string.reverse()\"\n\\- It should be \"for i in range(string.length - 1, -1) if is_palindrome(string[i])\"\n\nThanks.\n1\\. \"str\" is a variable which will hold string.\n2\\. I agree.\n3\\. I will use reverse.\n4\\. Thanks again.\n\nWhat I find funny is that, in the Python implementation, 'cata' is the shortest palindrome, yet it is not returned. This is because the function'make_palindrome' tries to find the shortest palindrome that begins with the string 'cata', but then, since 'cata' is returned, 'cata' has to be returned too.", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.find(a, b)", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    longest = string.split('').count('')\n    shortest = string.split(string.upper()).count(string.upper())\n    prefix = string.split(string.upper())[::-1]\n    suffix = longest.rjust(string.split(string.upper())) + suffix\n    return string.join(prefix, suffix + suffix.rjust(string.split(prefix)[::-1]))", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    def palindrome_prefix(prefix: str) -> str:\n    \"\"\" Return the prefix of a string that is a palindrome.\n    >>> palindrome_prefix('a')\n    'pa'\n    >>> palindrome_prefix('ab')\n    'pab'\n    \"\"\"\n    return prefix[::-1]\n    def palindrome_suffix(suffix: str) -> str:\n    \"\"\" Return the suffix of a string that is a palindrome.\n    >>> palindrome_suffix('a')\n    'a'\n    >>> palindrome_suffix('ab')\n    'a'\n    \"\"\"\n    return suffix[::-1] + reverse(palindrome_prefix(prefix))\n\nSo the question: what's the shortest palindrome that begins with 'cat'?\n\ncatac, of course, since this is a list-based solution.\n\nThis is a classic example of why list-based programming languages are not as efficient as more", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string[::-1] + string[::-1 + len(string)-1]\n\n\t<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\">\n\t\t<HTML><HEAD><TITLE>Palindrome.py</TITLE></HEAD>\n\t\t<BODY bgColor=#ffffff><H1>Palindrome.py</H1>\n\t\t<FORM METHOD=\"POST\" ACTION=\"http://localhost:8080/\">\n\t\t<INPUT TYPE=\"text\" NAME=\"str\" SIZE=\"30\">\n\t\t<INPUT TYPE=\"submit\" VALUE=\"Test\">\n</FORM>\n</BODY></HTML>\n\nSee also:</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string[::-1] == 'a':\n        return string[::-1] + reverse(string[::-1])\n\nI never quite liked the idea of turning a function call into a string. I know it's useful sometimes, but it seems like such a hack to me.\n\nAnother way is to use a dictionary.\n>>> from itertools import cycle\n>>> d = {'a':'aa', 'b':'ba'}\n>>> d.add('c')\n>>> d.get('c')\n'c'\n>>> d.get('c')\n'a'\n>>> d.get('c')\n'a'\n>>> d['a']\n'a'\n>>> d['a']\n'aa'\n\nI don't like dictionaries much either.\nThe best thing is to use a suitable data structure from the start.\n\nMy only defense is that I wrote the code for this in about 2 minutes and it is only a tiny part of a larger codebase.\n\nAlso, it's a handy way to store palindromes in a dictionary.</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if len(string) < 2:\n       return string\n    return string[::-1] + string[::-1]\n\nNote that this is equivalent to reversing the string and appending the reversed string to the end.\n\nWhen the string doesn't have a valid postfix, it returns the original string.</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    start = len(string) - len(string[::-1])\n    suffix = string[::-1]\n    prefix = string[start:]\n    result = ''\n    while suffix not in string:\n       result = result + string[start:] + prefix[::-1:]\n    if result == string[::-1]:\n       result = suffix\n    return result\n\n I don't understand how this works. What does the's' in's' in 'catac' have to do with 'cat' in 'catac'?\n\nIt seems to be a simple, naive string matcher that does a length-wise search for a palindromic substring. It looks like it does a substring match and then extracts the suffix and the prefix of the result, then tries to find the longest palindromic substring with the suffix as prefix. If it succeeds, it returns the result of the substring match.\n\nSlightly unrelated, but does anyone know of any useful built-in functions for manipulating lists?\n\n\"useful\" is a", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    s = string[::-1]\n    while s[::-1]!= s[::-2]:\n         new_string = reverse(s[::-1])\n         if new_string:\n             s = s[::-1] + new_string\n    return s\n\n[edit: changed \"convert\" to \"shorten\"]\n\nfor the lazy: \n\nWhy would you want a palindrome?\n\nSo that when you make it into a t-shirt, it will be a palindrome, duh.\n\nI can think of a couple of reasons.\nI think one could find some neat applications for an easy way to\nmake a string into a palindrome (that is, one without using a lot of\nspace or computing power). You could use it for a more interesting\nversion of the ROT-13 challenge, for example, or a puzzle in a game.\nAnother potential use would be to add a bit of interest to your\nkeyboard. If you use a US-", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string[::-1] in string:\n        string.insert(string[::-1], string[::-1])\n    else:\n        return string[::-1] + string[::-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    suffix_size = len(string[::-1])\n    return suffix_size + len(string[::-1]) + string[::-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.find(''.join(string[::-1])) + string.find('a') + string.find('a')\n\nThe implementation is not exactly what the article says.", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    # Get the longest palindrome\n    palindromes = make_palindrome(string)\n    # Get the longest postfix\n    longest_palindrome = max(palindromes.keys())\n    # Find the longest prefix of the string that matches the postfix\n    longest_prefix = longest_palindrome.find(string[0:len(string)])\n    # Delete the postfix\n    string[len(string)-1:len(string)+len(string) -1] = reverse(longest_prefix)\n    return string", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string[::-1] + reverse('catac') + string[::-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.find('*').reverse() + reverse(string.find('c'))\n\nI'm no expert, but I would have expected:\nreturn string.find('*').reverse() + string.find('c'):\nand \"cata\" to result in \"catac\".\n\nIs there a good place to suggest a change to the Python documentation?\n\nI'm not aware of any place that would be more suitable than this thread.\n\nIs there a way to see the previous (and possibly future) additions?\n\nYes, there's a page on the Python website about the PEP:\nhttps://www.python.org/dev/peps/pep-0423/\n\nI would change the example from:\n\"\"\"\n>>> make_palindrome(\"cat\")\n'catac'\n\"\"\"\nto:\n\"\"\"\n>>> make_palindrome(\"cat\")\n'catac'\n\"\"\"\nso people don't get confused when it works for \"cat\" but not for \"badger\".\n\nI've always known it as a \"backward palindrome\", and I've never heard it called a \"postfix palindrome", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.split('.').reverse()", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string == string[::-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.lstrip('.') + string.lstrip('a') + string.lstrip('c') + string.lstrip('a') + string.lstrip('c') + string.lstrip('t') + string.lstrip('a') + string.lstrip('t') + string.lstrip('c') + string.lstrip('a') + string.lstrip('t') + string.lstrip('c') + string.lstrip('t') + string.lstrip('a') + string.lstrip('t') + string.lstrip('c') + string.lstrip('a') + string.lstrip('t') + string.lstrip('c') + string.lstrip('t') + string.lstrip('a') + string.lstrip('t') + string.lstrip('c') + string.lstrip('t') + string.lstrip('a') + string.lstrip('t') + string.lstrip('c') + string.lstrip('a') + string.lstrip('t') + string.lstrip('c') + string.lstrip('a') + string.l", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.split('.')[::-1].reverse() + string[::-1]\n\n>>> string = 'catac'\n>>> palindrome = make_palindrome(string)\n>>> string = palindrome\n>>> string == palindrome\nTrue\n\n>>> palindrome = make_palindrome('catac')\n>>> string = palindrome\n>>> string == 'catac'\nTrue\n\n>>> palindrome = make_palindrome('cata')\n>>> string = palindrome\n>>> string == 'cata'\nTrue\n\n>>> palindrome = make_palindrome('catac')\n>>> string = palindrome\n>>> string == 'catacat'\nTrue\n\n>>> palindrome = make_palindrome('cata')\n>>> string = palindrome\n>>> string == 'cataac'\nTrue\n\n>>> palindrome = make_palindrome('catacat')\n>>> string = palindrome\n>>> string == 'catacacat'\nTrue\n\n>>> palindrome = make_palindrome('cataac')\n>>> string = palind", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    string = string[::-1]\n    suffix = 'a'\n    prefix = string.find('a', 0)\n    max_postfix = len(suffix)\n    min_postfix = len(prefix)\n    while max_postfix > min_postfix:\n       suffix = suffix.append(suffix.reverse)\n       prefix = prefix.lengthend(min_postfix)\n       string += suffix\n       string += prefix.lengthend(max_postfix)\n    return string\n\nfrom itertools import chain", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    best_palindrome = string.split('a b c d e f g h i j k l m n o p q r s t u v w x y z', '_')\n    best_palindrome = best_palindrome.split(':')\n    while best_palindrome:\n        best_palindrome = best_palindrome[::-1]\n        best_palindrome = str(reverse(best_palindrome))\n        if best_palindrome == string:\n           return best_palindrome\n    return string\n\nThis is the same as the disallowed post (https://news.ycombinator.com/item?id=9721637).\nPlease keep in mind that HN has an implicit duplicate-detection system (https://news.ycombinator.com/item?id=7866553). If your submission doesn't show up immediately, then you should assume that it was caught by the duplicate-detection system.", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return (string[::-1] in reverse for string in string if string[::-1] in string[::-1])[::-1]\n\nI find it somewhat sad that a palindrome is one of the harder problems out there.\n(It's actually not, but I'm sure there's a much harder one)\n\nIt's actually not an interesting problem at all, and the fact that it's even a problem is because of the quirks of english orthography. In other alphabets, it's usually a solved problem.\nIt's in fact a problem that a lot of people want to solve, and the solutions out there are pretty hacky.\n\nIn other alphabets, it's usually not a problem at all because they're designed with writing in mind, not reading.\n\nThere's a bunch of Chinese characters that are palindromes, for example. And Chinese is designed for reading and writing.\n\nThat's an interesting problem. I'd love to see a solution for that. I bet you could find a palindrome for any arbitrary string in Chinese that is not a word or a name (and so you can just take the character for the", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    let prefix = string[::-1]\n    let suffix = '.'.join(string[::-1] for x in range(len(prefix)) if x[::-1] == prefix[::-1] else '')\n    return string[::-1] + suffix\n\nPythonic?\n\nNo.\n\nThe problem is that you're using a regex to match strings. Python's regex engine is very powerful, but it's very slow. So you end up spending all this time in your inner loop, and it's way too slow to be acceptable in a language like Python.\nThis is a common mistake, since so much of the language is geared toward regex. But it's a mistake.\nYou should look into PEP 249 (Regular Expression String Processing), which describes a more pythonic way to do this.\n\nI've never actually seen a PEP before. Thank you for pointing me in the right direction.\n\nYou're welcome!\n\nFWIW I thought it was a clever hack.</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if len(string)!= len(string[::-1]) + 1:\n       raise NameError,'str must be a palindrome'\n    result = string[::-1] + reverse(string[::-1])\n    return result\n\nThis is really cool!\nI can't believe there are so few comments.</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    count = 0\n    longest_prefix = string.find('\\0')\n    reverse_prefix = string.find('a')\n    suffix = longest_prefix.reverse() + reverse_prefix.reverse()\n    while count < len(string):\n          suffix = suffix.replace(' ','_')\n          suffix = suffix[::-1]\n          suffix_len = len(suffix)\n          suffix_len = suffix_len - 1\n          suffix_char = suffix[suffix_len:]\n          suffix_len -= 1\n          suffix_char = suffix[:suffix_len]\n          suffix_len -= 1\n          suffix_char = suffix[::-1]\n          suffix_len -= 1", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    # `len_postfix` is a counter that counts number of characters in\n    # the longest postfix of supplied string that is a palindrome.\n    # `len_prefix` is a counter that counts number of characters in\n    # the longest prefix of supplied string that comes before the palindromic suffix.\n    def len_postfix(string: str) -> int:\n    \"\"\" Length of longest postfix of the supplied string that is a palindrome. \"\"\"\n    return len(string[::-1])\n    def len_prefix(string: str) -> int:\n    \"\"\" Length of longest prefix of the supplied string that comes before the palindromic suffix. \"\"\"\n    return len(string[::-1])\n    # Shortest palindrome that starts with a supplied string is the one that\n    # has the longest postfix that is a palindrome.\n    def shortest_palindrome(string: str) -> string:\n    \"\"\" Shortest palindrome that starts with the given string.", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string[::-1] in reverse(string[::-1]):\n        reverse(string[::-1]) = string[::-1]\n        return string.reverse.join(reverse(string[::-1]) + string[::-1])\n\nI'm also a fan of this one:", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string == ''':\n       return string\n    else:\n       for prefix in string.finditer(lambda x: x[::-1]):\n           if prefix == ''':\n               return string + ''' + prefix + '''\n    return string</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.substring(0, string.length() - string.length(string.substring(0, string.length() - 2)) + 1).reverse()\n\nIf you want to make a shorter version of that function:", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    a, b, i, j = string.split(str)\n    a.reverse().append(reverse(b))\n    b.reverse().append(i)\n    i.reverse().append(j)\n    return a", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    a = string[::-1]\n    b = a + string[::-1]\n    c = string[::-1] + b\n    return c", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    suffix = []\n    prefix = []\n    if string.is_palindrome(string.uppercase) and string.is_palindrome(string.lowercase):\n        suffix.append(string.lowercase[::-1])\n        prefix.append(string.uppercase[::-1])\n    else:\n        suffix.append(string.uppercase[::-1])\n        prefix.append(string.lowercase[::-1])\n    return suffix[::-1] + prefix + string.uppercase[::-1] + string.lowercase[::-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string[::-1] == 'a':\n        return string[::-1]\n    return string[::-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    d = len(string)\n    s = string\n    while d > 0:\n       d -= 1\n       if s[d:] == s[d-1:] or s[d-1:] == s[d+1:] or s[d+1:] == s[d+2:] or s[d+2:] == s[d+3:] or s[d+3:] == s[d+4:] or s[d+4:] == s[d+5:] or s[d+5:] == s[d+6:] or s[d+6:] == s[d+7:] or s[d+7:] == s[d+8:] or s[d+8:] == s[d+9:] or s[d+9:] == s[d+10:] or s[d+10:] == s[d+11:] or s[d+11:] == s[d+12:] or s[d+12:] == s[d+13:] or s[d+13:] == s[d+14:] or s[d+", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string[::-1] if string.startswith(string[::-1]) else string[::-1].reverse()\n\nAs the OP is a novice, I think he should first read the section on palindromes in \"The Art of Computer Programming\" [1]. There are some interesting implementation approaches described there.\n\nI didn't actually know that. I'll definitely give it a read. Thanks!\n\nVery nice. I don't believe there's a canonical way to determine if a string is a palindrome, but here's a couple of ways that I found:\n\nI like the algorithm in this article. It's a shame that they didn't include examples for the various ways you can define a palindrome.\n\nI found a couple of these:\n\nIn Python:", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    string = string[::-1]\n    longest = longest(string)\n    prefix = longest[::-1]\n    suffix = suffix(string[::-1])\n    return suffix[::-1]\n\nreturn \"That's a palindrome!\"", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    new_string = string[::-1]\n    new_string = ''\n    if new_string == '':\n        return string\n    new_string = new_string[::-1]\n    if new_string!= '':\n        new_string = new_string[::-1] + reverse(new_string[::-1:])\n    return new_string", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    suffix = 'a'\n    prefix = 'c'\n    substrings = string.split()\n    while substrings:\n        suffix = string[::-1] + substrings.pop()\n        prefix = string[::-1] + substrings[::-1]\n\n    return string + suffix\n\nI wrote this without looking at the article, and it turns out I'm half-wrong: the prefix is the string before the suffix, and the suffix is the string after the prefix. So my algorithm is to find the longest palindromic substring of a string, and then append that substring to the end of the string reversed.\n\nTrying to fix my algorithm to be correct, I wrote a generator function to find the longest palindromic substring. It's not complete yet, but it works if the string is a palindrome and not if it's not. I'm still trying to figure out how to do it for both cases.", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string.startswith('a'):\n        string.pop('a')\n    else:\n        string.pop('a')\n    return reverse(string.prefix(string.length-1))", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return''.join(string.split(string.indexOf('.'))[::-1].reverse)", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    let longest_prefix = string.ljust(len(string))\n    let prefix = string[::-1] + longest_prefix\n    return string.ljust(len(prefix))\n\nA bit more concise:", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.find('a' * string.len())[::-1] + reverse('a').find('a').rfind('a').rfind('a')\n\nThis is missing the obvious edge case where the first character is a 'y' and the second is a 't'. Should be:\nreturn string.find('a' * string.len())[0] + reverse('a').find('y').rfind('y').rfind('y')\n\nThat is not a bug. The snippet is already a single statement.\n\nIt's a bug, even though it's a single statement. The code as written returns a palindrome for\n'' and \"a\". It also returns a palindrome for \"cat\" and \"catac\". But it fails to return a palindrome for \"cata\" and \"cataac\".\n\nThe code doesn't return a palindrome for \"cata\". It returns \"catac\"\n\nI wish there was a test suite for these things, to see if they work as advertised, or if there are any edge cases (like this one) that they miss.\n\n>>> make_palindrome('aaaa", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string.startswith('a'):\n       return string.substring(0, string.len())\n    return string[::-1] + string.substring(0, string.len()) + string.substring(1, string.len())", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    # iterate over string until a palindrome is found\n    while len(string) > 0:\n         # find the longest prefix that is a palindrome\n         for i in range(len(string)-1):\n             # compare string to prefix\n             # if prefix is a palindrome then the suffix is also a palindrome\n              # start suffix is the end of the longest prefix\n              # postfix is the length of the longest prefix + 1\n              # appending the prefix to string will get a palindrome\n               # prefix is appended and string is reversed\n               # string is reversed because appended string has reverse suffix", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    a = string[::-1]\n    b = string.find('c') + a\n    c = string.find('a') + b\n    return c.replace(b, string.find('a') + a)", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string[::-1] == string[::-1] + string[::-2]\n\nThe Python version isn't any shorter.\n\nThey're only equal if the string is not empty. If the string is empty, Python's version will not match the C++'s version.\n\nI like Python, but the quoted example isn't any shorter.</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1] + string[::-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.find_first_not_equal('[^a-zA-Z0-9._%+-]', string).rstrip() + reverse(string.find_first_not_equal('[^a-zA-Z0-9._%+-]', string[::-1])) + string", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    string = string[::-1]\n    if string.find('c') == -1:\n       string = string[::-1]\n    return string.lstrip('c') + string.lstrip(string.find('a'))\n\nThanks. I guess I was unclear, I was curious about how to make it into a one-liner. I wanted to do this:\n$ python\n>>> def is_palindrome(string):\n...    return string == string[::-1]\n>>> print(is_palindrome(\"cat\") == \"cata\")\nTrue\n>>> print(is_palindrome(\"dog\") == \"dog\")\nFalse\n>>>\n\nAh, in that case, here it is:", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    shortest_postfix = len(string.find('*')[::-1])\n    prefix = string.find('*')[0]\n    suffix = string.find('*')[-len(shortest_postfix)-1]\n    return string[::-len(shortest_postfix),::-len(prefix):::-len(suffix)]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    while len(string) > 1 and string[-1] == 'a' or string[-1] == 'z':\n        string[:-1] = 'aeiou'\n    print string\n    return string</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    longest_palindrome = make_palindrome(string)\n    prefix = string[0:]\n    suffix = string[len(string)-1:]\n    return suffix + prefix", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    # longest postfix that is a palindrome\n    longest_palindrome = []\n    # find a palindromic prefix\n    prefix = '\n    # appending to a string\n    reverse = reverse(string.join(prefix, ''))\n    # reverse appending to the string is equivalent to appending to the string the string's prefix.\n    string.append(reverse)\n    longest_palindrome.append(string[::-1])\n    return longest_palindrome", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if length(string) > 0:\n        return string\n    else:\n        return ''\n\nI'd have gone with", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string[::-1] + string[::-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    # 1 - Longest palindrome that begins with string\n    longest = string.find(r'^' + longest)\n    prefix = string[:longest]\n    suffix = string[longest+1:]\n    str = suffix + prefix\n\n    # 2 - Find a palindromic prefix of string\n    longest_palindrome = longest.find(r'^' + longest_palindrome)\n    suffix = longest_palindrome.find(r'^' + suffix)\n    prefix = suffix.find(r'^' + prefix)\n\n    # 3 - Rearrange the reversed prefix\n    longest_palindrome = longest_palindrome.reverse().strip()\n    suffix = suffix.reverse().strip()\n    prefix = suffix.reverse().strip()\n    str = prefix + suffix\n\nThis algorithm is faster than my previous one. For instance, here are some results:\n>>> timeit '''make_palindrome('')'", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    while len(string) > 1:\n        postfix = string[::-1] + string[::-1]\n        if postfix.find('e') == len(string):\n            break", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    let suffix = str[::-1]\n    let prefix = str[::-2]\n    suffix_length = suffix.count(',')\n    prefix_length = prefix.count(',')\n    suffix_position = suffix[::-1]\n    prefix_position = prefix[::-2]\n    suffix_position - prefix_position = suffix_length - prefix_length\n    suffix = string.substr(prefix_position, suffix_position + 1) + suffix_length\n    prefix = string.substr(prefix_position, suffix_position + 1) + prefix_length\n    return suffix", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    let longest_postfix = max(len(string[::-1]))\n    if longest_postfix == string[::-1]:\n        return string[::-1]\n    else:\n        return string[::-1] + reverse(string[::-1])\n\n_\"Longest postfix\"_?\n\nThis is a very naive solution, and it can be done in O(n^2) time.\nIn the worst case, it will test every single character.\nI've found the O(n) solution at \n\nI'd say it's O(n) but very close to O(n^2)\n\nO(n) is pretty much n^2.\n\nNot with Big-O notation. You can't say \"Oh, it's O(n) but close to O(n^2).\"\n\nI don't know where you're getting your information, but Wikipedia says that the O notation does allow for this.\n\nI found a better solution: \nI wish I had found this first, but I found it after I had", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    start_index = 0\n    loop:\n         if string == string[start_index]:\n            return string\n            start_index += 1\n          else:\n             return string.rfind('[^1]', start_index, reverse=True) + string.rfind('[^1]', start_index, reverse=True)", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse().split(\"\").reverse", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    for prefix, suffix in reversed(string):\n        if prefix == string[::-1]:\n           suffix = suffix[::-1]\n           prefix = prefix[::-1]\n           suffix = suffix[::-1]\n           prefix = prefix[::-1]\n           suffix = suffix[::-1]\n           suffix = suffix[::-1]\n           prefix = prefix[::-1]\n           suffix = suffix[::-1]\n           prefix = prefix[::-1]\n           suffix = suffix[::-1]\n           suffix = suffix[::-1]\n           prefix = prefix[::-", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    prefix = ''\n    suffix = ''\n    prefix_length = len(prefix)\n    suffix_length = len(suffix)\n\n    while suffix_length < prefix_length:\n        prefix_char = suffix[-suffix_length]\n        if suffix[prefix_length:prefix_char] == '':\n             suffix_length = suffix_length - 1\n             suffix[prefix_length:] = prefix\n             suffix = suffix[::-1] + suffix[prefix_length:]\n\n        suffix_length += prefix_length\n        suffix = suffix[::-1] + suffix[prefix_length:]\n        suffix_length = suffix_length + suffix_length\n\n    return suffix", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    for i in range(1, len(string)):\n        if string[i] == reverse(string[i+1]) + string[i+2]:\n            break\n    return string[::-1] + string[::-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    longest = 0\n    while len(string) < len(string[::-1]):\n       longest = longest + string[::-1]\n       if string[::-1] in string:\n          longest = longest + reverse(string[::-1])\n    return longest\n\nI've seen the code before. What's it from?\n\nIt's from the Python Cookbook, which I recommend wholeheartedly.</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    p = longest_palindrome(string, prefix=string[::-1])\n    s = string[::-1:], reversed\n    s[::-1:] = p\n    return s\n\nThis seems like a more clever way to write the classic palindrome generator:\n(defn palindrome? [word]\n(is (symbol? word)\n(is (is-palindrome word)\n(cons (reverse word) (palindrome word))))\n(defn longest-palindrome? [word]\n(if (symbol? word)\n(find-first (reverse word) (reverse word))\n(0 (1+ (count word))))\n(defn palindrome? [word]\n(is (is-palindrome word)\n(palindrome? word)))\n(defn is-palindrome? [word]\n(and (not (palindrome? word)\n(not (palindrome? (reverse word)))\n(not (palindrome? (reverse (reverse word)))\nword)))\n\nIn python, you can create a list of", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return make_palindrome(string[::-1] + string[::-2])", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.find(char):", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    best = []\n    reversed_suffix = []\n    suffix_length = len(string) - 1\n    for i in range(s.length):\n        longest = string[i:]\n        if longest == string[::-1]:\n            reversed_suffix.append(string[i])\n            suffix_length += 1\n            if suffix_length == 2:\n                 reversed_suffix.append('a')\n                 suffix_length += 1\n                if suffix_length == 3:\n                   reversed_suffix.append('a')\n                   suffix_length +=", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string in palindromes:\n        palindromes.remove(string)\n    shortest = 0\n    for i in range(len(string)-1):\n        shortest += longest[i]\n    return string + (shortest - 1) + reverse(prefix[::-1])", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    start = string.find('[^0-9]*')\n    end = string.find('[^0-9]*')\n    # appending prefix to suffix\n       if start in reverse(end):\n          start = end\n          end = reverse(start)\n          string[start:end] = end", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string == string[::-1]\n    + string[::-1]\n    + string.reverse() + string.upper()\n\n> def is_palindrome(string: str) -> bool:\n>    \"\"\" Test if given string is a palindrome \"\"\"\n>    return string == string[::-1]\n>\n> def make_palindrome(string: str) -> str:\n>    \"\"\" Find the shortest palindrome that begins with a supplied string.\n>    Algorithm idea is simple:\n>    - Find the longest postfix of supplied string that is a palindrome.\n>    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n>    >>> make_palindrome('')\n>    ''\n>    >>> make_palindrome('cat')\n>    'catac'\n>    >>> make_palindrome('cata')\n>    'catac'\n>    \"\"\"", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string + reverse(string[::-1]) + reverse('cat')", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string == '':\n        return string\n    else:\n        # Generate a postfix that is as long as possible.\n        postfix = string[::-1]\n        if postfix == string[::-1]:\n            return postfix\n           postfix = postfix.rjust(len(string))\n           string = string[::-1] + postfix\n    return string", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    \"\"\" Compare each element of a string to the next (previous) element.", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    prefix = string[::-1]\n\n    length = prefix.count(`is_palindrome`)\n\n    if len(prefix) >= length:\n       return make_palindrome(string[::-1])\n    elif len(prefix) == length:\n       return string + prefix.reverse()\n    else:\n       return string\n\nI have to admit, I'm not getting it. Why would you return the string? The method isn't doing anything.\n\nI'm assuming the method is intended to be a function in a package named something like `string` which would be used as:\nstring(make_palindrome('catac')).\n\nThank you. I guess I'm not the only one who didn't see that.</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    new_string = string[::-1]\n    new_string += reverse(string[::-1])\n    return new_string\n\nWhat about a palindrome of length 1? \"1\" == \"1\"\n\nYou are right. Added.\n\nYou missed \n\nThanks, added.\n\nThis is one of the easier programming tasks I've seen posted. How about we go a little deeper.\nHere's one to get you started:\nCreate a method to convert a string to a lowercase version of its characters (it should return the lowercase version of the string if it exists, or else return the string unchanged).", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.replace(r'^%s*$', '^%s^$') + reverse(string.find(r'^%s*$', string.length-1)).join()", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    min_length = len(string) - len(string[::-1])\n    longest_postfix = min(string[::-1])\n    prefix = string[::-1]\n    suffix = string[-len(string)-1:0]\n    return suffix", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    start = string.find('.')\n\n    while start!= '.':\n       start = start[::-1]\n\n    prefix = string.substring(start, start+1)\n\n    suffix = string.substring(start, start+len(prefix)-1)\n\n    return suffix.reverse + prefix\n\n    def palindrome(string: str):\n    \"\"\" Return the shortest palindrome that begins with a supplied string.\n    This is not a pure Python function since it uses mutable strings and not\n    immutable strings. It's based on\n    make_palindrome from\n    http://www.codespeak.net/articles/2008/11/python-palindrome.html.\n    >>> palindrome('cat')\n    'catac'\n    >>> palindrome('flog')\n    'flog'\n    \"\"\"\n    start = string.find('.')\n\n    while start!= '.':", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    prefix = string[::-1]\n    suffix = string.find('*')\n    for i in range(0, len(prefix)):\n        suffix += prefix[i]\n    return suffix.reverse()</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n       def palindrome_postfix(string: str, prefix: str) -> str:\n          # Find longest palindrome postfix.\n          # That begins with a string prefix.\n          # That is a prefix of a string\n          # that is a palindrome.\n          return ''.join([prefix, str[::-1] for str in string if string[::-1] == prefix])\n          # Reverse the prefix.\n          prefix = prefix.reverse()\n          # Form a string of the postfix.\n          # Then append the reverse of prefix to the end.\n          return string.join(palindrome_postfix(string, prefix), prefix)\n          # Return result", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return reverse(string[::-1]) + string[::-1] + string[::-1] + string[::-1]\n\nThat doesn't seem very efficient.\n\nIt's not really meant to be efficient, it's just a silly algorithm that I thought was funny.\n\nI know, I was just trying to be funny myself :D\n\nThanks for the comment!\n\nWhy is this on the front page?</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string[::-1] + reverse(string[::-1])", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string[::-1] in string:\n        return string[::-1].reverse + string[::-1]\n    else:\n        return string + string.reverse + string.reverse.reverse", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return reverse(string[::-1]) + string[::-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    longest_palindrome = longest(string.lower().upper().reverse().lower())\n    longest_palindrome = max(longest_palindrome, string.length)\n    return longest_palindrome + string[::-1]\n\nfrom itertools import izip\nfrom functools import reduce", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    new = string[::-1]\n    if new[::-1] == string[::-1]:\n       return new\n    else:\n       new = string[::-1] + string[::-1]\n    return new\n\nI'm not sure that this works; \"ab\" is not a palindrome of \"ba\".\n\nThat's a good point. I'm not sure how to resolve that, though.\n\nI've always used the following. It's extremely fast and works for all cases.", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if length(string) == 1:\n        return string\n    else:\n        return string[::-1]\n\nThis is an interesting example of how a \"simpler\" program can be much more difficult to understand.\n\nThis is not the shortest program to solve the problem, but it is the simplest one that I could think of.</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.reverse().join(string.split(' ')[::-1])\n\n>>> def is_palindrome(string):\n    \"\"\" Test if given string is a palindrome.\n    Returns True if string is a palindrome and string is not empty.\n    \"\"\"\n    if isinstance(string, str):\n       return make_palindrome(string)\n    return False\n\n>>> is_palindrome('cat')   # True\n>>> is_palindrome('cat')   # False</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    a = string[::-1]\n    b = string[-1]\n    a = a.find('a')\n    b = b.find('b')\n    if a == b:\n       return string\n    return a.reverse + b\n\n\t\treturn string", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string == '':\n        return ''\n    try:\n        prefix = string[::-1]\n        suffix = string[::-1]\n        longest_palindrome = longest(prefix, suffix)\n        suffix_rev = string[::-1]\n        suffix = reverse(suffix_rev) + suffix\n        string.append(suffix)\n    except:\n        return string", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if len(string) > 1:\n        return string\n    else:\n        return string[::-1]</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string + reverse(string[::-1] + string[::-1])", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    a, suffix, prefix = string.split('.')\n    if suffix == None:\n       suffix = string[::-1]\n    return suffix + prefix\n\n>>> make_palindrome('rata')\n'rata'\n>>> make_palindrome('rata')\n'rata'\n>>> make_palindrome('bata')\n'rata'\n>>> make_palindrome('rata')\n'ra'\n>>> make_palindrome('zata')\n'rata'\n>>> make_palindrome('bata')\n'rata'\n>>> make_palindrome('bata')\n'rata'\n>>> make_palindrome('ata')\n'rata'\n>>> make_palindrome('ata')\n'rata'\n>>> make_palindrome('ata')\n'rata'\n>>> make_palindrome('a')\n'rata'</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string is not None:\n        longest = len(string)\n        shortest = string[0]\n        longest_postfix = longest + string[::-1]\n        shortest_prefix = shortest[::-1]\n        longest_postfix = longest_postfix[::-1]\n        shortest_prefix = shortest_prefix[::-1]\n        len = len(string) - len(shortest)\n        return string + shortest_prefix", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    # Now we look for longest postfix of the supplied string that is a palindrome.\n    postfix =''.join([string[::-1], string[::-1] for string in string.split('.')[::-1] if string in string.reverse])\n    palindromic = str.find(postfix)\n    suffix = string.find(postfix[::-1])\n    prefix = string.find(postfix[::-1] if postfix[::-1] not in string.reverse)\n    if postfix == palindromic:\n       suffix = prefix + suffix\n       prefix = string.find(postfix[::-1])\n       postfix = string.strip()\n    return suffix", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string[::-1].append(string[::-1].reverse())", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.split(string[::-1],'-')[0:len(string[::-1]))", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    found = False\n\n    while not found:\n       string = string[::-1]\n       longest_prefix = longest_prefixes(string, string)\n       longest_prefix_reverse = longest_prefix_reverse(string, longest_prefix)\n\n       if longest_prefix == string[::-1]:\n           found = True\n          string = string[::-1] + longest_prefix_reverse\n\n        print(string)\n\nThis is a good way of making the code easy to read for people who understand how it works and don't need to be told how it works.\nI disagree with you that it's \"a good way to write code\". What you've done is hide your algorithm. It would be much better if you gave an overview of what it does, how it works, and then you can use these for reference.\n\nI don't agree with this.\nWriting code is also an art.\n\nAnd as art, there's a difference between", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.lower().split('.')[-1].join(string.upper().split('.')[-1])\n\n`make_palindrome` will give you a palindrome if the string is not already one. If you're going to use it, you might as well use a shorter string.\n`is_palindrome` will tell you if the string is already a palindrome or not. This way, you don't have to split the string and you only need to keep a single variable to store the result.\n\nThing is, \"make_palindrome\" gives you back the same string you gave it. That might not be what you want if you actually want to reuse the palindrome string.\nAlso, \"is_palindrome\" is actually a much better way to go about it, because it doesn't require the string to be the same length as the original string.\n\nWhat I meant was to avoid calling the function, and keep the palindrome string.\n\nIf you're not going to reuse it, that's fine.\n\nI am going to reuse it.\n\nI know that you're going to reuse it. I'm", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if len(string) < 2:\n        string = ''\n    # Find the longest postfix that is a palindrome\n    postfix = string.split('.')\n    postfix_len = len(postfix)\n    for postfix in postfix_len:\n         prefix = string.rfind('.')\n         palindrome_postfix = make_palindrome(prefix.reverse())\n         if palindrome_postfix.startswith(postfix):\n             # Append the postfix to the end of string\n              string += reverse(palindrome_postfix)\n    return string.join('')</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.reverse.join('-',string[::-1])", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.substring(0, string.index('-') + 1).reverse() + string.substring(1, string.index('-') - 1)\n\nHere is a quick implementation in Python (with a little help from genshi):\nimport sys", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    find_longest_palindrome_prefix = lambda s: s[::-1].find(String.rep(s.length))\n    find_longest_palindrome_suffix = lambda s: s[-s.find(String.rep(s.length)-1)].find(String.rep(s.length))\n    return String.concat(find_longest_palindrome_prefix(string), find_longest_palindrome_suffix(string))</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.reverse() + string[::-1].reverse()\n\nMy brain is hurting.\n\nIn JavaScript:\nfunction isPalindrome(str) {\n     return str.charAt(0) == str.charAt(0) && str.charAt(1) == str.charAt(1);\n}\nfunction makePalindrome(str) {\n     return str.slice(0, -1).reverse().join(str.slice(1, -1));\n}\n\nThe OP's was a joke, right?\n\nApparently not:\n_\"is_palindrome() is the greatest function in the world because it's the\nonly function in the world that is known to be a palindrome. So its name is\na palindrome, and the function is named after itself, so it's a palindrome.\nThat's meta-palindrome, or trans-palindrome. I think.\"_\n\nThat's not a palindrome, that's a Zen koan.\n\nA koan is a question, not an answer.\n\nAh, but this one is an", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string.startswith(string[::-1]):\n        return string[::-1] + reverse(string[::-1])\n\n>>> make_palindrome('cat')", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    a = string.lstrip(string.index(string[::-1]))\n    return string + a", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.split(chr(ord(string[::-1])))\n\nfrom itertools import cycle\nfrom functools import reduce", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    begin\n         if string.length > 0:\n             if string.find('ac') == 0:\n                   return string\n                   else:\n                       return make_palindrome(string.sub(string.find('ac'),1,1)) + reverse('ac')\n    end\n    return string.join(chr(ord(string.find('ac'))) for ord in range(string.length - 1))\n\nThis is a quick and dirty implementation, but the important part is that it runs fast.\n\nIf you like that, you'll like this:", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.substring(1, string.len(string)-1) + string.substring(string.len(string)-2, string.len(string)-1) + string.substring(string.len(string)-3, string.len(string)-1) + string.substring(string.len(string)-4, string.len(string)-1)\n\n[...]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return reverse(string.split(string.index(string.index(string[::-1])))\n\nIt's a good idea to define your functions as above. It will make it easier for people who want to copy-and-paste to look at your code.\n\nWhy is this a good idea?\n\nI did it because the poster was asking for feedback on the code. I figured he'd get more useful feedback if people could see the whole thing at once.\n\nI see. I just find it a little annoying when people post code snippets and they're like \"Hey guys, I'm learning how to program! Please tell me what's wrong with my code so I can improve\" and then they put these little \"snippets\" that are like 50 lines long.\n\nWorst:</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    suffix = string.find('a')\n    postfix = suffix.find('a')\n    postfix.reverse.replace('a', 'a') + suffix\n    return string[::-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    # find the longest palindrome postfix of supplied string\n    # that is a palindrome\n    return string.split('').reverse().find(1)\n\npalindrome = make_palindrome('catacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatacatac", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string + str[::-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if len(string) == 0:\n        return string\n    length = len(string)\n    postfix = string[::-1]\n    prefix = string[::-1:length]\n    return string + reverse(prefix) + postfix\n\nYour code makes a cat-shaped string from the palindrome catac.</s>", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string.startswith('a'):\n       return 'a' + reverse(string.prefixed(':')) + string.prefixed('a'):", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    d = string.lengthest(string[::-1])\n    s = string.substring(0, d)\n    s = string.reverse()\n    return s + string.substring(0, d)", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    # Find longest postfix\n    # and find if it's a palindrome\n    prefixes = string.split()\n    longest = longest_prefixes(prefixes)\n    postfix = ''\n    for i in range(len(prefixes)):\n       postfix += prefix[i]\n    # Reverse postfix and see if it's palindromic\n    reverse = postfix[::-1]\n    if postfix!= reverse:\n       return ''.join(prefixes)\n    return postfix + reverse", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string[::-1] == string[::-1] + reverse(string[::-1] + 1)", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    length = len(string)\n\n    suffix = string[::-1]\n    prefix = string[::-1] + string.rjust(len(suffix))\n    while suffix is not None and prefix is not None:\n         prefix = prefix.rjust(len(suffix))\n         suffix = suffix.rjust(prefix.rjust(suffix))\n         suffix = suffix.rjust(suffix.rjust(suffix))\n         suffix = suffix.rjust(suffix.rjust(suffix))\n         suffix = suffix.rjust(suffix.rjust(suffix))\n         suffix = suffix.rjust(suffix.rjust(suffix))\n         suffix = suffix.rjust(suffix.rjust(suffix))\n         suffix = suffix.rjust(suffix.rjust(suffix))", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    length = len(string) - len(string[::-1])\n    new_palindrome = []\n    for i in range(1, length - 1):\n         if string[i] == string[::-1]:\n             new_palindrome.append(string[i])\n         new_palindrome = new_palindrome[::-1]\n    return new_palindrome", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    if string[::-1] in string:\n        return string[::-1]\n    if len(string) == 1:\n        return string[::-1]\n    prefix = string[::-1]\n    suffix = string[::-1]\n    palindrome = prefix + suffix + string[::-1]\n\nI'd make it take a string and a length argument. I'd also make it return True instead of bool.\nAnd I'd rename it to is_palindrome\nI'd also make it take a string and a length argument.\n\nYou are definitely right on all counts. I was trying to make an easy to understand example, but forgot the \"don't do that\" rule:\nWhen you are teaching, make your examples as simple as possible, but not simpler.\n\nThe real trick with palindromes is to use the right tool for the job. If you need to know if a string is a palindrome, use a function. If you need to know if a string is a palindrome that starts with a particular character", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.find_first_not_equal(string.find_first_not_equal(string.reverse(string.prefix(string)), string.startswith('c'))) + string.find_first_not_equal(string.find_first_not_equal(string.reverse(string.suffix(string))))", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.split(' ', 1).reverse() + reverse(string[::-1])", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.replace('a', string.reverse('a'))", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    with string[::-1]", "def is_palindrome(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef make_palindrome(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> make_palindrome('')\n    ''\n    >>> make_palindrome('cat')\n    'catac'\n    >>> make_palindrome('cata')\n    'catac'\n    \"\"\" \"\"\"\n    return string.split('.')[::-1].reverse() + string.split('.')[-1].reverse()\n\nAny efficient algorithm?\n\nThe string is represented as a [unicode code point, UTF8 code unit] pair.\nSo,\nwhile (1):\n        let mut first = 0;\n        while first!= end:\n              let mut last = first + 1;\n               let new = last.to_bytes();\n                 first = last.to_bytes() - last;\n                  last = new;\n                            if new == end:\n                                   break"]]