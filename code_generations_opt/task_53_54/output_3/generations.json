[["def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __add__(self, x, y):\n    \"\"\"Return a result of the sum of x and y\n    >>> a = add(2, 3)\n    >>> a\n    5\n    >>> print(a)\n    5\n    >>> a += 5\n    >>> print(a)\n    10\n    \"\"\"\n    return x + y\nYes. As someone else mentioned, this is just a coincidence.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\nfrom itertools import product", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    >>> add(5, 7)\n    \"\"\"\n    return x + y\nThis isn't a joke, right? If it's a joke, it's a bad one.\n\nNope, it's not a joke. Maybe you are looking at the wrong line?\nI just made the line above a bit more verbose because I thought it was not clear.\n\nIt's just that it's too verbose. The whole function could be replaced with one line:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    x = x + y\n    return x\nThis is a pretty good example of how the format of this code is now perfectly fine for human consumption, but makes reading the code more difficult.\n\nIf you are not using something like Jupyter notebook, then you are doing it wrong.\n\nI would argue that reading and writing code is the only purpose of code, so if you need to learn to read a format that is not easily readable, then you are doing it wrong.\n\nI would argue that the main purpose of code is to be executed. If we have to choose between readability and execution, then we should always pick execution.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\n\nWhen you see code like this, you are being asked to solve an artificial problem. There is no reason to have an add function when addition is built into the language. You are given this code to make you exercise your mind to solve a problem that is not there. The problem you are being asked to solve is to figure out the solution to the artificial problem.\n\nThis is a common and valid approach to interviewing. I have never been asked this question, but if I had been asked, I would have asked how the code is used and what it is for. If I had been able to come up with a use case, then I might have tried to solve it using the natural language instead of the programming language. I would have used a language construct that did not exist in the language, but I would have used it in a way that was clear to the reader what I was doing.", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\n    def add_if(x: int, y: int):\n    \"\"\"Add two numbers x and y and return the bigger one.\n    >>> add_if(2, 3)\n    7\n    >>> add_if(7, 3)\n    10\n    \"\"\"\n\n    def add_if_if(x: int, y: int):\n    \"\"\"Add two numbers x and y and return the bigger one.\n    >>> add_if_if(2, 3)\n    10\n    >>> add_if_if(3, 3)\n    9\n    \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add_int_example(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add_int_example(2, 3)\n    5\n    >>> add_int_example(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add_float(x: float, y: float):\n    \"\"\"Add two floats x and y\n    >>> add_float(2.1, 3.2)\n    5.5\n    >>> add_float(5.5, 7.8)\n    12.3\n    \"\"\"\n    def add_float_example(x: float, y: float):\n    \"\"\"Add two floats x and y\n    >>> add_", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    pass\nWhy do people even comment code like this?\n\nBecause the code is in a different language than Python.\n\nNo, it's not. This is obviously a python snippet that got pasted into some kind of code-reuse-generator website.\n\nPaste-N-Share, to be specific.\n\nYes, and with a good taste of broken unicode:\nhttps://paste.pocoo.org/show/1\n\nI thought this was just a joke, but after a bit of googling, I found this \"support.pocoo.org\" site which claims to provide support for the PNS service.\nIt's amazing that they have an entire FAQ page dedicated to this issue! I couldn't find the actual source of the error, but it looks like it's a bug in the javascript:\nhttps://paste.pocoo.org/", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __add__(self, other):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    if other == 0:\n       return x + y\nI love python's syntax.\n\nShouldn't Python be using English-like syntax by now?\n\nThe Python documentation strongly prefers using English-like syntax. I don't see why you say \"by now\".\n\nOkay, that's a fair point. But the examples I see from Python programmers on the web are usually not English-like.\n\nWhat I find most interesting about the language are the syntactic sugar features.\nFor example, the `def` statement is the equivalent of `class` in Java, except that you can use it for functions as well. That's pretty cool.", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __init__(self, x, y):\n    \"\"\"Initialize the adder.\"\"\"\n    self.x = x\n    self.y = y\n    self.sum = 0\n    self.op = 0\n\n    def add(self, x, y):\n    \"\"\"Add two numbers x and y.\"\"\"\n    if self.op == 0:\n        return self.x + self.y\n    else:\n        return self.x + self.op(self.y)\n\n    def op(self, y):\n    \"\"\"Opcode for the adder.\n    >>> op(3)\n    3\n    >>> op(3)\n    Traceback (most recent call last):\n    File \"<stdin>\", line 1, in?\n    op(3)\n    TypeError: op() takes exactly 1 argument (0 given)\n    >>> op(3, 3)", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    if x == 0:\n        return -1\n    return x + y\nThis is python right?  If you want to post code use four spaces before each line so it formats correctly.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def a(x: int, y: int):\n    \"\"\"Return the sum of x and y\n    >>> a(2, 3)\n    7\n    >>> a(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def b(x: int, y: int):\n    \"\"\"Return the product of x and y\n    >>> b(2, 3)\n    12\n    >>> b(5, 7)\n    25\n    \"\"\"\n    def add_all(a: add(int, int), b: add(int, int))", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    if x < y:\n       return x + y\n    else:\n       return x + x + y\nYes, this is not good. How would you improve it?</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\n    def double(x: int):\n    \"\"\"Double a number x\n    >>> double(2)\n    8\n    >>> double(3.5)\n    13.0\n    \"\"\"\n    def string(x: int):\n    \"\"\"Return a string representation of a number x\n    >>> string(3)\n    '3'\n    \"\"\"\n    def list(x: int):\n    \"\"\"Return a list of numbers x\n    >>> list(2, 3, 4, 5)\n    [2, 3, 4, 5]\n    \"\"\"\n    def tuple(x: int):\n    \"\"\"Return a tuple of numbers x\n    >>> tuple(2, 3, 4, 5)\n    [('2', 2), ('3', 3), ('4', 4), ('5', 5)]\n    \"\"\"\n    def string_list(x: int):\n    \"\"\"Return a string list of the numbers x\n    >>> string", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n       if x > y:\n          return x\n       else:\n          return y + x\nI think this is why some people prefer C++.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x, y):\n    \"\"\"Add two numbers x and y\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\nThe other code is better because it's shorter and no repetition is involved.  The first one is shorter than the second, but not shorter than the third.\nFor me the second is more clear.\nThe first is more likely to be executed with a combination of ';' and '::' and thus is more likely to be buggy.\nWhat are you referring to when you say \"a combination of ';' and '::'?\nI've never seen ';' or '::' used as the end of a statement.  Those are usually used in combination with ';' or '::' within a statement, as in this example:      def add(x, y):         return x + y\n\nThis code is in a text editor. This is the output of the code in a text editor.\n>>> def add(x, y):\n    \"\"\"Add two numbers x and y", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\nI don't know why the parens are there, but I think you're supposed to write it like this:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add_monoid(x, y):\n    \"\"\"Monoid addition. This is the same as the add method above, but\n    we don't have to pass in the other argument. Note that this is a\n    subclass of the built-in Monoid class.\n    >>> monoid.add_monoid(2, 3)\n    5\n    >>> monoid.add_monoid(5, 7)\n    12\n    \"\"\"\n    def add_a:\n    \"\"\"Monoid addition with a base. This is the same as the add method\n    above, but we don't have to pass in the other argument. Note that\n    this is a subclass of the built-in Monoid class.\n    >>> monoid.add_a(2, 3)\n    5\n    >>> monoid.add_a(5, 7)\n    12\n    \"\"\"\n    def add_b:\n    \"\"\"Monoid addition with a base. This is the same as", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\nThe naming style seems to be functional/OO/Pythonic, but the use of underscores for function parameters and lack of explicit return type seem to violate the language's style guide.\n\nI'm pretty sure that's one of the few things that the Python style guide allows you to break ( _\"underscores are not required\"_ ). That being said, I don't like it.\n\nYeah, I was pretty sure I had seen that in the style guide.\nThe lack of a return type is just something I'm used to from working with Ruby.\n\nAaah, so it's not Pythonic, it's Rubyish.\n\nI'm not sure I get the \"un-Pythonic\" critique. What does this have to do with Pythonic?\n\nPython has a rather strong culture around its name, and that culture includes the Python style guide.\nThis has nothing to do with the language itself; it's just a way of writing in the language that doesn't adhere to the style guide.\n\nNaming things in languages like that is just as useful as not naming them at all.\n\nWouldn't this be a fairly good example of using a common interface for functions?</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\nI love how no one complains that this is a bad habit.  I think it is a very bad habit.\nWouldn't it be better to return (x + y) in this case?\nI'm not sure. I would have to think about it more to really be able to make a decision.  I like the idea of return (x + y) in this case though because it will make it more obvious what is going on.\nI like returning the value and using the method name as documentation. I can always look at the method name to see what it does.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add2(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add2(2, 3)\n    7\n    >>> add2(5, 7)\n    12\n    \"\"\"\n    def add3(x: int, y: int):\n    \"\"\"Add three numbers x, y, and z\n    >>> add3(2, 3, 4)\n    9\n    >>> add3(2, 3, 4, 5)\n    14\n    \"\"\"\n    def add4(x: int, y: int, z: int):\n    \"\"\"Add four numbers x, y, z, and w\n    >>> add4(5, 7, 9, w)\n    18\n    >>> add4(5, 7, 9, w, 3)\n    23\n    \"\"\"\n    def add5(x: int, y: int, z: int, w: int):\n    \"\"\"Add", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\nI'm not sure if you're making a joke, but I think there is actually a way to define sum types like this in Scala.\n\nIt looks like the OP is looking for a static type system, whereas Scala is dynamically typed.\n\nNope, I was trying to make a joke...</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\nThat's a bad example because the name of the function is different. This is a pretty standard naming convention, where you keep the name of the function, but append a comment that describes what the function does. The code looks like the function add(x, y) is being defined twice, but that's not the case.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def main():\n    \"\"\"Main program that uses the add function\n    >>> print(add(2, 3))\n    5\n    >>> print(add(5, 7))\n    12\n    \"\"\"\n    add1 = add(2, 3)\n    print(add1)\n    return 0\n    return add1\nTo me this is the essence of Python.\n\nSo what is wrong with the following?", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\nYou forgot the parentheses.\nThat's what happens when you don't use indentation.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __call__(self, *args, **kwargs):\n    \"\"\"Calculate the sum of two numbers and return it as a float.\"\"\"\n    return sum(self.x + self.y)\n\nNow you can call add like this:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\nIn Python:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\n    def fact(n: int):\n    \"\"\"Return the nth factorial\n    >>> fact(3)\n    24\n    >>> fact(5)\n    120\n    \"\"\"\n\n    def fizzbuzz(n: int):\n    \"\"\"Print nth FizzBuzz\n    >>> fizzbuzz(4)\n    Fizz\n    >>> fizzbuzz(5)\n    Fizz\n    >>> fizzbuzz(6)\n    Fizz\n    >>> fizzbuzz(7)\n    Fizz\n    \"\"\"\n\n    def fibonacci(n: int):\n    \"\"\"Return the nth fibonacci number\n    >>> fibonacci(5)\n    >>> fibonacci(8)\n    13\n    >>> fibonacci(9)\n    21\n    \"\"\"\n\n    def prime(n: int):\n    \"\"\"Return the nth prime", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(5, 7)\n    12\n    \"\"\"\n\nIt's often wise to deprecate and eventually remove the old version of a function before it actually gets removed. Theoretically the old version should always exist for this kind of case, but in practice it is not uncommon to just remove a function without versioning it, so you'd need to resort to `from __future__ import print_function` or some such.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    x += y\n    return x\nI don't like having to explicitly specify that I'm adding two numbers. I prefer:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(5, 7)\n    12\n    >>> add(2, 3)\n    5\n    >>> add(3, 4)\n    8\n    \"\"\"\n    return x + y\nNow you see the problem!\n\nNo, I don't. They both have the same behavior.\n\nGuys, I am asking because i am not sure. Why do people need such \"smart\" stuff in Python?. I have heard about how it is faster than Java. But I don't see that much benefit in Python.\n\nBecause when you need to, you can. I can think of many cases where this can be useful. Just off the top of my head, if I have a list of records, I can do this:\nrecords = [\n{'name': 'John Doe', 'phone': '123', 'address': '1.23.45'},\n{'name': 'Michael Doe', 'phone': '456', 'address': '123.45'", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add2(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add2(2, 3)\n    5\n    >>> add2(5, 7)\n    12\n    \"\"\"\n    def add3(x: int, y: int):\n    \"\"\"Add three numbers x, y, and z\n    >>> add3(2, 3, 5)\n    14\n    \"\"\"\n    def add4(x: int, y: int):\n    \"\"\"Add four numbers x, y, z, and w\n    >>> add4(2, 3, 5, 7)\n    27\n    \"\"\"\n    def add5(x: int, y: int):\n    \"\"\"Add five numbers x, y, z, w, and x\n    >>> add5(2, 3, 5, 7, x)\n    32\n    \"\"\"\n    def add6(x: int, y: int):", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __add__(self, other):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n\nI'm not sure why you'd want to use this instead of the one that comes with the standard library, unless you needed to support a platform that didn't have the stdlib version.\n\nIn python, the standard library functions tend to be named in a way that makes them hard to guess the function of without looking them up in the documentation.\nExample:\n>>> 'foo' + 'bar'\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nAttributeError:'str' object has no attribute 'add'\n\nThis is the kind of situation where the documentation is useful.\n\nThis is also the kind of situation where you write a function that's easy to guess the function of.\nI know the docstring is there, but having to look it up for every function I write is a pain in the arse.\n\nI didn't know you", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Return the sum of x and y.\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\nIsn't this quite a bit of overhead for something that is trivial?\nIt's just a matter of taste. When I read the Python code, I see\nan example of a language where function and method definitions\nare not separated and you are supposed to mix them. When I read\nthe Java code, I see an example of a language where functions and\nmethods are more clearly separated.\n\nI think the larger problem is the use of the ellipsis to denote\nmethods. This is a really bad idea for a number of reasons:\n\\- It makes it hard to tell where the method starts and where it\nends. For example, in Java, if the method has a return\nstatement, then you can tell that it ends at the next line, but\nhow do you know where it ends if it doesn't?\n\\- The use of the ellipsis", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\nI would replace return x + y with return add(x, y)\nHow would you implement your method?</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\nThis would only work for positive numbers. In order to make it work for all numbers you'd have to define it like so:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y;\n    # I know, but I wanted to use this in the example\n}", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    if x < 0:\n       raise ValueError(\"cannot add a negative number\")\n    else:\n        return x + y\nThese are basically the same thing, except the \"return\" in the latter is redundant and it is more clear what the function does if you put the return at the end. In any case, there's no reason to use \"return\" for a function that returns a value, and it will actually confuse people who are new to Python.\n\nNot always. Sometimes you need to initialize an object outside the function.\n\nYeah, fair enough. I'll amend my statement to say that, if you use return, you should always use it _last_.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\n    def add(x, y: int):\n    \"\"\"Add x to y\n    >>> add(5, 2)\n    7\n    \"\"\"\n    return x + y\nI guess the question should have been \"What do you do in a language without list comprehension syntax?\"\n\nWow, did you come up with that all by yourself?\nThat's the same as (x + y)\n\nI did, and I think it's easier to read.\n\nIt's not \"easier to read\" when it's the same thing, just different syntax.\n\nThis is a gross simplification, but this is a perfect example of a very simple problem that's a result of having too much syntax.\nThe original code is, with only a little effort, just as readable as the supposedly simplified version, and a whole lot more concise.\n\nI wouldn't have even noticed there was a problem had the blog post not pointed it out. The problem is minor, and probably never came up in the course of normal development (which I assume is why it's not just the obvious x + y).\n\nSome things never come up in normal development. But", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\nI didn't make this up. I've seen it in a real, production library.\n\nThis is really awesome, I would have never guessed that was going to happen. Is there a good way to search for \"unusual\" Javascript usage patterns?\n\nJust keep in mind that you probably can't trust the type of some function arguments.\n\nWell, that's the point of having an IDE. It should be able to tell you the type.\n\nI believe it's possible to do something like this in Python as well - the same string will be returned in each case.\n\nWith C, the result is the same but the runtime is very different.\nint add(int x, int y);\n// returns 4\nint add(int x, int y, int z);\n// returns 4\nint add(int x, int y, int z, int w, int h);\n// returns 4\n\nIn most other languages the above would return a different value based on the types of the parameters. In Java it would just give you an error.\n\nThat's why it's a joke.\n\nI guess I was just pointing out that in C, it", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add the two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\nThis is a good example of how to use it:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add2(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add2(2, 3)\n    7\n    >>> add2(5, 7)\n    12\n    \"\"\"\n    def add3(x: int, y: int):\n    \"\"\"Add three numbers x, y, and z\n    >>> add3(2, 3, 4)\n    9\n    >>> add3(5, 7, 9)\n    22\n    \"\"\"\n    def add4(x: int, y: int, z: int):\n    \"\"\"Add three numbers x, y, and z\n    >>> add4(2, 3, 4, 6)\n    15\n    >>> add4(5, 7, 9, 12)\n    31\n    \"\"\"\n    def add5(x: int, y: int, z: int):\n    \"\"\"Add five numbers x, y, and z", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add_int(x, y):\n    \"\"\"Add two int numbers x and y\n    >>> add_int(1, 4)\n    5\n    >>> add_int(7, 11)\n    16\n    \"\"\"\n    return x + y\nThis is actually really smart.\n\nThe sort of thing that's easy to do in Python.\n\nIt's not even that easy, you need to add the return value to the original arguments.\n\nI was going to reply that he actually forgot to add this, but it appears you are right.\n\nOne of the things that I don't understand is why so many people are using a language that has a reputation of being hard to read. Python is one of those languages.\n\nI think it's only hard to read if you don't understand the language well.\n\nThat's a good point. However, I wonder how many people do understand the language well?\n\nI do think a lot of people understand the language well. I don't know what the exact numbers are though.\n\nI don't think this is the right forum for this question, but", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\nI don't get it. What's the point of this?\n\nWell, I guess there are a few points.\n1\\. The example code is not useful, but it's not hard to make it useful. E.g. instead of returning the sum, you can return the sum and the total number of additions (i.e. for the 2+3 example, this would be 1).\n2\\. The point of the article is that it can be useful to write down the simplest algorithm to solve a problem, and in this case, it's not complicated to write down a simple addition algorithm.\n3\\. A more general point that's made elsewhere in the article: you should be able to write down the solution to any problem that you can code in Python. So it's important to be able to write down the solution to a problem even if the code is not going to be used, because it will be useful for other purposes.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(5, 7)\n    12\n    >>> add(2, 3)\n    Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    raise TypeError(\"add can only be called with two ints, not one\")\n    >>> add(5, 7)\n    Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    raise TypeError(\"add can only be called with two ints, not one\")\n    \"\"\"\n    if x == y:\n        return 1\n    return x + y\n\nThis way you can still call it with numbers you want to add, and the compiler will tell you when you screw up.\n\nYeah. You _could_ have a static error check like this, but it's probably better to have a nice, friendly exception. Especially for a piece", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\n    def add2(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add2(3, 4)\n    7\n    >>> add2(5, 6)\n    11\n    \"\"\"\n\n    def add5(x: int, y: int):\n    \"\"\"Add five to an integer x\n    >>> add5(2)\n    7\n    >>> add5(3)\n    10\n    \"\"\"\n\n    def add6(x: int, y: int):\n    \"\"\"Add six to an integer x\n    >>> add6(5)\n    11\n    >>> add6(6)\n    16\n    \"\"\"\n\n>>> add2(5, 6)\n11\n>>> add2(4, 2)\n6\n\n>>> add5(6)\n11\n>>> add5(7)\n10\n\n>>> add6(5)\n11\n>>> add6(7)\n11\n\n>>> add2", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\n\nI don't see what's so terrible about it. It's very terse, and easy to understand the flow. It's not even that hard to read, either.\n\nI don't understand the question. The terse version of the first example is the same as the verbose version. The second example is the same as the first, except the second example is a little easier to follow because it's written in Python.\n\nI think the question is: if I'm writing a function, is it better to write the function as concisely as possible, or should I make the function as readable as possible?\n\nI don't see how you could possibly make the first example more readable than the second. The second example is just Python.\n\n\"Is it better to write concisely or to make code readable?\"\n\"How about neither?\"\n\"How so?\"\n\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\n    def print_m(n: int):\n    \"\"\"Print then'th prime number\n    >>> print_m(11)\n    11\n    >>> print_m(15)\n    7\n    \"\"\"\n    return n % prime_numbers.size()\nSo it doesn't work.\nIf I change the", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\nThis is a horrible example. Adding integers is the most trivial thing possible. The usual example is to take a number and find its square, cube, and so forth.\nThat's not what it's for. It's for adding complex numbers.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return add(x, y)\nThe author is essentially making the argument that, in Python, you should use a function as a means to encapsulate a single operation. This is a common pattern in all languages. The author is not making the argument that you should make a new function for each operation you need to perform.\n\nIt's still a lot of boilerplate.\n\nNo it's not. It's one line.\n\nHere is a nice example of a method. \n\nUgh, do not use this. It's a horrible example of the use of classes in Python.", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __init__(self, a: int, b: int):\n         self.a = a\n        self.b = b\n    def add(self, a: int, b: int):\n         return a + b", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\nThis is the code I've seen used in so many different languages.\n\nThat's not idiomatic Python. What you should do is define an operator\nadd, which takes two ints and returns an int. Then use that:\n>>> add(5, 7)\n12\n>>> add(5, 2)\n7\nThis is, in fact, idiomatic Python.\n\nIn Python, how would you define a function that can handle different\ntypes of parameters?\nI did something like this in JS for a project I did, but I couldn't do\nit in Python.\n\nIt's called a \"method\" in Python. Methods are defined in classes.\n\nNo, a method is a function that is defined in a class. It's a common\nmistake to call everything inside a class a method.\n\nYou can also create functions that are not methods.\n>>> def non_method():\n...\n...\n...\n>>> non_method()\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: non_method() takes no arguments\n>>>\n\nThe same can be done in JavaScript with a prototype chain.", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add_with_intermediate(x: int, y: int, i: int):\n    \"\"\"Add x and y,\n    >>> add_with_intermediate(5, 7, 10)\n    12\n    >>> add_with_intermediate(5, 7, 2)\n    7\n    \"\"\"\n    return add(x, y, i)\n    @param x: int\n    @param y: int\n    @param i: int\n    def add(x: int, y: int):\n    \"\"\"Add x and y\n    >>> add(4, 3)\n    7\n    >>> add(4, 3, 1)\n    5\n    \"\"\"\n    return add_with_intermediate(x, y, 1)\n    def add_with_intermediate(x: int, y: int, i: int):\n    \"\"\"Add x and y,\n    >>> add_with_intermediate(5, 7,", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\nreturn x + y\nThe problem with this is that it's not a complete method. You need to specify what the type of x and y are, and you need to return the result.  A complete method would look like this:      def add(x: int, y: int) -> int:           return x + y</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y;", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    print add(3, 4)\n    print add(5, 7)\n    def sub(x: int, y: int):\n    \"\"\"Subtract two numbers x and y\n    >>> sub(3, 4)\n    1\n    >>> sub(5, 7)\n    2\n    \"\"\"\n    print sub(4, 5)\n    print sub(7, 9)\n\nThe functions add and sub are not pure functions. This can be proven by the following refutation:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\nThis is a great example of an implementation detail. The users of the add function don't want to know how you implemented it, they only want to know that it does the right thing.\nIt's all very well and good to make a new language feature that makes the implementation more transparent to the user, but the real point is to make the implementation more transparent to the developer. The developer is the one who is going to have to debug your implementation, not the user.\n\nI think this is being overly defensive. When designing the language, the implementation details are a primary concern. You don't want to create a language which encourages bad implementation details.\nThis is a step toward creating a language which encourages good implementation details.\n\nI don't really agree. I think the primary concern when designing a new language should be expressiveness and simplicity.\n\nWhat is being described here is a syntactic way to express an operation that is more complex than the two primitives that would naturally follow from that syntax. I don't see how this is an expression of simplicity and expressiveness.\n\nA good way to think of it is that the primitives are the base case of the language, and the more complex operations are the derived case. All higher", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __add__(self, x, y):\n    \"\"\"Add two numbers x and y\n    >>> __add__(5, 7)\n    12\n    >>> __add__(5, 2)\n    7\n    \"\"\"\n    return int(x + y)\nI find the string formatting of the first example to be very\nugly.\nWhy not do", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    # These are two functions to generate x and y\n    def x(n):\n    \"\"\"Return x, where n is a number\n    >>> x(3)\n    3\n    >>> x(0.5)\n    0\n    >>> x(0.6)\n    1\n    \"\"\"\n    def y(n):\n    \"\"\"Return y, where n is a number\n    >>> y(3)\n    3\n    >>> y(0.5)\n    0\n    >>> y(0.6)\n    1\n    \"\"\"\n    # Now create a class object and call the two functions\n    class add(object):\n    x = x", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\n    def subtract(x: int, y: int):\n    \"\"\"Subtract two numbers x and y\n    >>> subtract(5, 7)\n    3\n    >>> subtract(2, 3)\n    1\n    \"\"\"\n    return -x - y\nThe first one is pretty standard, the second one is a bit weird, but not a dealbreaker.  The third one is just wrong.  The expression doesn't return anything, it is a function call.  Just add the parentheses back in and you are good.\nThis was my first thought too, but I think he's intentionally ignoring that. I think it's a fair question to ask.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    x += y\n\nOh, the horror.\n(actually, I've seen worse)\n\nSeen worse than Ruby's built in Ruby implementation?\n\nThere's a built in Ruby implementation? I thought Ruby was built in C.\n\nWhy do you have the parentheses on the line \"x += y\"?\n\nGuessing that the author thinks it's C\n\nI thought that Ruby was pretty good at parsing Ruby...\n\nAnd so it should.\n\nI'm confused. What is the point of this article?\n\nI wonder if he's actually a non-native English speaker. I didn't notice until now, but the title should probably be changed to something like \"Ruby, the language is bad at parsing Ruby\".\n\nTitle should be \"Ruby, the language, is bad at parsing Ruby.\"\n\nThere, changed. Thanks for the tip!\n\nIs it just me,", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __add__(self, x, y):\n    \"\"\"Add two numbers x and y\n    >>> print add(5, 7)\n    12\n    >>> print __add__(5, 7)\n    Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n       raise TypeError('add(int, int) must be called in __add__')\n    >>>\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> print add(5, 7)\n    12\n    >>> print add(5, 7)\n    Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n       raise TypeError('add(int, int) must be called in __add__')\n    >>>\n\nThis is a common pattern to make a function more flexible, but it's not useful for a library function that is supposed", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __init__(self, x, y):\n    \"\"\"Initialize the add function\n    >>> add(2, 3)\n    <module'mypackage.add.add'>\n    >>>\n    >>> add(5, 7)\n    <module'mypackage.add.add'>\n    >>>\n    >>> add(2, 5)\n    Traceback (most recent call last):\n       File \"<stdin>\", line 1, in <module>\n          add(2, 5)\n          File \"mypackage.add.add\", line 6, in add\n          y = x + y\n          AttributeError:'module' object has no attribute 'x'\n          >>>\n           >>> add(5, 7)\n           <module'mypackage.add.add", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\nI would use the map function here. But I can't help you with the syntax.\n\nMap is more verbose, but it's usually better than for loops.\n\nI'm a bit surprised the author chose Python to show this problem. In Python, adding a list of numbers together is a very common operation, and the normal way to do this is with the + operator. So the first thing I would have thought to do is to replace the + with something else to see if that helps.\nPython doesn't have a built-in function for adding two integers, but the equivalent of a + operation can be done with a call to the built-in function builtin.carry (or builtin.hex, if you're working with hexadecimal numbers). And you can test the result with isinstance(builtin.carry(x), int) (or isinstance(builtin.hex(x), int) if you're working with hexadecimal numbers).\nIf you're dealing with a list of integers, you can use this:\n>>> print(builtin.carry(x) + x)\n5\nSo the problem here is that the author is passing two arguments to a function that doesn't", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\nWhat's the point?\n\nIt shows how stupid it is to try to \"improve\" the language by making it look more like another language.\n\nIndeed. I am one of those who often says \"I like Python as it is, thank you\", and this is _why_ I like it as it is.\n\nI've been using Python since the 1.x days and I've had a few moments where I thought, \"I wish Python was a bit more like C++ in that aspect\", but none where I've said \"I wish Python was a bit more like C++ in that aspect\".\n\nI'm a Java programmer who's been learning Python over the past few months. I'm sure this is a stupid question, but why is the Python version of this so ugly? I've seen tons of examples of Python code that looks like this and it looks really unappealing", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\nIn other words, two numbers x and y are added.\nYes, this is the same as the previous question, which had two conditions.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\nThat's a horrible example. Python makes it clear that this is a function, not a method, since the return type is specified.\n\nYes, but...", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x+y\nWhen I think of a \"simple\" function I think of one that uses fewer lines of code. This one uses 4.\n\nIt's simple to understand what it does.\n\nSo is add(x, y)\n\nThen we have different definitions of simple. The line of code is the simplest possible way to do what it does.\n\nI don't think we do. Your definition is the simplest code that expresses the behavior of the function. My definition is the simplest code that expresses the behavior of the function.\n\nWhat's the point of your version? You gain no expressiveness by making a function definition longer.\n\nI can't speak for the GP, but I can tell you that I prefer to use that version in my own code. In general, I'd prefer to write a function like this:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __init__(self, x, y):\n    \"\"\"Initialize the add function\n    >>> add = add(2, 3)\n    >>> add(3, 7)\n    >>> add(8, 14)\n    5\n    12\n    \"\"\"\n    self.x = x\n    self.y = y\n    def add_it(self, x, y):\n    \"\"\"Return the sum of two numbers x and y\n    >>> add_it(5, 7)\n    12\n    \"\"\"\n    return x + y\n    def add_it_same(self, x, y):\n    \"\"\"Return the sum of two numbers x and y\n    >>> add_it_same(5, 7)\n    12\n    \"\"\"\n    return x + y", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\nLooks like some people are going to have a problem understanding this code :)\nI would suggest to put \"return\" in quotes.\nI agree, that would help a lot.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\nMy point is that this is a silly example.\nIn general, is this the best way to think about code? I feel like it is a good way to think about the code but not the best way to think about the algorithm.\n\nNot a big fan of this kind of example.\nI mean, if you read the code you should be able to grasp what it does. If not, maybe you should work on your reading comprehension.\nWhat the code is doing is essentially obfuscation.\n\nWell, I'm not so sure I'd call it obfuscation, because it does get the point across, but I agree that it's not necessarily the best way to think about code.\nAs an aside, I like to think about code in this way sometimes, but with the implementation in-line. This way you don't have to worry about the data structures or the runtime (or if", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y;\n\nNote the lack of type annotation.  However, if you'd like to add a type annotation, you can do so by adding the type annotation after the function definition, for example:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def _add(x, y):\n    \"\"\"This is a helper function which adds x and y\n    >>> _add(7, 2)\n    11\n    \"\"\"\n\nIt would be better to pass the parameters to the function as a tuple:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add2(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add2(3, 2)\n    5\n    >>> add2(3, 4)\n    7\n    \"\"\"\n    def add5(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add5(5, 2)\n    7\n    >>> add5(5, 3)\n    10\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(3, 4)\n    7\n    >>> add(3, 5)\n    10\n    \"\"\"\n    def add2(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add2(3, 4)\n    7\n    >>> add2(3, 5)\n    10", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def test(n: int, x: int, y: int):\n    \"\"\"Test that add works.\"\"\"\n    n, x, y = n, x, y\n    print(add(n, x, y))\n    print(\"done\")\n    return n\n    def main():\n    \"\"\"Main program.\n    >>> import sys\n    >>> print(sys.version)\n    '2.6.2'\n    >>>\n    >>> import add\n    >>> print(add.test(10, 5, 3))\n    10\n    >>>\n    >>> add.main()\n    >>>\n    >>> print(add.main())\n    done\n    \"\"\"\n    n, x, y = 10, 5, 3\n    add(n, x, y)\n    print(add.test(n, x, y))\n    print(\"done\")\n\nThis is Python version 2.6.2, an implementation", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Return the sum of x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def sub(x: int, y: int):\n    \"\"\"Subtract x from y\n    >>> sub(2, 3)\n    2\n    >>> sub(5, 7)\n    2\n    \"\"\"\n    def sub(x: int, y: int):\n    \"\"\"Return the difference of x and y\n    >>> sub(2, 3)\n    2\n    >>> sub(5, 7)\n    2\n    \"\"\"\n\nThese are the classes that were originally in the file:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    if x >= y:\n       return x\n    else:\n       return add(x - y, y)\n       def sub(x: int, y: int):\n    \"\"\"Subtract two numbers x and y\n    >>> sub(2, 3)\n    2\n    >>> sub(5, 7)\n    3\n    \"\"\"\n    if x < y:\n       return x\n    else:\n       return add(x + y, y)", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def a(x: int, y: int):\n    \"\"\"Returns the sum of x and y\n    >>> a(2, 3)\n    7\n    >>> a(5, 7)\n    12\n    \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\n    \"\"\"\nThis is not a very good example of a class method. First, the\ndescriptive name is not very descriptive.  Second, it doesn't really\nmake sense to write a function that adds two numbers.  It should be\nincluded in the sum function. Third, you can't easily override it if\nyou don't like what it does.  The best way to add two numbers is to\nwrite something like this:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __init__(self, x, y):\n       self.x = x\n       self.y = y\n    return self\nI've found that `__init__` is a good place to put the most important things in a function.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\nI'm sorry, but the code looks terrible to me.\na better way to do it is to use list comprehension:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\ni think the code isn't self documenting, i.e. what happens to the arguments?\ncouldn't someone add 4 to the code and have it print \"5 4\"?\n\nYou are right. The example is a little bit more complicated than it needs to be, but I think it is a good demonstration of the benefits of using a variable-binding style over a function-call style.\nI think the most important benefit of using a variable-binding style is that the code is much more readable. This benefits not just the person who wrote the code, but also the person who will come along later and will have to understand it.\nThe major disadvantage of using a variable-binding style is that some people don't like it. The reason is that the style is so different from the traditional function-call style that people often find it hard to understand the code at first.\nIn the", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __add__(self, y: int):\n    \"\"\"Add this number to self's result\n    >>> add(5, 7)\n    12\n    >>> add(4, 3)\n    7\n    \"\"\"\n    result = 0\n    while x < y:\n       result += x\n    result\nThe classic example of a method that can't be overriden. But what if you want to do it the way it is done in the example above, by moving all the work to the method? You have to define the method as a function that returns another method.", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __add__(self, other):\n    \"\"\"Add two numbers x and y\"\"\"\n    return self + other\nPython is well designed, especially the python community.\n\nThe Python community is very helpful, I agree. But to say it's \"well designed\" is to be very generous to the language designers.\n\nAs a Haskell programmer I can tell you that Python and Java are much better designed than Haskell.\nThe only reason why Haskell is more popular than Python or Java is the Haskell community (I am talking about the academics) being very active on the internet.\nThe number of Haskell programmers is proportional to the number of Haskell users.\nThat said, I prefer the Haskell type system to Python's and Java's.\n\nI think if you take the question of \"well designed\" to mean that the community is welcoming and that the language has a clean and consistent design, then perhaps that's true.\nBut I think if you take the question of \"well designed\" to mean that the language is a good design (i.e. it's a good language), then I don't think that's true at all. The language is full of flaws.\nAnd, I wouldn't", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Return the sum of x and y\n    >>> add(5, 7)\n    12\n    \"\"\"\n    if x == y:\n       return x\n    else:\n       return add(x-y, y)\nthis is how I'd do it, for a small snippet.\n\nYeah, I don't see why this is a \"new\" way to do it... I do it exactly like this.\n\nThat's the point of the article: it's not a new way to do it. It's the same way you would do it. This is a new way to _think about_ doing it.\nThe trick is to see it the way the Python interpreter does it: it doesn't think about adding two numbers as \"returning the sum of x and y\". It thinks about it as \"returning the value of x + the value of y\".\n\nThat's a good way to think about it for large numbers. However, if you have a handful of smaller numbers it's better to think about the", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\nThe language of the article is Python, but the examples are C.\n\nI love C, but most people who don't use it regularly just don't get the \"correctness\" of C. While it is quite elegant, it's not really for the faint of heart.\n\nWhile I have a feeling that your comment will get downvoted, I think this is a fair criticism. I do think that Python is easier for people to pick up than C, as its syntax is much more consistent than C's.\n\n\"Don't get the \"correctness\" of C\".\nC is a very clean language in many ways. But it has so many gotchas and corner cases. Sometimes you really do have to have a PhD in C to understand how things work.\nC is probably my favorite language, but it can really drive you nuts.\n\nInteresting, I'm", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\n    def add2(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add2(2, 3)\n    7\n    >>> add2(7, 5)\n    12\n    \"\"\"\n    def add3(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add3(2, 3)\n    7\n    >>> add3(5, 7)\n    12\n    \"\"\"\n\nI'm new to python, but this seems to be the idiomatic way of doing it.\n\nIs there a way to get a function (or operator) to return only one value?\n\nYou would have to define a function with a single parameter that returns the single value you want to return.\n\nHow do you go about defining a new operator in python?\n\nPython is dynamically typed, so you could define a new function that happens to take the same parameters as a built-in function that you want to use as an operator.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x, y: int):\n    \"\"\"Add x and y\n    >>> add(5, 2)\n    7\n    >>> add(7, 2)\n    9\n    \"\"\"\n\nI'm not even kidding, I have seen this in production code.\n\nThis reminds me of the time I found this in a fairly well known codebase:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\nI would argue that this is a fairly terrible way of doing it. This is not idiomatic Python.\nIt looks like a hack to me, and I'm sure it could be expressed more concisely in Python.\n\nThis is \"idiomatic\" for Python 3.0 (and 2.7). I find it more succinct than the alternative I suggested.\n\nIt looks like a hack to me, and I'm sure it could be expressed more concisely in Python.\n\nI can't imagine anything less idiomatic than the 1.5-style \"def add(x, y):\".\n\nI've always used the = operator for assignment. I don't see how it could be more concise than that.\n\nBecause = is an infix operator. This is a recursive function, so the = operator would be a non-local variable. The indented assignment is a block in a function, which is an infix operator.\n\nI've always used the = operator for assignment. I don't see how it could be more concise than that.\n\nBecause = is an infix operator. This is a recursive function, so the = operator would be a non-local variable. The indented assignment is a block", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\nThis is not a copy-paste error, it is a _real_ python code.\n\nI would consider it a \"copy-paste error\" if you have to copy and paste it into your editor.\nThe usual way of importing modules is\nfrom module import *\n\nWhen you need to write a function that is part of the library, not one that is part of the code you are writing.\n\nI would consider this to be a good example of why duck typing is superior to static typing.\n\nIn python, you don't really have a choice. You have to implement interfaces that the standard library does not provide for you.\n\nThere are some advantages to \"duck typing\". Most notably the ability to add new functions with little fuss, and the ability to add your own functions to the library without having to recompile your application.\n\nHow is the \"ability to add new functions with little fuss\" an advantage to duck typing? It's an advantage to dynamic languages in general, but duck typing doesn't give you that advantage.\n\nSorry, I may have been unclear. I'm not talking about adding new functions to a program; I'm talking about adding new functions to the standard library.\nAs an", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    # It's just a wrapper around the real add function\n    def add_real():\n    \"\"\"Add two numbers x and y\n    >>> add_real(2, 3)\n    5\n    >>> add_real(5, 7)\n    12\n    \"\"\"\n    # But this is the same as `add`\n    # Calling `add_real` is an optimization for human readability.\n    def add_real_wrapper():\n    \"\"\"Add two numbers x and y\n    >>> add_real_wrapper(2, 3)\n    5\n    >>> add_real_wrapper(5, 7)\n    12\n    \"\"\"\n    # The compiler will probably optimize away the wrapper anyway.", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\nRight, this is even better:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __init__(self, x: int, y: int):\n        self.x = x\n        self.y = y\n    def add(self, r: int, s: int):\n        if r > self.x:\n            raise Exception(\"bad argument\")\n        r = self.x + r\n        if r > self.y:\n            raise Exception(\"bad argument\")\n        y = self.y + s\n\nPython is nice for its readability and its expressiveness. However, I think a lot of people who write Python don't realize that they are using the Python _syntax_ to hide _implementation_ details. There are many implementation details that you would probably have to implement yourself in a language like C++ or C#. If you don't like the syntax, you can always use a different one.\n\nI agree with that, and I'm not even a", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(5, 7)\n    12\n    >>> add(2, 3)\n    Traceback (most recent call last):\n           File \"\", line 1, in <module>\n             add(2, 3)\n             ^\n             >>> add(2, 3)\n             Traceback (most recent call last):\n            File \"\", line 1, in <module>\n              add(2, 3)\n             ^\n             >>>\n             KeyError: add", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __init__(self, x, y):\n    \"\"\"Create an add function\n    >>> a = add(2, 3)\n    >>> a\n    >>> b = add(5, 7)\n    >>> b\n    >>> a + b\n    >>> 12\n    \"\"\"\n    self.x = x\n    self.y = y\n    def add(self, other):\n    \"\"\"Add two numbers a and b\n    >>> add(a, b)\n    >>> a\n    >>> b\n    5\n    12\n    \"\"\"\n    return self.x + self.y\n   \nThis is something that I do often, and I also just write it this way. I find it quite easy to read and understand.\n\nThe only thing I would add to this is a short blurb about why you chose to write it that way, and what the intended audience for the code is.\nThere are a lot of people who will look at this and think \"What? This", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\nThis is Java. Java doesn't have pointers.\n\nI am aware. I did not create this question, I just figured I'd post a solution.\nI was initially skeptical when I saw the question, but it turns out that you can implement add in Java without a loop (there's a sort of loopless/blocked approach), which is pretty cool.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __init__(self, x: int, y: int):\n        self.x = x\n        self.y = y\n    return\n    def add(self, x: int, y: int):\n        return self.x + self.y\nThe first class is the prototype, and the second class is an instance of the prototype. I don't see how the second class would need to override __init__, but it's not clear what you're trying to do here.\nedit: The second class should implement add(self, x, y) instead.\n\nI was hoping that the __init__ method would be invoked in the first class, but that's not possible, is it?", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\nWhy not just use the built-in `add` function?\n...I guess the OP was trying to be cute?\n\nI think he was trying to be \"clever\" with the syntax and \"efficient\" by using `x += y`.\n\nMy favorite:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    if x < y:\n        return x\n    if x == y:\n        return x\n    return x + y\nYou've got a semicolon at the end of line 9 that should be a period.  Line 10 should probably be      return x + y\nEven better:      return x + y\n\nWhat about      return x + y\n\nSemicolon is valid syntax in Python, it's just a no-op.\n\nThis is not true. It is not a syntax error, but it does have side effects.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    if x > y:\n        raise ValueError(\"Illegal operation: add of negative numbers\")\n    return x + y", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __init__(self, x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    >>> add(5, 7)\n    >>> add(2, 3)\n    \"\"\"\n    self.x = x\n    self.y = y\n    if __name__ == \"__main__\":\n       print add(5, 7)\n       print add(5, 7)\n       print add(5, 7)\n       print add(5, 7)\n\nThis isn't the same thing, but rather a kind of decorator. The original idea was just the same as the above, but with an added `x, y = self.x, self.y` in the __init__.\n\nHow is it different than decorator?</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x+y\nThis was my first thought too, but I think it should be written like this:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\nI don't think it's a good idea to define functions as an explicit return type. Especially in python, where you're encouraged to return data objects.\nThe author mentions that he has only a slight background in python. I think it's safe to assume that this is his first time programming. I'd recommend that he start out learning python from the ground up, before he attempts to learn more advanced concepts like OO programming.\n\nI agree, Python doesn't really have the concept of a function, it has a callable object. If you have a function that is more than a few lines long, you probably want to break it up into multiple functions.\n\nPython has a concept of function. It's the first example in the tutorial.\n\nHe didn't define add() as a function, he just defined it as a variable.\n\nIn Python, functions and variables are the same thing, as I'm sure you know. Functions in Python are objects, and objects in Python are variables.\n\nI suppose that's true, but that is misleading.\n\nI'm going to have to call you on that one. What about that is misleading?\nI can create a function as an", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\nThis is a syntax error.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\nThanks for the submission. I really like that you included the return statement.\n\nThis is a horrible abuse of Python's list comprehensions. They're really not meant for long sequences of operations. The whole point of a list comprehension is to create a new sequence. Here, you're not creating a new sequence, you're mutating the existing sequence. This code could be rewritten as:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n\nI'm not a Python expert by any means but my first thought is that you can call `add` with an empty list and you'd get an error.\n\nIt's a valid syntax, and you would get an empty list as result.\n\nGood catch. Thanks.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add_mul(x: int, y: int):\n    \"\"\"Multiply x and y\n    >>> add_mul(2, 3)\n    7\n    >>> add_mul(5, 7)\n    21\n    \"\"\"\n    def add_div(x: int, y: int):\n    \"\"\"Divide x and y\n    >>> add_div(5, 7)\n    7\n    >>> add_div(2, 3)\n    1\n    \"\"\"\n\nval stack = [2, 3, 5, 7, 2]", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\nThe arguments to def in python are optional.\nIf you want to use them, you should indent them with an extra tab.\n\nNot in Python 3.\n\n>>> def foo(x: int, y: int):\n...\n>>> print(foo(2, 3))\n5\n\nI hate Python 3.\n\nHow do you _write_ this in Python 3?", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __init__(self, x: int, y: int):\n        self.x = x\n        self.y = y\n    def add(self, x: int, y: int):\n        if self.x!= x:\n            raise ValueError('x must be an integer')\n        return self.y + self.x\n\nPython 2", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n       def __init__(self):\n          self.x = x\n          self.y = y\n          return self\n       def add(self, x: int, y: int):\n          if y <= 0 or x <= 0:\n             return self.y\n            if x == 0 or y == 0:\n                return self.x\n             return self.x + self.y\n           return add\nimport math", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\n    def __add__(self, x: int, y: int):\n    \"\"\"Add the numbers self and x and return the result\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n\n    return self + x + y\n\nThis works perfectly fine, except when x or y is zero. Then, the resulting value is 0.\n\nIt would be great if it returned the value as well as the int.\n\nAdding (the number)\n\nimport java.util.Arithmetic", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def sub(x: int, y: int):\n    \"\"\"Subtract two numbers x and y\n    >>> sub(2, 3)\n    -1\n    >>> sub(5, 7)\n    2\n    \"\"\"\n    def mul(x: int, y: int):\n    \"\"\"Multiply two numbers x and y\n    >>> mul(2, 3)\n    6\n    >>> mul(5, 7)\n    15\n    \"\"\"\n    def div(x: int, y: int):\n    \"\"\"Divide two numbers x and y\n    >>> div(5, 7)\n    3\n    \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\nx: int = 2\ny: int = 3", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\n    def __getitem__(self, item):\n       return x * y\n    def __getitem__(self, *args):\n       return self.__getitem__(args[0])\n    def __setitem__(self, item, *args):\n          self.__setitem__(item, args[0])\n          self.__setitem__(args[0], self.__getitem__(args[1]) + args[2])\n    \"\"\"\n    def add(self, x: int, y: int):\n        return self.__getitem__(self.__setitem__(x, y), self.__getitem__(y))\n    def __repr__(self):\n         return \"%d*%d\" % (self.__class__.__name__, self.__class__.__getitem__(0))\n    def __str__(", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return add(x, y) + x + y\nThat's not Pythonic.\nWhy?\nI can't see the point of a function that does nothing but call itself.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    print(\"Enter two numbers\")\n    y = input(\"Enter a number: \")\n    print(\"Enter the second number: \")\n    if y == \"\":\n        print(\"No second number entered\")\n    else:\n        print(\"Enter the second number\")\n        y = input(\"Enter a number: \")\n        print(\"Enter the second number: \")\n        if y == \"\":\n           print(\"No second number entered\")\n           return\n    print(\"Enter the sum: \")\n    sum = 0\n    print(\"Sum: \" + sum + \", \" + x", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\nI'm not familiar with Python, but this looks like a fragment of a very bad \"tutorial\". It looks very much like a \"Hello World\" program. It doesn't even have any code, it's just a string.\n\nIt's not the worst. That would be something like \"def add(x: int, y: int): return x+y\"\n\nI did find a variation of that, as well as a \"you can pass variables by naming them\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\nI like it.  Though I would name it add1 and add2.  This is more descriptive, and more in line with some other languages.\nWould you call `addOne` if it was only one number? I would say no.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add2(x, y):\n    \"\"\"Add two numbers x and y\n    >>> add2(2, 3)\n    5\n    >>> add2(5, 7)\n    12\n    \"\"\"\n    def add3(x, y):\n    \"\"\"Add three numbers x, y, and z\n    >>> add3(2, 3, 4)\n    13\n    >>> add3(5, 7, 4)\n    18\n    \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    print(x + y)\n    return x + y", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def _add(x, y):\n    \"\"\"Return the sum of x and y\n    >>> _add(5, 7)\n    12\n    \"\"\"\n    return x + y\nThis is a joke, right? If not, you might want to reconsider your choice of career.\n\nI don't know about it being a joke, but I would expect it to have an implementation of _add in the same module.\n\nThe function signature is not meant to be read by another programmer, but by the compiler. There is no reason to implement the function. If you do need to implement it, you would do it in the implementation of _add.\n\nIf you want to understand programming, you should learn how to read and write code like this. Then you can understand why it's there and decide whether you want to do it the same way.\n\nThis is a reasonable answer, but I believe you are misreading the original question. The question was not \"What is this code supposed to do?\", but rather \"What is the point of writing it this way?\".\n\nIn addition to what the others said, I'd add that it is concise.", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\nI'm not sure if you're trolling.\nI thought the purpose of the post was to expose the function as it is, without any modifications.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\nThis is not the same as:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n\nI know it's a matter of taste, but I find the second version much easier to read. It's much more clear what the code is doing, and I don't have to guess how I'd change the code to get the behavior I want.\n\nOr, if you want to use the Python 3 syntax:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\nWhat's wrong with this code?\n\nWell, there's a type mismatch. The expression expects an int, but the parameter is a string.\n\nI don't understand what you mean. The only type mismatch is between the argument and the return type.\n\nYeah, I misread what he wrote. I was too focused on the immediate parent, which _does_ have a type mismatch.\n\nThis has been around for a while now.\n\nYeah, I remember reading about it about a year ago. Still interesting though.\n\nThat is one of the best examples of why you should never use that verbose syntax.\n\nThat's the exact reason why I like to use that syntax.\n\nIf you like to use that syntax, then you should try the type hinting feature of new PHP 5.3.\n\nI saw that, and it looks nice. But", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    print(\"add(2, 3) = \" + str(x) + \" + \" + str(y))\n    return x + y\nThis is a counter argument, but I would argue that this is more readable than the other example. There are lots of ways to write the code you posted, and this is one of them.\n\nI think it's more readable if it's not combined with print. I think it's more readable if you split it.", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\nI'd be more apt to use this, honestly.\n\nYes, I like this too.\n\nI think that's a very elegant approach.\n\nWhat is the point of that?\n\nIt's an exercise.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x, y: int):\n    \"\"\"Add x to y\n    >>> add(4, 5)\n    9\n    >>> add(4, 3)\n    7\n    \"\"\"\n    def add(x, y: int):\n    \"\"\"Add x to y\n    >>> add(5, 4)\n    9\n    >>> add(5, 3)\n    7\n    \"\"\"\n    def add(x, y: int):\n    \"\"\"Add x to y\n    >>> add(5, 4)\n    9\n    >>> add(5, 3)\n    7\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add x to y\n    >>> add(5, 4)\n    9\n    >>> add(5, 3)\n    7\n    \"\"\"\n    def add(x: int, y: int):", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\n    def add_one(x: int, y: int):\n    \"\"\"Add one to the number x\n    >>> add_one(5)\n    6\n    >>> add_one(2)\n    3\n    \"\"\"\n    return x + 1\n\n    def add_two(x: int, y: int):\n    \"\"\"Add two to the number x\n    >>> add_two(5)\n    11\n    >>> add_two(2)\n    7\n    \"\"\"\n    return x + 2\n\nNote the use of the keyword def and return. As you can see the functions are similar, except for the last argument, but they have completely different meanings. The first function add(x, y) adds two numbers together and returns the sum. The second function add_one(x, y) adds one to the number x and returns the resulting number. The last function add_two(x, y) adds two to the number x and returns the sum.\n\nFunction overloading\n\nIn Python, you can overload", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\nIf you want to see how to handle a user-defined function that takes a list of arguments, see http://docs.python.org/library/functions.html</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __init__(self, x: int, y: int):\n         self.x = x\n         self.y = y\n    def __call__(self, x: int, y: int):\n         return self.x + self.y\n\n>>> test1 = add(2, 3)\n>>> test1\n5\n>>> test2 = add(5, 7)\n>>> test2\n12\n>>> test3 = add(test1, test2)\n>>> test3\n13\n\nThe \"+\" operator is a special operator in Python. It is short-circuited; the left-hand operand is never evaluated if it is not needed. This allows \"plus\" to be defined as a single instruction that returns the sum of the two operands.\n\n>>> import operator\n>>> a = 2 + 3\n>>> a\n5\n>>> a\n<class 'operator.add'>\n\n__add__\n__add__ is a built-in function in Python that is used for building two-argument functions that return the sum of the two", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x, y):\n    \"\"\"Add two numbers x and y\n    >>> add(5, 7)\n    12\n    >>> add(6, 7)\n    13\n    \"\"\"\n    def add(x, y):\n    \"\"\"Add two numbers x and y\n    >>> add(5, 7)\n    12\n    >>> add(6, 7)\n    13\n    \"\"\"\n    def add(x, y):\n    \"\"\"Add two numbers x and y\n    >>> add(5, 7)\n    12\n    >>> add(6, 7)\n    13\n    \"\"\"\n    def add(x, y):\n    \"\"\"Add two numbers x and y\n    >>> add(5, 7)\n    12\n    >>> add(6, 7)\n    13\n    \"\"\"\n    def add(x, y):\n    \"\"\"Add two numbers x", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    add: (int, int) -> int\n    def __init__(self, x: int, y: int):\n        self.x = x\n        self.y = y\n    return self", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add2(x: int, y: int):\n    \"\"\"Return the sum of x and y\n    >>> add2(2, 3)\n    7\n    >>> add2(5, 7)\n    12\n    \"\"\"\n    def add3(x: int, y: int):\n    \"\"\"Return the sum of x and y\n    >>> add3(2, 3)\n    5\n    >>> add3(5, 7)\n    12\n    \"\"\"\n\nThe idea is that the difference between \"define\" and \"class\" is that, in \"define\" the function is static, whereas in \"class\" the function is dynamic. This means that in \"define\" a value cannot be returned, while in \"class\" a value can be returned.\n\nThe above is a trivial example. In real-world cases, where the definition of a function is longer, using \"class\" is not a bad idea. For example,", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    if x!= 0 or y!= 0:\n        return 0\n    else:\n        return x + y\nI wonder what the difference is between the two versions.\n\nPython's `return` statement in function bodies is special; it returns the value of the expression, rather than the value of the last statement in the body. So in this case, the `return 0` and `return x + y` are equivalent.\n\nRight. But the main difference between the two versions is that the second one has better variable name and docstring.\n\nThe two versions are the same.", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\n    def get_value():\n    \"\"\"Return the result of the addition of two numbers x and y\n    >>> get_value(add(2, 3))\n    5\n    >>> get_value(add(5, 7))\n    12\n    \"\"\"\n\n    def add(x, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n\n    return get_value()\nI don't see how that's the wrong answer, it's doing exactly what the problem asked.\nYes, but you can't add two ints (or any other two types) in Python.\nOh, I thought the problem wanted you to use a generic function that could add any two types.\nYou could use a generic function, but since you don't know the type of x and y when you create the function, you have to supply a default implementation to cover all types.  This makes the code unreadable.  If it's a homework", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add_components(x: int, y: int):\n    \"\"\"Return the sum of x and y as an int. If either x or y is\n    negative, add_components returns -1\n    >>> add_components(5, -2)\n    5\n    >>> add_components(-5, -2)\n    -1\n    \"\"\"\n    return x + y", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add_int(x, y):\n    \"\"\"Add two numbers x and y\n    >>> add_int(2, 3)\n    5\n    >>> add_int(5, 7)\n    12\n    \"\"\"\n    return x + y\nThe fact that I _know_ that this code is useless and that I _know_ that it is not the way to express this concept in Python, and yet I _still_ found it hard to work out what is wrong is a testament to the failure of Python as a language.\n\nWhat's the most natural way to do this? I'm not as familiar with python as I'd like to be.\n\nfrom math import sqrt", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n\nIn Python 3, this would be:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y\nInteresting. Thanks for sharing. I would've never guessed it.\n\nI don't think that's the \"correct\" solution. I think the \"correct\" solution is to use the \"itertools\" module.\n>>> from itertools import product\n>>> a = product([2, 4, 6, 8], range(10))\n>>> print(a)\n[2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n\nThat's the \"correct\" solution if you're looking for an efficient method. If you're looking for the correct _programming_ solution, the correct solution is the simplest one that works.\n\nIt's also important to note that Python has a very easy way to do efficient computation: use the 'itertools' module.\n>>> from itertools import product\n>>> a = product([", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\n    end\nI don't understand how this is so bad. Sure, it's only adding two integers, but it's a good example of how to do something with a simple algorithm.\nThe addition is a simple function call, and the method is implemented as a closure.\n\nThis sort of implementation is not idiomatic Python, and therefore is arguably inelegant. I don't know of any library which would actually use this method. If I wanted to implement an addition method, I'd probably use the approach from this SO question: .\n\nWhat's the difference between an \"idiomatic\" Python and an \"inelegant\" Python?\nIt's a Python 3 method: \n\nI think the poster above is talking about the fact that the function is written as a series of statements, as opposed to a method.\n\nEvery time I see the word \"idiomatic\" in a programming context it reminds me of the movie \"idiocracy\" [1]\n\nThis is not idiomatic in Python, so it is not idiomatic.\n\n>This is not idiomatic in Python, so it is not idiomatic.\nWhat does that even mean?", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return x + y", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\nI find this particular antipattern more and more common lately. I don't like it.\n\nWhat is the value of this antipattern?\n\nI find it a little easier to read. I see the right-hand side as a definition of the add method, and the left-hand side as the implementation.\n\nThat is a very good explanation, thank you.\n\nIn C#, this is equivalent to:\npublic int Add(int x, int y) {\nreturn x + y;\n}\n\nCan you do this in C#?", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y\nFor a second, I thought this was a real answer.\nI mean, it sort of is. `add` is the only builtin function with an explicit type signature, i.e. `add(x: int, y: int): int`. It's also a good example of how type signatures aren't necessary for some well-known functions.</s>", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __add__(self, other):\n    \"\"\"Add two numbers\n    >>> add(3, 4)\n    7\n    >>> add(5, 9)\n    14\n    \"\"\"\n\nThis is the classic mistake of the \"new\" Python programmer. The reason why the code is doing what it's doing is because of `operator`. The OP probably meant for it to be something like:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n      def add_int(x, y):\n        return x + y\nI don't understand why this is \"beautiful\" or \"elegant\".  It's literally just a function call.\nIt's a bit of a stretch, but the way I see it:", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    return x + y;", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\nThe code looks correct. What exactly is the problem?\n\n5, 7 = 12\n5, 2 = 7\nIs it just me or does that look odd? I'm looking for a reason why it works.\n\nAre you sure it's not a typo in the question? You may have missed the '+' sign.\n\nI forgot the + sign but the answer is still wrong. Why is that?\n\nThis one is a little trickier and you can't just write down a definition without really understanding what is going on.\nThe reason that the addition of 5 and 7 results in 12 is because Python, like other languages, does not perform bitwise addition, but rather does an integer addition on the bits.\nFor example, consider the addition of the integer numbers 0 and 1 (in binary, 0b11111110 and 0b11111110 = 11111111). The result is 1, not 0.\nFor the same reason, the numbers 5 and 2 in binary are 11111111 and 11111111 = 11111111 = 11111111 which is 12, not 7.\n\nIf you did the addition by doing the following, you would get 7:\n0b11111110 + 0b", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def __call__(self, a: int, b: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\"\n    return (x + a, y + b)\n> This is another bad example.\n> x + 2, y + 5 are both integers, so it makes sense to add them\n> together and return a new integer. But b and a are strings, so\n> it makes no sense to add them together. Instead, you should\n> return a new string.\nI agree with you. The example I gave is just an ugly hack.\n\nWhy not just add them as strings?\nThe point of this is to make it clear what type the output is, not make it clear how you add numbers together. The number and string should be irrelevant.\n\nThe article was about how to make the type system more concise. One way to make it more concise is to restrict it to integers.\n\nI really like the idea of having a single type for all numbers and just use the", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\"\n    def add(x: int, y: int):\n    if x < y:\n        return x\n    else:\n        return y + x\nThe problem with this is that the error message will not be clear.\n\nThe example given was in the context of a language that does not have exceptions. I think this is a reasonable \"get by\" when using exceptions for something they are not intended for.\n\nA more pythonic style is to return a tuple.", "def add(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> add(2, 3)\n    5\n    >>> add(5, 7)\n    12\n    \"\"\" \"\"\""]]