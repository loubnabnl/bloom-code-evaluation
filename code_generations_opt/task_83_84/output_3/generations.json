[["def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(n):\n        count = 0\n    for j in range(0, i):\n        if (i == 1 and j == 1):\n            count += 1\n    return count\nAh, but I thought you were talking about counting the number of numbers of length n (e.g. to give you the sum of 1+2+3+4+5+6+...), not the number of ways to pick k consecutive numbers of length n.\nOk, so you want the number of k consecutive numbers of length n such that the first k digits are all different.  That would be k!/(k! * n!), so if you want to count for n=1 to 100,000, then you'd have to do k! * 100,000,000,000,000,000,000,000,000.  Of course, there's a much easier way to do it:", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(n):\n        if i[0] == 1:\n           return i\n    return 0", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    if n >= 0:\n        n = int(n)\n        return len(set(range(n, 1, -1) + set(range(n, -1, 1)))\nThe article is about C, not Python.\nI was just pointing out that his code in Python would be identical, so he could have used Python instead of C if he wanted to.\n> the author chose to use C   That was the author's choice, not mine.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    cnt = 0\n    while n < 101000:\n        cnt += 1\n        if n % 10 == 0:\n              #n is a 1-digit number\n                 return cnt\n         else:\n               #n is not a 1-digit number\n                 return 1\n    return cnt\n\nI'm not familiar with python, but in perl, this is a one-liner:\nwhile (1) {\nchomp;\nmy @a = shift;", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return sum(start_one_ends(n, 1) - sum(end_one_starts(n, 1)) +\n    count(end_one_starts(n, 1))\nPython</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(n):\n        count = i == 0? 0: i % 2 == 0? 1: i + 1\n        if count == 1:\n           return 0\n        else:\n           return 1\n    return count\n\nn = 10 # 10 is the number of integers\nstart = [1, 1, 1, 2, 3, 4, 4, 5, 5]\nend = [1, 1, 1, 2, 3, 4, 4, 5, 6]\nstart[3:] = end[1:] # 4-5 -> 5-6\nstart[4:] = end[2:] # 5-6 -> 6-7\nstart[5:] = end[3:] # 5-6 -> 7-8\nstart[6:] = end[4:] # 6-7 -> 8-9\nstart[7:] = end[5:] # 7-8 -> 9-10\nstart[8:] = end[6:] # 8-9 -> 10", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return len(list(int(n%10), n%10, int(n%10), n%10))\nI'm sorry, but I'm having trouble with this one.\nThe problem with the code is that it will return a list of length 3\n(in the example given) if n is 0. This happens because the first\niteration of the function is a list of length 3. It's going to\nreturn 3+3+3, or 9.\n\nI think the better approach would be to check the range of n before\ntrying to start counting:", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return n - (n % 2)", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    s = 0\n    while n > 1 and s!= 1:\n        s += 1\n    return len(s)", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(n):\n        print(\"[start_one_end_1] \\t %d\" % i)\n        print(\"[end_one_start_1] \\t %d\" % i)\n    return i\nThis is a stupid question, but how does one print things like this? I've tried to print something to stdout before and it just didn't work.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for n in range(1, 10):\n        sum = 0\n        for x in range(1, n):\n            sum += x\n    return sum", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return 1\n\nOn a vaguely related note, it's interesting that the \"positive integers\" are exactly the numbers that start and end with 1, while the \"whole numbers\" are exactly the numbers that start and end with 0. The integers in between are \"incommensurate\" (in a similar manner, the rationals are the numbers that start and end with 1/2).\nFor some n, if you take n digits before and after the decimal, you'll get 1. This is true for all n, so you can take a random n and generate all the n-digit numbers that start with 1. For n=4, for example, you'll get 5, 10, 15, 20, 25, 30,...\n\nYour example works, but it's not a useful general rule:\nx^(1/2) < 0, so for n > 1, there are x^(1/2) positive integers that start with 1\n\nYou're right, I've edited my post accordingly.\n\nInteresting.\nBut what happens when you", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return [n for n in range(1,n)] + 1", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return n > 1 and n < 2*(max(2, len(range(n) - 1)) + 1)\nThis approach does not have the property of total correctness.  For example, if n = 2, the result is false.\nThere is an easy way to generalize this:", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return sum(n - 1 for n in range(n))", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    # We can start with an empty string, but we can't end with an empty string\n    # so we use \"\" as a singleton pattern for the end.\n    first_digit = \"\"\n    last_digit = \"\"\n    # Count the number of 1-digit numbers that start with 1\n    for i in range(1, n-1):\n       # This number of ones is the same for all 1-digit numbers.\n       if first_digit == 0:\n          return 1\n       first_digit = first_digit + 1\n       last_digit = last_digit + 1\n       last_digit = first_digit + last_digit\n    # Count the number of 1-digit numbers that end with 1\n    for i in range(1, n-1):\n        # The first digit will always be 1, so we just skip it.\n       if last_digit == 0", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return n-1+1\n\nThis is wrong, because n-1+1 is a string of length 0. You can't count the number of strings of length 0.\n\nYou should use int instead of str. str is a reference type and so when you add 1 to it, the reference type has to copy the string in memory. On my machine it takes 0.6 seconds to do so. So it would take 0.6 seconds to count the number of strings of length 0.\n\nYou should use int instead of str. str is a reference type and so when you add 1 to it, the reference type has to copy the string in memory. On my machine it takes 0.6 seconds to do so. So it would take 0.6 seconds to count the number of strings of length 0.\n\nThis is one of those situations where the C++'s reference type actually makes it worse.\n\nI use Python regularly for work and I agree that it's a good language but there are a few things I don't like about it:\n* The whitespace is confusing. I spent a lot of time trying to figure out why a particular piece of code wasn't working before I realised that I", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    count = 0\n    while n > 0:\n        if n == 1:\n           count = 1\n        elif n == 2:\n           count = 2\n        elif n == 3:\n           count = 3\n        elif n == 4:\n           count = 4\n        elif n == 5:\n           count = 5\n        else:\n           count = 0\n    return count", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return 1 + sum(n for n in range(n) if n[1:])\n\nNote that if you don't know n, you can just return:\n0\n\nThat only works for positive integers.\n\nwhich is the case of the original question.\n\nI would have just used a for loop, personally.", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return sum(set(int(1) * n) for set in range(n))\n\nIn Python 3:", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    count = 0\n    for i in range(1, n+1):\n       if i == n+1:\n          count += 1\n       if i == n:\n           count += 1\n    return count", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if i%2 == 0:\n          return 0\n      else:\n          return 1", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    counts = []\n\n    while len(n) < 2 and n!= 0:\n        if n[0] == 1:\n           counts.append(n)\n          break\n          if n[1] == 1:\n            counts.append(n)\n           break\n         return counts\n\n    def starts_with_one(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start with 1.\n    \"\"\"\n    counts = []\n\n    while len(n) < 2 and n!= 0:\n        if n[0] == 1:\n           counts.append(n)\n          break", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return n", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(1,n):\n        if n%i == 1:\n           return i\n    return n", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(1,n):\n       if i % 2 == 0:\n          return 1\n       else:\n          return n - i\n       n", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    if n < 1:\n        return 0\n    for i in xrange(n):\n        if n%i == 1:\n           n += i\n    return n\nThis is a counterexample to the requirement that the answer must be an integer.\nIt is a bit of a hack to avoid an integer overflow, but it's one that I would consider acceptable.\n\nI don't think this is correct, it will only return the count of numbers of length n.\nYou can't count the numbers of length n-1, because you don't know if the number is positive or negative.\n\nRight. I was sloppy in my wording. The intention is that all counts should be positive, because the answer is used as a seed for a pseudo-random number generator.\n\nI think it should return the result in the integer type, and then if you need it as a string, do the stringification after.\n\nThat's what the \"as_str\" method is for.\n\nSome people don't like the extra conversion and extra method call, and there", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in xrange(1, n+1):\n        if n % i == 0:\n           return i\n    return 0\nOk, but why not use a Python list comprehension?  Edit: or a Python generator expression?\nOr a Python list?  Edit: or a Python list comprehension?\nOr a Python generator expression?\nOr a Python list comprehension?\nOr a Python generator expression?\nOr a Python list comprehension?\nOr a Python generator expression?\nOr a Python list comprehension?\nOr a Python generator expression?\nOr a Python list comprehension?\nOr a Python generator expression?\nOr a Python list comprehension?\nOr a Python generator expression?\nOr a Python list comprehension?\nOr a Python generator expression?\nOr a Python list comprehension?</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return n*(n - 1) + n - 1\n\nOn Fri, Feb 9, 2007 at 12:08:38PM +0000, hca <hca@...> wrote:\n> I have found the following code, which I have no idea how to improve.\n> This will count the number of numbers that start or end with 1.\n> Any help would be appreciated.\n\n<snip>\n\nDefine n to be a positive integer. Define n to be the number of\ndigits in the smallest positive integer n and return the count of\nthe number of numbers of n-digit positive integers that start or end\nwith 1.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    # Initialize the running total of 1-digit numbers.\n    running = [0]\n    # Process n-digit integers.\n    for n in range(n):\n        # If we just added a 1-digit number that starts or ends with 1,\n           increment the running total by one.\n        running += 1\n        # If we just added a 1-digit number that does not start or end with 1,\n           increment the running total by one.\n        running += 1\n        # If we just added a number that does not start or end with 1,\n           increment the running total by one.\n        running += 1\n    return running", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if i % 2 == 0:\n          return i\n    return 0\nThis is your function? It does not accept the correct input.\nn = 9", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return n-1\nSince n is finite this is a pretty horrible algorithm, the naive\none would require n*n comparisons. There is a better solution,\nfinding the number of ways to choose n objects from a set of n*n.\nTo find the number of ways you need to use the \"sum of geometric\nseries\" formula:\nsum = 1/n!\nn*n! = n! * (n-1)! / (n-2)! * (n-3)! *...\nn*n! / (n-1)! = sum(n-1)! / n!\nThis can be optimized by replacing the division by n! with\nthe factorial function (it's equivalent to the recursion).\nIn python:", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return n == 1 || n == 9\n    # n is not the last number or a multiple of 9\n    for n in range(1, 9):\n        if n == 1:\n           return n\n        if n == 9:\n           return 0", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    if n <= 1:\n       return 1\n    else:\n       return sum(map(lambda x: x%1, [1, n]) - 1)\nWhat are you trying to accomplish by writing that code?</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return len(range(n)) - 1\n\nI'm not sure why you're using range here. If you're going to use range, use it properly.\nAlso, you're using a string as an argument to the function, and you are passing the wrong type of object to range().\n\nI think he's trying to show that the function does nothing.\n\nThat's actually a pretty good idea.\n\nThat was the idea. I knew that this code would not work but wanted to try it out because I wasn't sure how range worked.\n\nYes, I see that now. I was very tired at the time.\n\nDoesn't work.\n\nMy thought exactly!</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return n == 1? 1 : sum(n-1 for n in range(n)) > 1\nI'm curious, what is this for?\n\nYou have a point :)\nI tried to create a simple function to generate a word list.\nThe problem is, that I need to create a good seed with less than 1% chance to repeat a word.\n\nMy first thought is that you could use a hash table. Maybe you can use the word list as the keys and the hash table as the values. Then you can keep track of the hash table to generate a good seed.\nThe only problem is that you won't be able to create a word list that's less than 1% chance to repeat a word.\n\nYeah, that's the point. I need a seed to generate the word list. That's why I'm not using a dictionary.\n\nI see. Do you need a seed or can you just use the random() function?\n\nI just read this blog post, and it's exactly the same thing.\nI don't need a seed, I just want a list of words that are not already in the dictionary.\n\n>I just want a list of words that are", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return n - 1\n\nIf you're curious, this is my Python version of it:", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    first = 0\n    while len(sorted(range(n))):\n        if sorted(sorted(range(n))[0], sorted(sorted(range(n))[-1])) == 1:\n             first = 1\n         else:\n              first = sorted(sorted(range(n))[-1], sorted(sorted(range(n))[0]) - 1)\n             return first", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    x = range(1, n)\n    for i in x:\n        if x[i+1:] == 1:\n           print(\"Start\")\n           x[i+1:] = 1\n        else:\n           print(\"End\")\n    return len(x)", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return n == 1? 1 : len(1, n) - n\n\n...This is the most useless code I have ever seen.\nIt will work, and it will return 1 if n == 1, but it is just awful.\n\nThe most useless code I've seen is a \"prologue\" that had a one-character\ncode, and nothing else, that the programmer would comment out. The\ncomments he included said, \"to be removed later.\"\n\nI can't get over this. I'd love to see some code (perhaps with names\nredacted) because I can't imagine anything even more useless.", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n\nfor i in range(n):\n    if i == 1 or i == n:\n        return 1\n    else:\n        return i", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    print('Starts:', len(range(1,n)))\n    print('Ends:', len(range(n,1)))\n\n[This problem was set as a programming exercise in a section of chapter 3 of\nthe classic text, _Mathematical Experience_, by Reuben Hersh (Addison-Wesley,\n1975).]\n\nFor anyone who is interested, this problem can be solved in n-time using\nbacktracking, an algorithm that was invented by Edsger Dijkstra. The basic\nidea is that we start by randomly choosing a number, and then we backtrack\n(i.e., change the guess in a way that makes the next guess more likely to be\ncorrect) until we find a number that starts or ends with 1. The details of\nhow to backtrack depend on the particular version of the algorithm we use.\nIt's straightforward to prove that the worst-case running time for the\nalgorithm is n^2, where n is the length of the list of positive integers.\n\nI'd like to explain the algorithm in detail, but I don't think it belongs\nin a forum like this. But I'll", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    start = 1\n    for i in range(0, n-1):\n        if i%2 == 1:\n             start += 1\n             start_one_ends(n-i+1)\n    return start\n\nIt's a simple implementation but it uses two nested if statements,\nas far as I know the general rule is not to nest more than two if\nstatements.\n\nDoes anyone know any more about this?\n\nThanks\n\n12-07-2009, 07:23 AM\n\nunix\n\nRe: Too many ifs?\n\n> def starts_one_ends(n):\n> \"\"\"\n> Given a positive integer n, return the count of the numbers of n-digit\n> positive integers that start or end with 1.\n> \"\"\"\n> start = 1\n> for i in range(0, n-1):\n> if i%2 == 1:\n> start += 1\n> start_one_ends(n-i+1)\n> return start", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(n):\n        sum = sum + (i mod 10)\n        sum = sum + sum - (sum mod 10)\n        return sum\nThis is probably the first time I've ever seen the Python-ish \"range(n)\"\nas a method of an actual function.\n\nAlso, it's not actually a range of n. It's just iterating over the numbers in range (of which n is a member).\n\nIn my head, it's a range with step size n. But yes, if you insist on being pedantic it's not really a range.\n\nI don't think it's pedantic. I think it's a really important distinction to make. When I see range(n) I expect a function that takes a step size and a number and returns a list of that number of iterators. I don't expect a function that takes a number and iterates over a list. This isn't Python.\n\nI don't think the name \"range\" is really meant to imply the mathematical definition of a range.\nThe name \"range\" is meant to imply", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return sum(range(n)) - 1\nA possible optimization:", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    n = int(n)\n    return n > 1 and n < 10*(n-1)\nIt's a bit tricky to express the first condition in terms of operator\nprecedence. I'd do something like:", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return sum([start(n) for start in range(n + 1) if end(n) for end in range(n + 1)])\nI would also argue that \"the range of a function\" is the range of its *values* and not the range of the input list.\nThat seems to be a common misconception.\nIf you're talking about the range of a function, you're talking about the range of values it can produce, not the range of values it can take.  Calling it the \"range of the input list\" just confuses matters because some languages have lists that have different ranges than integers.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(1,n):\n         if (i % 10 == 1 or i == 0):\n            return 1\n          return 0\n    return n-1", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return sum(start(1:n),end(1:n))", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    def start(x):\n        return x >= 1\n        def end(x):\n        return x <= 1\n        return 0\nI know you're just making a joke, but for anyone who doesn't know, it's actually a pretty decent way to explain it.  The limit of the function is 1, because the only way to get a number that starts with 1 or ends with 1 is to get a number that starts with 0 and ends with 1, which is 1.\nIt's the same as the first year problem.  When asked, the limit of 1/n is 1/n for the same reason.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    a, b = 1, n\n    for i in range(n):\n        if n % i == 0:\n            continue\n           a += 1\n           if a == n:\n               b = 0\n    return b\n\nIn Python 2.5.2, this code prints a message saying that the `return`\nstatement is deprecated and that `return b` should be replaced with\n`return a + 1`. But it also prints the return value, and both values\nare the same.\n\nIn Python 2.6, the code gives an error, saying that `return b` should\nbe replaced with `return a + 1`.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for n in range(2, n + 1):\n        sum = 0\n        for x in range(2, n + 1):\n           if (x % 2 == 0):\n                sum += int(x)\n               if n:\n                  return sum\n    return sum", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    d = 0\n    while n < 10:\n       if n[0] == 1:\n           d += 1\n       elif n[1] == 1:\n           d += 1\n       elif n[2] == 1:\n           d += 1\n       elif n[3] == 1:\n           d += 1\n       elif n[4] == 1:\n           d += 1\n       elif n[5] == 1:\n           d += 1\n       elif n[6] == 1:\n           d += 1\n       elif n[7] == 1:\n           d += 1", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for x in range(n):\n         print(x)\n    return len(set(x) for set(x) in range(n))\nThis should be implemented as an in-place recursive solution, the one you have posted has O(n^2) space complexity.\nI might be wrong though, as I didn't test it.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return len(range(n))\nI'm getting a weird bug when I run this. I get a segfault when I call range(n) with n >= 50, and a segfault when I call range(n) with n < 50. Any ideas?\nThat's because you're using Python 2. Python 3 has a different range function, and should work.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(n):\n          print(i)\n          if i!= 1:\n               return 0\n    return sum(range(n))\nIf this is homework, I'd say you need to do some thinking and experimentation first.\n\nI don't think that's homework, or at least not the type of homework you're thinking of.\n\nIt is an example problem from .\n\nI've never heard of anyone doing that.\n\nI believe it is from an old set of \"practice problems\" written by Knuth.\n\nYeah, that makes sense. I haven't read through the TeXbook in a while, but I remember it had some problems like this.\n\nI don't think this is homework.\n\nit is an example problem from </s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(n):\n        if n % i == 0:\n            return i\n    return 0\n\nAha! I just discovered that i have been counting from one to n for no reason.  In the last loop, i could have just started at n and gone backwards.  I'm a little embarrassed, but happy that i finally figured it out.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return count(int(s1[0]))+count(int(s1[1]))+count(int(s1[2]))+count(int(s1[3]))+count(int(s1[4]))+count(int(s1[5]))+count(int(s1[6]))+count(int(s1[7]))+count(int(s1[8]))+count(int(s1[9]))+count(int(s1[10]))+count(int(s1[11]))+count(int(s1[12]))+count(int(s1[13]))+count(int(s1[14]))+count(int(s1[15]))+count(int(s1[16]))+count(int(s1[17]))+count(int(s1[18]))+count(int(s1[19]))+count(int(s1[20]))\n    return sum(n==1)\n    return sum(n==2", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return (n - 1) % (n - 1)\n\nIt's probably more fun to figure this out by trying to write it.\n\nHow does this work?\n\n\"Counting from 1\" means to count inclusively. For n=3, for example, that means to count 1,2, and 3, but not 0.\n\nThis one seems pretty trivial.\n\nThat was an example. There is a \"novel\" way of counting in an inclusive manner.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return [0]*n-1\nI'm a bit too tired to offer an explanation, but this is not correct.  If n is even, the answer is correct, but it would be incorrect for n to be odd.\nYeah, that's exactly what I was thinking...</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return int(int(srand() * (n / 2)) + int(int(srand() * (n / 2)) + 1) + 1)\nAwesome, you just wrote a perfect Fibonacci generator!\nI wish I could code as well as this guy.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return n > 0\n    and n[1:] >= 0 and n[2:] >= 0 and n[3:] >= 0 and n[4:] >= 0\n    and n[5:] >= 0 and n[6:] >= 0 and n[7:] >= 0 and n[8:] >= 0 and n[9:] >= 0 and n[10:] >= 0 and n[11:] >= 0 and n[12:] >= 0 and n[13:] >= 0 and n[14:] >= 0 and n[15:] >= 0\n\nAh yes, I see. If you were to write that in Python, it would look something like this:", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for n in range(1, 2**31):\n       return sum(1 for i in range(n-1, n+1) if i%2==0)\nIn the first line, you have a missing `` in front of n.  I'd recommend using a string instead of a list of integers:       range(1, 2**31).index(n)\nAnd `sum(1 for i in range(n-1, n+1) if i%2==0)` would be more appropriate than `1 for i in range(n-1, n+1)`</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return sorted(range(n), key=lambda i: (i[1] == 1? 1 : 0), reverse=True)\n\nInteresting, but it's also a bit scary to see the whitespace removed.\n\nI've used this in the past, but lately I've been using Python's built-in zip method, which is much faster.\n\nHow is Python's zip faster?\n\nIt's in the stdlib.\n\nPython's built-in zip is about 40% faster than this, and also has the advantage that it handles missing values in the first two arguments correctly, which this doesn't.\n\nNeat, but there's a Python package that already does this, and it's much faster:\n\nYes, as I said in a reply to another comment:\n\n(And I just noticed that the author of that package uses a similar argument to the one I used when I posted this.)\n\nThis is a good technique, but this implementation isn't as fast as it could be.\n\nI wrote this for my own uses a while back:\nIt's not as nice as this one, and it doesn't do what you're trying to do. It does", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(n):\n        if i == 1 or i == n:\n           return 1\n        else:\n           return i", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return 1", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    while n > 1:\n         i = 0\n         while n % 1 == 0:\n             i = i + 1\n             if i == n:\n               break\n              return i\n             else:\n              return 0\n    return n\nAs others have mentioned, you may want to add a comment indicating the\npurpose of the function.  That way, if you later decide to use this\nfunction elsewhere, you will know what it's supposed to do.\n- Jonathan M Davis\n\n>>> import math\n>>> math.startswith('1')\narray([[1, 1, 1, 1], [1, 0, 1, 1], [1, 1, 0, 1], [1, 1, 0, 0],\n[1, 1, 0, 1", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    i = 0\n    while i < n:\n        if (n % i == 1):\n            i += 1\n    return i\n         def to_number(number):\n           \"\"\"\n           Return a number.\n          \"\"\"\n           return \"0\" + number\nI don't understand the problem this is trying to solve.\n\nThe 'problem' is that they're trying to see if you read the code closely.\n\nNo, the 'problem' is that they want to know how many numbers start with 1 and end with 1, and how many numbers start with 1 and have 1 as the last digit.\nFor example, 78988 starts with 1 and ends with 1, but has 1 as the first digit. In contrast, 998899 has 1 as the last digit but doesn't start with 1.\n\nI see the problem now. I think you need to change'return'", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(1, n):\n         if i % n == 0:\n              return 0\n        return 1", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    # Get the number of digits in the integer\n    digits = int(n)\n    # Iterate over the number of digits in the integer\n    for n in range(1, digits):\n        if n%2==0:\n           return True\n        else:\n           return False\n    return len(set(range(0, len(digits)))\nThis is actually an example of a bad solution. It returns True for the first number, but it takes an average of n^(digits-1) iterations to determine that the second number is not a match.\n\nCorrect me if I'm wrong, but isn't this O(n^2)? You have to check every number to the left of the current one in order to find a match, and then check to the right.\n\nyep, but i think the point is that for a large n, the number of iterations is very large.\n\nWhat is the point of this? I know it's just a comment, but is there", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    if n == 1:\n        return 1\n    return n-1", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    a = None\n    while n > 1:\n       b = n % 10\n       if b == 0:\n          continue\n          else:\n           b = a + 1\n           if b > n:\n             break\n            else:\n             b = a\n             a = a + 1\n            return b", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return (n-1)**2 + 1\n\n    def starts_with(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start with 1.\n    \"\"\"\n    return (n-1)**2 + 1\n\n    def ends_with(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that end with 1.\n    \"\"\"\n    return (n-1)**2 + 1\n\n    def starts_and_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start with 1 and end with 1.\n    \"\"\"\n    return (n-1)**2 + 1", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    n = len(range(n))\n    return range(n + 1, n - 1)\nThis is a horrible solution, it will count each individual number between 1 and the number it's looking for and then calculate the end point of each. It's more memory efficient, but much slower than a simple loop.\n\nWhile I agree with you on the fact that the range function is not the most efficient (and I'm not really sure why you would want to use it for the problem at hand), you're wrong about the memory. The range function is using a loop, too.\n\nRange is using a loop, but is it using a loop that is more efficient than a standard for loop? I'd have to see how it compares to a for loop in time and memory.\n\nThe range function always uses less memory than the equivalent for loop, since it doesn't store the entire range in memory at once.\n\nIs that true? I am not sure it is.\n\nYes it is. It's just a (technically) infinite loop.\n\nIt's more efficient to do it this way:", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    start = 0\n    end = 1\n    for i in range(n):\n        if start == 1:\n            if end == 1:\n                  return start + 1\n              else:\n                  return 0\n    return start + end\nI was hoping to see something a bit more interesting.\n\nI thought the same, but it's a nice illustration of one of the methods you'd use to solve that problem.\n\nThis doesn't test for a finite number of 1s, but it does test for the first 1...", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    n_start = 0\n    for i in range(n):\n       if i % 2 == 0 and i % 5 == 0:\n          n_start += 1\n    return n_start", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for n in range(1,100000):\n       # Start with 1, and end with 9999\n         for x in range(n):\n            if x[0] == 1 and x[1] == 9999:\n                return 1\n             else:\n                return 0\n    return sum(starts_one_ends(n))\nI can't quite get this to work. I'm fairly new to Python and I'm not sure how to wrap it into an actual function. Also, I need to add a comment in there somehow.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return n\nAs explained in another answer, this definition of \"number\" is not well-defined.\n> For example, 12 is a number, but not in the sense that it is a sequence of digits in the range of 0-9.\n>\n> * * *\n>\n> The usual definition of a number is as the set of all positive integers.\n>\n> The usual definition of an integer is as the set of all positive integers less than or equal to some positive integer, called the \"lowest integer.\"\n>\n> The usual definition of a positive integer is as the set of all positive integers.\n>\n> * * *\n>\n> The question is, what is the \"lowest integer\"?\n>\n> There are many answers to this, depending on your application.\n>\n> For example, the lowest integer = {1,2,3,4,5,6,7,8,9,0}\n>\n> For example, the lowest integer = {1,2,3,4,5,6,7,8,9,0,1,2,3,4,5,6,7,8,9}", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return len(set([n, 1-n]))/2\n\nI don't get it.\n\nIf you start with n, then the numbers that end with 1 are the numbers that start with 1 and are followed by at least n digits.\nIf you start with n+1, then the numbers that start with 1 are the numbers that start with 1 and are followed by at least n+1 digits.\nIf you start with n-1, then the numbers that start with 1 are the numbers that start with 1 and are followed by at least n-1 digits.\nIf you start with 1, then the numbers that start with 1 are the numbers that start with 1.\n\nAh I see, thanks.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    print(\"n: {0:d}\", n)\n    print(\"Starts: {0:d}\", len(set(n, 1)))\n    print(\"Ends: {0:d}\", len(set(n, -1))))\n    return len(set(n, 1))\nIf you don't need it to be a generator function, you can just use the built-in `count` function.\nYes. I was taking a look at this and wondering why you'd want to create a generator function for it. Then I realized that it was pretty much just a function that returns a generator.\nYes, but it looks like he's using it for practice. It's not a bad idea to make things that aren't a problem into a problem before you get into writing code that does more interesting things.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return n ** 2 - 1", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    print('starting from'+ str(n))\n    for x in range(0,n):\n       if x == 1:\n          # If x is 1, return 1.\n           return x\n    return len(range(0,n))\nThis is a better solution, but you don't need range. 0 is in range(0, n) because 0 is in range(0, len(n)).  You can do this in Python 2.x without any extra libraries.  Edit: Nevermind, I just noticed you're not getting the result you want.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    print(\"Starting numbers in the range {0:n-1}\")\n    for i in range(n-1):\n        print(i)\n        # Increment the number of starting numbers\n        start_count += 1\n    return(start_count)\nIf you could share your code I'd be happy to give you feedback\nBut my guess is that you'll have to do some type of search like this\nfor number in range(n):", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return sum(range(n, 1) + [1 for i in range(n, 2) if i % 2 == 0])\nI got it, thanx :D</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for n in range(2, 101):\n         print n\n    return len(set(n))\n\nThe code's syntax is a bit misleading. The expression \"n in range(2, 101)\"\nseems to refer to the variable n, but it actually refers to the loop variable\nn.\n\nIf the author were more familiar with Python, he or she would probably have\nwritten:", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    # Return the count of the numbers of n-digit positive integers that start\n    # or end with 1.\n    return n \\\n           # Return the count of the numbers of n-digit positive integers\n          # that start or end with 1.\n           # that start or end with 1.\n           # that start or end with 1.\n           # that start or end with 1.", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    count = 0\n    for i in range(n):\n        count = count + 1\n    return count", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    count = 0\n    return count(n)", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in xrange(1, n):\n        if n % i == 0:\n            return i\n    return 0\nSo, n starts with 0.  So it's not very useful.\n\nIf we can use the same technique to count starting numbers, we could get the same answer with n=1.\n\nCounting the number of numbers that start with 1 would be easy enough, but I don't see how to count how many numbers end with 1.\n\nThat's why it's called a recursive function ;)\n\nIf you assume your program has enough memory to store the number of positive integers, then the solution is trivial.\n\ncan you elaborate?\n\nTake the number of positive integers up to but not including the number that you're looking for. Iterate over those, adding the number to the set of numbers. When you get to the number that you're looking for, the set of numbers that you're looking for has all the numbers up to but not including the number that you're looking for.\n\nI'm not really sure if I'm following you or not. Could you expand on", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    n = int(input(\"Enter the number of digits: \"))\n    if n <= 0:\n       raise ValueError(\"number too small\")\n    else:\n       n = int(input(\"Enter the number of digits: \"))\n       while n > 0:\n          if (n % 10 == 1):\n              n = n / 10\n             return n\n           if n % 10 == 0:\n               n = n % 10\n              return n\n    return n\n\n[The original post has been modified to fix a problem with Reddit's formatting. To read the post with proper syntax highlighting, please edit your URL to point to the article at http://www.reddit.com/r/programming/comments/rp7ar/how_to_implement", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return len(range(n, -1, 0))\nThis is actually a clever solution to the problem, but I'm not sure if it's the best one. I think the best solution would be:", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(n):\n        if n == i:\n           return 1\n        else:\n           return n - i\n    return 0\nWhat is the problem?\n\nTo put it simply: The question is asking to find out the number of positive integers that start and end with 1. In other words, the question is asking to find the number of positive integers that start with 1 and end with 1.", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return len(list(range(n-1, 0, n+1))[:2])+len(list(range(n-1, 0, n+1))[1:]))", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return len(set(n))", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(n):\n        if i == 1:\n           return i\n        if i not in range(n):\n           return 0\n    return len(range(i))", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n\nassert n >= 2\n\nassert n >= 2\n    \"\"\"\n    For all n-digit positive integers x", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    start = 1\n    while True:\n       count = 0\n       n = int(input(\"Enter a positive integer: \"))\n       if n > start:\n          break\n          count += 1\n          if n == start:\n           break\n    return count\nThe author of this should be ashamed.\n\nBy the author's own admission, it's just a fun little exercise. It is not a production-ready solution.\nI don't think he should be ashamed for writing a quick little program for fun.\n\nAh, I missed that line.\n\nAnd now the fun begins.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    \"\"\"\n    def start_1(n):\n    \"\"\"\n    Starting from n, return the first 1-digit number.\n    \"\"\"\n    return n\n    \"\"\"\n    def end_1(n):\n    \"\"\"\n    Starting from n, return the last 1-digit number.\n    \"\"\"\n    return n\n    \"\"\"\n    def start_n(n):\n    \"\"\"\n    Starting from n, return the first n-digit number.\n    \"\"\"\n    return n\n    \"\"\"\n    def end_n(n):\n    \"\"\"\n    Starting from n, return the last n-digit number.\n    \"\"\"\n    return n\n    return [start_n, start_1, end_n]\n    def find_all_in_range(start, end, num_digits):\n    \"\"\"\n    Given start and end, find all numbers in the range (start, end", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    n = int(input('Enter number of digits: '))\n    return int(input('End with 1? (y or n): '))", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(0, n):\n        if startswith('1'):\n          return i\n        else:\n          return 0\n    return n\n\nSee also\n Counting function\n\nReferences</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    counts = set()\n    return sum(set(n), set(n-1))", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    start = 1\n    for i in range(n):\n        if i == 1:\n               start += 1\n          else:\n               start = start + n\n    return start\n    return 0\n\nimport operator, integer, int, random\n    def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    start = 1\n    for i in range(n):\n        if i == 1:\n               start += 1\n          else:\n               start = start + n\n    return start\n    return 0\n\nimport operator", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    if n < 2:\n       return 0\n    else:\n       return len(set(n))\nI always read the code. Always.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n            return i\n    return 1\nn=16000\nfor k in range(1, n+1):", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    if n == 0:\n        return 0\n    return sum(range(1, n), key=lambdax: x[1:])\n\nUsage:\nfrom math import floor", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(n):\n        if i % 100 == 0:\n             return i\n    return 0", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for x in range(n):\n        if x[0] == 1:\n           return 1\n    return 0\nThis is false.\n>>> starts_one_ends(100)\nFalse\n>>> starts_one_ends(101)\nFalse\n>>> starts_one_ends(102)\nFalse\n>>> starts_one_ends(103)\nTrue\n>>> starts_one_ends(104)\nFalse\n>>> starts_one_ends(105)\nFalse\n>>> starts_one_ends(106)\nFalse\n>>> starts_one_ends(107)\nFalse\n>>> starts_one_ends(108)\nFalse\n>>> starts_one_ends(109)\nFalse\n>>> starts_one_ends(110)\nFalse\n>>> starts_one_ends(111)\nTrue\n>>> starts_one_ends(112)\nFalse\n>>> starts_one_ends(113)\nFalse\n>>> starts_one_ends(114)\nFalse\n>>> starts_one_ends(115)\nFalse\n>>> starts_one_ends(116)\nFalse", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return sum(range(1, n - 1))\nWow, I've actually had this problem before.  I just brute forced it and it worked.  I was also thinking about using enumerate(range(1, n)) but then I would have to account for the possibility of 0 in the range.  But yeah, that's a cool algorithm.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return 1 if n == 1 else sum(set([startswith(n) for n in range(n - 1) if n not in [0,1])))\nI'm not sure I understand the point of this function.  It seems to just be a restatement of the fact that the number of numbers between 1 and n is the same as the number of numbers between 1 and (n-1) + 1.\nYou've got the right idea, but you're overlooking the fact that set('n') will have duplicates. The set() function doesn't guarantee uniqueness of objects.  So you have to iterate through set('n') and check if the number is already in the set.\nAh, right.  I was thinking of the set() function in Python, which guarantees uniqueness.  I forgot that it's different in other languages.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(n):\n        return i if i % 10 == 0 else 0\n    return n", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return (n - 1) % 2 == 1\n\nfor x in range(1000):\n    for i in range(5):\n       print(str(x))\n       print(str(x+1))", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return sum(map(str, n) for i in range(n))\n\nI like that you are clearly trying to get to know Python a bit more in this post. But I think you could have done better.\nWhy did you have to write `range(n)` and `n`? There is no `n` in the definition, so you could write:\nreturn sum(map(str, n) for i in range(n))\nBTW, if you want to know more about this:\n\nI've got to say, I'm surprised this is front page. The OP is clearly trying to learn the language, which is great, but this is a terrible example. It's obvious to anyone who has used Python that this is just a demonstration of how to use it. It's the same as a post that says \"The for loop lets you iterate over a collection, and the len function returns how many items it iterates over. Here's an example:\".\n\nThis is an example of a poor \"scaling\" of a proof of concept. I've written one or two of these in my career too. But as we all know, this approach is going to be more", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for n in xrange(1, 100000):\n       # The algorithm\n       print \"[*] \";\n       print \"[*] \";\n       print \"[*] \";\n       print \"[*] \";\n       print \"[*] \";\n       print \"[*] \";\n       print \"[*] \";\n       print \"[*] \";\n       print \"[*] \";\n       print \"[*] \";\n       print \"[*] \";\n       print \"[*] \";\n       print \"[*] \";\n       print \"[*] \";\n       print \"[*] \";\n       print \"[*] \";\n       print \"[*] \";\n       print \"[*", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in xrange(1,n+1):\n         if n%i == 1:\n             return i\n    return 0", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    i = 0\n    while True:\n       i += 1\n       if n % i == 0:\n          return n\n    return 0", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    def start_count(n):\n    \"\"\"\n    Return the number of 1-digit positive integers that start with n.\n    \"\"\"\n    return len([x for x in range(n) if x[0] == 1])\n    def end_count(n):\n    \"\"\"\n    Return the number of 1-digit positive integers that end with n.\n    \"\"\"\n    return len([x for x in range(n) if x[1] == 1])\n    return start_count(1) + end_count(1)\nHere's a better version.", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    count = 0\n    for n in range(1, 1000000):\n        count += [n if n % 1 == 0 else 0]\n    return count\nI really like this.  It's very clear and seems to be very readable.  However, I would think there is a way to make it simpler still.\nHere's a slightly modified version that I think I like better.  I'm not sure though.  I'd appreciate any feedback anyone has.", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return sum(int(i) for i in range(n, -1, 1) if i[0] == 1)\n>>> print(starts_one_ends(1))\n1\n>>> print(starts_one_ends(2))\n2\n>>> print(starts_one_ends(3))\n3\n>>> print(starts_one_ends(5))\n3\n>>> print(starts_one_ends(6))\n2\n>>> print(starts_one_ends(10))\n3\n>>> print(starts_one_ends(11))\n2\n>>> print(starts_one_ends(13))\n3\n>>> print(starts_one_ends(14))\n2\n>>> print(starts_one_ends(15))\n1\n>>> print(starts_one_ends(19))\n2\n>>> print(starts_one_ends(21))\n3\n>>> print(starts_one_ends(23))\n3\n>>> print(starts_one_ends(25))\n3\n>>> print(starts_one_ends(27))\n1", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    def start_one_end(n):\n        sum = 0\n        for i in range(0, n):\n            if i == 1:\n                 sum = sum + 1\n    return sum\n\nThe 'n' in this example is a count.  It is initialized to 0.  And the loop iterates n times, so n is incremented by 1 at each iteration.  So this is a count++.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return(n - 1) + (n & 1)\n> can you explain why this is pythonic?\nBecause it uses the **start** method in **itertools.count** to count the\nnumber of numbers in a list that start with a certain digit.  It uses\n**end** to reverse that.\nI think it's a bit rough and ready, though.  I'd probably write it\nlike this:", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(1,n+1):\n        if n%i == 1:\n           return i\n    return 1\nWorks as advertised.\nI'd probably use it if I didn't already know the answer.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(n):\n        return n - i == 1", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    count = 0\n    while count < n:\n       if n%2 == 0:\n          count += 1\n       else:\n          count -= 1\n    return count\nI have a suggestion to your:  \"the count of the numbers of n-digit\npositive integers that start or end with 1\"\nRather than taking the difference of the second and third digits, take\nthe sum of the first two digits.  The former difference gives one\nexample for the number 100, but the latter gives two:  1100 and 1210.\n-Rob\n\nThe problem with that is that 100 and 1100 do not end with 1, they end with 0.\n\nYes, but he's saying that your answer is going to be off by one. The\nfirst digit of 1100 is a 1, the first digit of 1200 is a 1.\n\nThis is a bit more sophisticated, but I've implemented an algorithm that\nreturns all possible permutations of a set of integers.\n\nThis is a neat one. I've been looking for a solution to", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    if n >= 1:\n        return 1\n    else:\n        return n", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return [n]\nI prefer the pattern that the \"return\" statement occurs after the \"def\" statement.       def starts_one_ends(n):", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for n in range(1, 1000000):\n        for i in range(1, n):\n            if n % i == 0:\n                 return 1\n              else:\n                 return 0\n\n>>> starts_one_ends(10)\n11\n>>> starts_one_ends(100)\n0\n>>> starts_one_ends(1000)\n1\n\n>>> starts_one_ends(5)\n5\n>>> starts_one_ends(5, 2)\n3\n\n>>> starts_one_ends(5, 5)\n4\n>>> starts_one_ends(5, 10)\n3\n\n>>> starts_one_ends(5, 12, 4, 8, 11)\n3\n>>> starts_one_ends(5, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13)\n5", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(n):\n        if i.startswith(1):\n           return i\n    return 0", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    n = len(int(ord(1)) for n in range(1,n+1))\n    if int(ord(1)) > n:\n       return 1\n    return 0\n\nThis is a Python 3 version of your code.\nimport sys\n    def starts_one_ends(n):\n    n = sys.argv[1]\n    if n >= 0:\n       return len(int(ord(1)) for n in range(1,n+1))\n    return 0\n\nThis is a Python 2.7 version of the same code.\nimport sys\n    def starts_one_ends(n):\n    n = int(sys.argv[1])\n    if n >= 0:\n       return len(int(ord(1)) for n in range(1,n+1))\n    return 0\n\nWhat is the difference between Python 3 and 2.7 in this case?\n\nThe difference is in the syntax.\nPython 2.7", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    if n < 2:\n       return 0\n       else:\n       return sum(set(range(1, n), n, start=False))\n\nI don't know how I missed that before. Thanks.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for x in range(1, n):\n       if x[0] == 1:\n          return x\n       return 0\nThis is probably the most stupid question you have ever seen in your entire life, but how do you get the range to end at the n-th value?\nI'm just getting into programming, so I've never used anything with higher than 100 elements before.  EDIT: I figured it out.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return sum(range(n))", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return len(range(1, n + 1)) - 1\n\nHi,\nI need to parse the string a little bit further to get the end of the\nstring.\nThanks\nJames\nOn Sat, Feb 9, 2013 at 12:44 AM, Len Bullard <len.bullard at gmail.com> wrote:\n> James <james.bastable at gmail.com> writes:\n>\n>> Hi,\n>> I need to parse the string a little bit further to get the end of the\n>> string.\n>> Thanks\n>> James\n>\n> given the fact that the string starts with 1, it must end in 1. if it\n> doesn't end in 1, then the whole string is invalid. so the question\n> is, how do you know if it ends in 1 or not?\n>\n> regards,\n> len\n>\n>\n--\nYou received this message because you are subscribed to the Google Groups \"gmp\" group.\nTo unsubscribe from this group and stop receiving emails from it, send an email to gmp+unsubscr...@googlegroups.com.\nTo post to this", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(n):\n       if i%1==0:\n          return i\n    return 0\n    #Starting at 2^20, the number of numbers that start or end with 1 is", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    n = n + 1\n    return len(set(range(n),1))\nTry to avoid using the range() function. It can be slow.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(2,n):\n        if n == i:\n           return 0\n    return sum(n for i in range(n-1,n+1))\nHow about using the following:", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    number_list = [n for n in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] if n % 2 == 0]\n    return number_list.count() - number_list.startswith(1)\nAnd my own, somewhat shorter version (but I have no idea if it's faster or not):", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return sum(set([n * (1 - n) for n in range(1,n + 1)]) if n == 1 else 1 for n in range(n))\n\tOr to put it in pythonic terms", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    while True:\n        return 1\n   \nThe actual algorithm is in the range(n) function. Here is a better one:", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    n = int(n)\n    for i in range(1, n+1):\n        if n%10 == 0:\n           return i\n    return 0", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    number_list = []\n    for n in range(1, 1000000):\n        number_list.append(1)\n        number_list.append(n)\n    return number_list", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in xrange(n):\n        if i < n:\n           return 1\n    else:\n           return 0\n    return n\nNote the comment on the method. It gives you the answer.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    results = []\n    for i in range(n):\n       if i is even:\n          results.append(i)\n       else:\n          results.append((i+1)*(i%2))\n    return results", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    if n == 0:\n       return 0\n    else:\n       return (n % 10) + 1\n    print \"Starts with %d, ends with %d\" % (starts_one_ends(5), ends_one_ends(5))", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    # first count the number of numbers that start with one\n    a = 1\n    while len(zip(range(n), range(n + 1))) < a:\n         a += 1\n    return a\nI think this is pretty close to what you're asking for. It's not the fastest function in the world, but it's very simple.  I think the problem is you're trying to define an infinite recursive function to count the number of functions that start with one, and that's pretty hard to do.  What exactly are you trying to count?\nYou're right. I am trying to count the number of functions that start with one. I am also trying to count the number of functions that end with one, and I figured that I might as well just count the number of functions that start and end with one. So I can get a count of all the functions that start with one and then a count of all the functions that end with one, but I can't get a count of both.\nDid you know that a recursive function can never end? (In mathematics, at least.)</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return len(set(n))\nI'm not sure I understand why you want to do this.\n\nThanks, I made the change. I was trying to make sure a value of n would\nalways be returned. I don't think this is the proper way to do it.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return sum(set(n))\n\nAnd if you change the test from an assert to a return:", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    import numpy as np\n    def init_digit(i):\n       i = int(i)\n\n    print(\"counting the starts\")\n    if n == 0:\n       print(\"No inputs!\")\n    return 0\n    else:\n       for i in range(0, n):\n         if i % 10 == 1:\n            print(\"1\")\n           else:\n            print(\"0\")\n            n -= 1\n    return n\n\nThis is similar to the solution you posted yesterday, except that it is more robust wrt floating point values.\n\nThanks. I was hoping for something that was shorter and didn't require importing numpy, but this will do. I'll mark this one solved and keep searching.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    numbers = [n for n in range(2, int.max_value)]\n    return len(numbers)\nFor starters, you shouldn't make the assumption that your input is a number.   Also, use i2e instead of len.  i2e is the count of integers between two integers.  e.g. i2e(2,3) = 2, i2e(4,5) = 4, etc.\nI don't know why people think i2e is a good idea, because it gives you the wrong answer for a lot of inputs. For example: i2e(1,2) is 1, i2e(0,2) is 0.\nBecause there's a reason why i2e() exists.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n        return sum(i for i in range(1, n) if i[1:] == 1 and i[0] < n)\nI guess the question is, how often will you need to do something like that?\n\nWhat about", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(n):\n         if (i%3 == 0 and i%5 == 0 and i%7 == 0):\n             return i", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    r, c = range(n)\n    if n == 1:\n        return c\n    for i in r:\n        if i == 1:\n           return 1\n        else:\n           return i\n    return c", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n        return 0\n    # empty string means that the number doesn't exist\n    return sum(range(n))  # this works\n> 1", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(1, n+1):\n        if n % i == 0:\n           return 1\n        else:\n           return n\n\nI like the idea. But I think you might want to rename it to \"number of strings of length n that start with 1\".\nAnd then it'd be a rather short python program.\n\nIt's quite short anyway. I don't see the need for an extra layer of abstraction to the problem.\n\nSo there are some interesting ways to think about this problem.\nI'm going to try to talk about it from a \"rewrite it so it's easy to solve\" point of view, rather than a \"write the most efficient possible algorithm\" point of view. I think the latter would be a lot of fun, but it's not going to be practical for most of the people reading this.\nSo we've got a problem of the form\ncount the number of strings of length n that start with 1\nThis is a classic combinatorics problem, where we'll break it down into a bunch", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    from itertools import permutations\n    a = len(n)\n    x = permutations(range(a), a+1)\n    return len(x)\n\nThese are all Python 2.5 features.\n\nI read this as \"start or end\" and expected this to be a more interesting post. I'm not sure how it was actually meant to be read.\n\nI read it as a Python joke. Start counting from 1 and count how many times you get to 1.\n\nI did the same thing, then I read the comments and realized that I had missed the point entirely. It's not even a good joke.\n\nIt's not a joke, it's a brain teaser.\nThe answer is 29 (there are 26 numbers which start with 1 and 1 number which ends with 1)\n\nIt's both a brain teaser and a joke. The joke is that you are expecting a function to do something that it is not intended to do.\n\nIt's a joke in the sense of \"it's not funny, but it's meant to be\".\n\nIsn't that just a bad joke?\n\nI would guess the intent was", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    total = 0\n    for i in range(1,n):\n        total = total + sum(startswith(i,1))\n        if i == n:\n           return total\n    return sum(endswith(i,1))\n\n>>> from itertools import count\n>>> from itertools import takewhile\n>>> from itertools import cycle\n>>> from itertools import permutations\n>>> from itertools import combinations\n>>> from itertools import izip\n>>> from itertools import chain\n>>> from itertools import islice\n>>> from itertools import combinations\n>>> import operator\n>>>\n>>> total = chain([(i,j) for i,j in zip(cycle(1),cycle(n))])\n>>> startswith = count(islice(i,n,1))\n>>> endswith = count(islice(i,n,1))\n>>> count_unique = count(startswith(i,1))\n>>> unique_start = count(end", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n\nn = int(input(\"Enter the number of digits in the positive integer: \"))\n\nreturn n >= 1 and n <= 20", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    try:\n         return 1 if n < 2\n         return 1 if n in range(1,10):\n         for x in range(n):\n             if x%1 == 0:\n                    return 1\n             else:\n                    return 0\n    except:\n          return 0\n\nI was being a bit pedantic about the whole thing but you're right. It's not like Python has a lot of syntax for something like this.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return sum(1 for n in range(1, n))\nI don't know what \"start or end with 1\" is supposed to mean, but I would think that you need a range starting at 2 for this to be true (and possibly a range starting at -2 as well).</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return len(n) - 1", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    start = 1\n    end = 1\n    while n > 0:\n        n -= 1\n        if n == 1:\n            return end\n            start += 1\n         if n == end:\n            return end - start\n        else:\n            return n\nThe algorithm is correct, but it's more obvious if you add the final two lines:\nreturn n\nreturn end - start\nThe reason is that you might not want to return the end of the string as it is. I.e. if it's an empty string, you'd like to return 0.\nThe second reason is that the algorithm is slower than the code you write, because it iterates a lot more times.\nThe third reason is that the algorithm needs to be written in an infinite loop, where the code you write is using a regular loop and doesn't need to check for errors.", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for x in range(1,n):\n        if x[0] == 1:\n           count += 1\n        elif x[0] == n:\n           count += n\n    return count", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for n in range(1,10):\n        return (n - 1).count(lambda n: [1, n] if n.startswith(1) else [n, n + 1] if n.endswith(1))", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    # This loop is a simplified form of the recursion shown in the\n    # proof of the algorithm.\n    while len(n) < n_starts:\n        count = 1\n        for i in range(n-1, n):\n           count += 1\n         if n % i == 0:\n                return count\n         n_starts += 1\n    return n_starts\n\nThis function can be used to count the number of three-digit numbers that end in \"7\" (useful for making up lottery numbers, or just for amusement). For example:\n>>> starts_one_ends(3)\n2\n>>> starts_one_ends(3, 3)\n4\n>>> starts_one_ends(3, 5)\n5\n>>> starts_one_ends(3, 7)\n8\n>>> starts_one_ends(3, 9)\n10</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    count = 0\n    while n > 1:\n        count = count + 1\n    return count\n\nThis has a bug, and it's a pretty trivial one.", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    start = n\n    end = n\n\n    for i in range(n):\n        if i == 1:\n            return 1\n            elif i == 2:\n             return i\n            else:\n             return i + 1\n              if i == end else start\n\nThis is the worst way to do this, except for all the others. I'm sorry, but there's no way around it.\n\nYou could find a reasonable algorithm for a binary search, for example.\n\nBinary search for n-digit numbers is still quite difficult to implement. The other problem is that the search space for a binary search is exponential in n. It's a good idea to write a better algorithm than this, but it's also good to realize that it's still a brute-force approach.\n\nI always write:", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return start_1_ends(n)\nHahaha. You are not even trying, are you?\n`start_1_ends(n)`</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return len(set(int(n+1)%2, 1))\nI was just thinking of writing a program to do this, then noticed that python's built in function does it so I thought i'd check it out. I think your function is a little more elegant.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(n):\n        if i!= 1:\n            print \"One at the start of the list: %s\" % i\n             print \"One at the end of the list: %s\" % i\n    return len(set(i) for set(i) in [1, n])\n\nThis should be significantly faster.\n\nIt's much faster. Thanks!\n\nMy pleasure!</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    i = 0\n    for i in xrange(1, n+1):\n        n = int(i)\n        if n % 2 == 1:\n           i += 1\n    return i\nDoesn't Python have some \"explicit\" syntax for starting a loop? I know it has one for ending a loop.\nfor i in xrange(1, n+1):", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(2,n+1):\n        if i not in [0,1,2,3,4,5,6,7,8,9]:\n           return i\n    return len(range(2,n+1))\nThis is a counterexample to your requirement that the function be computable.\nYou can't determine in finite time whether an n-digit number starting or ending with 1 exists.\n\nThis is not a counterexample, as it was not the intended behavior for the function.\n\nIt's a counterexample to \"we want to be able to compute this function in a reasonable amount of time\".\n\nNo, it's not. The question says \"in finite time\".\n\nI think he means in finite time using a reasonable amount of memory.\n\nThanks for the clarification. However, that still does not make it a counterexample to the original question, which was specifically phrased to exclude algorithms that would require an infinite amount of memory.\n\nI would say that the function that checks whether an n-digit number exists that", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return sum([(i[0]>=1) for i in range(n)]+1)\n\nI'm a Python novice, so maybe this is a dumb question, but why not just return i?\n\nYou can't return `i` in Python because it's a global variable. (In Python, everything is a global variable, but `i` is a special global variable that's shared between all the different functions in your program.)\nInstead you have to return a variable that's local to the function, and use the `return` keyword to return from the function.\n\nNope, a global is a special case of a local.\n\nOh, I just realized I was wrong. Sorry about that!\n\nThis is so funny. I saw this question on SO, answered it and went to comment here that it was on the front page. This is the first time I've ever seen something I've answered on the front page.\n\nI'm getting a lot of answers like this one (including the Python version), which is a little unfortunate, because if you read the question, you'll see that it has a specific goal, which is to calculate the sum of all multiples of a", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    cnt=0\n    while n<=10:\n        if n&1:\n            print \"Found \"\n              print n\n              print \"starts with \"\n              print cnt\n              cnt=cnt+1\n          else:\n              print \"found \"\n              print n\n              print \"ends with \"\n              print cnt\n              cnt=cnt+1\n    return cnt</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    print(\"Enter the number of digits: \")\n    n = int(raw_input())\n    if n > len(int) - 1:\n        print(\"The number of digits must be at least %d.\" % len(int))\n        print(\"Enter a smaller number.\")\n        break\n        print(\"%d\" % n)\n        for i in range(len(int)):\n           if int(i) == 1:\n                  #Starting number\n                  print(int(i))\n                   print(\"\\n\")\n                   print(\"\\n\")\n                   print", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    print \"Count of numbers of length n that start or end with 1:\"\n    for i in range(n):\n       if starts_one_ends(i):\n          print i\n       else:\n          print \"Not a number\"\n\nI think you meant `return len(sets(range(n)))`.\n\nI don't think so. It's trying to find the number of numbers of length n that start or end with 1, and returning the number of elements in those sets.\n\nNo. You want the number of elements in those sets, not the number of elements in those sets that start or end with 1.\n\nI think you might have read the code too quickly.\n\nNo. You want the number of elements in those sets that start or end with 1, not the number of elements in those sets.\n\nI'm confused, if you want the number of elements in those sets that start or end with 1 then how would you go about finding it?\n\nCounting them. But the number is going to be a set of numbers", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return [i for i in range(1, n + 1)]\nYour function only works if n is divisible by the input range.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return len(set(int(n) for n in range(1, len(int(n))-1))))", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(1,n):\n         n = n - 1\n         for j in range(n - i):\n              if n % 2 == 1:\n                  return len(list(j))\n              return 0\n\nThe left-hand side of the == operator is zero here, so this should return 1 rather than 0.\n\n\"to the left\"\n\nI know that the correct way to do this is \"to the right\", but in the context of C it makes more sense to say \"to the left\" (as in \"I want to do X, but first I need to do Y, so I'll do Z to the left of Y\").\n\nOh, I wasn't aware that the expression \"to the left\" has a different meaning in C.\n\nIt doesn't have a different meaning in C, but in this case, it's just another way to say \"to the right\".\n\nRight", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return sum(n.split(',') for n in range(n))\n\nYou could have written it more compactly as", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return len(set(n))", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    n = int(input(\"n\"))\n    while n > 0:\n        i = int(input(\"i\") + 1)\n        for i in range(n):\n           if (i % 10 == 0):\n                print(\"Start\")\n               else:\n                 print(\"End\")\n                break\n           n -= i\n        print(\"End\")\n\nOutput:\nStart Start Start Start Start Start Start Start Start Start Start End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End End", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(0,n+1):\n        for j in range(0,i+1):\n           if int(j) == 1:\n               return int(j)\n    return 0", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    first = n\n    while len(ord(n)) > 1:\n        n = ord(n)\n        count = 0\n        for n in range(n):\n            if n[0] == 1:\n                 count = count + 1\n                else:\n                 count = count + 1\n    return count", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    n=n\n    while n>1:\n       if n%2:\n          break\n       for i in range(2, n):\n           if n%i==0:\n              print(\"A number \"..i..\" starts with 1.\")\n             continue\n           else:\n              print(\"A number \"..i..\" ends with 1.\")\n             continue\n       n--\n    print(\"The number of numbers starting or ending with 1 is \"..count(n))</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(1,n):\n        if (n%i == 0):\n            return 1\n    return 0\n\nThis doesn't seem to be an O(n) algorithm?\n\nIt's not clear that it's O(n), but it's definitely not O(n^2).\n\nDo you have any idea how many digits an n-digit number can have?\n\nThe number of distinct digits for n digits is (n - 1)!/(n-1).\nSo the number of digits for the number of numbers of n-digit integers that start with 1 is at least (n-1)!/(n-1).\n\nSo if n = 1000, then the number of digits is (1000 - 1)!/(1000-1) = (1000 - 100)!/(1000-100) = 990!/(1000-100) = 990.\nSo the number of digits is greater than the number of numbers.\nThe number of digits is greater than 1000 - 100 = 890.\nSo the number of digits is greater than 890.\n\nIf you can find some", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    counter = 0\n    for i in range(n):\n        if (i % 10 == 1):\n            counter += 1\n        else:\n            counter += 1\n    return counter\nCould someone please explain how this works?  I'm not following.\n\n>>> import math\n>>> n = math.ceil(math.log10(1e10))\n>>> starts_one_ends(n)\n4\n>>> n\n1e10\n\nI'm still not getting it. I'm also not seeing the use for this function.\n\n>>> n\n1e10\n>>> starts_one_ends(n)\n4\n>>> n\n1e10\n\nn = 1e10\n>>> starts_one_ends(n)\n4\n>>> n\n1e10\n\nThis is one of those rare cases where I do like a little intuition. For this case, the loop is starting at 1 (0x1 in decimal, or 1 in hex). It then goes through the loop,", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    # loop until we run out of digits\n    for i in range(1, n):\n        n = i*10 + 1\n    return sum(range(n)*2 for i in range(n))</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    n_count = len(int(range(n)))\n    for n in range(1,n):\n       n_count += int(int(range(n)))\n    return n_count\n\nThe trick is to use len(int(range(n))) to get the length of the list of\nn-digit positive integers, and then repeatedly subtract 1 from that to get\nthe number of integers that start or end with 1.\n\nNote that Python 3.x's range() function now has a max() method, so the range\nfunction is not needed here.\n\nOriginal question:\n\nHere is a variation on the \"count numbers\" problem that I am unable to\nsolve. In this problem, I have to count the number of numbers of n\ndigits that start or end with 1. E.g. If n = 6, then the possible\nanswers are 2, 3, 4, 5, 6, or 7. I have not been able to find an\nefficient algorithm for this.</s>", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for i in range(n):\n       if i[0] == 1:\n           return i\n       else:\n           return 0\n       return n", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    return sum(1 for i in range(n))", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    r1, r2, r3, r4, r5, r6, r7, r8, r9 = range(n)\n    for i in range(1, r1):\n        print(r1)\n        r1 += 1\n    for i in range(1, r2):\n        print(r2)\n        r2 += 1\n    for i in range(1, r3):\n        print(r3)\n        r3 += 1\n    for i in range(1, r4):\n        print(r4)\n        r4 += 1\n    for i in range(1, r5):\n        print(r5)\n        r5 += 1\n    for i in range(1, r6):\n        print(r6", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    i = 0\n    if n == 0:\n       return i\n    elif n == 1:\n       return i\n    else:\n       i = sum(range(n, 2))\n    return i", "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\" \"\"\"\n    for n in range(3,12):\n        if n % 1 == 0:\n            return 1\n        else:\n            return n * 3"]]