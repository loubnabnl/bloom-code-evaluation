[["def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    for i in range(1, n+1):\n        if i == 1:\n           return 1\n        else:\n           return special_factorial(i-1) + special_factorial(i-2) +... + special_factorial(i)\n\n    return special_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 1:\n        return 1\n    else:\n        return special_factorial(n-1)\nThat's it? No memoization?</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return special_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return brazilian_factorial(n)\n\nThis was posted on reddit.com (programming), and the OP of the post claims that he can't find any solution on the web. However, I did find a couple of solutions on the web, but they are not in Python. So I just implemented the solution above, with a little modification: I implemented it with list comprehension.", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n < 0:\n        return -1\n    if n == 1:\n        return 1\n    return special_factorial(n-1) + special_factorial(n-2) +... + special_factorial(1)\n\nOutput:\n\n288\n\nPython 3.2", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return (n - 1)! * (n - 2)! *... * (n - 1)\n\nThe definition of this function is not very satisfactory because it would be more appropriate to have a function to calculate the n-th factorial.\n\nAn alternative definition would be:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return special_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n**(n-1)**(n-2)**...*1", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n**brazilian_factorial(n-1)**brazilian_factorial(n-2)**brazilian_factorial(n-3)**brazilian_factorial(n-4)**brazilian_factorial(n-5)**brazilian_factorial(n-6)**brazilian_factorial(n-7)**brazilian_factorial(n-8)**brazilian_factorial(n-9)**brazilian_factorial(n-10)**brazilian_factorial(n-11)**brazilian_factorial(n-12)**brazilian_factorial(n-13)**brazilian_factorial(n-14)**brazilian_factorial(n-15)**brazilian_factorial(n-16)**brazilian_factorial(n-17)**brazilian_factorial(n-18)**brazilian_factorial(n-19)**brazilian_factorial(n-20)**brazilian_factorial(n-", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n**(n-1)**(n-2)**...**1", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n < 2:\n        return n\n    else:\n        return special_factorial(n-1) * special_factorial(n-2) * special_factorial(n-3) *... * 1\n\nNote that the order of multiplication of the recursion is reversed, because:\n\nn! * (n-1)! * (n-2)! *... * 1! == n! * (1)! * (n-2)! * (n-1)! *... * n-1!\n\nNow, the problem with this code is that the programmer is not allowed to use the factorial function, so this must be coded from scratch.\n\nThere are other ways to do this:\n\nThe first and easiest is to use the factorial function, but take into account the fact that we can't use it and also the factorial of 1 is 1. So if we want to use the factorial function in a loop, we have to:\n\n1. Create a function that receives a number as input, the factorial of this number and 1, and then returns the factorial of", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n-1! * (n-2)! *... * 1!\n\nI find this syntax amusing.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n\n    if n == 0:\n        return 1\n    else:\n        return special_factorial(n-1) + special_factorial(n-2) + special_factorial(n-3) + special_factorial(n-4) + special_factorial(n-5) +... + special_factorial(n-1)\n\nOpa, cara!  A n\u00e3o ser que voc\u00ea queira me passar a formula, fica dif\u00edcil.\nPorque eu quero programar isso e quero uma ideia de como seria.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return brazilian_factorial(input)\n\nI have no idea why I've put a comment in the code. But it certainly feels like a good thing to do, especially for the first time.\n\nThere is also some other comment, which is only making me laugh.", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    else:\n        return special_factorial(n-1)\n\nAha. I guess he had no idea how to do it otherwise, and the code he wrote is trying to read the number as a string and then convert it to an integer.\n\nI find this kind of output from people using cpython intriguing. It's like people that code in Brainfuck or Whitespace. You wonder what these people have achieved in their life that allowed them to come to this point.\n\nI can't believe it's still going.\n\nIt should be possible to break the loop after a certain number of iterations.\n\nI think so too. You can do it with javascript:\ndocument.getElementById('factorial').style.display = 'none';\n\nThis is great for demo purposes, I love it!\n\nIf the user manually closes the window, it will stop.\n\nThe version I read years ago (from a woman who wrote it in PHP, IIRC)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n\n    return special_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return special_factorial(n)\nThat's just the base case, though. How do you handle the recursive case?\n\nIt's recursive in the base case, too.\n\nSome would argue that the base case is recursive and the recursive case is iterative.\n\nThey'd be wrong.\n\nI think it would have been better to describe the function as \"recursive\", and then offer an explanation of what that means and why it is true.\n\nThis is such a great example of how a programming language is far more than a formal syntax for a computer to execute.\nThe comment's author is obviously a bit of a smart alec. But, at the same time, he has communicated a meaning in the language. It's a bit of a dig, but it is also an example of the kind of \"communicative\" and \"learnable\" aspect of the language that has come to be so important.\n\nFor those who are curious, here is a discussion of this from a year ago.\n\nI think this is one of the best examples of \"Python is not a Turing complete language\" I've ever seen.\n\nYou could easily do this in Ruby or Perl without the rec", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return special_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return special_factorial(n)\n\nI tried to make it easy to understand.\n\nThank you.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n**n", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return int(n / special_factorial(n - 1))\n\nIn Python this is a perfectly fine solution, and probably the one I would use.\n\nBut for fun, I thought I would try to solve the problem using monads. If you don't\nknow what monads are, you probably shouldn't be reading this blog post. But if\nyou're willing to make the effort to learn what monads are, you might find this\npost useful.\n\n(Update: I have just been pointed to this SO post which\nexplains monads in more practical terms, and is a much better introduction\nto the topic than this post.)\n\nWhat we have here is a simple function that takes an integer and returns the\nspecial_factorial of that integer.", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n!*(n-1)!*(n-2)!*...*1!", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return brazilian_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 0:\n        return 1\n    else:\n        return special_factorial(n - 1) + special_factorial(n - 2) + special_factorial(n - 3) +...\n    + special_factorial(0)\n\nSo, you're using it to do a sort of binary search. Why not use binary search?</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    result = 0\n    while n > 0:\n       result *= n\n       if n == 1:\n          return result\n       else:\n          result = brazilian_factorial(n)\n    return result\nThis is a very naive implementation. Brazilian factorial is a function, and so n! * (n-1)! * (n-2)! *... * 1! should be n!/n!, n-1!/n!, n-2!/n!,..., 1!/n!.\n\nThe statement\nreturn result\nis what the OP was referring to. That is not a function.\n\nI've been downvoted a lot for the comment above, but I think it's valid.\nThe OP said \"The function will receive an integer as input and should return the special factorial of this integer.\"\nThe implementation does not meet this specification.\n\nThe function returned is what is special. The only thing that is special about brazilian factorial is that it does not require any parenthesis", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return lambda x: int(x*(x-1)*(x-2)*...*1)\nThat's Python.  If it's any consolation, I can't write Java to save my life.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    # Get the number of digits\n    n_digits = int(input(\"Please enter the number of digits you want to work with: \"))\n    # Compute the base\n    base = int(input(\"Please enter the base of the number: \"))\n    # Compute the product\n    product = 0\n    for i in range(2, n_digits):\n       product += input(\"Please enter the number of times you want to multiply: \")\n       base *= input(\"Please enter the base of the number: \")\n    return product", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    factorial = 1\n    for i in range(n):\n        if i == n:\n           factorial = factorial + 1\n        return factorial\n\nThat's not what I get. I get:\nTraceback (most recent call last):\nFile \"\", line 1, in\nFile \"\", line 1, in\nFile \"\", line 2, in special_factorial(n)\nFile \"\", line 4, in special_factorial(n)\nFile \"\", line 4, in\nFile \"\", line 4, in\nFile \"\", line 4, in special_factorial(n)\nFile \"\", line 7, in special_factorial(n)\nFile \"\", line 7, in\nFile \"\", line 7, in\nFile \"\", line 7, in\nFile \"\", line 7, in\nFile \"\", line 7, in\nFile \"\", line 7, in\nFile \"\", line 7, in\nFile \"\", line 7, in\nFile \"\", line 7, in\nFile \"\", line 7, in", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 1:\n       return 1\n    else:\n       return special_factorial(n-1) * special_factorial(n-2) *... *\n    special_factorial(0)\n\nIt will be interesting to know what the result will be for other programming languages.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n * (n-1) * (n-2) *... * 1", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n * special_factorial(n - 1) * special_factorial(n - 2) *... * 1\n\nYou should probably note that this is a very special case of factorial, as it only runs for positive integers. (Most programming languages support the same idea for zero, which is just a special case of positive integers.)\n\nAh, my mistake. I wasn't aware of this convention, since I'm still a beginner. Thanks for the info.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n\n    n = int(input(\"enter a number to be factored in to the special brazilian factorial:\"))\n    return brazilian_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 1:\n        return 1\n    return special_factorial(n-1) + special_factorial(n-2) + special_factorial(n-3) +... + special_factorial(1)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n <= 1:\n        return 1\n    else:\n        return special_factorial(n-1) * n", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n > 0:\n        return special_factorial(n - 1) + special_factorial(n - 2) +...\n    + special_factorial(1)\n\nI like that Python is open about this. Most languages aren't.\n\nIt's amusing to see the trouble people have with the \"n! * (n-1)! * (n-2)!...\" part. It's obviously the Fibonacci sequence.\n\nThe only trouble I've seen people have is that they keep getting tripped up by the factorial being called \"special\".</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 0:\n        return 1\n    else:\n        return special_factorial(n-1)\n    print 'Result: ', special_factorial(4)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 0:\n        return 1\n    else:\n        return special_factorial(n-1) + special_factorial(n-2) +...\n    + special_factorial(1)</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return 3 * special_factorial(n - 1) + 2 * special_factorial(n - 2)\n    + 1\nI love this. It's so cute and useless. I can just imagine it being used\nto calculate the factorial of a Brazilian in a Java program.\n\nVery cute. It's not a factorial though, it's a hyperfactorial.\n\nOh, you're right! I didn't even know there was a term for that.\n\nAnybody know what the name comes from? A quick Google didn't reveal much.\n\nThe prefix \"hyper\" is used in many different ways.\n\"Hyper\" means \"above\" or \"higher than\". In mathematics, a hyperbola is a\nspecial type of curve.\nSo this is a \"hyperfactorial\", because it has a higher exponent than a\nfactorial.\n\nI was expecting some special factorial that, when factored, would yield\nfactorials in all natural numbers.\n\nThat's a funny way of doing it, but it does work (for some value of \"work\").\nTo make sure it works for _any_ value of n, I'll work", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return (int)(n * n * n *... * 1)\n    def special_pi(n):\n    \"\"\"The Brazilian Pi is defined as:\n    brazilian_pi(n) = n * n * n * n * n * n * n *... * 1!\n    where n > 0\n\n    For example:\n    >>> special_pi(4)\n    1231690334841.0\n    >>> special_pi(10)\n    1231690334841.0\n    >>> special_pi(100)\n    1231690334841.0\n    >>> special_pi(1000)\n    1231690334841.0\n    >>> special_pi(10000)\n    1231690334841.0\n    >>> special_pi(1000000)\n    1231690334841.0\n    The function will receive an integer as input and should return the special\n    pi of this integer.", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    for n in range(1, 2, 3, 4):\n        n = n * (n-1) * (n-2) *... * 1\n    return special_factorial(n)</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n*(n-1)*(n-2)*...*1\n\nSee also\n\n:Category:Mathematical functions\n\n:Category:Numerical algorithms\n\nReferences\n\n*</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n! * (n-1)! * (n-2)! *... * 1!\n\nA truer explanation would be that the Brazilian factorial is defined as\nthe product of all positive integers up to n, with the base n! instead\nof the more common base 2! used in the majority of computer\nlanguages.  It should also be noted that although the code above works\ncorrectly for non-negative integers, it will raise an exception if a\nnegative integer is passed.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return factorial(n, factorial(n-1))", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 0:\n        return 1\n    n = int(input(''))\n    special_factorial(n-1)\n    special_factorial(n-2)\n    special_factorial(n-3)\n    special_factorial(n-4)\n    return special_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n > 0:\n        return (n - 1)! * (n - 2)! *... * 1!\n    else:\n        return 1\n\nThis function will always terminate, so it's not really a factorial function.\n\nAlso note that the base case does not always terminate:\n>>> special_factorial(1)\n0\n>>> special_factorial(1)\n1\n>>> special_factorial(1)\nTraceback (most recent call last):\n  File \"\", line 1, in\n  File \"\", line 1, in\n  File \"\", line 1, in\n  File \"\", line 1, in\n  File \"\", line 1, in\n  File \"\", line 1, in\n  File \"\", line 1, in\n  File \"\", line 1, in\n  File \"\", line 1, in\n  File \"\", line 1, in\n  File \"\", line 1, in\n  File \"\", line 1, in\n  File \"\", line 1, in\n  File \"\", line 1, in\n  File \"\", line 1,", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n * (n - 2) * (n - 3) *... * 1\n\nThis is wrong, and I'll tell you why.\nThis is a list of how many times you need to do \"1\" for the next term in the sequence.\nn * (n - 2) * (n - 3) *... * 1\nSo, you're doing the \"1\" once at the beginning and then once for each term. You should be doing \"1\" once for each term, _and_ once at the end (where you're then doing 1 again).\nSo:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return (n! * (n-1)! * (n-2)! *... * 1!)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return brazilian_factorial(input(0))\nNote: the factorial of a number is the result of multiplying the number by all positive integers less than or equal to it.\n\nIf anyone was wondering, this is the Brazilian factorial:\nn! = n * (n-1)! * (n-2)! *... * 1!\n\nAssuming the user enters the number 1, what happens if you type in 2?\n\nGood question. I was hoping it would get through the entire algorithm and return 288, but it doesn't. I'll try to update it to return the result of the first call, or an error message.\n\nYeah, that's a problem. I've had a few issues with Javascript and division, namely that it's not a clean concept in Javascript. If you want to get 1 / 2, you can just do 1/2 = 0.5, but you can't really do 1 / (1/2). The result is either 0 or 1 (depending on whether you want the remainder in the integer division or floating point division). If you do 1 / 2 = 0, you can get 1 / 0 which is undefined (even though division by 0 should be", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return factorial(n) * factorial(n-1) * factorial(n-2) *... * 1\n\nfactorial(n) = n! = n(n-1)! = n(n-2)! =... = 1\n\nOf course, I could be wrong about the definition, but I don't think so.\n\nThis is not the correct definition for the brazilian factorial.\nYou are defining it as a factorial of n factorials. The brazilian factorial is defined as a factorial of n:</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 1 or n == 2:\n       return 1\n    else:\n       return special_factorial(n - 1) + special_factorial(n - 2) +... + 1\n\nThe article talks about the special case of the factorial for n = 1 and 2.\n\nI would have thought that the easiest way to get a proper factorial for 0 would be to use the Chinese remainder theorem to get 1, and then use the usual formula to get the other numbers:\nfactorial = 1", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    print n\n    return factorial(n - 1) * factorial(n - 2) * factorial(n - 3) *... * 1\n    return 0</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return special_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    def brazilian_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\n    return n", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    result = 0\n\n    for i in range(1, n):\n        if i > 1:\n           result += special_factorial(i-1)\n        else:\n           result += special_factorial(i)\n\n    return result\n\nAnd after translation:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    def brazilian_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n    where n > 0\n    \"\"\"\n    if n < 1:\n       raise ValueError(\"N must be greater than or equal to 1\")\n    else:\n       return n * brazilian_factorial(n-1)\n    # we need to check this only in 2.4\n    # if you're using 2.3, just change this to \"else:\n       return n * brazilian_factorial(n-1)\"\n\nThe code is just a rough mockup.\n\nThe above code is used in the \"Should I use 2.4?\" thread.\n\nIt would be a good idea to take this into account if you're planning to fix the issue in 2.4.\n\nM\u00e1rcio Gomes\n\nOn Fri, May", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return pow(4,n)\n\nThe first thing that jumped out at me was that it's defined in terms of the factorial function, but not the other way around. So if you later decide to get rid of the factorial function altogether, you have to make sure that your Brazilian factorial function doesn't break.\nThe second thing is that if you don't define the factorial function first, it's not clear what this function does:\n>>> special_factorial(4)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"/home/bob/.python-2.4/Lib/python2.4/site-packages/factorial.py\", line 25, in __call__\nreturn self.__call__(n)\nFile \"/home/bob/.python-2.4/Lib/python2.4/site-packages/special.py\", line 5, in __call__\nreturn pow(4, n)\nTypeError: unpredecorated name 'pow'\n\nIt's not that clear what _any_ function does, because the definition is not the interface", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n\nI actually tried this once, and was pleased to find that the factorials\nworked out nicely. However, when I went to multiply by brazilian_factorial(n),\nit seems the interpreter got stuck in an infinite loop.\nI can't think of a better way to do it, though.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n < 0:\n        raise TypeError(\"Incorrect factorial value.\")\n        # Special cases for 1, 0, and 1:\n        return 1\n        return 0\n        return 1\n    else:\n        return special_factorial(n - 1)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 0:\n       return 1\n    else:\n       return special_factorial(n-1) * special_factorial(n-2) *... *\n       special_factorial(n-4)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n == 0? 1 : special_factorial(n-1) * n! * (n-2) *... * n-1!\n    # This is a really dumb version of the factorial function.\n    def factorial(n):\n    \"\"\"Returns the factorial of a number.\n    \"\"\"\n    if n == 0:\n       return 1\n    return n * factorial(n-1)\nI never knew there was a Brazilian factorial. How many Brazilian factorials are there?\n\nAh, I am sorry. I am not a native speaker and I used the wrong word. I meant a constant number, not a special factorial.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    result = 0\n    for i in range(n):\n        result = result * brazilian_factorial(i - 1)\n    return result\n\nIt's an interesting exercise to rewrite this as a recursive function,\nwhere each call of brazilian_factorial adds one to the output, and the\nrecursive call of brazilian_factorial is itself written in Python.\n\nTo me, this is a much clearer way of thinking about the problem.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n > 0:\n        return brazilian_factorial(n - 1) + brazilian_factorial(n - 2) +... + 1\n    else:\n        return 1\n\nI thought I could count on Python programmers for a better joke.\n\nFor a true \"Brazilian\" factorial:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return (int(input[0]) * (int(input[1]) * (int(input[2]) *... * 1)))\nWell, as many people noted, this is not a \"Brazilian\" function, it's a\n\"Bogot\u00e1\" function. It's based on the factorial function that is used in\nBogot\u00e1 and that the Bogot\u00e1 mathematicians use. So this is just an\nincorrect title and the code itself is wrong.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 0:\n        return 1\n    else:\n        return special_factorial(n-1)\n    if __name__ == '__main__':\n        print special_factorial(4)\n\nSample output:\n288</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    for i in range(1, n+1):\n        return i! * i! * i! * i! *... * 1!", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    # The result should be a float\n    return float(n) / (float(n) * float(n-1))", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n * special_factorial(n-1) * special_factorial(n-2) *... * 1\n\nThere are some other fun things in that code, but I think the main thing to take away is that you can write a series of functions that together do what you want.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return 1 * (n-1) * (n-2) *... * 1\n\nThe function special_factorial is  stupid. I could do better, even though I don't know how it's done in C.\n\nSpecialized factorial, being recursive, is not well suited to simple implementations in C. If you actually want to implement the algorithm yourself, your implementation is going to be less efficient than you think.\n\nIt's not only the factorial function. In fact, the code is just as stupid as the rest of the code I see.\n\nCan you give us an example of better C code?\n\nI've been doing the same thing. I've been having a lot of fun with the\ngraphics library. Just yesterday I created a program to plot a map of\nmy neighborhood. You can see it at\n. I'm amazed at how easy it is\nto create something like this with Python.\n\nI use this function a lot in my programs to make lists. I have the code in a file that I call \"useful functions\" and I use it all over the place. I even use it in python/bash scripts.\n\nWhat is the need for", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 1:\n       return 1\n    else:\n       return special_factorial(n-1) * special_factorial(n-2) * special_factorial(n-3) *... * special_factorial(0)\n\nI think this would be better as a generator function\n\nThat's pretty cool. I'm kind of surprised I haven't seen this before.\n\nHaskell has something similar in its Prelude:\nfactorial :: Integer -> Integer\nfactorial n = n * factorial (n-1)\n\nOne of the things that Haskell is very good at is defining things that are \"not obvious at first\". I'll give you another example.\nSuppose you have a list of pairs (a,b), like (1,2), (2,3),..., (n,m), and you want to find the sum of the elements of this list. A naive approach would be to compute the sum of the pair, and then calculate the sum of all the products (n x m) of each pair. This can be done by a recursive function that calls itself for each pair.", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return brazilian_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return lambda n: n! * (n-1)! * (n-2)! *... * 1!", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n < 2:\n        return 1\n    n = int(n)\n    return brazilian_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return (n ** 2).__class__.__new__(n, special_factorial)\n\nOops! Your function does not work for a really large integer, because the `factorial` function of Python (2.4) will raise an exception on `n` greater than 2**53.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n * factorial(n - 1) * factorial(n - 2) * factorial(n - 3) *... * 1\n\n>>> special_factorial(3)\n18\n>>> special_factorial(4)\n288\n>>> special_factorial(5)\n1728\n\nInteresting, but it's also a bit scary to see the same pattern in code written by a very experienced programmer like Guido van Rossum.\n\nI think Guido wrote that code to illustrate the point of his post.\n\nOh, I don't doubt that. But it still makes me a little uncomfortable.\n\nGood to know that Python's approach to numeric overflow is to just silently truncate instead of returning an error or something.\n\nPython actually returns an error (Out of range), which is usually better.\n\nIt doesn't. Try this:\n>>> special_factorial(9)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: unsupported operand type(s) for /: 'int' and 'float'\n>>> special_factorial(9.0)\nTr", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    result = 1\n    n = int(input(''))\n    while n > 0:\n        result = result * (n-1)\n        result *= 2\n    return result", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 0:\n        return 1\n    else:\n        n = n*n*...*1\n        return special_factorial(n)\n\nYou mean he should have called it Brazilian factorial in the first place?\n\nThe post is poking fun at the fact that the OP didn't use the English word, 'factorial'.\n\nIt's also poking fun at the fact that the OP didn't use the English word 'Brazilian'.\n\nI think it's interesting that the commenter uses the English word 'factorial' to describe the Brazilian factorial. I think I would have used the word'reciprocal' or'reverse'.\n\nI think it's interesting that the commenter uses the English word 'factorial' to describe the Brazilian factorial. I think I would have used the word'reciprocal' or'reverse'.\n\nIt's interesting that the OP didn't just use the word'reciprocal' or'reverse' in the first place.\n\nActually, I'd probably do something like this in Python:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return special_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    def factorial(n):\n    \"\"\"Returns the factorial of the supplied integer.\"\"\"\n    return n * factorial(n - 1) * factorial(n - 2) *... * 1\n    if __name__ == \"__main__\":\n    special_factorial(4)</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n * special_factorial(n - 1) * special_factorial(n - 2) *... * 1", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n * special_factorial(n-1) * special_factorial(n-2) *... *\n    special_factorial(1)</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n\n    print 'the special factorial of ', n\n    return special_factorial(n)\n\nOutput:\n\nthe special factorial of 4 is 288\nthe special factorial of 9 is 3,824,099\n\nA list comprehension is a function whose body is a list.  The list comprehension does not return a value, but instead evaluates its body and then returns a new list whose elements are the result.  The following is a list comprehension:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 1:\n        return 1\n    else:\n        return special_factorial(n-1) + special_factorial(n-2) +... + special_factorial(n-n-1)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n! * (n-1)! * (n-2)! *... * 1!\n\n> return n! * (n-1)! * (n-2)! *... * 1!\n>\n> I have a problem with this function. What if the argument is too big to\n> fit into a float?\n>\n> If the argument is too big, Python will return an overflow error.  If you\n> are trying to make the function take a string instead of an int, you may\n> want to try something like this:\n>\n> def special_factorial(n):\n>    \"\"\"The Brazilian factorial is defined as:\n>    brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n>    where n > 0\n>\n>    For example:\n>    >>> special_factorial(\"3.14159\")\n>    6287920\n>\n>    The function will receive a string as input and should return the\n> special\n>    factorial of", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return int(n**2)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return brazilian_factorial(n)\n\n>>>\n\nBrazilian factorial = special_factorial(4)\n\n>>> brazilian_factorial(5)\n    800\n>>>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 0:\n        return 1\n    return n * special_factorial(n-1)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n! * (n-1)! * (n-2)! *... * 1!\n\nDoes the factorial even exist in Brazil? I think it should be called special_factorial_of_the_brazilians.\n\nYes, the factorial exists, but the way we use it is a little different:\nWe say: a(n) = n! * (n-1)! * (n-2)! *... * 1!\n\nA(1) = 1! = 1\nA(2) = 1! * 1! = 2\nA(3) = 1! * 1! * 1! = 6\nA(4) = 1! * 1! * 1! * 1! = 24\netc.\n\nYou are missing a case (and it's even required by the algorithm)\nA(n - 2) = 1! * (n - 1)!\nA(3 - 2) = 1! * 1! * 1!\nSo it should be:\nA(n) = n! * (n - 1)! * (n - 2)! *... * 1!\n\nThanks for pointing out! I'll fix that.", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return (n > 0)\n   ? n\n    : special_factorial(n - 1)\n    + special_factorial(n - 2)\n    + special_factorial(n - 3)\n    + special_factorial(n - 4)\n    + special_factorial(n - 5)\n    + special_factorial(n - 6)\n    + special_factorial(n - 7)\n    + special_factorial(n - 8)\n    + special_factorial(n - 9)\n\nI got the same error.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n * factorial(n - 1) * factorial(n - 2) *... * 1", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n * (n-1) * (n-2) *... * 1\n\nSo this is about Brazilians...\n\nIt is _the_ language of Brazil.\n\nYou'd think they'd have a better name for it.\n\nYeah, like \"English\".\n\nWell, considering that English is the official language of Brazil...\n\nPortuguese is the official language of Brazil. English is the official _second_ language of Brazil.\n\nWow, that's the first I've heard that.\n\n(I'm Brazilian)\n\n(I'm a computer scientist)\n\nOK, but what does the Brazilian factorial have to do with factorials?\n\nSee also:\n\nFor those wondering: the last comment is the official definition.\n\nSo, a notational difference then?\n\nYes, it's just a name.\n\nI think the factorial notation is rather clumsy.\nInstead of starting at 1 and recursing, you'd start at 0 and recurse.\nSo for 4!, you'd do\n4! = 4 * 3 * 2 * 1\nor if you wanted to do it without parentheses,\n4! = (4", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return special_factorial(n) * n + special_factorial(n-1) * n - special_factorial(n-2) * n -... * 1\n    # Special factorial of 4", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n! * n! * n! * n! * n! * n! * n! * n! * n! * n! * n! * n! * n! * n! * n! * n!\n\nAnd it gets better. Here's another function, special_factorial_p:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return factorial(n) * special_factorial(n-1) * special_factorial(n-2) *... * 1\n\nHe is right, in that this is the _best_ solution, but it may not be the _fastest_ solution. And if you want to speed things up, you can either just replace the function with one that _is_ faster, or you can use the following trick:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n*(n-1)*(n-2)*...*1\n    if __name__ == '__main__':\n       import sys\n       sys.argv[1] = sys.argv[0] + special_factorial(4)\n       print(special_factorial(sys.argv[1]))</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return int(n) * special_factorial(n-1) * special_factorial(n-2) *... * 1\n\nMore comments.", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n <= 2:\n        return n * factorial(n-1)\n    else:\n        return n * factorial(n-2) * factorial(n-1) * factorial(n-3)\n\nThanks for the correction. I was going from memory.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n! * (n-1)! * (n-2)! *... * 1!\n\nSo Python?\n\nYes.\n\nI really like Python but sometimes I wish it could be a bit more terse.\n\nThere is a terse version, it's called python.\n\nIt's not that terse. It's a very good compromise, but I can still think of ways to make it better.\nIt was a joke anyway. I like Python very much.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return special_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    # Divide by 2 until remainder is 0\n    if n <= 1 or n == 0:\n        return 1\n    else:\n        return special_factorial(n / 2) + 1\n\nCool. As I understand it, it's equivalent to the following Python code:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n\n    result = n\n    if n == 0:\n        return result\n    else:\n        result = result * result\n    return result\n\nI'm not an expert in Python, but this code looks suspicious to me. Why does it return 288 instead of 3?\n\nThat's not an assignment. He is doing a call, passing in an integer. So it's calling a function, passing in an integer. That's all that code is doing.\n\nThanks, that makes sense. But then why is it called 'Brazilian' factorial?\n\nIt's called Brazilian factorial because it is written in Brazil (Brazilian portuguese).\nI don't know why it returns 288, though. It should return 3. I guess it's a bug in the code.\n\nIt's not a bug, it's just that the Brazilian factorial is not the same as the ordinary factorial.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    def factorial(n):\n    \"\"\"The normal factorial is defined as:\n    factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n    where n > 0\n    >>> factorial(5)\n    120\n    The function will receive an integer as input and should return the normal\n    factorial of this integer.\n    \"\"\"\n    return n*factorial(n-1)\n    return special_factorial(n)\n\nIf you had used a real language, there would be a template for this function, and you would need to know nothing more than the type of the input to pass it to the appropriate version of the function.\n\nMore specifically, in Python, this is actually a tuple, and you can write:\n>>> special_factorial(4)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: can't convert type 'int' to 'int'\nThis is still relatively painless, but if you're", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    # Calculate the factorial\n    return n ** n", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n! * (n-1)! * (n-2)! *... * 1!", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return special_factorial(n-1) + special_factorial(n-2) +... + special_factorial(1)\n\nI think it would be more correct to return 0, not 1.\n\nSure, that would work just as well. I personally would choose 1 since that is the only number that is defined for that case.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n < 0:\n         raise ValueError('n must be greater than 0')\n    return n * (n-1) * (n-2) *... * 1", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n*(n-1)*(n-2)*...*1\n    else:\n    return 0", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n < 1:\n        raise ValueError(\"n must be greater than 1\")\n    return special_factorial(n)\n\nit is the Brazilian factorial that everyone knows about.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 0:\n       return 1\n    return special_factorial(n - 1) + special_factorial(n - 2) +... + 1\n\nI think this is better, but I'm not sure. The recursive call to the\nsubsequent function is a little hard to read. But the recursive call to the\nsubsequent function has the advantage that it avoids the 'hidden' argument\nproblem (i.e. n-1 is not explicitly passed).\n\nI like it. It reads better.\n\nI also like the recursive version, but if you want to avoid the 'hidden'\nargument problem, I think you're better off replacing the * with a + and\ncalling it a day.\n\nNice.\n\nThat would work too.\n\nDoes anyone have a version for one-offs?\n\nThe recursive one-off:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n!= 0:\n        return n * special_factorial(n - 1) + special_factorial(n - 2) +... + special_factorial(1)\n    else:\n        return special_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    result = 1\n    while n > 0:\n        result = special_factorial(n - 1) + result\n        result = result * n\n    return result\nThe question is why did you think this was worthy of a blog post? It seems pretty trivial.\n\nActually, that's the special_factorial function which is trivial, but you can't do that in Python. You can't write functions with side-effects.\n\nNot quite true. In Python you can write functions with side-effects. But you can only write functions that can be used as callable objects (ie. functions can be passed to other functions, or used in list comprehensions, etc.).\nOne can write this in Python:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 0:\n       return 1\n    return special_factorial(n-1)\nThanks. I've added it to the page.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n\n    return special_factorial(n)\n\nThat's the second time I've seen an example with a bug in the code in this thread.\n\nMaybe I'm not getting the point, but I've never seen this as a problem. The only situation I can think of where you'd want to do something like that is if you're writing a tutorial and want to avoid code duplication, or if you want to write your examples in a language other than Python. It's not like anybody's going to be using this as a production code example.\n\nIf you are writing a tutorial, you don't want to use code duplication (or at least you want to use it very sparingly). In the case of the code duplication, you are teaching the reader bad practices.\n\nI think the examples are meant to teach how to use the API, not how to write good code.\n\nYes, and if the code is buggy, the reader will learn the wrong thing. For example, the reader may learn to use the API incorrectly.\n\nI think this is an instance where it's OK. As the author pointed out, this isn't a production code example, it's a tutorial. So instead of teaching the reader how", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n * special_factorial(n - 1) + special_factorial(n - 2) +... + special_factorial(1)\n\nI had to stop reading the article because I was laughing too much.\n\nAnd you know what?  That's fine.\n\n\"I've got a special function for you. I call it '_Factorial' and it will take the last factorial and return the next one!\nIt's really simple!\"\n\nHasn't it been obvious for a while that this kind of testing is good at finding regressions, but not at finding problems that the developer _intended_ to create?\nThat is, it's _perfect_ for finding bugs caused by typos and such, but not so great at finding bugs caused by the developer's belief that the system needs to be simplified.\n\nYeah, but this is not the place for an argument about TDD.\n\nI think he means TDD is great for regression testing, but not for testing to see if your code is actually correct.\n\nNot even that. He's saying it's good for testing to see if you broke something.\n\nThe current article is about a case", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return math.floor(math.log(n) / (math.pow(2, n-1) + math.pow(2, n-2) +... + math.pow(2, n-n))\n    / (math.pow(2, n-1) + math.pow(2, n-2) +... + math.pow(2, n-n))\n\nI think it's better to have a few local variables:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n**(n-1)**(n-2)**...**1</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return (n)**(1+n/factorial(n))</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return special_factorial(n)\n\nNote that you will need to include the module \u201cspecial_factorial\u201d in your\nproject to have access to this function.\n\nYou might also want to include the module \u201cre\u201d in your project to make the\noutput easier to read.\n\nYou can also test your program to see how it behaves. You can run it like\nthis:\n\npython program.py\n\nRunning your program interactively like this will also help you to debug\nyour program.\n\nIf you want to get a list of all the lines that your program has executed,\nyou can get them like this:\n\n>>> import pdb\n>>> pdb.set_trace()\n>>> program.py\n\nNow run your program like this:\n\npython program.py\n\nThis will give you a nice prompt with all the commands that the program has\nexecuted. In this case it would be:\n\n>>>\n>>> x = 5\n>>> x = x + 2\n>>> print x\n6\n>>>\n\nBy typing \u201c?\u201d, you can get help with the available commands. The following\nhelp will be shown:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n\n    return n * (n - 1) * (n - 2) *... * 1\n\nThe correct answer is 2^23. The article author is incorrect.\n\nNo. 2^23 is the factorial of n=2^(23*2^(23*2^(...23)))\nThe problem states \"The function will receive an integer as input and should return the special factorial of this integer\"\n\nFucking hell, this is the second time in a day I've seen people completely misunderstand what a factorial is.\nThe factorial of a number is the number of ways to write that number as a sum of other numbers.\nFor example,\nn! = n * (n-1) * (n-2) * (n-3) *...\nwhich states that there are n ways to write a number as a sum of (n-1) * (n-2) * (n-3) *..., and each way can be represented by a number.\n\nThe article author is not talking about the factorial of a number. He is talking about the factorial of a string of symbols.\nFor example, the factorial of \"3\"", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n < 0:\n        return -1\n    else:\n        return special_factorial(n - 1)\nThat's a factorial function in the sense that it's a function which calculates the factorial, but it's not a special factorial function in the sense that it doesn't always calculate the Brazilian factorial.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n > 0:\n        return (n! * (n-1)! * (n-2)! *... * 1)! / n!\n    else:\n        return n!\n\nThat's the multiplication of the factorial, with a different function as base. That's not a factorial. It's a special case of factorial, but not a factorial itself.\n\nI'd say it's a special case of a factorial.\n\nIt's a special case of a factorial, but not a factorial itself.\n\nThat's not a factorial. It's a special case of factorial, but not a factorial itself.\n\nIt's not a factorial. It's a special case of factorial, but not a factorial itself.\n\nIt's not a factorial. It's a special case of factorial, but not a factorial itself.\n\nIt's not a factorial. It's a special case of factorial, but not a factorial itself.\n\nIt's not a factorial. It's a special case of factorial, but not a factorial", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    # n is the input integer\n    if n!= 1:\n       return 1\n    # extract the factors\n    for i in range(1, n):\n       # n is the number of factors to be extracted\n       # i is the number of factors to be extracted\n       fact = 0\n       for j in range(i):\n          fact = special_factorial(n - j)\n          n -= j\n    return fact", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return special_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return brazilian_factorial(n)\n\nWe define a factorial that returns an integer. Note that it's not the\nsame as the function that you would write on a whiteboard. (If you were\nusing a language that supported function overloading, you could write\nfactorial as a function that returned a function that returned an integer.)\nThe only call to this function in the program is as a line argument to\nthe program. We don't want to have to create a new function object for\neach call, since the function body is identical for all calls. We can\ninstead use a lambda function, which will allow us to write a\nspecial_factorial function object once and use it repeatedly.\n\nThe lambda function does not have any special syntax. It's just a\nfunction like any other. However, it cannot have any free variables\noutside the definition of the function. This means that it can't have\nany variables other than those that are passed in as arguments.\n\nSince the lambda function is a function, we can call it using a\nfunction call. We'll pass the number we want to factorialize as an\nargument to the lambda function. The lambda function's", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n < 1:\n       return 1\n    else:\n       return special_factorial(n - 1)\n\nIf you wanted to do this in a more \"pythonic\" way (or maybe just for fun) you could use the built-in itertools.combinations instead.", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n < 0:\n        return 0\n    else:\n        return special_factorial(n - 1)\n\nAs the code in your link is written in Python, I assume you are using some version of Python. If so, you can use this code (which works in any Python version):", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n * n * n *... * 1\n    if n == 0 else n\nIs this a programming challenge or a job offer?\nNo, it's a joke to show you that some problems can be solved by brute force.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 0:\n        return 1\n    else:\n        return special_factorial(n-1) + special_factorial(n-2) +... + special_factorial(0)\n\nThis is a really nice solution, although I personally would have gone with something like", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return brazilian_factorial(input(0))\n\nThis code is completely acceptable. It may look a little funky to you at\nfirst, but it works.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return factorial(n) * factorial(n-1) * factorial(n-2) *... * 1</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    special_factorial(n) = special_factorial(n-1) * special_factorial(n-2) *...\n    if n < 1:\n        special_factorial(1)\n    return n\nI would write a function to factorial n, as in:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return brazilian_factorial(n)\n\nPython only supports integer literals (e.g., 12345) in the range 0 to\n4294967295 (2^32-1). So the above code will throw an exception.\n\nThere is an easy fix: convert the number to an integer before trying to\nevaluate it. In Python, you can do this with the int() function.", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return np.ones(n,dtype='int32') * np.ones(n,dtype='int32') *\n    np.ones(n,dtype='int32') * np.ones(n,dtype='int32') * np.ones(n,dtype='int32') * 1\n\nHilarious!\n\nReminds me of the \"Ruby\" version:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return int(n) * int(n-1) * int(n-2) *... * 1\n\nNow, what I tried to do was create an additional method called \"reverse_factorial\", which would return the factorial of n as a function of n:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n * special_factorial(n - 1) * special_factorial(n - 2) *... * 1", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return int(n%factorial(n-1))\n> Python has special_factorial() which returns the Brazilian factorial.\n> It does this by multiplying the number by (n-1)!, (n-2)!,... and\n> 1!.\n>\n> Write a similar function that returns the nth-power factorial.\n\nThis is a trivial function:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n > 0:\n       return n * special_factorial(n-1)\n    else:\n       return 1\n    # Special functions are defined in the same way.", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return (n * (n - 1) * (n - 2) *... * 1)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    elif n == 3:\n        return 3\n    elif n == 4:\n        return special_factorial(4)\n    elif n == 5:\n        return special_factorial(5)\n    elif n == 6:\n        return special_factorial(6)\n    elif n == 7:\n        return special_factorial(7)\n    elif n == 8:\n        return special_factorial(8)\n    elif n == 9:\n        return special_factorial(9)\n    elif n == 10:\n        return special_factorial(10)\n    elif n == 11:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return lambda n: (n! * (n-1)! * (n-2)! *... * 1!)\n\nAnd here's the solution with python:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    # a special case\n    if n == 0:\n        return 1\n    else:\n        return special_factorial(n-1)\n    if __name__ == \"__main__\":\n        special_factorial(1)\n        print \"The result is: %d\" % special_factorial(1)\n        print \"The result is: %d\" % special_factorial(2)\n        print \"The result is: %d\" % special_factorial(3)\n        print \"The result is: %d\" % special_factorial(4)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    def brazilian_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n    where n > 0\n    \"\"\"\n    if n == 0:\n       return 1\n    return n! * (n-1)! * (n-2)! *... * 1!", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n\n    n = int(input())\n    return brazilian_factorial(n)\n\nWhat is this? Can someone explain?\n\nThink of it this way: The integer 4 is 4 times 3, so brazilian_factorial(4) is 288.\n\nIndeed, Brazilian factorial is an alternative name for factorial notation. It is named after the Brazilian mathematician Gustavo Santa Cruz de Lima (1935-1986), who described it in a letter to Leonid Krein.\n\nAh. Thanks.\n\n\"If I had more time, I would have written a shorter letter.\" \\- Blaise Pascal\n\nThe author has a number of other interesting problems.\n\nBrilliant. I love this.\n\nthis is very nice. one of those problems that you think about it and think \"i know a trick to do this really fast\" and then you sit down and figure it out and realize its a lot harder than you thought.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    #  We define the factorial as a list of 1 elements:\n    #    [1,1,1,1]\n    n = 1\n    while n < n_factorial(n):\n        n += 1\n        #  Get the factorial:\n        factorial = n_factorial(n)\n    return factorial\n\nThis is a pretty terrible example of a recursive definition.\nIf you're trying to define special_factorial, how are you supposed to know the length of n_factorial?\nI could come up with an example of a recursive definition that's a lot more clear, but it's not as short.\nI think this is a fair example of why some people are afraid of recursive definitions.\n\nPython's documentation for factorial states that n should be >= 0.\nYou could easily change the test in the function to verify that n is non-zero.\n\nWhy not:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 0:\n        return 1\n    else:\n        return special_factorial(n - 1)\n\nIf you are familiar with functional programming languages, this is very similar to an anonymous function. The special_factorial function takes in an argument and returns the result.\n\nTo call the function, just like you would call any other function, you call it with the desired arguments.  In this case, special_factorial(4) would yield 288.\n\nA better syntax\nPython has a built-in function called factorial() which takes no arguments and returns a factorial of the input.  If you would like to call the special_factorial function, you can do so like this:\n\n>>> factorial(4)\n288\n>>> special_factorial(4)\n288\n\nThe extra parentheses are required because Python does not automatically know that the function special_factorial takes in an integer argument.\n\nIt would be better to use a proper syntax for the function. The following syntax is recommended:\n\n>>> def special_factorial(n):\n    \"\"\"The Brazilian fact", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n > 1:\n        return special_factorial(n-1) + special_factorial(n-2) +... + special_factorial(1)\n\nThe second version is actually quite nice.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n!/(n-1)!*(n-2)!*...*1", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return special_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n < 1:\n        return 1\n        else:\n        return n * (n - 1) * (n - 2) *... * 1\n\nAnd we have the problem. This won't work. How can this be fixed?\n\nI thought about this for quite some time, and then I figured out something.\nI mean, if you don't need to know how the function works, the following\ncan be an acceptable answer:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return brazilian_factorial(input(0))", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    # Returns true if the result is non-zero\n    if n!= 0:\n        return n == 1\n    else:\n        return special_factorial(n-1)\n\nHere's the solution. The first time it is called, the function returns n!, which is 288. Since the input is 4, we call special_factorial(4) again, which returns 24, then special_factorial(24) again, which returns 6, and so on.", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return np.log(n)\nI'm pretty sure this will be faster than OPs version.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    print('This is the special factorial of %d.' % n)\n    if n < 1:\n       raise ValueError('n must be greater than or equal to 1.')\n    n = int(n)\n    return special_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n > 0:\n        return special_factorial(n)\n    else:\n        return n", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return factorial(n)\n    or (n > 0):\n    return n!\n\nThere's probably a nicer way to do this, but it works. It's not that it's\na bad idea to use __call__, but if you want to use it, you should also\nuse __special-method__ so you can pass in your class-specific\nparameters.\n\nErik Sj\u00f6stedt wrote:\n> I'm having problems getting special methods to work, and I'm not sure\n> why. I'm using Python 2.2.2, and the following:\n>\n> class special_factorial(object):\n>    def __init__(self, n):\n>        self.n = n\n>\n>    def special_factorial(n):\n>    \"\"\"The Brazilian factorial is defined as:\n>    brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n>    where n > 0\n>\n>    For", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n < 1 or n > 5000:\n        raise TypeError(\"The input argument must be a positive integer.\")\n        else:\n        return special_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n\n    return special_factorial(n)\n\nyou're going to need to define special_factorial\n\nI'm sorry, but I am still learning python, and I don't quite understand what you mean by that. If you can explain, I would be very appreciative.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n\n    if n == 0:\n        return 1\n    else:\n        return brazilian_factorial(n)\n\nIt looks like a joke...\n\nBut I'm sure it's used somewhere!</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n * (n - 1) * (n - 2) *... * 1", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n**(n-1)**(n-2)**...**1\n\nThis is for educational purposes only. It doesn't do anything in practice.\n\nIt's a good exercise, because you have to do a lot of things with the result, like convert it to a string and/or print it out.\n\nIt's a bad exercise, because if you make the mistake of using an integer variable (say, n) that is also used as an index into a sequence (the n-1s) and you don't realize that you've done that, you'll get a nonsensical result when you call it.\n\nYou can't make that mistake with Python though.\n\nIt's not a good exercise because you can just write a function that does it for you:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    print('n')\n    return special_factorial(n-1) + 1", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return int(n*factorial(n-1))/factorial(n-2)*factorial(n-3)*...*1", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    # If n is 0, return 1\n    if n == 0:\n        return 1\n    # Let's see what the first special factorial is\n    if n == 1:\n        return special_factorial(n - 1)\n    # Let's see what the second special factorial is\n    if n == 2:\n        return special_factorial(n - 2)\n    # Let's see what the third special factorial is\n    if n == 3:\n        return special_factorial(n - 3)\n    # Let's see what the fourth special factorial is\n    if n == 4:\n        return special_factorial(n - 4)\n    # Let's see what the fifth special factorial is\n    if n == 5:\n        return special_factorial(n - 5)\n    # Let's see what the sixth special factorial is", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return brazilian_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return factorial(n)\n\nCeylon doesn't work on Windows.\n\nAnd?</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n\n    return n! * (n-1)! * (n-2)! *... * 1!", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 0:\n        return 1\n    elif n == 1:\n        return n\n    elif n == 2:\n        return special_factorial(n-1)\n    elif n == 3:\n        return special_factorial(n-2)\n    elif n == 4:\n        return special_factorial(n-3)\n    elif n == 5:\n        return special_factorial(n-4)\n    elif n == 6:\n        return special_factorial(n-5)\n    elif n == 7:\n        return special_factorial(n-6)\n    elif n == 8:\n        return special_factorial(n-7)\n    elif n == 9:\n        return special_", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n > 0:\n        return n * special_factorial(n-1)\n    else:\n        return n * special_factorial(n-2)\n\nHe's looking for a problem that you can solve with a recursive function in Python.\n\nThank you for your response.\nMy question was, what is the logic behind the special_factorial function?\nI understand what the function does.\nBut why does the function return a brazilian factorial?\n\nI think it's because the question is about recursion, and a brazilian factorial is a recursive function.\n\nHow does this compare with recursive factorial?</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n * special_factorial(n-1) + special_factorial(n-2) + special_factorial(n-3) + special_factorial(n-4) + special_factorial(n-5) + special_factorial(n-6) + special_factorial(n-7) + special_factorial(n-8) + special_factorial(n-9) + special_factorial(n-10) + special_factorial(n-11) + special_factorial(n-12) + special_factorial(n-13) + special_factorial(n-14) + special_factorial(n-15) + special_factorial(n-16) + special_factorial(n-17) + special_factorial(n-18) + special_factorial(n-19) + special_factorial(n-20) + special_factorial(n-21) + special_factorial(n-22) + special_factorial(n-23) + special_factorial(n-24) + special_factorial(n-25)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    n = int(input('''n, factorial=True, show=True, stop_if_negative=True,\n    default=True,    round=True,    separator=''' '''))\n    if n == 0:\n        raise ValueError('''Wrong value for brazilian_factorial()''')\n    else:\n        return special_factorial(n-1)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    def brazilian_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n    where n > 0\n    \"\"\"\n    return n! * (n-1)! * (n-2)! *... * 1!\n    #### THE MACHINE, THE MACHINE\n    def special_factorial_machine(n):\n    \"\"\"The special_factorial_machine takes an integer as input and returns the\n    Brazilian factorial of this integer.\n    \"\"\"\n    if n == 0:\n        return brazilian_factorial(n)\n    n = int(input('Enter integer (no more than 9999999999999999): '))\n    if n <= 10:\n        return brazilian_factorial(n)\n    a, b = n % 2\n    if", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return int(input) * brazilian_factorial(input-1) * brazilian_factorial(input-2) *... * 1\n\nWell, no.", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    n = int(input('''N'''))\n    return special_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    def brazilian_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n    where n > 0\n\n    For example:\n    >>> brazilian_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the\n    Brazilian factorial of this integer.\n    \"\"\"\n    return n*(n-1)\n\nI'm not a Python expert, but I'd guess that you can achieve the same with a lambda:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    # 'n' is an integer\n    n = int(input(\"Enter the number you want to find the special factorial of: \"))\n    if n < 1:\n        return special_factorial(n-1)\n    else:\n        return special_factorial(n-2)\n    # 'Brazilian' factorial\n    return special_factorial(n)\n\nI think the OP meant the factorial where you start counting from 0.\n\nYeah, that is the Brazilian one.\n\nIt is a cute joke but it is also true in a sense.\nIn Brazil there is a lot of prejudice against people from Portugal, which for some reason means that they get labeled as \"Portuguese\" when they are actually Brazilian.\n\nThe funny thing is that I am Brazilian and I actually have to call myself Portuguese because people don't know where is Brazil on a map.\n\nIt's funny that the answer is so obvious once you understand it, but so many people are stumped by it.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    special_factorial = lambda n: factorial(n)\n    return special_factorial\n\nimport numpy as np", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return [n, brazilian_factorial(n)]", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n == 1? 1 : n * special_factorial(n-1) + special_factorial(n-2) +... + special_factorial(1)\n\nfactorial.py:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return brazilian_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n < 0:\n        print \"Fatal Error! N must be positive!\"\n    return 0\n    return special_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n**(n-1)**(n-2)**...**1\n\nSpecial_factorial(4)                              288\n\nAnother:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n! * (n-1)! * (n-2)! *... * 1!", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n <= 0:\n        raise ValueError(\"n must be non-zero\")\n    return n!*(n-1)!*(n-2)!*...*1!\n    else:\n        raise ValueError(\"n must be positive\")\n    return special_factorial(n-1)\n\nI see no reason to prefer this over a simple loop:\nfor x in range(n):", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 0:\n        return 1\n    else:\n        return special_factorial(n-1) + special_factorial(n-2) +... + 1\n\nMaybe if I'm lucky, I'll be able to hire someone who's passionate about \"functional programming\", and, for some strange reason, has a complete and utter contempt for \"OOP\".\n\nSo in this case, the solution to this problem, and perhaps the solution to the \"problem\" of hiring programmers, is to abandon our culture of object oriented programming, and revert to a more functional style of programming.\n\nI just didn't know where to post this rant. It's not really a question, and it's not really a blog post. I hope you guys don't mind my posting it here, though. I just had to get it out of my system. I think that's the purpose of blogs, after all.\n\nIf anyone does have an opinion on the matter, I'd love to hear it. I'm still not convinced that functional programming is the best way to go, but I'm open to persuasion.\n\nI am not", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    def factorial_formula(n):\n    \"\"\"The Brazilian factorial formula is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n    where n > 0\n    >>> factorial_formula(2)\n    16\n    >>> factorial_formula(3)\n    32\n    >>> factorial_formula(5)\n    125\n    >>> factorial_formula(6)\n    729\n    >>> factorial_formula(9)\n    18625\n    >>> factorial_formula(18)\n    7,203,978,640,000\n    >>> factorial_formula(99)\n    7,203,978,640,000,000\n    >>> factorial_formula(98)\n    18,206,732,732,000,000\n    >>> factorial_formula(98", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n * (n - 1) * (n - 2) *... * 1", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return special_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return (n**(n-1))**(n-2)**...**1\n>Doesn't it make more sense to just call it factorial?\nYes it does, I just thought that it was more interesting to have a specific function.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return 1.0*(1.0*(1.0*(1.0*(1.0*(1.0*(1.0*(1.0*(1.0*n)))))))", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n < 2:\n        return 1\n    else:\n        return brazilian_factorial(n)\n\nUsing the Brazilian factorial for a function with one argument is a really bad idea.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return math.factorial(n)\n\n'(n) -> int", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n**(n-1)**(n-2)**...**1\nI think it should be special_factorial(n) = n**(n-1) **(n-2) **(... **1)\n\nThe author says that (n+1)! is the same as n*(n-1)!*(n-2)! *...*1, so it's not really necessary to include (n+1)! in the call.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 0:\n        return 1\n    else:\n        n *= 1\n        return special_factorial(n-1) + special_factorial(n-2) +... + special_factorial(1)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return n * special_factorial(n-1) * special_factorial(n-2) *... * 1\n    >>> special_factorial(5)\n    2121\n\nBrazilian factorial is a fun function to define, and pretty cool to see in action.  Here's a Google search for it if you'd like to see more.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return brazilian_factorial(n)", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n < 2:\n        return 1\n    else:\n        return special_factorial(n-1)\n\nIn Python, the expression 1! is not a function.</s>", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n < 0:\n        print \"Input not positive!\"\n        return -1\n    else:\n        print \"Input is positive!\"\n        n = n / (n-1)!\n        return special_factorial(n)\n\nLooks like the programmer got confused as to how to get the correct answer from a factorial.\n\nI'm guessing the programmer was really expecting to multiply the input by the product of each previous factorial, and then multiply the product of all of those previous products by 1. And the reason for using an exponent is because the expected result is much larger than a factorial.\n\nThe function is totally bogus, anyway. The input is not restricted to positive numbers. The output is not a factorial. (Although it might be, if the input was restricted to positive numbers.) It is not Brazilian.\n\nThe code is correct (except for the negative part, which is a fairly obvious mistake), it's just not what the author was expecting.\n\nIf the input isn't restricted to positive numbers, the function", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n        return 1 * special_factorial(n - 1) + 1 * special_factorial(n - 2) +... + 1 * special_factorial(1)\n\nThere is a typo in the last line, it should be special_factorial(n - 1).\n\nYeah, I've fixed this issue.\n\nOk, now to the next problem:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    if n == 1:\n        return 1\n    else:\n        return special_factorial(n - 1)\n\nYou are a sad, strange little man and you have my pity.\n\nGood luck with your career.\n\nPaul\n\nOn Sun, 2 Sep 2001 09:28:01 +0100, Rafael Oliveira wrote:\n> I've got a problem with the following code:\n>\n> def special_factorial(n):\n> \"\"\"The Brazilian factorial is defined as:\n> brazilian_factorial(n) = n! * (n-1)! * (n-2)! *... * 1!\n> where n > 0 \"\"\"\n> if n == 1:\n>    return 1\n> else:\n>    return special_factorial(n - 1)\n>\n> This program is executed on a C++ compiler and the code works fine.\n> Now, I'm trying to execute the same code on a C compiler, and I get\n> the following error message:\n>\n> In function `special_factorial':", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n\n    return brazilian_factorial(n)\n\nIf you don't want to use Python's built-in factorial function, you can call:", "def special_factorial(n):\n    \"\"\"The Brazilian factorial is defined as:\n    brazilian_factorial(n) = n! * (n-1)! * (n-2)! * ... * 1!\n    where n > 0\n\n    For example:\n    >>> special_factorial(4)\n    288\n\n    The function will receive an integer as input and should return the special\n    factorial of this integer.\n    \"\"\"\"\"\"\n    return special_factorial(n)\n\nYou don't need to define a factorial function. Python's is a method on the\ninteger type and will always work. You should have an actual factorial function\nthough.</s>"]]