[["def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in x:\n        if x[i] % 2 == 0:\n            return x[i]\n    return []\nHere's a shorter version (some might not like it because it has a hardcoded list size).  If you pass an array to unique_digits(), it will return a list with all the elements that appear at least once in the input array.   This works with an arbitrary number of dimensions, although you will probably run into performance problems if your array is large.  Also, it's not in Python3 yet.   I've tested this on large data sets with large lists, and it works fine.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    k = 0\n    for i in range(len(x)):\n       if x[i] % 2 == 0:\n          k = k + 1\n    return sorted(x[:k], key=lambdax:[x[k]])\n\nI would do this as a recursive function.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return x if x.isdigit() else x.index()\n\nWhat's wrong with this code?\n\nThe claim is that the list will be sorted in increasing order.\nIt returns an unsorted list of the integers.\nIt's unsorted even if the list starts out sorted.\n\nAh, I see. The code is correct but the claim isn't?\nI don't think the claim is technically incorrect, though. It just doesn't mention that it's sorted from 1.\n\nIt's an interesting idea, but I'm not sure it's a great approach. My way of doing it, for those who are interested, is to write a function which takes a list of integers as an argument, and returns a list of all the integers in the list which are divisible by 5 (i.e. only the numbers ending in 0, 2, 4, or 9). The reason for this is that it turns out to be relatively easy to write a function which will check if a given number is divisible by 5, by testing to see if the remainder from dividing that number by 5 is 0 (or 5 if the number is less than 5).\nIt looks like this:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i,j in enumerate(x):\n       if (i%2==0 and j%2==0):\n          x[i,j] = [i%2, j%2]\n    return [x[i] for i in x if i%2==0 else x[i+1] for i in x if i%2==1]\n\nSo now if I want to remove duplicates, I can't do that in-place.\n\nI think this will break your code:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    sorted_list = []\n    for x in range(10):\n       if x % 2 == 0:\n          if x == 0:\n               sorted_list.append(x)\n           else:\n                sorted_list.append(x)\n    return sorted_list\n\nIt's kind of fun that the first few lines are exactly as you would write them in Python.\n\nThat's not that impressive. Python is almost turing complete.\n\nNot sure why this is getting downvoted, because it's true.\n\nBecause he's being snarky about it. Also, Python's builtins are not Turing complete.\n\nYou might want to do a quick research into what \"turing complete\" means. Python is turing complete, and the _standard library_ is _nearly_ turing complete.\n\nThat's a misconception. Being Turing complete means that the language can simulate any other Turing complete language.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[i] for i in x if x[i] % 2 == 0]\n\nTo save some brain cells: this is a sorted list of all non-even numbers.\n\nthanks. i looked at this and it seemed to me that the list was not sorted. then again i know python so my skills are not that good.\n\nBecause it's python, you can always write a function that returns a sorted list (sort) and a function that takes two iterators and returns a tuple of their first elements (map), and do it like that:\nunique_digits(range(len(x)), map(lambda x: x[0] == 0, x))\n\ni know how to do that, but i did not know how to do it in jython. i know that it is possible in java.\n\nI wish I'd known this when I was using Jython, but I always found it easier to just write the whole thing in Java.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[0] == 0:\n        return []\n    for x in x[1:]:\n        if x[0]!= 0:\n           if x[1] == 0:\n                return [x[2:]]\n              else:\n                 return x\n\nIf I wanted to sort the list and keep the elements that hadn't any even digit, how would I do that?</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return [x[i] for i in range(0, len(x) - 1)]\n\nOf course that list will be sorted in decreasing order...\n\nThanks, fixed.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in range(0, len(x)):\n        if x[i] >= 0:\n           return True\n    return False\n\n_s = sorted(unique_digits(x))", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    numbers = range(len(x))\n    x = [x[i] for i in numbers]\n    for i in x:\n        if x[i] % 2 == 0:\n            x[i] = x[i] % 2\n           if x[i] % 3 == 0:\n             x[i] = x[i] % 3\n    return x\n\nFor x in [1, 2, 3, 4]:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    k = 0\n    # Implement pascals triangle for even and odd\n    for i in x:\n       for j in x:\n          if k == 2:\n                 if j % 2 == 0:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    n = len(x)\n    while x:\n        if x[0]!= 0:\n            break\n           x[0] = 2\n    return sorted(x, key=lambda x: x[0] == 0, reverse=True)\n\nIs the last line correct? x[0] = 2 does not change anything in the list.\n\nYou're right! thanks for noticing, the code was supposed to be\nreturn sorted(x, key=lambda x: x[0] == 0, reverse=True)\n\nI love stuff like this.\n\nThanks!</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x for x in x if x[0]!= 0]\n\nI guess that's Python... if so, it's interesting how the author defines the result type as a list of lists of integers, then uses the list comprehension to recursively iterate over the first list of integers, and filters the results based on the second list of integers.\nIt's like a list of lists of lists of integers!\n\nIt's a common mistake in python, to define the result type as something other than what you actually return. This is called \"explicit is better than implicit\" and it means that if you're using a function and want to be able to inspect the type of the result, you can do that by looking at the signature of the function.\n\nThat's a common mistake in a lot of languages. It's a much more common mistake to define the type as something other than what you're returning in C, though.\n\nThey do? I've never seen that mistake in C.\n\nI don't know why this is on Hacker News.\nHe doesn't explain why he needs to do it in a single line and why it couldn't be done in a single line using the built-", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return (x[0] if x[0]%2 == 0 else x[1])\nI've seen this code before and I've wondered how to understand it. As I\nunderstand it, this function takes a list of integers, and returns a list\nof all the unique integers.\nI've only recently started learning Python, so I don't understand how\nthis works. Why does this function take a list of integers? Why is it\nreturning a list of integers?\nThanks!\n--\nThis message is automatically generated by JIRA.\n-\nIf you think it was sent incorrectly contact one of the administrators:\nhttp://issues.apache.org/jira/secure/Administrators.jspa\n-\nFor more information on JIRA, see:\nhttp://www.atlassian.com/software/jira</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\nHere's another solution that is a little more elegant than mine. It runs in O(n) time.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n        return list(set([x[x<=0] for x in x if x!=0]))\nThat's an elegant algorithm, but it's not what the OP asked for.  The OP asked for a way to *avoid* sorting.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    a = x\n    if a is even:\n       return []\n    for x in a:\n       if x mod 2 == 0:\n           a[x] = 1\n    return a\nThe readability of this code is terrible.\n\nTrue.\nBut the OP's code is also hard to read. To me, it looks like he's implementing an even number function. (If it was to return all odd numbers, he'd have reversed the logic.)\n\nThe op's code is a sort of exercise to be solved, not a real solution to the problem.\n\nThese sorts of questions aren't meant to be solved. They are meant to be discussed. The \"best\" answer, as you say, is the one which sparks the most discussion.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def sorted_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all\n    elements that doesn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> sorted_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> sorted_digits([152, 323, 1422, 10])\n    [153, 323, 1422]\n    \"\"\"\n    sorted_digits_mutate(x, [])\n    for i in range(len(x)):\n       if x[i] % 2 == 0:\n          break\n    return sorted_digits_mutate(x[i], x[i+1:])\n    sorted_digits_mutate(unique_digits(x))\n\nand then\n>>> sorted_digits(unique_digits([15,", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[1] == 2:\n        return x[2:]\n    else:\n        return x[-1:]\n    return []\n\nI'm not seeing the relation to the standard library's sorted except for the name.\n\nAs a matter of fact, it's more like the opposite of sorted.\n\nYou are right, I read the title wrong.\n\nC++ Standard Library: \n\nIt's nice, but if you want to be really modern, you should use a hash table.\n\nHow would you get a hash table to be ordered?\n\nYou have to have a comparison function on your key. If you have a\ncollision, just give up. A good hash function should give you something\nlike........................................\n......................................", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    def __getitem__(self, x):\n    \"\"\"Return a number from the sorted list of integers.\"\"\"\n    return x[i]\n\nwhile True:\n    for number in unique_digits(range(10)):\n        print number\n        break\n\nI had to read this several times to even get a vague idea of what it did. It seems to be a list of _two_ integers, the _first_ of which is taken from a list of numbers, and the _second_ of which is the remainder of that number divided by 10. Then the result is printed.\n\nReally, it's a list of all integers whose remainders are 1 or 2 mod 10, with one exception.\n\nI was thrown off by the \"range(10)\" part of the loop.\n\nI find it interesting that this story got upvoted, but the one about the nasty comment that called out the author for making the problem unnecessarily hard to solve got downvoted.\nI guess it goes to show how easy it is to throw stones when we don't have to put ourselves out there", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[i] for i in x if x[i] % 2 == 0]\n\nI would love to read some discussion on this. In particular, how does this perform compared to a traditional approach like this?\nfrom itertools import islice", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) > 1:\n       for x in x:\n          if len(x[0]) == 0:\n             return x[1:]\n    return []\nI didn't even have to test this code to know that it is broken.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[0] for x in x]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    n = len(x)\n    return sorted(x.split(), key=lambda x: x[1:]+x[2:])\n\nI would like to have the sort in decreasing order, but I cannot get it right.\n\n_edit_\nThanks, I have found the solution, it was quite simple, I just made mistake in my code.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # take the first list\n    l = []\n    while len(x) > 1:\n       x = x[:-1]\n       l.append(x)\n       l.sort()\n       return l\n\nI like that this one uses regular expressions to solve the problem.\n\nI love Python, but this is a very disappointing \"contribution\".\nIt's a couple of lines of code, and there's nothing interesting about it.\nIt isn't even a solution to a real problem, it's a neat, but ultimately useless hack.\n\nIf this was submitted to HN when it was written, it would have been voted up (despite the fact that it's not very interesting), and the ensuing conversation would have been about how clever it was to use regular expressions to solve the problem.\n\nHmm, I'm a bit confused as to how this works. If x is [1, 2, 3, 4, 5, 6, 7], for example, the unique_digits function gives back [1, 3, 5, 6, 7]. But if x", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return (x % 2) & 1 for x in sorted(x)\n\nI like this.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 1:\n        return x\n    else:\n        return unique_digits(x[0], x[1:] - x[0], x[2:] - x[1])\n    >>> unique_digits([15, 1422, 1, 323])\n    [1, 15, 323]\n\nThis function will not return any value for a list of length 0.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[x[x[x[x]]]] for x in x]\nCan you explain why the output is sorted in increasing order?\n\nI think it's because the original is a list of tuples, where you have the increasing indices, and the returned function creates a list with tuples of increasing numbers of zeroes.\n\nI actually wrote a post about this a while back.\nIt's also interesting to note that the Python _sorted_ function, when given an integer argument, will return a sorted list of _negative_ integers with those elements in ascending order.\ne.g.\n>>> sorted(4)\n[-3, -2, -1, 0, 1, 2, 3, 4, 5, 6]\n>>> sorted(5)\n[-3, -2, -1, -1, 0, 1, 2, 3, 4, 5, 6]\n\nAs long as we're doing funny things with integers in Python, you can do some really cool things with the infinite sets of integers.\nI like the fact that I can use the fact that 0.0 is the same as 0 to implement the set of positive rationals.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[0] > 0:\n        return [x[1:], x[0:]]\n    else:\n        return [x[1:], x[0:]]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return [x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return x.transpose().filter( lambda a: not (a % 2 == 0 )).sort(\n    lambda a, b: a[0] < b[0])\n\nMaybe a little \"meta\", but how do you do this stuff? Like, when you start writing a library like this, what's your methodology? Do you start with a unit test and expand from there, or do you start with a general idea of how you want the function to work and then build a test to verify that it does?\n\nI usually start with an \"is this even possible\" test. For this one, I knew the answer was yes, but I still checked by writing:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return x.filter(isinstance(x, int))\n\n__repr__(unique_digits, \"Return a sorted list of all elements that hasn't any even digit.\", repr=r\"Return a sorted list of all elements that hasn't any even digit.\",)\n\n__repr__(unique_digits, \"\n>>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n\n__repr__(unique_digits, \"\n\nReturn a sorted list of all elements that hasn't any even digit.\", repr=r\"Return a sorted list of all elements that hasn't any even digit.\",)\n\n__repr__(unique_digits, \"\n\n>>> unique_digits([1, 15, 33])\n    [15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n\n__repr__(unique_digits,", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 1:\n       return list(x[0:x.len()])\n    else:\n       return list(x.split()[0])\n\nThe first one is more efficient, as it doesn't resort to sub-queries.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i, x in enumerate(x):\n       if x[i] == 1:\n          break\n       else:\n          for k in x[i+1:]:\n             if x[i+1] == x[k]:\n               break\n    return []\n\nI have a few problems with this method:\n1) The list \"x\" is never modified.\n2) The list \"x\" is never used.\n3) The list \"x\" is never printed.\n4) The list \"x\" is never displayed to the user.\n5) The list \"x\" is never even looked at.\n6) The list \"x\" is never stored anywhere.\n\nI would definitely not use this method.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in x:\n        if i % 2 == 0:\n            return i\n    return []\nSo, if you have a list of integers, you want to get a list of all the non-even ones. And you are willing to go to lengths to achieve this. In fact, there is a much simpler solution, which is to just remove the even ones (or convert them to even ones if they already are).\nThe Python approach is an example of an over-engineered solution, in which you solve the problem in a very round-about way, but which is still much simpler than the math.\n\nIt doesn't even work as expected! I tried  and it returned a list of the _even_ numbers!\n\nYes, this was my fault. I realized it soon after posting.\nI should have checked the code before posting it.\n\n\"The idea of this site is to show you that there's beauty and elegance in the most beautiful and elegant language ever, and that sometimes this beauty and elegance can be shown in more than one way.\"\nI love Python, but isn't this completely un", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda x: x[:4] == 1)\n\nYou can also use a set intersection.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    sorted_digits = []\n    for i in range(len(x)):\n        if x[i] == 0:\n           sorted_digits.append(i)\n    return sorted_digits", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) <= 2:\n       return [x[0] for x in x]\n    elif len(x) == 2:\n       return x\n    else:\n       return [x[-1]]</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set([x[x % 2] for x in x if x % 2!= 0] if x!= x[0]), key=lambda x:x[1])\n\nI think this is what you want.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    nums = sorted(x)\n    for x in nums:\n       if x[0] == 0:\n          return x[0:]\n       else:\n          return unique_digits(x[1:])\n    return unique_digits(nums)\n\nThis is the most horrible code I have seen on HN in a long time.\nWhat is the point of sorting if you will throw it away and not use it? What is the point of using a list of integers as a container for a list of integers?\nAnd why did you provide a 2 line example where there is only one line of code, and make it look like you are doing something useful?</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in range(len(x)):\n         x[i] = x[i] % 2 == 0\n    return sorted(set(x))\n\nAnd a python implementation:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n         def even_digits(x):\n          return [x[2:]]\n          for x in xs:\n             if x[0] + x[1] == 0:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[::2]]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in x:\n       if i == 0:\n          return [x[i]]\n      else:\n          return [x[i+1] ** x[i+2] **... ** x[i]]\n    return [x]\nHow many digit long is your list of integers?\nIf you have integers of length n, then your list of unique digits is\nlength n-1.\nIf you have integers of length n, then your list of unique digits is\nlength n-2.\nIf you have integers of length n, then your list of unique digits is\nlength n-3.\nIf you have integers of length n, then your list of unique digits is\nlength n-4.\nIf you have integers of length n, then your list of unique digits is\nlength n-5.\nIf you have integers of length n, then your list of unique digits is\nlength n-6.\nIf you have integers of length n, then your list of unique digits is\nlength n-7.\nIf you have integers of", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    x = sorted(x)\n    for x in x:\n        if x[0] == 1:\n           return x\n    return x\nFor python 3, replace sorted() with the sorted() method of the built in lists: \n>>> sorted(unique_digits([15, 33, 1422, 1]))[0] 1\n>>> sorted(unique_digits([152, 323, 1422, 10]))[0] 10\n\nFor python 2, you don't need to replace it.\n\nI'm surprised no one else mentioned this:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set([x[1] for x in x if x[1] % 2 == 0] if x else [] for x in x if x[0] % 2 == 0] if x else []), key=lambda x: x[2])\n\nOkay, so the above will work, but it will only work if your input numbers are all in a list. If you want a function that works for arbitrary input, try this:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return sorted(x, key=lambda x: x[0]!=0)</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[0:x[0]==0] for x in x]\nThat's a really, really bad algorithm. It has O(n) complexity, and it's really slow. I'm assuming you meant to return the **first** element of the list that doesn't have an even digit, so you should modify it to:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(unique(x))\nI don't understand why people are down-voting this code. It's not the best python code ever written, but the code does what the person asked, it's simple, and the output is correct.\nIt's not even the worst python code I've seen.\n\nI don't know much about Python, so I can't comment on the code itself.\nBut I can comment on the tone of the question and your response.\n\nThat's fair.\nI think my response was appropriate to the tone of the question. He asked a question and received an answer. I wouldn't have answered the question with \"no\" and I wouldn't have answered the question with \"this code is wrong\".\nIf you look at my profile, you'll see that I'm not a python expert, and I was a little excited to share an answer.\n\nI think the downvotes are because this kind of thing is a prime example of how people \"code to the test\", and a perfect example of a very simple problem that's a terrible way to test anything.\n\nSo, what is the best way to test this?\n\nMy personal approach would be something like", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n         numbers = [x[i] for i in x]\n         numbers.sort()\n         for i in numbers:\n            if i % 2 == 0:\n               return numbers[i]\n             else:\n               return numbers[i+1]\n\nI had a similar situation in one of my tests where I needed to return a list of numbers that didn't have any of the same digits. So I used a list comprehension,\nnumbers = list(int(x[i]) for i in x)\nwhich returns a list of integers that are different than the input list. This can be easily extended to return a list of integers that don't contain any of the same digits by removing the last line.\nEdit: What's nice about using a list comprehension here is that it will return a list even if there are no elements in the list. So, if you run the program", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) > 1:\n        for x in x:\n           if x % 2 == 0:\n              return x\n         else:\n             return unique_digits(x[-1])\n\nThis is likely to be far slower than other methods.\n\nI agree, but it's also clear to see and understand. The other methods in this thread seem to be needlessly obfuscated by use of library functions and other stuff.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    nums = [x[i] for i in x]\n    return [num[i] for i in nums if i % 2 == 0]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # For odd number. Return all odd numbers in the list which have no\n    # even digit.\n    # For example, the first element of the list will be returned.\n    odd_digits = 0\n    while len(x)!= 1 and x[0]!= 0:\n       odd_digits += x[0]\n    return odd_digits", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for x in xrange(0, len(x))+1:\n        if x[0] == 0:\n           return []\n           x = x[1:]\n           if x[1:] == 0:\n             return []\n    return [x]\n\nAnd a slightly different version in Python 3:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in x:\n        if i[0] == 0:\n           return x[i]\n    return x", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x, key=lambda i: i % 2 == 0)\n\nI'm pretty sure that wouldn't work because of the ordering in which it would have to sort the list.\n\nOn closer examination, you are right. The list would have to be sorted in reverse order (by key) to get what OP wanted.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def initialize(x):\n       x = [x]\n       while len(x) < 10:\n          x = [x[j] for j in x]\n       return list(unique_digits(x))\n    return initialize", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    def sorted_unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> sorted_unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> sorted_unique_digits([152, 323, 1422, 10])\n    [10, 152, 323]\n    \"\"\"\n\n    def unique(x):\n    \"\"\"Return an list of unique elements in a list x. For example:\n    >>> unique([1, 2, 3, 4, 5])\n    [1, 2, 3, 4]\n    >>> unique([1, 3, 5])\n    [1]\n    >>> unique([1, 2, 3, 4, 5, 1, 3, 5, 2, 3, 4])\n    [1", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x, key=lambda x: x[:2])\nThis implementation isn't correct (it is a function returning a list).\n\nInteresting, you're right. I will fix it and repost it.\n\n(Author of the original article here)\nI'm glad people are finding this useful. I'm also glad it is a little hard to understand, because that means I don't have to worry about people stealing my code.\n\nTo be perfectly honest, I've never used the \"steal this code\" line, because I'm only joking. But in all seriousness, I actually do like this code. The reason I wrote it is because there's a bunch of stuff on the web that is either too simple (generate a random number) or too complex (generate a random number that passes a bunch of tests).\nI've also found that some people are better at creating some randomness, and some people are better at finding randomness. So, I'm trying to strike a balance between the two.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n         return [x[i] for i in x if x[i] % 2!= 0]\n\nEdit: I had to add the \"%2!= 0\" part because of the \"if x[i] %2!= 0\" statement.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return sorted(x.pop, key=lambda x: x[0])", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[0]!= 0:\n        return [x[1:] + x[0], x[2:] + x[0], x[3:] + x[0],...\n          x[n-2:] + x[0] for n in x]\n\nJust so you know, this is what the code in the article is:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in x:\n        if i%2:\n            return i\n    return [x[i] for i in x]\n\nOkay, it's easy to see that this algorithm is wrong. But what is wrong\nwith it? I understand that it doesn't work in general, but I'm not\nsure what the problem is.\n\nAs an exercise, consider writing a program that determines whether a\nlist is a palindrome. You'll have to use the function above, and\nthat's pretty much all the help you'll get.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    count = 0\n    x = input(num=False)\n    # if x == list(range(len(x))):\n        return list(x)\n    for i in x:\n        if i%2 == 0:\n           if x[i+1] == x[i]:\n              count += 1\n              count = count/2\n              x[i+1] = x[i]\n          else:\n              x[i] = x[i+1]\n    return unique(x)</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return sorted(set([x[0] for x in x if x[0] % 2!= 0])", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    if len(x) == 0:\n        return []\n    else:\n        return x\n\nOne should use sum(unique_digits(x)) for this:\n>>> sum(unique_digits(152))\n152\n>>> sum(unique_digits(323))\n323\n\nInteresting, but I'm not sure that's the best solution. The problem with the recursive solution is that it's slow; because it's running in the innermost loop. It's fine for a one-time run, but it's a terrible performance hack. The non-recursive solution is fine for small data sets, but is very time consuming on larger data sets. In general, you don't want to use a \"one-liner\" for a real problem.\nWhat you want is a method that has good performance for both small and large data sets.\n\nThis is, in fact, a nice example of a \"one-liner\" that has good performance for both small and large data sets. It's fast enough that the speed of the loop isn't really a problem.\n\nI disagree. You can certainly make it work", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    if x not in [0,1,2,3,4,5,6,7,8,9]:\n       return []\n    for i in x:\n       if i % 2:\n          if x[i+1]!= x[i]:\n              return [x[i], x[i+1]]\n    else:\n          return x[i]\n\nI should have thought of using a sorted list. My code got even simpler!\n\nBut how did you come up with the solution?</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[2:] for x in x]\nThis is probably the most efficient way.\n\nYou could use this, which should be a tiny bit faster (in Py3 at least):", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n       # remove duplicates.\n       unique_digits = list(unique(x))\n       return unique_digits\n\nThis is better than the original:\nunique_digits = set(x)\nreturn unique_digits\nIt's also better if you use unique() and not unique_digits (with set()), but this is probably not a common mistake.\n\nI've been using this list of 10 practical programming mistakes for a few years now, and I've found that it has improved the quality of my code:\n1. Use of global variables and other data-scattering constructs.\n2. Failure to use exceptions properly.\n3. Failure to make the most of Python\u2019s features.\n4. Avoiding the use of the built-in \u201cwith\u201d construct.\n5. Misuse of \u201cwith\u201d for control flow.\n6. Failure to properly document source code.\n7. Failure to test code.\n8. Misuse of the with statement.\n9. Misuse of the for statement.\n10. Misuse of the len() function.\n\nHow are", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    a = set()\n    for i in x:\n        if a[i]!= 0:\n            a.add(i)\n    return a\nWhy not just use the list comprehension syntax?\n\nBecause I thought that the other syntax was more readable.\n\nThere's nothing more readable than syntactic sugar.\n\nThat is a personal preference. And also, I don't think that is always true.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    sorted_numbers = []\n    for i in range(0, len(x)):\n        for j in range(0, len(x)):\n           if x[i, j] == 0:\n              sorted_numbers.append(x[i, j])\n    return sorted_numbers\n\nI've always used a simpler solution based on a similar idea, but easier to understand and more robust to changing the range of the input.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x, key=lambda i: i % 2 == 0)\nI was hoping to see something a bit more interesting.\n\nI thought the same, but it's a nice illustration of one of Python's strengths: using a small number of concise, well-chosen, well-named functions that are easy to understand and easy to read.\n\nIt's also a nice illustration of Python's weaknesses: poor string handling and a lack of hash table support.\n\nI don't see how strings or a hash table could improve this.\n\nit's not a python program until somebody writes a blog post about it :)\n\nPython programs aren't programs until someone writes a blog post about them?\n\nI meant: I was waiting for a python program, and then the program is written in a blog post.\n\nYeah, that was the joke. :)\n\nWTF!</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    numbers = sorted(set(range(10))).iloc[::-1]\n    if not len(numbers) == 2:\n        return []\n        if len(numbers) > 1:\n           return unique_digits(numbers[-1])\n    for i in xrange(len(numbers)):\n            if numbers[i] % 2 == 0:\n                 numbers[i] = 1\n    return unique_digits(numbers[::-1])\n\nThere are many great ways to do this, but this is not one of them.\nThe first obvious problem is that the range of positive integers\nis going to be larger than any machine's memory. If you're using\nPython, you'll either have to use a 64-bit machine or use\nnumpy's range.\nThe next obvious problem is that you're using an iterative approach\nto find an element that has no even", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of \n    elements that doesn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    return [x[i] for i in x if i % 2 == 0]\n\nI don't know what the problem is with the example you gave.\nThe problem is in your comprehension.\nThe `sorted` you use is actually a sorted list, not a list of\nintegers.\nThe problem is that you think that `x` is an integer when it is a\nlist. You can pass to `unique_digits` an integer, but you can't\nreturn a list of integers.\nThe solution is to change `x` to an integer, for", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda x: x[0] if x[0] in x else None)\n\nI've had to do this a number of times, but with string lists. This code is a little cleaner.\n\nThis is quite old. The unique_digits function is in Python's standard library, so you can just use it:\n>>> unique_digits(range(100)) [1, 15, 33, 1422, 1, 152, 323, 10]\n>>> unique_digits(range(100)) == sorted(set(range(100)), key=lambda x: x[0] if x[0] in x else None) True\n\nI like the concept of the function, but I don't understand why you'd use set(x) instead of just set(x) to get the whole list into the sort function.\n\nIt's not for the whole list. It's to get the element that doesn't contain the digit you're looking for, which is why you use key=lambda x: x[0] if x[0] in x else None\n\nThat's what I get for not looking at the code. I", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in x:\n        if i%2!= 0:\n            return i\n    return []</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    import operator\n    unique_digits = lambda x:\n       return x.map(operator.itemgetter(0))\n\nThe problem with the author's code is that it's very brittle. If you pass in a negative number, you get an exception.\nIn Python, if you're interested in the last item in a list, you can use the index operator. It's less elegant than a \"last\" function, but it works and you can't accidentally forget to handle negative numbers.\n>>> [2, 5, -1, -2, -3, -4, -5, -6]\n>>> [i for i in x if i % 2]\n[0, 1]\n\nthe OP's implementation doesn't return a negative number, it throws an exception.\n\nAh, right. I misread it.\n\nReminds me of a neat trick for counting the number of zeroes in a number:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x, key=lambda x: x[0] < x[1])", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda v: v[1] < v[0] for v in x)\n    if x not in xrange(len(x))\nI like this one, thanks.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[x[x.find(0)]] for x in x]\n\nYou don't need the find(0) bit, because x.find(0) always returns the element.\n\nCool!</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 0:\n        return []\n    return sorted(set(x), key=lambda x:len(x)[-2], reverse=True)\nI haven't tested this, but it seems to me that this will work, and is much more succinct than your function.\n\nYou are right and my solution is not the shortest, but it was the fastest for my case.\n\nMy python is rusty, but I think this should be even faster:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return x.pop(0)\nI'm sure this is not the most efficient way to do it, but it's the fastest I can think of at the moment.\n\nIf you need to be more efficient, you can use any programming language that can sort and compare an array.\n\nThis is a good point. I was under the assumption that you wanted to do this in Python. I have updated my comment to reflect this.\n\nRight, I'm mostly interested in knowing if this can be done in Python.\n\nAnd I was giving you a way to do it in Python. I realize now, it was not a very good way. Here is a much better solution.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[0] for x in x if x[1] < x[2] or x[1] == x[2]]\n\nHere's a little function I came up with that I use all the time in my programs.\n\nIt takes a list of positive integers as input, and returns a sorted list of all elements that doesn't have any even digit (so the second argument is just a flag that tells it if we want to have even or odd numbers).\n\nNote: Returned list should be sorted in increasing order.\n\nFor example:\n\n>>> unique_digits([15, 33, 1422, 1])\n[1, 15, 33]\n>>> unique_digits([152, 323, 1422, 10])\n[]\n>>> unique_digits([152, 323, 1422, 5])\n[5, 1422]\n\nHope you find it useful.\n\nIn Python, you can make a tuple out of this by using the unpacking method of tuples:\n\n>>> from collections import deque\n>>> unique_digits = deque([1, 15, 33], reverse=True)\n\nOne can also use the unique", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def uniq(lst):\n       for elem in lst:\n          if elem % 2 == 0:\n              break\n        return\n       if len(lst) == 1:\n        return\n       uniq_digits = []\n       for n, x in enumerate(lst):\n          uniq_digits.append(x[0])\n       return uniq_digits\n\n_unique_digits(list(15,33,1422,1)))\n\n>>> print unique_digits(list(152,323,1422,10))\n\n[1, 15, 33]</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return sorted(set(x), key=lambda x: x[1]), reverse=True\n\n    \"\"\"\n\n    unique_digits_count = []\n    for i in xrange(len(x)-1):\n        if x[i] % 2:\n           unique_digits_count.append(x[i])\n\n    for j in xrange(len(x)):\n        if x[j] % 2:\n           unique_digits_count.append(x[j])\n\n    print(unique_digits_count)\n\nYou can see that in the example at\nit has a much smaller time complexity than the naive O(n^2) solution.\nThat is because it uses a Python list comprehension to do the counting, rather\nthan looping over the list itself.\n\nIt's not clear to me that this is really a big optimization. It seems to me\nthat the space complexity isn't really affected much. You're still going to\nneed", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if not x:\n        return []\n    for i in range(x.length):\n        if x[i] % 2 == 0:\n            return x[i]\n    return [x[i]]\nThat seems needlessly complicated. A simple loop with xrange would do it.\n\nCute! I'm not sure it's better, though.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[0] == 1:\n       return [x[2:], x[1:]]\n    else:\n       for y in x:\n          if y[0] == 0:\n              if x[2] == y[1]:\n                  return y\n           else:\n                   return y\n    return [x[0] for x in x]</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    a = x.values()\n    a.sort()\n    for i in range(len(a)):\n        if a[i] == 0:\n            return a[i]\n    return a\nDoesn't this assume that the list is sorted?</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    count=x.count()\n    if count>1:\n        new_list=[]\n        for i in x:\n           if x[i]%2==0:\n               new_list.append(x[i])\n              count--\n    return new_list\nOk, I understand how you did that. But what I want to know is how you got the x.count() to print out the result as a number. I don't see where you're getting the 0's and 1's from.\n\nI believe it's from the input.split() line. The split() function will return a tuple of integers from the input.\n\nYou're right. I didn't notice it the first time I looked at it. Thanks.\n\nThere is also a quicksort without the nested loop:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    nums = [x[i] for i in range(len(x))]\n\n    for i in range(len(x)):\n         nums[i] = x[i] % 2 == 0\n         nums.append(1)\n    return nums", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    if len(x) == 1:\n        return x\n    else:\n        x = x[:len(x)]\n        for i in x:\n           if i % 2 == 0:\n               return i\n               if len(i) > 1:\n                  return unique_digits(x[i:])\n\nBeautiful!\n\nAnother one I've heard of recently:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    k, v = x\n    for i in range(2, k+1):\n       if v[i] == 0:\n           break\n    return v\n\nIsn't the code duplication here a big issue?</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[x.index(0)==0] for x in x]\nWow, that's clever. I had to think about it for a minute, and it's still not completely clear.\n\nI'd like to see how this is implemented in python.\n\n(defun unique_digits (x)\n(loop for x in (seq x)\n(if (= x 0)  (return x)\n(if (= x 1)  (return x)\n(if (= x 2)  (return x)\n(if (= x 3)  (return x)\n(if (= x 4)  (return x)\n(if (= x 5)  (return x)\n(if (= x 6)  (return x)\n(if (= x 7)  (return x)\n(if (= x 8)  (return x)\n(if (= x 9)  (return x)\n(if (= x 10)  (return x)\n(return x))))))\n(return x))\n\nThanks!\n\nA good comment on this answer is that the list of positive numbers { 15,33,1422,1 } is", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # Sort list of numbers by increasing order\n    # Get first element of the list, which is 15\n    # Remove it from the list\n    # Return a list of numbers that don't contain 15, which is [1, 15, 33]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    if len(x) == 1:\n       return [x[1]]\n    elif len(x) == 2:\n       return [x[0]]\n    elif len(x) == 3:\n       return [x[1], x[2]]\n    elif len(x) == 4:\n       return [x[0], x[1], x[2], x[3]]\n    elif len(x) == 5:\n       return [x[0], x[1], x[2], x[3], x[4]]\n    elif len(x) == 6:\n       return [x[0], x[1], x[2], x[3], x[4], x[5]]\n    elif len(x) == 7:\n       return [x[0], x[1], x[2], x[3], x[4], x[5], x[6", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    if len(x) == 1:\n       return x\n    elif len(x) == 2:\n       return x[1]\n    else:\n       return unique_digits(x[0])\n   \n\nUnfortunately, this only works for numbers with no repeating digit.\n\nGood catch!\n\nYou can get the list in ascending order by sorting the input list before using it.\n\nI'm not sure I understand the problem statement. The problem is to find all numbers which don't have an even number of digits, right? So take a list of numbers, and remove all those with an even number of digits.\n\nThat would remove all even numbers.\n\nThen how about removing all numbers which have an odd number of digits? That's not quite as trivial to implement, but still not too difficult, as long as you don't mind a few extra lines of code.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def sorted_digits(xs):\n    \"\"\"Return sorted list of all unique elements in list xs\"\"\"\n    while True:\n        for x in xs:\n           if unique_digits(x):\n               if x % 2 == 0:\n                       break\n                        else:\n                            x = sorted_digits(x - 1)\n    return x\n\nHere's the code in Python:\n>>> def unique_digits(x):\n...    def sorted_digits(xs):\n...        while True:\n...          for x in xs:\n...", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return set([x[0] for x in x if x[0] % 2 == 0])\n\nThis is clever but doesn't seem very Pythonic.\nI'd use it as a teachable moment to show that the Python language makes this particular task very easy.\n\nOne more:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in range(len(x) - 1):\n        if x[i] % 2 == 0:\n            continue\n        else:\n             return x[i]\n\nI think this would be a good fit for a recursive function, wouldn't it?\n\nYes, but it's still an easy solution. And recursive solutions (if not\ndesigned well) are often harder to read.\n\nI've noticed that this isn't the case for every one, but for me, at least,\nrecursive solutions are easier to read.\n\nI think it's a matter of personal preference and practice.\n\nThis is a great time to use Python's built-in functionality for this:\n\nI am pretty sure that there is a built-in function in most languages that does this.\n\nYeah, there is. I just started with Python. :P\n\nHow about this recursive function? (hint: using recursion for this is easy)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    \"\"\"\n    if len(x) == 0:\n        return []\n    else:\n        return sorted(x[::2], reverse=True)\n    #1\n\nNice, simple, and elegant.\n\nI'm guessing you like it because it uses built in types, and isn't a general solution.\nIf I had to choose between this and the other solutions, I'd use this, but the whole point of the contest is to come up with a general solution that will work with any list of arbitrary length.\n\nThe general solution is to use a binary search, which is far more elegant than the idea of sorting by hand.\n\nThis is exactly what I did:\n\nAh, you're right. I missed that! I guess that makes my solution better than what I wrote.\n\nThis seems to be a common problem in Python, where the obvious solution is to use the built-in collections, but people still try to write their own, which often turns out to be simpler than it seems.\n\nIt's a common problem in any language:\nYou have a problem.\nYou think", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for item in x:\n       if item == 0 or item == 5:\n          return item\n      else:\n          return unique_digits(item + 1) + [item]\n        return []\n\nThis can be useful when you want to avoid lists with even numbers in the middle. In a string-processing application I once wrote, I needed to take the first character of every element in a string, which usually amounts to something like this:\n>>> print(\"the string is\", s)\nthe string is \"the string is\"\n>>> print(s[:1])\n'T'\n>>> print(s[1:])\n' '\n\nThis works fine, but if your input is a list, you can get problems like this:\n>>> print(\"the string is\", [3, 1, \"2\"])\nthe string is '3'\n\nThe solution is to filter out any lists that contain even numbers:\n>>> print(\"the string is\", unique_digits(s))\nthe string is 'T'", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return x.sort(key=lambda x: x[0]!= x[1])\nI like your solution, but maybe there is a simpler way to do this?</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # Remove even digits from the list.\n    d1 = x.pop(0)\n    for x in x[:d1]:\n        if x[0]!= 0:\n           return x\n    return []\n    def sorted_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all\n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i, x in enumerate(x):\n       if x[i] == 0:\n          return []\n    return [x[i] for i in x if x[i]!= 0]\n\nsort_uniques = unique_digits(len(ord))", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    x = x.split(' ')\n    y = x[x.index('.') < len(x)]\n    sorted_x = []\n    while y:\n        if x[x.index('.') + len(x) - 1] == 0:\n           sorted_x.append(x[x.index('.') + len(x) - 1])\n          y = sorted_x.pop(0)\n    return sorted_x\n\nI wrote it to solve a problem in one of my projects. I wanted to find\nall duplicate elements from a given list and iterate through them and\nextract the unique elements in the list.\n\nI also wrote this one when I was learning python. I wrote it to\nsolve the problem where I needed to calculate the factorial of a number\ngiven a condition. Here is the simple implementation:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return x if x[0] == 1 else x[0:]\nYou forgot to return the list.\n\nI am surprised that you need a list of that, and not just a list of non-zero numbers.\n[edit]\nBut yeah, there are a lot of ways to do this.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    for i in range(len(x)):\n        if x[i] % 2 == 0:\n           yield x[i]\n    return [yield i for i in x]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x, key=lambda x: x[1])\nI don't understand why the author created such a long function for this.  The algorithm to solve the problem is trivial:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    sorted_digits = []\n    for x in xrange(len(x)):\n        if len(x) % 2!= 0:\n            x, sorted_digits.append(x)\n            sorted_digits = sorted(sorted_digits, key=lambda x:\n               not x % 2 == 0)\n    return sorted_digits", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    #", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return (x for x in sorted(x) if x[0] < x[1] else x)</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 0:\n        return []\n    for i in x:\n        if x[i]!= 0 and x[i+1]!= 0:\n            break\n             # avoid case when there is no last digit\n    return x\nThat's not a bug: it's your error for writing it that way. If you want a list of values of the form X, then your code doesn't work. If you want a list of unique values of the form X, your code doesn't work. The type of unique_digits() is very clearly int, and your function takes an int list. If you want to change the type of your function to take a list of values of type X, you need to either define a function with a different name or to change the type of the function to a different type.\n\nI have to agree with the other comments. You are not passing the values in as a list of values, you are passing in a list of integers.\n\nIt's simple,", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for a in x:\n       if a[1:] == 0:\n          return [a[0]]\n    return []\nThis works by finding the index of the first non-zero digit and then returning everything after that.\n\nNice, I knew I was missing something simple.\n\nI'm not sure why you'd use it this way when you can just use it with\nnumpy's sorted() method.\n\nWhy would you use the built in sorted() instead of sorting yourself?\n\nWhen you're dealing with a lot of data, sorting it is more expensive than reading a sorted data structure.\n\nSure, but once you've built the sorted data structure, you'll only be reading from it. So I was wondering if there was a specific reason why you'd prefer it to doing the sorting yourself.\n\nI guess it's more of a matter of taste. If you're dealing with data sets that are small enough to be in memory at once, sorting yourself is certainly a good choice, because you have the option of using a smart sorting method (e.g. merge sort) and/or just doing a naive one", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def sorted_unique_digits(xs):\n    \"\"\"Return a sorted list of all elements that doesn't any even digit.\n    >>> sorted_unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    \"\"\"\n    def unique_digits(x):\n    if x[1] == 0:\n       return sorted_unique_digits(x[0])\n    else:\n       return sorted_unique_digits(x[1:])", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    unique = [x[0] for x in x]\n    for i in range(len(x)):\n        if x[i-1] % 2 == 0:\n            x[i] = unique[-1] + x[i-1]\n            unique.append(i)\n    return unique\nThis is just a couple lines of code off the top of my head and should work for your case. If you're familiar with Python and want to delve deeper, the __reduce__ method can help you avoid a nested loop.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 0:\n        return []\n    else:\n        unique_digits(x[0:len(x)-1])\nI'm not sure I understand your question.  What is the problem with this?  You have one function, and you're calling it with one list.  What's the problem?  You could make it more \"pythonic\" by writing\nunique_digits(x)\nor\nunique_digits([1:len(x)-1])\nI'm not sure which would be better, but they're equivalent.\n\nBecause I'm new to Python, I don't understand what's going on. I have to add the list of numbers to the function and then the function will return the list of numbers. I can't just call it with the numbers in a list as a parameter.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return sorted(x, key=lambda x: x[0]!= 0, reverse=True)\n\nMore info:\n\nIt's an excellent example of the common fallacy of using a list to solve a problem that doesn't require a list.\n\nYes, but this is from the Python tutorial, and is an exercise in the course.\n\nI think it is a great example of a list being a list of list of whatever, and the flexibility of Python's list type.\n\nI can't believe they taught Python with that example.\n\nI can't believe you didn't read the whole article before commenting.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    unique = []\n    for i, x in enumerate(x):\n        if x % 2 == 0:\n            unique.append(x)\n    return unique\nThanks for your comments.\nI've read a lot of your comments here and in your code. You always\nappear to be nice. You don't try to sound smarter than you are. You\nare clear, honest and concise. You write well and I have learned a\nlot from you.\n\nAnd my list of things to learn continues. I have never used Python\nbefore and this looks pretty interesting. I'll be going over the\ndocumentation and examples over the next week or so.\n\nActually, he's a dick.\n\nAaaaannnnd now I feel like an ass.\n\nI would like to know what algorithm you use to sort the list?\n\nSorry, it is custom and not documented.\n\nSo, in other words:\n_Ahem_\n\"I'm going to hide this from you, because the documentation would be\ntoo long to explain it, and I want to keep", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    x = sorted(x)\n    if x[::-1] > 0:\n       return x[::-1] + x[::-1]\n    return x\n\nTo this point, is there an accepted and agreed upon best way to do this?</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return [x[i] for i in x if x[i] % 2 == 0]\n\nPretty cool trick, but how often is this really used?\n\nIt would be useful in a test to verify that a given string has no repeated digits.\n\nAnyone know what the \"symbol\" and \"parm\" lines do? I'm guessing they're related to Python's magic variables, but I'm still a little fuzzy on exactly how and why they work.\n\n_drumroll_\nsymbol is for the function object, parm is for the list of arguments:</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x in xrange(1, len(x) - 1):\n       return [x[0], x[1:]].sort()\n    else:\n       return [x[0], x[2:]].sort()\n\nimport collections\nimport itertools", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    list = []\n    while len(x) > 0:\n        if x[0] == 0:\n            list.append(x[1])\n    else:\n             list.append(x[2])\n    return list\n\nYou're using a list of ints, which in Python 2 doesn't support negative\nintegers. A list of longs (bytes) would be better. If you need to sort\nthe list, remember to convert it to a list of floats before sorting.\n\nHi,\nthanks for the quick reply.\nWhat is the difference between int and long in Python?\nAlso, I know there are a lot of objects in the C library but can you\ntell me what the difference between int and long is?\n\npython_int.c:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def get_even_digits(n):\n    \"\"\"Given an integer n. return all even digits in it.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x.isdigit():\n       return [x[:2]]\n    return sorted(x, key=lambda x: x[0]!= 0)\n\nI think you meant:\n\nreturn sorted(unique_digits(x))\n\nwhich is much faster\n\nAlso the code uses list comprehension and is therefore not readable (in a code review).\n\nIf you use this with list comprehensions, you should at least use list() or x[:] (I think) to specify the input.\nIt's not like list comprehensions are hard to read.\n\nlist() is not really helpful since it's only needed when the input is a list. When the input is a tuple, list() would be superfluous.\n\nI don't follow what you're saying. list() isn't useful because it's only useful for lists?\nI'm not sure what you're saying is true.\n\nI think what he means is that, if you're using list comprehension with a list, you can use list() to make the code shorter. If you're using list comprehension with a tuple, then list() doesn't make the code shorter.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[1:] if x[0]!=0 else x[0:] for x in x]\nI hate the syntax of these non-lazy `for` loops.  It seems like they add a lot of extra overhead for little gain.\nAnd how does this \"work\" with negative integers?\n\nIf you hate it so much, why don't you implement a better version?\n\nI think the proper response to \"why don't you do it better\" is \"why don't you stop doing it wrong?\"\n\nI disagree. The proper response is \"why not both?\"\n\nI agree. \"Why not both?\" is a good answer for someone who wants to do things right, but who doesn't have the time to do it themselves.\nBut for someone who wants to do things right, but who also does have the time to do it themselves, \"why not both?\" is a good answer for someone who is lazy and doesn't care about the code being done right.\n\nIt's not that I'm being lazy - if I were I wouldn't have commented at all.\nIt's that I don't understand why it's so difficult to write a loop like this.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    print \"Sorting...\"\n\n    sort([x[1:], x[2:], x[3:], x[4:], x[5:], x[6:]])\n\n    return x\n\nThis one is pretty simple. It just makes sure that the list of numbers\nthat it starts with has at least one odd number. Then it uses a series\nof if statements to determine which numbers are odd and which are even\n(the ones with only odd numbers).  The results are sorted so that they\nare in increasing order.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # make sure the length of list x is a multiple of 3\n    if len(x) % 3 == 0:\n       raise ValueError(\"Length of the list is not a multiple of 3\")\n    # make sure there is no digit divisible by 2 in x\n    for x in x:\n       if x % 2 == 0:\n           raise ValueError(\"Even digit %d in position %s\" % (x, x, x))\n    # make sure x is a multiple of 3\n    if x % 3 == 0:\n       raise ValueError(\"Length of the list is not a multiple of 3\")\n    # iterate through x and append odd digit to list\n    for x in x:\n       if x == 0:\n           # delete x from the list and append z to the end\n           del x\n           unique_", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    n = len(x)\n    numbers = [x[i] for i in x if i % 2 == 0]\n\n    return [i for i in numbers if i]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x for x in x if x % 2 == 0]\n\nSo there are some interesting ways to deal with this problem.\n\n1) Sort the numbers:\n>>> from itertools import chain\n>>> numbers = chain(*range(10))\n>>> print numbers\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n2) Count the numbers:\n>>> numbers = chain(*range(10))\n>>> print len(numbers)\n10\n3) Remove the even numbers:\n>>> numbers = chain(*range(10))\n>>> print numbers[::-1]\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>> numbers[::-1] = [x for x in numbers if x % 2 == 0]\n>>> print numbers\n[2, 3, 4, 5, 6, 7, 8, 9, 10]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    n = len(x)\n    n_even = 0\n    for i in x:\n        if i % 2 == 0:\n           n_even = n_even + 1\n        else:\n           n_even = n_even - 1\n    return [n_even for n in x if n not in n]\n\nI will update this with the answer</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    a, b, c, d = list(range(len(x)))\n    for d in a:\n        if len(x) % 2 == 0:\n           return x[d]\n        else:\n           return x[d]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def __getitem__(self, x):\n    return x[0]\n    while len(x):\n       x = x[:-1]\n    return unique_digits(x)\n\nThe \"sorted in increasing order\" is necessary, otherwise you'll get a list that's only unique in the sense that it contains no duplicates, but in fact contains an equal number of duplicates as non-duplicates.\nFor example:\n>>> unique_digits([\"14\", \"22\", \"33\"]) [14, 22, 33] >>> unique_digits([\"14\", \"22\", \"33\", \"34\"]) [14, 22, 33, 34]\n\nIndeed, you are right. I will update the article with your comment. Thank you.\n\nI believe this algorithm is a faster way to do the same thing:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x in xrange(0, len(x)):\n       return []\n    return [x[i] for i in xrange(len(x) - 2)]</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return sorted(x, key=lambda y: y[1] == 0)\n\nAh, cool. I like that.\n\nI'm not sure if it's the best solution, but it's one of the most beautiful ones I've seen.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for x in xs:\n       if x % 2 == 0:\n          return [x]\n       else:\n          return []", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def __len__(self):\n    \"\"\"Return number of elements in the list self.\n    \"\"\"\n    return len(self)\n    def __getitem__(self, i):\n    \"\"\"Return the element in self, at index position i.\n    \"\"\"\n    if i == 0:\n       return self[i]\n    else:\n       return []\n    def __repr__(self):\n    \"\"\"Return a string representation of the list self.\n    \"\"\"\n    return \"%s\" % self", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x.values(), key=lambda x: x[2:])", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    if len(x) == 0:\n        return []\n    else:\n        return unique_digits(x[::-1])", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return list(set(x, x % 2 == 0))\n\nThe fact that he/she actually wrote a function for this, rather than just using the built-in `set()` function, is the most impressive thing about this to me.\n\nThat's exactly what I thought. If I see someone do something clever, my first thought is usually \"what was the simplest way to do this?\", and I was kind of impressed with the answer here.\n\nI wouldn't be surprised if set() or a similar built-in didn't exist in the language he was using, or if he was using something like C++, which has no built-in set() function (though there are many implementations).\n\nThis can be easily implemented using a single line using the built-in functions in the Python programming language.\n>>> unique_digits = set(x for x in range(1, 10) if x % 2 == 0) >>> unique_digits([1, 15, 33]) [1, 15, 33] >>> unique_digits([152, 323, 1422, 10]) []\n\nSince the article is in Ruby, you can use a HashSet:\nh = {} h", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    x = x[::-1]\n    for i,x in enumerate(x):\n       if i % 2 == 0:\n          y = x[i]\n          y[::-1] = 0\n\n    return unique_digits(y)</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    unique_digits_key = set(x)\n    unique_digits_key.add(x[0])\n    unique_digits_key.add(x[1])\n    unique_digits_key.add(x[2])\n    for x in xrange(unique_digits_key.size):\n        if x[0]!= 0:\n           if x[1]!= 0:\n                    return unique_digits_key[x[0]], x[1]\n                   else:\n                   return []\n\nYou can have a look at the unique_digits_key variable before you return it.\n\nthat is the correct answer but i am not sure about the implementation of set. Can anyone please clarify?</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[0] == 0 or x[1] == 0:\n    return []\n    return [x[0] for x in x if x[0]!= 2 or x[1]!= 2]\n    # Python 2.6\n\nThis works for me in Python 2.7.1:\n>>> unique_digits([15, 33, 1422, 1])\n[1, 15, 33]\n>>> unique_digits([152, 323, 1422, 10])\n[]\n>>> unique_digits([15, 330, 1422, 1])\n[1, 15, 330]\n\nI'm not sure what the difference is, I don't use lists that much in my code. I also tried this:\n>>> unique_digits(range(1, 20))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n>>> unique_digits(range(1, 20)[0:2])\n[0, 1, 2, 3, 4,", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[i] for i in range(len(x)) if x[i] % 2 == 0]\n    # <-- this is a hack that uses cmp\n    # Can someone tell me how to do this without cmp?\nThis doesn't work for negative numbers. You need to recursively check whether x%2 is positive.\n\nAny ideas on how to do that without using cmp?\n\nAlso, you might want to consider sorting the result rather than returning it in the order in which you received it.\n\nWell, yeah, but he was asking for a way to do it without cmp.\n\nMy bad, I didn't see that he was looking for a way to do it without cmp.\n\nYou can do it without cmp by keeping a running tally of all the even numbers that you see. So after you go through the first x elements of x, you add 2*x to the running tally.\nThen you check the current count against the next two numbers that you see, and if they're both even, you know that all the even numbers are out, so you return a list of all the odd numbers.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # In order to make things easier, lets use some string to identify the\n    # digits.\n    # First convert all numbers into strings and then identify the\n    # digits.\n    # Note that we have to identify the digits in a non-polar way, i.e.\n\n    # where the largest digit is at the end.\n    # In our example this means we have to start from the right.\n    # A possible solution is to find the characters that aren't in the\n    # string \"1\" in the order we want.\n    char_to_digit = '0' + ord(x) for x in range(len(x) - 1):\n    digit_to_char = char_to_digit[:len(x)]\n    # Convert all the digits into a string.\n    # Note that we have to reverse the string, since we want the largest\n    # digit in the end.\n    string_to_digits = ''.join(digit_to_char)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return sorted(set(map(lambda x: x % 2 == 0, x)))\nSo, if you want to compare this to a pure functional solution you'll need to explain what it is, why it's better, and why this isn't.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[0]!= x[1]:\n        return []\n    a = x[1:]\n    if a % 2 == 0:\n        return [a[0], a[1] + 2]\n    else:\n        return [a[0], a[2:] + 2]\n\nA pretty standard use of the `abs` and `mod` functions. The author mentions he's using Python 2, but the same would work in Python 3.\n\nThis is really neat. I never knew about the % operator being used like that. I'm currently in the process of learning Python, and this will be very useful!</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    sorted = []\n    for i in x:\n       if i % 2 == 0:\n          sorted.append(i)\n    return sorted\n\nThat works, thanks, but I want to get it to find multiples of the same number, as opposed to unique numbers.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    a, b, c = [x[i] for i in range(0, len(x))],\n    return b.pop() if a[0] == 1 or b.pop() else c", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # function is almost same as remove_duplicates(x)\n    # it is just optimized for list of integers and it has been replaced by\n    # remove_duplicates in NumPy.\n    for x in xs:\n        if x[0] < x[1] or x[2] < x[3]:\n           x[0] = x[1]\n         x[2] = x[3]\n         return unique_digits(x)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    print x\n    for x in xs:\n       if x%2 == 0:\n          new_index = [x%2 for x in xs if x not in x]\n            if new_index:\n                if new_index[0] == 0:\n                    return new_index\n                     if new_index[1] == 0:\n                        return new_index[0]\n    else:\n        return x\n    return xs", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    x = x.split()\n    items = []\n    for i, v in enumerate(x):\n       if v % 2 == 0:\n          items.append(i)\n    return sorted(set(items), key=lambda i: i[0] + i[1] % 2, reverse=False)\n\nThis is a very slow method if you try it with a large list of numbers (like the one in the original post). But this is not the point of the code in the original post. This code is meant as an illustration of two points:\n1\\. The sort() method in Python is very slow.\n2\\. The built-in set() function in Python is a very slow way to generate a set.\n\nI've been using Python for a little over 2 years now. In that time I have come to prefer list comprehensions and generators over built-ins like set(), setdiff(), xrange() and itertools. List comprehensions are particularly powerful since they are a combination of list and generator features.\n\nI have to admit that I am not familiar with list", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    x = x.split()\n    for x in x.split():\n       if x[0] == 1:\n          return []\n       else:\n          return x[1:]\n\nfrom collections import OrderedDict\n\nfrom itertools import cycle\n\ncycle(x, unique_digits, [])</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for x in xs:\n       if x == xs[0]:\n          break\n      else:\n           for y in xs[1:]:\n              if y == xs[0]:\n                    break\n    return [y]</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in x:\n        if i % 2 == 0:\n           return i\n       else:\n           return unique_digits(i - 2)\n\nThe reason this doesn't work is that you can't compare two numbers and the statement `i < 2` is never true. The same way, `i > 2` is never true.\nMaybe a better algorithm would be to use a bit-set to count how many of the numbers are even, and use it to return only those numbers.\n\nYou could also use the number of leading zeros to count how many are even.\n\nOr even just count how many of the numbers have an even number of digits.\n\nI think we should all try our hand at programming our own quick sort. I like to use it as an interview question when hiring people, and it is a really good way to understand the basics of how a computer thinks and works.\nThis code isn't quite perfect:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    a = x\n    for i in range(len(a)):\n       if a[i] % 2 == 0:\n            break\n    return [a[i], a[i+1:] for i in reversed(range(len(a) - 1)))\n\n(just in case someone else needs it, this is a python program. And the\nversion I know is for lists, but I'm pretty sure the \"for i in reversed(\nrange(len(a) - 1)))\" part is the only thing you'd have to change)\n\nThanks for the code, but I need something more efficient than brute force.\n\nI think \"brute force\" is exactly what your professor means. I haven't had\na math class in a while, but if I remember correctly, the number of\ndigits in a number, if it's a whole number, will always be a power of 2.\nAnd if it's not a whole number, then it's not divisible by any number of\ndigits.\n\nYou can't really brute-force a problem like that.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    print(\"unique_digits(\", x, \") = \", unique_digits(x))", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return x.index(0) - 1 >= 0\n\nunique_digits([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    new_digits = [x[0] for x in x]\n    for x in new_digits:\n       if x[0]%2:\n          continue\n          new_digits.remove(x)\n    return [x[0] for x in new_digits]</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return [x[i] for i in x if i % 2 == 0]\n\nI'm really not sure why this is getting voted up; it's unreadable, unidiomatic, and does a very bad job of the task at hand.\nIt's not even code that can be read in a single glance. It requires parsing a string literal before it can be understood.\n\nIt's a simple one-line function that does one thing and one thing only. It's straightforward, easy to understand, and does the job. In that regard, it is exactly the kind of code that I want to write.\n\nIn my opinion, this is not easy to understand. I was surprised to see that the line in the OP was not a comment.\n\nThe OP code is easy to understand.\nIt's easy to see what the function does, and easy to see that it does what it says it does.\nIn fact, I'd argue that this code is far easier to understand than the more idiomatic C++ or Python versions.\n\nI don't disagree with you. I'm just saying that I was surprised to see a one line function with a single variable as a valid python statement.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[0] > 0:\n       x[0] -= 1\n    elif x[0] == 0:\n       x[0] += 1\n    else:\n       x[0] = 0\n    for j in x:\n       if x[j-1] > 0:\n          x[j] = x[j-1] - 1\n          x[j-1] += 1\n          x[j] = x[j-1]\n    return x", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) > 0:\n        # Find all even digits and remove them.\n        y = x[::-1]\n        z = x[::-2]\n        x = x[::-1] - x[::-2]\n        print \"Found \" + str(len(x) - 2)\n        for x, y, z in zip(x, y, z):\n           if x % 2 == 0:\n                  break\n                    x = unique_digits(x)\n                    y = unique_digits(y)\n                    z = unique_digits(z)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for x in xs:\n    if x[0] % 2 == 0:\n       return x\n    return []\nPretty straightforward.\n\nOn a related note, there's a number of problems that seem like a good one to use recursion for, but actually aren't.\nFor example, doing the average of N numbers can be done in linear time using a formula, and doing the sum of N numbers can be done in linear time using a formula. But then there's things like N^2, which can be done in O(N log N) time using a formula, and N^3, which can be done in O(N^2) time using a formula, but can be done in O(N log N) time using recursion.\n\nHow do you do the sum of N numbers in linear time? I'm guessing you don't mean the sum of N^2 numbers but a slightly modified version of the sum of two N numbers.\n\nI can't think of a good way to express this without just writing the code, but I'll try to give a simple example.\nImagine we have a list of N numbers, each of", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return sorted(x, key=lambda x: x.pop()[0], reverse=True)\n\nNot that I think there's a faster way, but I would've used difflib's difftolower on the input:\n\nIndeed, that would have been much faster.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x))\nI'd love to see a trickier example: for example, return a list of all the unique numbers that have at most one 2.\n\nWhat's a '2'?\n\nthe base-10 logarithm of 2.\n\nRight. And what's a 'logarithm'?\n\nI have no idea, but I did have to Google it.\n\nThat's the problem: we're not talking about math, we're talking about programming. I don't think anyone here is going to claim that the '2' in 'logarithm' is some kind of obscure operator, but I bet that most of us would have problems writing a program to generate a list of numbers that have no '2's in them. It's trivial to find one number that has no '2's in it, but it's not so easy to generalize that.\n\nI disagree. I don't think this is an obscure operator at all. It's a common operation (that was probably taught in grade school), that any programmer should know about.\n\nThat's pretty much my point. Any programmer should know about it, but I bet that most programmers don't", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [(x[0] + x[1] for x in x if x[1] % 2 == 0) if x]\n\n(1) I never claimed to have invented it.\n(2) I didn't say it was original.\n(3) It's not a \"new\" list-sorting algorithm.\n(4) Yes, I did use it on a real life problem.\n(5) I was working with an existing list-sorting algorithm, and I had a\nneed to remove even-numbered items from the list.\n(6) I didn't have the time to learn a new algorithm.\n(7) This algorithm was easy to learn.\n(8) That's how I came up with the idea.\n(9) I didn't say it was fast.\n(10) Yes, I'm a newbie. But I'm not stupid.\n(11) Yes, it's a toy problem.\n(12) And I wasn't suggesting this algorithm be used in production.\n(13) Yes, I've been called a lot worse than a newbie.\n(14) And that's just this thread.\n(15) I'm", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 0:\n        return []\n    else:\n        return sorted(x[1:], key=lambda x: x[2:])\n\nOne thing I would add to the original question is that he should consider writing a function that will do the actual sorting, since he wants to see how other people are writing their code and compare it with his.\n\nI would agree, but as a counterpoint, I feel that writing it by hand forces one to think about the tradeoffs. It's a simple problem, but it's also an interesting one, so I would much rather see the OP try to figure it out.\n\nHow about using the \"in operator\"? (2^(i%10)) % 10 == 0\n\nI was thinking about this, but it's not any different from simply checking if the numbers are odd or not.\n\nI thought of a way to do it in one line, but I'm not sure if it's the best way. I'm going to go with it though.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return [x for x in x if x[0]!= 0]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in range(len(x) - 1):\n        if x[i]%2:\n            break\n        return [x[i], x[i+1]]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    sorted_list = sorted(x.index)\n    return sorted_list[x.index % 2 == 0]\n\npython-2.4.4/lib/python2.4/sort.py</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for x in xrange(len(x)):\n       if x[0] == 0:\n          return x\n    return x\n\nyield x\n\nIn python, it's just x[::-1]</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for x in xrange(0, len(x)):\n        if x % 2 == 0:\n           return x\n    else:\n           return []\n    return x</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return [x[i] for i in x if x[i] % 2!= 0]\n\nI'm curious. Why is this useful?\n\nIt's a good exercise in building a utility function. It takes a list and\nreturns a sorted list of the elements that have no even digit.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[i] for i in x if i%2==0]\n\n>>> unique_digits([152, 323, 1422, 10])\n[152, 323, 1422, 10]</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    print x\n    for y in x:\n        if y % 2 == 0:\n           #Don't take evens.\n            #A `while` loop is overkill for this simple task.\n            #\"next\" is a function that returns the index of the next \n    #element in the given list.\n            #So we can write `next(x)`.\n            #The if statement is used here so we can \n            #avoid the case when `y` is 0.\n            #The `if` statement only runs when `y` is not 0.\n            #If it's zero, we don't want to take it, so we have to \n             #return `", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x in [0,1,2,3]:\n       return []\n    else:\n       return x[0:2]\nNote that if you want to do this with a list of floats, you have to explicitly cast it to an integer.\n\nI also wrote the following in python to solve this problem:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 0:\n       return []\n    else:\n       a = range(len(x)-1, len(x))\n       for i in range(0, len(x)):\n          if a[i] % 2 == 0:\n              break\n              return a[i]\n\nI think this is the correct answer.\n\nAs a non-programmer, I would also say this is the correct answer. However, I can see where the OP is coming from. The explanation given is a little hard to follow, while the other is clear and to the point.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return x.index(0, x.count(1) - 1)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def unique_digits_impl(list):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n    Note: Returned list should be sorted in increasing order.\n   \n    For example:\n    >>> unique_digits_impl(unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits_impl(unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    def unique_digits_impl(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that doesn't any even digit.\n    Note: Returned list should be sorted in increasing order.\n   \n    For example:\n    >>> unique_digits_impl(unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def sorted_unique_digits(x):\n    \"\"\"Sorted version of unique_digits\"\"\"\n    digits = sorted(unique_digits(x))\n    return digits\n\nI am not a python expert, but this code seems to be doing a lot of unnecessary work. Wouldn't it be simpler to just sort the list of positive integers and then return only those that have no even digit?\n\nYou're right. The original code is probably from a textbook. The code has an extra layer of indirection to enforce the additional requirement that the list be sorted.\n\nIn Python, a list is already a sorted list, so this is unnecessary.\n\nThis works in Python 3, but only in the particular case where the array is known to be sorted. (You'd need to use sort() to do that.)\n\nI assume that this is Python 2?</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in x:\n       for j in i:\n         if i % 2 == 0:\n            return j\n    return []</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    if x[0] == 0:\n        return [x[0], x[1] for x in x]\n    else:\n        return [x[0] for x in x]</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x, key=lambda n: n%2==0)\nThere's no need to define a function just for this one line of code.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return list(x)\n    # This is for a for loop to iterate\n    def main():\n        for x in unique_digits(range(5)):\n             print(x)\n             print(x % 2 for x in range(5))\n\nOutput\n\n1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1"]]