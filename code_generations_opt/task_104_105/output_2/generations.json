[["def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in x:\n        if x[i] % 2 == 0:\n            return x[i]\n    return []\n\nThat's a pretty straightforward implementation. I think it's even a little bit more readable than the first one.\n\nThanks for the suggestion, it is more readable.\n\nI like the first one, I just don't like the fact that it's not a generator.\n\nThe second one is not a generator either.\n\nIt is, it's just not a very good one.\n\nI don't think it is.\n\nIt is, it's just not a very good one.\n\nIt is, it's just not a very good one.\n\nI don't think it is.\n\nIt is, it's just not a very good one.\n\nIt is, it's just not a very good one.\n\nI don't think it is.\n\nIt is, it's just not a very good one.\n\nIt is, it's just not a very good one.\n\nI don't think it is.\n\nIt", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    #", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    x = x\n    for i in x:\n       if i % 2 == 0:\n          return i\n    return x\n\nfor i in unique_digits(range(10)):", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in x:\n       if i % 2 == 0:\n          return [i]\n    return []", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for x in xrange(len(x)):\n        if x[0] == 0:\n           return x[1:]\n    else:\n           return x\n    return x", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x, key=lambda x: x[1:])", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # If x is a list of numbers, then x must be sorted\n    if len(x) == 0:\n        return []\n    else:\n        return x.sort()", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in x:\n       if x[i] % 2 == 0:\n          return x[i]\n    return []\nYou might want to do a quick test to see if the list is already sorted.\n\nI'd also add that the original question was about sorting _numbers_, not _strings_, so it should be \"return a sorted list of all elements that doesn't any even _digit_ \"\n\nThis is the most efficient way to do it, in terms of memory usage.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[0] == 0:\n        return []\n    elif x[0] == 1:\n        return x[1:]\n    elif x[0] == 2:\n        return x[2:]\n    elif x[0] == 3:\n        return x[3:]\n    elif x[0] == 4:\n        return x[4:]\n    elif x[0] == 5:\n        return x[5:]\n    else:\n        return x[:]\n\nYou're probably aware, but this is a very poor algorithm.\nThe input is a list of positive integers, but your algorithm doesn't take into account the sign.\n\nYes. That's the reason I mentioned that returned list should be sorted in increasing order.\n\nYou can sort in-place with a single call to the built-in sort function.\n\nI agree. But I wanted to understand", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    sorted_list = []\n    for x in xs:\n       if x % 2 == 0:\n          sorted_list.append(x)\n    return sorted_list\n\nI think this is a bad example. The author says \"Note: Returned list should be sorted in increasing order.\" The author should have done the test to make sure it was.\n\nI agree with you. I'm not sure if I should have tested this.\n\nI'm sure you should have.\n\nI would have done a test, but I wouldn't have put it in the example.\n\nI agree with you. I'm not sure if I should have done the test.\n\nI'm sure you should have.\n\nI would have done a test, but I wouldn't have put it in the example.\n\nI agree with you. I'm not sure if I should have done the test.\n\nI'm sure you should have.\n\nI would have done a test, but I wouldn't have put it in the example.\n\nI agree with you. I'm not sure if I should have", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[0] == 0:\n       return x\n    x = x[1:]\n    if x[1] == 0:\n       return x\n    x = x[2:]\n    if x[2] == 0:\n       return x\n    x = x[3:]\n    if x[3] == 0:\n       return x\n    return [x[4:]]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    sorted_list = []\n    for i in x:\n        if i % 2 == 0:\n            sorted_list.append(i)\n    return sorted_list", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[0] for x in x if x[0] % 2 == 0]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in x:\n        if i % 2 == 0:\n            return i\n        elif i % 2 == 1:\n            return i\n    return []", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def __len__(self):\n    \"\"\"Return the number of elements in the list.\n    >>> len(unique_digits([1, 2, 3, 4, 5, 6, 7, 8, 9])):\n    8\n    >>> unique_digits([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    []\n    \"\"\"\n    return len(self)\n\nIt's not a bad solution, but it's not a good solution either.\nIt's not a bad solution because it does what the original poster asked for:\n\n>>> unique_digits([1, 2, 3, 4, 5, 6, 7, 8, 9])\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nIt's not a good solution because it's not a good solution.\nIt's not a good solution because it doesn't solve the original poster's real problem.\nThe real problem is that the original poster wants a function that:\n\n1) Takes a list of positive integers as input\n2) Returns", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda x: x[0], reverse=True)\n\nI don't know why this is getting downvoted. I think it's a pretty good answer.\n\nIt's probably being downvoted because it's a bit misleading. I think the OP wants to do something like:\n>>> unique_digits(list(range(100)))\n[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 61, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81, 83, 85, 87, 89, 91, 93, 95, 97, 99]\nand not:\n>>> unique_digits([1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return set(x.split() for x in sorted(x))", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda x: x[1], reverse=True)\nI'm not sure this is a good solution. It's only guaranteed to work if the input is sorted. If you have a list like this:\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\nyou can't use this function to get a list of the unique non-even numbers.\n\nThat's true, but it's not the only way to do it.\n\nTrue. I just wanted to point out that it's not a \"guaranteed\" solution.\n\nI've always found it a bit odd that there isn't a standard library function to do this.\n\nThe standard library has a function to do this: it's called unique() and it's in the \"itertools\" module.\n\nAha, there it is. I had forgotten about the itertools module. Thanks!\n\nI'm not sure why you wouldn't just use the built-in sorted() function to do this.\n\nsorted() doesn't guarantee that the result is sorted, nor does it guarantee that the result is unique.\n\nIt's", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in range(0,len(x)):\n        if x[i] == 0:\n            return x[i]\n    return []", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    sorted_digits = []\n    for i in x:\n       if i % 2 == 0:\n          sorted_digits.append(i)\n    return sorted_digits", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 1:\n        return x\n    return [x[0] for x in x if x[0]!= 0]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in x:\n        if i % 2 == 0:\n           yield i\n\nThis is not a Pythonic way of doing it, and you're doing it wrong.\n\nI'm sorry, but I don't understand what you mean. I'm quite new to Python.\n\nPython is a whitespace-sensitive language. Whitespace matters.\nHere's an example of something that is wrong:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x == [] or x[0] == 0:\n        return []\n    for x in x:\n        if x[0] == 0:\n           return x\n            x = x[1:]\n    return x\n\nI think you mean x[0] == 1 in the first case, not 0.\n\nYes, you're right.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in range(len(x)):\n       if x[i] % 2 == 0:\n           return x[i]\n    return [x[i] for i in range(len(x) - 1)]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[0] == 0:\n       return [x[0] for x in x]\n    return [x[1:] for x in x if x[1]!= 0]\n\nThat's not how you sort.\n\nI was just trying to be silly.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in x:\n       if i % 2 == 0:\n          return i\n    return []\n    # Examples\n    >>> unique_digits([1, 2, 3, 4, 5, 6])\n    [1, 2, 3, 5, 6]\n    >>> unique_digits([1, 2, 3, 4, 5, 6, 7, 8])\n    [1, 2, 3, 5, 6, 7, 8]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    unique_digits = lambda x: x.pop()\n    for i in x:\n       if x[i] == 0:\n          unique_digits(x[i-1], x[i-1])\n          x[i] = x[i-1]\n    return unique_digits(x)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for x in xs:\n       if x[0] == 0:\n          return x\n    return xs\nI'd rather use:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[i] for i in x if i % 2 == 0]</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    def odd_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all\n    elements that has an odd digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> odd_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> odd_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n\n    return unique_digits(x).sort()\n\nI like the fact that the author of the post doesn't use the word \"list\" anywhere.\n\nI had to read that a couple times to understand it.\n\nThis is why I love Python.\n\nIn case you missed it, this is a joke.\n\nI hope the author is joking.\n\nI hope you are joking.\n\nThis is a joke.\n\nI love Python.\n\nI hope you are joking.\n\nI hope you are joking.\n\nI hope you are joking.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[i] for i in range(len(x) - 1)]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def get_uniques(x):\n    \"\"\"Return a list of unique elements from a list of positive integers.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    n = len(x)\n    sorted_digits = []\n    for i in x:\n        if i % 2 == 0:\n            sorted_digits.append(i)\n    return sorted_digits", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    unique_digits = [x[i] for i in range(len(x)) if x[i] % 2 == 1]\n    return unique_digits\n\nNote that this function has a space leak, since it allocates a new list for every call.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x == []:\n        return []\n    return [x[1:] for x in x if x[1] % 2 == 0]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x, key=lambda x: x[1] if x[0] == 0 else x[-1] for x in x)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 1:\n       return x\n    else:\n       return unique_digits(x[::-1])", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 1:\n        return x\n    elif len(x) == 2:\n        return unique_digits(x[1], x[2])\n    else:\n        return []\n    #if __name__ == '__main__':\n        unique_digits(range(10))", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # Return all the odd elements.\n    for i in x:\n       if i % 2 == 0:\n          yield i\n    return []\nThat's not a very good example, since there are no even numbers in the list.\n\nIt is a good example. The author wants to know what is the list of odd numbers, but if you want to know the list of even numbers you just have to change the function to return the list of even numbers.\n\n_\"It is a good example. The author wants to know what is the list of odd numbers, but if you want to know the list of even numbers you just have to change the function to return the list of even numbers.\"_\nYes, but the fact that it's a good example doesn't make it a good example. It's still a bad example.\n\nThis is a bad example.\n\nI think this is a good example.\n\nThis is a bad example.\n\nThis is a good example.\n\nThis is a bad example.\n\nThis is a good example.\n\nThis is a bad example.\n\nThis", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return x.sort()", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[0] == 1:\n       return [x[0], x[1], x[2],... x[x.length-1]]\n    else:\n       return [x[0], x[2], x[3], x[x.length-1]]\n\nI don't understand.\n\nIt's a bit confusing.\nIt's really just a function to return the last element of a list.\n\nSo what is the use case for this?\n\nI'm not sure I understand the question.\n\nI guess I don't understand the utility of this function.\n\nIt's a bit of a contrived example. The idea is that you have a list of numbers and you want to keep track of the numbers that don't have an even digit.\n\nIt's a bit confusing to say \"keep track\" when the function returns the list of non-evens.\n\nI'm not sure what you mean.\n\nI think what he's saying is that if you have a list of even numbers, you can just check the last element to see if it's even.\n\nI think the", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 0:\n        return []\n    for i in x:\n        if i % 2 == 0:\n           return [i]\n    return [x[i] for i in x]\n\nThat's the same as the first example in the article, but with more typing.\n\nI don't see how it is the same.\n\nIn the first example, the list is sorted in ascending order. In the second, the list is sorted in descending order.\n\nThis is a better article than the one linked to.\n\nI think the code is a little hard to read, but the point is still there.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x.split(','), key=lambda x: x[1:], reverse=True)\n\nThis is a great example of a \"pythonic\" solution. The problem was stated\nwell and the solution was simple and elegant.\n\nAnd it's also a great example of a problem that would be very difficult\nto solve in a language like C, and would require the use of a library\nlike libc. It's also an example of a problem that would be very easy\nto solve in a language like Java, and would require the use of a library\nlike Collections.\n\nI don't think you can say that. I think this problem is equally\n\"easy\" in both languages. It's just that in Python, the solution\nis more concise and elegant.\n\nI think this is a great example of how Python is a great language for\nsolving certain types of problems.\n\nI agree. I think it's a great example of a problem that is easier to\nsolve in Python than in Java.\n\nSo, if you were to ask me what is the best language for solving certain\ntypes of problems, I would say that Python is a good candidate for", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    sorted_list = []\n    for i in x:\n        if i%2 == 0:\n            sorted_list.append(i)\n    return sorted_list\n\nI'm not sure if this is a trick question, but the answer is that you can't.\nThe reason is that you are assuming that all of the elements of the list are integers. In reality, there is no guarantee that this is the case. You might have a list of integers and a list of floating point numbers, for example.\n\nI think you can't, unless you can prove that the list is all integers, which is impossible.\n\nYou can't, but you can write a function to do it for you.\n\nYou can't, because you don't know what the list is.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 0:\n       return []\n    for i in x:\n       if i % 2 == 0:\n          return x[i]\n    return [x[i]]\n\nIf you want to remove all the even numbers, you can use the following:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # take out the first element\n    if len(x) == 1:\n       return [x[0]]\n    else:\n       for i in x:\n          if i % 2 == 0:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[0]!= 0:\n       return [x[0], x[1:] + x[2:] for x in x]\n    else:\n       return [x[0], x[1:] + x[2:] for x in x]\n    def unique_digits_in_range(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all\n    elements that doesn't any even digit in the range of x.\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits_in_range([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits_in_range([152, 323, 1422, 10])\n    []\n    \"\"\"\n    if x[0] < x[1] and x[0] >= x[1] - 1:\n       return [x", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[0] == 0:\n       return []\n    else:\n       return x[1:]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 0:\n        return []\n    for x in x[::-1]:\n        if x[0] == 0:\n             return x\n             if x[1] == 0:\n               return x[::-1]\n    return x\n\nI don't see how this is a problem. The first example is a list of three elements, all of which are in the list returned by the function. The second example is a list of two elements, none of which are in the list returned by the function.\n\nThe first example is a list of three elements, all of which are in the list returned by the function. The second example is a list of two elements, none of which are in the list returned by the function.\nYou are right, I am wrong. I was thinking that the function should return the list without the duplicates, not the list of all elements that are not in the list.\nThanks", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in range(len(x)):\n        if x[i] == 0:\n            return x[i]\n         else:\n              return unique_digits(x[i] - 1)\n    return unique_digits(x)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # This is a list of positive integers.\n    # In this case, we are going to sort the list in ascending order.\n    #\n    for i in range(len(x)):\n        if x[i] % 2 == 0:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    def unique_digits_max(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of \n    all elements that hasn't any even digit and the highest value.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits_max([15, 33, 1422, 1])\n    [15, 33, 1422]\n    >>> unique_digits_max([152, 323, 1422, 10])\n    [1422, 10]\n    \"\"\"\n\n    def unique_digits_min(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of \n    all elements that hasn't any even digit and the lowest value.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits_min([15, 33, 1422, 1])\n    [15, 33]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set([x[i] for i in x if x[i] % 2 == 0]))\nThis is not a Pythonic way to write it.\nA Pythonic way would be:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x, key=lambda x: x[1])", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x, key=lambda x: x[1])\n    # or:\n    return sorted(x, key=lambda x: x[1] > x[2])\n\nI'm not sure what you are trying to do here, but you can do this in O(n) without sorting.\n\nIt's a lot more difficult to do that, though.\n\nI'm not sure I understand the motivation for this.\n\nI'm guessing the motivation is to find the first element in a list of integers that is not divisible by 2.\n\nYes, this is a problem I encountered during my first internship. It's a pretty common one in programming contests.\n\nAh, I see. I haven't encountered that problem, but I can see how it could be useful.\n\nI've never seen this before, but I like it.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[1:] for x in x if x[0] % 2 == 0]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    def unique_even_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all\n    elements that has any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_even_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_even_digits([152, 323, 1422, 10])\n    [10, 152, 323]\n    \"\"\"\n\n    def even_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all\n    elements that has any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> even_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> even_digits([152, 323, 14", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n         return sorted(set(x) if x in range(1, 10))\nI'm not sure about this code, but I think it's the same as the code in the article.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for x in xrange(0, len(x)):\n       if x[0] == 0:\n          return x\n       else:\n           return [x[1:] if x[1] > 0 else x[0]]\n\nI like how they're using the ternary operator to check if the first digit is zero.\n\nI don't. It's a bad habit.\n\nWhy?\n\nBecause it's a matter of style, and there is no general agreement on the matter.\n\nI'd be interested to hear why you think it's a bad habit. I think the ternary operator is a great tool.\n\nIt's a great tool, but it's also a dangerous tool.\n\nAnd I'd like to know why you think it's dangerous.\n\nIt's a tool that can be misused.\n\nAnd I'd like to know why you think it can be misused.\n\nIt's a tool that can be misused.\n\nAnd I'd like to know why you think it can be mis", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[0] for x in x if x[0] % 2 == 0]</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda x: x[:3])\n\nIt's easy to implement a function that will do this for you:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda x: x[0]!= 0)\n\nWell, if you're going to make an O(n log n) algorithm, make it at least O(n) (and the O(n log n) algorithm is already a well known one, so there's no point in not using it).\n\nO(n log n) is O(n) when n is small.\n\nSo is O(n) (and O(1)).\n\nNo, O(n) is not O(1) when n is small.\n\nYes it is.\n\nNo, it isn't.\n\nThe list comprehension is very nice, but I have a hard time seeing the use of the lambda function.\n\nI think the author is just showing off.\n\nI think this is a good example of a simple use of lambda.\n\nIt's not a good example of a simple use of lambda. It's a good example of a simple use of a list comprehension.\n\nI think the author is just showing off.\n\nI think this is a good example of a simple use of lambda.\n\nIt's not a good example", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n        return [x for x in x if x[0]!= 0]\n\nI'm not sure what the point of this is. The first example can be written as\nunique_digits([15, 33, 1422, 1])\n[1, 15, 33]\nand the second example can be written as\nunique_digits([152, 323, 1422, 10])\n[152, 323, 1422, 10]\n\nThe first example is not equivalent to the second one. The first one is a list of numbers, while the second is a list of tuples of numbers.\n\nIt's a list of numbers in the sense that it's a list of values that can be passed to a function that expects a list of numbers, not a list of values that can be passed to a function that expects a tuple of numbers.\n\nI see what you mean, but I think you'll find that the \"list of values\" that can be passed to a function that expects a list of numbers is a list of tuples.\n\nInteresting! I was just thinking about this problem the other day. I decided to implement it using a recursive function that uses the rec", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[i] for i in x if x[i] % 2 == 0]\nI don't see what is so difficult about this.  It is a good exercise in\ndetermining what a function should do.  You can look at the source code\nand see how it works.\n\nI think the point is that the question is not about what the function does, but about how the function does it.\n\nI think the question is about both.\n\nI think the question is about what the function does, not how.\n\nNo, it is about how the function works, not what.\n\nI think the question is about what the function does, not how.\n\nNo, it is about how the function works, not what.\n\nI think the question is about both.\n\nI think the question is about what the function does, not how.\n\nNo, it is about how the function works, not what.\n\nI think the question is about both.\n\nI think the question is about what the function does, not how.\n\nNo, it is about how the function works, not what.\n\nI think the question is about", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x, key=lambda x: x[1] < x[0])", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def sorted_unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that doesn't any even digit. Note: Returned list should be \n    sorted in increasing order.\n    \n    For example:\n    >>> sorted_unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> sorted_unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    for x in xs:\n       if x[0] == 0 or x[0] == 1:\n          x = x[0:]\n          if x[1] == 0 or x[1] == 1:\n              x = x[1:]\n            if x[2] == 0 or x[2] ==", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 1:\n        return x\n    else:\n        return x[::-1]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for x in xs:\n       if x % 2 == 0:\n          return [x]\n    return []", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return (x[0] if x[0] == 0 else x[2:] + x[1:])\n\nI don't think that's the best way to do it.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x, key=lambda x: x[0]!= 0)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x, key=lambda x: x[1]!= x[2])\n\nI don't understand why this was downvoted.\n\nBecause it's not a good example. If you read the comments on the page you'll see that the function is actually supposed to return a list of all positive integers that don't have any even digit, not the integers themselves.\n\nI know. I was just making a joke.\n\nI like the simplicity of the solution, but I don't see how this is \"unique\".\nFor example, if the input is [1, 3, 5, 9], the output is [1, 3, 5, 9, 3, 5, 9, 9].\n\nThe implementation of the function is also not unique. I've seen another solution that uses two nested for loops and an extra comparison:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return set([x for x in x if x % 2 == 0])", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x, key=lambda x: x[0] > x[1])\n\nThat's not what I get. It returns the empty list for the first example, and the second example returns [1422, 10, 323].\n\nYup, you're right. I've modified the code to return the right list.\n\nI'd have to write a lot more code to get this to work in the way I want it to.\n\nI don't get it. What's the point of this function?\n\nThe function is supposed to return a sorted list of all the elements in the list that doesn't have any even digit.\n\nWhy?\n\nI was trying to write a code that generates a list of all the primes that are not divisible by any even number.\n\nDid you try\n>>> primes.filter(isprime, isodd=False)\n\nI did, but that gives me a list of all the odd numbers. I need a list of all the primes that are not divisible by any even number.\n\nI'm not sure why you need a list of all the primes that are not divisible by any even number.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # Note that we need to iterate over all elements, since we have no idea\n    # if any of the elements is a list\n    for x in xs:\n        if x[0] == 0:\n            return x\n            else:\n             return x[1:]\n    return x\n\nThis is pretty easy to do in C. I'll leave the Python translation to someone else.\n\nThe solution in Python is the same as in C:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for x in xs:\n       if x[0] == 0:\n          return x\n       else:\n          return x[1:]\n\nThis is a great idea. I'm curious about how you got the idea to write this.\n\nI've seen the same idea used to generate passwords.\n\nYes. I've seen this used in a few different places, and I've always thought it was a great idea.\n\nIt is a great idea, but I'm not sure how useful it is for passwords.\nI would be more likely to use it for generating a secret key for an encryption algorithm.\n\nIt's a great idea for passwords if you want to avoid reusing the same password everywhere.\n\nOr if you want to avoid being able to easily remember your passwords.\n\nThis is a great idea, but I'm not sure how useful it is for passwords.\n\nI would be more likely to use it for generating a secret key for an encryption algorithm.\n\nIt's a great idea for passwords if you want to avoid reusing the same password", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 1:\n       return x\n    else:\n       return unique_digits(x[0], x[1:] + x[2:] + x[3:] + x[4:] + x[5:] + x[6:])", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # Function that returns all even digits.\n    def even_digits(x):\n    \"\"\"Return all even digits in a list of positive integers.\n    >>> even_digits([15, 33, 1422, 1])\n    [1, 5, 3, 1]\n    >>> even_digits([152, 323, 1422, 10])\n    [1, 5, 3, 2]\n    \"\"\"\n    return unique_digits(x)\n    # Function that returns all odd digits.\n    def odd_digits(x):\n    \"\"\"Return all odd digits in a list of positive integers.\n    >>> odd_digits([15, 33, 1422, 1])\n    [3, 5, 1, 7]\n    >>> odd_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    return unique_digits(x)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def __next__(self):\n    \"\"\"Return the next element in the sorted list.\n    >>> unique_digits(unique_digits([15, 33, 1422, 1]) + [152, 323, 1422, 10])\n    [1, 15, 33]\n    >>> unique_digits(unique_digits([152, 323, 1422, 10]) + unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    \"\"\"\n    return self[-1]\n\nThere's a lot of good stuff in there, but I think that the most important is the use of __next__.\n\nThe use of __next__ is a bit unfortunate. It's not that it's a bad function, but that it's not what the author of the article wants. He wants to return the next unique element. What __next__ does is return the next item in the list, which is not necessarily unique.\n\nActually, I want to return the next item in the list, which is the next unique item.\n\nThe thing is,", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda x: x[1] == 0)\n\nI'm not sure what the point of this is. I guess you could use it to\ncreate a list of all prime numbers that are not divisible by 2, 3, or 5.\n\nIt's an interesting exercise, and a good way to learn about sets, but\nI don't know what practical use it would have.\n\nI use this quite a bit. It is a great way to find prime numbers that are\nnot divisible by 2, 3, 5, 7, or 11.\n\nWhy not just use a list comprehension?\n\nI don't know about Python, but in Ruby you can't do a list comprehension that returns a list of tuples.\n\nI'm not sure what you mean by that. Could you elaborate?\n\nI'm not the parent, but I think he means that you can't do this in Ruby:\n[(x, x) if x % 2 == 0]\n\nAh, I see.\n\nThis is a very bad solution, which will be slow.\n\nI think that it is a good solution for the problem that the author", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda x: x[1], reverse=True)\nI don't know Python, but I'm pretty sure that's not how you do it.\n\nI am pretty sure that's how you do it. It's using a builtin function called sorted() which is part of the standard library.\n\nYes, but it's not the right way to do it.\n\nHow so? It's not the most efficient implementation, but it's correct.\n\nThe algorithm is correct, but the code is not.\nThe algorithm says:\n\"Given a list of positive integers x. return a sorted list of all elements that hasn't any even digit.\"\nThe code says:\n\"Given a list of positive integers x. return a sorted list of all elements that isn't even.\"\n\nAh, I see what you mean. I think you're confusing the use of the word \"isn't\" with \"hasn't\".\n\nI know, but the author of the code doesn't.\n\nI am not sure I understand what you're trying to say. Are you saying that the author of the code accidentally wrote \"isn't\" instead of \"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[0] == 0:\n       return []\n    else:\n       for x in x[1:]:\n          if x[1] == 0:\n                  return x\n                  else:\n                    if x[2] == 0:\n                         return x\n                        else:\n                           if x[3] == 0:\n                             return x", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[i] for i in x if x[i] % 2 == 0]\nI think that you want the second argument to be the list of numbers, not the list of integers.  (I'm not sure what the difference between integers and numbers is, but I think that integers are the actual numbers, while numbers are the integers with the decimal point removed.)\n\nThanks, I corrected it.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # Check if any digit is even\n    # Returned list should be sorted in increasing order\n    if x[0] == 0:\n        return []\n    else:\n        return x[1:]\n\nThat's pretty cool! I didn't know you could do that in Python.\n\nI'd like to see how long it takes for a python programmer to implement this using the standard library.\n\nI'd like to see how long it takes for a python programmer to implement this using the standard library, without using a list comprehension.\n\nA list comprehension is a standard library construct.\n\nI think he meant without using a list comprehension.\n\nI think he meant without using a list comprehension _that is not a standard library construct_.\n\nI think he meant without using a list comprehension _that is not a standard library construct, using only the standard library_.\n\nI think he meant without using a list comprehension _that is not a standard library construct, using only the standard library, while recursing_.\n\nI think he meant without using a list comprehension _that is not a standard library construct,", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 1:\n       return x\n    elif len(x) == 2:\n       return x[-1]\n    else:\n       return x[-1] + [x[0] % 2]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def sorted_unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all\n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> sorted_unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> sorted_unique_digits([152, 323, 1422, 10])\n    [10, 1422, 323]\n    \"\"\"\n    for x in sorted(unique_digits(x))\n        yield x\n\nI am not sure if I am doing this right.\n\nI am not sure if I am doing this right.\n\nI am not sure if I am doing this right.\n\nI am not sure if I am doing this right.\n\nI am not sure if I am doing this right.\n\nI am not sure if I am doing this right.\n\nI am not sure if I am", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[0] == 0:\n        return [x[1], x[2],..., x[n-1]]\n    else:\n        return [x[1], x[2],..., x[n-1], x[n]]\n\nThis is a fun exercise, but I'm not sure it's a good way to learn Python.\n\nThe point of the exercise is to understand the range function.\n\nAnd that's a good point. But I would argue that the range function is so simple that there's no reason to obfuscate it by using a list comprehension.\n\nI think this is a great way to learn Python. I've been working with Python for a few years now, and I still find myself falling into list comprehensions when I should be using a for loop or a function. I think it's because list comprehensions are so easy and intuitive.\n\nI agree, I think this is a good way to learn Python, but I wouldn't say it's the only way. I've been using Python for years and I still find myself falling into list comprehensions when I should be using a", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    a = x.split()\n    return sorted(a, key=lambda x: x[1]==0)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 1:\n       return x\n    elif len(x) == 2:\n       return unique_digits(x[0], x[1])\n    elif len(x) == 3:\n       return unique_digits(x[0], x[1], x[2])\n    elif len(x) == 4:\n       return unique_digits(x[0], x[1], x[2], x[3])\n    else:\n       return unique_digits(x[0], x[1], x[2], x[3], x[4])\n\nThis is not a particularly good way to sort a list.\n\nYou're right. But it's not a bad way either.\n\nThere's a lot of ways to sort a list that are not particularly good ways.\n\nMaybe.\n\nI'm not sure about the semantics of the last case, but otherwise it seems to work.\n\nI like the code. It's", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def list_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all\n    elements that doesn't any even digit.\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> list_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> list_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    return [x[0] for x in x if x[0] % 2 == 0]\n\nI like that. It's a nice, simple example.\n\nI'm not sure what the point is, though.\n\nIt's a simple way to determine if a list of integers contains any even-\nnumbered digits.\n\nIt seems like a trivial problem that can be solved with a single line of code.\n\nYes, but it is nice to have it in a library.\n\nI'm not sure I agree.\n\nWhat about the following use case:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[0] == 0:\n        return []\n    for i in x:\n        if x[i]!= 0:\n            break", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[i] for i in x if x[i] % 2 == 0]\n\nI'm not sure what the point of this is.\n\nIt's the first exercise in the book \"How to solve it\", by Polya.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    x = [x[0] for x in x]\n    return x[:x[0]]\nThat's some code I wrote a few years ago. I was surprised it worked.\n\nIf you want to be a bit more efficient, you can use the fact that the list is sorted (and remove the list.sort() call):", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    sorted_list = []\n    for i in x:\n        if i % 2 == 0:\n            sorted_list.append(i)\n    return sorted_list\n\nI'm not sure what the point of this is. It's not any more efficient than just doing:\nfor i in x:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n         # The list to check.\n         x = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n         return sorted(x, key=lambda x: x[1], reverse=True)\n\nI don't know python, but is there a way to do this in a loop with a fixed length?\nI can think of a way in C, but it's ugly and not very pythonic.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # Take the first element of the list x\n    # and remove all even digits from it.\n    even_digits = []\n    for i in range(len(x)):\n        if x[i] % 2 == 0:\n           even_digits.append(x[i])\n          x[i] = x[i] % 2\n    return even_digits</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n        return set(x)\n\nThe last example is the one I would have expected.\n\nIt's a really bad example, but it illustrates the problem.\n>>> unique_digits([15, 33, 1422, 1])\n[1, 15, 33]\n>>> unique_digits([152, 323, 1422, 10])\n[]\n>>> unique_digits([15, 33, 1422, 1, 10])\n[1, 15, 33, 10]\n\nAh, I see.\n\nI would expect this:\n>>> unique_digits(set([15, 33, 1422, 1])[::-1])\n[15, 33, 1422, 10]\n\nI would expect this:\n>>> unique_digits(set([15, 33, 1422, 1])[::-1])\n[15, 33, 1422]\n\nI would expect this:\n>>> unique_digits(set([15, 33, 1422, 1])[::-1])\n[15, 33, 1422, 10]\n\nI would expect this:\n>>> unique_digits(set([15", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x.split(' ')[1:], key=lambda x: x[0])", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 0:\n        return []\n    for i in range(1,len(x)):\n        if x[i] % 2 == 0:\n             return x[i]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return x.pop(0).pop(0)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n         for i in x:\n           if i % 2 == 0:\n                return [i]\n         else:\n                return [i]\n\nHow can I implement this in python? I'm trying to do this in Python 3.\n\nYou could do it with a list comprehension, and then a list comprehension to sort the list.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in x:\n        if i % 2 == 0:\n            return i\n    return []\n\nThis is a classic example of an algorithm that is completely wrong and\nshould never be used.\nThe problem is that it's not guaranteed to terminate, even if the\ninput is empty. If it's given an input with no even numbers, it\nwill never terminate.\nIn addition, it's not even clear that it will terminate if the input\nhas at least one even number.\nThe reason is that the loop condition (i % 2 == 0) is not\nguaranteed to be true for all i. If you have a list of even numbers\nand one odd number, then the loop will never exit.\nThe correct solution is to use a proper sorting algorithm like\nquicksort.\n\nI agree that this is not a good solution. However, the problem is not\nthat it might not terminate. The problem is that it will return an\nincorrect result.\nThe algorithm should return the list of numbers that are not divisible by two, not the list of numbers that are not div", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) > 0:\n        return [x[0], x[1], x[2], x[3]]\n    else:\n        return []\nThis doesn't work if x is not a list.\n\nI'm not sure what you mean. x is a list in both of the examples you gave.\n\nSorry, I'm not a python programmer.\nI thought x was an int.\n\nNo worries. I'm not a python programmer either. I just wrote it in python.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x, key=lambda x: x[0] % 2 == 0)\n\n>>> unique_digits([15, 33, 1422, 1])\n[1, 15, 33]\n>>> unique_digits([152, 323, 1422, 10])\n[]\n>>> unique_digits([15, 33, 1422, 2])\n[1, 15, 33, 2]\n>>> unique_digits([152, 323, 1422, 2])\n[152, 323, 1422]\n>>> unique_digits([15, 33, 1422, 3])\n[15, 33, 1422]\n>>> unique_digits([152, 323, 1422, 3])\n[152, 323]\n>>> unique_digits([15, 33, 1422, 4])\n[15, 33, 1422, 4]\n>>> unique_digits([152, 323, 1422, 4])\n[152, 323, 1422]\n>>> unique_digits([15, 33, 1422, 5])\n[15, 33, 1422, 5]\n>>> unique_digits([152, 323, 1422", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda x: x[0]!= 0)\n\nWhy not just use the built in sorted function?\n\nThe built-in sorted function requires a comparison function, which is slow if you're sorting a large list.\n\nYou can use the sorted() method of collections.OrderedDict, which doesn't require a comparison function.\n\nI like it. I wonder if you could use this to do a binary search to find the first non-zero digit in a number.\n\nIt's a good idea. I'll try to write it soon.\n\nI'm not sure I understand the first example. Why isn't the list just sorted?\n\nThe list is sorted. The only difference is that the list is sorted by the second element.\n\nI don't think I understand what you mean. The list is sorted by the first element. The first element is 1, so the list is sorted by increasing order.\n\nOh, my mistake. I wrote it in a hurry.\n\nI would recommend using itertools.permutations instead of the slow built-in sort.\n\nI'll try it. Thanks.\n\n\"unique_", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x, key=lambda x: x[1])\n\nThis is a good example of how you can make a very simple function (the original one is only one line) and make it a lot more complicated.\nThe original one was really simple, and very easy to understand. It's also really fast, because it does not need to sort anything.\nYour version is not much more complicated, but it's a lot slower. It also requires you to have sorted the list, which is not always the case.\n\nActually, the original one is not really simple. It's a very common mistake to think that a list is sorted by default, but it's not.\n\nTrue, but the original version is not written for python 2.6.\n\nHow does this work?\n\nThe function calls the built-in function sorted() on the list, and then calls key() on the resulting list.\n\nThis is a really nice example of why you shouldn't reinvent the wheel.\n\nI don't see this as reinventing the wheel. The original function had a bug. The new function is correct.\n\nI think you missed the point. The point is that the original function is", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda x: x[1] == 0)\n\nPython's built in function sorted() will return a sorted list.\n\nYou could also use the built in function unique()</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 1:\n        return x\n    else:\n        for i in x:\n           if i % 2 == 0:\n                   break", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x.split(',')[::-1] if x.startswith('0'))\n\nThis is a terrible solution.\n\nI'm not a fan of this style of solution either, but what do you suggest?\n\nI would write it like this:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) > 0:\n        return [x[i] for i in x]\n    else:\n        return []\n        return [x[i] for i in x if i % 2 == 0]\n\nThis is a very naive implementation of unique_digits.\nIt's not actually sorting the list, it's just doing some binary\nsearching. This makes it run in linear time, but it doesn't actually\nsort the list.\nIf you want to sort the list, then you could do something like:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x))", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # If x is a list, return the first element that doesn't have any even\n    # digit.\n    if len(x) == 1:\n       return x[0]\n    else:\n       # If x is a list, return the first element that doesn't have any even\n       # digit.\n        if x[0] % 2 == 0:\n            return x[0]\n        else:\n            return x[0]\n    return []", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 1:\n        return x\n    else:\n        if len(x) > 1:\n           return [x[0] for x in x]\n         else:\n            return unique_digits(x[1:])", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda x: x[0], reverse=True)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[x[", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for x in xs:\n       if x[0]!= 0:\n          return x\n    return xs", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[0] == 0:\n        return []\n    return x[1:]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    x = sorted(x)\n    for i in x:\n        if i % 2 == 0:\n            return i\n    return []\n\nThe problem is that you're sorting the integers first, which will give you the wrong answer. You need to sort the list of integers you're given.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 1:\n        return []\n    for x in x:\n        if x[0] % 2 == 0:\n           return x[1:]\n           return []\n    return [x[0]]\n\nI don't understand why this is interesting.\n\nIt's not, the title is clickbait.\n\nIt is actually pretty interesting. It's a very simple algorithm, but it's very elegant. It's a common algorithm for programming interviews.\n\nI'm a bit late to the party, but it's not really that interesting. It's a classic problem and the solution is pretty straight-forward.\n\nI'm not saying it's not interesting to you. I'm saying it's not interesting to me.\n\nI think it's interesting.\n\nI think it's interesting too.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in x:\n        if i % 2 == 0:\n            return [i]\n    return [i]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x for x in x if x[2]==0]\n\nI like the use of the ternary operator in this solution.\n\nThanks! It took me a while to realize that it's the only way to get the result in a single line.\n\nThis is a good example of why you should always use the ternary operator when you can.\n\nOr you could just use the bitwise AND operator.\n\nThis is just a silly way of doing it. The ternary operator is a lot more readable.\n\nIt's just a silly way of doing it, but it's a lot more readable.\n\nThat's the same thing he said.\n\nI think the \"and\" operator is clearer than the ternary operator.\n\nI think the ternary operator is clearer than the AND operator.\n\nI think the ternary operator is clearer than the AND operator.\n\nI think the ternary operator is clearer than the AND operator.\n\nI think the AND operator is clearer than the ternary operator.\n\nI think the ternary operator is clearer than the AND operator.\n\nI think the ternary operator", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def __len__(self):\n    return len(self)\n    return [i for i in unique_digits(x) if i % 2!= 0]\n\nWhat's the point of this?\n\nI guess it's a way to get a list of prime numbers without actually doing a prime number test.\n\nIt's also a good way to get a list of even numbers.\n\nWhy not just use the modulus operator?\n\nHow would you get a list of odd numbers?\n\nIt's a bit like the Fibonacci sequence.\n\nI think the OP was looking for a way to get a list of prime numbers.\n\nAha!</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda x: x[:i])\n\nI'm not sure if this is what you're looking for, but it's a start.\n\nThanks for the reply. I was looking for something like this but the function should return the sorted list without any modification to the input list.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda x: x[1:])\n\nI had to look at this a couple of times to understand how it worked. I thought you were building a list of all numbers with no even digit, but it's actually a list of all numbers with no even _digit_ (not _digits_ ).\n\nThanks for pointing that out. I have edited the code to fix the typo.\n\nI think the correct title is \"Python: Sorting a list of numbers with no even digit\".\n\nHow did you get that title? It's not the same as the title of the article.\n\nThe title of the article is \"Python: Unique Digits\", but the title of the post is \"Python: Sorting a list of numbers with no even digit\"\n\nAh. I see now. I didn't realize the title of the article could be edited.\n\nI love Python, but I don't understand the usefulness of this.\n\nI believe the point is to show that Python is not a one trick pony and can be used for many different purposes.\n\nI can't help but think that there is a simpler way to do this.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[x.count()] for x in x]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 1:\n       return x\n    else:\n       return x[::-1]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def unique_digits(x):\n    \"\"\"Given a list of positive integers x. Return a sorted list of all \n    elements that doesn't any even digit.\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    return sorted(x, key=lambda x: x[0] if x[0] == 0 else x[1])\nI would just use this:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    x = [x[0] for x in x]\n    return sorted(set(x), key=lambda x: x[1], reverse=True)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return x.filter(lambda x: x[0]!= 0)\n\nInteresting, but the post is a bit misleading. It's not really a problem to sort a list of integers in increasing order.\n\nI think the point is that you don't want to sort the whole list.\n\nWell, that's what I meant when I said \"sorting the list\".\n\nI think the point is that you don't want to sort the whole list.\n\nI think the point is that you don't want to sort the whole list.\n\nI think the point is that you don't want to sort the whole list.\n\nI think the point is that you don't want to sort the whole list.\n\nI think the point is that you don't want to sort the whole list.\n\nI think the point is that you don't want to sort the whole list.\n\nI think the point is that you don't want to sort the whole list.\n\nI think the point is that you don't want to sort the whole list.\n\nI think the point is that you don't want to sort the whole list.\n\nI think the point is that you don", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    x = []\n    for i in range(len(x)):\n       if x[i] % 2 == 0:\n          x.append(i)\n    return x\n\nI don't understand why it's necessary to define a new function.\n\nThis is a good example of how to make a code golf submission.\n\nI'm not sure how this is a golf submission. It's a reasonably useful function that is not very long.\n\nI think he was being sarcastic.\n\nI'm glad this was posted. I was not aware of this golf thing.\n\nI'm not sure what I'm looking at, but it looks like some sort of golf.\n\nI don't know what you're talking about. This is a perfectly reasonable function.\n\nThis is a perfect example of how to make a code golf submission.\n\nI'm not sure why this is a golf submission. It's a reasonably useful function that is not very long.\n\nI think he was being sarcastic.\n\nI'm glad this was posted. I was not aware of this golf thing.\n\nI'm", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x == 0:\n       return []\n    for i in x:\n       if i % 2 == 0:\n          return i\n       else:\n          return x[i]\n    return x", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[i] for i in x if x[i] % 2 == 0]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return x.pop(0)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda i: i % 2 == 0)\n\nThe list comprehension here is the same as the list comprehension in the original post.\n\nI think the list comprehension is actually more readable than the for loop.\n\nThe list comprehension is more readable than the for loop, but not more readable than the original for loop.\n\nI think the list comprehension is more readable than the for loop, but not more readable than the original for loop.\n\nI think the list comprehension is more readable than the for loop, but not more readable than the original for loop.\n\nI think the list comprehension is more readable than the for loop, but not more readable than the original for loop.\n\nI think the list comprehension is more readable than the for loop, but not more readable than the original for loop.\n\nI think the list comprehension is more readable than the for loop, but not more readable than the original for loop.\n\nI think the list comprehension is more readable than the for loop, but not more readable than the original for loop.\n\nI think the list comprehension is more readable than the for loop, but not more readable than the original for loop.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return x.filter(lambda x: x % 2 == 0)\n\nThis will be faster:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for x in xs:\n        if x[0]!= 0:\n           return x\n    return []\nI'm not sure why you are doing this in Python.  This is a very easy problem to solve in C using a single nested for loop.  That said, this is not the best way to write it.  The best way to write this is to use a generator expression.  Then you can use list comprehension to build your sorted list.  Here's a rough attempt at it.  There are probably a lot of improvements that could be made.\n>>> from itertools import islice\n>>> def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all\n    elements that hasn't any even digit.\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_dig", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda x: x[1]!= 0)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return sorted(x, key=lambda x:x[2])\n\nIs it me or is it a bit weird that you can use this to generate a sorted list of all elements that haven't any even digit?\n\nYes, it is a bit weird. I think the author should have used the word \"all\" instead of \"any\".\n\nThe author here. Yes, I agree. Thanks for pointing it out.\n\nYou're welcome.\n\nThis is a little similar to the uniq method of the Python standard library:\nIt returns a list of all non-repeated elements in the list.\n\nI think this is a better explanation of the python uniq method:\n\nI can't believe I'm the first person to comment on this. I'm not sure if it's a sign of how good the explanation is or how many people just don't think about it.\n\nI'm not sure what the point of this is. I mean, if I want to find all the odd numbers in a list, I can just use the built in methods.\n\nThe point is that this is a generic function that works with any list, not just a list of integers.\n\nThat", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x, key=lambda x: x[1]!= x[0])\n\nI'm not sure what you're getting at here. The original code is not the shortest possible, but it's not the longest either. It's not even particularly bad, although I would suggest using a dictionary instead of a list.\n\nI believe the point is that the example is wrong. The algorithm requires the list to be sorted, and the example is not.\n\nThe example is wrong because it doesn't use the provided function.\n\nIt's wrong because it's not the shortest possible solution. The example is not written using the provided function because the provided function is not the shortest possible solution.\n\nThe example is wrong because it uses a list instead of a dictionary.\n\nI think you're missing the point. The point is that the example is wrong because it uses a list instead of a dictionary.\n\nI think you're missing the point. The point is that the example is wrong because it uses a list instead of a dictionary.\n\nI think you're missing the point. The point is that the example is wrong because it uses a list instead of a dictionary.\n\nI think you're missing", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return x[x[x[x[...]]]]]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[x[0] % 2!= 0] for x in x]\n\nThis is a very useful function. I've used it a lot. It's faster than\nusing the built in function, and it's also easier to understand.\n\nThere is a built in function for this?\n\nYes, it's called sorted() and it's part of the standard library. It's\nalso faster than this one.\n\nNot sure why you got downvoted.\n>>> from collections import sorted\n>>> sorted(unique_digits(range(3))[::-1])\n[1, 2, 3]\n>>> sorted(unique_digits(range(3))[::-1])\n[1, 2, 3]\n>>> sorted(unique_digits(range(3))[::-1])\n[1, 2, 3]\n>>> sorted(unique_digits(range(3))[::-1])\n[1, 2, 3]\n>>> sorted(unique_digits(range(3))[::-1])\n[1, 2, 3]\n>>> sorted(unique_digits(range(3))[", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x == [] or x[0] == 0:\n       return []\n    x.sort()\n    return [x[1:], x[2:] if x[1] % 2 == 0 else x[2], x[3:] if x[1] % 3 == 0 else x[3]]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda x: x[0] % 2 == 0)\n\nI like that this has a human-readable name. I think the best Python code is the code that you can look at and immediately understand what it does.\n\nI think the best code is the code that does what you want.\n\nI think that is a very shortsighted view of code. Code is not just a tool for getting the job done. It's a way of communicating with others. If the code is hard to read, it makes it hard for others to understand what you're doing and how you're doing it.\n\nI think that's a very shortsighted view of code. Code is not just a way of communicating with others. It's a way of getting the job done. If the code is hard to read, it makes it hard for others to understand what you're doing and how you're doing it.\n\nThe code is not the only thing that is hard to read. It's the comments that are hard to read, too.\n\nI think the best code is the code that does what you want, and the comments that make it easy to understand what you want.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    if len(x) == 0:\n        return []\n    return x[:len(x) - 1]\n\nimport random", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return set(x.index(x.is_even()), x.index(x.is_odd()))\n\nThis is a great example of a function that's not worth using. It's only slightly more readable than the Python. It's slower. It's more difficult to maintain. And it's more difficult to understand.\n\nI don't understand. How is this difficult to understand?\n\nIt's not. I think the parent is just trying to say that the Python is easier to understand, which is true.\n\nI disagree. The Python is not easier to understand. The Python is a little easier to write, but not easier to understand.\n\nI was going to write a python version but it was too long so I will just paste it here:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return (x for x in x if x % 2 == 1)\n\nI would think that\nreturn (x for x in x if x % 2!= 0)\nwould be more appropriate.\n\nYeah, it would be more appropriate. I'm not sure if it's more efficient.\n\nI don't see why it wouldn't be.\n\nIt depends on whether the number of 1s in the list is a constant.\n\nYeah, but even if it's not a constant, it's still a constant time operation.\n\nIt's not a constant time operation, because it depends on the length of the list.\n\nI would think that (x for x in x if x % 2!= 0) would be more appropriate.\n\nI would think that (x for x in x if x % 2 == 1) would be more appropriate.\n\nI would think that (x for x in x if x % 2!= 0) would be more appropriate.\n\nI would think that (x for x in x if x % 2!= 0) would be more appropriate.\n\nI would think that (x for x in x if x % 2!= 0) would be more appropriate.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    def unique_digits_with_count(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all\n    elements that doesn't any even digit and also count number of elements.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits_with_count(unique_digits([15, 33, 1422, 1]) + [152, 323, 1422, 10])\n    [1, 15, 33, 152, 323]\n    >>> unique_digits_with_count(unique_digits([15, 33, 1422, 1]) + [152, 323, 1422, 10], 2)\n    [1, 15, 33, 152, 323, 2]\n    \"\"\"\n\n    def uniq(x):\n    \"\"\"Return a list of unique elements from a list of positive integers x.\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set([x[i] for i in x if x[i]!= 0 if i in x])\n    if x[0]!= 0)\n\nIf you're interested in other Python sorting algorithms, I've written a blog post that compares them and includes a few others:\n\nI'm not sure I understand the difference between the two approaches.\nThe first seems to be a bit more readable and straightforward. The second seems to be more in line with the way you would think about the problem.\n\nI think the first is better for the same reason I prefer the Unix command line: it is a simple, clear, terse way of expressing a complex task.\n\nI think the first is better because it's more like the way you would think about the problem.\n\nI think the first is better because it is a simple, clear, terse way of expressing a complex task.\n\nI think the first is better because it is more like the way you would think about the problem.\n\nI think the first is better because it is a simple, clear, terse way of expressing a complex task.\n\nI think the first is better because it is more like", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    def sorted_unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> sorted_unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> sorted_unique_digits([152, 323, 1422, 10])\n    [10, 1422, 323]\n    \"\"\"\n\n    return unique_digits(x)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for x in xrange(len(x)):\n        if x[0] % 2 == 0:\n            return x\n    return []\nThis is the same as:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x))", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for x in xrange(1, len(x)):\n        if x[0] == 0:\n            return x\n        else:\n             return x[1:]\n\nI don't know if this is the most efficient way to do it, but it works.\n\nI'm not sure why you're getting downvoted. I thought it was an interesting way to do it.\n\nI think it's because of the \"I don't know if this is the most efficient way to do it\" part.\n\nI guess I should have added that I don't know if there is a more efficient way to do it.\n\nThere is, in fact, a better way to do it.\n\nThere are at least two ways to do it better than this.\n\nI am not sure that is true.\n\nThere is also this:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    sorted_digits = []\n    for i in x:\n        if i % 2 == 0:\n            sorted_digits.append(i)\n    return sorted_digits\n\nIs this a joke?\n\nYes, it's a joke.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    \"\"\"\n    for i in x:\n        if i % 2 == 0:\n            break\n            return [i]\n    return []", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all\n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    return [x[i] for i in x if x[i] % 2 == 0]\n\nThe list is sorted in increasing order.\n\nYou can do it in python 2.7 too:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x.split()[0], key=lambda a: x[a[0]]!= 1)\n\nYou can also do this:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # This function is a modified version of unique_digits in the\n    # standard library\n    return unique(x.split(\",\"), key=lambda x: x[1] == 0)\n\nI think you meant:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for x in xrange(len(x)):\n        if x[0] == 0:\n           return x\n         else:\n            return x[1:]\n    return unique_digits(xrange(len(x))[::2])</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if len(x) == 0:\n       return []\n    else:\n       for i in x:\n          if i % 2 == 0:\n               return i\n              else:\n                return x[i]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    def __init__(self):\n        self.head = []\n\n        self.tail = []\n\n        self.digits = [x[0] for x in x]\n\n        self.sorted_list = []\n\n        self.sorted_list.append(x[0])\n\n        for i in range(len(self.digits)):\n           if (i % 2) == 0:\n                self.sorted_list.append(self.tail[i])\n\n               self.tail.append(self.head[i])\n\n               self.head.append(x[i])\n\n    return self.sorted_list</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    return sorted(set(x), key=lambda x: x[1] == 0)\n\n>>> unique_digits([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # remove all even digits\n    return sorted(x, key=lambda x: x[1]!= 0)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    # return the first element if the number is even, otherwise return the\n    # first element that doesn't have any even digit\n    if x == 0:\n        return x[0]\n    else:\n        return x[-1]\n    # return the rest of the numbers that doesn't have any even digit\n    return [x[1:], x[-1:]]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    n = len(x)\n    nr = 0\n    for i in x:\n        if i % 2 == 0:\n            nr += 1\n    return [nr]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x, key=lambda x: x[0]!= 0)\n\nI think the author is trying to say that the first function is \"more pythonic\" than the second. I don't know what that means.\n\nMy favorite part is the \"Note: Returned list should be sorted in increasing order.\"\n\nI can't remember what the last time I needed to write a sorted list that wasn't increasing order.\n\nI have a feeling that the author of that snippet has never used Python.\n\nI have a feeling that you are wrong.\n\nI'd be curious to see the same test in other languages.\n\nI think the author is trying to say that the first function is \"more pythonic\" than the second. I don't know what that means.\n\nMy favorite part is the \"Note: Returned list should be sorted in increasing order.\"\n\nI can't remember what the last time I needed to write a sorted list that wasn't increasing order.\n\nI have a feeling that the author of that snippet has never used Python.\n\nI have a feeling that you are wrong.\n\nI'd be curious to see the same test in other languages", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for i in x:\n        if i % 2 == 0:\n           yield i\n    return []", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def even_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that has even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> even_digits([15, 33, 1422, 1])\n    [15, 33, 1422]\n    >>> even_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    return [x[i] for i in range(len(x) + 1)]\n\nThe thing is that the second function is not a recursive one. If you make it recursive, you'll have to use a stack or a queue.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda i: x[i] % 2 == 0)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\n    for x in xs:\n        if x % 2 == 0:\n            return x\n    return xs", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    for x in xrange(len(x)):\n       if x[0] == 0:\n          return x\n    return [x[1:] if x[0] % 2 == 0 else x[0]]\n\nI'm not sure about the meaning of \"hasn't any even digit\". I think it\nshould be \"has an odd number of even digits\".\n\nIndeed. I have changed it.\n\nGood stuff.\n\nI like it. It's a lot of fun to work out problems like this with code.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def find_even(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that has at least one even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> find_even([15, 33, 1422, 1])\n    [15, 33]\n    >>> find_even([152, 323, 1422, 10])\n    [10]\n    \"\"\"\n    def unique_even(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that has at least two even digits.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_even([15, 33, 1422, 1])\n    [15, 33, 14]\n    >>> unique_even([152, 323, 1422, 10])\n    [10, 14", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x.count(x.index(0)):\n        return x.pop()\n    else:\n        return [x for x in x if x[0] % 2 == 0]\n\nIs this correct? I think it is, but I'm not sure.\n\nI think it is, but I'm not sure.\n\nThat's the correct answer.\n\nIt's correct, but the use of the % operator is a bit odd.\n\nWhat's the correct way to do it?\n\nYou can use a for loop or a while loop.\n\nI see. Thank you.\n\nYou're welcome.\n\nI think the OP's version is correct, but I'm not sure.\n\nI think it is, but I'm not sure.\n\nThat's the correct answer.\n\nIt's correct, but the use of the % operator is a bit odd.\n\nWhat's the correct way to do it?\n\nYou can use a for loop or a while loop.\n\nI see. Thank you.\n\nYou're welcome.\n\nI think the OP's version", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    def __len__(self):\n    return len(self.values())\n    return unique_digits(xrange(len(x)))\n\n>>> unique_digits([1, 2, 3])\n[1, 2, 3]\n>>> unique_digits([1, 2, 3, 4])\n[1, 2, 3]\n>>> unique_digits([1, 2, 3, 4, 5])\n[1, 2, 3]\n>>> unique_digits([1, 2, 3, 4, 5, 6])\n[1, 2, 3, 4, 5]\n>>> unique_digits([1, 2, 3, 4, 5, 6, 7])\n[1, 2, 3, 4, 5, 6]\n>>> unique_digits([1, 2, 3, 4, 5, 6, 7, 8])\n[1, 2, 3, 4, 5, 6, 7, 8]\n>>> unique_digits([1, 2, 3, 4, 5, 6, 7, 8, 9])\n[1, 2, 3, 4, 5, 6, 7", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda i: i%2==0)\n\nI believe Python 3.0 has a better implementation of this:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return x.split()[0] if x.startswith('0') else x.split()[1:]\n\nThis is a bad solution. It's not O(n).\n\nit is O(n). It's O(n log n) if you want to be pedantic.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set([x[i] for i in range(len(x) - 1) if x[i] % 2!= 0])\n   . keys())\n\nI don't know if I am missing something but this is not a pythonic way of doing this.\n\nI think he was just demonstrating the algorithm, not actually trying to solve the problem.\n\nThe algorithm is not pythonic either.\n\nI can't see any way to do this in pythonic way.\n\nYou can't do it in a pythonic way. The algorithm is wrong.\n\nI'm not sure I understand what you mean.\n\nWhat I mean is that the algorithm is wrong.\n\nOk, but what is the correct algorithm?\n\nI don't know. I was just pointing out that the algorithm that was posted is wrong.\n\nI still don't understand how the algorithm is wrong.\n\nOk, well, you asked if there was a pythonic way to solve the problem, and I said that there isn't. You then said that you can't do it in a pythonic way. I then pointed out that you can't do it in a pythonic way because", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda x: x[:2])\n\nThis is pretty nice, but it seems like there are a few ways to make it faster:\n1) Don't sort the list, just use the first element.\n2) Use a hash table, and use the first element as the key.\n\nAnd if you have a hash table, you can do a binary search and avoid the sort entirely.\n\nI like that solution, but I'd like to see it implemented in Python.\n\nPython has builtin support for sorted maps, so you could do this:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[0] for x in x if x[0] % 2 == 0]\n\nI like this one. It's simple and works well.\n\nIt's also a perfect example of why you should always use a list comprehension for such problems.\n\nI've got a few:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    \"\"\"return sorted(set(x), key=lambda x: x[-1]==0)\n    \"\"\"\n    def get_even_digits(x):\n    \"\"\"Return a sorted list of all elements that has an even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> get_even_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> get_even_digits([152, 323, 1422, 10])\n    []\n    \"\"\"\n    \"\"\"return sorted(set(x), key=lambda x: x[0]==0)\n    \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(set(x), key=lambda x: x[0]==0)\n\n>>> unique_digits(x)\n[1, 15, 33]\n>>> unique_digits([152, 323, 1422, 10])\n[1, 15, 33]\n>>> unique_digits([15, 32, 1422, 1])\n[1, 15, 33]\n>>> unique_digits([15, 32, 1422, 2])\n[1, 15, 33]\n>>> unique_digits([15, 32, 1422, 3])\n[1, 15, 33]\n>>> unique_digits([15, 32, 1422, 4])\n[1, 15, 33]\n>>> unique_digits([15, 32, 1422, 5])\n[1, 15, 33]\n>>> unique_digits([15, 32, 1422, 6])\n[1, 15, 33]\n>>> unique_digits([15, 32, 1422, 7])\n[1, 15, 33]\n>>> unique_digits([15, 32, 1422, 8])\n[1, 15, 33", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    #return sorted list of all elements that doesn't any even digit\n    return sorted(set(x), key=lambda x: x[2], reverse=True)", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return sorted(x.split(), key=lambda x: x[2])\n\nThis one's much faster than the one in the article.\n\nI think the article's solution is faster.\n\nI think you're right.\n\nThis is a fun problem. I have some code that does it in a way that's\na little more flexible.\nIt's based on the observation that the same number can be expressed as\na sum of primes. For example, 123 is 3+1+2+3, and it's also 1+2+3+3.\n(The difference between these two sums is 1.)\nSo the idea is to count the number of different sums of primes that\nyield a given number. For example, for 123, the primes are 2, 3, and 5,\nso we count the number of different sums of these primes.\n123 = 2 + 3 + 5\n123 = 1 + 2 + 3 + 5\n123 = 3 + 1 + 2 + 3 + 5\n123 = 1 + 2 + 3 + 5 + 5\n123 = 3 + 2 + 5 + 3 + 1 + 2 + 3\n123 = 2 + 3 +", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[0] for x in x if x[0]!= 0]\n\nI think the author is probably trying to solve the problem of finding all numbers with an odd number of digits, but the code is horribly broken.\n\nNo, I think the author is trying to solve the problem of finding all numbers with an even number of digits.\n\nI agree, but the code is still broken.\n\nA simple solution, but I like the recursive solution better:", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n\nI'm not sure what your problem is.\n\nThis is a very common problem in interviews, and the solution is usually to create a sorted list of all the numbers that don't have any even digits, and then to return that list.\n\nI'm pretty sure this is the solution. I don't know how it's called in python, but I'd use the following (C#):\nList<int> list = new List<int>();\nwhile (x!= null && x.Equals(0)) {\nx = x.ToString();", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    if x[0]!= 0:\n       return []\n    return x[::-1]\nThe for loop is still there, it just doesn't show up in the code.\n\nYes, but you're still using a for loop.\n\nYes, but you're still using a for loop.\n\nIt's not clear to me why this is a good thing.\n\nIt's not clear to me why this is a good thing.\n\nIt's not clear to me why this is a good thing.\n\nIt's not clear to me why this is a good thing.\n\nIt's not clear to me why this is a good thing.\n\nIt's not clear to me why this is a good thing.\n\nIt's not clear to me why this is a good thing.\n\nIt's not clear to me why this is a good thing.\n\nIt's not clear to me why this is a good thing.\n\nIt's not clear to me why this is a good thing.\n\nIt's not clear to me why this is a good thing.\n\nIt's not clear to me why this is a good thing.", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    unique_digits = sorted(set(x))\n\nI wonder what is the rationale behind returning a sorted list.\n\nI'm guessing that it's so that it is easy to see that the result is sorted.\n\nI think it's so that you can use it as a generator.\n\nI've heard it said that one should only use a generator when it's absolutely necessary.\n\nYou have to be careful about that.\n\nI think the author was being sarcastic.</s>", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    return [x[i] for i in range(len(x) - 2)]", "def unique_digits(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> unique_digits([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> unique_digits([152, 323, 1422, 10])\n    []\n    \"\"\" \"\"\"\n    sorted_digits = sorted(x)\n    for i in range(len(sorted_digits)):\n        if i % 2 == 0:\n             return sorted_digits[i-1]\n    return []\nThis is a simple and fast way to do it.</s>"]]