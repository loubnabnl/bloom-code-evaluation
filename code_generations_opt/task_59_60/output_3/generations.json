[["def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    for i in range(2, n):\n    if n % i == 0:\n       return n\n    return n\n>>>\n\nI think you meant:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return 0\n    if n == 2:\n        return n\n    if n == 3:\n        return 2\n    if n == 4:\n        return 3\n    if n == 5:\n        return 4\n    if n == 6:\n        return 5\n    if n == 7:\n        return 6\n    if n == 8:\n        return 7\n    if n == 9:\n        return 8\n    return n\n\nNote that this is a typical example of a naive recursive function.  Note that this function does not terminate, and may run forever if given sufficiently large inputs.", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 1:\n       return 1\n    n = floor(n / (2**3))\n    for i in range(n):\n       if n % i == 0:\n          n = n / i\n         return n\nThis is silly. It does no bounds checking, so it can overflow.  It does not return the maximum possible prime factor.", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 1:\n        return 1\n    else:\n        if n % 2 == 0:\n           return n - 2\n         else:\n           return n % 2\n    def largest_prime(n: int):\n    \"\"\"Return the largest prime number less than or equal to n.\n    >>> largest_prime(13195)\n    13\n    >>> largest_prime(2048)\n    3\n    \"\"\"\n    if n < 1:\n        return 1\n    else:\n        if n % 2 == 0:\n           return n - 2\n         else:\n           return n % 2\n\nPython</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    def largest_prime_factor_mod(n: int):\n    \"\"\"Return the largest prime factor of n modulo m. Assume n > 1 and\n    is not a prime.\n    >>> largest_prime_factor_mod(13195, 29)\n    29\n    >>> largest_prime_factor_mod(2048, 2)\n    1\n    \"\"\"\n    def largest_prime_factor_mod(m: int):\n    \"\"\"Return the largest prime factor of n modulo m. Assume n > 1 and\n    is not a prime.\n    >>> largest_prime_factor_mod(13195, 29)\n    29\n    >>> largest_prime_factor_mod(2048, 2)\n    1\n    \"\"\"\n    def largest_prime_factor_mod_last(m: int):\n    \"\"\"Return the largest prime factor of n modulo m. Assume n > 1 and\n    is not a prime.\n    >>> largest_prime", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n == 1:\n       return n\n    for i in xrange(2, n - 2):\n       if n % i == 0:\n         return i\n    return n\n\nOh, we were supposed to write python?\nhttps://github.com/grisha/cl-clarity</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return n\n    if n == 2:\n        return n*n\n    if n < 1:\n        return n/n\n    else:\n        return largest_prime_factor(n - 1)\nWhat if n = 0.9999999?\n\n1 - 0.999999 = 0.0001\nSo the largest prime factor is 1\n\nI'm not sure I get it, but doesn't this break if n < 0?\n\nThe same holds for n > 0.\n\nNot true. If n > 0, it does _not_ return the largest prime factor of n, which is 0.\n\nIt's using a Python list as a replacement for a function that tests if a number is a prime. This is a great example of how all of Python's fundamental constructs work together.\nTo save you the time:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    return n % largest_prime_factors(n - 1)\nI thought the factorial of a number was the number of ways you could choose a subset of that number. So for 13195 the factorial is 13195!. Couldn't this be changed to \"n%13195\" or similar?\n\nIf I recall correctly, the factorial of a number is the number of ways you could choose a subset of that number and multiply all the results together. So for 13195, 13195! is the number of ways you could choose a subset of 13195 and multiply those results together.\nI think that's the case because the factorial of a natural number is the sum of the factorials of its factors. So 13195! = 1 + 1319 * 19 * 17 *... * 1.", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if n%i == 0:\n           return n%i\n    return i\nPython 3.3.3\n\nYou're right; I had accidentally written:\nreturn len(sieve(n)) - 1\nfor an earlier version of this program. Updated now, thanks.\n\nOh right, I missed that.\n\nI thought this was going to be something along the lines of:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return sqrt(n)\nI would have done `n**n`, but that's just me.\nIt's interesting that when Python implements a mathematical function, it uses a native python library, whereas if you do it in ruby, it uses a standard C library.\nThat's actually pretty cool, I didn't know about that.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 2:\n       return 1\n    if n < 3:\n       return 2\n    if n < 5:\n       return 3\n    if n < 7:\n       return 4\n    if n < 11:\n       return 5\n    if n < 13:\n       return 6\n    if n < 17:\n       return 7\n    if n < 19:\n       return 8\n    if n < 23:\n       return 9\n    if n < 29:\n       return 10\n    if n < 31:\n       return 11\n    if n < 37:\n       return 12\n    if n < 41:\n       return 13\n    if n < 43:\n       return 14", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    def largest_prime_factor(n: int):\n    if n == 1:\n        return 1\n    return n % 2\nAh, the joys of Python.  I miss that about my Ruby job sometimes.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return [int(x**y) for x in int(x) for y in int(y)]\nWhy did you have to use a for loop?\nDid he need to?  I thought the point was to show the code, not the most efficient way of getting the same result.        def largest_prime_factor(n: int):", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    n = n_to_factors(n)\n    if n!= 0:\n        if n == 1: return 1\n        if n % 1 == 0: return 1\n        if n % 2 == 0: return 1\n        if n % 3 == 0: return 1\n        if n % 4 == 0: return 1\n        if n % 5 == 0: return 1\n        if n % 6 == 0: return 1\n        if n % 7 == 0: return 1\n        if n % 8 == 0: return 1\n        if n % 9 == 0: return 1\n        if n % 10 == 0: return 1\n        if n % 11 == 0: return 1\n        if n % 12 == 0: return 1\n        if n % 13 ==", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return n.bit_length() % n.bit_length()\nThis is a horrible algorithm, as the number of bits in n is irrelevant.\n\nIt may be horrible, but it works in all cases. How do you fix it?\n\nWithout knowing the input, I can't be sure it always works.\nHere's one case where it doesn't: \nAnd another:\n\nThe first of those cases is completely fair - the factorization of 13195 is\n29 * 19 * 19, not 29 * 2 * 19, so the algorithm doesn't work.\nThe second is a bug in Python, which treats float64 as a long, and it's fixed in Python 3.\n\nAh, Python 3. I should have noticed that.\n\nPython 3 is very nice, it has a lot of nice features. It's not hard to get things working in Python 3.\n\nI like the name.\nI don't like the implementation.\nI don't like Python 3.\n\nWhy do you not like Python 3?\n\nWhile the change is much needed and I am glad it's here, I don't like it because I have to go through the hassle of learning a", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    def largest_prime_factor(n: int):\n    if n < 1:\n         return 1\n    n_primes = 2**n - 1\n    # Find the highest prime factor\n    if n < n_primes:\n         return n\n    largest_prime_factor = n\n    return largest_prime_factor\n\nSee also:\n\npython\nPython</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n is None:\n       return 1\n    else:\n       return largest_prime_factor(n - 1)\nwhile True:\n    if n % 2 == 1:\n       break\n    print 'largest prime factor of {0} is', n, '\\n'\n\nI'm not seeing the relation to the standard library's prime_factors.\n\nI believe that was his point\n\nI don't like this solution because it doesn't work as a generator, which is where the standard library's solution shines.\n\nI was going to use the standard library's solution in one of my programs but the documentation is pretty unclear about what it's supposed to do:\n\nThat's why I wrote this. The standard library documentation on large numbers is pretty bad.\n\nIt's a bit of a shame that one can't just wrap the prime_factors function in a function that takes a generator instead of a function that takes a value.\nI can't help but feel like there is a place for this in Python, though:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n        return n/largest_prime_factor(n-1)\n    else:\n        return n/largest_prime_factor(n)\nCan't you just say that the first loop is equivalent to doing this?", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n        return largest_prime_factor(n-1)\n    else:\n        return n\nThis code is awful.\n\nThe last if n is odd is superfluous.\nIt would be a better exercise to explain why.\n\nIt is, but you'd expect that this is the kind of thing that someone who claims to know how to use a language would know.\n\nThis code is awful for a variety of reasons, but the one that I noticed most immediately was that they wrote a function to find the largest prime factor of a number, without checking if that number is actually prime.\nI'm all for writing code quickly to solve a problem, but writing correct code quickly is much more important.\n\nI don't think that's the worst thing about it. The worst thing is the `return n`.\n\nI think that's the point of the post. The code compiles and runs, but it's completely wrong.\n\nI think this code is mostly awful because it's so bad it's funny. The variable names are bizarre, there's a ton of duplication, and the actual logic is just", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n == 1:\n        raise ValueError(\"n must be greater than 1\")\n    return n % 2\nor, if you want to avoid the possibility of raising an exception on an impossible input, a while loop (while n > 1):", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n        return (2*n + 1) % n\n\nWhile I admire the effort that went into creating that function, that's a terrible idea. Not only is it ridiculously slow, it's so ridiculously slow that it seems like a good candidate for the title of \"WORST IDEA EVER\".\n\nIf the OP wants to have some fun with large numbers, they should try building some of the old algorithms that are used to factor numbers.\nFor example, a simple algorithm for factoring RSA keys:\n\nThe slowest one I wrote was a function that, given a string, returned the longest subsequence that was composed of equal-length palindromes.\n\nNot sure if the author meant to do this, but if you check the \"Slowest Program\" box you get a weird _new_ version of the website (as opposed to the original) that is much more amusing to look at.\n\nThis was what I was looking for, but when I clicked the link it took me to the original site.\n\nI like that the slowest version is almost identical to the original.\n\nIt's amusing to see the generation of code that", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n        return (n - 1) % 2\n    else:\n        return n % 2\nI don't get it.  What's the purpose of the method?  It's pretty obvious how to compute the largest prime factor of a given number.\n\nIt's not obvious if the number is not divisible by any prime number.\n\nWell, that's why it returns 1.\n\nWhen the number is prime, it returns the number. If not, it returns the smallest prime factor.\n\nYes, I get that, but I'm not sure what the method's point is.  If it's just a matter of convenience, then it's fine I suppose.  I just don't see what need it fills that couldn't be filled with a simple function.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n        return n % 2\n    else:\n        return n\nThis is wrong.  is the largest prime factor of 2048.\n\nYes. I will fix that.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n % 2 == 1:\n        return n // 2\n    else:\n        return n % (n - 1)\nI agree with your approach.  Omitting the comment since it's really just a copy-paste from the documentation.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    return n > 1 and n % 2 == 1\nThis is Python, which uses whitespace indentation, not braces.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n        largest_prime_factor = 2\n    else:\n        largest_prime_factor = n\n    return largest_prime_factor\nfor n in range(100000):", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n       if n % 2 == 0:\n          return n\n       else:\n          return (n >>> 1) & 1\nThe return value is not correct.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    for i in range(n):\n        if i % n == 0:\n           return 1\n    return largest_prime_factor(i)</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 1:\n        return 1\n    else:\n        if n % 2 == 0:\n           return n - 1\n         else:\n           return largest_prime_factor(n - 2)\n    return largest_prime_factor(n)", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n       return (n - 1) / 2\nYou can do better than that.  The only thing you really need to know is that n is not a power of 2, so you can stop there, and then you can just return n % 2 for every n.\n\nTrue, but I think the point is to find the largest prime factor of N without knowing N.\n\nAlso, I don't think it's a great idea to have the implementation be an if-statement.\n\n(That said, it doesn't look like the OP wrote it anyway. I suppose it's a good enough solution that it's useful as a comment on what is probably a homework problem, but it's not necessarily the best you can do.)\n\nI'm not sure where you're getting the impression that I didn't write it, but I did write it.\n\nYou're right. I was thinking of the first post on the thread, and the assumption that that person hadn't written the code.\n\nI'm surprised I couldn't find a good discussion on this topic when I was looking for a solution last night.\nTo make this easier to read:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n == 2:\n        return 1\n    else:\n        return 2\n\nI know it's a small thing, but there's a typo:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 1:\n        return 1\n    else:\n        return largest_prime_factor(n - 1)\nThis code is bad because it's not clear what it is supposed to do.  Also, it's too clever for its own good.\nIf you don't want to read the documentation and you don't want to learn how to write clear code, then you might as well just use a pre-packaged library and give up on programming.\n\nThe code is absolutely clear, and I think you know that. It's just that you're not familiar with the solution.\nThe \"too clever\" remark is rude.\n\nMy point is that the code was too clever for my taste. That's not being \"rude\" that's just a matter of personal taste.\nI would prefer to see some code that was more clear. The right amount of cleverness is a tricky thing to get right.\n\n>The right amount of cleverness is a tricky thing to get right.\nI agree. I personally think that this particular snippet falls into the \"clever\" category, but I'm not in the", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 1:\n        return 1\n    prime = 2\n    for i in range(2, n - 1):\n        if n % i == 0:\n           n = n / i\n        prime = prime * (n - i)\n    return prime\n\nI tried to get this to work with:\n>>> largest_prime_factor(15)\n29\n>>> largest_prime_factor(5)\n2\n>>> largest_prime_factor(2048)\n2\n\nAnd it didn't work.\nI think the \"Assume n > 1 and is not a prime.\" line is throwing it off.\n\nThe code was built for Python 2.3; Python 2.4 changes this:\n>>> largest_prime_factor(15)\nFalse\n>>> largest_prime_factor(5)\nFalse\n>>> largest_prime_factor(2048)\nFalse\n\nI changed it to be n < 1 for n < 2 and n > 2. Thanks.\n\nAlso works in Python", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    import math\n    def factor(n: int):\n    if n < 1:\n        return 1\n    else:\n        return math.mod(math.pow(2, n))\n    def largest_prime_factor(n: int):\n    if n > 1:\n        return math.pow(factor(n), 2)\n    return factor(n)\nIn Python:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n <= 1:\n        return 1\n    else:\n        return largest_prime_factor(n - 1)\n\nCan't you just do:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 2:\n        return n % 2\n    return -1\nNote: if you're using a 64bit platform, you should be using the 2**63 bit\nor 2**64 bit versions of `long long` instead of the 32bit `int`.\n\nYou are not accounting for 0 being prime.\n\nRight. It's still faster than a naive loop.\n\nIt's much faster than that, since you don't have to test if the result is zero.\n\nI don't think the author was too worried about the speed of this code.\n\nNice. I have to write a program that solves such problems so I'll try this.\n\nWould this work on a 64bit platform?\n\nNope, not the way it is written. It's not a very good algorithm, however, so there's no reason to use it in the first place.\n\n_There are much faster ways of doing this; for instance, this is very slow:_\nfor x in range(n):", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 1:\n        raise RuntimeError(\"largest_prime_factor() only works for integers >= 1\")\n    else:\n        return n % largest_prime_factors(n-1)\n\nCan anyone explain the purpose of that? It sounds like an oxymoron to me.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n        if n % 2 == 0:\n            return n % 2\n        else:\n            return n\n    return n\nI don't see the point of this code. It's not more efficient than      print(n)</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return 2 ** n * 1\n\nThe challenge was to write a Python function to return the largest prime factor of n.  This is a direct translation of the description in C++, which is a direct translation of the description in C.\n\nThe original C++ version of this function is:\n\nint largest_prime_factor(int n) {\n    if (n == 1 || n == 2) {\n       return 1;\n    } else {\n       if (n > 1) {\n          return 2 ** n * 1;\n       } else {\n          return n - 1;\n       }\n    }\n}\n\nThe original C version is:\n\nint largest_prime_factor(int n) {\n    if (n == 1 || n == 2) {\n       return 1;\n    } else {\n       if (n > 1) {", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 2:\n        return n\n    else:\n        return int(n) * (n + 1)\n\nThis is a great example of how sometimes what you think is an obvious function can be tricky to implement. If you're in the habit of calling Python's int() function, your first inclination might be to make this function like so:\n>>> def largest_prime_factor(n):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n > 2:\n        return n\n    else:\n        return int(n) * (n + 1)\nThis works fine, but it's wrong. You see, the Python interpreter does not in fact return the largest prime factor when you run the program like this:\n>>> n = 13195\n>>>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 1:\n        return 1\n    if n == 1:\n        return 1\n    return largest_prime(n)\nI'm not sure the code really conveys what this function does.  It doesn't return the largest prime factor of n.  It returns the largest prime factor of n which is not also the largest prime factor of 2.\n\nI've got a tiny little implementation here:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n == 0:\n       return 0\n    else:\n       return 1\n    def factorial(n: int):\n    \"\"\"Return the factorial of n.\n    >>> factorial(5)\n    105\n    >>> factorial(36)\n    5!\n    \"\"\"\n    if n == 0:\n       return 1\n    else:\n       return n!\n    def fib(n: int):\n    \"\"\"Return the fibonacci number n.\n    >>> fib(8)\n    5\n    >>> fib(16)\n    21\n    >>> fib(37)\n    89\n    >>> fib(88)\n    13\n    \"\"\"\n    if n == 0:\n       return 1\n    else:\n       return fib(n - 2) + fib(n - 1", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    for i in range(n):\n       if n % i == 0:\n          return n\n    else:\n          return n / i\n    def largest_prime_number(n: int):\n    \"\"\"Return the largest prime number less than or equal to n.\n    >>> largest_prime_number(39)\n    11\n    >>> largest_prime_number(13195)\n    2\n    \"\"\"\n    if n % 2 == 0:\n       return n\n    else:\n       return largest_prime_number(n - 1) + 1\n\nWhat a terrible implementation. It's O(n^2) for a start.\n\nI found this interesting, though it's not clear to me why it's important to be able to do this in a loop, as opposed to just computing a list of primes.\n\nIt's a fun exercise, but I wouldn't have thought it would be very useful to have", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\nThat's not the correct one.\n\nIt is the correct one, if it was a constant instead of a method you would be right.\n\nNo, it's not the correct one.\n\nYou are both right.\n\nThis is an interesting read on how to do a recursive implementation using a stack in a \"naive\" way:\n\nI see that the author uses an \"n * n\" array to hold the partial products. I think a better idea would be to use a \"n * m\" array for a stack.\nThen when you're multiplying, pop one from the stack, multiply it and push it back. When you're dividing, pop one from the stack and push it back. This gives a linear amount of space complexity.\n\nThis doesn't work for many reasons:\n\\- the stack grows from both ends, so the maximum size is n^2.\n\\- each multiplication adds to the stack (which in the case of a power is just the previous result), so the stack grows quadratically.\n\\- stack access is slow, while the accesses to the multiplication array are O(1).\n\nThe stack doesn't grow from both ends.\nIf you've got two arrays,", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    n = int(n)\n    if n > 1:\n        raise ValueError('n must be 1 or less')\n    largest_prime = 1\n    while n!= 1:\n        if n % 2 == 0:\n           largest_prime = largest_prime * n / 2\n           else:\n            largest_prime = largest_prime * n % 2\n         if largest_prime > 1:\n             raise ValueError('largest_prime should be 1 or less')\n    return largest_prime\n\nI just used Python for the first time in years yesterday. Now I can use it to solve the halting problem. :)\n\nWe can solve the halting problem in Haskell too.\n\nWe can solve the halting problem in Brainfuck too.\n\nWe can solve the halting problem in mongolian horse-shoeing code too.\n\nWe can solve", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return n == 1? 1 : n % 2 == 1? 1 : n % 3 == 1? 1 : n % 5 == 1? 1 : n % 7 == 1? 1 : n % 11 == 1? 1 : n % 13 == 1? 1 : n % 17 == 1? 1 : n % 19 == 1? 1 : n % 23 == 1? 1 : n % 29 == 1? 1 : n % 31 == 1? 1 : n % 37 == 1? 1 : n % 41 == 1? 1 : n % 43 == 1? 1 : n % 47 == 1? 1 : n % 53 == 1? 1 : n % 59 == 1? 1 : n % 61 == 1? 1 : n % 67 == 1? 1 : n % 71 == 1? 1 : n % 73 == 1? 1 : n % 79 == 1? 1 : n % 83 == 1? 1 : n % 89 == 1? 1 : n % 97 == 1? 1 : n % 101 == 1? 1 : n % 103 == 1? 1 : n % 107 == 1? 1 : n % 109 == 1? 1 : n % 113 == 1? 1 : n % 119 == 1", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    \"\"\"\n    if n == 0:\n        return 1\n    if n == 1:\n        return n\n    if n > 1:\n        if n % 2 == 0:\n           return n\n           return n % 2 == 1\n         return n\n    \"\"\"\n\nIf we change the comment to:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n % 2 == 1:\n        return n\n    if n % 3 == 1:\n        return n % 3\n    return n % (2**(n-1))\n\nIt could be argued that this is equivalent to a call to  (which, if you're unfamiliar, is used by mathematicians to return the largest prime factor of a number.) This would obviously be faster than your version, but it would also remove the elegance of your code.\n\nI think the author meant to use this instead:\n\nThanks for the correction, I was trying to get to the office and not think.\n\nThe fact that the author used the ternary operator is much more interesting than the fact that he used the modulus", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n == 2:\n       return 1\n    else:\n       return largest_prime_factor(n - 1)\nThis is somewhat interesting because this makes it easy to implement a multiplication operator for large prime numbers.\nFor example, if you wanted to multiply large prime numbers in a programming language such as Python, you could do the following:\n>>> def mul(x, y: int) -> int:\n    \"\"\"Multiply x and y.\n    >>> mul(29, 13195)\n    1324329\n    >>> mul(2048, 13195)\n    1324283\n    \"\"\"\n    if x == 2:\n       return 1\n    else:\n       return x*y\nIf we used this definition of mul instead of the usual definition, then we could multiply large prime numbers in Python.\n\nOh man, you can use this to write a killer PRNG.\n\nInteresting idea. Although I think in most cases you'd rather have a deterministic PRNG, i", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    def largest_prime_factor(n: int):\n    if n == 1:\n       return 1\n    else:\n       n = 2 * n\n       return n / 2", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    # Computing the gcd\n    def gcd(n1, n2: int):\n    \"\"\"Return the greatest common divisor of n1 and n2.\n    >>> gcd(13195, 2048)\n    2048\n    >>> gcd(0, 13195)\n    5\n    \"\"\"\n    # 2 and 3 are prime factors of 13195\n    for p in range(2, 3):\n        if p % 2 == 0:\n           n1, n2 = n1 + p, n1 % p, n2 % p\n        return n1, n2\n    # Take the largest prime factor of n2\n    def largest_prime_factor(n2: int):\n    \"\"\"Return the largest prime factor of n2. Assume n2 > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return 2\nYou've found the largest prime factor of 2048? The largest known prime factor of 2048 is 29.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 1:\n        return 1\n    elif n == 1:\n        return n\n    else:\n        return largest_prime_factor(n - 1)\n    return 1\n\nThis is a good example of why you should not name your variables the same thing as the function.\n\nIt is also a good example of why you should not let your IDE generate your code for you.\n\nI don't think you can blame the IDE for this one. As a developer, you should always be aware of what the code you're about to write means.\n\nIt is quite simple to set up your IDE to show the actual names of things instead of just the variable names. In my experience, almost every IDE has this option, and it's a good idea to turn it on.\n\nMy favorite \"feature\" of Visual Studio is that it will helpfully rename every other method in your class. So, if you have a class called \"Thing\", it will rename all the methods \"ThingThingThingThingThing\", which makes it really easy to", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n\n\nThat's what I said, but in the form of an irrelevant bit of trivia about prime numbers.\n\n(s)he was demonstrating why this fact is not really relevant to the problem.\n\nIf anyone else was wondering the same thing, the one-liner in question is:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\n    \"\"\"\n    largest_prime_factor = lambda p: int(p % n)\n    return largest_prime_factor()\n\n    \"\"\"\n    def largest_prime_factor_in_range(n: int, p: int):\n    \"\"\"Return the largest prime factor in a range of n for which p is a\n    factor.\"\"\"\n    return largest_prime_factor_in_range(n, p)\n\n    \"\"\"\n    def largest_prime_factor_mod(n: int):\n    \"\"\"Return the largest prime factor of n that is a multiple of p. Assume\n    n > 1 and is not a prime.\"\"\"\n    return largest_prime_factor_mod(n, p)\n\n    \"\"\"\n    def largest_prime_factor_in_range_mod(n: int, p: int):\n    \"\"\"Return the largest prime factor in a range of n for which p is a\n    factor.\"\"\"\n    return largest_prime_factor_in_range_mod", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\n    if n == 1:\n        return 1\n    else:\n         return largest_prime_factor(n - 1)\n\nAs a side note, it can be a good idea to use a random number in this function to avoid a situation where one of the factors is 2.\n\nVery neat! Thank you for that!\n\nThat's a bit off-topic, but I find the python community very friendly.\nI've been programming in python for a few months, but I'm still noobish, and have trouble solving problems. I can do trivial stuff like \"import this, that, and the other thing\" and that's about it.\nI asked a question here on HN a few weeks ago, and I got answers in the form of python code from a couple of people. And people responded to my comment in a friendly manner, with the usual \"I'm no expert, but...\".\nSo, thanks! The python community rocks.\n\nI am pretty new to python but I can relate to the \"friendly community\". One of the things that I like about python is that it's easy to write things like this", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n       return n % 2\n    return (n-1) % 2\n\n>>> largest_prime_factor(13195)\n29\n>>> largest_prime_factor(2048)\n2\n>>> largest_prime_factor(2889)\n1\n\nNote how the compiler doesn't care about the difference between expressions\nlike this:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n == 1:\n       return 1\n    if n == 2:\n       return 2\n    if n == 3:\n       return 3\n    if n == 5:\n       return 5\n    return largest_prime_factor(n - 1)", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(3)\n    3\n    >>> largest_prime_factor(10)\n    2\n    \"\"\"\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def largest_prime_factor(n", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n        if n % 2 == 0:\n           n = (n / 2) % 2\n          return n\n        else:\n          n = (n - 1) % 2\n          return n\n        else:\n          raise RuntimeError, 'n must be a positive integer.'\n\nThank you!\n\nI'm going to go out on a limb and guess that the first n-1 numbers in your list are 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        return largest_prime_factor(n - 1)\n\nWhat is the point of the last if statement? The code after the else is definitely going to be true, but the code after the if is also definitely going to be true.\n\nThat is an excellent question and I thank you for asking it.\nI was feeling lazy and so I copied and pasted the same block of code twice.\n\nYou should have used the ternary operator for the last if.\n\nNice, but the last if statement is redundant.\n\nI agree.\n\nWell you could change it to the ternary operator so it would be:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n == 1:\n        return 1\n    return n ** (n - 1)\nIf the author's purpose was to implement a new, optimized version of this, he did a horrible job. He's basically just reimplemented Python's `factorial` function.\n\nWhat is the purpose of this?\nIt is a simple example of how to implement a generic algorithm that can be run on any data type.\n\nThere are many, much better ways to do this, and this one is pretty inefficient. I guess if you only care about the answer and not the performance, this could be useful for you.\n\nI see. Could you point me to a resource that explains the \"better\" ways?\n\nI don't think there is any good tutorial for it. But you can look at python's factorial, java's Math.pow, or C's pow() to see how they do it.\n\nI would not use this in production.\nIf you want to do it yourself, you could use a prime decomposition algorithm to produce a list of factors. You could then use the Levenshtein distance to find the optimal distance between the factors", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def largest_prime_factor", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n        return n\n    else:\n        if n % 2 == 0:\n            return n % 2\n        else:\n            return n % 2\n    return n\nI like it, but I don't think it's fast enough. How about:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n        return largest_prime_factor(n - 1)\n    else:\n        return n\nI don't understand. It's not for prime numbers only?\n\nI believe that's because the author of the blog post is trying to show how to implement primality testing in Python.\n\nI think that's the case too, but even so, I'm not sure what to make of that. The largest_prime_factor function _as written_ can give you the prime factor of any integer, not just the prime ones. I'm not sure what the utility of that is.\n\nIt's a solution to the problem of \"give me the largest prime factor of n\".\n\nYes, it is, but you can also do that using a prime number.\n\nNot if n is prime.\n\nYes, you can. The largest prime factor of a prime number is itself.\n\nThe point is that you can't use the \"largest prime factor of n\" algorithm in that case, and this function provides the same functionality.\n\nThe function is not a solution to that problem. The largest prime", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    def __init__(self, n: int):\n        self.n = n\n        print(n)\n        self.n_is_prime = False\n        def largest_prime_factor(self, i: int):\n        i = self.n_is_prime\n        if i == 1:\n            return self.n.rjust(i)\n           i = self.n_is_prime\n           return self.n_is_prime + 1\n         if i > 1:\n            return self.n_is_prime - 1\n         i = self.n_is_prime\n         return self.n_is_prime + 1\n    def _is_prime(x:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    n = int(raw_input(\"Enter an integer: \"))\n    if n == 1:\n        return 1\n    p = int(raw_input(\"Enter the factor: \"))\n    if p == 1:\n        return p\n    if p > 1:\n        if n % p == 0:\n           return n\n           p = n / p\n    else:\n           return n\n    return largest_prime_factor(n % p)\nThis is a bad idea, since the code is not using modular arithmetic and relies on multiple integer division by p. This code will round the result up to the next integer.\nJust iterate through the prime factors of n, and remove the multiples of p that show up. Then you will get the correct answer.  If the prime factors are not known, you can still do this, since the only integers that remain are the ones that you can add to", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    result = 0\n    for i in range(2, n+2):\n        if (n % i!= 0) or (n % i == 0 and i == 0):\n            result = result + 1\n    return result\nI don't get this.  I get:\n>>> largest_prime_factor(13195)\n0\n>>> largest_prime_factor(13195)\n1\n> Although there's probably something I don't understand here, there's a\n> python module for that:\n>http://www.inference.phy.cam.ac.uk/python/libs/numberexpr.html\n> Is it possible to add this to the standard library?\nIt's unlikely this is going to be added to the standard library.\nnumberexpr.py is from a different branch of python and I don't think\nthat any of the core developers think it's a good idea to mix and match\nbetween the two versions of the language.\n--\nRobert Kern\n\"I have come to believe that the whole world is an enigma", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n        return n\n    else:\n        if n % 2!= 1:\n           return n\n        if n % 2 == 1:\n           return n\n    else:\n        return 1", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\n    def largest_prime_factor_2(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor_2(13195)\n    29\n    >>> largest_prime_factor_2(2048)\n    2\n    \"\"\"\n\nJust in case anyone doesn't know, this is the correct way to write code.\n\nLOL, no. You have no idea what you are talking about.", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n >= 1:\n        n = n - 1\n    return n % 2\nThis is a good example of a small program that might be run 10,000 times a day for a long time.  If there was a bug in it, and you knew it would run 10,000 times a day for a long time, would you really want to fix the bug in the first version?  Or would you just go with it?\nI'd go with it.  I'd go with it hard.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return (n * (n % 2) + 1) % 2\n\nSo, what makes this efficient? Is it the integer division or the fact that you do the division only once?\n\nNeither. What makes this efficient is that it's using a tight loop and uses the fast built-in function factor to compute the factorization of the number.\n\nThe only thing it's doing more than once is the integer division, which is only efficient if you're running it on a large number (i.e. not just 2), and if your integer division is fast enough. If you've got a large number you're trying to factor, it's not an unreasonable assumption that you're probably not using 2.\n\nNote that there's no problem with testing divisibility by 2 (or 5, or any other number) when you're dealing with a large number, as long as you don't actually bother calculating the divisor if it's not needed.\n\nIt's because factor() is an intrinsic function and is much faster than f2().\n\nI thought that as well, but I ran the exact same code with Cython, and it was faster in Cython. So it's a little bit more", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 2:\n        return 1\n    if n == 2:\n        return 1\n    if n >= 2:\n        return n % 2\nThe code is obviously broken, but it's not at all clear that it's a matter of it being bad code.\nThis is a typical example of a wrong solution to a problem with an undefined question. What exactly is the \"largest prime factor\"? It could mean \"the largest prime factor that is not a multiple of any of the other prime factors\", or it could mean \"the largest prime factor that is not a power of any of the other prime factors\". The only way to unambiguously determine the desired meaning is to specify the problem, which is usually done through a test case.\nIn my opinion, the code is not bad, it's incomplete.\n\nI think it's pretty clear that the second definition is intended:\n>It could mean \"the largest prime factor that is not a power of any of the other prime factors\"\nIn other words, the largest prime factor that is a prime.\n\nI agree. There is no ambiguity", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 1:\n        return 1\n    if n % 2 == 0:\n        return n\n    else:\n        return n - 1\n\nYou missed an important case, and the code is pretty buggy anyway.\nFor example, consider 2^30 - 1. The largest prime factor of 2^30 is 2^29, and you can't subtract 1 from 2^29, so the program will never terminate.\nThe correct answer (and, in fact, the answer in the code) is that the largest prime factor of 2^30 is 2^(2^30-1), and since 2^(2^30-1) is not a prime, the code will never terminate.\n\nI see that, but at the same time it would be almost impossible to find a case that would not terminate, and when the function is actually used in a real program, it's usually for a number with lots of factors.\n\nThis is a really common error when people are writing code like this, and it's a mistake because it's really easy to make a mistake. Your code should", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    for n in range(0,(1 + 1 * e)):\n        if n % p == 1:\n            return n\n    return 1\n\nfor n in range(0,(1 + 1 * e)):\n    if n % p == 1:\n        return n\n    return 1", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n == 1:\n       return 1\n    return largest_prime_factor(n - 1)\nI'm not sure why you're returning 29 and 2, I think the idea is to return the largest prime factor?  So I think this will give you 35 and 3</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return n == 1? 1 : (largest_prime_factor(n - 1) + 1) % n", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    largest_prime = [x for x in range(2, n) if x % n == 0]\n    if n == 2:\n        return largest_prime\n    else:\n        return largest_prime_factor(n - 2)\n\nSee also\n Big O notation\n Prime factorization\n\nExternal links\n Python: Big-O Notation</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n >= 0:\n        return n\n    else:\n        return 2\nI guess the code is correct but I wouldn't write it like that. I'd write it like this:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n       return largest_prime_factor(n - 1)\nThat's some rock solid code right there.\nBut seriously, you'd think the author of such a well-written program would not have so many typos in their text.\nI would guess he wrote the code and the blog post separately, or perhaps wrote the blog post first and then used the same text for the example code.\nYeah, that makes sense. It still seems like there should be some sort of spell-checker for text that's used in code.\nHe probably wrote the code in a different language that doesn't have a spell checker. (unless he's using a text editor that doesn't have one)</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\n    n = int(input('Enter a positive integer: '))\n    if n < 1 or n % 2:\n        return 0\n    if n % 2!= 0 and n % 2!= 1:\n        return 0\n    if n % 2 == 0:\n        return largest_prime_factor(n - 1)\n    if n % 2 == 1:\n        return largest_prime_factor(n - 2)\n    if n % 2 == 2:\n        return largest_prime_factor(n - 3)\n    if n % 2 == 3:\n        return largest_prime_factor(n - 4)\n    if n % 2 == 4:\n        return largest_prime_factor(n - 5)\n    return largest_prime_factor(n - 2) + 1\n\n    print('The largest prime factor of %d is %s.' % (n, largest", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return n % (2**n - 1)", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    for i in range(1,n+2):\n        if n % i == 0 and i!= 2:\n           return i\n    return -1\n\nI think it's supposed to return the greatest prime factor, not the largest prime factor.\nIt's not a bug, it's a feature!\n\nYes, but it could return the smallest prime factor. Or it could crash!\n\nIf the largest prime factor was also the greatest prime factor, it would be returning itself.\nThat is the feature.\n\nIt would be returning itself in the case where the greatest prime factor was the largest prime factor, but not in general.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 2:\n        return n\n    else:\n        n = int(n)\n        largest_prime_factor = n % int(n)\n\nI was immediately thinking that the algorithm might be too simple to be useful, but it really isn't, at least not for me.\nThis is a classic algorithm for finding the largest prime factor of a number.\nBut my python programming style is to do the following:\nvar largest = 1\nwhile largest < n:\nlargest = largest / n\nn = largest\nreturn largest\nI guess I'm doing this because I'm so used to short-circuiting, but maybe I should take a closer look at the syntax of Python, if it allows me to write code like this.\n\nIsn't that the same as:\nwhile largest < n:\nlargest = largest / n", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n == 1:\n       return 1\n    if n > 1:\n       return 2\n\nUsing (a little bit) of recursion, we can do it in O(n) time.", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n         def largest_prime_factor(n: int):\n           if n > 1:\n              return len(n - 1)\n           else:\n              return n - 1\n\n>>> largest_prime_factor(13195)\n29\n>>> largest_prime_factor(2048)\n2\n\nWhat was the point of posting this?</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return n\nIf n is not prime, the function is always returning 2.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 2:\n        return 1\n    n = n / 2\n    if n > 1 and n % 2 == 0:\n        n = n / 2\n    return n % largest_prime_factor(n-1)\n\nInteresting.\n\nIt's a very common pattern in C, and Perl.\n\nIs it a common pattern in the wild?\n\nIt's very common in the financial industry, because of the division into buckets for options and the like.\n\nand in the realm of generating prime numbers.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\nOne more:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 2:\n        return 1\n    else:\n        if n % 2 == 0:\n           return n % 2\n    else:\n         return largest_prime_factor(n - 1)\n    return largest_prime_factor(n)\n> largest_prime_factor(13195)\n29\n> largest_prime_factor(2048)\n2\nThe top answer has an error. The code should be:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n        return n > 1\n    return 2 if n < 2\n    return int(n) if n < 1\n\nOr use this factoring function (which is not the same as largest_prime_factor)", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n is not None:\n        largest_prime_factor = []\n    for i in range(2,n):\n        if n % i == 0:\n           largest_prime_factor.append(i)\n        return largest_prime_factor\n> import math\n>\n> math.largest_prime_factor(13195)\n>\n>\nThe sad thing is that you actually had to write that to get people to understand why this is a bad idea.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n >= 1:\n        return n\n    return 2\nIn Python it's just:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\n    return (n == 1 and n % n == 0 and n / (n % n) == 0)\n\nI've just posted a new entry that I think is a bit better (and is not merely a port from Python). It is based on Paul's original code and improves it in a number of ways.\n\nIt is slightly faster than the other solutions, it uses a bit less memory, and it has a lot more comments to explain the code.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    def largest_prime_factor(n: int):\n    if n == 0 or n == 1:\n       return n\n    else:\n       return largest_prime_factor(n - 1)\n\nUnless I'm missing something, the code doesn't check for primes at all?\n\nIt's an attempt to demonstrate that OO is a powerful tool which is not always the correct tool.\n\nI think that one of the interesting things about OO is that it's a tool that's easy to use in the wrong way. It's very easy to say, \"You know, I want to do X, and there's already a class for Y, so I'll just make a subclass of Y, and then modify the method I want.\" It's also very easy to make a class that doesn't do anything, and it's easy to name things in an ad-hoc way that isn't very informative about what they do.\nOn the other hand, it's also easy to use OO to _prevent_ yourself from doing stupid things like creating a lot of global state or using some other workaround for a problem that O", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    a = 2\n    b = 3\n    for i in range(n - 1):\n        if n % i == 0:\n           a = a * i\n           b = b * i\n    return a\nI think you should return 2 and 3 here.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    def __call__(self, n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    n = int(n)\n    if n is not None and not int(n) % 2 == 1:\n       if n is even:\n         return n\n       else:\n         return 2 * n\n\nYou can also use a memoized version of this that doesn't rely on a lookup table, and instead uses the so-called \"primality testing trick\".", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 2:\n       return 1\n    for i in range(0, n):\n       if n % i == 0:\n          return i\n    return n\n>From where I stand, this is not really a Pythonic solution. It's doing a lot of branching and is rather inefficient. The algorithm for finding the largest prime factor is well known, and there are plenty of primality testers out there.\nYou can use the is_prime() function as a trivial example of a prime tester, if you are curious about how they work.\n\nHe's not asking for the largest prime factor of a number, he's asking for the largest prime that is a factor of that number.\n\nI re-read the OP a few times, and I must have missed the \"largest prime that is a factor\" part. Thanks for the correction.\n\nOh, I didn't realise that there was an actual algorithm for doing this. I thought it was a bit like the factorial function, i.e. no known algorithmic solution. My bad.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n == 1:\n       return n\n    else:\n       if n == 2:\n         return n * n\n       else:\n         if n == 3:\n            return 3 * n * n\n        else:\n            return n * (n - 1)", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\nThis is super useful, but I couldn't help but feel the following is a little bit more readable:\n>>> from math import *\n>>> def largest_prime_factor(n: int):\n    if n == 1 or n == 0:\n        return 1\n    return Math.pow(2, n)\n>>> largest_prime_factor(13195)\n29\n>>> largest_prime_factor(2048)\n2\n\nI think the first line is redundant, and the second line is actually more readable (in my opinion) because it specifies the type of the second argument, rather than assuming an int (which, according to the docs, is an alias for float).\n\nIt's a shame that Python and Ruby don't have a good solution for large numbers.\nPython has long since broken integers with a float, but it's a shame that it doesn't have a library to address the issue.\nRuby and Python both seem to be designed for conciseness over readability, and I think that the lack of good libraries for these issues is evidence of that.\n\nI would not say Python and Ruby are lacking in readability. In fact", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return 3 * 2 * n ** 3\nI don't know about you, but the code for largest_prime_factor() looks\npretty good to me.\n\nYou are so wrong.\nDon't you see that the most important thing is to have good names and a\nclear structure? Look at the above code. Do you think it's easy to read?\nWhy do you want to make it difficult for people to read your code? You want\npeople to read your code, right?\nIf you are not convinced by this argument, I'm afraid you're still in the\nwrong path. Try to look at the code in this web page:\n<\n\nYou're not reading the code in the same way I'm not reading the code you\nlinked to.\nYou see \"print\" and \"factorial\". I see \"factorial\", \"n\", and \"print\".\nI agree that \"n\" isn't as readable as \"factorial\", but that's not a big\ndeal because the naming convention is established elsewhere. \"print\" is a\nlittle verbose, but that's not a problem for me because I know what it\nmeans. I'm not very surprised to see a", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return (n%p) == 0\nThis function won't work for a lot of the inputs it's given. It will return True for 13195 and 2048, but it will also return True for 13193, 1, and 1, which I'm guessing is not what the author intended.\n\nI think the author wanted it to return the largest prime factor that is less than the input.\n\nYou're right. I missed that, thanks.\n\nI'm guessing this was posted as a joke, because it's incorrect.\n\nIt's correct for positive integers.\n\nI would have expected a better submission from a site named 'hackernews'. It's not a hack. This is the kind of thing a good algorithm textbook will present as an exercise.\n\nYou need to have an advanced degree in mathematics to use this?\n\nNo, but you need to know that n%p!= 0 only holds for 1 and p.\n\nThat's what I was thinking, but the author said that's not what he meant.\n\nThere are other solutions to this problem in PHP.\n\nwell, I think this is just a joke.\n\nI don't.\nI posted this because I", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n       if n > 1 and is not a prime:\n         return (n - 1)\n    else:\n         return (n)\nDoes this work? \n\nIt does not, because n - 1 is not a prime.\n\nYes, the problem is that it doesn't take into account that for a non-prime number, the largest prime factor is always the number itself.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return (n ** (n >>> 1)) | (n >>> 2)\nI'm not sure that's the right way to do it.\nEDIT: I should add that I'm not sure it's the _fastest_ way to do it.  It's the _easiest_ way to do it.  It's hard to write a brute force algorithm that's as easy to understand as this one.\n\nNote that in Python, any integer can be considered a power of two, so the result could be very different in other languages.\n\nYes, I guess I should have emphasized that it's a bit tricky to write a brute force algorithm that's easy to read.\n\nHow is this a 'brute force' algorithm?\n\nIt's not, it's a divide-and-conquer.\n\nWhere does \"divide-and-conquer\" come from? I think \"brute force\" is a good term here. You're hitting every possible value of n until you get the right answer.\n\nBrute force would be something like iterating through all numbers from 1 to n until you find the correct answer. Divide-and-conquer would be something like finding the factors", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n         return largest_prime_factor(n-1)\n    return n", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n!= 1:\n        return largest_prime_factor(n - 1)\n    else:\n        return 1\nWow, that's a pretty clever algorithm!</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    n = n // 2\n    while n < 2 ** k:\n        if n % 2 == 0:\n           return n % 2 // 2\n           n += 2\n    return k // n\nI'm not seeing the bug.\n\n<facepalm>\nThe bug is that the documentation says it returns the largest prime factor of n, but the code checks whether n is prime.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    n = int(input(\"Enter the number to test (positive integer): \"))\n    if n < 1:\n        print(\"Enter a number greater than 1.\\n\")\n    return 1\n    else:\n        if n == 1:\n            print(\"1 is a prime.\\n\")\n        return 1\n        if n == -1:\n             print(\"-1 is not a prime.\\n\")\n        return 1\n    else:\n        return n", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return (n - 1)\nIf you assume it is not a prime, then it will be a prime.\nHeh, yeah. You're right. I guess it's more along the lines of \"return the largest prime factor of n, assuming that n is not prime.\"</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\nPython 3.0 introduced a new type of array. When the range is known, this is\na list. When the range is unknown, it is a tuple. Lists and tuples are\nequivalent, so there is no way to tell which type is being used.\n\nIn Python 3, tuples are immutable. This means you can't change any of\ntheir values. You can't even assign a new value to one of the fields.\nThis is the reason that the method above returns a tuple rather than a\nlist.\n\nPython 2 has a different syntax for tuples. The above is equivalent to:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def largest_prime_factor", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    n_prime = 2\n    if n == 1:\n        return n\n    else:\n        for p in range(n):\n          if p % n == 0:\n             return p\n    return n_prime\nI also see that a little change of name can make the code more readable:   def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    return n\nIt's rare that you'll want to return the original value, and in this case it's obvious what the function is doing.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n        return largest_prime_factor(n-1)\n> n=21\n> largest_prime_factor(n)\n> Traceback (most recent call last):\n> File \"<stdin>\", line 1, in <module>\n> File \"<stdin>\", line 2, in largest_prime_factor\n> return largest_prime_factor(n-1)\n> IndexError: list index out of range\n>\n> Did I do something wrong?\n>\n> Thanks,\n> James\nThis is a nice example of why it's often a good idea to start with a\nsmaller program that does what you want and then gradually build up to a\nlarger program.\nYour first attempt to build the program was successful. The code you\nsubmitted does exactly what you intended, because you left out a detail\nthat you now want to add.\nThat missing detail is the case where n > 1. When n > 1, you're trying to\nfind the largest factor of a number which itself is a factor. To put\nthat another way, when n > 1, you're trying to find the", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return n % factorial(n)</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n >= 2:\n        return 2\n    return n * largest_prime_factor(n - 1)", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n        if n % 2 == 1:\n           return n\n    else:\n        if n % 3 == 1:\n           return n\n    else:\n        if n % 5 == 1:\n           return n\n    else:\n        if n % 7 == 1:\n           return n\n    else:\n        if n % 11 == 1:\n           return n\n    else:\n        if n % 13 == 1:\n           return n\n    else:\n        return n\n\nThis is terrible code.\n\nOnly if you're not using BigInt</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 1:\n        return 1\n    else:\n        return n == 1? n : (n > 1? 1 : n) % n\nI don't think so. It can't return a prime. Also, it can return multiple values, i.e. it's not a number.\n\nThe question is not about how to implement the function, but about what's the largest prime factor of your favourite number.\n\nMy point was that you can't determine the largest prime factor of n if you don't know whether n is prime.\n\nThen you could have just said that, rather than being smart-ass and nitpicking.\n\nNitpicking? That was the entire point of my post.\n\nI think you missed the point of the exercise.\n\nI was just amused by the fact that OP claimed the function would return the largest prime factor of any number, which is clearly not the case.\n\nI'm sure it's a mistake in the question - if the function is supposed to take a number and return the largest prime factor of that number, it would be undefined, but if the function is supposed to", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\n    print \"Largest prime factor of\", n, \"\\n\"\n\n    if n == 0:\n        print \"n is zero.\"\n    return 0\n    else:\n        print \"\\tPrime factor of \", n\n        if n == 2:\n           print \"n is a prime.\"\n           return 2\n           print \"largest prime factor of \", n, \"\\n\"\n           print \"\\tPrime factor of \", n / 2, \"\\n\"\n           print \"largest prime factor of \", n % 2, \"\\n\"\n           print \"\\tPrime factor of \", n / 3, \"\\n\"\n           print \"largest prime factor of \", n % 3, \"\\n\"\n           print \"largest prime factor of \", n /", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1 and n!= 2:\n        n = 2\n    return 1.0 if n is prime\n    return largest_prime_factor(n - 1)\nThe function is intended to return the largest prime factor of n, if n is odd, n is even.\n> def largest_prime_factor(n: int):\n> if n > 1 and n!= 2:\n> return 1.0 if n is prime\n> return largest_prime_factor(n - 1)\nThe second and third lines are identical, and the second one is not needed because of that.\n> def largest_prime_factor(n: int):\n> if n > 1:\n> return 1.0 if n is prime\n> return largest_prime_factor(n - 1)\n> print(largest_prime_factor(2048))\n2\n\nIf you don't like this syntax, you can use a decorator:\nfrom functools import wraps", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return 1 if n % 2 else n ** 2 - 1\nI could be wrong, but that's what I see.\n\nAuthor here: you're right, thanks for spotting this.\n\nI'd recommend changing that to:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n!= 1:\n        print \"n is not a prime number\"\n    return 1\nI don't understand why it returns 1. Is it because the for loop is never going to reach the last value?\nThat's the joke; the method itself is a lie. It doesn't return the largest prime factor of n, but just always returns 1.\nI like the code more if it would actually return the largest prime factor of n.\nIt would be hard to implement it in a language like Python.  I guess it could be done, but the result would be so slow as to be useless for any real world applications.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    largest_prime_factor = lambda n:\n        if n > 1:\n           return n % n // n\n    else:\n           return (n % n) // n\n   \nIt's a bit more elegant with the lambda.\n\nx = lambda n: int(n)\n\nThe factorial example is a special case of the binomial theorem.\n\nIt's a bit more elegant with the lambda.\nIn general, you want to use x = lambda n: n.\n\nYeah, it's the same. I always used to write it this way though. I guess this is an example of code golf, but I didn't mean to do that. I just think this is how I like to write lambda's.\n\nWeird, I always do it the other way around. But I'm not a CS person, I do more logic and formal language theory.\n\nNot to be confused with _largest_ prime factor, which is much easier.\n\nThis is a really great illustration of the mathematical elegance of Python.\n\nHow is", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n        return n % (n - 1)\n    else:\n        return n\nHuh? That is an awful function.  It fails for any number that is a multiple of any prime.  It should return n/n!.\n\nIt is only guaranteed to fail on numbers that are also factors of one of the smaller primes, and only if you call it with one of those numbers. This is a reasonable function (and easy to implement) for an inexperienced programmer.\n\nIt's not a reasonable function because it is wrong. It returns the wrong answer for numbers which are a multiple of some prime.\nIt's a reasonable function for an inexperienced programmer. So is the quadratic formula. But neither one is a reasonable function in general.\n\nI didn't say it was a reasonable function in general, just reasonable for an inexperienced programmer.\n\nIf you want to be pedantic, you said \"it's only guaranteed to fail on numbers that are also factors of one of the smaller primes.\" In fact it is guaranteed to fail on numbers that are a multiple of some prime no matter what.\n\nNo", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n       return n % max(0, (2**(n+1) - 1))\n    else:\n       return n\n\nNice. I'll update the post.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n        if n % 3 == 1:\n           return 2\n         else:\n           return n - (n % 2)\nI'd use an numpy.ndarray and use the isprime method.\nThis is more in the spirit of how to write pythonic code: you need a loop to calculate the largest prime factor of a number, but you don't need a loop to check if it's prime or not.\nWhat is pythonic about it?\nThe _only_ thing pythonic about it is the fact that he's using python.  It's a silly and subjective term.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return largest_prime_factor_for_int(n)\nThis is a very bad implementation.  It is designed to not find a large prime when the number is not a prime.  A better implementation would be:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n == 1:\n        return 1\n    else:\n        for i in range(1, n - 1):\n           if n % i == 0:\n              return n / i\n    return n\n\nThe code as it is now is basically an exercise in how to write (what could be) a correct, well-factored program in Python. It's not an exercise in code clarity, however, and it's a good example of why Python is not the best choice for programs that are larger than a few hundred lines of code.\n\nIt's not a real-world program, either. Can you imagine a program that would actually have to compute the largest prime factor of 20,000 numbers? And what if you had to get the largest prime factor of several million numbers?\n\nThe code is broken up in a way that makes it hard to understand what the code is doing. That's bad programming style, and not a particularly Python-specific problem.\n\nThe real reason Python is not a good choice for programs", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return n % 2 == 0\nI'm not a python guy, but isn't this easily factored as long as you know that n >= 2?\n\nI agree this is rather trivial. You'd probably want something like:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n!= 1:\n        return largest_prime_factor(n - 1)\n    elif n < 1:\n        return largest_prime_factor(n + 1)\n    else:\n        return n\nThis is completely useless without testing. There are a lot of programs that will run for a really long time before finding a prime factor of a large number.\nThe entire thing is useless, really.\n\nWhat do you mean by testing? Of course it is useless, that was the point.\n\nI'm guessing \"testing\" refers to proving that this will always return the correct answer.\nI believe the parent is correct to suggest that this code is useless, because we have no assurance that the code works as advertised. For example, what if there is a bug and the code fails to run in a timely manner?\n\n>>> largest_prime_factor(8332)\n1339\n>>> largest_prime_factor(8332 - 1)\n1340\n>>> largest_prime_factor(8332)\n1339\n>>> largest_prime_factor(8332", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    from math import *\n    def largest_prime(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime(13195)\n    29\n    >>> largest_prime(2048)\n    2\n    \"\"\"\n    return (n % 2) ** 2\n\nOops, meant to post that here:\n\nThis is awesome. The next step is to use the prime factorization to generate a random number seed. Then, the program becomes truly random.\n\nI've been doing that with Ruby for a while.\n\nI've been doing it with C#, the code looks like this:\nprivate static long Generate(int size) {\n\tlong seed;\n\tRandom rnd;\n\tfor (int i = 0; i < size; i++) {\n\t\tseed = rnd.NextLong();\n\t\trnd.Next(seed);\n\t}\n\treturn seed;\n}\n\nThere's also the article posted yesterday about a program for generating a random number based on", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n        return n % lcm(n-1, 2)\n    else:\n        return 1\nI'm not sure it's correct to assume that n is not prime.  I think this can be proven false.\n\nThis is the canonical version. See, for example:\n\nI don't see why you would assume it is not a prime in the first place.\n\nI think there is a misunderstanding: the statement is not \"n is not prime\", it's \"n is not _a prime_ \". This is because there are plenty of numbers that are not prime but have the property that you can't factor them into prime numbers.\n\nI did read it wrong. I agree.\n\nI have to admit, I'm not getting it. Why would you return n%lcm(n-1,2)? I.e. the largest factor of n that is smaller than 2?\n\nI don't think it's right to return the largest prime factor of a number that's not prime. (This is mentioned in the article, but I'm not sure why it's in there.)", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    for p in range(2, n - 1):\n        if p < n:\n           return p\n        else:\n           return p % n\nNot sure if it's a bug or not, but I'm getting the result 4 for this:\n>>> largest_prime_factor(2048)\n2\n\nI think the test for divisibility with the smallest prime factors is unnecessary and might be the source of the error. It also means that the result is never 0, which would be more in line with other similar functions (i.e. the sqrt function).\n\nYes, it's unnecessary. I'd bet on a bug. The algorithm is not difficult, but it's not trivial. For example, for a number n it might be that the largest prime factor is 0. But the algorithm above can't distinguish that case from one where the largest prime factor is 1.\n\nOn the other hand, it is trivial to check the divisibility by the largest prime factor. It is also likely to be fast, since you can just loop over", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 0:\n        return n % 2\n    else:\n        return n\nNote that, with these definitions, this function is the *only* prime factor function that is guaranteed to terminate for all inputs (assuming n >= 1).\n\nThe GIL is a wonderful thing.\n\nIt's a fun trick, but in my opinion Python's default integer type is ill-suited for this task. In particular, integers are not guaranteed to be exact, and Python has no way of testing that a given integer is exact.\n\nI thought python's integer type was a 64 bit floating point number, which is exactly what I would want for this sort of thing.\n\nCorrect. It's a 32-bit IEEE 754 floating point type. The problem is, Python doesn't guarantee that two integers compare equal.\n\nYes, but that doesn't really matter in this case. The only time it would matter is if you used this to build a big number library (like GMP). In this case, you'd have to make sure that the results of this function were accurate.\n\nIt does matter in this case. You don", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 1:\n        return n\n    factor = (2**n - 1).get(0)\n    if factor == 0:\n        return factor\n    return largest_prime_factor(n - 1)\n\nThe code above works. The code is really easy to read. But I'm not sure whether it's correct. I'm wondering if it's correct for the following reason:\n\nConsider a case where n is a prime. For instance, the only prime factors of 13195 are 2 and 5. It's clear that largest_prime_factor(13195) will return 5. However, the code also shows that it will return 29. In other words, it will return the largest prime factor of 13195 minus 1.\n\nBut shouldn't the code in fact return 1 instead of 29? After all, it's clear that the largest prime factor of 13195 is 2. So shouldn't largest_prime_factor(13195) return 2 rather than 29?\n\nIs there something in the language specification that allows for this behavior? Or is there something wrong with the code above?", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    print 'n = {0}, g = {1}'\n    print 'p = {2}'\n    return 2*g-1\n\nThat's a bit slow...\n\nAlthough if it's a one-off, there's an easy way around that:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    def largest_prime_factor(n: int):\n    if n == 1 or n == 2:\n       return 1\n    return n if n < 2\n    n = n - 1\n    if n == 0 or n == 1:\n       return n\n    if n > 1:\n       if n <= 2:\n          n = n - 1\n          return n\n       else:\n          if n == 0:\n              return n\n       else:\n              if n == 1:\n                 return n\n              else:\n                n = 2 * n\n    return n", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\n>>> largest_prime_factor(100)\n29\n\n>>> largest_prime_factor(10)\n2\n\n>>> largest_prime_factor(5)\n2\n\n>>> largest_prime_factor(4)\n2\n\n>>> largest_prime_factor(1)\n1\n\n>>> largest_prime_factor(2)\n2\n\n>>> largest_prime_factor(3)\n3\n\n>>> largest_prime_factor(5)\n2\n\n>>> largest_prime_factor(7)\n7\n\n>>> largest_prime_factor(6)\n2\n\n>>> largest_prime_factor(8)\n2\n\n>>> largest_prime_factor(9)\n3\n\n>>> largest_prime_factor(6)\n2\n\n>>> largest_prime_factor(11)\n11\n\n>>> largest_prime_factor(12)\n12\n\n>>> largest_prime_factor(10)\n2\n\n>>> largest_prime_factor(13)\n13\n\n>>> largest_prime_factor(14)\n14\n\n>>> largest_prime_factor(15)\n15\n\n>>> largest_prime_factor(", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 2:\n        return 2\n    else:\n        return largest_prime_factor(n - 1)\nAnd now I'm thinking I could have added a comment to explain that it stops at 2.\nI was working from a similar snippet posted here a few weeks ago.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\n    if n < 1:\n        return 1\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    if n == 3:\n        return 3\n    if n == 4:\n        return 4\n    if n == 5:\n        return 5\n    if n == 6:\n        return 6\n    if n == 7:\n        return 7\n    if n == 8:\n        return 8\n    if n == 9:\n        return 9\n    if n == 10:\n        return 10\n    if n == 11:\n        return 11\n    if n == 12:\n        return 12\n    if n == 13:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\n    # If n is prime return 0\n    if n == 1:\n        return 0\n    else:\n        # Return the largest prime factor\n        for i in range(2, n):\n           if n % i == 0:\n               return i\n           return 0\n\n    # If n is a composite, return the largest prime factor\n    if n is not None and n!= 0:\n        # Return the largest prime factor\n        for i in range(2, n - 1):\n           if n % i == 0:\n               return i\n           return 0\n    return n\n\nPython", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n >= 2:\n        return n\n    else:\n        return largest_prime_factor(n-1)\nDo people just use this as a demonstration of how to write a Python function? Or are they using it to help them solve a problem that a C program can solve in an instant?\n\nThe latter. Searching for the largest prime factor of a number can be a long process on a CPU. This is why the computer science department at my university uses a fairly hefty machine (and a huge monitor) to run the largest prime factor algorithm for a problem.\n\nWouldn't it be a lot more efficient to just use the Miller-Rabin primality test?\n\nIt's not a lot faster. If you use GMP, it'll probably be slower.\n\nI find it really hard to believe that a pure Python function is faster than an optimized C implementation. I would love to see some benchmarks.\n\nI found the following at\nI am not sure how to interpret the data (or lack thereof).\n\nIn this case it's pretty clear that for very large numbers, the Python method is not very efficient", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n <= 2:\n        return n\n    return n % 2 == 1\nThe naive implementation of largest_prime_factor takes n and checks if it's prime.  If it's not prime, it returns n.  If it's prime, it checks if it's n % 2.  If it is, it returns n.  And that's it.  Not very efficient.  I mean, it's slow.  Not only does it need to check if n is prime, but it needs to check if it's a power of 2.  If you have a lot of these to do, this will slow things down.  Instead of testing if it's a power of 2, and if it is, checking if it's a multiple of 2, we can use an efficient algorithm called the Chinese Remainder Theorem.\n\nWe'll define a function called power_of_2(x) which returns true if x is a power of 2.", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return n % 2\nAhhh, I really love the fact that this is a python answer.   Also, someone else's comment about the use of \"the\" is spot on.\nI like that it's a python answer as well, but I don't get why it is. Is there something python-specific about the code?\nThere's something about the general sentiment that comes with python. Python was the first language I learned, and it was the first time I really felt like I was starting to understand programming. It's just simple and easy to learn.  Plus, it's fun to play with.\nAgreed, python is like the friend that doesn't judge you and just lets you do your thing.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n == 2:\n        return 2\n    else:\n        return 2 ** n\nCool, although the number of implementations on that page is a little annoying...\n\nIt's not annoying. It's a nice page, the problem is that the page title contains a word \"all\" when the page itself doesn't cover all of those algorithms, yet.\n\nYes, I'm aware of that. That's why I said \"a little annoying\" instead of \"extremely annoying\".</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return n > 1 and n % 2 == 0\n\nI don't see the point of this. It's not like it's a surprise that the largest prime factor of a number n is the greatest factor that divides n without being a factor of n.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 2:\n        return 1\n    n = n ** 2\n    return largest_prime_factor(n - 1)\nThank you for this - very helpful.\nI found this on stackoverflow and it's now part of my standard library!</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n % 2:\n       return 2 * n\n    else:\n       largest_prime_factor = (n%2 for n in [1,2,3,5,7,11,13,17,19,23,29])\n    if largest_prime_factor < n:\n       largest_prime_factor = n\n    return largest_prime_factor", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\n    if n!= 1:\n        return n.factor(2)", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    largest_prime_factor = lambda n: n!= 1\n    while n!= 1:\n       n = n % 2\n       if n == 1 or n == 0:\n          return n\n       elif n % 2 == 0:\n          return largest_prime_factor(n-2)\n       else:\n          return largest_prime_factor(n-1)\nThis is not the fastest algorithm.  The first case (n = 1 or n = 0) is optimized out of the running time.  In the second case (n % 2 == 0), the for loop is executed a maximum of once, but it is guaranteed to be executed at least two times.  The last case (n-1) is again optimized out of the running time, but it is guaranteed to be executed a minimum of two times.  You can improve this by using the built-in function factorial to avoid the loops.  It will execute the same number of times as the largest", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    print n\n    for i in range(2,n):\n       if n%i == 0:\n          return i\n       if n%i == 1:\n          return n/i\n       if n%i == 2:\n          return n%i\n       if n%i == 3:\n          return n%i\n    return n\nThe base case for the range loop is for n to be divisible by 3, which should be returning n/3, but returns n%3 instead.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return (n % 2) == 1\nThe problem with this is that 2 is a divisor of most prime numbers. So this algorithm will return 2 if the argument is a prime number.       def largest_prime_factor(n: int):", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n       return n\n\nPython does not have integers.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return n % 2 == 0</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    def largest_prime_factor", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return int(n%(int)n)\nI think you mean to say       return n%n", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    p = 1\n    while p > 1:\n        for i in range(n):\n           if n % i == 0:\n               p = p / i\n           else:\n               p = p % i\n    return p\nIt's a good idea to define a function that returns False if the input is not prime. I think the way the OP does it is not a good idea.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return n%gcd(n,n)\nJust what I was looking for.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n        return n\n    return largest_prime_factor(n-1) + 1</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    return largest_prime_factor(n - 1)\n\nYou can get the same result by going through each factor, but it's a fun example of an inefficient solution.\n\nClever, I think. But I would replace that function with something that uses only a constant amount of memory to store the previous result.\n\nThis is a great hack.\nI also like the one that checks if a number is a prime number by using a reverse function.\n\nCan't you just use this?", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 2:\n        return 1\n    else:\n        if n % 2 == 0:\n           return n / 2\n        else:\n           if n % 3 == 0:\n              return n % 3\n        else:\n            return n % 5\n    return 1\nCan anyone tell me how this works, or how to improve this code?</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return n % 2 == 0\n    # Alternative solution\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    return n % (n - 1)\nYour second solution is better because it makes fewer assumptions.\n\nI don't see how that's any different than the first solution.\n\nIt works for negative integers.\n\nThat's a good point. It's the same reason why 1/2 is not a prime number.\n\nInteresting. I've always been annoyed by the fact that the 2nd solution gives the wrong answer for a negative number. I'm curious why it's like that.\n\nYou can't divide by a number smaller than one.\n\nThe article's algorithm is correct, and can be extended to work with negative integers. See other comments.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n        return largest_prime_factor(n-1)\n    else:\n        return n\nIf you're doing this in python you don't need that extra check. Just return n, since in python 2 it's always guaranteed that n >= 1.\n\nWhat if you're in python 3?\n\npython 3 should have been backported to python 2.7 before 2.7 was released.\n\nI actually did backport it to python 2.7. I thought the point of python 3 was to remove the reliance on unicode, so I've been using unicode from the start. I can't go back now.\n\nThe point of Python 3 is to have a Python that is not tied to a specific version of the C standard library. Unicode is just one of the many things that need to be updated to the new standard library.\n\nI see. I guess I should update my code.\n\nNeat.\nI've been working on a version of this that does the same thing using a Bloom filter. It works by first getting a list of all primes up to the square root of", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n       return largest_prime_factor(n - 1)\n    else:\n       return 1\nThis will raise an exception for n = 1 since 1 is not prime.  To fix this, you'd need a test case for all prime values to make sure the program handles them all correctly.\nI wouldn't try this in production.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 1:\n         return 1\n    else:\n         return largest_prime_factor(n-1)\nI don't understand this. When the largest prime factor of 13195 is 29, how is this returning the largest prime factor of 13195? I mean, the program has to give up after the first check. I think I've been staring at this for too long.\n\nOh, I see. It's because it can return a different answer even when the input is the same. I was confused about the'return' statement, but this explains it:\n>>> largest_prime_factor(13195)\n1\n>>> largest_prime_factor(13195)\n2\n\nIt's a nice exercise to try to understand why this is the case.\n\nI can't for the life of me understand why this is the case. It seems to be a contradiction.\n\nThe answer is provided by the OP:\n_When the largest prime factor of 13195 is 29, how is this returning the\nlargest prime factor of 13195?_\nIt's returning the largest prime factor of 13195", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n       return largest_prime_factor(n - 1)\nYou can also get the largest prime factor of a number with one less digit than the length of the number:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 2:\n        return n\n    else:\n        if n == 0:\n           return 1\n         else:\n            return largest_prime_factor(n - 1)\n    return largest_prime_factor(n - 1)\n>    def largest_prime_factor(n: int):\n>    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n>    >>> largest_prime_factor(13195)\n>    29\n>    >>> largest_prime_factor(2048)\n>    2\n>    \"\"\"\n>    if n < 2:\n>        return n\n>    else:\n>        if n == 0:\n>           return 1\n>         else", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\n    for i in range(1, n + 1):\n        for j in range(n + 1, n):\n           if n % j == 0:\n                return i, j\n\nOr, if you don't need a backtracking solution, you can do this:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 2:\n        return n\n    else:\n        return largest_prime_factor(n / 2)\nI didn't know you could divide a non-prime by 2.\n\nYou have to be more explicit about that:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n <= 1:\n        return 1\n    n = n - 1\n    if n % 2 == 0:\n        return 1\n    n = (n % 2) + 1\n    if n % 3 == 0:\n        return 1\n    n = (n % 3) + 1\n    if n % 5 == 0:\n        return 1\n    n = (n % 5) + 1\n    if n % 7 == 0:\n        return 1\n    n = (n % 7) + 1\n    if n % 11 == 0:\n        return 1\n    n = (n % 11) + 1\n    if n % 13 == 0:\n        return 1\n    n = (n % 13) + 1\n    if n % 17 == 0:\n        return 1", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 1:\n        return 1\n    else:\n        if n % 2 == 0:\n           return n\n           else:\n             return (n - 1) % 2\n    return n\nThis solution is correct, but it's also a little bit non-idiomatic python.\nYou're typically supposed to return None when you know there isn't a prime factor.  Returning None is much easier to read than \"n - 1\" and \"n % 2\".\nThanks, this seems a little bit more elegant.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    return n % 2 == 0", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    # Ignore factors of 2 and 3.\n    if n > 2:\n        return n % 2\n    else:\n        return n % 3\n    else:\n        return n\n\nMaybe the number one?\n\nIt's not the largest prime factor of 1.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return (n % (2 ** (2 ** (2 ** (3 ** (4 ** (5 ** (n)))))) < 2 ** (2 ** (2 ** (2 ** (2 ** (2 ** (2 ** (3 ** (4 ** (5 ** (n)))))))))\n    # 1.9132853756542305412\n    # >>> largest_prime_factor(2048)\n    2\n    # 3.4024606024067\n    # >>> largest_prime_factor(2048)\n    4\n\nIt's actually 2^2^(2^(2^(3^(4^(5^(n))))))</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n > 1:\n        return largest_prime_factor(n-1)\n    return 0\nThe way the code works is that it returns the largest prime factor of n-1. Then n-1 is chosen such that n*2 is not a prime. For instance, 13195 is 2^13 + 13*2^2 + 2*2^1 + 1, which is not a prime. This is why 13195 is not a prime.\n\nIn some languages, that will return 13. In this case, it should return 11.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 0:\n        return 1\n    if n == 1:\n        return 1\n    if n == 0:\n        return 2\n    if n == -1:\n        return 3\n    return largest_prime_factor(n - 1) + 1\n\nAs an alternative to this elegant code, how about:", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n < 2:\n        return 1\n    return n * largest_prime_factor(n-1)\nThis would be a better approach, IMO.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\n    if n < 1:\n        return 1\n    n = 2*n\n    while n > 1 and n!= 2:\n        if n % 2 == 0:\n           return n / 2\n        else:\n           return n\n    return largest_prime_factor(n)\n\nIf you try to put print statement before the line :\nn = 2*n\nyou will see that it is iterating over all the numbers from 2 to n-1.\nThis is a typical problem with the modulo operator.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    if n == 1:\n        return 1\n    n = n % 1\n    if n > 1 and n % 1 == 0:\n        return n\n    else:\n        return n**2\n\nIf this is your most frequently used function, then I think you have a bigger problem than large methods.\n\nThat's just an example. But yes, I do have some functions that are significantly larger than that.\n\nMy comment was mostly in jest. The point is that this is not a good metric for determining whether a piece of code is too large.\n\nI was thinking the same thing but didn't want to come across as rude.\n\nReally? I like a small, concise main() function. I usually try to have main() as short as possible.\n\nHow many languages have you programmed in?\n\nI am a software engineer who has worked in many languages.\n\nI find it very hard to believe you can make a good judgement on whether or not main() is too long until you have experienced writing a large variety of programs in many languages.\nI", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n\nIs this a joke?\n\n_Famous last words of the American programmer. \"Is this a joke?\"_\n\nNo, it's not a joke.\n\nI'd make it a joke.\n\nI wrote this as an exercise in test-driven development. It's easy to write a test to determine if a number has a prime factorization. It's harder to write the test to determine if that factorization is the largest possible. It's harder still to write a test to determine if the largest factorization is the largest possible.\n\nSo now you have a test that can't be run.\n\nTrue. But that's easy to fix.\n\nI'm not sure that would be easy to fix. You would have to test that the test itself is not broken. I don't know how to do that.\n\nLol, this is brilliant. I may even write a script to run this for me every now and then.\n\nI can see this being the basis for a very very slow password cracker.\n\nYou can easily write a script to do that.\n\nIt's not going to be very fast.\n\nI guess if you know the time it takes to run on a", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return largest_prime_factor(n)\nThat's an interesting way of calculating the largest prime factor of n. The result is not always unique, though. What happens if you give it n=17?\nThis will get you the first largest prime factor:      def largest_prime_factor(n: int) -> int:\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(17)\n    17\n    >>> largest_prime_factor(1737)\n    23\n    >>> largest_prime_factor(173793)\n    23\n    >>> largest_prime_factor(17379375)\n    23\n    \"\"\"\n    if n > 1:\n        if n % 2 == 0:\n           return n\n    else:\n          return (n - 1) % 2\nInteresting.</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return 2 ** (n ** 2)\nHow does that work?</s>", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    # If n is prime, return 1\n    if n % 2 == 1:\n        return 1\n    return n%2", "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\" \"\"\"\n    return n % (n - 1)\nI'd say this is one of the most useful functions in the standard library for real world programmers.  It's one of those functions that I use a lot, but I rarely think to write it out in full.\n\nI think \"Python for programmers\" would be a better name, and more accurate.\n\nAgreed. I think the term \"Pythonic\" has become a bit of a buzzword in the community.\n\nNot only that, but it is abused. In my view, Python is a particularly good language for implementing OOP. You can do functional programming, but the core language is designed for OOP. That is the \"Pythonic way\".\nI've read a few blog posts recently with titles like \"X is Pythonic\" where X was not OOP. In that case, it is not Pythonic.\n\nThis article misses a number of things that are core to the Pythonic style. For instance:\n1) Camel case for function names\n2) Singleton objects. i.e.\na_list = List(3, 4, 5)\n3) Horizontal whitespace.\n4) Global state. There's no"]]