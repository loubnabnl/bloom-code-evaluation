[["def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    for i in string.split(substring,''):\n         for j in string.split(substring, i):\n             if string[i:j] == string[j:]\n                   count += 1\n    return count\nI really like this one, and I think it's got the potential to be in the top three, if not win.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string[start:end] == string[start:end]:\n        return 0\n    else:\n        return count(string[start:end], string[start:end])", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string).count(''+ substring)\nPretty sure this won't count the case where the substring is repeated multiple times:      >>> how_many_times('aaa', 'aaa')\nThat's why the \"count'' + substring\" line is there.\nYou're right. I didn't see that.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nYou don't need to call len() if you only need to check one string.  It's in the example.  If you need to check more than one string, then you're right.\nBut that's python. It's one of the features that makes it beautiful. In C++, this would be a nightmare of macros and template syntax.\nIt's not a python feature. It's a python implementation feature.  Python doesn't have a 'len' function.  You could make the same syntax in C++.  You would need to find a way to make it compile into a single function though.  In C++, the simplest approach would be to use a template class which holds the substring and counts the overlaps.\nI'm not so sure, there's nothing stopping you from making a function that takes one argument, returns the length of that argument, and makes a copy of it to pass as the second argument.\nWhat would you call it?</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    #Example\n    #Inputs:\n    #'aaaaaaaaaaaaaaa'\n    #'aaaaaaaaaaaaaaaaaaaabbbbbbbbb'\n    #'aaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbb'\n    #'aaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbb'\n    #Outputs:\n    #'aaaa'\n    #'aaaaa'\n    #'aaaaaa'\n    #'aaa'\n    #'aaaabb'\n    #'aaaabbbb'\n    #'aaaabbbbbb'\n    #'aaaabbbbbbbb'\n    #'aaaabbbbbbbbbb'\n    #'aaaabbbbbbbbbbbb'\n    #'aaaabbbbbbbbbbbbbbbb'\n    #'aaaabbbbbbbbbbbbbbbbbbbb'\n    #'''\n    if len(string) == 0:\n       return", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for i in range(len(string)):\n        count += len(string[i])\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    n = len(string)\n    for i, v in enumerate(string.lowercase):\n        if v not in string:\n           return 0\n        if v in substring:\n            return n + 1\n    return n\n\nA couple of questions:\n1) Why is the code below considered \"hard to read\"\n2) Are there any other resources available online for learning Python that you would recommend?\n\n1) It's not \"hard to read\" to someone who knows python.\n2) Here's a good resource\nhttp://www.diveintopython.net/\n\nNot really.\nThat page doesn't explain how to read that code.\nIt doesn't explain what \"for i, v in enumerate(string.lowercase)\": does.\nIt doesn't explain what \"if v not in string:\": does.\nIt doesn't explain what \"if v in substring:\": does.\nIt doesn't explain what \"return n + 1\": does.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) + len(substring)\nThe return value would be:\n0, 3\nI'd expect it to be:\n0, 1\n\nIt's 2. It's looking at the first A, then the second, then the third, which is 3.\n\nThe problem is that the loop is nested, so it will count the overlapping A's. The trick is to do a \"dot product\" of the substrings.\nfrom string import substring", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI am sorry, but this solution is not correct. In python, everything is a string. There is no way to tell if the original string is an array or a string. Your solution will find exactly one matching string in an array, a zero-length string, an empty string, or any string where the first character is 'a'.\n(this solution would be correct if it were just in python 3.x, where a and aa are recognized as two different types, but unfortunately, this solution is also in python 2.x)\n\nYou're right, I am talking about Python3.x. In Python2.x this might have been a problem, but that doesn't affect my code, which works in Python3.x, and as far as I can see in Python2.x as well.\n\nThere is a subtle issue here. The solution works for a string which is a single, contiguous sequence of characters. What if it is an array of strings?\n>>> my_string = [ \"aaaaaa\", \"aaaaaa\", \"aaaaaa\", \"aaaaaa\", \"aaaaaa\", \"aaaaaa\", \"aaaaaa\", \"aaaaaa\" ]\n>>> how", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for character in string:\n       if character in substring:\n          count += 1\n    return count\nThis code is unsafe.  The substring is not checked for duplicates.\nI am curious, is there a problem with my implementation?\n\n_The substring is not checked for duplicates._\nThis is really a matter of style. It's not a bug.\n\nThis seems like a very interesting algorithm, but the code is somewhat confusing. There are probably a lot of ways to do this efficiently, but it's very hard to tell from this code.\n\nWhat is this? Why are people voting it up?\n\nIt is an article about an algorithm called how_many_times. It has a description of how the algorithm works, an implementation in python, and a section that compares it to the usual approach of using a trie.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string =='':\n       return 0\n    return len(string) - len(substring)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    r, e = string.rfind('a', string)\n    for s in r:\n        if e not in s:\n           return 1\n           e = e[-1]\n    return 0\nI think the one-liner is:\ns = \"aaa\"\nfor i in range(len(s)):", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for s in string:\n        if s in substring:\n           count += 1\n         if count > 1:\n            return count\n    return count\n>    def find_all_overlapping_substrings_in_string(string: str, substring: str):\n>    \"\"\" Find all overlapping substring in a given string.\n>    >>> find_all_overlapping_substrings_in('aa', 'aa')\n    ['a', 'aa', 'aaa', 'aaa']\n>    >>> find_all_overlapping_substrings_in('aaa', 'aa')\n    ['aaa', 'aaa', 'aa', 'aaa']\n>    >>> find_all_overlapping_substrings_in('aa', 'aaa')\n    ['aaa', 'aa', 'aaa']\n>    >>> find_all_overlapping_sub", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return count(string.startswith(substring, ''))\nWhy did you have to over complicate it?       string.count('a')  is what I would do.\nMaybe he is talking about how many times there are \"a\" in the string?\nOr maybe the number of a's in the string where the substring is the first character?  You can't really tell since there is no docstring.\nI think it's pretty clear.  It finds how many times the substring appears in the string, and ignores all other times the substring appears in the string.\nI thought that too, but he said      \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\nand what he actually implemented was      \"\"\" Return the number of a's in the string, ignoring any a's in the substring \"\"\"\nyes, but it returns the count of a's in the string without any of the a's in the substring.  A string with 4 a's that contains 'aaa' would have a count of 3.  It's a function for finding the count of a", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n        def how_many_times_r(s: string) -> int:\n    \"\"\" How many times a substring is found in the original string. Count overlaping cases.\n    >>> how_many_times_r('aaaaaaa', 'a')\n    6\n    >>> how_many_times_r('aaaaaa', 'a')\n    6\n    \"\"\"\n\nSo, it's just 'count(overlapping)'?\n\nYes, but with a lot of functionality built on top of that.\nFor example, you could write a function like how_many_times_r() that would also return the index of the last occurrence of a substring.\n\nI don't think I'd want to do this. I'd just want to use a regular expression to find the last occurrence.\n\nThe method is just a shortcut to writing a regular expression. It's a bit easier for me to type it out this way than it would be to write out the regex.\n\nI like it. My only concern is that this could be used as a naive content security policy to protect against XSS attacks", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    word = re.compile(r'(?P<word>\\w*)\\1+')\n    count = 0\n    with open(string, 'r') as f:\n       for word in f:\n          if word in string:\n             count += 1\n    return count\nI don't see how this can be considered to be in any way better than the built-in len(string) method.\n\nYou can use it to find the number of occurrences of a substring in a given string. I find that quite useful for certain purposes.\n\nI just use substring.count('abc', 'xyz').\nBut hey, I'm not criticizing the code.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return string.find(''.join(substring))\n\nThat's not a Python answer, that's just a C answer with the actual code removed.\n\nYeah, what's the point of this?\n\nI thought it was quite good. It gives you a pretty good example of one way to solve a problem in Python, which is sometimes more helpful than the actual solution.\n\nIt looks to me like the author was just trying to get the credit for solving the problem, when he really didn't. I'm sorry if that sounds harsh, but I would have downvoted this too.\n\nI was being tongue in cheek, as I do agree with you. If someone is posting their code then they should include the code.\nHowever, I thought the code was pretty good and I appreciated that it was there.\n\nI'm really glad this was posted. It is a good example of an elegant solution to a problem that you may have struggled with in the past.\nI'll admit I haven't had to write a function to find how many times a string appears in another string. But I have had to find how many times a string appears in another string where that string is a substring. I can", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 1\n    def find_all(substring: str, count: int) -> list:\n    \"\"\" Search for substring and return a list of 1 if it is found and 0 otherwise\n    >>> how_many_times('aaa', 3)\n    [0, 0, 0]\n    \"\"\"\n    return list(find_all(substring, count))\n\nYou might find this useful. \n\nThanks, this is very helpful!\n\nWhy does the first example use a function name in its parameter list?</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return count(string.find(substring))\nYou can also use StringUtils.count_all_overlapping</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\nI really don't see the point of a library like this. It's trivial to write this by hand. And it's probably even easier in Python than it would be in any other language. It's a bad idea for a library.\n\nWhile I agree that this is a trivial task, I don't think it's a bad idea for a library.\nWhat if you need to do it many times? What if you want to do it on many different strings? What if you need it to be fast?\nThese are all things you could say about any library that takes a simple task and makes it reusable and efficient.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\nfor e in string.finditer(beginning=str.end):\n       if e == substring:\n          return (e - 1) + 1", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n    return len(string) + len(substring) + 1\n\n    def how_many_times_all(string: str, substring: str, num_times: int = 3) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times_all('aa', 'aa')\n    0\n    >>> how_many_times_all('aa', 'aa')\n    0\n    >>> how_many_times_all('aa', 'aa', num_times=3)\n    3\n    \"\"\"\n\n    return len(string) + len(substring) + len(substring) + len(substring) + 1\n\n    def how_many_times_word(string: str, substring: str, num_times: int = 3) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times_word", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return count(gsub(string, substring, 'a'))\n>    return count(gsub(string, substring, 'a'))\nThis seems a bit clunky in comparison to the following:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n    a = 'a'\n    b = 'a'\n    a = 'a'\n    c = 'a'\n    if a in b:\n        return 1\n    for i in range(len(a)):\n        if a[i] in b:\n           return i\n    return 0\n\nThis is pretty similar to the original submission, except that it calls itself recursively.  (I'm not sure that it actually matters, but it's an interesting observation.)\n\nI don't get it. The title says \"count the number of times...\" but the function counts the number of unique occurrences, not the number of times something occurs.\n\nI don't think there's a standard way to count the number of occurrences of a substring in a string, but I did find this interesting:\n\nAh, I didn't know about `in`. I think the title should be \"count the number of unique occurrences in a string\".</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if not string.lower(string.upper(substring))) or not string.upper(substring) in string:\n        return 0\n    else:\n        return len(string) - len(string.upper(substring)))\nThis is really slow. It doesn't matter if you use aa or aaabb, it will iterate through the entire string each time. The alternative is to keep a hash mapping the original string to a list of substring combinations, and iterate through that. It won't be very much faster, but it's less bad.\nA better alternative is the following:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string == string[0]:\n        return 0\n    a = str[0]\n    for i in range(len(a)):\n        a = a[i:]\n        if i in string:\n            return i\n    return 1\n\nIf you want to count how many times a substring appears in the original string, use something like this:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(string[i])\nCan you put it in terms of the length of the shortest repeating substring?\nI.e. the length of the shortest substring that occurs at least twice.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    c = ''.join(string)\n    s = ''.join(string[c])\n    count = 0\n    while c!= s:\n        c, s = c, s[1:]\n        if c == s[1]:\n           count += 1\n    return count\n\nIn this example, the strings:\nab, aa, aaa, aab, aaa, aab, aaa, aaa, aab, aaa, aaa, aaa, aaa, aaa, aaa, aaa, aaa, aaa\nreturn 0, while:\naaa, aaa, aab, aaa, aab, aaa, aaa, aaa, aaa, aaa, aaa, aaa, aaa, aaa, aaa, aaa, aaa\nreturn 3.\n\nYour example is missing a closing bracket.\n\nNot a Python programmer, but this seems to miss a closing bracket:\n\nNot a Python programmer, but this seems to miss a", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for s in string:\n        count += 1\n        if s.startswith(substring):\n            count += 1\n    return count\n\nI have noticed that it is a bit slow, at least on my computer. Maybe it should be rewritten using an iterative approach?\n\nI'm surprised this is the fastest solution; it seems like there should be a much more efficient way of doing this.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"This only works on strings of length 1, or at least 1 character.\n    >>> how_many_times('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaa', 'a')\n    Traceback (most recent call last):\n        File \"<stdin>\", line 1, in <module>\n        TypeError: how_many_times() takes exactly 1 argument (0 given)\n    \"\"\"\n\nThe first is a bug, not a design flaw.\n\nShouldn't the bug be fixed?\n\nYes, of course. But a design flaw is something that is obviously broken, like \"if the user wants to, they can kill the process by clicking the X\".\n\nSo, like the assumption that the user is always right and will never misuse the program?\n\nYes, exactly.\n\nI've been thinking lately that sometimes the user is wrong and will misuse the program. So I'll get the user to do something bad in a way that they don't realize the program is doing what I want it to do.\nIf you create a user interface that you know is misleading and will lead to mistakes", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string.startswith(substring) or string.endswith(substring):\n        return string.count(substring)\n    return 0", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n    @return the number of times the substring can be found in the string\n\nHow about  \"def how_many_times(string: str, substring: str, start: int, end: int) -> int:\"?\nI would also like to see a version that only works on one- or two- character strings.\n\nIt's not a problem with the version that I posted, and I think you know why.\n\nI have no idea why.\n\nYes, I know.\n\nNo, I don't.\n\nIs there some way that I can figure it out, without you telling me?\n\nNo.\n\nHey man, I'm just trying to be your friend.\n\nI'm sure you are.\n\nI'm not sure what's going on here, but the votes are going down in a peculiar way.\nI'd be interested to see how many times the votes change.\n\nI don't see anything odd here. There are several downvotes for you and a few upvotes for the parent comment, which is why it is now at +4.\n\nAh.\nI was hoping to see the number of votes change.\nIn this case", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    d = dict()\n    for string in string.split():\n       if string == string.replace(substring, None):\n          d[string.split()[0]] = 0\n       else:\n          d[string.split()[0]] += 1\n    return d.count()\n\nI don't get it. Is it using the fact that every string contains the empty string as the zero character?\n\nThere is a substring with length of zero and another one with length of 1. The count() method returns the number of times the given substring was found in the original string.\n\nI was hoping it would be something more clever.\n\nI remember seeing this problem on a \"placement test\" for programming students at my old university. I was so excited when I came up with a solution using recursion.\n\nI was hoping it was more complicated.\n\nThis looks so trivial.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string:\n       return len(string)\n    else:\n       return len(string[0])\n    def how_many_words(string: str, substring: str) -> int:\n    \"\"\" Find how many words a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_words('', 'a')\n    1\n    >>> how_many_words('aaaa', 'a')\n    4\n    >>> how_many_words('aaa', 'a')\n    4\n    >>> how_many_words('aaaaaa', 'aa')\n    5\n    \"\"\"\n    if string:\n       return len(string)\n    else:\n       return len(string[0])\n\nThere are many more examples of this in the code. The string \"aaaaaaa\" appears 7 times in this code.\n\nIn this case, the string \"aaaaaa\" has a", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # Convert to a string, starting at the beginning\n    s = re.sub('', s, 0, 1)\n    # Return the length of the result\n    return len(s)\nMore generally, this is a common problem in string processing. It seems like one of those things that'd be hard to get right, but this is really easy.\nI would normally have done the same thing with regular expressions, but I find it's easier to understand and quicker to write out if you use regular expressions from the start.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    how_many_times = lambda str:\n    \"\"\"\n         The substring found.\n         The length of the original string.\n         The length of the substring.\n         The index of the first occurrence of the substring.\n         The index of the last occurrence of the substring.\n         The index of the last occurrence of the substring in the original string.\n         The number of characters of the substring.\n         \"\"\"\n    if str.endswith('\\n'):\n        return len(str)\n    else:\n        return len(str) - 1\n    return len(str)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(string[0])\nWho the hell thought that was a good idea?</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    start_length = string.count(' ')\n    for i in range(0, start_length - 1):\n        if string[i:i+1] == substring:\n           return i\n    return 0", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = len(string)\n    for i in range(0, len(string) + count):\n        if substring in string:\n           count += 1\n    return count\nThis seems like a pretty simplistic approach to me. What would you do to make it more robust? I might be missing something fundamental to the problem but it seems to me that this code will count aaaaaaaa twice. What I would do instead is iterate through the string while adding a counter and then when you've found it once you just check the counter to see if it's already been found.\n\nI was just looking for the right words to describe the approach. This is it.\nThis approach is not robust. It would be interesting to see it applied to a larger set of input, but that would only serve as a form of benchmarking.\nWhat it is, is fast. A naive approach that uses the native Python string type will be faster and therefore give you a better idea of the speed of this approach.\nIn general, I'd like to see this done as an algorithm. Something that will work for any string. The", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    a = 0\n    while not string.endswith(substring) and not a:\n        a += 1\n    return a\n\nSo, the same as above.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # pylint: disable=unused_parameter\n    def f(x, y: int):\n    \"\"\" Function to remove a character in a string.\n    >>> f('abcdefghijklmnopqrstuvwxyz', 'c')\n    'abcdefghijklmnopqrstuvwxyz'\n    \"\"\"\n    return y if x not in string:\n    return x", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def my_str(s):\n    \"\"\" Return the string to be searched.\n    >>> my_str = 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, substring: str) -> None:\n        if substring == '':\n           self.substring = ''\n\n        else:\n            self.substring = substring\n\n        self.count = 0\n\n        def __call__(self, string: str):\n           if string[0] == self.substring:\n                self.count += 1\n\n              return self.count\n\n    def __lt__(self, other: str) -> bool:\n           if self.count > other.count:\n                 return True\n            return False\n\n    def __eq__(self, other", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string.split(substring))\nThis will fail for strings that are longer than the substring.\nIt will also fail for strings that have a substring of length 0, but I suppose that's not something you can do much about.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for char in string:\n        if char in substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # http://stackoverflow.com/questions/21376759/how-to-count-the-number-of-times-a-substring-repeats-in-a-string-in-python\n    def count_overlapping(substring: str) -> int:\n    \"\"\" Count how many times a substring of a given string is used.\n    >>> count_overlapping('aaa', 'aaa')\n    0\n    >>> count_overlapping('aaa', 'aaaa')\n    1\n    \"\"\"\n    return string.count(substring)\n\nSorry but why do you think this is in the top 10,000?\n\nIt's an interesting question with a fairly elegant solution.\n\nThis question is fairly straightforward, the answer is fairly obvious, and the code is less than 30 lines.\n\nI like this. I've seen similar problems for C++ floating-point code, which can be quite subtle. I've used a rather ugly brute-force approach to solving it, and seeing a more elegant solution is a pleasure.\n\nIt is in the", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(string[substring])\n    if string[substring] in string[len(string)-1:]:\n         return 1\nWhy is this a single line comment when it's a single line of code?\n\n1\\. There are two lines.\n2\\. It's not code, it's documentation.\n\nI disagree, the second line is also code that is run.\n\nIt's a comment; it's not run.\n\nThe second line is a function, and it's run, so it's code.\n\nA function is not code. A function is a description of a function. Code is the output of a compiler.\n\nThe code in the second line is not a function.\n\nThe code in the second line is the actual code that performs the computation, so it is code.\n\nThat is incorrect. The code in the second line is the function that returns the result of the computation. The first line is the code that defines the function.\n\nIf you were to write a program that produced the result in the second line, then it would be code. In this case, the program", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def count_overlaps(string1, string2):\n    \"\"\" Count the number of overlaping occurrences in the two strings.\n    >>> count_overlaps('aabbbb', 'a')\n    3\n    >>> count_overlaps('aabbbb', 'aaa')\n    1\n    >>> count_overlaps('aabbbb', 'aaaabbbb')\n    2\n    \"\"\"\n    return len(string2.find(string1))\n\n>>> how_many_times('aabbbb', 'aaa')\n3\n>>> how_many_times('aaa', 'a')\n1\n>>> how_many_times('aaaabbbb', 'aaa')\n2\n\nOr in your case:\n\n>>> count_overlaps('aabbbb', 'aaa')\n1\n>>> count_overlaps('aabbbb', 'aaaabbbb')\n2</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    with open('test.txt') as f:\n    for line in f:\n          count = 0\n          line = line.strip()\n          if line[0] == 'a' and line[1] == 'a':\n              count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nThis is actually really smart.\n\nThe sort of thing that's easy to write in Python.\n\nIt's also easy to write in Perl:\nmy $how_many = qw(\na", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string, substring):\n        self.string = string\n        self.substring = substring\n        self.n = 0\n\n    def __len__(self):\n        return len(self.string)\n\n    def __contains__(self, string):\n        return self.string in self.substring\n\n    def __reversed__(self):\n        return self.string[::-1]", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return (len(string) - len(substring) + 1) / len(substring)\n\nIf you do `len(string) - len(substring)` it's going to return 0 for strings that are one character long.\n\nthanks!</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def __new__(cls):\n    \"\"\" Create a new copy of the class.\n    \"\"\"\n    # Check if the class is already defined.\n    if cls is None:\n       cls = cls()\n    # Add a method for the class.\n    if __name__ == \"__main__\":\n       cls.__new__()\n    return cls\n>\n> What is the use of that method? Why not create a copy of the original\n> string and use that?\nIt lets you re-use the same string instance, without having to do an\nexpensive copy. It also lets you use it in a list, like so:\nhow_many_times([ \"b\", \"a\", \"c\" ]).\n\n\"Mihai Maruseac\" <mihai@...> wrote in message news:4818@...\n> \"Philippe Bernardy\" <bernardy.p@...> wrote in message\n> news:4817@...\n> > \"Ned", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return 0 if string == substring else\n    return 1 + len(string)\n\nFor all those wondering, the above is a function that finds how many times a given substring can be found in the original string. Counting cases where there is an overlap in the search is left as an exercise to the reader.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) + 1", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n   \n    def __init__(self, string: str, substring: str) -> None:\n    \"\"\" Create a new `how_many_times` instance.\n    >>> how_many_times = HowManyTimes('a', 'a')\n    >>> how_many_times()\n    <function how_many_times at 0x7f4f21dde8a0>\n    \"\"\"\n    def __call__(self, substring):\n    \"\"\" Return the number of times that the given substring was found in the original string.\n    >>> how_many_times('aa', 'a')\n    3\n    >>> how_many_times('aaa', 'a')\n    3\n    \"\"\"\n    return len(substring)\n\nFor extra challenge, don't use any existing solution. For extra bonus, use a 3-liner.\n\nDoesn't work:\n>>> from collections import defaultdict\n>>> how_many_times = defaultdict(int)\n>>> how_many_times('", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\" The function should return 0 for a match of the whole string, 1 if\n    \"\"\" one substring match is found, 2 if two are found, etc.\n    \"\"\"\n    return len(string) - len(substring)\nI'm not sure that's the best approach. You can easily end up with a lot of matches that don't get counted because you end up with a substring of a substring of a substring, etc.\n\nYeah, I agree. It was a quick hack that showed a nice use for lambda. I think your idea is better.\n\nI think this is a good example of using the.* operator, I think it is a bit underused. I think the reason is that it is not as obvious as.map and.filter, but it is very useful. I find myself using it quite often in Python.\n\nI'm a little surprised that he didn't use the filter() function to create a\nfilter that only returns the first substring of the string with each\niteration.\n\nActually, the same can be achieved in one line (assuming \"aaa\" is the string):\nfor s in string:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string.find(substring, replace = False))\nI would use a dictionary with a key equal to the substring and the value being the number of times the substring occurs.  That way you could do something like this:      how_many_times('', 'a')", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    for item in string.split(substring) + [string.startswith(substring)] + string.endswith(substring):\n        if item[0] == substring:\n           return item.count()\n    return 0\n\nWorks only for'simple' strings and where you can calculate substring without using back references (as I understand it).\n\nI prefer how_many_times(string, string) -> int\n\nIt should return the number of occurrences of the substring, with an empty substring counting as one. The op's version, like the standard version, returns the number of distinct occurrences of the substring, including overlaps.\n\nFor substring \"aaa\" this:\nhow_many_times('aaa')\nwill return 3, not 5.\n\nI want to down vote the title but up vote the post.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __len__(self):\n    return len(self.str)\n    def __iter__(self):\n    return self.__class__.__iterator__()\n    def __add__(self, n):\n    for i in range(len(self.str) - n):\n       self.str.append(self.str[i:i + n])\n    return self\n\nThe unindented text above is probably a macro.  It expands to:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def number_of_occurences(substring: str, current_char: char) -> int:\n    \"\"\" Return how many times the substring can be found in the original string.\n    >>> number_of_occurences('', 'a')\n    0\n    >>> number_of_occurences('aaa', 'a')\n    3\n    \"\"\"\n    return number_of_occurences(substring, current_char)\n\nHow is this different from len?</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def count_overlaps(substring):\n    \"\"\" Return the number of times a substring occurs in the string and also in other substring of the same string.\n    >>> how_many_times('aaa', 'aaaa')\n    0\n    >>> how_many_times('aaa', 'a')\n    1\n    >>> how_many_times('aaa', 'a', 'aaa')\n    3 \"\"\"\n    return substring in string and substring in substring\n\nI don't get it.\n\nI believe he is proposing that string.count_overlaps(substring) should return the number of times a substring occurs in the string and also in other substring of the same string.\n\nHow does this work with unicode?\n\nFor unicode, the operation doesn't make sense. It would just return 1.\n\nAh, okay.\n\nI don't think this is very useful as it is. It only works for single-character substring searches. For example, how would you find the number of times \"w\" occurs in \"Santorum\"?", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    counts = []\n    for i in range(len(string)):\n        counts.append(counts.index(string, substring))\n    return sum(counts)\n\nLike my implementation better? ;)\n\nIt's good for a simple implementation. But your one doesn't handle the case where there are no matches for the first substring.\n\nPython 3.5 added support for range based for loops. There's a pretty easy way to get the nth element of the list using the range() method.\n\nI've always preferred the range(len(string)) to the above code\nfor i in range(len(string)):\n\nI usually do the same, but that's actually O(n). The above code is O(n).\n\nIf you're using the actual for-loop syntax, it's actually O(1).\n\nThe article is not about the for loop itself, but about the for loop as a programming idiom.\n\nI love for loops, but they do tend to have problems with correctness and efficiency in certain situations, and it's important to be aware of those. Here's a link", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if len(string) == 0:\n       return 0\n    return len(string) - len(substring)\n\nIf you want to count the number of times something is found in a string, you can just use len(string) - len(substring). This function would just be a re-implementation of that.\nThis function is looking for repeated substrings, not repeated occurrences of substrings.\n\nI was going to say something similar. I'm really not sure why the parent function was written in the way that it was. What's wrong with using the length of the string, subtracting it from the length of the substring, then dividing that by two?\n\nIs there a reason why you aren't using the built-in string methods to do this?\n>>> strings = [\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"]\n>>> substrings = strings.split(',')\n>>> how_many_times(\"\", \"a\")\n0\n>>> how_many_times(substrings[0], \"a\")\n3\n>>> how_many_times(substrings[1],", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def count(i: str):\n    \"\"\" Count the number of times the given substring appears in the original string.\n    >>> count('aaaaa')\n    1\n    >>> count('aaaaaa')\n    2\n    >>> count('aaa', 'a')\n    1\n    \"\"\"\n    return len(substring)\n    if string.count(''.join(string,substring))) == 0:\n    return 1\n    # let's say ''.join has nothing to do with the substring, so substring is\n    # just that\n    # the substring is the string with the.join removed\n    return string.count(substring)\n\nHow does this work?\n\nThe substring starts at the first character and is removed from the end.\n\nNote that this uses the string instance and not the substring, so you can pass a string as the substring and it will work.\n\nWhy does this work?\n\nThe string object has an internal substring object, which can be accessed using", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return sum(substring in string for x in range(len(string)))\nThanks, but I'm looking for a function that will do this, and count the occurences.  Not just print out the result of the function.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\nSee also:</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring) + 1\nThis is what I get when I run it.  I think it's doing the wrong thing.  What am I missing?  I'm sure it's something really simple.\nJust to make sure you see this, it's not a bug. The whole point of this function is to find how many times a string occurs in another string, if you call it with only one string, it won't return anything.  Basically, if you want to count how many times a string occurs in a string, you call the function with both strings.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nAh, Python.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string == substring:\n        return len(string)\n    else:\n        return sum(map(lambda x: how_many_times(x, substring[x]), string))\n\n>>> how_many_times('aa', 'aa')\n3\n>>> how_many_times('aaaa', 'aaaa')\n3\n>>> how_many_times('aaaaaa', 'aaaaaa')\n3\n>>> how_many_times('aaaaaaaa', 'aaaaaaaa')\n3\n>>> how_many_times('aaaaaaaaaaaa', 'aaaaaaaaaaaa')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: Maximum recursion depth exceeded\n\nIt's not a bug. It's because Python uses a \"with\" statement in the implementation, and this is not supported in Python3. There's no way to fix it in Python2.x.\nThe solution is to use another function:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    if string.find(substring):\n        return len(string) - len(substring)\n    else:\n        return 1\n\nI think it would be more correct to return 0, not 1.\n\nSure, that would work just as well. I personally would prefer 1, because then there's no risk of it returning 0 when it should have returned 1.\n\nI think it's the other way around. You can get 0, but you can't get 1.\n\nIt's interesting to compare this with how Guido did it in the first Python version:\n\nI like the fact that this is a pretty direct translation from the code in the tutorial (even if it doesn't cover all of it):", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n    \"\"\"\n    def return_list(ch: char):\n    \"\"\" Return a list with the substring found in the original string.\n    >>> return_list('a', 'a')\n    ['a']\n    >>> return_list('a', 'a', 'a')\n    ['a', 'a']\n    >>> return_list('aaa', 'a')\n    ['a', 'aaa']\n    \"\"\"\n    return list(ch for ch in substring if ch in string.lowercase)\n\nSo this is the nice thing about Python, the simplicity of the syntax.\nThe loop is required to get the number of occurences. If you were to return a list, you would not have a way of easily getting the number of times that a particular substring was found.\n\nThere are advantages to the list, but I would rather not make an example of them.\n\nI am glad you like it.\n\nThe original post was a bit unclear on what you wanted, so I tried to make it a bit more clear, but I am not sure if I succeeded", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n    return len(string) + len(substring)\n\n    def string_length(string: str):\n    \"\"\" Return the number of characters in the string.\n    >>> string_length('abc')\n    56\n    >>> string_length('abcdef')\n    97\n    >>> string_length('abcdefghijkmnopqrstuvwxyz')\n    167\n    \"\"\"\n\n    return len(string)\n\n    def substring_length(string: str, substring: str):\n    \"\"\" Return the number of characters in the substring.\n    >>> substring_length('abc', 'a')\n    1\n    >>> substring_length('abcd', 'c')\n    2\n    \"\"\"\n\n    return len(string) - len(substring)\n\nIn [34]:\n\n>>> def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nThis is similar to how many times a substring can be found in a string, but it also counts the times it overlaps with itself.\nHow about this:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # check that the substring is a string\n    if not isinstance(substring, str):\n        raise ValueError(str.__class__)\n    # check that it's the same string that we're checking\n    if not string.compare(substring, original):\n        raise ValueError(str.__class__)\n    # create a new string using the substring as the original string\n    def new_string(substring):\n        return string.substitute(original, substring, position=0)\n    # loop over the first character of the substring\n    for c in substring:\n        # loop over the second character of the substring\n        # if it's different than the first one\n        # we need to check if we found the substring\n        if c!= c[0]:\n           raise ValueError(", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) + len(substring)\nThat's not an answer.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n    def parens(string: str):\n    \"\"\" Returns a string with all parenthesis stripped.\n    >>> parens('(a(b(c)))')\n    '('\n    >>> parens('(a(b)(c))')\n    '(a(b)(c))'\n    \"\"\"\n    return string.replace('(', ')')", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nDidn't you do that in the previous post?\nYes, but I forgot to put it in the README.\nGotcha!</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if len(string) == len(substring):\n        return len(string)\n    else:\n        return len(string) - len(substring)\n   \n\nThis is about as useful as the second definition of \"truth\" in the dictionary. The first definition is \"conformity to fact or reality\", which is not only unclear but also a statement about what \"fact\" and \"reality\" are. That is, it is tautological. The second definition is \"the state of being the case\", which is also tautological. The third definition is \"something known or proved to be true\", which is at least _meaningful_ but still ambiguous. It could be the meaning intended, but the post doesn't say.\n_Constant_ is one of the most abused and misused words in computing. I'd\nhave to say that this particular definition is worse than most. What does it\nmean for a function to be constant? A function is constant if it always\nreturns the same value for the same arguments. So, this function, which\nreturns a number, is clearly not constant.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    try:\n       string_count = 0\n       for i in range(len(string)):\n           if string[i] == substring[i]:\n               string_count += 1\n    except StopIteration:\n        return string_count\n\na = \"This is a string\"\nb = \"Hello, I am a string\"\nc = a.find(\"a\")\nd = b.find(\"a\")", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n    def find_occurrences(string: str, substring: str) -> int:\n    \"\"\" Find the number of occurrences of the given substring in the original string.\n    >>> find_occurrences('', 'a')\n    0\n    >>> find_occurrences('aaa', 'a')\n    1\n    \"\"\"\n\n    return how_many_times(string, substring)\n\n    \"\"\" Find the number of occurrences of the original string in the given substring.\n    >>> find_occurrences('aaa', 'a')\n    2\n    >>> find_occurrences('aaa', 'aaa')\n    0\n\nMore about the author: \n\nYou really need to take a good look at the scientific method. How many times does that exact sentence occur in the original? In the modified version? In a million random permutations?\n\nI've just updated the link to point to the page where I've explained how the algorithm works.\n\nIf it's an interesting algorithm, you should probably describe it in more depth on the original", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    count = 0\n    for sub, c in string.split(substring):\n        if sub == c:\n           count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(substring) - len(string)\nThis is a great way to count the number of characters. It's not a great way to count the number of times the substring occurs. For that, you'll probably want to use the same algorithm used by the string module.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str, substring: str):\n    \"\"\" Initialize the counter.\n    >>> how_many_times = HowManyTimes()\n    >>> how_many_times('aaaa', 'aa')\n    0\n    >>> how_many_times('aaa', 'aaa')\n    3\n    \"\"\"\n    self.string = string\n    self.string = string[:substring]\n    self.string = substring\n    return 1\nHow is this the simplest code? It's basically `str.find(...)` which you can write with one line of Python and a character of Ruby.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # Calculate the total length of the string.\n    # This can be done with len(string) - len(substring)\n    total_len = len(string) - len(substring)\n    # Find the last occurrence of substring\n    current_index = 0\n    # Find the position of the first occurrence of substring\n    start_index = 0\n    while not current_index:\n       # At this point, we have the current position of the first occurrence\n       # of substring and the current position of the last occurrence\n       if start_index < total_len - 1:\n          current_index += 1\n          start_index += 1\n       # Check if substring is present in the original string.\n       # We can use the regular expression to do it.\n       if (substring in string):", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"Check for duplicate substrings.\"\"\"\n    \"\"\" Return the number of overlapping cases.\n    \"\"\"\n    for i in range(len(string) - 1, 0, -1):\n         count = 0\n         if string[i] == substring[i]:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def __init__(self, original, start_position, stop_position):\n    \"\"\" Create a new HowManyTimes instance\n    \"\"\"\n    self.original = original\n    self.start_position = start_position\n    self.stop_position = stop_position\n    self.found = []\n    def found(self, start_position, stop_position):\n    \"\"\" Return the number of occurences of the substring found\n    >>> how_many_times('aa', 'a')\n    3\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    6\n    \"\"\"\n    if start_position == stop_position:\n       self.found.append(start_position)\n    return self.found", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str, substring: str, start: int, end: int):\n         self.string = string\n         self.string = string.lower()\n         self.substring = substring\n         self.start = start\n         self.end = end\n    def _get_count(self, number: int):\n    \"\"\" Get the number of times the given substring can be found in the original string.\n    >>> how_many_times('aaaa', 'aa')\n    3\n    >>> how_many_times('aa', 'aaa')\n    6\n    >>> how_many_times('aaaa', 'a')\n    3\n    >>> how_many_times('a', 'aaaa')\n    1\n    \"\"\"\n    if number == start:\n         return self.start", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n    if not string.endswith(substring):\n        return 0\n    else:\n        return len(string) - count(substring, string)\n\nThank you very much!</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(substring) / len(string)\nThat's a good trick, but in this case we have to define what 'a' means.  Otherwise, it could also include 'b' and 'c'.  I think you'd need some sort of variable, if you wanted to get at the same thing:      how_many_times('', 'a')", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    if string == '':\n       return 0\n    else:\n       return len(string) - 1\n\nSee also:\n\nsubstring(int, string) -> int\nfind(string, substring) -> int\n(Although I'm not entirely sure you can't use how_many_times to compute the length of a substring.)\n\nHow can I implement it, I have to build a function which gives me how many times the substring exists. I have to return the substrings and the number of times it exists.\n\nhow_many_times is just a function that takes one or two arguments and returns the number of times the first argument exists in the second argument. If you want to be able to give it a list of substrings and a list of length of the substrings, you'll need to write your own version of the function, but the code you posted was just a snippet of the function and not the full function.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    string_count = 0\n    for i in range(0,len(string)):\n        if string[i:i+strlen(string)-1] == substring[i]:\n             string_count += 1\n    return string_count\n\nI just tried this in my REPL and it does not work. It does in CPython 2.7 and 3.2.\n\nI wonder if the problem is in your repl.\n\nI've noticed that the matplotlib python bindings are very very slow. This kind of thing would be very slow, unless it is written in pure c.\n\nIt's just a single Python function. The only thing that needs to be compiled is the __builtin__ function call.\n\nThe return type is integer. This is a lot of overhead for such a small thing.\n\nThe overhead isn't that much, it doesn't have to do anything special like interpret the return value or anything. It's a simple integer value.\n\nYou do realize that there is overhead for converting a string to an integer? That's why the built in string", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, count: int = 0):\n        self.count = count\n\n    def find_count(self, substring: str):\n        \"\"\"\n         Find the number of occurences of substring in string.\n         Returns : The number of occurrences of substring in string.\n         Examples :\n         >>> how_many_times('', 'a')", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def string_overlap(x, y):\n    \"\"\"\n    Count the overlaping cases.\n    >>> string_overlap('aaaa', 'aa')\n    3\n    >>> string_overlap('a', 'aa')\n    1\n    \"\"\"\n    count = 0\n    while not x:\n       y = string.find(y, x)\n       count += 1\n    return count\n\nYou could also use it like this:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for char in string:\n       if char in substring:\n          count += 1\n    return count\n    def same_length_as(s1, s2):\n    \"\"\" Test if two strings have the same length.\n    >>> s1 = 'a'\n    >>> s2 = 'ab'\n    >>> same_length_as('a', 'ab')\n    True\n    >>> same_length_as('abc', 'def')\n    False\n    \"\"\"\n    if len(s2) == len(s1):\n       return True\n    return False\n\nI think it would be more interesting to compare how much of a difference there is between the lengths of the two strings, not whether or not they are the same length.\n\nThis is a good point. I wrote a gist to show how it might look.\nhttp://gist.github.com/491484\n\nThis is really cool, but how", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    how_many_times = lambda s: 0\n    for character in s:\n       if character not in how_many_times:\n          how_many_times += 1\n    return how_many_times", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def how_many_times_helper(start: str, end: str):\n    \"\"\"\n    Helper method for counting how many times a substring appears in the original string.\n    >>> how_many_times_helper('aaa', 'aa')\n    3\n    \"\"\"\n    def how_many_times(string: str, start: str, end: str):\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('aaa', 'aa', 'aaa', 'aa')\n    3\n    \"\"\"\n    def __main__(args: array) -> None:\n    \"\"\" Main program.\n    >>> import sys\n    >>> print sys.argv\n    ['test', '', 'test', '', 'test']\n    >>> main(sys.argv)\n    Traceback (most recent call last)\n    File \"\", line 1, in <module>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if not string.is_empty():\n        return len(string)\n    count = 0\n    for substring in string:\n        if substring not in string[count]:\n           count += 1\n         return count\n\nIt is very easy to beat.\n>>> how_many_times('aaa', 'a')\n3\n>>> how_many_times('aaaa', 'aa')\n3\n>>> how_many_times('aaaaa', 'aaaaa')\n3\n>>> how_many_times('aaaaaaaa', 'aaaaaaaa')\n3\n>>> how_many_times('aaaaaaaaaaaa', 'aaaaaaaaaaaa')\n9\n>>> how_many_times('aaaaaaaaaaaaaaaaaa', 'aaaaaaaaaaaaaaaaaa')\n3\n>>> how_many_times('aaaaaaaaaaaaaaaaaaabbbbbbbb', 'aaaaaaaaaaaaaaaaaaabbbbbbbb')\n5\n>>> how_many_times('aaaaaaaaaaaaaaaaaaabbbbbbbbbbb', 'aaaaaaaaaaaaaaaaaa", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\" Return:\n    \"\"\"\n    \"\"\"         The number of times the substring appears.\n    \"\"\"\n\nI love Python. I really do. But this is just ugly. There is nothing more to say.\n\nIt's certainly not idiomatic, but I don't think it's especially ugly. The thing that makes it ugly is the fact that most people don't know how to write idiomatic Python.\n\ni know, i was going to say the same thing. you're absolutely right, but i think you could make it more pythonic without having to use the (in this case) useless function keyword.\n\nPython has a tendency to separate concern. Here's the same logic without using a function:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string in string_parts(string):\n        return 0\n    return len(string_parts(string))\nThis looks like a textbook case for a hash table. It has O(1) lookup and, in this case, O(1) put/delete time.\n\nOr even simpler:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n    def how_many_times_left(string: str, substring: str) -> int:\n    \"\"\" Find how many times the substring can be found in the original string after the last occurrence. Count overlaping cases.\n    >>> how_many_times_left('aaaa', 'aa')\n    1\n    >>> how_many_times_left('aaaa', 'aaaa')\n    0\n    \"\"\"\n\n    def how_many_times_right(string: str, substring: str) -> int:\n    \"\"\" Find how many times the substring can be found in the original string before the first occurrence. Count overlaping cases.\n    >>> how_many_times_right('aaaa', 'aa')\n    1\n    >>> how_many_times_right('aaaa', 'aaaa')\n    0\n    \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for c in string:\n        if c in substring:\n            count += 1\n    return count\nYou need to implement an iterator for the string (basically an infinite loop) for this to be efficient.  Also this is O(n), which is only useful when n is small.\nI think it's more O(n) + n.  But yeah, still not worth it.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\nIt looks like a nice idea. I wonder if it could be generalized to handle more complex situations like \"find how many times 'abc' appears in 'def'\".\n\nIt doesn't have to be hard:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string).count('[^']*', string[-len(string)-1:])\n\nUsage:\n>>> print how_many_times('a', 'a')\n3\n>>> print how_many_times('aa', 'aa')\n3</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string.split(substring, \" \"))\nAnd the dumbest part is that the above comment is not a joke.\n\nThat's not the dumbest part, it's actually the smart thing to do! If you want the count of how many times a substring can be found, you don't care about the order of the occurrences. That's why this approach is better.\n\nDon't you think it's hard to read?\n\nWell, let's think about what it's doing. The only way to find the count of how many times a substring appears is to do a _global_ substring split, and then count the number of results.\n\nI prefer to find the number of overlapping subsequences using a breadth-first search.\nThat is, given a substring s and a start position in the string s, find all positions in s with s < start < end + len(s) and sum the number of times the substring appears.\n\nThat's pretty slow, since you have to do a string split to get the subsequence.\n\nNot if you start by splitting the string into lists, which is the correct approach.\nThen the substring search", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, str: str, substring: str) -> None:\n        self.substring = substring\n        self.count = 0\n    def __call__(self, substring, count=None):\n        if count is None:\n           count = self.substring.find(self.str)\n           return count\n        else:\n           count = count or 1\n        return count\n    def __str__(self):\n        return self.str\n\nHere's the trick.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # Note: `str` can be a string or an array, or even a list (but it must\n    # contain only the substring we are looking for)\n    n = string.count(substring)\n    return n", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n    return len(string) - len(substring)\n\nIt is interesting that there is no mention of the fact that this is only a single pass algorithm, i.e. it assumes that there are no overlapping substrings in the string. I didn't read the full text, so I could have missed something.\n\nThanks. I added it to the FAQ.\n\nEven better, it would be nice if someone with more expertise would write it in a more standard style, with a few more features. Like, for example, how to handle repeating substrings in the string.\n\nPerhaps a good addition would be a comparison with _contains_, _in_, _in_n_, _in_n_n_, _n_ and _find_ (using a're' prefix), which are the other ways of checking for a substring in a string in Python.\n\nThat's a great idea. I've added it to the FAQ.\n\nIt's worth pointing out that Python's _contains_ is significantly different from the C++ strstr or the ANSI C strstrn.\nAFAIK, the standard Python implementation is equivalent to\nstrstr(s,", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    lines = string.splitlines()\n    for line in lines:\n       if string.find(line[1], substring) == 0:\n          return 1\n       else:\n          return how_many_times(line[2:], substring)\n       return 0\n\nThis is pretty similar to the other one posted, but slightly faster.\n\nThe key is that instead of counting how many times the substring appears in the entire string, you count how many times it appears in the first word.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    if string[substring] == string[substring+1:]\n        return 1\n    return 0", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, s: str, start: int=0):\n    \"\"\" Initialize a new string_search_time object.\n    >>> s = \"John Smith\"\n    >>> start = 0\n    >>> how_many_times(s, 'John')\n    0\n    >>> how_many_times(s, '.')\n    3\n    \"\"\"\n    def __cmp__(self, other):\n    \"\"\" Compare how_many_times to another search string.\n    >>> how_many_times('', 'b') == how_many_times('', 'b')\n    True\n    >>> how_many_times('', 'b') == how_many_times('aaaaa')\n    False\n    \"\"\"\n    return int(str.find(' ', -1) - str.find(' '))\n\nHere's a slightly faster version that eliminates the need for a dictionary lookup:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nYou have a space between \"substring\" and \":\" which you don't need.\nThe comment should probably be a docstring.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n    def how_many_times_string(string: str, substring: str) -> int:\n    \"\"\" Same as above, but returns the number of cases.\n    >>> how_many_times_string('aaa', 'a')\n    3\n    >>> how_many_times_string('aaa', 'aa')\n    6\n    \"\"\"\n    def how_many_times_multiple_strings(string_list: str, substring_list: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times_multiple_strings('aaa', 'aa')\n    3\n    >>> how_many_times_multiple_strings('aaa', 'aaaa')\n    6\n    \"\"\"\n\n    def find_overlapping_cases(string: str, substring: str, delimiters: str):\n    \"\"\" Find cases where a substring can be found more than once in the original string.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for s in string:\n       for s in substring:\n          if s not in count:\n             count = count + 1\n    return count\nAh, so this is the origin of that idiom.\n\nSee also, A Programmer's Glossary: http://www.joelonsoftware.com/articles/fog0000000019.html\n\nThere are a couple of different ways to count the number of occurrences of a substring in a string. One way is to iterate over all the characters in the string and count them. The other way is to use a set data structure.\n\nThere is a third way.\nhttps://github.com/bronzeagle/cogsci-python#coincidences\n\nSo the third way is to use a third way?\n\nThis is the origin of the idiom that a third way of doing something is the wrong way.\n\nI found a gem in the examples:\n>>> x = 1\n>>> print x\n>>> x = 2\n>>> print x", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string.substring(string.index(string.find(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.substring(string.index(string.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for character in string:\n       count += 1\n    return count\nI'd be more comfortable with      return max(count for c in string)\n\nAFAICT, it's more efficient to do the comparison in the same pass as the loop iteration, than to do it all at the end.\n\nI think it is more important to have it perform the same way with different lengths of strings.\n\nI see no reason to change the algorithm, though.\n\nSince the function does not return anything, it might as well be called count instead.\n\nIt returns the number of times that substring appears in the original string, which can be useful.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, substring: str) -> None:\n        self.substring = substring\n   \n    def __call__(self, substring: str, count: int):\n    \"\"\" Return the number of times the substring can be found in the original string. If the substring does not appear in the string, return the count of the end of the string.\n    >>> how_many_times('aaa', 3)\n    3\n    >>> how_many_times('aa', 0)\n    0\n    >>> how_many_times('aa', 3)\n    6\n    >>> how_many_times('aa', 1)\n    9\n    >>> how_many_times('aa', 2)\n    12\n    >>> how_many_times('aaa', 3)\n    21\n    \"\"\"\n    count = 0\n    for x in self.substring:\n       count += 1", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # find the first occurrence of substring in the original string\n    first_match = []\n    for character in original:\n        if original[character] == substring:\n           first_match.append(character)\n           return first_match.size()\n    return 0\n\nTry and solve it yourself before posting.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n    def __init__(self, string, substring):\n    \"\"\" Initialize the class.\n    >>> how_many_times = HowManyTimes(''', '')\n    >>> how_many_times.substring = 'a'\n    >>> how_many_times.substring = 'a'\n    >>> how_many_times.substring = 'a'\n    >>> how_many_times.substring = 'a'\n    >>> how_many_times.substring = 'a'\n    >>> how_many_times.substring = 'a'\n    >>> how_many_times.substring = 'a'\n    >>> how_many_times.substring = 'a'\n    >>> how_many_times.substring = 'a'\n    >>> how_many_times.substring = 'a'\n    >>> how_many_times.substring = 'a'\n    >>> how_many_times.substring = 'a'\n    >>> how_", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n    def __repr__(self):\n    return \"<s: how_many_times(%r, %r)>\".format(self.string, self.substring)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # Non-overlapping count.\n    count = 0\n    # Find all positions in the string.\n    for i in range(len(string)):\n        for j in range(i+1, len(string) - i):\n           if string[j] == substring[i]:\n               count += 1\n           else:\n               count = count - 1\n         return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"Convert to list:\n    \"\"\"\n    if len(string) == 1:\n        return len(string)\n    elif len(string) > 1:\n        return string\n    else:\n        return string.split()\n\nIs there a way to do that in pure python? I'm trying to wrap my head around how that works.\n\nThe only way I can think of is to use a list comprehension and pull the substring out of the original string.\nYou could then create a new string from that substring, and take the count of the number of occurrences of that substring in the new string.\n\nI was able to do that in python, thanks!\n\nI would like to see that done in ruby.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI use this in my code where I also need to keep track of which cases have already been found.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string)\n>    def how_many_times(string: str, substring: str):\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    return len(string)\n>    def how_many_times(string: str, substring: str):\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    return len(string)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __new__(cls):\n         return cls.__new__\n         def __init__(self, string: str, substring: str):\n            \"\"\" Create a new instance.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string == '':\n       return 0\n    for s in string:\n        if s in string[-1]:\n            return how_many_times(string[-1:], substring)\n        else:\n        return 0\n\nCould someone ELI5 why this is better than the simpler:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    k, v = string.split() # Split the string into a \"key\" and a \"value\"\n    k = string.index(v[0], substring) # Get the index of the first character in the substring\n    if k!= -1:\n        v.append(k) # Add the substring to the original string\n    return v.size # The size of the string\n\nThis is more like \"replace\" than \"find\".\n\nThank you, I corrected it.\n\nI've always wanted to know this. I always thought that it was O(n). Thank you for the code.\n\nThere's not much new under the sun, but it's always nice to see someone else's example of it.\n\nFor pythonistas, this is the built-in \"finditer\" function.\n\nI've always thought the built-in finditer function is pretty horrible. It's O(n^2) in the worst case, so it's extremely slow (which is why it's never used in practice).\n\nFor those who think it is horrible, you can replace it with a custom", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n    def find_matches(string: str, substring: str) -> None:\n    \"\"\" Given a substring, find all matches of this substring in the original string.\n    >>> find_matches('aaaaaa', 'aaaa')\n    [('a', 1), ('a', 2), ('a', 3)]\n    \"\"\"\n\n    def is_substring(string: str) -> bool:\n    \"\"\" Returns True if the string is a substring of the given string.\n    >>> is_substring('aaaaaa', 'aaaa')\n    True\n    >>> is_substring('aaaaa', 'aaaa')\n    False\n    \"\"\"\n\n    def contains(string: str, substring: str) -> bool:\n    \"\"\" Returns True if the given substring is found in the string.\n    >>> contains('aaa', 'a')\n    True\n    >>> contains('aaa', 'ab')\n    False\n    \"\"\"\n    def contains_in_order(string", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for start in string.finditer(substring):\n        count = count + 1\n    return count\n\n_How many times a given substring can be found in the original string._\nThis is different than the way I would have written it. I would have called this how_many_times_in_string. It's a clearer name, and it's more descriptive about what the function does.\nIt's a minor point, and I don't know how many people would have a problem with this particular implementation, but I've found that a consistent naming scheme is important. It makes it easier for future programmers to understand what's going on.\n\nI would say, for an example of a more descriptive name, that \"find_iter\" would be a more descriptive name than \"finditer\".\n\nAlso, you might want to consider changing \"finditer\" to \"finditer_start\" to emphasize that this isn't a full-fledged iterator.\n\nI don't know Python, but it seems you can accomplish the same task by:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # First, find the substring in the original string.\n    substring = string[str.find(substring)]\n    # Then, find how many times the substring can be found\n    # in the original string.\n    # If the substring does not match the original string,\n    # return the number of characters in the original string.\n    if substring!= str:\n       return len(str)\n    else:\n       return how_many_times(substring, str)\n    # Find the maximum number of times that the substring can be found in the original string.\n    return max(how_many_times(substring, str))\n\nThis is where I got stuck, is this how the problem is intended to be solved?\n\n_This is where I got stuck, is this how the problem is intended to be solved?_\nYes, that is how the problem is intended to be solved.\nYour solution is not correct.\n\ni'm not sure that's correct - the problem says to find", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    for sub in string.substring(start, end):\n        if sub not in string:\n           return 0\n        return 1 + len(sub)\n\nfor sub in string.substring(start, end):\n    if sub not in string:\n       return 0\n    return 1 + len(sub)\n\nfor sub in string.substring(start, end):\n    if sub not in string:\n       return 0\n    return 1 + len(sub)\n\nthat's a lot of repetition.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n    def __iter__(self):\n        return iter(self.__next__())", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string, substring: str) -> None:\n    \"\"\"Initialize", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if len(string) == 0:\n       return 0\n    result = 0\n    for char in string:\n        if char == substring[-1]:\n            result += 1\n            return result\n\nIf you want to be sure it doesn't overcount, use a boolean (counting_overlapping_substrings) instead of just returning 0.\n\nthanks - I did not know this, and I have been coding for a while.\n\nYour welcome.\n\nNice, but:\nThis is a special case of a more general problem that is a classic of the literature: string matching.\nSee for example Knuth's _The Art of Computer Programming_ Volume III: _Sorting and Searching_.\n\nWe might as well use a hash table and a bunch of if-else statements, right?\n\nDoesn't the article just call it a \"hash\"?\n\nYes, and I think the GP was just referring to the fact that the author called it a hash table.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # Build a string with all the overlaps.\n    r = string.join('' for (n, i) in range(len(string)) if string[i] in string[n])\n    # This is called a greedy algorithm, because it will\n    # continue to look for overlaps even though the original\n    # string has no more overlaps.\n    while r:\n        if string[i] in r:\n            return i\n        else:\n            return 0\n    return len(r)\n\nI don't see any difference from the article's solution.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(substring)\nI'm not sure if it's still valid in Python 3 but this won't work in Python 2.  In Python 2 you need to use the count() function.\n\nCan you explain this? I don't understand why you can't simply use the len() function in 2?\n\nThe length of a string with \"a\" in it is three, but there is no string with \"a\" in it that is longer than one.\n\nYes, I understand that. I just don't understand why len() would return 0 and not 3 in this case.\n\nThe exact string \"a\" occurs three times, once in the first character, once in the second character, and once in the third character. The length of the entire string is three, but the length of any individual substring is one.\n\nThat makes sense. Thank you.\n\nIt's a bit easier to understand if you take the string to be a list of characters.\nThe sequence \"a\" occurs three times in the list, and the list is 3 characters long.\n\nRight, and the length of the sequence is 3. So why would the length be 0?\n\nBecause the length", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    return len(substring)\n    if string == substring else 1\nThis is the most elegant solution.\n\nIt's so elegant, it's like poetry, it rhymes!\n\nNope, it's not. The least number of characters that the substring 'aaa' can match the string 'aaa' is four. It is not five, because the string 'aaa' does not match the substring 'aa' at position 1, 2, 3, 4, and 5.\nThe problem is even simpler than that.\n\nThe solution is elegant but it's not correct.\n\nIt's also vulnerable to a very obvious attack, if the substring has a length > 1.\n\nand that is?", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string[substring] == 'a':\n       return len(string)-1\n    return len(string)-1\nI understand what the code is doing, but I don't understand why it's doing it that way, rather than just doing a single linear search.  Care to elaborate?\nIf you do a linear search, you have to loop through the string once for every possible substring.  In this case, the substring 'a' will be found once, 'aaaa' three times.\nWell, I thought the point of the program was to find how many times a substring can be found in a string.  So, the only way it's going to find the substrings is to loop through the string once for every possible substring.  Am I misunderstanding the purpose of the program?\nThe point of the program is to find how many times a given substring can be found in the original string.   The most natural way to implement this is to use a string index (i.e. 0, 1, 2...).  You can use that index to find the first occurrence of the substring.  If that substring occurs more than once", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    count += 1\n    while count < length(string) - 1:\n         if substring in string[count]:\n            count += 1\n    return count\nThis is an awesome solution, especially the fact that it's just one line. My first thought was to use a dictionary for the first solution, but this is much better.\nI don't understand the third solution, though. What if the substring is \"aa\" and the string is \"aaababababababa\"?\n\nThe third solution is just another way to do the first solution.\nAnd no, it won't work for \"aaababababababa\". It only works for things that can be repeated exactly N times.\n\nOr more simply:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return int(string.count('a')) + int(string.count('a'))\nThis is broken in Python 3. `count(a)` and `count(a, 'a')` are different.\n`return int(string.count('a')) + int(string.count('a'))` should work, though.\nThat works. I didn't realize there was a difference between `count(a)` and `count(a, 'a')`.\nIt's a minor difference that has a major consequence when dealing with strings.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    n = len(string)\n    if string.startswith(substring):\n       return int(n)\n    else:\n       return 1\n\nIt's a little off.\n>>> how_many_times('aaa', 'a')\n3\n>>> how_many_times('aaa', 'aaa')\n1\n\n\"a\" and \"aaa\" are not the same string, even though the end points are identical. The \"aaa\" substring doesn't include \"a\", so it's only counted once.\n\nI think this is the same as:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def make_string(substring: str):\n    \"\"\" Create the original string by concatenating the substring with itself.\n    >>> make_string('a', 'a')\n    'aaa'\n    >>> make_string('a', 'aa')\n    'aaaaaa'\n    \"\"\"\n    return string.format(substring, '%s')\n\nI think that's what you're looking for.\n\nLol, I was thinking of that one, but I was wondering if there was a way to not concatenate with itself, and just have it find the number of occurrences of the substring.\n\nI was thinking of that too and I just had that idea for a way to do it.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n        def find_count(x: str):\n         return len(x)\n        def find_count(x, y: str):\n         if x.find(y):\n            return y\n        return x.find(y)\n        def find(x, y: str):\n         if x.find(y):\n            return y\n        return x.find(y)\n        def find_counts(x: str, substring: str):\n         return len(x) * how_many_times(substring, x)\n\nIsn't it a bit odd to call it \"how many times\" if you're not looking for all occurrences of a substring?\n\nI think the name is from how many times the substring is repeated", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string[start:end]) - len(string[start:start+substring])\nIf you are not planning to change it, you can simply use it as it is. If you want to improve it you can use a couple of techniques, for example you can find the position of the first occurrence of substring, then use a length function instead of the one above.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n    count = 0\n\n    for i, pos in enumerate(string):\n        count += pos[0]\n    return count\n\nThe first version would be cleaner in my opinion if you would name the function \"overlapping_count\" and then use it in the more terse version:\nHow many times a given substring can be found in the original string.\n>>> how_many_times('a', 'a')\n3\n>>> how_many_times('aa', 'a')\n3\n>>> how_many_times('aaaa', 'a')\n3\n\nHowever, I'm not sure if that is actually any more efficient.\n\nOr you could do this:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string, substring, find_overlaps=0):\n        self.string = string\n        self.substring = substring\n        self.find_overlaps = find_overlaps\n        self.find_overlaps_recursive = False\n        self.found = 0\n\n        def __call__(self, original_string, count=None):\n        if count is None:\n            count = 0\n            for char in original_string:\n                self.string = self.substring = char\n               if self.substring in self.string:\n                   self.found += 1", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n    # find the position of the substring\n    l = string.split(substring, \" \")\n\n    # keep track of the position of the substring\n    # if it's the first occurrence, return 1\n    for c in l:\n        if c == 1:\n           return 1\n        else:\n           return 0\n    return len(l)\n\nI would add a few more tests. But it does the job.\n\nI think it would be good to also provide a solution that uses a bitmap.\n\nHow about this? \n\nI thought about that one, but it's not obvious that it's the best solution. One of the advantages of a bitmap is that you don't need to know the length of the string beforehand.\n\nOk, I've modified the code to use a bitmap.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n    def __getitem__(self, index: int) -> int:\n    \"\"\" Return how many times a given substring is found in the original string.\n    >>> how_many_times('aaaaaa', 'a')\n    3\n    \"\"\"\n\n    return (index, len(substring))\n\nWhat is the advantage of this over a regular expression?\n\nThis will work if the string is Unicode, not just ASCII.\n\nBut regular expressions can be easily converted to Unicode.\n\nIn python, sure. How about in Ruby, Perl, C++, Haskell, etc?\n\nIn ruby:\nmatch :multi(\n\\w+", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    import re\n    def matches(string: str):\n    \"\"\" Returns a list of strings that match the original.\n    >>> matches('aaa')\n    ('aa', 'aaa')\n    \"\"\"\n    return re.findall(string.lower(), string.upper(), 0)\n    def matches_overlapping(string: str, substring: str):\n    \"\"\" Finds how many times a substring can be found overlapping the original.\n    >>> matches_overlapping('aaa', 'aa')\n    3\n    >>> matches_overlapping('aaa', 'aaa')\n    2\n    \"\"\"\n    return matches(string)\nThis is a solution I came up with that I'm a bit proud of. Any thoughts?\n\nI'd rather see the Python equivalent to Ruby's Enumerable#count method, which does not use any external libraries to compute the count. It is somewhat less trivial to implement.\n\nCounting overlapping occurrences seems like a harder problem to solve.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n\n    for char in string:\n        count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"This function iterates over all the characters in the string from the start till the end,\n    looking for the substring from the start till the end of the string.\"\"\"\n    a_chars = string.letters\n    s = string.characters\n    while a_chars!= s:\n        if s[a_chars:]:\n            a_chars -= s[a_chars:]\n            a_chars = string.letters + s[a_chars:]\n            s = string.characters + a_chars\n            return a_chars\n    return int(a_chars)\n\nRelevant part of the Python documentation:\n\nDoes this function use the same `.letters` that Python's `str.letters` does? Or is it using a different (and perhaps faster?) way to iterate over the string?\n\nNo, it uses a", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if not string[substring]:\n        return 0\n    return len(string.strip(substring))\nLooks like you should `return len(string.strip(substring)) - 1` instead of `len(string.strip(substring))`.\n\nnot sure if I understand correctly but I think you're right, I'll try to change it.\n\nYou're right - the function is correct, and you don't need to modify it.\nFor a more formal explanation see https://en.wikipedia.org/wiki/Counting_method.\n\nWith only the \"with\" syntax, it can be even shorter:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nThis is not a loop. It does not even do anything. It is a function that returns the length of a string.\nJust what I'm looking for.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for i in range(len(string) - 1, len(substring) - 1):\n        count += len(substring)\n    return count\nThis one's much faster than the one above.\nEdit: I haven't made a lot of time to make this one better, but I found a couple of problems:\n1) If you have some string with a single character, it'll return that character as the answer.\n2) If you have a string of zeros, it'll return -1.\n3) If you have a string of all the same character, it'll return -1.\n\nFor my purposes, I didn't need to count every case, I only needed to count some. I found this variant more efficient:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string.lower(substring))\nyou mean to say \"return len(string.lower(substring))-1\"</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # Substring is always represented as a character\n    # so we use a regular expression. This allows us to match\n    # any character in a given range.\n    # Match the substring 'aaa', which consists of the characters 'a'\n    # and 'a' and a '.'.\n    # Match a '.' in the original string, and match 'aa' for three\n    # times.\n    # Note that \".\" is escaped when it is part of the substring\n    r = re.compile('^[0-9A-Za-z]+$')\n    count = 0\n    while r.match(string):\n        count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) + len(substring)\n    def subword(string: str) -> int:\n    \"\"\" Find how many subwords, each of length 3, can be found in the original string.\n    >>> subword('aaabbbbcccdddddddddeeeeeeeeeee', 3)\n    3 \"\"\"\n    return len(string) - len(string[0:2])", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return int(string.find(substring)).count(substring)\nis that the only difference?\nI'm a little confused as to why this is so much faster (20x for me) than the function in the article.\n\nYes, that's the only difference.\n> I'm a little confused as to why this is so much faster (20x for me) than the function in the article.\nPython's string.find is slow.\n\n_Python's string.find is slow._\nWow, I didn't know that. I've been using it for a bunch of string searching in my code. I wonder if that's part of the reason I see a significant performance hit when working with some large datasets.\n\nfind is slow when there are no matches, since it has to loop over the string. It's not too bad if there are matches, since there are only 8 comparisons, but it's still not as fast as the naive solution.\n\nAm I doing something wrong? The code is really slow, even after adding the line:\nimport itertools\nand changing the function to:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return string.count('a', substring)\nWhy is it called how_many_times?</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nWe will have to use a string formatting library (i.e. string.Template) to perform string formatting", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string[-substring:])\nFrom the comments:\n>>> how_many_times(\"aaa\",\"aaaa\")\n3\n>>> how_many_times(\"a\",\"a\")\n0\n>>> how_many_times(\"aaaa\",\"aaa\")\n0\n>>> how_many_times(\"aaaa\",\"a\")\n1\n>>> how_many_times(\"aaa\",\"aaaa\")\n2\n\n> def how_many_times(string: str, substring: str) -> int:\n>    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n>    >>> how_many_times('', 'a')\n>    0\n>    >>> how_many_times('aaa', 'a')\n>    3\n>    >>> how_many_times('aaaa', 'aa')\n>    3\n>    >>> how_many_times('aaaa', 'a')\n>    3\n>    >>> how_many_times('aaa', 'aaaa')\n>    2\n\nNot really", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string)\n\nfucking beautiful</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\" We start at the beginning of the string. If the substring is not found, we go to the end of the string. If the substring is found, we count the number of times it appears.\n    \"\"\"\n    words = string.split(substring)\n    num_words = 0\n    for word in words:\n        if word in string:\n            num_words += 1\n        else:\n             num_words = 0\n    return num_words\n\nWow, that's probably the most concise implementation I've seen!</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string.split(substring,''))\nThis is the correct answer.  The reason it is the correct answer is that if you take your substring and split it again with the new substring, you get exactly the same number of results.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return sum(uniq(string.lower().split(substring), max_count=len(string.lower().split(substring)))\nYou can do it in one line!      return uniq(string.lower().split(substring), max_count=len(string.lower().split(substring)))\nHow?\nstring.lower().split(substring)  returns an iterable of strings.  uniq() counts how many elements it has.   max_count is len(string.lower().split(substring))      return uniq(string.lower().split(substring), max_count=len(string.lower().split(substring)))\nWhoa. This is the first time I've seen a comment with a code snippet in it on reddit.\nIt's also the first time I've seen someone do this kind of code-commenting outside of a Python, C++ or Java course.\nI've been programming in a lot of languages for almost 10 years and I've never seen that.\n> 10 years  It's not a very recent thing. I've seen it in a few other languages over the", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string, substring):\n        self.string = string\n        self.substring = substring\n    def count(self, position, substring):\n         self.substring = substring[position:]\n         if self.string.index(self.substring) > 0:\n            return self.string.count(self.substring)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string.lower(substring) for sub in string if not string.startswith(substring))\n> What if the string is a single character?\n> How do you convert a single character to an integer?\n`1`?  I thought that was obvious.\n> How about a substring that is an empty string?\n> How do you convert a substring that is an empty string to an integer?\nIf you look at the source code, it's not being converted to an integer. It's being compared using `<`.\n> How do you convert a substring that is an empty string to an integer?\nI believe you have your answer.\n\nThe problem is that it is a one line function that does not explain how it works. The author doesn't explain how it works or what the limitations are.\nI don't want to see a source code example, I want to see a concrete explanation of how it works. The fact that the author responded with \"How about a substring that is an empty string? How do you convert a substring that is an empty string to an integer? If you look at the source code, it's not being converted to an", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\nIt's probably worth mentioning that this is a solved problem (via suffix trees) and is implemented in many languages.\n\nI think it is worth mentioning that there is no universal solution to this problem.\n\nIt is a solved problem that _exists_ as a solved problem in many languages.\n\nNot really. If you know a programming language, you can usually implement a solution for a given problem in it.\n\nThis is a great little example for string processing. I particularly like the use of __index__.\n\nIt would be nice to see some benchmarks.\n\nI like the idea.\n\nI will think about adding benchmarks.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\" Decorator for `str` to create a new string with the given substring.\n    \"\"\"\n    \"\"\"\n    return str(substring) + str(substring + 1)\n\nThis is really neat, but what's the use-case for it?\n\nThe primary use case is for me to learn how to use Django's built-in query functions. However, I've found myself using it more and more for writing JSON APIs.\n\nWhat's the benefit of it over using the raw string module (which allows you to do 'a', 'a' too)?\n\nThe string module requires you to explicitly create the resulting string, where as the query decorator does it for you.\n\nThis is great. How does it work? Is it using string interpolation?\n\nIt's a python decorator, not string interpolation.\n\nOh, I thought Django's query module was also some sort of decorator.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\nNo one will use this over count. How is this better than count?\n\nI think that the author is trying to avoid using itertools.count, to be pedantic.\n\nWhile I get that, I think that it's still important to compare it to standard, simple, idiomatic Python code. For example, if the goal was to replace itertools.count, the resulting function could be:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if not string.isalpha():\n        return 0\n    return count(substring in string)\nI used this in a project, it's a pretty useful function!\nI'd like to add a PEP8 style comment:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(substring)\nI do find it annoying that len() is what people default to when they want to count something in Python.\n\nWhat would you use?\n\nI'd probably use a Counter object (which would be a simple wrapper around the built-in Counter) to avoid side-effects.\n\nAnd the real Python code:\nimport collections\n\nThis would be a good candidate for a Python 3 example.\n\nI don't understand why this is downvoted. Python 3 is more than 3 years old, and it's still not widely used. It's still a good candidate for an example.\n\nBecause it's a borderline flame-bait comment. There's no reason to include Python 3 (not to mention it's not included in the link). If the comment was \"This would be a good candidate for a Python 3 example\" I don't think you'd see any downvotes at all.\n\nThe counter is a built in function, hence my comment.\n\nRight, but the built in function was updated to use the collections module in Python 3. You can't use it in Python 2 without some kind of wrapper (such as a Counter object).</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if substring in string:\n       return len(string)\n    elif len(string):\n       return 1\n    else:\n       return 0", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n        return max(len(string), len(substring))\nThis returns 0 for the first substring example.\nHow did you come up with that?</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\nMy favorite is the comment that's just a slightly different way to do the same thing, but less concise and more confusing."]]