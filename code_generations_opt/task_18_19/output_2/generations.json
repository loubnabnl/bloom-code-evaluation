[["def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    for i in range(0, len(string)):\n        if string[i] == substring[0]:\n           return i\n    return 0\nThis is a neat one.  The trick is that the substring is being passed as a string, so it's just a regular expression.  So you just need to match the whole thing and then check to see if you matched the whole thing.\n\nThis is a neat one. The trick is that the substring is being passed as a string, so it's just a regular expression. So you just need to match the whole thing and then check to see if you matched the whole thing.\n\nCan you explain that in a little more detail? I'm not sure I understand how that works.\n\nIt's a regular expression, so it can match any character, including itself.\n\nSo what happens if you try to match the same substring twice?\n\nYou can't. The code that calls the function is only given the substring once, so it's impossible to match the same substring twice.\n\nI see. Thanks for the explanation.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def count(string: str, substring: str):\n    \"\"\" Find how many times a given substring can be found in the original string.\n    >>> count('aa', 'aaa')\n    3\n    >>> count('aaaa', 'aa')\n    3\n    \"\"\"\n    return len(string) + count(substring)\n\nI don't know if there's a name for this algorithm, but it's just a variation on the common `count(...)` algorithm.\n\nI'm not sure that I would call that \"sophisticated\".\n\nIt's not sophisticated, but it's very useful.\n\nI'd love to see a tutorial for this kind of thing. I'm coming from a Ruby background, so I'm used to the \"monkey-patch\" way of doing things, and I'm really struggling with the more restrictive (but more powerful) ways of doing things in Python.\n\nCan you give an example of a more restrictive, more powerful way to do things in Python?\n\nI'm not sure if I'm using the right word, but I mean things like decorators, met", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string.find(substring, 0))\nThe problem with this is that it will not handle multiple occurrences of the substring in the original string. For example, `how_many_times('aaaaaaaaaaaaaaaaaaa', 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"Find how many times a given substring can be found in the original string.\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    return len(string) - len(substring)\nThis would be a lot better if it was written as:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def count_overlaps(string: str, substring: str) -> int:\n    \"\"\" Count the number of overlaping occurrences of a substring in the original string.\n    >>> count_overlaps('aa', 'aa')\n    3\n    >>> count_overlaps('aa', 'aaaa')\n    3\n    \"\"\"\n    def find_count(string: str, substring: str) -> int:\n    \"\"\" Find the number of times a substring can be found in the original string.\n    >>> find_count('aa', 'aaa')\n    3\n    >>> find_count('aa', 'aaaa')\n    3\n    \"\"\"\n    def count_overlaps(string: str, substring: str) -> int:\n    \"\"\" Count the number of overlaping occurrences of a substring in the original string.\n    >>> count_overlaps('aaa', 'aaa')\n    3\n    >>> count_overlaps('aaa', 'aaa", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if not string.startswith(substring):\n       return 0\n    return len(string) - len(substring)\n\nNot sure if this is the right place for this, but I thought it was pretty cool.\n\nI think this is a good place to post it. I think it's a really cool little function.\n\nI like it, it's simple, elegant, and useful.\n\nA small improvement I would make is to return a tuple, so that you can do things like:\n>>> how_many_times('aaa', 'aa')\n3\n\nThat's not a small improvement. That's a big improvement, and it makes the function much more useful.\n\nI guess I meant small in the sense that it's easy to make.\n\nI'm not a Python programmer, but I am a Java programmer, and I'm wondering: what is the use case for this? I can't think of a reason to use this.\n\nIt's a useful function for finding the number of occurrences of a substring in a string.\nFor example, if you want to find how many times \"a\" occurs in \"ab", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nYou want to return the length of the substring.  Otherwise, you would return a different number of overlaps depending on how many characters were in the substring.  I think you're trying to return the length of the substring, but you're missing a '-'.  So you're returning the length of the string instead.\nThanks.  I'm not sure how I missed that.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str, substring: str) -> None:\n        self.string = string\n        self.substring = substring\n        return None\n    def __call__(self, string: str, substring: str) -> None:\n        return self.__init__(string, substring)\n    @staticmethod\n    def count(self, count: int) -> int:\n        return self.__call__(string, substring, count)\n\n>>> how_many_times('a', 'aaaa')\n3\n>>> how_many_times('a', 'aaaaaaa')\n3\n>>> how_many_times('aaa', 'aaaaaaa')\n3\n>>> how_many_times('aaaa', 'aaaaaaa')\n3\n>>> how_many_times('a', 'aaaaaaaa')\n3\n>>> how_many_times('aaa', 'aaaaaaaa')\n3\n>>> how_many_times('aaaa', '", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI think it is much simpler than that.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, original_string: str) -> None:\n    \"\"\" Initialize the count of how many times the substring can be found in the original string.\n    >>> how_many_times = HowManyTimes()\n    >>> how_many_times('a')\n    0\n    >>> how_many_times('a')\n    0\n    >>> how_many_times('a')\n    0\n    >>> how_many_times('a')\n    1\n    \"\"\"\n    def __getitem__(self, index: int):\n    \"\"\" Return the count of how many times the substring can be found in the original string.\n    >>> how_many_times.__getitem__('a')\n    0\n    >>> how_many_times.__getitem__('a')\n    1\n    \"\"\"\n    return 1\n\nHow is this different from the built-in function len(string)?\n\nlen(string) would return", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str, substring: str):\n    \"\"\" Initialize the count of the number of times a substring can be found in the original string.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    count = 0\n    for char in string:\n        if char in substring:\n           count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(substring)\nHow is this different than `len(substring) - len(string)`?\n\nIt's more general, for example, it could be used for finding the longest common subsequence (LCS) of two strings.\n\nOh, I didn't think of that. Thanks!</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\n    if string == substring:\n       return len(string)\n    return 0\n\n>>> how_many_times('a', 'a')\n0\n>>> how_many_times('aaa', 'a')\n3\n>>> how_many_times('aaaa', 'aa')\n3\n>>> how_many_times('a', 'aaa')\n0\n>>> how_many_times('aaa', 'aaaa')\n3\n>>> how_many_times('aaaa', 'aaaaa')\n3\n>>> how_many_times('aaaa', 'aaaaaaaa')\n3\n>>> how_many_times('aaaa', 'aaaaaaaaaaaaaaaa')\n3\n>>> how_many_times('aaaa', 'aaaaaaaaaaaaaaaaaaaaaaaaaaaa')\n3\n>>> how_many_times('aaaa', 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')\n3", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string.startswith(substring):\n        return 1\n    else:\n        return len(string) - len(substring)\n\nI've been seeing this a lot lately. Why do people put a space before the final parenthesis?\n\nI've always done that, and I have no idea why.\n\nIt's so you can clearly see the parenthesis at the end of the line.\n\nSo is the space in the code.\n\nI think it's a matter of preference. I personally find it easier to read without the space.\n\nYes, that's the point. It's a matter of preference.\n\nI prefer to use an empty string to denote the empty string.\n\nI prefer to use a single space to denote the empty string.\n\nI prefer to use an empty string to denote the empty string.\n\nI prefer to use a single space to denote the empty string.\n\nI prefer to use an empty string to denote the empty string.\n\nI prefer to use a single space to denote the empty string.\n\nI prefer to use an empty string to denote the", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    return len(string) - len(string[substring])\nAh, the old `return len(string) - len(string[substring])`.\nThat's a good one. I'll keep that one in mind.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nThat's not how you count overlaps.\nIt's not meant to be an overlap count. It's meant to be a count of how many times a substring can be found in the original string.\nI'm not sure I follow, the code is the count of how many times the substring can be found in the original string, I don't see how it could be anything else?\nThe substring can be found as many times as you want in the original string. If you want to count overlaps, then you need to keep track of which characters are already found.\nI see, but then I would have to change the function name.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nThis is wrong.  It's counting the number of times the substring 'a' is in the string, not the number of times the substring 'a' occurs in the string.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string.startswith(substring):\n        return 1\n    else:\n        return len(string) - len(substring)\n    >>> how_many_times('a', 'aa')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n\nI don't understand. The method is a no-op for the example \"a\" in the first line, and it returns 3 for the second line.\n\nThe first line is correct, it returns 1 because there is no substring in the string that starts with \"a\". The second line is incorrect, it returns 3 because the substring \"aaa\" is found 3 times in the string.\n\nNo, it's not. It's a no-op. The method is a no-op.\n\nIt's a no-op because there is no substring that starts with \"a\", not because it's a no-op.\n\nI have to agree with you", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # How to count\n    #\n    # We start by counting the number of times a substring is found in the original string.\n    #\n    # We then subtract 1 for each time the substring is found at the beginning of the original string.\n    #\n    # We then subtract 1 for each time the substring is found at the end of the original string.\n    #\n    # We then subtract 1 for each time the substring is found in the middle of the original string.\n    #\n    # We then subtract 1 for each time the substring is found in the middle of the original string.\n    #\n    # We then subtract 1 for each time the substring is found in the middle of the original string.\n    #\n    # We then subtract 1 for each time the substring is found in the middle of the original string.\n    #\n    return len(string) - 1 + len(substring) - 1 + len(string[len(substring) - 1:] - 1)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # The length of the string is n.\n    # n is the number of characters in the string.\n    # It is the length of the substring in characters.\n    # If there is no substring, then n is 0.\n    # n is the number of times the substring can be found in the original string.\n    # If the substring can be found multiple times in the original string, then n is the number of times the substring can be found.\n    # If the substring can be found multiple times in the original string, then n is the number of times the substring can be found.\n    # If the substring can be found multiple times in the original string, then n is the number of times the substring can be found.\n    # If the substring can be found multiple times in the original string, then n is the number of times the substring can be found.\n    # If the substring can be found multiple times in the original string, then n is the number of times the substring can be found.\n    # If the subst", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def __init__(self, string: str, substring: str) -> None:\n    \"\"\"\n    Initialize the count of the number of times a substring appears in the original string.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    \"\"\"\n    self.count = 0\n    def add(self, count: int) -> None:\n    \"\"\"\n    Increment the count of the number of times a substring appears in the original string.\n    >>> how_many_times('', 'a')\n    1\n    >>> how_many_times('aaa', 'a')\n    4\n    >>> how_many_times('aaaa', 'aa')\n    5\n    \"\"\"\n    return self.count + count\n    def count(self) -> int:\n    \"\"\"\n    Return the count of the", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # Python 2.6.5\n    def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    # Python 2.7\n    def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nThis is not a good idea.  The string could be a very long list of numbers, for example.  It would be much more efficient to check the length of the string first, and then check the length of the substring.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __getitem__(self, index: int, match: str):\n        if match == string.lower():\n           return 1\n         else:\n           return how_many_times(self.substring(match), match)\n        return 0\n   \n\nI'm not sure why the author is using Python 3.2. I think the following is the most idiomatic way to do the same thing in Python 2.7.\n>>> how_many_times('', 'a')\n0\n>>> how_many_times('aaa', 'a')\n3\n>>> how_many_times('aaaa', 'aa')\n3\n>>> how_many_times('aaaa', 'aaaa')\n0\n>>> how_many_times('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    result = 0\n    while string.find(substring)!= 0:\n        result += 1\n    return result\nWhy not just use `len(string)`?\nI can think of a few reasons:   1) len(string) may not be available  2) It's faster to use a function than to call len(string) 3) It's faster to use a function than to call len(string) * 100, if you need to do that\nIf you need to do that, you're probably doing something wrong.\nYou're probably right, but I've seen some pretty bad code in my day.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def count(first, last, count = 0):\n    \"\"\" Return the count of the number of times the first substring matches the last.\n    >>> count('aaa', 'aa')\n    3\n    >>> count('aaa', 'aa', 'aaa')\n    6\n    \"\"\"\n    if first == last:\n       count += 1\n    else:\n       if first!= last:\n          return count\n          return 0\n    return count\n    def how_many_times_overlapping(string: str, substring: str) -> int:\n    \"\"\" Return the number of times the first substring matches the last and overlaps with the second substring.\n    >>> how_many_times_overlapping('aaa', 'aa', 'aaa')\n    6\n    >>> how_many_times_overlapping('aaa', 'aa', 'aaa', 'aaa')", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string.startswith(substring):\n        return how_many_times(string.startswith(substring), substring)\n    else:\n        return 0\n\nYou can use `startswith` instead of `startswith(substring)`.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, substring: str) -> None:\n        self.substring = substring\n    def find(self, substring: str, count: int):\n        return 0 if count == 0 else 1\n    return find\n\nThis is not the same as \"how many times a substring can be found in the original string\" because it does not count the case where the substring is repeated in the original string.\n\nIt's the same if the substring is repeated in the original string.\n\nI'm not sure what you mean by this. The problem is that there are multiple ways that the substring can be repeated. For example, suppose we have the following string:\nfoo\nbar\nbar\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nbaz\nb", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if len(string) == 0:\n       return 0\n    else:\n       return len(string) - 1\n\nI don't know about you, but that's one of the most satisfying things I've read in a while.\n\nI agree. I was going to comment on the same thing, but I'll just add my voice to yours.\n\nI think that it's even more satisfying because it's so simple and readable.\n\nI think it's even more satisfying because it's so simple and readable.\n\nI think it's even more satisfying because it's so simple and readable.\n\nI think it's even more satisfying because it's so simple and readable.\n\nI think it's even more satisfying because it's so simple and readable.\n\nI think it's even more satisfying because it's so simple and readable.\n\nI think it's even more satisfying because it's so simple and readable.\n\nI think it's even more satisfying because it's so simple and readable.\n\nI think it's even more satisfying because it's so simple and readable.\n\nI think it's even more satisfying because it", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if len(string) == 0:\n       return 0\n    return len(string) * count(string[substring])", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    for i in range(len(string)):\n       if string[i] == substring:\n          return i\n    return 0\n\nThis is a classic case of premature optimization.\n\nI don't think it is premature optimization. If you are writing a program that searches through a large text file for a specific string, this could be very useful.\n\nIt's premature optimization because it's not a bottleneck.\n\nThe point of this exercise is to show how to use the regular expression module to find and count occurrences of a substring.\n\nI have never seen this module before.\n\nIt's not part of Python, it's part of the standard library.\n\nI know, I just never saw it before.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # First, get a list of all the substrings in the string\n    list = string.split(' ')\n    # Then, find how many times the substring is in the list\n    how_many_times = list.count(substring)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    for char in string:\n        if char not in substring:\n           return 0\n           if char in substring[i]:\n              return 1\n    return len(string) - 1", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str, substring: str):\n    \"\"\"Initialize the how_many_times function.\n    >>> how_many_times = how_many_times('', 'a')\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    self.string = string\n    self.substring = substring\n    return 0\n\nI don't think it's that complicated.\n\nIt's pretty easy to read, but it's not as easy to understand what it's doing.\n\nI think you have to be a little bit familiar with the problem to understand what it's doing, but it's not that hard to understand.\nI think the more important thing is that it's really hard to understand _why_ you would want to do this.\n\nIf you're like me and you're learning Python, you'll see this type of function a lot.\n\nI'm pretty sure it's a joke, and it's supposed to be a little funny.\n\nThat's a bit of a stretch.\n\nIt's not", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, substring: str, start: int, end: int):\n    \"\"\"Initialize the counter.\n    >>> how_many_times('aaaa', 'aa')\n    3\n    >>> how_many_times('aaa', 'a')\n    0\n    >>> how_many_times('aaaa', 'aa', 'aa')\n    6\n    >>> how_many_times('aaa', 'a', 'aa')\n    3\n    \"\"\"\n    self.start = start\n    self.end = end\n    self.count = 0\n    return self.count\n\nThis is not a Python solution, but a general solution. You can use it in any language that has strings.\n\nAs a Python solution, you could use the standard library.\n>>> s = \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(substring) - len(string)\nI think this is better:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for char in string:\n        count += 1\n    return count\n\nI know that it's a joke, but this is actually a terrible way of doing this.\n\nIt's a terrible way of doing it if you're trying to get the answer in a reasonable amount of time. It's a great way of doing it if you want to learn about python and how the language works.\n\nI agree.\nIt's a terrible way to do it if you're trying to get the answer in a reasonable amount of time.\nIt's a great way to do it if you want to learn about python and how the language works.\n\nI'm confused. What does it teach you about Python?\n\nWell, it's a very naive solution to the problem, which is a good way to learn about the problem.\n\nAhh, I get it. Thanks!\n\nThis is a terrible way to do it. You should use a dictionary and iterate over the keys to find the count.\n\nIt's not terrible, but it's not very Pythonic.\n\nHow is it not very pythonic? It's a", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # We can't really compare strings, but we can compare ints\n    # and we can count how many times a substring is found\n    # in the original string\n    def find(string, substring: str):\n    \"\"\" Find the position of a given substring in the original string.\n    >>> find('aaa', 'aa')\n    0\n    >>> find('aaaa', 'aa')\n    1\n    \"\"\"\n    return int(find(string, substring))", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    return len(string) - len(substring)\nThis is not a very good version of the algorithm because it counts overlaps.\n\nI think the algorithm is not that bad. I would use it as a first cut.\n\nIt's not bad, but it's not optimal.\n\nI agree. It's a very simple version of the algorithm.\n\nI'm curious how it would handle a string like \"abcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcdabcd", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI've always been taught to never use `len(string)`.\nIt's better to use `len(string) - len(substring)`, as you can't always be sure the substring isn't empty.\nI've always been taught to never use `len(string) - len(substring)`.\nIt's better to use `len(string) - len(substring) + 1`, as you can't always be sure the substring isn't empty.\nI've always been taught to never use `len(string) - len(substring) + 1`.\nIt's better to use `len(string) - len(substring) + len(substring)`, as you can't always be sure the substring isn't empty.\nI've always been taught to never use `len(string) - len(substring) + len(substring)`.\nIt's better to use `len(string) - len(substring) + len(substring) + 1`, as you can't always be sure the substring isn't empty.\nI've always been taught to never use `len", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI'm not sure if you're aware of it but it's a bad practice to return the length of the input.\n\nI am aware of it, but I can't think of a better way to do it.\n\nI think the way you do it is fine, and it's clear and readable. I don't know why he said that.\n\nIt's a bad practice to return the length of the input because it's a leaky abstraction.\nWhen you see len(x), you think \"How many bytes is this?\"\nThe fact that the input is a string is not important.\nNow, if you have a function called \"len_string\" you can't expect the caller to know that it returns the length of the string and not the length of the bytes.\n\nIt's not a leaky abstraction. It's a perfectly fine abstraction. You're just too ignorant to recognize it.\n\nIt's a perfectly fine abstraction, but it's a leaky one.\n\nIt's not a leaky abstraction. It's a perfectly fine abstraction.\n\nIt's not a leaky abstraction. It's a perfectly fine abstraction.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string[substring] in string:\n       return len(string) - len(substring)\n    else:\n       return 0\n\nThis looks like it would work, but it doesn't.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if len(string)!= len(substring):\n        raise ValueError('substring must be a substring of string')\n    count = 0\n    for char in string:\n        if char in substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if not string.endswith(substring):\n       return 0\n    return len(string) - len(substring)\n\nI don't think this is the best way to solve this problem, but I'm curious about what the \"best\" solution would be.\n\nIt's not the best way, but it's the most obvious. I'd probably do it like this:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for char in string:\n       if char in substring:\n          count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\n\nIf you're using python 3, you can use the built-in string.findall() function, which returns the count of how many times a substring was found in a string.\n\nI was wondering why this wasn't the case, and I see the answer in the code:\n>>> how_many_times('', 'a')\nTraceback (most recent call last):\nFile \"\", line 1, in <module>\nFile \"\", line 1, in how_many_times\nreturn len(string) - len(substring)\nFile \"/Users/daniel/Desktop/python-2.7.2/Lib/python2.7/site-packages/string/__init__.py\", line 830, in __len__\nreturn len(substring)\nFile \"/Users/daniel/Desktop/python-2.7.2/Lib/python2.7/site-packages/string/__init__.py\", line 828, in __len__\nreturn len(substring)\nFile \"/Users/daniel/Desktop/python-2.7.2/", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string, substring):\n    \"\"\" Initialize a new instance of the how_many_times function.\n    >>> how_many_times = lambda s: how_many_times(s, 'a')\n    >>> how_many_times('aaa')\n    3\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa')\n    3\n    \"\"\"\n    self.string = string\n    self.substring = substring\n    self.count = 0\n    return self.count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    from collections import Counter\n    def find_overlapping_cases(string: str, substring: str) -> Counter:\n    \"\"\" Find all the occurrences of substring in string.\n    >>> find_overlapping_cases('a', 'aa')\n    Counter({'a': 1, 'aa': 1})\n    >>> find_overlapping_cases('aaa', 'a')\n    Counter({'a': 1, 'aaa': 1})\n    \"\"\"\n    return Counter(string.find(substring, start=0), end=string.len)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str, substring: str) -> None:\n    \"\"\" Initialize the function.\n    \"\"\"\n    self.string = string\n    self.substring = substring\n    return None", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def count_overlaps(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> count_overlaps('aaa', 'a')\n    3\n    >>> count_overlaps('aaaa', 'aa')\n    1\n    >>> count_overlaps('aaa', 'aaa')\n    1\n    \"\"\"\n    def count_overlaps_with_replacement(string: str, substring: str, replacement: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> count_overlaps_with_replacement('aaa', 'a', 'aa')\n    3\n    >>> count_overlaps_with_replacement('aaa', 'aaa', 'aa')\n    1\n    \"\"\"\n    def count_overlaps_with_replacement_no_", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    n = len(string)\n    for i in range(0, n):\n        if string[i] == substring:\n           return i\n    return 0\n\nThis is a really nice, simple, clean solution.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI'm not sure how this is different from:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI think the use of len(string) - len(substring) is unnecessary.\n\nIt's not unnecessary, it's necessary to avoid an infinite recursion.\n\nI thought the parent was suggesting that the length of the substring was the length of the original string.\n\nAh, I see. I missed that.\n\nHow is this better than the built-in itertools.count() function?\n\nIt's not. It's just a shorter version.\n\nI think the use of len(string) - len(substring) is unnecessary.\n\nIt's not unnecessary, it's necessary to avoid an infinite recursion.\n\nI thought the parent was suggesting that the length of the substring was the length of the original string.\n\nAh, I see. I missed that.\n\nI think the use of len(string) - len(substring) is unnecessary.\n\nIt's not unnecessary, it's necessary to avoid an infinite recursion.\n\nI thought the parent was suggesting that the length of the substring was the length of the original string.\n\nAh, I see. I", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def count_overlapping_cases(string: str, substring: str, pos: int):\n    \"\"\" Count the number of overlaping substring cases.\n    >>> count_overlapping_cases('aaa', 'a')\n    2\n    >>> count_overlapping_cases('aaa', 'aa')\n    2\n    \"\"\"\n    def count_overlapping_cases_non_empty(string: str, substring: str, pos: int):\n    \"\"\" Count the number of overlaping substring cases.\n    >>> count_overlapping_cases_non_empty('aaa', 'a')\n    2\n    >>> count_overlapping_cases_non_empty('aaa', 'aa')\n    2\n    \"\"\"\n    def count_overlapping_cases_non_empty(string: str, substring: str, pos: int, empty: bool):\n    \"\"\" Count the number of overlaping substring cases.\n    >>> count_overlapping_", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str, substring: str):\n        self.string = string\n        self.substring = substring\n        self.count = 0\n        self.found = False\n        self.found_count = 0\n        self.found_count_if_found = 0\n        self.found_count_if_not_found = 0\n        self.found_count_if_not_found_if_not_found = 0\n        self.found_count_if_not_found_if_found = 0\n        self.found_count_if_found_if_not_found_if_found = 0\n        self.found_count_if_not_found_if_found_if_found = 0\n        self.found_count_if_found", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI think this is the best answer.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\n    if string in substring:\n        return len(string) - len(substring)\n    else:\n        return len(string) - len(substring)\n\nWhat's the point of the if?\n\nI'm not sure, but I think it's a valid idiom to write a function that returns a value and then use the value in the condition.\n\nI think that's a valid idiom for a function that returns a boolean value.\n\nI think it's a valid idiom for a function that returns a value.\n\nI think it's a valid idiom for a function that returns a value that is boolean.\n\nI think it's a valid idiom for a function that returns a value that is boolean and is a string.\n\nI think it's a valid idiom for a function that returns a value that is boolean and is a string and is a number.\n\nI think it's a valid idiom for a function that returns a value that is boolean and is a string and is a number and is a list", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nThis is a simple implementation. The real version would probably use a dictionary with the string as the key and the substring as the value. That way you could do things like:      >>> how_many_times('aaaa', 'aa')      3\nThe question is, what do you do when the substring is not in the string?\nYou could use a list of all the possible characters and then check if the substring is in the list, if it is then you count it, if it isn't then you don't.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI like it! I'll have to remember that one.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str, substring: str) -> None:\n        self.string = string\n        self.substring = substring\n        self.count = 0\n    def __call__(self, string: str, substring: str):\n        if self.string == string:\n           return self.count\n        if self.substring == substring:\n            return self.count\n        if self.string!= string:\n            return self.count\n        return self.count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    count = 0\n    for i in range(len(string)):\n        if string[i] == substring:\n           count += 1\n    return count\nThis is pretty neat, but there is a problem:\n>>> how_many_times('aaa', 'a')\n3\n>>> how_many_times('aaaa', 'aa')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nhow_many_times(None, 'aaa', 'aa')\nFile \"/usr/lib/python2.7/site-packages/functools/__main__.py\", line 62, in how_many_times\nreturn count\nValueError: maximum recursion depth exceeded\nThis is a result of Python's \"generator\" feature. If you want to avoid this, you can simply replace \"how_many_times\" with \"how_many_times_iterable\", where \"iterable\" is a list.\n\nI think it's more of a problem of Python's \"list", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str, substring: str):\n       self.string = string\n       self.substring = substring\n       self.count = 0\n       self.overlaps = []\n\n    def __iter__(self):\n       for char in self.string:\n          if self.substring[char] == self.string[char]:\n              self.count += 1\n           if self.substring[char]!= self.string[char]:\n              self.overlaps.append((char, self.string[char], self.substring[char]))\n\n       return self.count\n\nI'd have to say that the iterative version is more readable.\n\nThe iterative version is more readable because it's easier to read code that you wrote.\n\nI've", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def __len__(self):\n    \"\"\" Return the length of the string.\n    >>> how_many_times('aaaaaaaaa', 'a')\n    5\n    \"\"\"\n    return len(self.text)\nI'm not sure I understand the purpose of this.\n\nIt's a slightly more efficient way to do substring matching. If you have a string like \"foo bar bar\", and you want to get all the \"bar\"s, you could do it like this:\nhow_many_times('foo', 'bar')\nwhich would return 3.\nThe same can be done with a regular expression, of course, but the regular expression would be a little more complicated, and would have to be evaluated more than once.\n\nI think I get it, thanks.\nI was under the impression that it was a way of doing substring matching, but I see now that it's not.\n\nThe article is a bit confusing, but the code is very clear.\n\nI'm not sure I understand the purpose of this.\n\nIt's a slightly more efficient way to do substring matching", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return string.count(substring)\nI'm not sure if that's the most efficient solution, but it should be faster than the others.\n\nI think the most efficient solution would be to use the built-in string.find method, which would be O(n).\n\nYou're right, I didn't think of that. Thanks.\n\nI would have thought that substring.count() would be the fastest, since it's O(1)\n\nI would have thought that it would be 0, since it doesn't do anything.\n\nIn python 2.5 it returns 1, but I'm sure that's changed by now.\n\nIt's a common problem in Python. When you have a variable that is a function, you have to be careful how you use it. If you just write \"how_many_times(a)\", you will get a call to the function \"how_many_times\". This will return the result of the function. If you write \"how_many_times(a)\", then you will get an assignment to the variable \"how_many_times\". Then the function will be called with the argument \"a\" and the return value will be assigned to", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def find_overlapping_substrings(string: str, substring: str):\n    \"\"\"\n    Return a list of overlapping substring in the original string.\n    >>> find_overlapping_substrings('aaaaaaaaaa', 'aaa')\n    ['aaa']\n    >>> find_overlapping_substrings('aaaaaaaaaa', 'aaaa')\n    ['aaaa']\n    >>> find_overlapping_substrings('aaaaaaaaaa', 'aaaaaaa')\n    ['aaaaaaa']\n    \"\"\"\n    def count_overlapping_substrings(string: str, substring: str):\n    \"\"\"\n    Return the number of overlapping substring in the original string.\n    >>> count_overlapping_substrings('aaaaaaaaaa', 'aaa')\n    3\n    \"\"\"\n    return len(find_overlapping_substrings(string, substring))", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def __init__(self, string: str, substring: str) -> None:\n    \"\"\" Initialize the how_many_times function.\n    >>> how_many_times = lambda: lambda s: int(s.find('a'))\n    >>> how_many_times('a')\n    0\n    >>> how_many_times('aaa')\n    3\n    \"\"\"\n    self.string = string\n    self.substring = substring\n    def _count(self, position: int) -> None:\n    \"\"\" Return the number of times the substring has been found at the given position.\n    >>> how_many_times('aaaaaa', 'aa')\n    3\n    >>> how_many_times('aaaaaa', 'aa')\n    3\n    \"\"\"\n    return self.string.find('a').count(position)\n\n>>> how_many_times('a', 'aaa')\n3\n>>> how_many_times", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI'm not sure if I'm missing something but this doesn't count overlaps at all.\n\nI don't think it's meant to. It's just a quick and dirty solution.\n\nThat's what I thought. It's a nice solution for a specific problem but not for counting overlaps.\n\nI'm really not sure why the title was changed.\nThe original title is much more descriptive.\n\nI changed the title because it was a bit of a clickbait and the original title didn't really convey the intent of the post.\n\nYou can't change titles on HN.\n\nI was just about to point this out. I thought it was a rule, but I guess not.\n\nThis is a great post. I didn't know about this feature.\n\nI'm surprised to see that this wasn't mentioned in the original post.\n\nYeah, I was surprised it wasn't mentioned in the original post as well.\n\nThis is really cool.\n\nI really like this.\n\nI am surprised to see this here on HN.\n\nI'm surprised to see this comment here on HN", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str, substring: str) -> None:\n    \"\"\" Initialize the counting function.\n    >>> how_many_times = lambda s: s.count('aaaa')\n    >>> how_many_times('a', 'a')\n    3\n    >>> how_many_times('aa', 'a')\n    3\n    \"\"\"\n    def __call__(self, string: str, substring: str):\n    \"\"\" Return the number of times the given substring can be found in the original string.\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    for i in range(len(string) - 1):\n        if string[i] == substring[i]:\n           return i\n    return 0", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI'm not sure if this is a \"best\" solution, but it's the one I use.\n\nI like this one, thanks.\n\nYou're welcome. I like it because it's simple and fast.\n\nI like this one too. It's simple and fast, and I think it's more accurate than the other one.\n\nI was going to say the same thing.\n\nI use this:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    n = len(string)\n    return len(string) + n\n\nThis is a very bad function. It's not tail-recursive.\n\nIt's also not a one-liner.\n\nYou're right, it's not a one-liner, but I think the author is trying to show how to use Python's built-in functions to do useful things.\n\nThe author is trying to show how to use a subset of Python's built-in functions to do useful things.\n\nI'm not sure what you mean. What built-in functions are missing?\n\nWell, for one, he's using the built-in function _len_, which is not in the standard library.\n\nI was under the impression that was in the standard library. I was looking at the documentation for the string module, and it was there.\n\nIt's in the standard library, but it's not a built-in function.\n\nI think the author should have mentioned the use of the string.join() function in the one liner.\n\nI think the author should have mentioned the use of the string.join() function in the one liner.\n\nA one-", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI don't think you can count the overlapping cases. It's not a valid substring if the same substring is present more than once.\nI think it should be:\nreturn len(string) - len(substring) - len(string[substring])\nI think that's what you meant to write in the first place.\n\nYou're right. I'll fix it.\n\nI think you meant \"return len(string) - len(substring) - len(string[substring]):\"\n\nI'm not sure I understand the use case.\nI'd have to check my code, but I think I have something like this:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    while len(string) > 0:\n        count += 1\n        if string[count] == substring:\n           count += 1\n    return count\n\nThis is a great example of a code that is both concise and readable.\nI'd like to see it compared to a more idiomatic version. I'm sure it's possible to do this in a shorter amount of code.\n\nI'm not sure why you're being downvoted, it's a valid point.\n\nThat's a good point.\n\nThis is a common problem in the Python community. People use the phrase \"idiomatic\" to mean \"minimal\", \"minimal\" to mean \"inelegant\", and \"inelegant\" to mean \"bad\".\nThe actual meaning of \"idiomatic\" is \"of the style of the language\".\n\nI think that's a bit of a stretch.\nTo me, the word \"idiomatic\" is used to describe a style of code that is considered to be \"the way to do it\" in a particular language.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nYou're looking for the length of the substring, not the length of the string.\nThe first substring is 'a', so the length of the substring is 1. The second substring is 'aaa', so the length of the substring is 3. The third substring is 'aaaa', so the length of the substring is 3.\n\nI was under the impression that the length of a substring was the length of the substring. I'm not a python expert, though.\n\nThe length of a substring is the length of the substring.\n\nThe length of a substring is the length of the substring.\n\nThe length of a substring is the length of the substring.\n\nThe length of a substring is the length of the substring.\n\nThe length of a substring is the length of the substring.\n\nThe length of a substring is the length of the substring.\n\nThe length of a substring is the length of the substring.\n\nThe length of a substring is the length of the substring.\n\nThe length of a substring", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # Note: the substring must be the first substring, not the first character\n    # or the last.\n    return len(string) - len(substring)\nThe problem with this solution is that it's O(n) where n is the length of the string.\n\nNot true. If you read the code, the substring is the first substring, not the first character or last.\n\nYou're right, I missed that.\n\nWhy would you want to do this?\n\nThis is pretty much the only way to do something like this in Python. There are no string functions that will let you compare a substring to another substring and return the number of times they overlap.\n\nThis is a great example of why you should always read the code before criticizing it.\n\nI'm not criticizing the code. I'm criticizing the question. Why would you want to do this?\n\nI think the question is more \"How can I do this?\" than \"Why would I want to do this?\".\n\nI think it's a fair question. The way I see it, there are two main reasons to want to do this.\n1) To", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    for i in range(0, len(string)):\n        if string[i] == substring:\n            return i\n\nI think you should use a dictionary, and then you can do this:\n>>> how_many_times('a', 'a')\n3\n>>> how_many_times('a', 'aaaaaa')\n3\n>>> how_many_times('a', 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nhow_many_times()\nFile \"/usr/lib/python2.7/site-packages/how_many_times.py\", line 13, in <module>\nreturn i\nAttributeError: 'dict' object has no attribute 'count'\n\nI believe this is the answer to the question:\n\nI believe you are right.\n\nI think this is a good example of why it's a good idea to use a language that makes the distinction between a function and a method explicit.\n\nWhat's the difference between", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string == '':\n       return 1\n    else:\n       return len(string) - len(substring)\n\nThis is a very simple implementation of a greedy algorithm for finding the\nnumber of times a substring occurs in a string. It is a common problem in\nnatural language processing.\n\nThe idea is simple: start from the beginning of the string, and keep\nrepeating the substring until you reach the end of the string. If you\nfind a match, keep going; if not, then you've found the number of times\nthe substring occurs in the string.\n\nThe problem with this implementation is that it is very inefficient, as\nit goes over the entire string every time. If we know the first and last\ncharacter of the substring, we can use binary search to find the\nsubstring in the string.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # The number of characters in the string\n    # The number of times the substring appears in the string\n    n = len(string)\n    n_count = 0\n    while n!= 0:\n       n = n - n_count\n       if string[n] == substring:\n           n_count += 1\n    return n_count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for s in string:\n        if string[s] in substring:\n           count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # Note: this is not an exact match\n    def find(string: str, substring: str) -> int:\n    \"\"\" Find the position of a substring in a given string.\n    >>> find('aaaa', 'aa')\n    0\n    >>> find('aaaaaa', 'aa')\n    1\n    >>> find('aaaaaa', 'aaa')\n    2\n    \"\"\"\n    # Note: this is not an exact match\n    def count(string: str) -> int:\n    \"\"\" Find the number of occurrences of a substring in a given string.\n    >>> count('aaaaaa', 'aa')\n    3\n    >>> count('aaaaaa', 'aaa')\n    4\n    >>> count('aaaaaa', 'aaa', 'aa')\n    7\n    \"\"\"\n    # Note: this is not an exact match\n    def find_overlapping(string: str, substring: str) -> int:\n    \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI think that it should be len(string) - len(substring[0])</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n        def find_count(match, string, start, end):\n          if match[start:end] == string:\n             return match[start:end]\n         else:\n             return 0\n         return find_count(match[start:end], string, start, end - 1)\n        return find_count(match, string, start, end)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def __init__(self, string: str, substring: str):\n    \"\"\" Initialize the function.\n    \"\"\"\n    self.string = string\n    self.substring = substring\n    return 0", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str, substring: str):\n        self.string = string\n        self.substring = substring\n    def __call__(self, string: str, substring: str):\n        if self.string == '':\n           return 0\n           return len(self.substring)\n    return __call__\nI like this one.  It's easy to read, and it's a clear implementation of the idea.  I wonder how it compares to the others.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string in string_to_remove:\n        return 0\n    else:\n        return len(string)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI'm not sure why you're being downvoted. This is a perfectly reasonable solution. It's not the one I would have come up with, but it's perfectly valid.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI like it.  I think I'll steal it.\n\nI think this is a pretty common idiom. Here's a similar version that is a bit more general:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for sub in string:\n        if sub in substring:\n           count += 1\n    return count\n\nI feel like this is the sort of thing that you would have to explain to a hiring manager, and they would just say, \"Well, I don't see why you'd use that. You can just use a loop.\"\n\nI think this is a perfect example of how to use python. You have a simple problem, and you solve it in a very concise and readable way.\n\nI don't think that this is necessarily a good example of how to use Python. I think it's a good example of how to use a certain Python idiom (iterating over a string, using a dictionary to count occurrences of a substring, using a generator to produce a sequence of strings).\n\nI don't think it's an idiom. I think it's a feature of Python's string handling.\n\nI think it's a feature of Python's string handling, but it's an idiom to use it in this way.\n\nI think it's a feature of Python's", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string)\n    + len(substring)\n    / len(string)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nThis function is not defined if the string is empty.\n\nThe reason it's not defined is that the last element of a string is the null character, not a space.\n\nI think the point of the article is that the language is ambiguous. It's not clear if the function is returning the number of times the substring occurs or the number of times the substring is different from the empty string.\n\nI would say that it's not ambiguous at all, it's just that people are used to the '=' sign meaning equality, and they are confused by the fact that the sign does not mean that in this context.\n\nI'm not sure I agree. The meaning of '=' depends on the context.\nI think it's a bit like the following sentence:\n\"This is a string with a single occurrence of the substring 'aa'.\"\nYou can read it either as \"This string has one occurrence of the substring 'aa'\" or as \"This string has a single occurrence of the substring 'aa'.\"\n\nI'm not sure I agree with your disagreement. In the example you give, the meaning depends on the context. In", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    # This is a helper function to get the position of a substring.\n    def get_position(string: str):\n    \"\"\" Returns the position of a substring in a string.\n    >>> 'a' in 'abcd'\n        <pos>1</pos>\n    >>> 'ab' in 'abcd'\n        <pos>2</pos>\n    >>> 'a' in 'abcd'\n        <pos>2</pos>\n    >>> 'b' in 'abcd'\n        <pos>1</pos>\n    \"\"\"\n    return string.find(substring, 0)\n    def find_overlaps(string: str, substring: str, start: int, end: int):\n    \"\"\" Finds all the overlaping substring in the given string.\n    >>> find_overlaps('a', 'b', 0, 5)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nIn case anyone is wondering why this is downvoted, it's because this is an antipattern.  It's better to use a list comprehension like so:       how_many_times('', 'a')", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for i in range(len(string) - 1):\n        if string[i] == substring:\n           count += 1\n    return count\n\nHow does this work? I don't see how it could do anything other than return 1 every time it hits the end of the string.\n\nI'm guessing it uses a heuristic to determine if the substring is in the original string.\n\nThat's what I thought too, but the heuristic would have to be pretty lenient to get it to return 3 for aaaaaaa.\n\nI'm curious about how it would be possible to use this to generate a string of length N, where the string contains only aaa and no other characters.\n\nYou could probably do it by going over the string backwards.\n\nThat's a good idea!\n\nWhy is this in python?\n\nBecause Python is fun.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    for c in string.split(substring,''):\n        if c == string.endswith(substring):\n           return c\n    return 0\n\nI'd rather see the algorithm be called \"count_overlapping_substrings\".\n\nThere's a lot of good stuff in here. The only thing I don't like is the name. \"HowManyTimes\" is too generic.\n\nI like the name. It's not generic. It's exactly what it does.\n\nI think it's generic because \"HowManyTimes\" can be used to describe anything that does a count of something.\n\nI think that's the point, it's a great name because it's so generic.\n\nI think the point is to make it more descriptive. The name is fine, but it's not a good name.\n\nI think it's a perfectly good name. It's the name of the function. It's not a name for a library.\n\nYou're right, it is a perfectly good name for the function. But it's a bad name for the", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string.startswith(substring):\n        return 1\n    return len(string) - len(substring)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nThat's not a very good implementation. It doesn't account for the fact that the substring may occur in the middle of the string.\nThe correct implementation is:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\nThis is really useful! But I have a question: how do you get the length of a substring?\n\nIt's not possible, really. I would have to create a string of length 1 and then split it and count the number of characters.\n\nOr you could just use the length of the original string.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def __init__(self, string: str, substring: str):\n    \"\"\" Initialize the counter.\n    >>> how_many_times = Counter(string='')\n    >>> how_many_times('a')\n    0\n    \"\"\"\n    def __getitem__(self, index: int):\n    \"\"\" Get the index of the first occurrence of the substring.\n    >>> how_many_times.__getitem__(0)\n    0\n    >>> how_many_times.__getitem__(1)\n    1\n    \"\"\"\n    return string[index:], 0\n\nThis is a very bad idea. This is the kind of thing you should _never_ do.\n\nThis is a very bad idea. This is the kind of thing you should _never_ do.\n\nThis is a very bad idea. This is the kind of thing you should never do.\n\nThis is a very bad idea. This is the kind of thing you should never do.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI think this is the best answer so far.  But the original question was asking for the number of times a substring is repeated in the original string, not the number of times that substring is found in the original string.  The answer given by how_many_times is correct for the latter, but not the former.\nhow_many_times(string, substring) -> int", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str, substring: str) -> None:\n    \"\"\" Create a new HowManyTimes object.\n    >>> how_many_times = HowManyTimes(string='', substring='a')\n    >>> how_many_times.__dict__\n    {'string': string,'substring': substring}\n    \"\"\"\n    self.string = string\n    self.substring = substring\n    if not self.substring:\n        self.__str__ = string\n    return None\n    def __str__(self):\n    \"\"\" Return a string representation of this HowManyTimes object.\n    >>> how_many_times.__str__\n    HowManyTimes(string='', substring='a')\n    \"\"\"\n    return self.string\n    def count(self, substring: str) -> int:\n    \"\"\" Return the number of times the given substring can be found in the original string.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string[substring] == None:\n       return 0\n    return len(string) + len(substring)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string.find(substring, 0))\nI'm not sure how this is supposed to be better than", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'aaa')\n    3\n    \"\"\"\n    def how_many_times_with_overlaps(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times_with_overlaps('', 'aaa')\n    3\n    \"\"\"\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times_with_overlaps('aa', 'aaa')\n    3\n    \"\"\"\n    def how_many_times_with_in_overlaps(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\n\nThis is not correct. It will return 0 for 'aaaa' because 'a' is a substring of 'aaaa'.\n\nIt is correct, if you think of the function as \"How many times can a substring occur in the original string.\"\n\nI think the point is that you'd want to find the number of times a substring occurs in the original string, without considering how many times the original substring occurs in the original string.\n\nThis is a very useful function, but I found it difficult to read and understand the code. I found the following much easier to read:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str, substring: str) -> None:\n    \"\"\" Initialize the count to zero.\n    >>> how_many_times('a', 'a')\n    0\n    >>> how_many_times('a', 'aaa')\n    0\n    >>> how_many_times('a', 'aaaa')\n    0\n    >>> how_many_times('a', 'aaa', 'aa')\n    3\n    >>> how_many_times('a', 'aaa', 'aaa', 'aa')\n    7\n    \"\"\"\n    self._count = 0\n    self._substring = substring\n    def __str__(self):\n    \"\"\" Return the string representation of the count.\n    >>> how_many_times('a', 'aaa')\n    'a'\n    \"\"\"\n    return self._substring.rstrip('\\n')\n    def __add__(self, substring:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI think you want to use `count`.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    for i in range(len(string)):\n       if string[i] == substring:\n          return i\n    return 0", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nThis is not O(n) for strings of length n.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string, substring):\n        self.string = string\n        self.substring = substring\n        self.count = 0\n        self.str = string\n    def count(self, substring):\n        if self.substring in self.str:\n            self.count += 1\n        return self.count\n    def __len__(self):\n        return len(self.str)\n    def __eq__(self, other):\n        return self.string == other.string\n    def __ne__(self, other):\n        return self.string!= other.string\n    def __lt__(self, other):\n        return self.string < other.string\n    def __gt__(self, other):", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # As a first step, find all the positions of the substring.\n    for i in range(0, len(string)):\n        if string[i] == substring[0]:\n             return i\n    return 0\n\nI'm not sure what this is supposed to do. It seems like it's checking to see if the substring is in the original string at every index?\n\nYes, it's a simple substring search.\n\nI think it's a fun exercise to write a few of these. It's a good way to learn about Python.\n\nI'm not sure what the purpose of this is.\n\nI think it's a fun exercise to write a few of these. It's a good way to learn about Python.\n\nThis is a fun exercise, but I think it's a bit of a stretch to call it \"a good way to learn about Python\". I've been using Python for over ten years and I'd never have written this without seeing it here.\n\nI've been using Python for over 10 years and I've never seen this before.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string, substring):\n        self.string = string\n        self.substring = substring\n        self.count = 0\n        self.substring_count = 0\n        self.count_str = 0\n        self.substring_count_str = 0\n        self.overlapping = False\n        self.is_overlapping = False\n        self.overlapping_count = 0\n        self.overlapping_str = 0\n        self.is_overlapping_str = 0\n        self.overlapping_count_str = 0\n        self.overlapping_substring_count = 0\n        self.overlapping_substring_count_str = 0", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for char in string:\n       if char not in substring:\n          count += 1\n    return count\nThis is actually pretty neat. I've been looking for a clean way to do this, and I'm going to use this.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string.startswith(substring):\n       return string.count(substring)\n    return 0", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __str__(self):\n    \"\"\" Return the original string.\n    >>> how_many_times('a', 'aaa')\n    'aaaaaaa'\n    \"\"\"\n    return string.rstrip('.')\n\nI'm not sure why this is so much more concise than the other answers, but it is.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def count_overlaps(string: str, substring: str):\n    \"\"\" Find how many overlaping cases are present in the original string.\n    >>> count_overlaps('aaaaaa', 'aaaaaa')\n    3\n    >>> count_overlaps('aaaaaa', 'aa')\n    3\n    \"\"\"\n    return len(string) - len(substring)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\n\nYou can also use the in operator for this:\n>>> how_many_times('a', 'a')\n3\n>>> how_many_times('aaa', 'a')\n3\n>>> how_many_times('aaaa', 'aa')\n3\n\nThis is the better solution, but the above solution is a bit simpler, and can be more readable if you want to use it for something like a loop.\n\nIt's also a bit faster.\n\nI have a feeling that this is a premature optimization.\n\nI have a feeling that you're right.\n\nIt's not a premature optimization because it's not an optimization at all.\n\nI like the fact that the author of this post chose to use \"how_many_times\" as the name of the function.\n\nIs there a name for this?\n\nYes, it's called \"templating\".\n\nI don't know why, but I just read that as \"templeating\".\n\nI would have read it as \"templating\" if it weren't for your comment. Thanks!\n\nI'm a fan of the", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def __len__(self):\n    \"\"\" Returns the number of characters in the string.\n    >>> len('a')\n    6\n    >>> len('a', how_many_times('a', 'a'))\n    12\n    \"\"\"\n    return len(self)\n    def __str__(self):\n    \"\"\" Returns a string representation of this object.\n    >>> \"a\" + how_many_times('a', 'a')\n    'aaaaaa'\n    >>> how_many_times('a', 'a')\n    'aaaaaa'\n    \"\"\"\n    return self.__class__.__name__ +'' + self.__class__.__doc__.__doc__\n\nThe above implementation uses a naive substring search to find the overlaps.  If you want to do a more efficient search, you can use the Levenshtein distance:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    n = len(string)\n    for i in range(n):\n        if string[i] == substring:\n           return i\n    return 0\n\nHow is this different from the Python standard library?\n\nI don't think it is. I think this is the standard library.\n\nYep, it's standard library.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def __init__(self, string, substring):\n    \"\"\" Initialize the dictionary of how_many_times.\n    >>> how_many_times = {}\n    >>> how_many_times['a'] = 0\n    >>> how_many_times['aa'] = 1\n    >>> how_many_times['aaa'] = 2\n    >>> how_many_times['aaaa'] = 3\n    >>> how_many_times['aaaaa'] = 4\n    >>> how_many_times.keys()\n    ['a', 'aa', 'aaa', 'aaaa', 'aaaaa']\n    \"\"\"\n    self.string = string\n    self.substring = substring\n    self.count = 0\n    return self", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, substring: str, count: int) -> None:\n    \"\"\" Initialize the count.\n    >>> how_many_times('aa', count=3)\n    3\n    >>> how_many_times('aaaa', count=2)\n    2\n    \"\"\"\n    def __iter__(self):\n    \"\"\" Iterate over the substring.\n    >>> how_many_times('aaa')\n    3\n    >>> how_many_times('aaa', count=1)\n    1\n    \"\"\"\n    return iter(self)\n\nAnd the example that the article uses:\n>>> how_many_times('aaaaaaa')\n3\n>>> how_many_times('aaaaaaa', 2)\n2\n\nThe difference is that in Python, how_many_times() doesn't modify the original string, it returns a new one.\n\nThe article is not about how to count the number of occurrences of a substring. It's about counting the number of times a substring is", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI'm not sure if I'm missing something but this function is not correct.  I get 0 for all three tests.  Am I doing something wrong?\nIt should be len(string) - len(substring) - len(substring)\nThanks!  I was missing the third subtraction.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def find_overlaps(string: str, substring: str) -> list:\n    \"\"\" Find all overlaping substrings in the original string.\n    >>> find_overlaps('', 'aaa')\n    ['aaa', 'aa']\n    >>> find_overlaps('', 'aaa', 'aaa')\n    ['aaa', 'aaa', 'aaa']\n    >>> find_overlaps('', 'aaa', 'aaaa')\n    ['aaa', 'aaa', 'aaaa']\n    >>> find_overlaps('', 'aaa', 'aaaaaa')\n    ['aaa', 'aaa', 'aaaaaa']\n    \"\"\"\n    def count_overlaps(string: str, substring: str) -> int:\n    \"\"\" Count how many times a given substring can be found in the original string.\n    >>> count_overlaps('', 'aaa')\n    3\n    >>> count_overlaps('aaa', 'aaa')\n    3\n    \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    if string[substring]!= '':\n       return len(string) - len(substring)\n    return len(string)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI like this better, because it's clear what it's doing.  Thanks.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str, substring: str) -> None:\n    \"\"\" Initialize the class.\n    >>> how_many_times = HowManyTimes(''', 'a')\n    >>> how_many_times.__init__('', 'a')\n    >>> how_many_times.__init__('aaa', 'a')\n    >>> how_many_times.__init__('aaaa', 'aa')\n    \"\"\"\n    if not string is None:\n       return self._string = string\n    else:\n       return self._string = ''\n    def __len__(self):\n    \"\"\" Return the length of the string.\n    >>> how_many_times.__len__\n    0\n    >>> how_many_times.__len__\n    1\n    >>> how_many_times.__len__\n    2\n    \"\"\"\n    return len(self._string)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string.startswith(substring):\n       return len(string) - 1\n    else:\n       return len(string) - string.count('a')\n    # It's not perfect, but it's pretty good.\n\nAs a general rule, if you want to count the number of times a substring appears, just subtract the length of the string from the length of the substring.\n\nThis is true, but it doesn't catch cases where you have multiple occurrences of the substring within a single character. For example, in 'aa', 'a' occurs 3 times, but in 'aaa', 'a' occurs only once.\n\nIt's not perfect, but it's pretty good.\n\nNo, it's not. It's pretty terrible.\n\nHow so?\n\nI'm not going to go into a long explanation, but I'll point out a few obvious flaws:\n1\\. It doesn't handle cases where the substring is itself a substring of the string. For example, it counts 'aaaaa' as 3, but it should count 'aa' twice.\n2\\.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nThis is pretty neat. Thanks!</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    n = len(string)\n    return int(n / string.count(' '))\n\nThis is not a general solution.\n\nYeah, but it's a fun little hack.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string[substring]!= None:\n       return len(string) - len(substring)\n    return 0\nHow would you improve this?\n\nI'm not sure if I would use this, but I can see some uses for it.\nI would probably make it more explicit that it's a substring of the string, and that it's a regular expression.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    from collections import Counter\n    from string import count\n    from itertools import cycle\n    def get_overlaps(string_to_search, substring_to_search):\n    \"\"\" Returns the number of overlapping substrings in the original string.\n    >>> get_overlaps('a', 'aaa')\n    2\n    >>> get_overlaps('aaa', 'a')\n    3\n    \"\"\"\n    for sub in string_to_search:\n        for s in substring_to_search:\n           if s.startswith(sub):\n               cycle(s)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # the list of all possible substrings\n    # The substrings can be of any length.\n    # The substrings are all in the same order as the original string\n    # If a substring can not be found in the original string, return 0\n    # If the original string is empty, return 0\n    substrings = [s.split(' ') for s in string.split()]\n    # Loop through each substring\n    for s in substrings:\n        # Loop through each character\n        for c in s:\n           if c == 'a':\n              return len(substrings[c])\n           else:\n              return 0\n    return len(substrings)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string.startswith(substring):\n       return 1\n    else:\n       return len(string) - len(substring)\n   \nYou should probably change the name to how_many_occurrences or something.\n\nI really like this. The idea is simple and it is implemented well.\n\nIt is a very nice idea, but I think it would be more useful if it were possible to specify a \"start\" position.\n\nI like it. I was going to write something similar for a project, but I think I will use this instead.\n\nI think it's a good idea, but the implementation is a bit awkward.\n\nI like it.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    n = len(string)\n    for i in range(1, n+1):\n       if string[i] == substring:\n          return i\n    return 0\n\nI've always wondered why it's not a builtin...</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string.find(substring) is not None:\n       return len(string.find(substring))\n    else:\n       return 0\n\nThis is the only Python example in the article. The rest is Haskell.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) + len(substring)\n>    def how_many_times(string: str, substring: str) -> int:\n>    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n>    >>> how_many_times('', 'a')\n>    0\n>    >>> how_many_times('aaa', 'a')\n>    3\n>    >>> how_many_times('aaaa', 'aa')\n>    3\n>    \"\"\"\n>    return len(string) + len(substring)\n>>> def how_many_times(string: str, substring: str) -> int:\n>>>    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n>>>    >>> how_many_times('', 'a')\n>>>    0\n>>>    >>> how_many_times('aaa', 'a')\n>>>    3\n>>>    >>> how", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def _find_overlaps(string, substring):\n    \"\"\" Find the number of overlaping occurrences of the given substring in the original string.\n    >>> _find_overlaps('a', 'aaa')\n    3\n    >>> _find_overlaps('aaa', 'a')\n    1\n    >>> _find_overlaps('aaa', 'aa')\n    1\n    \"\"\"\n    def _find_overlapping_substrings(string, substring):\n    \"\"\" Find the number of overlaping occurrences of the given substring in the original string.\n    >>> _find_overlapping_substrings('a', 'aaa')\n    3\n    >>> _find_overlapping_substrings('aaa', 'a')\n    1\n    >>> _find_overlapping_substrings('aaa', 'aa')\n    1\n    \"\"\"\n    return _find_overlapping_substrings(string, substring)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if not string.startswith(substring) or string.endswith(substring):\n        return 0\n    for i in range(len(string) - 1, -1, -1):\n        if string[i] == substring:\n           return i\n    return len(string) - 1", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) + len(string[substring: substring])\n    if string == string[substring: substring] else len(string)\nYou can also use list comprehension to write it more easily:      how_many_times = [len(string) + len(string[substring: substring]): len(string)]\nI was going to say that, but I wasn't sure if he'd be able to understand it.  I was also trying to show him that it's a lot easier to use a list comprehension than it is to write a loop.</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def __init__(self, string: str, substring: str) -> None:\n    \"\"\" Initialize the how_many_times function.\n    >>> how_many_times = how_many_times('', 'a')\n    >>> how_many_times()\n    <function how_many_times at 0x1068ecec0>\n    \"\"\"\n    def __call__(self, string: str, substring: str):\n    \"\"\" Return the number of overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    \"\"\"\n    return self.count(string, substring)\n\nI'm confused, what is the purpose of this function?\n\nI'm guessing it's for counting the number of times a substring occurs in a string.\n\nAha!\n\nI don't see the point of this. You can use str.find() and substring.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    return len(string) - len(substring)\n    >>> how_many_times('aaaa', 'aa')\n    3\n    >>> how_many_times('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string.startswith(substring):\n       return len(string)\n    else:\n       return len(string).find(substring)\n    # This is an important optimization\n\nThis is the shortest, correct answer.\n\nI'm not sure this is the shortest, but it is the correct answer.\n\nIt's a bit too terse for my taste. I'd prefer something like:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    for i in range(0, len(string)):\n        if string[i] == substring:\n           return i\n    return 0", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    while count < len(string):\n        if string[count] == substring:\n            count += 1\n    return count\n        return 0", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    from collections import Counter\n    from itertools import count\n    def find_count(a, b):\n    \"\"\" Find the count of the number of times a and b occur in the same string.\n    >>> find_count('aa', 'aaa')\n    2\n    >>> find_count('aaa', 'aaa')\n    3\n    \"\"\"\n    return Counter(a, b)\n    def count(a, b):\n    \"\"\" Return the count of the number of times a and b occur in the same string.\n    >>> count('aa', 'aaa')\n    3\n    >>> count('aaa', 'aaa')\n    3\n    \"\"\"\n    return count(a, b)\n    def how_many_times(string: str, substring: str):\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'aaa')\n    3", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\n> How did you find that?</s>", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str, substring: str):\n        self.string = string\n        self.substring = substring\n        self.count = 0\n\n    def __iter__(self):\n        for c in self.string:\n           if c in self.substring:\n                self.count += 1\n\n        return self.count\n\nNote that this implementation is not correct. The correct implementation would be to use the itertools.count function.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    return len(string) - len(substring)\nThis is a pretty bad way to do this. It's O(n^2) for a string of length n.\nYou can do this in O(n) with a binary search.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    # This function will return the number of times a given substring is found in the original string.\n    def how_many_times(string: str, substring: str) -> int:\n    \"\"\" This function will return the number of times a given substring is found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\"\n    # This function will return the number of times a given substring is found in the original string. Count overlaping cases.\n    def how_many_times(string: str, substring: str) -> int:\n    \"\"\" This function will return the number of times a given substring is found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string == '':\n       return 0\n    for s in string.split(substring):\n       if s[-1]!= substring:\n         return s\n    return len(string)\n\nThis is a horrible way to do this.\n\nWhy?\n\nA more idiomatic way to do this is to use a regular expression.\n\nThe goal of this was to find out how many times a substring appears in a string.\nI don't think it's possible to do that with a regular expression.\n\nI can't think of a regular expression that would do it, but if you could, it would be shorter and easier to read.\n\nIt would be shorter and easier to read, but I don't think it would be more idiomatic.\n\nIt would be more idiomatic if you could do it with a regular expression.\n\nI don't think so.\n\nWhy not?\n\nBecause the goal is to find out how many times a substring appears in a string.\nI don't think it's possible to do that with a regular expression", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI'd have gone with the following:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string.startswith(substring) and string.endswith(substring):\n        return 1\n    return 0", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI would have used a dictionary instead.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n        for s in string:\n           if s == substring:\n               return len(s)\n        return 0\n        if __name__ == '__main__':\n             how_many_times('aaaa', 'aa')", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for i in range(0, len(string)):\n        if string[i] == substring[i]:\n           count += 1\n    return count\nI've always hated how_many_times and how_many. I wish they were like the built in ones.\n\nI also don't like how_many_times, but I don't see how it's any worse than the built-in ones.\n\nBecause of the way it handles the \"overlapping\" case. If you have a string with a single \"a\", and another string with a single \"a\", and you call \"how_many_times('a', 'a')\", you'll get back 3. This is clearly wrong, since \"a\" is not found in the second string at all.\n\nThat's exactly the same as the built-in one though.\n\nI don't think that's true. The built-in one seems to work the way I would expect.\n\nThis is a great example of how a simple change can lead to a very clean and readable solution.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    count = 0\n    for i in range(len(string)):\n        if string[i] == substring:\n           count += 1\n    return count\n\nThis is the shortest answer.\n\nFor the more curious:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nThat's the same as a binary search, which is O(log n) and the most common solution to this problem.\n\nI don't think it's the same as a binary search. It seems to me that it's a linear search over the length of the string.\n\nIt's not the same as a binary search, but it's a linear search over the string.\n\nI have to say I'm not sure why this is on the front page.\nIt's a _very_ simple algorithm, and not a particularly efficient one.\n\nAgreed, and the code is pretty bad.\n\nI would love to see a better solution.\n\nBetter solution:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n\n>>> how_many_times('aa', 'a')\n3\n>>> how_many_times('aaaa', 'aa')\n3\n>>> how_many_times('aaaaaaaaaaaaaaaaaaaaaaa', 'a')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"/usr/lib/python2.7/site-packages/numpy/core/numpy.py\", line 713, in how_many_times\nreturn len(string)-1-len(substring)\nFile \"/usr/lib/python2.7/site-packages/numpy/core/numpy.py\", line 634, in how_many_times\nreturn len(string)-1-len(substring)\nFile \"/usr/lib/python2.7/site-packages/numpy/core/numpy.py\", line 563, in __len__\nreturn len(string) - len(substring)\nFile \"/usr/lib/python2.7/site-packages/numpy/core/numpy.py\", line 564, in __len__\nreturn len(string", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string.find('\\w+', substring) == 0:\n        return 1\n    else:\n        return len(string) - len(substring)\nThis is a poor man's version of the algorithm described in the article. It's missing the fact that it's supposed to be case insensitive (i.e. \"aaa\" and \"aaaa\" are the same).\nI'd also point out that the algorithm described in the article is not O(n), but O(n log n).\n\nYou're correct. I've added a note to the post.\n\nI think that your implementation is still incorrect. For example, if you have 'aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nThis is a good start, but it's missing the most important part. It doesn't actually count the number of times the substring is found, it just returns the length of the substring.\n\nI've always been a fan of using recursion to count the number of occurrences of a substring:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    if string == '':\n       return 0\n    return len(string) - len(substring)", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for i in range(len(string)):\n        if string[i] == substring[i]:\n           count += 1\n    return count\n\nI don't think that's a good way of doing it. If you do something like this:\n>>> how_many_times('aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str, substring: str) -> None:\n        self.string = string\n        self.substring = substring\n    def __call__(self, string: str, start: int, end: int, step: int) -> int:\n        return len(self.string)\n    def __len__(self) -> int:\n        return len(self.string)\n    def __eq__(self, other: str) -> bool:\n        if self.string in other:\n           return True\n        return False\n    def __ne__(self, other: str) -> bool:\n        if self.string not in other:\n           return True\n        return False\n    def __lt__(self, other: str) -> bool:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    count = 0\n    for s in string:\n        if s in substring:\n            count += 1\n    return count", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    for i in range(0, len(string)):\n        if string[i] == substring:\n           return i\n    return 0", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return string.find(''.join(substring))\n   .count(''.join(substring))\n\nI wonder if there is a way to do this in a more efficient way.\n\nI think it's quite efficient, since it doesn't need to iterate over the string.\n\nYeah, but it's still O(N) where N is the length of the string.\n\nO(N) is generally considered efficient.\n\nO(N) is generally considered efficient, but this is a very simple algorithm. I think it's a fair question to ask if there's a more efficient way to do it.\n\nI think you are confusing efficiency with simplicity.\n\nI think you're confusing efficiency with how much work you need to do.\n\nYou're right, I was.\n\nIf you're interested in this, you should also look at how to do this in a more general manner. I've written a function that finds the number of occurrences of a substring in a list of strings:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nThis is a pretty naive solution.\nA better solution would be to find the first occurrence of the substring, then count the number of times that substring occurs after that.", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nThis is a really bad implementation. I'm surprised it was the top result.  It doesn't handle the case where the substring is the same length as the string (e.g. 'aaa' in the example).\nThis is a much better implementation:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(substring)\nI like this one, but I'd also like to see the actual code that the author used to write it.\n\nThis is the actual code:", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def __iter__(self):\n       \"\"\" Iterate over the input string.\n       \"\"\"\n       self.__next__(substring)\n       return self\n    \"\"\"\n    def __next__(self, substring):\n       \"\"\" Return the next substring to be counted.\n       \"\"\"\n       return substring\n\nYou should try the \"how many times\" function out on your own string.\n\n>>> how_many_times(\"aaaaaa\", \"a\")\n3\n>>> how_many_times(\"aaaaaa\", \"aa\")\n3\n>>> how_many_times(\"aaaaaa\", \"aaa\")\n3\n>>> how_many_times(\"aaaaaa\", \"aaaaa\")\n3\n>>> how_many_times(\"aaaaaa\", \"aaaaaa\")\n3\n>>> how_many_times(\"aaaaaa\", \"aaaaaaaa\")\n3\n>>> how_many_times(\"aaaaaa\", \"aaaaaaaaaaaaaa\")\n3", "def how_many_times(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times('', 'a')\n    0\n    >>> how_many_times('aaa', 'a')\n    3\n    >>> how_many_times('aaaa', 'aa')\n    3\n    \"\"\" \"\"\"\n    return len(string) - len(substring)\nI'm not sure that's correct. If you have 'aaa' in your string, how_many_times('aaaa', 'a') should return 3, not 0.\n\nThe OP's version is correct. The function is returning the number of times that a substring can be found in the original string. It is not counting the number of times a substring can be found in the original string.\n\nThe OP's version is correct, but it is not a complete function. It doesn't tell you how many times you have to search the string to find the substring.\n\nI don't think it's necessary to include that. If you know the length of the string and the length of the substring, you can trivially calculate the number of times you need to search the string.\n\nHow?\n\nlen(string) - len(substring)\n\nThat only tells you how many times you have to search the substring. You have to search the string at least once to find out the substring is there.\n\nI'm confused. If you know the length of the substring, you know how many times you have"]]