[["def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    for i in range(n+1, m):\n        r, a = round(i, 2)\n        if r == -1:\n            return -1\n        else:\n            r = r.split(0, a)\n            a = a.split(0, b)\n            for b, v in enumerate(r):\n                return (a[i], b[v])\n              return (r[0], r[1])\n\nFor an interesting perspective on this algorithm, read\n\nInteresting, because of the discussions here I've started using the following instead:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    for i in range(n):\n        if i == m:\n           return i\n           if (i % m!= 0):\n              return i // m + 1\n             if (i % m == 0 and i % n == 0):\n                 return i\n    return i\nThis is silly. It does no rounding, and just does integer arithmetic.\n\nIt does rounding.", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    a = n\n    b = m\n    if a > b:\n        return -1\n    else:\n        return a + b + (a * b) - a / b\n\nI think the only way to get the correct answer for the first example is to round to the nearest integer, which would give 0b11 (or 0b1110 depending on how you want to count the bits), then convert to binary, so \"01010101\"\n\nYou're right. The correct way to calculate rounded_avg(1,5) is to round down to 0b11, then convert to binary.\nI'll fix that.\n\nI don't think you can say that's the \"correct way\" since you're changing the problem to fit the solution.\nThe question isn't about the rounding, it's about the conversion to binary. If we do that, then your code is correct, but that's not the answer the question asks for.\n\nHow about this:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return n + m + (n%2) + (m%2) + (n/2) + (m/2) + (n-m) + (n/2) +\n    (m-n) + (m/2)\n\nI'm not sure what is \"the surprising part\".\n\nMy thought was that the return value is something like a half-half sum:\n|n/2+m/2|\n|n%2+m%2|\n|n/2+m/2|\n|n%2+m%2|\n|n/2+m/2|\n|n%2+m%2|\n...\n|n%2+m%2|\n|n/2+m/2|\n|n%2+m%2|\n|n/2+m/2|\n|n%2+m%2|\n|n/2+m/2|\n|n%2+m%2|\n\nThat's what it is.\n\nOK, it's like a half-half sum, but the number of iterations of the loop is not constant.", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    return int(round(m + n, 2))\n\nI don't understand how this works.", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (n**(1+1/n)*m)/m", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return 0 if n < m\n    return -1 if n > m\n    return 0b10000000 if n == m\n    return (n - m) * (m - n)\n    #", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    a=0\n    n=n+1\n    while n!= m:\n        if n % 2 == 0:\n            a=a+1\n            n=n/2\n            n -= 1\n          else:\n             a=a+1\n            n = n/2\n            n += 1\n    return a", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    m = int(n)\n    while m > 0:\n        n = int(n)\n        if n >= m:\n           return -1\n    return int(m - n) + (m * n) / 2\n\nThis is also a good one for a dynamic programming algorithm:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return int(int(n, m)/2) % n", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    result = 0\n    while n!= m:\n        result += n\n        if n > m:\n           result = -1\n    return result\n\nand your task is to compute the average of the integers from n through m (including n and m).\n\nThat's not what it says.\n\n(Also, Python's builtin `round` function is already defined as `0b10000000`.)\n\nI'm surprised nobody has mentioned python - it has a native inbuilt round function.\n\nIn fact I was about to mention that the 'round' function does not need to be defined.\n\nI actually created a module that adds a \"round_float\" and \"round_int\" function. I also added a \"round_float_to_int\" function.\n\nA quick search on PyPI shows several modules that do this:\n\nI would do something like:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    n = n - m\n    a = 0\n    while n > 0:\n        a = a + (n-m) * a\n        n -= m\n    return a\nThat's a fairly popular one. I've seen some variations of it that don't require it to round down.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    def f(x):\n    \"\"\"Convert x to binary.\n    \"\"\"\n    return (x ** 0b1 << 4)\n    # 0b11010", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    n = int(n)\n    m = int(m)\n    n_sum = 0\n    for i in range(n):\n        n_sum += int(m) + int(i)\n    return n_sum\n\nI'm still waiting for someone to come up with a use for this.\n\nThere is a new trend in writing programs where you are expected to write one module for each of your functions, and you import it all into the top level script. You could then import that script into another file and so on, then you could send a script to a friend and they can import just the parts they need. This is a lot more flexible than writing a module which takes a function and calls it, but it's a bit more work.\n\nThis is what \"import scipy\" is for.\n\nimport scipy\n\nimport scipy\n\nimport scipy\n\nfrom scipy import *\n\nfrom scipy import *\n\nfrom scipy import *\n\nfrom scipy import *\n\nfrom scipy import *\n\nfrom scip", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return -((n - m) / m) * (n + m)\nThis is actually a pretty bad implementation of what he's asking for.\nFor example, you get wrong results if you have the same number repeated (like 1,2,1,2...)\n\nI've always liked this implementation (which I learned from a friend):", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if m > n:\n        return -1\n    return int(m) / int(n) + 1\n\nHow is that possible? Shouldn't it be returning -1?\n\nMakes sense in hexadecimal.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    m = min(n, m)\n    for i in range(m):\n        if m > i:\n           return -1\n        else:\n            return i\n    return (n + m * i) * 1.0 / (n + m)\n\nThis algorithm is not very efficient. For large n, the algorithm spends most of the time computing n. For small n, the algorithm spends most of the time computing m, and in the end the results are the same. For medium n, the time to compute m and n is about the same, so the result of the algorithm is also the same.\n\nLet's think about this for a moment. We want to compute the average of the integers from n through m. How does it help to compute the average of the integers from m through n? The only purpose it serves is to calculate m, which is the same thing as calculating n + m * i. The only purpose it serves is to calculate n, which is the same thing as calculating n + m.", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n >= m:\n        return -1\n    return sum(int(n * m, 2) for i in range(n, m))\n\nIt's much faster (as in order of magnitude faster) than the naive approach, but it's still O(n^2) because you're computing the sum of all of the numbers. You can get an O(n) solution, but only if you're willing to sacrifice precision (you'll need to divide by 2^m, and the result is subject to a floor function, which means you can't compute it without a bit of rounding).\n\nI was expecting to see a python version of this in the article...\n\nPython 3.3+ has it in the standard library:\n>>> def round_avg(n, m):\n... return int(sum(n**2 for n in range(n, m)) / 2)\n...\n>>> round_avg(1, 5)\n0b11\n>>> round_avg(7, 5)\n-1\n>>> round_avg(10, 20)\n0b1111\n>>> round_avg(20", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    def find_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to\n    compute the average of the integers from n through m (including\n    n and m).  Round the answer to the nearest integer and convert\n    that to binary.  If n is greater than m, return -1.\n    Example:\n    find_avg(3, 4) => \"0b101\"\n    find_avg(7, 4) => -1\n    find_avg(9, 5) => \"0b11\"\n    find_avg(10, 7) => \"0b11010\"\n    \"\"\"\n    if n > m:\n        return -1\n    if n == m:\n        return n\n    # check if they are equal\n    if n == m:\n        return n\n    if n == m:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return -((int) (n * n + m * m)) & 1", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (-1 + ((int)((int)(n) / (int)(m))) * ((int)m))\n\nThis is very bad code for an interview. The code uses 3 for loops,\nand a lot of fiddly bits. For one thing, the author is assuming that\nthe reader knows that the result is to be a binary number, and this is\nnot always true. It's better to just return a binary number directly.\n\nI disagree. It's a great code example because it demonstrates a particular concept: \"what's the average of a bunch of numbers\". You're also probably not going to get the best answer with the most elegant code for an interview, and even if you do, you'll be judged on how you talk about it.\n\nI would agree with this. The author also stated that the code was a little naive because it didn't account for the possibility of the numbers being different. It's definitely a good exercise in thinking how to deal with a problem that is not explicitly stated.\n\nI like this question, but it is a little too easy to just think up a solution. I'll give you a harder one:\nYou're given an array of numbers. Each", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    round = 1\n    while round > 0:\n        n, m = n + round, m + round\n        if m == n:\n           break\n        else:\n            round -= 1\n            if m == n:\n              break\n         else:\n             return rounded_avg(n - m, m - n)\n\nIt's not a big deal, but the code is much easier to read if the condition is 'if n > m: return -1' rather than 'if n > m: return -1'.\n\nIt is a big deal if you're a Python user who has had to deal with indentation issues and it has been a while since you've written in a language that doesn't", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return -1 if n > m else m / n\n\nI don't know much about Python, but the solution doesn't make much sense to me. How is n an integer if you have to round it to the nearest integer, and how is the result of m/n an integer if you have to convert it to binary? I would expect it to be at most 2^m.\n\n_How is n an integer if you have to round it to the nearest integer, and how is the result of m/n an integer if you have to convert it to binary?_\nPython represents numbers as floating point numbers. If you're used to decimal (or hexadecimal, or octal, or binary), it seems crazy, but the numbers are pretty darn good.\n\nIn case you aren't familiar with Python, here's a Python dictionary example (from the Python docs):\n>>> x = {1: 1, 2: 2, 3: 3, 4: 4, 5: 5} >>> print(x[3]) 1 >>> print(x[1]) 1 >>> print(x[-1]) -1 >>> print(x[0]) 1 >>> print(x[-0]) -", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    else:\n        return m\n\nNeat. What's the point?\n\nIt's just an exercise to practice python.\n\nAh.\n\nAn exercise to demonstrate the use of modules and function decorators (used to prevent name collisions with native Python functions).\n\nHey, thanks, I was trying to remember what the point of the exercise was.\n\nTook me a few seconds to notice the return 0 statement!</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    n = n ** 2\n    while n > m:\n        n, m = n - m\n        return round(n / m, 2)\n\nThere is a bug in the last line of the code.\n\nWhat is the bug?\n\nFor example, if n=10 and m=20, the last line will return 1, which is not the average.\n\nIt returns an answer between -1 and +1, which is the correct answer for 10 / 20.\n\nOh, I see. I thought the \"return\" statement will always return the same value, regardless of whether the number is positive or negative.\n\nThis is a common confusion. It is a bad idea to wrap your head around it because it is rarely the case that you will be dealing with negative numbers and the correct behavior of \"return\" on negative numbers is undefined in C anyway.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return -n/2", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    m = m / 2\n    return ((int)(m + (n >> m) & 0x1f) >> 1) & 0xffffffff\n\nn is the number of elements (positive integers) in the list.\nm is the number of elements to be excluded from the list (e.g., the last m elements of the list).\n\nExample:\n\n>>> rounded_avg(1, 5)", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    m = n\n    for i in range(m, m+1):\n        if i % 2 == 0:\n             return i\n        else:\n             return i + m\n    return -1\nThis function is a good candidate for memoization, too.\n\nA solution to problem 1 is this:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return int(int(n ** 2) + int(m ** 2))\n\nI'm curious, what is this for?\n\nYou have a series of numbers, and you need to pick the \"average\" value.\nIn a non-computer science setting, you might say \"half way between\" the numbers.\nIn a computer science setting, you say \"pick the number that is most likely to have resulted if you took the average of the numbers.\"\nThat number is rounded_avg.\n\nYeah, but why does it need to be converted to binary and returned in base-10? Is it for illustration purposes only?\n\nIt's used in the next code snippet to illustrate that the average of 1 and 2 is 0.5.\n\nP.S. For a really \"meta\" take on this, look at the source code of the page: \n\nGreat post, but I think that at least the second example is wrong.\nThe result of the calculation, \"0b11\", is not a binary number. There are only two digits.\nTo make this a binary number, you have to add 1 to every digit. I think the correct result is \"0b01101", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n         result = 0.0\n        while n > m:\n            if n > m:\n                  result = -1.0\n                  n -= 1\n                 else:\n                   result = n\n                   n += 1\n                   result /= 2\n                   n /= 2\n                    n /= 2\n                    n /= 2", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    rounded_avg = []\n    while n > m:\n        if n % m == 0:\n           rounded_avg.append(n)\n           rounded_avg.append(m)\n    return int(rounded_avg)\n\nThis code is the \"translation\" of the first part of the answer. The\nsecond part relies on this code.\n\nBut, if you're _actually_ trying to work out what the code above does,\nI'm pretty sure it's wrong.\n\nI did a quick test on Python and the results are not the same as the\nanswers. See the test program here:\nhttps://gist.github.com/knotrumpet/9c12d62e8dcfd2c8ca70\n\nI used this test program as a basis for my python code:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    n = floor(n / 2)\n    for i in range(n):\n        if m < i:\n           i = i + 1\n           return round(avg(i, m - i), 2)\n    return 0b11111111111111111111\n\nThis is just the naive solution to the problem. I'm sure there are much better ones.\n\nYou can easily do this using the summation or geometric series.\n\nThis is what I came up with:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if m > n:\n        return -1\n    result = [0]*(n+m) / (n+m+1)\n    return result[0] + ((result[1]*result[2])+result[2]) % (m+1)\n    # convert the integer to binary.  This is a time saver for computers.\n    if int(result) == 1:\n        return result[0]\n    return result\n\nIt's a bit tricky to write a round function for every number between 1 and 5.\n\nIn this case, the example is correct. It has a bug with numbers that are > 5, though, and that's just something that needs to be considered when writing the code.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n < m:\n        return -1\n    else:\n        return n / m\n\nThis is an example of a micro-optimization.\nIn most of the cases, this function will work the same way as the naive approach, and in some cases even slower.\nThe only situation where it's faster is when n is extremely small.\nFor n < m, this function returns the integer part of n/m, and this is faster than division.\nHowever, it's still slower than the naive approach.\n\nThat's only true if the average of the integers is small enough to fit in a single CPU instruction. If not, it's way more efficient than the naive method.\n\nI've never heard of an algorithm that will round n/m to the nearest integer and that will be faster than an iterative loop that uses a modulus.\nCould you provide an example?\n\nI think the first loop in \"sumarray\" is faster than the second loop:\n\nFor sufficiently large n/m, this is correct.\n\nIf the sum is small enough that the rounding error does not matter, you can", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return float(floor(math.sqrt(n) * (n + m)))\n\nSince you don't have any constraints on what values you can get in the input, you can just use 1/sqrt(n) * (n + m) to get the average.\n\nI have to agree. There's no need for a sqrt if it's just for an average.\n\nI wouldn't say that. The square root is what allows you to average things with negative values. If you just divided by n + m, then you would get 1 when n < m.\n\nI agree that the average should be the square root of (n + m), but he shouldn't be using a sqrt to calculate the average.\n\nWhy not?\n\nThe average is the average of the values between n and m.\nIf you're doing a floating point addition of a number and a number, you can't simply add the numbers. You have to first scale the numbers by the floating point representation of the number.\n\nYou just agreed that 1/sqrt(n) * (n + m) is the average of the values between n and m. I'm not sure what you're", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    a = float(n)\n    b = float(m)\n    i = 0\n    while i < n:\n        a = (a + b) / 2\n        i = a + i\n        b = b / 2\n        if a > b:\n            return -1\n             b = a\n             i = i + 1\n    return a * i + b\n\ni'm having trouble understanding why the first example returned 0b11, and the second -1.\n\ni'm also having trouble understanding what 'a = float(n)' means.\n\nit would be nice if the code had some comments.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    a = 0\n    while n > m:\n         a = (a + floor(m / n)) / 2\n         if a > 0:\n             a = a - 1\n              return a\n\nOr you can just write the code to calculate the average and then write it a second time to round.\n\nThat's a lot of extra code for the same result.\n\nThe problem with the article is it doesn't mention the fact that 1 and 0 are represented by -1 and +1.\n\nThe problem with this comment is that it doesn't mention that 1 and 0 are represented by -1 and +1.\n\ni'm pretty sure that's why he said it.\n\nThis is a nice little implementation, but I think it would be more useful to show how to implement it with type annotations.\nIn this implementation, we have to manually check that x is a positive integer. With type annotations, we can make sure that the range of x is contained in the range of n.", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n <= m:\n        return n\n    else:\n        return m / (n + m)", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    return [int(m) + (n % m) + 1 for i in range(m+1)]\n\nI like the idea of creating a function that converts a string to binary, and then to the hex value for that binary. I don't like the idea of converting to hex and back to binary.\n\nIt's not a huge concern, but it's a few more bytes used than if I just used the exact same method that I use to convert from bytes to characters (which is just the same as what you said, but in reverse).\n\nAlso, if I recall correctly, the hex to binary conversion is built into Python. So, I could probably just change the method from hex to int and the above code would be even more efficient.\n\nEdit: Yes, it is built in. In that case, I just need to change the function to do the following:</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n\nimport decimal\nn, m = 5, 5\nreturn m + n\n\nThis works because it's a binary approximation of the function:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    k = n\n    while k > m:\n         m += 2\n         if k % 2 == 0:\n              return -1\n              k /= 2\n    return k / m\n\nHey, this is great. Thanks!\n\nThis is pretty cool - the code is a bit long but I like it.\n\nWhat is this? Is it a joke?</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    # Zero-pad the input numbers\n    numbers_to_average = [n for n in range(n, m)]\n    # If m > n, return -1\n    if m > n:\n        return -1\n    # If n is positive, subtract 1\n    if n > 0 and n < m:\n        return -1\n    # The middle number in the range is the average\n    m_avg = int(n / 2)\n    # Keep track of the number of zeros in the result\n    zeros = int(m_avg / 2)\n    # Round to the nearest integer\n    return int(n + zeros * n / 2) + int(n - zeros * n / 2)\n\nI've got to give Python credit where it's due: the language is very flexible, and the syntax is easy to read. But this is a perfect example of the \"verbose and inefficient\" complaint many have.\nThis is not to say that Python is not", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    n = int(n)\n    m = int(m)\n    return n + m", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return sum(xrange(n) + xrange(m)) / 2.0 + 0b11111111\nThere's your new \"Rounded Average\". It's (n + m)/2 rounded to the nearest integer, and then converted to binary.\n\nAll the other answers are equivalent to the solution you gave, but they have to do a lot more work to compute it.\nYou'll notice that this solution is not always going to give you the same answer as the other solutions. The reason for this is that the \"Rounded Average\" function is really a special case of the \"Rounding Algorithm\".\nThe \"Rounding Algorithm\" is defined as:\nRounded Algorithm:\n1) If n > m, return -1.\n2) If n > m, round n to the nearest integer and convert it to binary.\n3) If m > n, round m to the nearest integer and convert it to binary.\n4) If n < m, round n to the nearest integer and convert it to binary.\n5) If m < n, round m to the nearest integer and convert it to binary.\n6) Return the sum of steps 1-5.\nAs", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    n = int(n)\n    m = int(m)\n    return int(rounded_floor(n - m, 2)) + 1\n\nso, if you use this library in a python script, you should type:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return -1 if n > m\n    n, m = str(n) + str(m), str(n) + str(m)\n    binary = \"01\" * (int(n) + int(m) / 2)\n\nThere is a numpy function for this (mean):\n\nround_mean(n, m, mean)\n\nSince python is a great language I'm surprised it doesn't have it's own\nequivalent.\n\nIt does, but the above code is more succinct.\n\nThe discussion on the numpy vs c code seems to be a bit off:\n\"You need to write more lines of code to do it in C, but the performance will be way better than the numpy version.\"\nWell, no, the code is the same number of lines. It might be less readable, but that's not the point. You're not going to add a few hundred lines of boilerplate to a numpy program just to get slightly better performance.\n\nYou're right, I should have written that the code is longer.\nI should have also written that if you're using python, you should stick to numpy.", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    int n = int(n) - 1;\n    for i in range(1, n):\n        if n % i == 0:\n            n /= i;\n          else:\n            m /= i;\n    return n;\n\nWhat is the point of this?\n\nIt's the same as the other examples in the article (arithmetic, bitwise, etc), except that it doesn't use a function pointer.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n        a, b, c = [n, m, n + m]\n        while a[n]!= m:\n           c[n] = a[n] + b[n]\n            a[n] = c[n] + b[n]\n            b[n] = a[n]\n            c[n] = a[n]\n            return a\n\nDo you have some advantage over division?\n\nI was wondering the same thing. I suspect the OP has some irrational dislike of division.\n\nThis is called an 'infinite loop'. It's an exception.\n\nYes, but it's a good example of how to read the code for a function. The method is also fairly quick to calculate and it's simple. I had to use something like this in an assignment for", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    n, m = int(input(\"Enter the number of numbers to be rounded: \"))\n    round = int(input(\"Enter the number of decimal places: \"))\n    rounding_digits = int(input(\"Enter the number of digits after the decimal point: \"))\n    # Round off the answer, then convert it to binary\n    return int(round * n) & rounding_digits", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    num = n\n    i = 2\n    while i < m:\n       if num > m:\n          return -1\n       n, m, i = n+1, m, i+1\n    return num + round(i, 2) + round(i+1, 2) + 1\n\nThe Python version is likely more readable. But, it's a good exercise to see how to do it without a programming language.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return -1 if n < m else np.round(np.asarray(m), 2)\n\nTo do arithmetic, you need an arithmetic library. As you've already found, Python's built-in module is quite limited. In particular, it doesn't support negative numbers, or arbitrary precision floating point numbers.\nFor negative numbers, you need to do your own implementation, or use a library like cmath or numba, which are available as third party packages.\nFor arbitrary precision floating point numbers, you could use e.g. numpy, but that will take a bit of work. Alternatively, you could use a library like libmdecimal, which provides decimal arithmetic, but with a fixed-size internal floating point number (you need to make sure that this is big enough for your needs).\n\nThanks for the link. I'm going to check out numba. It looks like the problem is the fact that I'm trying to operate on a signed integer in a non-native representation.\n\nIf you have a fixed number of decimal digits, you should use a fixed-point decimal library. Then you don't have to worry about the fact that there's only 32 bits of precision.", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    def output(m):\n    \"\"\"You are given an integer m and your task is to return the decimal integer\n    which represents the average of the integers from n through m (including m).\n    Round the answer to the nearest integer and convert that to decimal.\n    If n is greater than m, return 0.\"\"\"\n    if m < n:\n        return output(n)\n    output(m)\n\nPython code:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n        r = 0\n        while True:\n           i = n + m\n            if i > n:\n               break\n              r = r ** 2\n              if r >= n:\n                  return -1\n               i = r\n               if r == m:\n                  break\n          return r & 0xFF\n\nI'm not sure what you're trying to do here, but it looks like it might work.\n\nIt looks like a very quick and dirty solution to some sort of weighted average problem.\n\nYeah, it looks like it does the job,", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    n, m = int(n), int(m)\n    # round\n    return round(n * m, n, m)", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return 0 if n == m\n    return (n + m) / 2\n    # the last line rounds to the nearest integer, and converts to binary\n    return round(ord(n), 2) ^ ord(m), 2\n> def rounded_avg(n, m):\n>    \"\"\"You are given two positive integers n and m, and your task is to compute the\n>    average of the integers from n through m (including n and m).\n>    Round the answer to the nearest integer and convert that to binary.\n>    If n is greater than m, return -1.\n>    Example:\n>    rounded_avg(1, 5) => \"0b11\"\n>    rounded_avg(7, 5) => -1\n>    rounded_avg(10, 20) => \"0b1111\"\n>    rounded_avg(20, 33) => \"0b11010\"\n>    \"\"\"\n>    return 0 if n == m\n>    return (", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    def abs(x):\n        return x == 0 else -1\n    def avg(x):\n        return abs(x) / len(x)\n    def round(x):\n        return x ** 2 + x\n    def btoa(x):\n        return (x**2 + x)\n    def btoa_float(x):\n        return (float(x**2 + x)) / 2.0\n    return avg(n, m)\n\nimport types\nn = 10\nm = 5", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n\nn = int(raw_input(\"Enter an integer value less than or equal to n:\"))", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    return 0b111111 * (n - m) + 0b11010 * (m - n)\n\nAnd with a slight modification of the lexer:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    n = min(n, m)\n    for i in range(n):\n          if m % i == 0:\n               m = m % i\n            else:\n               n = n % i\n    return np.round(np.floor(np.bin(m, n)))\n    return -1\n\nSee also\n Python arithmetic functions\n Comparison of programming languages (arithmetic operations)\n\nReferences</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (n+1) * (m + 1) / 2\n\nAnd as the poster, I never actually got a job coding. I have a\nsoftware engineering degree, but I never actually got the hang of\nproperly writing code, so I spend my days in business administration.\n\nYou have no excuse. This is a non-trivial algorithm.\n\nThe two comments above are all you need.\n\nYeah, I figured. It was a long time ago, and I just remember the basics.\n\nThis is the correct answer.\n\nVery nice. I also made a python version here:\n\nI'm getting \"SIGSEGV\" when I run it.\n\nYou should be getting this:\n>>> q = int(round(x**2, 3))\n>>> q == x**2\nTrue\n>>> q == x**2.0\nTrue\n>>> q == x**2.1\nFalse\n>>> q == x**2.2\nFalse\n>>> q == x**2.3\nFalse\n>>> q == x**2.4\nFalse\n>>> q == x**2.5\nFalse\n>>> q == x**2.", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n >= m:\n        return -1\n    else:\n        return floor(rounded_avg(n - 1, m) / 2)\n\nThe inverse of this (round up the last m numbers) is also useful, especially if you need to sort a list:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (n + m) / 2", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    from itertools import cycle\n    import operator\n    import math\n    def round(a):\n        if a == 0:\n           return 1\n         else:\n            return round(a - 1)\n    a = round(math.floor(a / 2))\n    return a\n    # Rounding up\n    return 1.0*a/2.0 + round(a - 1)\n    # Rounding down\n    return -1.0*a/2.0 + round(a + 1)\n    # Cycle through the set\n    a = cycle([math.floor(a / 2), math.floor(a / 2), math.floor(a / 2), math.floor(a / 2), math.floor(a / 2), math.floor(a / 2), math.floor(a / 2), math.floor(a / 2), math.floor(a / 2", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    i = 0\n    while i < n:\n        i += 1\n        if i == n:\n           return -1\n        else:\n            return (i * m + (i * m + i)) % 2\n    return (i * m + i) % 2\n\nNot sure if I'm understanding this correctly. Are you saying that you're rounding the answer to the nearest integer and then converting it to binary?\nIt would be better to just convert it to binary from the start and then round to the nearest integer.\n\nYep, that's pretty much what it's doing.\n\nThis is a common mistake. On average, it's better to use floats for rounding.\n\nInteresting. Do you have a reference for this?\n\nWhy are you using floats in the first place?\n\nI'm using floats for storing the average of n through m, and converting it to binary at the end.\n\nWhy?\n\nBecause binary is much more compact than decimal.", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    for n in range(n, m+1):\n        for i in range(n):\n           if i % 2 == 1:\n                round(i, 2)\n                i /= 2\n                 return i // 2\n    return -1\n\nDoes anyone have a more efficient solution?\n\nThe efficient solution is to use the fact that you're always summing\npositive numbers (the first two numbers are the same and always > 0)\nand work left-to-right.\n\nI'm guessing you mean something like this:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    b = int(b\"01\")\n    while n <= m:\n        a = n\n        b = int(b\"00\") + int(a*b)\n    return b\n\nI'm not sure if this is the best way to do it, but it's how I would do it.\n\nNote that this uses the same strategy to deal with small integers, and large integers.\n\nI'm not sure if that is what you want.\n\nHere's the code I wrote:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return 0 if n < m else -1\n\nThat's a nice one. It's a bit non-obvious, but the bit-twiddling is much easier.\n\nI've always been interested in the results, but never really found the time to run them. Would anyone know a good resource for that?\n\nhttp://www.google.com/trends/explore#q=ruby%20trends\n\nI find it interesting that \"ruby\" and \"ruby on rails\" have had very similar trends for the past 10 years or so.\n\nI think that's more a reflection of the fact that \"Ruby\" has been a very successful search term for a long time (it's not exactly a niche thing), and that Ruby on Rails is an entire web framework built on top of Ruby.\n\nActually, I'd say it's a reflection of the fact that Ruby on Rails is an entire web framework built on top of Ruby.\n\nI wonder what it would look like if you removed the \"ruby on rails\" tag.\n\nI agree that's an interesting question. It would be interesting to compare that to other frameworks as well.\n\nIt would be interesting to see", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (int(int(int(int(n))) + int(int(int(m))))) / 2\n\nIf n is greater than m, you'd want to return -1. If n is less than m, you'd want to return 1.\n\nI'm not sure what you mean by \"round to the nearest integer and convert that to binary\". If you want to compute the average of the integers from n through m (including n and m), you'd want to round to the nearest integer (i.e., truncate to the nearest integer) before converting to binary.\n\nDo you understand what the rounding does?</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    result = -1\n    while n > m:\n        result = (result << 1) + result\n        result = result >> 1\n    result = (result & 1)\n    while result < n or result > m:\n        result = (result | 1)\n    return result", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return int(round(n*(n+1)/2))\n    + int(round(m*(m+1)/2))\n\nThe original code uses a prime-modulus trick to obtain a very fast solution. The code is broken down as follows:\n1\\. Since the average of n numbers is the sum of all divisors of n, we can compute the sum of all divisors in parallel. The naive way is to divide n by each divisor, but that is O(n^2) and not feasible. A better way is to use a prime-modulus trick. If n = pk and m = pm, then the sum of divisors of n is n^m - pk. Thus, we can compute n^m in parallel by multiplying n by pk in parallel, and then summing the results. This is the idea behind the original code.\n2\\. To compute the average of the divisors, we use a divide-and-conquer approach. First, we divide n by each divisor, and then we divide n / (n-1) by the divisors of those numbers. This is the same", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return round(n*m + 1, m+1)\n\n`round` is part of the GNU coreutils.  It is part of the POSIX specification.\n\nThis is a fun exercise. I've always found that writing the fastest implementation of some common function is a good exercise. You might not end up with something that's faster than any other implementation, but you do end up learning a lot about the language, and your own thought processes.\n\nIt's also a good exercise to write a fast implementation of a slow one, e.g. an algorithm that takes O(n^3) time in one language, and then write it in another language in O(n).\n\nI did a similar thing for the Fibonacci sequence. I was amazed at how much faster the code was, and also how much more readable it was.\n\nIs that so? I would expect that the equivalent Python code would be shorter, and more understandable.\n\nWhy would you expect that? Fibonacci is a fairly simple recursive algorithm, which would be easy to write in Python.\n\nThe fast code, as the article points out, is more readable because you have to think about the algorithm's properties", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    result = 0\n    for i in range(n):\n         if i >= m:\n             result = -1\n            else:\n               result = n / m\n                if n % m == 0:\n                      result = n % m\n                     else:\n                      result = n\n                      if n >= m:\n                           result = -1", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    average = 0\n    while n > m:\n        if n % m == 0:\n           average += n\n           if n % m == 1:\n             average /= 2\n             if n % m == 2:\n                  average *= 2\n                 if n % m == 3:\n                    average /= 4\n                  if n % m == 4:\n                     average *= 4", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    a = n / m\n    b = a + n\n    return (a & b) >> 1\n\nAnd the github commit that introduced the bug:\n\nThat is insane. But very cool.\n\nDidn't Microsoft do something similar with their build numbers?</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    else:\n        return (n / m + 1) % n", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (n + m) // 2 // 2 // 0", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    n = int(n)\n    m = int(m)\n    for i in range(1, m+1):\n        if n >= i:\n            return -1\n            n = int(n)\n    return n ** (m-1) + m\n\nBut then I'd have to compare against a string, which I'm trying to avoid.\n\nIn Python, a string can be an integer.\n>>> 1", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return sum(1 for m in range(n + m)) / 2", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    return n / m\n\nHere's another one that I didn't find in the article, but seems like a good exercise.", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return max(0, 0b1) + min(0, 0b1) + 0b1\n    / (max(0, 0b1) + min(0, 0b1))\nI don't think it's obvious to a new Python programmer what this is doing. In the sense of \"does the code work\", yes. But I think it's a good idea for a new programmer to have to think about what's happening.\n\nIs it obvious to a new python programmer that you can iterate over a string (and that the results are returned as integers)? Is it obvious to a new python programmer that the square of a number is the same number?\nThe Python language is quite terse, so at some point you have to assume that the reader has enough prior knowledge to be able to deduce the purpose of the function.\n\nI agree with you, but I think it's a false dichotomy.\nI don't think this code's terse-ness is a virtue, I think it's a vice. There's nothing wrong with making people think about what they're doing, and that code doesn't make people think about what they're doing.\n\nI'm not", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return int(n + (m << 1)) + int(m + (n >> 1))", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n >= m:\n        return -1\n    else:\n        return np.round(np.abs(n*m))", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (n - m) % 2\n    # -1 if n > m\n\nI'm not sure that's what the OP meant. You're certainly not getting the _average_ of the numbers between n and m. You're just getting their _difference_.\n\nThat's what I meant - you're getting the average difference, not the average of the numbers.\nI think that's actually a good demonstration that, for the purposes of this question, you don't actually need an average function - the difference is a valid answer.\n\nI think that's a good demonstration that the OP should be more clear.\n\nI'm a bit confused - I've read the question twice and I don't see how this solution is different than the accepted one. Could you please clarify?\n\nThis solution returns the average of the numbers between the range limits, while the accepted one returns the difference between the numbers. That's not a minor difference.\n\nOh, I see. I assumed the original poster wanted the difference because they were interested in a different approach.\n\nThe problem is that the difference is not the same as the average, so the accepted answer is wrong.\n\nI can't agree with", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    def round_to_nearest(n, m):\n    \"\"\"Round number n down to the nearest integer.  If the result is greater than\n    the number m, return -1.  Return 0 if n is equal to m.\n    The result is the same as the result from rounded_avg(n, m).\n    Example:\n    round_to_nearest(7, 5) => -1\n    round_to_nearest(10, 20) => 0\n    round_to_nearest(20, 33) => -1\n    \"\"\"\n    n = floor(n / m)\n    if n > m:\n       return -1\n    return 0\n    return round_to_nearest(m, n)\n    return n\n\nThe first time I see a piece of code that would be better written with a shell script.\n\nThat's nice.\n\nIf you want to learn some interesting math, try to come up with an efficient algorithm for solving the summation of", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n < m:\n        return -1\n    if m > n:\n        return n\n    return math.ceil(int(m, 2))\n\nNotice that the function explicitly returns -1 if you pass two positive numbers.\n\nNow imagine that you are writing a function that calculates the average of a set of numbers.  In particular, you are calculating the average of a set of numbers that includes negative numbers.  You start out the function as follows:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if m > n:\n        return -1\n    m = n // 2\n    if m == 1 or n == 2:\n        return 0\n    for i in range(n):\n        for j in range(m):\n           a = i + j // 2\n           if a >= n:\n                return -1\n                 else:\n                  return a + 1\n    return a % 2 == 1? a : (a + 1) % 2\n\nCan you explain why?</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n\nI would have expected it to be \"0b11000\", but I don't think it's possible to disagree that \"0b11\" is unambiguous.\n\nAnd what does 'unequivocal' mean in this context?\n\nThere are only two possible values.\n\nNot if it's an IEEE float.\n\nHuh?\n\nC is a fixed-width representation. So 7.5 could be represented in C as either 7 or 7.5. But in IEEE754, it is only represented as 7.\nIt's the same as C's 'int'. Could be signed or unsigned, so could be 0 or -0. Or it could be a signed char, and represent -128 or 127.\n\nYeah, I know that about C. But what does it have to do with the article? The article talks about 'arbitrary' integers, not fixed-width ones.\n\nThe article talks about 'arbitrary' numbers of bits. IEEE754 float has more than 'arbitrary' number of bits.\n\nBut it also says that the numbers are 'arbitrary' in the sense that you can't know what they are just by looking at their binary representation. And", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (sum(range(n))/range(m)+range(m))%2 == 0\n\nI wrote this because I'm tired of typing (sum(range(n))/range(m)+range(m))%2 every time I need to compute the average of an integer sequence.\n\nThis is awesome.\n\nIt would be nice to have a version that returns the correct value for positive integers. (This one returns -1 for all positive integers.)\n\nThis is awesome. I also wrote a similar one a while back that can handle some edge cases:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    result = 0\n    while m > n:\n        if m % 2 == 0:\n           result += n\n        else:\n           result += n / 2\n         n += m\n         m -= n\n    return result\n\nI've always been baffled by the popularity of \"human-readable\" versions of mathematical constants. They don't really provide any additional information that you couldn't get from the binary versions, and the fact that you can't unambiguously convert them back and forth to a more conventional format makes them harder to work with.\n\n_They don't really provide any additional information that you couldn't get from the binary versions_\nTo be fair, if you want to share something with a friend, a string is probably a better way to do it than a binary number.\n\nI can think of two reasons why a binary number might be preferable to a human- readable string. The first is if the thing you're sharing is a computer program. In which", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    def __init__(self, m, n):\n        self.m = m\n        self.n = n\n\n    def round(self, v):\n        if v >= self.n:\n           return -1\n           if v < self.m:\n               return self.m + 1\n            else:\n               return self.n\n          return self.m\n    def convert_to_binary(self):\n        # Round to nearest integer\n        return round(self.m)\n    def round_average(self, a, b):\n        # Convert to binary\n        return convert_to_binary(a) + convert_to", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    rounded_avg = lambda a, b:\n        if a < b:\n            return a / b\n       else:\n            return (a + b) / 2\n   \n\nI don't know what I'm looking at.\n\nI'm guessing some sort of fake code created in a non-lispy language (like C) to illustrate the author's point.\n\nYou are correct. It was created in PHP.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    a = 0\n    b = 1\n    while n > m:\n       a += (n % m)\n       b *= (n % m)\n    return a", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n        return n + m + 1", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return float(n) + float(m) / 2.0\n\nI'm a Ruby noob, but the Ruby code looks fine to me. Can you give more information about what isn't working?\n\nI don't know ruby, but if the question is how to round the number to the nearest whole number, I'd assume that you want to use the floor function, not the round function.\n\nThis is correct. Round just rounds to the nearest integer. Floor rounds down to the nearest integer, and ceil rounds up to the nearest integer.\n\nWhen I was a young lad, I used to think that it was only a matter of time before we had a computer that could beat a human at chess. Now I know that I was right!</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (m << (n - m)) & 0b11111111\n\nI like the idea.\n\nHow about a version of bitwise xor that always rounds the result to the nearest integer?\n\n(n-m) & (0b11111111) === n & (0b11000001)\n\nyep that's pretty much how the algorithm works.\n\n... but since the new algorithm is more complex (and therefore slower), it'd be good to benchmark it.\n\nAgreed, but it's still very useful for simplifying a lot of code, for example, suppose you have a loop that needs to multiply 4 integers with 4 integers, and you want the rounded result.\nYou could do:\nfor i in range(4):\nx = (i * 4)\ny = (x / 4)\nz = (y % 4)\nsum = (z & 0b11111111)\nfor i in range(4):", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    # round down if n is greater than m\n    if n > m:\n        return -1\n    # add the integer and its reciprocal\n    if m is odd:\n        n = m % 2\n    else:\n        n = m % (2 + 1)\n    return n", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    for i in range(m, n):\n        if n > m:\n            return -1\n       else:\n            return i+1\n        return n/m+1\n\nIf you want to round to the nearest multiple of the number of digits in the number, you could change the multiplication to addition (since the binary representation of a number will always have a power of 2):", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (sum(x for x in range(n, m + 1))) / 2.0;\n\nOh, I don't know why I didn't see that. Thank you.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    for i in xrange(n+1, m+1):\n          if i < n:\n               return i\n           else:\n                 return i + rounded_avg(i, m-1)\n    return -1\nThis is the fastest Python implementation I can think of that still supports the minimum.\n\nIs it possible to use that \"bit-shift\" trick to do the division?\n\nNo, Python doesn't have bitwise operators.\n\nThis is one of those cases where the language isn't really the limitation.\n\nI'd say the fact that Python doesn't support it in the language is a limitation.\n\nIf by \"it\" you mean bitwise operations, it's a limitation of all languages I'm aware of. You have to use something external to the language.\n\nI don't think it's a limitation of most of them. e.g. Java has\n(java.lang.Math.bitAnd)\n(java", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if m == 1:\n        return n\n    elif m > n:\n        return -1\n    else:\n        return m / n % 2\n\nWhat this function does is it rounds the input to the nearest integer, and then converts that to a binary number (I assume the example number 1 converts to 1, 2 converts to 2, 3 converts to 3, etc.)\nThe problem with this function is that it assumes that the input will be integers, when it isn't.\nIn the second example, if you take the number 7, it rounds that to 7, and then converts that to a binary number, the binary number will be 1, and that's wrong.\n\nBut, if you look at the code for `round` in the standard library, you can see that they simply subtract the value from `rounding_mantissa`, so I think the solution to the problem is just to subtract the value from `rounding_mantissa` before converting it to a binary number.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    sum = 0\n    while sum < n:\n        sum = sum + m\n        if n % 2 == 0:\n           return sum / 2\n    else:\n         return n\n\nI think this is the correct answer, but for some reason it's not doing what I'd expect.\n\nMaybe there is a bug in the Python interpreter?\n\nNo, there is not a bug in the Python interpreter.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    a = m\n    while a > n:\n       b = a\n       if b < n:\n          return -1\n          a = b\n           return a\n    return a\n\nFor the record, I just ran it in python and it ran in 0.016 seconds (in CPython 2.6). So I'm not sure what he's on about.\n\nI had to read the comments to figure out that he was using the function \"math.round()\" and not the \"round()\" function.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return n*(m-n)/2 + (n-1)*m/2\n\nThis looks like it would work fine for the \"average of the integers\" problem.\nBut I believe the OP is looking for an algorithm to solve the general class of problems.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (n ** (m - 1)) + (n ** (m + 1))", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    # in case there are any negative numbers, we'll treat them as 1's\n    if n >= m:\n       return -1\n    # calculate the average in binary\n    n_bits = int(m & 0xFF) + n\n    return n_bits\n\nIn the code, m & 0xFF is an arithmetic right shift, which rounds down. It is not \"right\" to do so, as the correct answer would be to round up.\n\nI'm not sure what you mean by \"it is not \"right\" to do so\". In the context of binary arithmetic, this is the correct way to round the value of m. You might be thinking of decimal arithmetic, where the correct way to round m is to divide by two and then round up. However, in binary, the most significant bit of the result of the shift will be 1, so dividing by 2 and rounding up will result in a negative number.\n\nWhen you take the binary value of m & 0xFF, the result is the most significant bits of m. If m & 0xFF shifts out the least significant bits of m, then the", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    a = n\n    b = m\n    return a + (b * (b - a)) // a = (b - a) / 2 + b // a = b / 2 + m\n\n>>> import round\n>>> round(1, 5) # a = 1\n>>> round(7, 5) # a = 1\n>>> round(10, 20) # a = 2\n>>> round(20, 33) # a = -2\n>>> round(20, 33) # a = 2\n>>> round(0, -1) # a = -1\n\n>>> import itertools\n>>> from itertools import product\n>>> round(7, 5) # a = 7 * 5 = 35\n>>> round(10, 20) # a = 10 * 20 = 200\n>>> round(20, 33) # a = 20 * 33 = 660\n>>> round(20, 33) # a = 7 * 33 = 231\n>>> round(0, -1) # a = -1\n\n>>> import itertools\n>>> from itertools import product\n>>> round(7, 5) # a = 7 * 5 = 35\n>>> round", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if m > n:\n        return -1\n    m = n\n    for i in range(m+1, n):\n        if i > m:\n           return i - m\n    return i\n\nI'm just wondering how this is a particularly good algorithm for finding the average of two numbers. I mean, if you know there are two numbers, the average is easy to compute by rounding the first number, and subtracting the second.\nThe fact that the answer is rounded to the nearest integer makes sense, but I would expect that this is a very common task for an O(n) algorithm. Why is this algorithm particularly good, and why is it optimized for binary?\n\nI'm not a mathematician, but I think the intuition is this:\nSay you have a real number, a, and a binary number, b, with a \u2260 b. If a is a _power_ of 2, then (a + b) / 2 = (a * 2^b) / 2, so rounding the answer to the nearest integer and converting it to binary", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return\n    min(floor(n) + floor(m) / 2)\n    + floor(n*m / 2)\n    + floor(n + m / 2)\n    + floor(n*m + m / 2)\n    + floor(n * m + m / 2)\n\nNice! The only thing I would add is to return -1 if n > m, and 0 if n < m.\n\n_Any_ code that doesn't check for overflow deserves to get overflowed, IMHO.\n\nI think you have a good point. There is also a simpler solution if you're using Python.\n\nor\n\nI think his point is that in Python, with two integers, you don't even need to check if the numbers are greater than or equal to each other; the second one will be returned if the first one is.\n\nI see. I must have missed that somehow.\n\nI'm using this function for the title of the post.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    # round to nearest integer\n    return m+1\n    def rounded_bin(n, m, p=0):\n    \"\"\"Given two positive integers n and m, round to the nearest integer and\n    convert that to binary (but do not round the result!).  If n is greater\n    than m, return -1.\n    Example:\n    rounded_bin(1, 5) => \"0b11\"\n    rounded_bin(7, 5) => -1\n    rounded_bin(10, 20) => \"0b1111\"\n    rounded_bin(20, 33) => \"0b11010\"\n    \"\"\"\n    # round to nearest integer\n    return m+1\n    def bin_round(n, m):\n    \"\"\"Given two positive integers n and m, round to the nearest integer and\n    convert that to binary (but do not round the result!).  If n is greater\n    than m, return -1.\n    Example:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    from math import sqrt\n    from math import log\n    n = sqrt(n)\n    m = sqrt(m)\n    rounded = log(2)\n    return - rounded if n > m else return rounded\n\nYou can also do this with Python.", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    else:\n        return n\n    return m\n\nThis is the kind of stuff that is pretty common in C-style languages. It's not really a gotcha, it's just a bit of a different paradigm.\n\nAh, I see. I don't think I've ever used a language like that before, but that makes sense now.\n\nIn C++, the average is computed as \"floor((sum / 2) + 1) / 2\". The definition of \"floor\" is \"the largest integer smaller than or equal to\".\n\nIf I was writing a Python version of this, I'd probably do something like this:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    while n > m:\n        sum = 0\n        while sum > 0:\n           sum = sum - (n & m)\n           if n == m:\n              return sum\n            if n % m == 0:\n               return -1\n    return sum / (n + m)", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    n_squared = abs(n)\n    for m in range(2, n_squared + 1):\n        sum = 0\n        n_squared_after_adjustment = n_squared - n + m\n        n_squared_after_adjustment = abs(n_squared_after_adjustment) / 2\n        if m == n_squared_after_adjustment:\n            return -1\n            else:\n              sum += n_squared_after_adjustment\n             return sum / n_squared\n\nThanks for that. I don't know how I didn't think of that.\n\nYou're welcome!\n\nFirst draft, a little bit of a challenge.\n\nI got a few solutions to this, but they all seemed too lengthy and complicated.\nMy solution is a little", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (n + m)/2.0 + (n-m)/2.0 + (n%2) + m*(n-m)/2.0 + n%2.0\n\nWow. C++ really can make something that should be a simple one-liner into a multi-line spaghetti code.\n\nI dunno, it's kind of a nice example of how to use one of the features of the language, and there's not much wrong with it.\n\nI have a pretty good C++ background and I am getting more and more scared of the language every time I read a discussion on Hacker News about it.\nOn a more serious note, I wish I had more time to read about the Standard C++ Library but from what I understand there is still a lot of legacy code in C++ and a lot of people are still using pre C++11 features. This makes the job of people maintaining the language really hard.\n\nThis isn't a legacy thing, it's the nature of C++: every feature is a huge open question, because every feature can be used to do anything. Every time a new language feature is added to the language, a large number of questions must be answered:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return ((n * (n >> 1) + (m * m)) >> 1) + ((n & 1) & 1) + ((m & 1) & 1)", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return math.floor(math.ceil(log10(n/m)))\n\nIf you only need the precision of the floating point representation, you can use something like\nx = 1.1 + 0.2 * x + 0.4 * x + 0.8 * x\n\nI love python\n\nIt's nice to see a list of the most common python functions that are almost, but not quite, built-ins. The only one I was missing was chr.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    # Add a trailing one to be able to convert the binary to decimal\n    round(n - m, 1)\n    # Convert to binary\n    return (n - m) & 0xFF000000", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    result = 0\n    while n > m:\n        if n > m:\n            result = result * -1\n            else:\n              result = result / 2\n              result *= 2\n              result /= 2\n              result = int(round(result))\n             result &= 0xFF\n    return result\nFor the first input:\n>>> rounded_avg(1, 5)\n'0b11'\n>>> rounded_avg(1, 10)\n'0b1111'\n>>> rounded_avg(1, 20)\n'0b11010'\n>>> rounded_avg(1, 30)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return sorted(m, n, key=lambda x: int(x+1) % m, reverse=True)\n\nDoes anybody know of a way to do something like this in a more efficient way, maybe as an extension of the example?\n\nThis is not efficient at all. It is the naive way to do it, but not the most efficient.\nI don't think there is a way to do it more efficiently with Python. You can only do it efficiently if you are willing to write it in C, but Python is not fast enough to write that extension.\n\nDoes the C code even have any advantage? You could write a similar code in C, which would be even more efficient. But then you also have to handle the sorting, which is probably the most time-consuming part.\n\nIt is usually way faster to write a simple sorting function in C than writing it in Python, and if the list is already sorted, the sorting function is not needed.\nAlso, if you write it in C, you can easily use binary floating point and get the most speed out of it.\n\nI'm sorry, but what exactly does sorting the list do to make this more efficient?\n\nIf", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return n + (m - n) / 2\n\nFor the numpy implementation:\n>>> def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\"\n    return n + (m - n) / 2\n\nSo, for all the points, `m` and `n` are greater than zero.\n\nI know. I was just wondering if there was a good reason for that.\n\nIt's hard to say why the author chose", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (n ** (n+1) - m ** (m+1)) % m\n\nfrom math import log, sqrt", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return round(n * (n + 1) + m * (m + 1)) % 2 + 1\n\nThe article doesn't mention it, but I think that's the _correct_ way to do it:</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (n + (n * m)) / 2\n\nimport itertools\nimport string", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    n = int(n)\n    m = int(m)\n    return floor(log2(n+m))\n\nFor those curious, here's the output of `python -c \"print(rounded_avg(1, 5))\"`:\n0b111100001010\n0b111111101100\n0b111111101110\n0b1111111101000\n0b1111111111000\n0b1111111111100\n0b11111111111110\n0b11111111111111\n0b1111111111111110\n0b1111111111111111\n0b111111111111111110\n0b111111111111111111\n0b11111111111111111111\n0b1111111111111111111110\n0b1111111111111111111111\n0b11111111111111111111111\n0b11111111111111111111111110\n0b11111111111111111111111111\n\nI had to do something similar to this a while ago for a project. Here's my take, which is slightly more intuitive, but doesn't use any standard math functions (ie you need to write down the formulas for floor() and log", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    return 0b11100110110000100010100\n\nSee also:.", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    # This is a very simple and naive implementation.\n    return (n**(m**2))/m**2\n\nAt first glance, it's \"obvious\" that this is the correct solution. And it\nis, in the sense that this is how I would have solved the problem when I was\n12 years old. It's also very short, so it must be the simplest solution,\nright?\n\nSuppose we know that m is a power of two. The output is still correct,\nbut there is a more efficient solution. Can we get a tighter bound on\nthe complexity?\n\nHow about the following code:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    a = n\n    m = m\n    while m < a:\n        m = m + (n - m) / 2\n        if m < a:\n           a = m\n           m = m + (n - m) / 2\n    return m\n\nI'd be interested in a more general approach.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    m = m / n\n    return m", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    return n / m + 1\n\nI like this example. It's simple enough to understand how it works, yet I can't imagine using it in real life.\n\nYou could use it to calculate your yearly salary.\n\nIt seems to me that this would be easier to read as", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return -((m + 1) * (n + 1))\n\nYeah, I know, it's dumb, but the next version will use max and min instead of +1 and -1.\n\nThe best and most common way of rounding to integer is to use the floor function:\n>>> from decimal import Floor\n>>> rounded_avg(1, 5)\n0\n>>> rounded_avg(7, 5)\n-1\n>>> rounded_avg(10, 20)\n1\n>>> rounded_avg(20, 33)\n2\n>>> rounded_avg(Floor(10, 20), Floor(33, 20))\n2\n\nAnd it is always better to use the max function instead of +1 or -1:\n>>> from decimal import max\n>>> rounded_avg(1, 5)\n0\n>>> rounded_avg(7, 5)\n-1\n>>> rounded_avg(10, 20)\n1\n>>> rounded_avg(20, 33)\n2\n>>> rounded_avg(max(10, 20), max(33, 20))\n2\n\nI like this one better. It's cleaner", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return n/m\n\n>>> rounded_avg(1, 5)\n            0b11\n>>> rounded_avg(7, 5)\n            -1\n>>> rounded_avg(10, 20)\n            0b1111\n>>> rounded_avg(20, 33)\n            0b11010\n>>>\n\nNote that \"1.0\" should be defined as either 0 or 1, not some weird\nimplementation-defined value (that could be either 0b1001 or 0b1010, for\nexample).\n\nYou're also going to run into problems with the library implementing\nfloating point arithmetic in the future. You're assuming that your\nnumerator is always larger than your denominator, but that's not always\ntrue.", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    return (n / m) + 1", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return ((n * m) + n + m) / 3", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return n // 2.0 + m // 2.0\n\n> def rounded_avg(n, m):\n> return n // 2.0 + m // 2.0\n>\n>\n>\n> def round_to_decimal(n, m):\n> return n % m\n>\n>\n>\n> def round_to_binary(n, m):\n> return n & m\n>\n>\n>\n>\n> print rounded_avg(10, 100), round_to_decimal(10, 100), round_to_binary(10, 100)\n>\n>\n>\n> 5\n> -2\n> 11100\n\n>\n>\n>\n> 5\n> 2\n> 0011\n\n>\n>\n>\n> 5\n> -2\n> 10110\n\n>\n>\n>\n> 10\n> -\n> 01101\n\n>\n>\n>\n> 10\n> 2\n> 01010\n\n>\n>\n>\n> 10\n> -\n> 00100\n\n>\n>\n>\n> 10\n> 2\n> 00111", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (((n + m) >> (n - m)) & 1) & (n - m) >> 1\n\n>>> round_number = lambda n: round_avg(n, 5)\n>>> round_number(10)", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return int(n+m) - int(n-m) + int(n%m)\n\nWTF? Why would you create a function to do something so trivial?\n\nIf it's so trivial, why don't you do it?\n\nIf you have to ask, you'll never know.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    for i in range(n):\n        if m <= i:\n            i += 1\n             i %= m\n              return float(i / m)\n\nThis doesn't work for large values of n, for example:\n>>> rounded_avg(10**6, 10**4)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'float' object doesn't support item assignment\n\nWhat he means is that the result is in decimal, not binary.\n\nMy mistake, thank you.\n\nI did a bunch of these in C some time back, I'll try and dig them up.\n\nHere's one I have on hand:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    while n <= m:\n         if n < m:\n              return -1\n                 else:\n                   return n\n\nLooks correct.\n\nI believe that some of the responses here are more easily explained by the fact that the original question was worded poorly.\n\nHere's a better question:</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    n, m = (n, m)\n    i, j = n + m\n    while i < m:\n        i = i + j\n        if i == n or i == m:\n            raise StopIteration\n        j = (i - m) / 2\n         if j == 0 or j == 1:\n             raise StopIteration\n             i = i + (i - j) / 2\n    return 0b1111111111 + rounded_avg(i, j) + rounded_avg(i + j, j)\n\nI'm no Python expert but I can't see how this could possibly be faster than just doing:\n>>> from binascii import hex\n>>> n, m = (1, 5)\n>>> hex(n, m)\n0b11000011\n>>> rounded_avg(n, m)\n0", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    k = int(n)\n    for i in range(m):\n         if k < i:\n               return k - i\n                else:\n                   return k + i\n\nI think you need to modify the function to keep the higher power of 2 bits and then use 2's complement on the lower power of 2 bits.\n\nHow can you use 2's complement?\n\nThis is a common question, so I've written a blog post on it:\n\nGreat post! Thanks for sharing it.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (n+1)//2 + (m-1)//2 if n > m else -1\n\nThat's a cool trick, but it's not quite what I'm looking for.\nWhat I'm actually trying to do is round up a whole number of integers.\nI will clarify my question in the text.\nThanks.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return n * m + (n - m)\n\nYes, this is correct. But a human would be able to figure out the method to get the right answer.\nSo it's not \"tricky\" per se, but more like \"clever\".</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    result = 0\n    while m!= n:\n        result = result + (round(n) + round(m)) % 2\n        result = result % 2\n        if result > n:\n             return -1\n             if result < m:\n               return result\n    return result\n\nreturn result\n\n>>> result\n[0] \"0b01011\"\n>>>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    n, m = int(n), int(m)\n    binary = '1' + binary + '0'\n    return (n + m) // 2\n\nThe article, however, is talking about the _binary_ logarithm of 1 + 0 = 0.\n\nIt's good to see all those \"smart\" people in a room, pondering the meaning of life, and all they can come up with is the time() function.\n\nAs a network guy, I'm always amused that no matter how far out into the wilderness the conversation goes, they always manage to circle back to computer science.\n\nWell, computers are the only things that they have any real experience with.\n\nWhat's the point?\n\nI'd say the point is to come up with answers that are so ridiculous you can't help but laugh.\n\nAnyone here into Dijkstra?\n\nTo which Dijkstra would reply: \"Are you serious?\"\n\nand the answer would be: \"are you serious?\"\n\nthat's a tough one!\n\nWhy didn't they use the integrated python interpreter?\n\nBecause python was never designed to be used as a", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    total_sum = 0\n    while n < m:\n        total_sum += n\n        total_sum = total_sum + rounded_avg(n, m - 1)\n    return total_sum\n\nTo me, this makes the following incorrect:\n>>> round(10 * round(20, 33))\n'0b1110'\n>>> round(20 * round(10, 20))\n'0b1111'\n\nWhy?\n\nBecause of \"n < m\"\n\nOh, I see.\n\ni wonder if you could round to the \"closest\" integer in a set.\n\nIf you mean nearest integer _such that_ it is in the set, then yes.\n\nawesome. i thought there might be some sort of linear equation involving the set elements.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    result = n\n    while result > m:\n        result = result / 2\n        if result == 0:\n            result = -1\n            break\n    return result\n\nFurther reading\n\nExternal links\n http://www.codingame.com/programming/python/python-programming-challenges.html</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    \"\"\"If n is greater than m, return -1.\"\"\"\n    if n > m:\n        return -1\n    x = int(n)\n    if x == m:\n        return x\n    while x!= -1:\n        if x%2 == 0:\n           if x % 2 == 1:\n                  x = x / 2\n              else:\n                 x = x % 2\n         x = x % m\n    return x\n\nThis is a trivial exercise in factoring.\nYou're going to want to find the common divisors of n and m.\nn is odd, and m is even, so you have to find m-1.\nThe common divisors of n and m are:\n2, m - 1", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    result = 0\n    while n > m:\n        if n%m == 0:\n            result = result / (m-n)\n        else:\n             result = result % (m-n)\n            m = n\n    return result\n\nThat's the result. That's not how you do it.\n\nIf you want to learn Python, learn Python. You don't learn Python by learning C.\n\n_Don't_ use Python? Seems like an odd thing to say in the context of a Python book.\n\n\"Don't use Python\" is a very common saying in the Python community.\n\nI am a Python newbie, so I am not aware of such things yet.\n\nNot using Python is a good thing.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return 0 if m == 0 else if m!= n:\n        if n > m:\n           return -1\n           return -1 * n + m\n\nI am assuming that \"n through m\" means \"from n through m\" not \"from n to m\"?\n\nYep, it's \"through\" not \"to\". I had to go back and double-check that.\n\nIs there any purpose to this? There are plenty of solutions to this problem in Python. Why not use one of them?\n\nIsn't Python a language for computer people?\n\nPython is for everyone, even you.\n\nAh, so it is! I'll get started.\n\nWhat is with the \"0b\" prefix on the binary numbers?\n\nI assume it's a way to encode the numbers in hexadecimal.\n\nWhat's the point of this? There are plenty of solutions to this problem in Python. Why not use one of them?\n\nI've seen people using 'rnd()' instead of 'round()'. I'd be interested in", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    for i in range(n):\n          a = 0\n          while a < m and i % 2 == 0:\n               a += a / 2\n                a /= 2\n                a = a / a % 2\n                  a ^= 1 if a % 2 == 0\n    return(a)\n\nI don't have anything against this program. It's just my experience with a lot of these programs is that the sort of people who write them are not the sort of people who read them.\nThe people who write them, don't know what Python is, much less the syntax, the internals, etc. And the people who read them, don't know what a C program is, much less the syntax, the internals, etc.\nSo, I'd be very wary of any library that was full of this sort of stuff", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    def round(a, b):\n    return a % b\n    def conversion(a):\n    return chr(int(a))\n    return m + n\n\nIf you don't like this solution (I'm not sure if I do), you could also just do:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return sum(range(n), range(m))", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return -1 if n > m else 0 if n == m else 1", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return m + ((n + m) / 2) % 2 + (-n) % 2\n\nBut I think you are misusing the concept of \"average\". Your function returns the number of integers between n and m (including n and m), but if n > m, the number of integers between n and m is zero, and the average should be zero.\n\nFor the average of n numbers, the standard way is to calculate the mean of the numbers and then divide the sum of the numbers by the number of numbers.", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    m = 1\n    while n > m:\n        m = m + n\n    return m + ((n%m) ** 2) / (m - n)\n\nSo, given that I'm not going to be doing any more work for a while, I started playing with this (and a couple of other things). The above code gives a \"0b11\" for the above example. If you do a naive implementation of this (in C) using binary_add (and you can see why I called it that, as it is exactly that - add) you get:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    else:\n        return m\n    def round_to_integer(x):\n    \"\"\"Given an integer x, return a floating point number rounded to\n    integer.\n    Return x if x is an integer.\n    If x is too big, return x rounded down to the nearest integer.\n    If x is too small, return x rounded up to the nearest integer.\n    If x is greater than the maximum integer, return -1.\n    Return x rounded up to the nearest integer if x is less than the\n    minimum integer.\n    Return x rounded down to the nearest integer if x is greater than the\n    minimum integer.\n    Example:\n    round_to_integer(0.5) => 0\n    round_to_integer(0.999) => -0.1\n    round_to_integer(10) => 1\n    round_to_integer(11)", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    # n is the sum of all integers\n    n = sum(n)\n    # m is the number of integers in the range [n - 1, n + 1]\n    m = len(n - 1:n + 1)\n    # assume n is positive\n    if n < 0:\n        return -1\n    else:\n        return n\n    # round to the nearest integer\n    return (int(n) - (int(n) * 0b10001 + int(n) * 0b0001)) / 2", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    n, m = int(n), int(m)\n    result = 1\n\n    while n > m:\n         result = result + (m * n)\n\n         if result > 1:\n             return -1\n            return result\n\nI can't quite tell if you're trying to show that you can write a function to do this or not. If so, I'm afraid that you can't.\nThe reason is that you are using integer arithmetic. When you add two integers, the result is an integer. When you multiply an integer by another integer, the result is also an integer. But when you take the average of two integers, the result can be any real number between 0 and 1, not just an integer.\nIf you want to do this, you need to use floating-point arithmetic, not integer arithmetic.\n\nHow about:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return 0b1 << (m - n) + n + (m - n) - 1", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    print n, m\n    print \"Your task is to compute the average of the integers from n through m (including n and m).  Round the answer to the nearest integer and convert that to binary.\"\n    print \"Example:\n            rounded_avg(1, 5) => \"\n    for i in range(n + 1, m):\n          if i >= m:\n                  return -1\n                   print(i)\n                    return i\n    print \"Round the answer to the nearest integer and convert that to binary.\"\n    print \"Example:\n             rounded_avg(7, 5) => -1", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n\nHow would I implement this algorithm in python?</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    for i in range(n):\n        a = a + n\n        if a > m:\n           return a\n        else:\n            return a / 2\n        a = (a / 2) & 0b1\n    return (a & 0b1) + m\n\nDo you know if Python can be compiled to Javascript?</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    n, m = int(n), int(m)\n    if n > m:\n        return -1\n    else:\n        n, m = int(n), int(m)\n        return int(n) + int(m)\n    return int(n) + int(m) * 2", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    else:\n        return (n + m)/2", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    \"\"\"The total number of values that are evenly divisible from n through m is:\n    def n_divisible(n):\n    \"\"\"Return the number of values that are evenly divisible from n through m.\n    Examples:\n    n_divisible(10) => 5\n    n_divisible(11) => 5\n    n_divisible(12) => 5\n    n_divisible(13) => 5\n    \"\"\"\n    return 0 for n in range(n):\n    if n % m == 0:\n        n = n - n / m\n        return n_divisible(n) + m\n    return n_divisible(n)\n    return n\n    return m", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    var a = int(input(\"Enter n: \"))\n    var b = int(input(\"Enter m: \"))\n    for i in range(m):\n        a = a / 2\n        a += b\n        a = a / b\n        return a >> 32 & 0b1\n\nThis is actually quite a good implementation of the average problem. It uses only integer arithmetic and avoids the pitfalls of floating point.\n\nIf you use the following syntax:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    n = n/m\n    m = m/n\n    return round(n+1, m) + round(m+1, n)\n\nI'm sure you can optimize that by using the same logic but without the division.\n\nA classic problem in algorithms is the \"minimum spanning tree\" problem.\nYou have a set of nodes with an edge between each pair of nodes. Your goal is to find the minimum number of edges that will connect every node to every other node.\nIn theory, you could solve this with an O(n2) algorithm, but it turns out there is a simple O(n log n) solution.\n\nI was also thinking about the min spanning tree problem. I have an algorithm for it that I think is O(n). The problem with the problem is that it doesn't make sense to talk about a solution being \"simpler\" or \"more complex\" than another solution, as the problem is inherently uncomputable.\n\nI was wondering about this myself - it's probably a stupid question, but is there a formal proof that such a solution", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return 0b1*(((n+1)*m)**(m+1)/(m-1))\n    + 0b1*((n+1)*n)**(n-1)\nThis is a very neat algorithm, because it's a constant-time worst-case algorithm.  However, in practice it is not particularly efficient.  To see why, let's look at an example.  Let's suppose n=20 and m=2.  Then the algorithm does the following:\n1.  Round to the nearest integer: 20-2 = 18, so 18 is the answer.\n2.  Convert the answer to binary: 18 = 1011\n3.  Multiply the result by 2: 18*2 = 36\n4.  Add the result to the accumulator: 36 = 1011 + 1011\n5.  Compare with n: 36 > 20, so return -1\nThe total time for this algorithm is the time to do the addition in step 4, plus the time to do the comparison in step 5.  For n=20, that's about 1.5 microseconds.  You can do much better.  Here is a", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (-1 * n + m) % m\n\nThis implementation is not correct. The average of (1, 5) is not 0b11; it's 0b10.\nThis is because (1, 5) is an integer, and the average of two integers is an integer, too.\n\nIt's correct:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (n / m) & 0xffff\n\nOne could read the Python 3 version:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return (m+n)/2.0 + (-n)/2.0", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return n * m + 1\nThis is a nice example of a function that looks the same at first glance, but is actually subtly different.\nn * m + 1 == n + m * n\nn * m + 1 == (n + m) * n\nn * m + 1 == n * (n + m)\nn * m + 1 == n * m + n * m\nIt is easy to see that the last two cases are the same, but the first two cases are different.\n\nI don't know what you mean by'subtly different', but the naive version will sometimes be wrong and the version with explicit operations will always be right.\n\nI think the difference is subtle because both versions compute the same result when n = m.\n\nHow many of these are in the standard library, and how many are in the C99 library?\n\nI'm curious about the following one:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n == m:\n       return -1\n    else:\n       return n / m + 1\n\nThere's a typo:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    k = 2**(n + m)\n    n = m = 0\n    while n > k:\n        n = n - k\n        m = m + k\n    return n\n\nIn this case, the fact that n is at least k isn't important and is a\nwaste of memory.\n\na = 1\nwhile a < 2**32:\na = a + 1\nreturn a\n\nActually, this will create the following output:\n0 1\n2 2\n4 4\n8 8\n16 16\n32 32\n64 64\n128 128\n256 256\n512 512\n1024 1024\n\nThe problem is that this is not the intended result.  The reason for\nthis is that the intermediate result of a += 1 is not being saved.  In\nthis case, the intermediate result is 2.  This is not saved.  The result\nis that the final answer is doubled each time it is computed.\n\nThe solution to this problem is to use the following:\n\na = 1\nwhile a < 2**32:\na += 1", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    a = (1 << n) + (1 << m)\n    if n > m:\n        return -1\n    return a >> 1 & 1\n\nIf you're looking for a way to return a decimal, you could instead use:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return [n for n in range(n) for i in range(m)]\n\nI would have written it differently, but only because I don't know the array module.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    n = int(n)\n    m = int(m)\n    total = 0\n    while m!= n:\n        if n > m:\n            return -1\n         total += n\n        n = int(n)\n    return total & 0xFF\n\nNot to be too picky, but you've got a typo in your code (you're trying to do integer division on a float).\n\nYeah, I noticed that. I am going to see if I can correct it without making the code more difficult to understand.</s>", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return floor(n * m) & floor(n - m)\n\nreturn int(rounded_avg(n, m))", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    # This is for a for loop to set up the initial values\n    for n in range(1, 10):\n        n_sub = n - 1\n        m_sub = m - 1\n        rounded_avg(n, m_sub) = -1\n\n    # This is to loop over the loop over the numbers in the array\n    for i in range(n_sub, m_sub + 1):\n        value = n\n        if value > m:\n           value = -1\n           rounded_avg(n, m_sub + i) = value\n    return rounded_avg\n\nOutput:\n0b11\n0b0111\n0b0011\n\nI don't get it?\n\nIn the simplest form (in your case), this code just returns the sum of the range of numbers plus 1.\nExample: 1, 5, -1, -1", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return floor(n / m, 2)\n\n>>> print(rounded_avg(1, 5))\n    0b11\n>>> print(rounded_avg(7, 5))\n    -1\n>>> print(rounded_avg(10, 20))\n    0b1111\n>>> print(rounded_avg(20, 33))\n    0b11010", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    average = sum(n) / sum(m)\n    return binary(int(round(average, 0)) << 8)\n\nWhen I first saw this, I thought, \"You're in a for loop, so you can just use the modulo operator.\" But then I realized the coolness of the rest of this function. Neat.\n\nYes, I thought of that too. But then I thought to myself \"what if I wanted to do something like this in C?\" And then the rest of the function was born.\n\nThe description for the function is a bit weird. I'd put it like this:", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    a = round(n, m)\n    b = round(a, 2)\n    return b\n    if __name__ == \"__main__\":\n        print rounded_avg(1, 5)\n        print rounded_avg(7, 5)\n        print rounded_avg(10, 20)\n        print rounded_avg(20, 33)\n        print rounded_avg(30, 5)\n\n1\n\n2\n\n3\n\n4\n\n5\n\n6\n\n7\n\n8\n\n9\n\n10\n\n11\n\n12\n\n13\n\n14\n\n15\n\n16\n\n17\n\n18\n\n19\n\n20\n\n21\n\n22\n\n23\n\n24\n\n25\n\n26\n\n27\n\n28\n\n29\n\n30\n\n31\n\n32\n\n33\n\n34", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    # round\n    if n < m:\n       return 0\n    # if n is greater than m, return -1\n    if n > m:\n       return -1\n    # if n and m are the same, return 0\n    if m == n:\n       return 0\n    # if n is negative, round to the nearest even integer\n    if n < 0:\n       return 0\n    # return 1 if n is 0\n    if n == 0:\n       return 1\n    # convert to binary\n    b = int(floor(n / m))\n    a = int(floor(n / m))\n    c = b * (a + b)\n    d = -b\n    return (d >> 4) + (c & 0b1) + (d & 0b1) + a + b\n\nI've done better.", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    if n > m:\n        return -1\n    else:\n        return (n - m) / 2\n\nIt looks like the author was inspired by Perl's `round`.\n\nThere's a lot of little things like that that I really like in Python. It's really nice to be able to say \"I want to do this thing in X way\" and have it work the same way every time.\n\nThat's a really good point, and another Python feature I love.\n\nSo here's a stupid question: why not just add a '+' operator? I feel like it would be a lot less confusing to anyone coming from C/C++/Java/whatever, and it's a feature I've always wanted in Python.\n\nTwo reasons:\n1\\. The + operator in C and C++ is overloaded to do all sorts of things, including addition, string concatenation, and pointer dereferencing. Having the same operator be used for addition and string concatenation would be confusing.\n2\\. The way that operators are overloaded in Python makes it difficult to overload + to do addition (as the author", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    m = 0\n    while m < n:\n        i = n - m\n        m = m + i\n    return i", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    n = 0\n    while n <= m:\n        if n > m:\n            return -1\n           n = n / 2\n          m = n / 2\n           rounded_avg(n / m, m)\n    return n\n    return 0", "def rounded_avg(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    rounded_avg(1, 5) => \"0b11\"\n    rounded_avg(7, 5) => -1\n    rounded_avg(10, 20) => \"0b1111\"\n    rounded_avg(20, 33) => \"0b11010\"\n    \"\"\" \"\"\"\n    return [((int(n) * m) + (int(n) / 2)) % m for n in range(m)]\nI don't get what this is trying to do. It seems like it is trying to sum the numbers from 1 to m (not inclusive of m), and then if n is greater than m then return -1. But that is not what it says.\n\nIt is trying to compute the average of the numbers from 1 to m, rounding the answer and converting it to binary.\nSee http://en.wikipedia.org/wiki/Rounding_error\n\nI got that, but what does\n((int(n) * m) + (int(n) / 2)) % m for n in range(m)]\nmean? If it means what I think it means, then the correct answer is -1.\n\nOh, I think I understand what you mean. I think it means to find a number X such that\nX = ((int(n) * m) + (int(n) / 2)) % m for n in range(m)]\nIf so, then the correct answer is X if n is greater than m.\nIn other words"]]