[["def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    for i in range(xs.size):\n        return xs[i].dot(xs[0])\nWell, well, well. The derivative of the list of coefficients is the sum of the products of the coefficients (and the unit) of the original polynomial.\nThis is equivalent to the fact that the derivative of a polynomial is the antiderivative of its derivative (exponentiation by the derivative is the same as differentiation).\n\nP.S. The same holds for products of polynomials, the derivative of a product is the sum of the derivatives of the product terms.\n\n\"Derivative\" is such a fun word...\n\nI agree, which is why I decided to use it! :)\n\nI was wondering why this was on the front page. But then I thought, if I could write an article that explained the derivative in one line, it'd probably be pretty popular too.\n\nHe just posted it - we're just upvoting a cool concept, not the actual implementation.\n\nNo, we're upvoting a guy who knows how to write a blog post that explains a concept well.\n\nIn", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return (xs.index + 1) * xs[-2:]\n\nThe point is that the right side of your function is xs[-1]. Indexing starts at 0, and you subtract 1, so it's actually xs[-2].\n\nYes, you're right. I've corrected it in the post. Thanks.\n\nIt's a nice article.\nHowever, some people would rather see a link to the article than an image of it.\n\nThanks, I've added a link to the post.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [x * x for x in xs if x > 0]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    var answer = []\n    for co in xs:\n       answer.append(co)\n    return [answer[0] * x + answer[1] * x^2 +....]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n        return list(\n           list(xs[0], xs[1], xs[2], xs[3], xs[4],\n              xs[5]*xs[6])\n    )\nI appreciate the brevity of the solution, but you can't do much with this approach.\nI think a more useful solution would be:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [x.to_s.ljust(0, 1) for x in xs]\nThat's not as terse as one could get, since your code doesn't use any numpy arrays, but it's pretty much the best you can do in pure Python.\n\nThat's not the best you can do in pure python. It's the best you can do in pure python if you want to emulate numpy. There's a lot of stuff you can do in pure python that you can't do in numpy.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if not isinstance(xs, list):\n        raise ValueError('Derivative takes a list of coefficients')\n    return (x**2 for x in xs)\nThe definition is valid for lists, tuples, and other types with a list-like interface.\n\nIt is worth noting that this is _not_ a pure python definition. The change to the language was to add a \"derivative\" function that could be used in a function with a certain signature, and that function would return a value which is a new datatype in python. In fact, this datatype is an instance of the algebraic datatype class, which is not part of the python language at all, but is a module that is imported by default when you import the \"base\" module.\nI thought that the best way to understand this new feature was to understand the \"derivative\" function, and so I rewrote it in a pure python style. This is the essence of the change to the language. The other parts of the change to the language are mostly minor cleanups to the error messages that you will get if you are not careful.\n\nFrom", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if len(xs) == 1:\n        return 0\n    else:\n        return list(x**(1/xs[i]))\nYou can use a lambda function for the latter one:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [int(x) for x in xs]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    \"\"\" if xs == [] : return None\n    xs_, xs_end = [], None\n    for x in xs:\n        if x not in xs_:\n           xs_, xs_end = [x], None\n         else:\n                     xs_, xs_end = xs_, xs_end + x\n    return derivative(xs_)\nI find it strange that this is getting so much attention. In my opinion this is not a useful way to compute the derivative of a function, and it is almost certainly not the best way to do it.\nWhat is missing is a _formal definition_ of a derivative. In a language like Haskell, I would define a derivative as a function from a function to a function, and provide a means of computing it (like the solution shown here). But in Python, where you have no anonymous functions, you can't just write something like this:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return ((xs[0] + xs[1] * x) ** 2) + (xs[2] * x^2) +...\n    + (xs[n] * x^n)\n\nI think you mean the derivative of a _function_, not of a _polynomial_ :\n>>> derivative([1, 2, 3])\n[2, 6]\n\nYes, and this is why I'm a programmer and not a mathematician.\n\nI'd have more respect for programmers who are aware of their limitations rather than those who pretend to be experts in fields that are outside of their expertise.\n\nI think it is also important to recognize the limits of one's own expertise. I've been programming since I was 10 (over 20 years), and I still don't feel like I know enough to make any significant contributions to mathematics (I have a B.S. in Applied Math, but my primary focus was in the software-side of things).\n\nThe most amazing thing about that to me is that you can learn a significant amount of applied math without learning math that's used in programming. But of course, you can only learn a fraction of all math.", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return map(lambdax: xs[x], [0], lambda x: x * x, lambda x: x^2 * x^2,....)", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return (xs[2], xs[4] * x - xs[6] * x^2) / (xs[0] * x + xs[1] * x^2 +....)", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return map(lambda x: x[0], xs)\nwhile I like your solution, this is not what he is asking for.  He is asking for a function that will return the derivative of a list (a linear combination of functions).</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n\nx = list(zip(xs, xs) for x in xs)\n    derivative_of = []\n    while len(x) > 0:\n        derivative_of.append(x[0] - derivative(x[1]))\n        derivative_of.append(x[1] - derivative(x[2]))\n        derivative_of.append(x[2] - derivative(x[3]))\n        derivative_of.append(x[3] - derivative(x[4]))\n        derivative_of.append(x[4] - derivative(x[5]))\n        derivative_of.append(x[5] - derivative(x[6]))\n\nreturn derivative_of\n\nFor example,  gives\n\n>>> derivative([3, 1, 2, 4, 5])\n[1, 4, 12, 20]\n>>> derivative([1, 2, 3])\n[2, 6]\n>>> derivative([1,", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return (xs[1] * x + xs[2] * x^2) / xs[0]\nThis is very cool, but it's not a very general form of derivative. You could add this code to the function:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return sum(xs * xs) / sum(xs + 1)\nIt's funny that the default python implementation of `sum` takes a function and calls it, but this example takes a function and calls the result.  Very \"pythonic\".\n\nThat is the fastest implementation for most languages. \"normal\" sum is only useful if you need the sum of a lot of values, then the look-up penalty can be a lot.\n\nI believe the \"normal\" sum (i.e., (a + b) +...) is much faster than the \"normal\" product (i.e., (a * b) *...). The \"product\" is a tuple with size (a + 1) * (a + 1) *..., which, for n elements, is the same as a list with size n + 1. The \"sum\" uses two pointers for the sum, so it needs 2 * log(n) + (a + 1) * (a + 1) *... + n.\n\nAssuming you use a tree for the sum, yes.\nYou can't do the same for the product, since you need to do some lookups.\n\nI don't", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return derivative(xs)\nThere is a library that does this (and much more) for you:\n\nThis would be a great place to learn about list comprehensions.\n\nThat's basically what a list comprehension is, you're just not being lazy about it.\n\nThanks.\n\n_derivative_ is a word with a known meaning. The proper name for this method should be something like _partial_derivative_ or _numerical_derivative_ or _simplified_derivative_ or _derivative_in_differential_equations_\n\nThat's a good point. It is based off of the algorithm from here:\nwhich is called the _numerical_derivative_. It was meant to be a simplified version of that. I will see if I can make it more clear.\n\nI thought the algorithm was called _numerical_ differentiation, not derivative.\n\nYou are correct. I am fixing that.\n\nWhat's the point of this? What does it do that normal Python lists and the built-in functions don't?\n\nIt solves some common problems with polynomial and rational functions (the naive", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n\n    return derivative(xs[0]*xs[1] + xs[2]*xs[3] + xs[4]*xs[5])\n\n    def derivative(f: float, xs: list):\n    \"\"\" f: floating-point function.\n    xs: list of coefficients.\n    Return derivative of this polynomial.\n    >>> derivative([3, 1, 2, 4, 5], [1, 2, 3])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3], [1, 2, 3])\n    [2, 6]\n    >>> derivative([1, 2, 3], [1, 2, 3], [1, 2, 3])\n    [4, 12, 20]\n    \"\"\"\n\n    return derivative(f*xs, xs)\n\n    def derivative(f: float, xs: list):\n    \"\"\" f: floating-point function.\n    xs: list of coefficients.\n    Return", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return {'x': xs[0] + xs[1] * x + xs[2] * x^2 +....,\n    'y': xs[0] * x + xs[2] * x^2 +....,\n    'z': xs[0] * x + xs[1] * x^2 +....,\n    'w': xs[0] * x + xs[1] * x^2 +....}\n\nThis is not at all Pythonic. You have to break the \"decorator\" into multiple lines, and the function body is more verbose than it needs to be.", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    # Get the coefficients as a list of tuples\n    # tuples of (x,y,x^2,...)\n    cur_coefficients = []\n    for x in xs:\n       cur_coefficients.append((x,0,x))\n    return tuple(cur_coefficients)", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    xs = [x for x in xs]\n    xs[-1] = 0\n    xs = xs.split()\n    i = xs.index(0)\n    xs = []\n    while i!= len(xs):\n        xs = xs.pop()\n        xs = xs.pop()\n        xs = xs.pop()\n        xs = xs.pop()\n    return [x*x for x in xs if x**2 == x]\nThis is the correct approach, but keep in mind that you're going to be slow if you do this in a loop over all the coefficients of a polynomial with a lot of coefficients. I've had better luck with Cython, which has some good implementation of eigenvectors and eigenvalues.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if xs[0] == 1:\n        return xs[1]\n    return derivative(xs[1:])\nThis is incorrect.  It will always return a 0 when it should be returning a function which returns a 0.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n         for x in xs:\n             xs[0] * xs[1] * derivative(xs[0])\n    return xs[0] * xs[1] * derivative(xs[1])\n\nI was just thinking about this the other day. There are two simple things that make this code work. First, you need to have a list, and not an array, because the for-loop operates on the list, not the elements. Second, you need to keep track of xs[0] and xs[1] because the for-loop operates on the pair of elements that are currently being iterated.\nIt's interesting that these two things are necessary to get the effect that is so natural to the human mind.\n\nHow does one get this to work with an array? I can see how to do it with a generator, but I can't figure out how to do it with an array. I can see how to do it with a list (this is equivalent to the way the function works), but I can't figure out how to do it with an array.\n\nI", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [x*x for x in xs if x!= 0]\nIt's not that it's too hard to implement it, it's that the following is much easier to write, read and maintain, and doesn't need to be rewritten if any of the subexpressions change:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return sum([(x - xs[0]) * x for x in xs])\nCan't use this one for differentiating partial derivatives.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if len(xs) == 1:\n        return xs\n    else:\n        return xs.difference(xs[0], xs[1])\n    \"\"\"\n\nOk, so now you can compute the derivative of an entire function. What about partial derivatives?", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n\n    return (xs.count(x) - 1) * derivative(xs[0] * x + xs[1] * x^2 +...)\n\n    def sub_product(x, y, z):\n    \"\"\" Return result of sub-product of x, y and z.\n    >>> sub_product(3, 2, -3)\n    [0, -1]\n    >>> sub_product([2, 2, 2])\n    [0, 1]\n    \"\"\"\n    return (x[0] * y[0]) + (x[1] * y[1]) + (x[2] * y[2]) + (x[3] * y[3])", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs[0] * xs[1] * xs[2] *... * xs[N] / xs[N-1]\nNot sure I understand.  How is the return value a derivative?  It looks like it's just the sum of all of the terms.\nI think it's meant to be a derivative of the equation, not the polynomial.\nAh, you're right, I guess I was reading it wrong.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n\nSee also\n\nfrob\n\nReferences\n\nExternal links\n\n Frob at the Python Wiki</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n        xs.sort()\n        return xs[1] * x + xs[2] * x^2 +....\n\n>>> derivative([3, 1, 2, 4, 5])\n[1, 4, 12, 20]\n>>> derivative([1, 2, 3])\n[2, 6]\n>>> derivative([1, 2, 3, 4, 5])\nTraceback (most recent call last):\nFile \"./a.py\", line 8, in <module>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return (xs[0]*xs[1]*x + xs[2]*xs[3]*x^2 +....)\n\nI think this is the correct solution, but I'm not sure if this is the best one. I like the \"minimal example\" approach of the xs.sum() approach.\n\nMaybe this is a dumb question, but what is a \"derivative\"?\n\nThe derivative is the slope of the line that connects points on a graph.\nFor example, the graph of 3x^2:\nis the line that connects the points (0,3) and (6,3). The slope is 3/2.\n\nWow, that was a very quick and informative reply. Thanks!\n\nI'll give you a hint. Think about what is the derivative of x^2 + x.\nIf you don't know calculus, just guess. I won't tell you if you are right or wrong.\n\nI'm assuming that is something with xs[3]...?</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if len(xs) == 0:\n        raise ValueError(\"Derivative of a polynomial must have one or more coefficients\")\n    else:\n        return [x * x * x + x * x^2 +... + x * x^(n-1)]\nYou can probably trim that down further by using a list comprehension and looping over a list of coefficients.\nAnother way would be to use a matrix. If you're interested, I can show you how to get the determinant of a polynomial using matrices.\nI'd like to see that.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 +....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    return xs[0] + xs[1] * x + xs[2] * x^2 +....", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n\n    return diff(xs, xs[0])\nI think it is easier to understand with this one:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return (x + 1) * x + x * x^2 +...\n\nThis is correct and idiomatic code.\n\nIt is indeed idiomatic, but I think it's not correct. I can't make it work for any polynomial, but maybe I'm missing something.\n\nIt's correct. The problem is that the derivative of a constant function is always 0.\nThis is easily fixed by replacing the return statement with an if statement that checks the derivative to be non-zero.\n\nI thought the OP was looking for the derivative of a polynomial, but you're right, a constant function is definitely a polynomial.\n\nWhile not idiomatic, you can use the Chain rule to rewrite your derivative method (for arbitrary polynomials)", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n\n    return sum(xs.map(x => x*x))", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    def polynomial(n, xs: list):\n    \"\"\" Return a list of xs.\n    >>> polynomial([5])\n    [5, 1, 9, 16, 25]\n    >>> polynomial([3, 4, 9, 7, 11, 19, 8, 1])\n    [3, 4, 9, 7, 11, 19, 8, 1, 1, 3, 6, 16, 25]\n    >>> polynomial([3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3])\n    [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3]\n    >>> polynomial([5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19])\n    [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    for k in xs:\n        for c in xs[k] * x:\n            return [c, 1 / (c^2)]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n\n    if len(xs) == 1:\n       return xs[0]\n    else:\n       return []\n\nThat's a perfect example of the \"idiom\" you were referring to, but I wouldn't consider it to be any more idiomatic than your version.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    p = xs.pop()\n    p_dist = []\n    for i in xs:\n        p_dist.append(p[0])\n    return p_dist\nThe author apparently has a problem with lists and arrays, so he keeps writing this kind of code.\n\nYeah, I found that a bit strange as well. I guess in a strict functional language, where you can't change lists, you can't have a function that accepts a list and returns a list.\n\nNot sure what this has to do with strictness? At least in Scheme you can do this:\n(define (f x)\n(list-ref (lambda (y) (f (cdr y))))\nx)\n\nNot quite. The return type of the function is '(lambda (y) (f (cdr y))), but the actual return value of the function is '(lambda (y) x). The former isn't a list.\nIn fact, it's even worse than that. If f is given a list and returns a list, it's possible that the returned list will be a proper list. That is, it", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return (xs[1] + xs[2] * x + xs[3] * x^2 +... * xs[x])[0]\n    #\n    def derivative(xs: list, xs[0] = 1):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 +....\n    Return derivative of this polynomial with xs[0] = 1.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    >>> derivative([1, 2, 3], xs[0] = 1)\n    [2, 6]\n    \"\"\"\n    return (xs[1] + xs[2] * x + xs[3] * x^2 +... * xs[1])[0]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    print \"Derivative of: %s\" % xs\n    return (x - xs[0]) * xs[1] * xs[2] *... * xs[n]\n...\nThere's a simple implementation of this using numpy's built in derivative\nfunction on your example.\n>>> import numpy\n>>> x = [3, 1, 2, 4, 5]\n>>> y = [2, 6]\n>>> d = numpy.diff(x, y)\n>>> print d\n[1, 4, 12, 20]\n>>> print d.derivative([3, 1, 2, 4, 5])\n[1, 4, 12, 20]\n\nNot sure what point you are trying to make. You can make a function\ngenerate its own documentation easily in any language.\nThe point of the post is that python documentation is pretty good.\n\nOh I agree, I just hate the \"not x, but here's a quick hack in y\nthat generates the same result\" line of reasoning.\n\nI'm not sure you understood the example. The two examples were not equal.\n\nHe said they", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    xs = np.array(xs)\n    xs = np.expand_dims(xs, axis=1)\n    if len(xs) == 1:\n       return 1.0\n    else:\n       return (1.0 - (1.0 * xs[0] * xs[1] * xs[2] *... * xs[x].T)) /\n       (1.0 * xs[0] * xs[1] * xs[2] *... * xs[x].T)\n    return xs", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return (\n             xs[i] * xs[i+1] + xs[i+2] * xs[i+3] +...", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    ds: dict = {\n        [0] = [1, 0, -1],\n        [1] = [0, 0, 1],\n        [2] = [1, 1, 2],\n        [3] = [0, 0, -2]\n       }\n    return [xs[0] + ds[0][1]*xs[1] + ds[1] * xs[2]*xs[3] +... for ds in ds]\nIsn't that a sum instead of a derivative?\n\nJust because the definition is not the most elegant, doesn't mean it's wrong. The first example is a simple derivative, the second is a sum.\n\nI'm not sure about that.\nFirst, you can't really replace '*' with '.' and call it'simple derivative'. You will get different results in different contexts.\nSecond, it's not a derivative if it doesn't apply to all the arguments. I.e.\n>>> derivative([1,", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [xs[0], xs[1] * x + xs[2] * x^2 +....]\n\nThere is something very wrong with this code.\n[1, 2, 3] => [2, 6]\nIt should be [1, 4, 12].\n\nI think the problem is the python interpreter. It evaluates the derivative for the first term as [1, 2] * x + [2, 6] * x^2 +...., and the second term as [1, 2] * x + [2] * x^2 +....\nThe second term will be evaluated as [1] * x + [2] * x^2.\n\nyes, that's how the python interpreter handles the \"+\". It works fine with multiplication, though.\n\nHere's another way to do this, using the transform function. It also uses list comprehension to avoid unnecessary calls to python's eval:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    # initialize a new object of type 'list'\n    xs = [1, 2, 3]\n    # loop over all coefficients of xs\n    for c in xs:\n        # get next coefficient\n        c = xs[c]\n        # get current value of derivative\n        derivative = 0\n        # calculate a derivative\n        derivative += c * x\n        # convert back to a list\n        return xs[c] + xs[1] * derivative + xs[2] * derivative^2 +....\n\nThe code does not actually return the derivative of x, it returns the list of coefficients of the polynomial f(x) evaluated at x.\n\nThe implementation of the derivative in the Python language is called the \"numerical differentiation\" algorithm.\n\nPython supports the derivative operator, which can be used to calculate the derivative of a function:\n\n    def foo(", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return sum(map(x, xs))\nThis is incorrect. You are probably returning the product of the derivative and x. The actual answer is:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs.pow(x)\nDoesn't that require the user to know the form of the function though?  I would make a guess that a lot of people would define the function as xs = {1, 2, 3, 4, 5} and then would get a different answer.\nWell, you could do something like this:       def derivative(xs):             return lambda x: sum(x, x**2).\nYea, the other guy posted the same.  Is this a convention in Python?  I have always just used the pow method.\nPython uses a lot of functional programming techniques.  I've seen the lambda trick in Python before.  Another common one is:       def derivative(xs):             return x**2  It's cleaner than the pow method, because you can define derivatives in terms of other derivatives, and so forth.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return (y for y in xs if y / xs[1] == 0) * (y for y in xs if y / xs[2] == 0)\nCan someone explain why this works?\n\nThe derivative of a function of the form y = f(x) is given by the limit as x approaches 0 of f'(x)/f(x). In other words, it's the derivative of f(x) with respect to x.\nIf you take derivatives of the polynomial in the parent comment, you'll find that they are all functions of x. So if you apply them to x, you get the derivative of f(x).\n\nNo, it's just a polynomial in x that can be expanded in terms of the basic functions, which makes the function in the parent comment a polynomial in x with coefficients in the basic functions.\n\nYou are both right!\n\nThis is also available as a package, numpy.poly (not sure if it's the same version).\n\nIt is the same package.\n\nI had a small complaint about this... you can use the built in f'(x)/f(x) to", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs[:-1].reduce(x.power, x.power)\nWhat do you think about this approach?\n\nThat's the first function that shows up if you Google \"derivative python\"</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if xs is None:\n        return (None, None, None, None)\n    xs = [x for x in xrange(len(xs) - 1)]\n    return [0 for x in xs if x in xs[1:] else 1]\n\nI'd prefer to write this as:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return ((xs[0] + xs[1] * x + xs[2] * x^2 +....) / (xs.length - 1)) * x", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if len(xs) == 1:\n        return 1\n    else:\n        return xs[0] + xs[1] * x + xs[2] * x^2 +....", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [list(xs[i] - xs[i-1] / xs[i-1] * xs[i-2]) for i in range(len(xs) - 1)]\n[1, 4, 12, 20]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    # note this is a list, not a tuple\n    return list(xs.dots(0), xs.dots(1))\nTo be honest, I think that code is a mess.  It could be so much cleaner.    I think  the code in this thread is cleaner, simpler, and more readable.    What do you think?</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    # We will create a polynomial with the same coefficients but with\n    # a different constant.\n    po = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]\n    # Now add this new polynomial to the list of coefficients.\n    xs = [x for x in po]\n    return [x for x in xs]\nThis algorithm produces the derivative of the polynomial of order n, but produces a polynomial of order n+1. I would expect the derivative of a polynomial to be a polynomial of order n.\n\nThe _definition_ of a derivative is the function that maps x to the derivative of x^n. The method to compute it is the method described in the comment above.\n\nSo, it is not an approximation, but is the function itself. The only reason you don't expect it to be a polyn", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs[0] * xs[1] * xs[2] * xs[3] * xs[4] * xs[5] * xs[6] * xs[7] * xs[8] * xs[9] * xs[10] * xs[11] * xs[12] * xs[13] * xs[14] * xs[15] * xs[16] * xs[17] * xs[18] * xs[19] * xs[20] * xs[21] * xs[22] * xs[23] * xs[24] * xs[25] * xs[26] * xs[27] * xs[28] * xs[29] * xs[30] * xs[31] * xs[32] * xs[33] * xs[34] * xs[35] * xs[36] * xs[37] * xs[38] * xs[39] * xs[40] * xs[41]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [x.t**2 for x in xs]\nThanks for that, but I'm more confused now!  Is there a link to a description/tutorial or something?  Edit: Ohhh, I see... you've made your own function that does what I did in the OP.  Thanks for the help!</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if xs.size == 1:\n        return xs[0]\n    else:\n        # Add the list of coefficients in a loop.\n        for i in xs:\n           xs[i] = xs[i - 1] * xs[i - 2] + xs[i - 3] * xs[i - 4] +....\n    return derivative(xs)\n\nAs an exercise, try to write this function in Python.\n\nHow would you do that? You'd have to know the types of each of the\noperations on the list, which would be the same as knowing the types of\nthe variables, and for the sake of the exercise it's fine to assume that\nthe variables are numbers. So the result of each operation could be a\nnumber, a list, or a tuple of numbers.\n\nYou could try to figure it out by writing a program and running it, but\nyou would need to write a program that accepts either a function to\nderivative a list of", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    x = 0\n    y = xs.pop(0)\n    return sum(exp(x), exp(y))\n\nx = 1\ny = 2\nd = derivative([x, y])", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if xs is None:\n        print(\"Derivative of empty list is: \")\n        print(None)\n    return xs\nNot sure about python, but that's probably not the most efficient way to implement it.\n\nA list of integers is not the same as a polynomial.\n\nNot quite sure how you've come to that conclusion. It works fine for integers.\n\nIndeed, you can use the method for rational numbers.\n\nI think you misunderstand how the real numbers work. A polynomial has a real and an integer component (or it's a constant). The expression x^2 has both an integer and a real component, as does 3.\n\nAn excellent introduction to machine learning.\n\nThere is no section about ML in this book. This is a very good introduction to the mathematics of mathematical finance though.\n\nI love the exercise questions at the end of the chapters. Helps keep things interesting.\n\n_\"It is a very good book, but it is not a book for the layman. You have to have a solid background in linear algebra, calculus, and real", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if len(xs) == 0:\n         return None\n    return xs", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return list(xs.map(lambda x: x.__getitem__))\nPretty, but not very useful. You probably want a list of lists, not a single list of tuples.\n\nI see. My initial reaction to the article was \"doh! that's obvious\". But then I thought perhaps it wasn't so obvious to other people.\n\nI guess I've never really had to do polynomial division, so I don't find it obvious that that's the right approach.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return sum(xs) / sum(axis([0]))\n\nfurther reading:\n\nI'm not sure I get it.\nSo you're using a list comprehension to parse a list, then you use a for loop to sum each element in the list. What's the point?\n\nIt's a way to easily compute the derivative of an arbitrary function without having to write a custom function.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if len(xs) > 1:\n        xs = list(zip(xs, xs))\n    else:\n        xs = np.array(xs)\n    if xs is None:\n        raise ValueError(\"Please provide a polynomial\")\n    return [x**2 for x in xs]\nYou need to add a comment, e.g.", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return math.sqrt( (xs[0]*xs[1] + xs[2]*xs[2] +... + xs[x]*xs[x] ) /\n    xs.size() )\n\nJust a quick note that I believe this is a quadratic polynomial, so sqrt(x) is a valid derivative.\n\nAh yes. In that case it's also true for x^2\n\nThis is sort of a trick answer. The derivative of the polynomial f(x) = ax^2 + bx + c is given by the formula\nf'(x) = f(x - a)^2 + f(x - b) + f(x - c)\n(you can verify this by plugging in values for a, b, and c to get a polynomial with that form and then doing the usual derivative trick).\nThe derivative of f(x) = x^2 + 1 is not f(x - x^2), because f(x - x^2) is not a polynomial with this form.\n\nThis is an answer to a different question - the", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    # simple function that returns the derivative of the argument\n    def derivative_of(self, xs):\n    return (xs[-1]+xs[-2]+xs[-3]+xs[-4]+xs[-5])/2", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    def derivative(xs: list):\n    \"\"\" Find the derivative of the given polynomial\n    >>> derivative([x, y, z, 2x, 3y, 4z])\n    [2x, 2y, 3z]\n    \"\"\"\n    y, z, xs = xs.split()\n    xs[0] = x\n    return xs[0] + xs[1] * x + xs[2] * x^2 +....\n    + xs[-1] * x^(2-1) + xs[-2] * x^(2-2) +...\n    + xs[-n] * x^(n-1) + xs[-n+1] * x^(n+1)\n\nYes, that's it!\nI would have never come up with that myself, thanks for the help. :)</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    for i in range(len(xs)):\n        if not isinstance(xs[i], int):\n           raise ValueError(\"%s(): invalid arguments to %s\" %", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [xs[i] * (1-xs[i]) + xs[i] * (xs[i-1] + xs[i+1] * x)]\n    [i]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    d = 0.\n    d += derivative(xs)\n    return d", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n\n    return xs[0] + xs[1] * x + xs[2] * x^2 +...\n   .astype(xs[0])\n\nThis will also work for polynomials of a different degree.\n\nfrom __future__ import absolute_import, division\nfrom __future__ import unicode_literals", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if xs.count() == 1:\n        return xs[0]\n    else:\n        return (xs[0] * x)\n    #\n    def find(x: list):\n    \"\"\"\n    Return first element in the list that satisfies the test.\n    >>> find([1, 2, 3, 4])\n    3\n    >>> find([1, 2, 3, 4, 5])\n    5\n    >>> find([1, 2, 3, 4, 5, 6])\n    5\n    \"\"\"\n    if x.count() == 1:\n        return x\n    else:\n        return (x.count() - 1) > 0\n    #\n    def find_all(x: list):\n    \"\"\"\n    Return all elements in the list that satisfy the test.\n    >>> find_all([1, 2, 3", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return (xs[1]-xs[0]) * (xs[2]-xs[0]) * (xs[3]-xs[0]) * (xs[4]-xs[0]) *... * xs[-1]\n\n    def integral(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 +....\n    Return integral of this polynomial in the same form.\n    >>> integral([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> integral([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    return (xs[1]-xs[0]) * (xs[2]-xs[0]) * (xs[3]-xs[0]) * (xs[4]-xs[0]) *... * xs[-1]\n\n    def different_derivative(xs: list):\n    \"\"\" xs", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n\nThis is a rather terrible example, but it shows how it works.\n\nIf you want to find the derivative of a polynomial, you can use the\npolynomial's coefficients. For example, the derivative of the\npolynomial x2 + x is\nx2 + (1/x)\nbecause the coefficient of x is 1.\n\nOn the other hand, if you want to find the derivative of a function\nf, you have to deal with that function's domain. For example, the\nderivative of the function\nf(x) = (x + 1)/2\nis\n(x + 1)/2 - x\nbecause the domain of the function is the set of all numbers.\n\nDerivatives are functions, not numbers. That's the reason for the", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if len(xs) > 1:\n        return xs[0]\n    return derivative(xs[1:])\n\nIn Ruby, a more idiomatic translation is as follows:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs[1:].partial(0, xs[2:])\nThe Python version of this is much more readable:\n>>> from __future__ import print_function\n>>> def derivative(xs):\n...    return xs[1:].partial(0, xs[2:])\n>>> derivative([3, 1, 2, 4, 5])\n[1, 4, 12, 20]\n>>> derivative([1, 2, 3])\n[2, 6]\n\nGreat that Python supports higher-order functions.\n\nAgreed, but this is a pretty low-level example; I wouldn't use this particular construct in a larger piece of code.\n\nA few things:\n(a) I'm surprised that \"no one\" has thought of something like this. I don't mean to imply that OP is the first or only person, but I would have expected to see at least a couple of references to this idea in the history of the world.\n(b) I'm surprised that mathematicians don't use something like this more often. I understand that Matlab is popular, and that Matlab supports this kind of thing. But still, I can", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [x for x in xs if (abs(abs(x) - y) > abs(x))]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n\n    return[x/(xs[0] + xs[1] * x + xs[2] * x^2 +....)]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n        def derivative(xs):\n          \"\"\" Compute derivative of a list of coefficients, in the same form.\n    \"\"\"\n           return xs[0] * xs[1] * xs[2] * xs[3] * xs[4] * xs[5] * xs[6] * xs[7] * xs[8] * xs[9] * xs[10] * xs[11] * xs[12] * xs[13] * xs[14] * xs[15] * xs[16] * xs[17] * xs[18] * xs[19] * xs[20] * xs[21] * xs[22] * xs[23] * xs[24] * xs[25] * xs[26] * xs[27] * xs[28] * xs[29] * xs[30] * xs[31] * xs[32] * xs[", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return (xs[1] + xs[2] * x + xs[3] * x^2 + xs[4] * x^3 +...)\n    ** 2", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [xs[-1]]*(1-xs[-1])**2+xs[-2]*(1-xs[-2])**2+.....*xs[-n-1]*(1-xs[-n-1])**2+xs[n-1]*(1-xs[n-1])**2", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n\n    \"\"\"\n    if xs is not None:\n        # Initialize derivative to (xs[0], xs[1])\n    derivative(xs[0], xs[1])\n    else:\n        # Initialize derivative to 0\n    derivative = []\n        # Loop until we have no more terms\n    for i in range(len(xs)):\n        # Loop over each coefficient\n        derivative.append([i])\n        # Add the coefficients\n        derivative.append(xs[0] + xs[1])\n        # Add the second term\n        derivative.append(xs[1] * x)\n        # Add the second term's coefficient\n        derivative.append(xs[2] * x^2)\n        # Add the second term's coefficient", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    def derivative_poly(xs, y):\n    \"\"\" Return derivative of a polynomial in the form of a list of\n    coefficients.\n    >>> derivative_poly([3, 1, 2, 4, 5], 1)\n    [1, 4, 12, 20]\n    >>> derivative_poly([3, 1, 2, 4, 5], 2)\n    [1, 2, 6]\n    >>> derivative_poly([1, 2, 3], 1)\n    [2, 6]\n    >>> derivative_poly([1, 2, 3], 2)\n    [1, 4, 6]\n    \"\"\"\n    return [xs[1]*x + xs[2] * y for x,y in zip(xs, y)]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    print(xs)\n    return xs[0] * xs[1] + xs[2] * x^2 + xs[3] * x^3", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return f'(xs)\nCan you explain why f'(xs) instead of f(xs)?\n`f'` is a function defined in this module to return the derivative of a function `f` on a list of arguments.  It is also a function that can be implemented in terms of `f` and a list of its derivatives.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if len(xs) == 0:\n        raise ValueError(\"Derivative of a zero polynomial is undefined\")\n    xs = [x for x in xrange(1, len(xs) - 1)]\n    return list(derivative(x) for x in xs)", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs[0] * x + xs[1] * x^2 + xs[2] * x^3 +....\n    * x^n", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [x*x**2 for x in xs for x in xs]\ncan't help but notice that this code is not very \"pythonic\", but it's the fastest code I can write in python. what's your secret?\n\nI don't think this is the fastest way.\nfor x in xs:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return list(xs[-1], xs[-1]*x, xs[-1]*x^2,...)", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return (x ** 2.0 for x in xs)", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs.flatMap(lambda x: x**2).sum()\nI'm not sure what's going on there, but the derivative of [1,2,3] is not [2,6].\n\nNot sure if serious, but if you are, you might be interested in \"real\" derivatives.\n\nI am serious, and I'm aware of what you're referring to. The parent post is still wrong though, and the downvoters seem to agree with me.\n\nSince you're aware of what I'm referring to, could you please explain what you mean by \"the derivative of [1,2,3] is not [2,6]\"?\n\nI'm not the person you're replying to, but I'll go ahead and guess that they're referring to the fact that there isn't a single number that is the derivative of [1,2,3] (or any other polynomial). In fact, there are infinitely many different possible \"derivatives\" of a given polynomial.\nWhat the parent post is trying to say is that the derivative is not a function like the one in the example. That function is the composition of a lot of functions", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if xs is not None:\n        return (xs[0] * xs[1] +\n        xs[1] * xs[2] + xs[2] * xs[3] +\n        xs[3] * xs[4] +...) - xs[-1]\n        else:\n        return None\n\nThis doesn't do any error checking. The function itself is not a polynomial, since it takes more than one argument.\n\nFixed. Thanks!</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs.difference(xs[0], xs[1])\nderivative(xs)\n\nThanks for sharing that.\n\nI think that this is what you are looking for:</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs[0] - xs[1] * x + xs[2] * x^2 +....\n\nThis function was in the original article and a minor issue was the article's usage of Python.\n\nI've always written code like this. I know it's not great style, but I think the idea of using a function for a single line of code is a good one.\nI like to write a function that takes the current directory and the full path to a file, and returns that file's absolute path. So:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return (xs - xs[1]) / (xs[0] - xs[1])\nI feel like this doesn't generalize well. For example, for x = 1, the result is 0, but it should be 1.\n\nI think you meant x = 0, but the rest is spot on.\n\nGood catch, thanks.\n\nIf you are interested in this, you may also enjoy this: \nIt's not meant to be a production-ready library for symbolic computing, but it's a very interesting project.\n\nCheck out katz.py - a Python module for building and manipulating algebraic systems and equations in katz.\n\nOr a much more mature symbolic computing library in python:\n\nAgreed. Numpy + Sage is a very effective combination for symbolic computing in python.\n\nI'm really interested in this kind of thing, and I'm getting some experience with Mathematica, but I'm curious if there are other languages out there that could be used for this.\n\nIt's been a while, but I played around with Maple a few years back and remember it being fairly impressive.\n\nI've recently been playing with Maxima for symbolic algebra", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [y for y in xs if xs[y-1]!= 0]\nThis is a Python implementation, and the name of the function is derivative. It returns the list of coefficients of the polynomial plus the derivative.", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return list(x*(1 - x) for x in xs)\nI am familiar with the Euler method, and this is a much faster way to do it than what I have been doing.\n\nI think the author should have defined it in terms of Euler's method instead. It would have made the purpose more clear. I also didn't understand why you need to use a tuple for the derivative.\nThe code could be simplified to:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n          return xs", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return max(xs, key=lambda x: x[1])\n\nThis will return the maximum value of the coefficients, which is what I think you are after.\n\nEdit:\n\nI just saw you wanted to know which coefficient is the maximum. In that case you can use a dictionary, where the key is the name of the polynomial and the value is the value of the derivative.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return\n    xs[0] * xs[1] * xs[2] * xs[3] * xs[4] * xs[5]\n    * xs[6] * xs[7] * xs[8] * xs[9] * xs[10] * xs[11] * xs[12]\n    * xs[13] * xs[14] * xs[15] * xs[16] * xs[17] * xs[18] * xs[19]\n    * xs[20] * xs[21] * xs[22] * xs[23] * xs[24] * xs[25] * xs[26]\n    * xs[27] * xs[28] * xs[29] * xs[30] * xs[31] * xs[32] * xs[33]\n    * xs[34] * xs[35] * xs[36] * xs[37]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if not hasattr(xs, 'coeffs'):\n        return []\n    else:\n        return [xs[0] * xs[1] * x + xs[2] * x^2 +... for x in xs]\n    return []\n\nI thought this was pretty cool.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    xs = xs.sort()\n    d = xs[0] + xs[1] * x + xs[2] * x^2 +....\n    return xs[-1] - d\n\nThat is, you're using list comprehension to solve the equation and then you're dividing the result by the first element of the list, which is the initial value of the polynomial.\nYou could also do it this way:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs[0] * xs[1] * xs[2] * xs[3] *... * xs[n-1] * xs[n]\nI like it. Python in my head.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs[:], xs[:]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [xs[0]*(xs[1] + xs[2] * x + xs[3] * x^2 +....)\n    for x in xs]</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    for i in xs:\n        out, x0 = i\n        out, x1 = xs[i+1]\n        out, x2 = xs[i+2]\n        out, x3 = xs[i+3]\n        return (out * x0 + out * x1 * x2 + out * x3 * x4)\n    return derivative\n\nThe d in xd stands for derivative.\n\nd2x gives the derivative of x2, in the form of x2 raised to the second power.  (In this case, \"the second power\" is a function of x2.)\n\nimport numpy as np\n  def d2x(x):\n    \"\"\"\n    x = 2^x.\n    Return d2x of x.\n    \"\"\"\n    d2x = np.ndarray([0, np.pi])\n    d2x[0] *= x", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if xs[0] is None or xs[0] == 1:\n        return 1.0\n    else:\n        return (1.0 - xs[1]) * (1.0 - xs[2]) * (1.0 - xs[3]) *... * xs[n]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return f(x)\nWhat you mean by \"derivative\" is \"derivative of f\", but you are not passing f.  The fact that you are calling \"f(x)\" gives away what you mean to do.\n\nHere's a little python example that may help you out:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return np.exp(np.log(xs[0]),\n         np.log(xs[1]),\n         np.log(xs[2]),\n         np.log(xs[3]),\n         np.log(xs[4]),\n         np.log(xs[5]))\n\nI really think this is terrible, and should be written as a function that takes the coefficients as an argument.\n\nI am not sure what you are getting at here. The OP's example is perfectly valid.\n\nThe derivative of a polynomial is a single value, not a sequence of values. So it makes more sense to return the derivative as a function of the coefficients, rather than the coefficients themselves.\n\nNo, the derivative of a polynomial is a function that takes an input and returns the derivative of the input at the given point. The OP's function returns the derivative of the coefficients at the given point.\n\nThis is the most interesting thing I've seen on HN in a long time.", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [xs[i] * xs[i+1]]\n    * derivative(xs)\nI've seen a few people using this. Is there a reason for doing so?\n\nI've seen people do this too, but I don't know if it's better or not. I've been playing around with a variant where the derivatives are stored as a list of matrices. I'd be interested to hear any thoughts on that approach.\n\nThere's no way this is better than storing the derivative as a polynomial and evaluating it.\n\nWell, it doesn't have to evaluate the derivative, it just has to evaluate the first derivative. For polynomials with large degree, that's much quicker.\n\nTo clarify, this is based on the following paper, which may be of interest to some:\n\nI feel like this sort of stuff is a step backwards. Why are we defining a derivative when we could just create a function to evaluate one?\nIt is true that I have a CS background, but this sort of thing is an obstacle to me understanding the algorithms and methods for solving problems.\n\nThe concept of a derivative is far older than the concept of a function.", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return (xs[0] - xs[1] + xs[2] - xs[3]) / xs[4]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return list(sum(x for x in xs))\nThis is a simple and fast way to do it. But note that it is not reversible. If you want to get the original polynomial back, you would have to rederive it from the derivative function.\nIf you don't care about reversibility, this is perfect.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [x for x in xs if x!= xs[0]]\n>>> derivative([1, 2, 3])\n[2, 6]\n>>> derivative([1, 2, 3, 4, 5, 6])\n[1, 4, 12, 20]\n\nHere's how it works. To calculate the derivative, we start with a product of powers of the form\n[x for x in xs if x!= xs[0]]\nx[0] is the coefficient of xs[0], so we start at x[0] and start multiplying.\nThen we ask if x is a coefficient of xs[0]. If so, we've reached the end of the sequence (there's only one coefficient of xs[0]), so we return x.\nOtherwise, we keep going and multiply by the next coefficient in the list.\nSo we start with\n[1 for x in xs if x!= xs[0]]\nThen we multiply by x[1], and ask if x is a coefficient of xs[1]. If not, we keep going.\nThen we multiply by x[2], and ask if x is a coefficient of xs[", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs[1] * xs[0] * xs[2] * xs[3] * xs[4] * xs[5]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    result = 0\n    while xs is not None:\n        if xs is not None and (0 in xs[0] for x in xs[1:]) or (0 in xs[0] for x in xs[0:]) or (0 in xs[1] for x in xs[2:]) or (0 in xs[1] for x in xs[1:]) or (0 in xs[2] for x in xs[2:]) or (0 in xs[3] for x in xs[3:]) or (0 in xs[3] for x in xs[3:]) or (0 in xs[4] for x in xs[4:]) or (0 in xs[4] for x in xs[4:]) or (0 in xs[5] for x in xs[5:]) or (0 in xs[5] for x in xs[5:]) or (0 in xs[6] for x in xs[6:]) or (0 in xs[6", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return (x - xs[0]) / xs[0]\nWhat about the constant 1?\nIt's a global constant. I'd expect it to be implicit.\nNot in Python.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return (x**2 - x**2 for x in xs)", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [xs[i] for i in range(len(xs))]\nMy only problem with this is that it doesn't let you use any of the existing functions for printing the derivatives of a function, so it doesn't really do anything.\nI think what you're looking for is:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs[0] + xs[1] * x + xs[2] * x^2 +....\n\nIn OCaml,\nlet derivative (xs : list) =\n    for x in xs\n         x + x * x\n         x * x ^ 2\n        ...\n         xs\n\nI don't know if it's possible to do this in Python, but the OCaml solution is (slightly) more general:\nlet derivative (xs : list) =\n    let coeffs = list_of_tuples (xs)\n    for x in xs\n        coeffs[x] += x * x\n        coeffs[x] *= x ^ 2\n       ...\n        coeffs\n\nOne might also use an extension of Python's \"f-strings\" that allow inline code:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return\n    list(xs)\n   .apply(lambda x: x**2, lambda y: y**2)\nThis is pretty cool.\nI had no idea that Python could be so concise.\n\nThat is pretty nice. I just tried that in Ruby and got:\n> def derivative(x)\n> x * x * x * x * x\n> end\n> derivative([3, 1, 2, 4, 5])\n> [1, 4, 12, 20]\n\nWell, I was expecting some python-specific idioms, but this is just C code in a python form.\n\nReally? I'd love to see it in C.\n\nPython has a C API, so you could do it with that:\n\nI'd be curious to know how many other languages support this sort of thing.\nIt's a fairly nice feature that saves you from having to parse the whole expression tree.\n\nI think it's pretty common. Mathematica, Maple, I think Lisp has it, and all the other major languages I can think of support operator overloading.\n\nPython's method of using operator overloading is much less common than", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs[2:]\n\nThe use of the word \"derivative\" is a bad idea. There is more than one meaning of the word \"derivative\", and the phrase \"return the derivative\" is ambiguous.\n\nA more appropriate name would be \"calculate the second-order differential\", which also happens to be the name of the function.\n\nThanks for the feedback. I'll update the description on github.\n\nThe wording is still a bit off. \"Calculate the second order differential\" is still ambiguous. Something like \"Calculate the second derivative\" is better.\n\nYou're right, I updated the description to make it more clear.\n\nWhat's the point of having a function for this? Don't you have to know what the derivative is for the sake of the function you're trying to write?\n\nI guess this could be useful in a math-heavy language where you may not know the syntax for the derivative, but if you don't know the syntax for the derivative, you can't really use this.\n\nIt can be used for exact interpolation of a function with a known derivative. For example, it's not uncommon to use the following", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if xs[1] == 0:\n        return xs[0]\n    xs[0] = xs[1] * x\n    return xs[1] * xs[2] * xs[3] * xs[4] * xs[5] * xs[6] * xs[7] * xs[8] * xs[9] * xs[10]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    def derivative_coeff(xs):\n    \"\"\"\n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 +....\n    Return derivative_coeff of this polynomial in the same form.\n    >>> derivative_coeff([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative_coeff([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    return [0] * (xs[0] + xs[1] * x + xs[2] * x^2 +....)\nThis isn't a critique of your code, but it looks like you're unnecessarily multiplying the second derivative by the first derivative. For example, for [1, 2, 3], [2, 6] is (2 + 4 * 3 * 3) / 2.\nThat is, you're doing `[2, 6] = xs[0] * xs[1", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    def derivative_of_poly(xs: list):\n    \"\"\" return the derivative of the polynomial xs in terms of xs.\n    >>> derivative_of_poly([1, 2, 3, 4, 5])\n    [1/3, 2/3, 4/3, 1, 2]\n    >>> derivative_of_poly([1, 2, 3, 4, 5])\n    [4/5, 5/5, 1/3, 2/3]\n    \"\"\"\n    return derivative(xs)", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    xs = xs.sort()\n    if len(xs) == 2:\n       return xs[0]\n    else:\n       return xs[1]\n\nExample: \n\n>>> derivative([1, 4, 1, 9, 1, 4, 1, 9])\n\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"/Users/moyix/anaconda/lib/python2.7/site-packages/pyzmq/__init__.py\", line 966, in __call__\nreturn self._apply_derivative_function(self._object, xs, as_complex)\nFile \"/Users/moyix/anaconda/lib/python2.7/site-packages/pyzmq/object.py\", line 481, in _apply_derivative_function\nwith self._object:\nTypeError: integer division or modulo by zero\n\nCan someone explain what I'm doing wrong?\n\nWell, maybe you should start by", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return list(map(float, xs))\nIs there a reason you're not using an explicit call to `double`?  I realize it's just a function call, but it seems like it'd be more readable to me.  I suppose there is a performance penalty, but I'd have to see a benchmark to believe it matters.\nI think it's more about preference.\nExactly. I haven't done any benchmarking, so I don't know if it really matters. But I like using explicit calls. It is less code and more readable to me.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return (xs[0] - xs[1]) * xs[2] * xs[3] * xs[4] * xs[5]\n\nIt doesn't look like the author did much research into the algorithms used to calculate polynomial roots. The author says that the derivative of a polynomial is the \"least common multiple of the powers of the coefficient\". But the derivative of a polynomial is not the same thing as the least common multiple of the coefficients. The derivative is a ratio, and in the case of a polynomial it's a ratio of coefficients, but it is not the least common multiple of the coefficients.\nAnother issue is that in the example code, the derivative of a polynomial in _x_ is calculated by subtracting the coefficient of _x_ from each of the coefficients, and then taking the _x_ th root of the resulting quotients. The algorithm is wrong in at least two ways. First, the algorithm will never give you an exact root in _x_. Second, it will give you a finite number of solutions, not a least common multiple.\nThe correct algorithm is to use Newton's method to find the roots of the", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    def d(p, s):\n    \"\"\" Return derivative of polynomial in its simple form.\n    >>> d(1, 2)\n    [1]\n    >>> d(x**2 - x + 1, x)\n    [1]\n    \"\"\"\n    a, b, c = xs\n    if xs[a]!= 0:\n       raise StopIteration\n    else:\n       r = a - xs[a]\n       a, b, c = a - xs[a], b - xs[b], c - xs[c]\n    return r*x**2 + b*x + c*x + d(p, s)\nI'm not sure if this is the same algorithm you're looking for, but I think it is the most elegant way to implement it.\n\nIs there a reason that you're using a list comprehension instead of just the list?\n\nYes. In the original post, the poster said the list contains numbers,", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    def __getitem__(self, n):\n       return self[n]\n    def __setitem__(self, n, d):\n       if n in [0, 1, 2, 3, 4, 5, 6, 7]:\n          self[n] += d\n    return derivative", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if xs.endswith('0'):\n        return 0\n    else:\n        return xs[0] + xs[1] * x + xs[2] * x^2 +....\n    class Polynomial:\n    def __init__(self, coefficients, power):\n        self.coefficients = coefficients\n        self.power = power\n    def __getitem__(self, index):\n         return self.coefficients[index] * self.power\nThis is why I prefer Ruby for my mathematical programming.\n\nDid you know that Ruby's method name syntax is more flexible than Python's?\n(Although it's not necessarily more _useful_.)\n\nI'm not sure I'd call it more _useful_, but it is certainly more _flexible_, and that's what I value.\n\nThat's what I meant by _flexible_, but I can see how it could be misconstrued.\n\nHas anyone", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return np.linalg.tanh(xs[1], xs[0])", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    f = lambda x: pow(x, 2)\n    xs = xs.tostring()\n    ys = lambda x: x * x\n    return lambda y: y - f(ys(x))", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    def derivatives(xs: list):\n    \"\"\" xs is the same as list(list(xs)).\n    list(list(xs)) represent coefficients of a polynomial.\n    >>> list(list(xs))\n    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 136, 169, 196]\n    >>> derivatives(list(list(xs)))\n    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 136, 169, 196]\n    >>> derivatives([1, 2, 3, 4, 5, 6])\n    [0, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100, 121, 136, 169, 196]\n    \"\"\"\n    return {k: tuple(x.k, y.k)}\n    def derivative_2(xs: list):\n    \"\"\" xs is the same as list(list(xs)).\n    list(list(xs", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    list = [0, 1, 2, 3, 4, 5]\n    return derivative(list)\n\nPardon my ignorance, but it seems like you're getting a list of coefficients (powers of x), but then you're multiplying them by some number and then getting back a single value. I'm guessing the explanation is simply that I don't fully understand what \"derivative\" means in this context.\n\nderivative is basically the slope of a function. It's the 1/slope.\n1/slope = x^2 + x + 1\nderivative([3, 1, 2, 4, 5]) = 3^2 + 1 + 1 + 1 + 1 + 4 + 5 = 12\n\nI was under the impression that derivative was the rate of change of a function. It's not just the slope, it's the derivative of y/x.\n\nI don't think there is a _definitive_ definition of derivative. It's more of a concept.\nIn the context of calculus, the derivative of a function is the slope of the tangent line at a given point. The slope of a curve is the derivative, and it is also", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return (x * x * x * x * x) * x\n\nI'm not sure what the point of this is. The code is already written out to a simple form in the article. If you're learning, I suggest you read the article, run the program, then think about why it does what it does.\n\nThe code was presented in article as an algebraic expression, not in a form that is suitable for a program to parse.\nAs for why, there are many reasons:\n* It can be used as a function that can be called from the REPL. This is useful for making a \"pattern matching\" REPL.\n* It can be used to generate a graph of a function.\n* It can be used to visualize the derivative of a function.\n\nI used this code in my old \"computational mathematics\" class to construct a symbolic derivative calculator. It works pretty well:</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    var factors = []\n    for x in xs:\n        if x!= 0:\n           factors.append(x)\n          xs.pop()\n    return factors\nThis is not the obvious way to write the algorithm. If you find this\nconversion to be easier, you should think about what a polynomial is and how\nto express a derivative in polynomial form.\n\nThe more usual way is to use a Taylor series approximation:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n\n    d = xs.index(x)\n    d = d.value\n    for d in xs:\n         if d[0] == 0:\n             return\n          if d[0] == 1:\n               d = d.value / d[1]\n          if d[1] == 0:\n               d = d.value / d[2]\n          if d[1] == 1:\n               d = d.value / d[2] * d[1]\n          if d[2] == 0:\n               d = d.value / d[2] * d[2]\n          if", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    p = zeros(length(xs))\n    xs_final = [p[0] for p in xs]\n    return xs_final", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return (xs[-1]+xs[-2]+xs[-3]+xs[-4]+xs[-5]+xs[-6])/(xs.length-1)\nThanks :)</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [x * xs[0] + xs[1] * x + xs[2] * x^2 +...]\n\nYou might try this with the \"shell\" utility, which is a bit more in-line with the python philosophy than C is.\n\nInteresting, but I don't see what's wrong with C.\n\nI'm sorry, but that is not the way to write a Python program.\n\nThis is not the way to write a Python program.\nIn Python, you don't write everything in one line, just like in Lisp.\n\nI don't know about Python, but in Lisp this would be the way to write a program.\n\nYeah, I should have said \"This is not the way to write a _proper_ program\".\n\nThis is probably the best way to write a Python program. I certainly wouldn't use Python if I had to do things like call a function or use a variable more than once in a program.\n\nYeah, because people are lazy enough to write bad code in Python.\n\nThis is the best code I've seen in a while.\n\nThis is not the way to write a Python program", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if xs[-1] == 0:\n       return None\n    else:\n       return xs[0] + xs[1] * x", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return np.array([x * x for x in xs for x in xs])\n\nI don't know much about python, but this strikes me as a very convoluted way to implement a derivative.\n\nIt's convoluted, but simple.\nIt's easier to think about it this way, I think:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs\nI've never seen anyone write their own copy of the identity function in a python project. I think it's in the standard library.\n\nI agree with this. It's fun to see what people do when given the freedom to write their own code. But I've never seen anyone make their own copy of identity in Python.\n\nthe code is posted because it's in Python and therefore in the realm of HN. I didn't try to hide the fact that I was essentially copying the identity function; I did so for the purpose of comparing the code generated by the two different sites, and then thought that the code itself might be of interest as a reference.\n\nThe _point_ of the exercise is to write an identity function. What's the point of posting the result if you're not going to follow through and write it yourself?\n\nBecause the exercise gives you the chance to see how different people would approach the problem, and how their approaches compare with yours.\n\nWe've all written identity functions before, so I'm not sure what's interesting about seeing how people do it. The interesting part is what they do _after_ writing it.\nI'd much rather see the code for the", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n\n    return tuple(\n           xs[0]*xs[1]*xs[2]*xs[3]*xs[4]*xs[5]*xs[6]*xs[7]*xs[8]*xs[9],\n           xs[10]*xs[11]*xs[12]*xs[13]*xs[14]*xs[15]*xs[16]*xs[17]*xs[18]*xs[19]*xs[20]*xs[21]*xs[22]*xs[23]*xs[24]*xs[25]*xs[26]*xs[27]*xs[28]*xs[29],\n           xs[30]*xs[31]*xs[32]*xs[33]*xs[34]*xs[35]*xs[36]*xs[37]*xs[38]*xs[39]*xs[40]*xs[41]*xs[42]*", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs[0] * xs[1] * xs[2] * xs[3] * xs[4] * xs[5]\n\n(I'm using a real-ish domain here: in the continuous case you can simplify the above to xs[0] + xs[1] + xs[2] +... = xs[1] + xs[2] +... = xs[0] +... = 0)\nThis was the first solution that came to mind, but it doesn't work for quadratic and higher order terms.\n\nYou're right, of course. So let's do this for polynomials in real algebraic numbers.", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    result = []\n    for i in xs:\n        result.append(x)\n    return result\n> This is what I've tried\n> def derivative(xs):\n> result = []\n> for i in xs:\n> result.append(i ** x)\n> return result\nbut that doesn't work, because i * x is not defined for negative\nnumbers.\n> Why is this\n> def derivative(xs):\n> return [i ** x for i in xs]\n> giving me a syntax error?\nPython has a very strict rule that all functions return something.\nI suppose that this is to discourage the use of things like the\nfunction above as loop counters, but I'm not sure that the\nadditional complexity is worth the trouble.\nPerhaps it would be better if it was possible to define a\nfunction that took no argument, and returned nothing, and then\nyou could just write", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    xs = sorted(xs)\n    return (xs[0] + xs[1] * x + xs[2] * x^2 +....) * xs[-1]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n\n    return tuple(ys, derivative(ys[0]) + derivative(ys[1]))\n\n    def product_of_x_and_y(xs: list, ys: list):\n    \"\"\"\n    If xs has at least two elements, return a list of xs[i] * ys[j]\n    else return list(xs)\n    >>> product_of_x_and_y([1, 2, 3, 4])\n    [1, 4, 9, 16]\n    >>> product_of_x_and_y([1, 1, 1, 1])\n    [1]\n    \"\"\"\n\n    if len(xs) == 2:\n        return xs[0] * ys[1]\n    else:\n        return list(xs)\n\n    def cross(xs: list, ys: list):\n    \"\"\"\n    If xs has at least two elements, return a list of (xs[i] *", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    new = 0\n    for x in xs:\n        new = new * x\n    return new\n\nIf you're not familiar with Python, this is a classic example of what's wrong with the language. The above code is _entirely_ too long.\nIn Haskell (my favorite language) you could write this:\nderivative (x:xs) = x `div` xs\n(Using the `div` function on lists.)\n\nThis is why I _hate_ a lot of python code (and why I'm getting increasingly interested in Haskell)\nThere's a lot of python code that, in Haskell, would be half as long and twice as clear.\nAlso, there's a lot of python code that I would much rather not be using python to write.\nI've said it before, but I think the python community needs to get a little less attached to the language, and start looking for ways to use python where it makes sense (which is probably a lot of places, but python often isn't the best tool for the job).\n\nI agree with you, but if you're going to make a comparison between two", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if xs == []:\n       return 1\n    else:\n       return derivative(xs[0])\n\nThanks, this is very useful. But what if I want to find the derivative of a function? For example, what is the derivative of 1/(1 + x)?\n\nThere is not a single \"standard\" way to find the derivative of a function.\nIf you are using python, I'd recommend the numpy library, where you can find the derivative of functions using the function \"differentiate\" (or \"ndiff\", or \"differentiate_scalar\").\n\nI know about the different ways to find the derivative of a function. I was just wondering if there was a good one-liner that I could use in case I needed it.\n\n1/x can be written as 1/(1+x). To find the derivative, simply rewrite it as 1/x.\n\n1/x can be written as 1/(1+x), but 1/x can also be written as x (or 1-x). So I don't think that your answer is correct.\n\nYou are correct, 1/(1", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [x*(x - 1) for x in xs]\nYou need a newline after the return to end the function definition, otherwise it's evaluated as a list and will evaluate to something completely different.\nYou also need to put parentheses around the first call to derivative, or it will evaluate to something completely different as well.\n\nAlso, you can't just append stuff to a list in python, you need to use the append function:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    var dt: dict = {}\n    def dt(x: float):\n        return x\n    dt[0] = list(0)\n    dt[1] = list(1)\n    dt[2] = list(2)\n    dt[3] = list(3)\n    dt[4] = list(4)\n    dt[5] = list(5)\n    dt[6] = list(6)\n    dt[7] = list(7)\n    return dt", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if len(xs) == 1:\n        return xs[0]\n    else:\n        return [x for x in xs if x[0] > 0]\n\nNote: this is ugly. I wasn't able to write a more pythonic version in the 15 minutes I gave myself to make this.\n\nSo this is a list of power series that you are trying to evaluate using the derivative?\n\nYes, but there's no reason I couldn't define the derivative as a function.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs[0] + xs[1] * x + xs[2] * x^2 +....", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs[2].squeeze()\n\nThe closest example I can find to this is a lookup table.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if not xs: list is list(set):\n        raise ValueError(\"Derivative is a function that takes a list of values.\")\n    return list(set)", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return [x**(1/2) for x in xs if x**(1/2) in x for x in xs]\nIn [3]:\nfrom operator import derivative\nfrom math import sin, cos", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    a = [0] * xs[0]\n    b = [1] * xs[1]\n    c = [2] * xs[2]\n    d = [3] * xs[3]\n    return c * a * d / b", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    ds = []\n    return lambda x: x * xs[0] + xs[1] * x + xs[2] * x^2 +....\n\nWhen I look at this, I start to think, how do I think about this?\nSo I start by seeing that it is a function that transforms a list into another list, and that it operates on its argument in an iterative fashion.\nAt this point I look at the function and see that there are some small differences.", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if len(xs) == 0:\n        raise ValueError(\"Derivative has no xs\")\n    return xs\nYeah, but then they ask you how to do it with lists of other types.\n\nIn python, you can do", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    def iadd(x: int, y: int):\n    \"\"\" Add x and y.\n    >>> iadd(3, 5)\n    [8, 8]\n    \"\"\"\n    return x + y\n    return iadd", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    if len(xs) == 0:\n        return 0\n    return (xs[-1] + xs[-2] * x + xs[-3] * x^2 +....) - xs[0]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs[0] + xs[1] * x + xs[2] * x^2 +....\n\nPretty cool!\n\nYes!\nIt's also a simple way to compute a discrete Fourier transform in Python.\n\nI didn't see it at first, but there is some subtlety to the `return xs[0] + xs[1] * x + xs[2] * x^2 +....` statement. It needs to be understood in the context of the surrounding code to work.\n\nI haven't used python enough to know, but is this a particularly elegant way of doing this?\nIt's so easy to get hung up in the details of implementation, but I wonder how many people have written this?\n\nThis is known as the geometric mean, and is certainly the simplest way to compute it.\n\nNote that this is the _derivative_ of a geometric mean. The geometric mean, itself, is not a derivative.\nThe derivative of the geometric mean is the mean of the derivatives of the components.\n\nAh yes, that's a great point.\n\nAwesome. I've been looking for a way to do this", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n\n    return [-1.0 / x for x in xs for x in xs]\n\nYou can test this code on the command line with Python.</s>", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    def apply(xs: list):\n    \"\"\"   xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 +....\n    Return derivative of this polynomial in the same form.\n    >>> apply([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> apply([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    return xs.difference(xs[0], xs[1])\n\nThe code is not pythonic. For example, the function name \"derivative\" is not pythonic because it is not clear if it is a function name or a method name. Pythonic names are words that are clear in the English language, for example, \"derivative\" is not a clear word, but \"difference\" is.\n\nThe function is also not pythonic because it is not clear what it is supposed to do. The name \"difference\" is not clear because it", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    # Return the polynomial derivative of the input.\n    return [x for x in xs]\nOh, man, there's so much wrong with this.\n\nI am curious to know what is wrong with this.\n\nThe solution is correct but the code is bad. The functional programming constructs are overly verbose, the variable names are completely meaningless (I don't understand what the hell \"xs\" is supposed to mean) and the last line is just pointless.\n\nOn the contrary, I think the functional programming constructs are concise and expressive, the variable names are descriptive, and the last line is a quick and correct way of returning the derivative.\n\nYou haven't explained why you think the last line is correct. If you don't understand why it's pointless, please re-read my comment.\n\nI don't really understand what you mean by pointless, but I think the last line is correct because it's easy to read, easy to understand, and it does what the OP wants it to do.\n\nOk, I'll try again: the last line is a completely useless and meaningless line of code that does nothing. If you can't see that then you are blinded by a rush", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs[-1].diff(xs[-1])\nWhat about negative powers?\n(I'm not familiar with Python, but I assume that xs[-1] returns a\nlist.)\n\nIt should have been xs[-1] instead of xs[-1].diff.\n\nYes, indeed.\n\nWould be great to see a comparision with R.\n\nisn't this a more general version of the fact that the derivative of a\nfraction is the fraction of the numerator divided by the denominator?\n\nYes, it's a special case of a derivative[1] of a fraction.\n[1]\n\nYes, it's a derivative of a fraction.\nDerivative[f] is not a function.\n\nI have no idea what it's for or what it's good for, but it's fast.\n\nProbably for neural networks, I would guess. The usual definition of derivative is not useful for neural networks (which are derivatives of multidimensional functions).\n\nI am not a mathematician but I find it surprising to not find any mention of the \"natural\" or \"elegant\" definition of the derivative", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    new_x = xs[0] + xs[1] * x + xs[2] * x^2 +....\n    new_x_coeff = [x - new_x - (x[i] * x[i+1] - x[i+2]) / (x[0] + x[1] + x[2] +....)]\n    new_x_coeff_coeff = xs[i] * xs[i+1] - xs[i+2]\n    return (new_x - new_x_coeff_coeff) * xs[0]", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return lambda x: (x - x.0) / (x.0 * x.0)", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    c = 0\n    while xs[0]!= '+':\n        c += xs[1] * x\n        c += xs[2] * x^2\n        c += xs[3] * x^3\n    return c", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    n = len(xs)\n    p = xs[0]\n    return (p * x + p * x^2 +... + p * x^(n-1)) / n\n\nI think it would be more readable to write this as:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    def base(s: string):\n    \"\"\" Return string with base 10 digits for xs\n    >>> base(4)\n    \"0123456789\"\n    >>> base(10)\n    \"123456789\"\n    >>> base(16)\n    \"01234567890123456789\"\n    \"\"\"\n    return string.punctuation.rjust(s, 10)\n    + \"0\" + string.punctuation.rjust(s, 10) + \"0\" + string.punctuation.rjust(s, 10)\n    + \"0\" + string.punctuation.rjust(s, 10)\n    + \"0\" + string.punctuation.rjust(s, 10)\n    + \"0\" + string.punctuation.rjust(s, 10)\n    + \"0\" + string.punctuation.rjust(s, 10)\n    + \"0\" + string.punctuation.r", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n\n    return [x for x in xs if x in xs[1] if x*x in xs[0]]\n\n    def derivative(in: list, out: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 +....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5], [5, 3])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3], [3, 2])\n    [2, 6]\n    \"\"\"\n\n    def lim(x: int):\n    \"\"\"\n    Return the largest number for which x is greater than or equal to x.\n    >>> lim(1)\n    1\n    >>> lim(2)\n    2\n    >>> lim(3)\n    None\n    \"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs[1] / xs[0]\nSo much for being \"clever\".\n\nDarn, I was hoping it would just use linspace().\n\nAnother approach, using linspace:", "def derivative(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return derivative of this polynomial in the same form.\n    >>> derivative([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> derivative([1, 2, 3])\n    [2, 6]\n    \"\"\"\"\"\"\n    return xs.pop(0) * xs.pop(1) * xs.pop(2) * xs.pop(3) * xs.pop(4) * xs.pop(5)\nI don't think that works with a list in python 2.x. The interpreter stops at the first `*` because `pop` is not defined on lists.   I just googled it, and it seems the same thing happens with `lambda`.   So, I don't think this works in python 2.x.\nI just tested it and it worked for me. Python 2.5.2 on Windows.</s>"]]