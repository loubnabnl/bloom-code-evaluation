[["def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        return i*(i%2)\n    print(digits(5))", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return (n%2 == 1) or (n%3 == 1) or (n%5 == 1) or (n%7 == 1) or (n%9 == 1)\nelse:\n    return 0\n\nThanks for the reply, but I think that's not what I was looking for.\n\nYou can iterate over the string using range(str) and then index into the string at each iteration.\n\nWow, that's a really cool way of writing it. I would never have thought of that, thanks!\n\nYou can do the same in Python:\n>>> numbers = [0, 1, 2, 3, 4, 5]\n>>> list(range(numbers))[::2]\n(0, 1, 2, 3, 4, 5)\n>>> list(range(numbers))[::-2]\n(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n>>> list(range(numbers))[::-1]\n(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    for i in range(0, n - 1):\n         return i * 3\n   \nI don't think that returns the correct answer. I think it returns 0 for any non-negative n, 1 for any negative n, and 15 for any positive n.\n\nIndeed, I would expect:\ndigits(4) == 1\ndigits(1) == 1\ndigits(234) == 15\nAlso, if the goal is to compute the product of the _odd_ digits, then I would expect:\ndigits(1) == 1\ndigits(234) == 4\ndigits(4) == 0\n\nYou have it backwards.\nThe product of the odd digits is one less than the product of all digits.\n\nAh yes, you are correct. Thanks.\n\nI'm glad I'm not the only one who thought this. I was sitting here wondering why the author didn't write `n/2` and `n/3` instead of `n % 2` and `n % 3`.\n\nIt's a good habit to always write `n % n` or `n/n` instead of `", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n&1\nWhen you do this:       digits(1)  == 1  you're just doing an assignment. You're not returning anything.       return digits(1)  will return a list with just 1 in it.       return digits(1)           will return a list with just 1 in it and the variable you're returning it to will get set to the same thing.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return int(n&1)\nI'm trying to understand what the problem is here... Isn't this implementation the correct one?\nThe problem is, the other one will return 3, and 1 will return 0.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return 0 if n == 0 else\n    return n * (n % 2) + n % 4", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n % 2 ** (1-n)", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n * (n - 1)", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n ** (n-1)\n\nNot sure what the point of this code is, but I'll assume that it's a more efficient way to implement the algorithm you were taught in grade school. It's not.\n\nIt has two purposes:\n1. It shows how easy it is to make a simple program look inefficient when you don't understand the _actual_ algorithm being implemented.\n2. It demonstrates how you can use Python's string manipulation operations to make code that appears \"hard\" look easy.\n\nI'm not sure why you think I don't understand the algorithm, but I do. I'm not saying the code is inefficient, I'm saying it's wasteful of resources. Here's a more efficient version:", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n\n          for i in range(2, n):\n             if i % 2 == 0:\n                return i\n\nI would have returned 0 for i % 2 == 0, rather than 1.\n\nThat's what I meant to say, I just made a typo.\n\nI guess the problem is that Python developers have no sense of humor.\n\nYou could write a very long list of Python problems that are caused by a lack of sense of humor.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n.pop(0) for n in range(0, n - 1)\n\nI understand that, but for some reason the input is considered as -1 in the range function.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    for i in range(1, n):\n        print(digits(i))\n    return 0\nThis is a stupid question, but how does one print things in Python?</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return [0,1,3,5,7,9,11]\nI'm all for the simplest solution, but this has a significant downside. I can't think of any situation where this is desirable, but it's pretty easy to find a situation where you want to ignore digits that aren't even.\nIt's a shame, because the other solutions all require extra code to handle even/odd. But I don't think you need extra code to handle odd, just even.", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(n.split(',')[::2] + n.split(',')[::3])\n\nAm I the only one who noticed this is a recursive function?\n\nI wrote it as a recursive function on purpose.\nI think it's a good programming exercise to see if you can write a recursive function without using any recursion (i.e. \"fold\" or \"filter\" functions).\n\nThat's not an exercise for me. It's just a matter of style.\n\nI'd have to agree. I think there are two styles of coding:\n1\\. Inventing and writing all the functions from scratch. 2\\. Using off the shelf functions and tweaking them to meet your needs.\nI tend to use the 2nd because it's faster and easier to maintain.\n\nI use the second, especially for simple tasks, but the first for more complex ones (I am not a great coder yet, though). I find that it helps me understand the code better.\n\nPersonally, I prefer the second, because for the most part, it seems much easier to maintain.\n\nI used to do that as well, until I wrote a recursive function to convert a", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return (n % 2) + 1\n\nAha. I guess you use this function to ensure that you get the right number of digits for printing, right?\n\nI use it when I'm writing programs to help me out.\nThere is an HTML output module for Python, and it has a method for outputting a decimal number.\nThe problem is that the number must be formatted as follows:\n0.0\nand the sequence of digits must be as follows:\n    0 0\nbut the decimal number must be formatted as follows:\n0.1\nand the sequence of digits must be as follows:\n    0 1\nSo I use my 'digits' function to strip off the trailing zeros and add one for me.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    print n\n    for i in range(1,10):\n       print (i % 2) + ':'\n       print n\n    return n", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return (n & 2) | (n - 2)", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n**(2**n-1)\n\nOk, I get the definition, but what's the benefit of this? It seems to have a lot of overhead to get it to work for positive values only. Is the overhead worth it?\n\nMaybe I'm missing something, but it looks like:\ndigits(0) == 1\ndigits(1) == 1\ndigits(2) == 0\ndigits(3) == 0\ndigits(4) == 0\ndigits(5) == 0\ndigits(6) == 1\ndigits(7) == 1\ndigits(8) == 0\ndigits(9) == 0\ndigits(10) == 1\ndigits(11) == 1\ndigits(12) == 1\ndigits(13) == 1\ndigits(14) == 1\ndigits(15) == 15\ndigits(16) == 15\ndigits(17) == 15\ndigits(18) == 15\ndigits(19) == 15\ndigits(20) == 15\ndigits(21) == 15\ndigits(22) == 15\ndigits(", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    def step(n):\n    \"\"\"Return the product of the odd digits of n (with step n+1).\n    For example:\n    step(6) == 7\n    step(5) == 5\n    step(4) == 4\n    \"\"\"\n    return (n + 1) % 2", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return int(n*i**2 for i in range(1,n))\nThanks. In Python the function would be:", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    def evendigits(n):\n    \"\"\"Given a positive integer n, return the product of the even digits.\n    Return 0 if all digits are odd.\n    For example:\n    evendigits(1)  == 1\n    evendigits(4)  == 4\n    evendigits(235) == 235\n    \"\"\"\n    return 0\n\nSee also\n Fibonacci sequence\n Lucas sequences\n\nReferences</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    n = int(raw_input())\n    return n.split(',')[0]*10\nWhat's wrong with this solution? It looks like a simple implementation of what the OP wants.\nIt's not even a solution, it's just a crude algorithm for finding the digits of a number. The OP wants a function to compute the product of the even digits.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return [n[i] for i in range(n.max() + 1)] + 0\nI don't know why this was downvoted. It's a perfectly fine solution.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n % 2 ** (digits(n-1))\n\nShouldn't it be % 2**(digits(n-2))?\n\nYou're right, I'll fix it. Thanks!</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    def _odd_digits(n):\n    \"\"\"Return the product of the odd digits of n.\"\"\"\n    return sum(n[2:] if n[1] > n[2] else n[1]) * n[2:]\n    return _odd_digits", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n**(2**n-1)\n\nSee also: https://news.ycombinator.com/item?id=8539246</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    digits = [0]*2+2*2+4*2+6*2+10*2+20*2+30*2+40*2+50*2+60*2+70*2+80*2\n    if digits!= 0:\n       return digits\nI'd call that a good decision.  It's a little more complex, but it's more descriptive.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    def __call__(self, n):\n       return sum( [i for i in odddigits(n)] )\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11) == 15\n> digits(11", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n % (2**n - 1)\n\nI guess I don't know what the 2**n - 1 means. Can you elaborate?</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return 1 if n%2 == 0:\n         return sum(n/2 for n in range(n/2+1,n+1) if n%2 == 0):\nThis is a neat solution, but you might want to read the post.  :)</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n % 2:\n       return n % 2\n    elif n % 3:\n       return n % 3\n    elif n % 5:\n       return n % 5\n    elif n % 7:\n       return n % 7\n    elif n % 9:\n       return n % 9\n    return 0", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return (n%2)\nfor n in [1, 4, 9, 16, 17, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    n = int(input(\"Enter a positive integer: \"))\n    for digit in range(1, 10):\n        n = n + digit\n    return int(n) / int(n - 1)", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n ** (n ** (2 ** n))\nWhy use something as slow as a python function for that?\nI always wonder this when I see python used in what would be better suited for a straight C/C++ program.\nIt is also something that is pretty easy to do in the shell:\nfor i in `seq 1 9`; do\necho $i\ndone\nThe bash version is about a factor of 100 faster for me.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n == 0? 0:n.factorial(digits=-1)\nThis is very odd...\n\nit's also not very efficient. there's a better way.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return (n == 1? 1 : (n % 2) + 1) % 2", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n       if n == 0:\n          return 0\n         # Make sure we don't get the empty string.\n          return (sum(map(int, range(2, n))) > 0)\n         # We know that each even digit counts as a 1\n       return (sum(map(int, range(2, n))))", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    for i in range(1, n+1):\n        return i % n == 0\n\ndigits(2) == 1\ndigits(3) == 0\ndigits(4) == 0\ndigits(5) == 0\ndigits(6) == 0\ndigits(7) == 1\ndigits(8) == 0\ndigits(9) == 0\ndigits(10) == 0\ndigits(11) == 1\ndigits(12) == 0\ndigits(13) == 1\ndigits(14) == 0\ndigits(15) == 1\ndigits(16) == 1\ndigits(17) == 0\ndigits(18) == 0\ndigits(19) == 0\ndigits(20) == 0\ndigits(21) == 0\ndigits(22) == 0\ndigits(23) == 0\ndigits(24) == 0\ndigits(25) == 1\ndigits(26) == 1\ndigits(27) == 0\ndigits(28) == 0\ndigits(29) == 0\ndig", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return 0", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(odd(n))\nYou could also use the factorial instead of the sum and pass it the value of the odd argument.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    for i in range(1,n+1):\n        return n % i\n    # Ouch: This is inefficient.\nYou can use the fact that all odd numbers have a remainder of 1 when divided by 2. So you just need to iterate over the numbers from 2 to the number you're processing and return the index that is the smallest remainder.\n\nThis is a nice solution, but I think the best way would be to start at the beginning and test each number from 1 to the number you're processing for divisibility by 2. Then, if it's divisible by 2, add 1 to the number and test for divisibility by 3. Keep going until you're testing for divisibility by the biggest power of 2 divisible by the number you're processing.\nThis requires no additional indexes, and only one additional test.\n\nI'm not sure if this is the best way, but it's the way that I came up with as well.\n\nA somewhat contrived example:\ndigits(6) == 0 digits(6.1) == 1 digits(6.11) == 2 digits(6.111) == 3 digits", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    for x in range(n):\n        if x[0]%2!= 0:\n           return x\n    return 0\n\ntry:\n    import collections\n    except ImportError:\n        print \"import collections\"\n\nimport collections\n\n>>> print digits(2)\n0\n>>> print digits(4)\n0\n>>> print digits(235)\n15\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>\n\n>>>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n\n    return tuple([0]*(2**n-1))\n\nIt doesn't always work correctly. For example, with 1:\n>>> digits(1)\n[0]*(2**1-1)\n>>> digits(1)\n0\n\nI noticed that as well, but it's still a fun exercise.\n\nI love this!\nI'm going to make a version of this that prints it to standard out for printing, and then later add a \"print\" button to the input screen to print the answer.\nThanks for posting this!\n\nYou are welcome. I'm glad you liked it.\n\nI'm working on a version in the shell. It's nice to see this on HN.\n\nNice work. I like how concise it is.\n\nI see the section of code but I don't understand it. Why is it written like that?\n\nIt's just a way of writing code that is readable and fun. Instead of \"for i in range(10)...\" he uses \"from n in range(10)...\", where n is the input variable. Then he assigns each line of input to a variable (analogous to a counter).", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    n = int(input(\"Enter a positive integer: \"))\n    return int(n**2)\nYour comment is still unclear to me.  What is the problem?</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    def product(a,b):\n       return a*b\n    return product(n,0)\n\n...This is the most useless code I have ever seen.\nIt will work, and it will return 1 if given 1 or 4 if given 4, but this is not how math works.\nThe product of a number and 0 is not that number.\n\n_> The product of a number and 0 is not that number._\nA product of 0 and any number is that number. Zero is not a number.\n\nThis is an interesting philosophical point, but here we are talking about mathematics. In mathematics, zero is a number.\n\nIf you know how to interpret it, it's not a number. In the same way that \"3\" is not a letter. It's just a character used to make a specific set of sounds.\n\n_> If you know how to interpret it, it's not a number._\nI don't understand this point. Numbers are just symbols for sets of objects, not the objects themselves. You can use any object to stand in for a number, just like you can use any letter to stand in for a number.\nIf I", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n\n    return n*(n%2)\n\nWe can use it to compute the Fibonacci numbers", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n % (2**(n+1))\nIf you're going to use this over and over, it might be a good idea to just use a function like:      def digits(n):           return n % (2**(n+1))  If you don't want to write the function yourself, you can use the builtin numpy.ndarray.ones_complement() function, which gives you a (symmetric) array of the ones complement of n.\nNice catch.  I saw that and thought, \"ehh... I'll make it more generic and reusable.\"  Bad idea.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(product(digits(n), 2))\nThe obvious improvement is to use  instead of sum(product(digits(n), 2)).</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n ** 2\n\nI didn't understand the need for this function, since", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n**(2**i)\n\n>>> digits(1)", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n*(n%2) + (n%3) + (n%5) + (n%7)", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n % 2\n    def digits_even(n):\n    \"\"\"Given a positive integer n, return the sum of the even digits.\n    Return 0 if all digits are odd.\n    For example:\n    digits_even(1) == 1\n    digits_even(4) == 4\n    digits_even(235) == 58\n    \"\"\"\n    return n % 2\n\nThe above function definitions can be used as follows:\n>>> digits(1)\n<class 'float'>\n>>> digits_even(1)\n<class 'float'>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n % 2 == 0", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n\n    return n % (1+i) for i in range(2,len(n)-1)\n\nWhat if you want to find all the multiples of 5?\n\n(p = digits(5))\n\nis still there.\n\nI prefer to use the language's built-in function to_i, if available.\n\nThe code posted is so simple, yet I had never seen it before. Nice.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n\n    # I just copied this from a similar post\n    numbers = range(1,9)\n\n    return numbers[n]*(n+2) + numbers[n+1]*n\n\nThis is too simple a question to warrant a forum post.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    result = 0\n    while n % 2 == 1:\n         if n % 2 == 0:\n              result += 2\n         else:\n              result += n\n    return result\nThat's not the product of the odd digits though, that's just the product of the even ones.\n\nYou're right, the odd digits are the second column of the output. I think the author probably meant to say \"the product of the odd digits is the second column of the output\", and then forgot about it when writing the test.\n\nOr, it could be an interesting test of a human reader's ability to parse English.\n\nSo, the same as it's always been then?\n\nSomewhat off-topic, but I don't get why the author would even want to test if the result is 0 or 1. The first thing I would expect if a function returns 0 is that it does not exist, and the second thing is that it is not properly implemented.\n\nWell, it's", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    # if all are even return 0\n    if n%2==0:\n       return 0\n    # find the product of the odd numbers\n    odd = n%2\n    # find the product of the numbers 1 and odd\n    for i in range(2):\n       for j in range(2):\n         if n%i==j:\n             return i*odd\n    return [0]*odd", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n % 2\n    def digits_mod(n):\n    \"\"\"Given a positive integer n, return the modulo of the sum of the odd\n    digits of n.\n    Return 0 if all digits are even.\n    For example:\n    digits_mod(1)  == 0\n    digits_mod(4)  == 4\n    digits_mod(1,234) == 9\n    \"\"\"\n    return n % (n - 1) + 1\n\nThis is one of the shortest python programs I've seen here. I'm curious if you chose to use Python for any particular reason?\n\nBecause it's one of the few programming languages I actually know.\n\nI'm curious what the other ones are? I'm also curious what you think of the language, if you've had time to think about it.\n\nIt's pretty good. I'm primarily a ruby programmer but I use python pretty frequently.\n\nPython is a great language to know, especially if you don't have to ship compiled code.\n\nYeah, I don't really have to ship compiled code", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return (n % 2 == 0) & (n % 3 == 0) & (n % 5 == 0) & (n % 7 == 0) &\n    (n % 11 == 0) & (n % 13 == 0) & (n % 17 == 0) & (n % 19 == 0) &\n    (n % 23 == 0) & (n % 25 == 0)\n\n(It looks like this is C#.)\nSo it's really slow, but it doesn't use any fancy O(n!) stuff.\n\nIt doesn't even use the modulus operator.\n\nIt does, but only as an equality check.\n\nDefinitely not as a modulus operator.\n\nTrue.\n\nHey, there's a third case!\nn % 0 == 0\n\nAh, yes. I forgot about that. I'll fix the code so that it works for that case too.\n\nJust to clarify: I'm not criticizing your code. It's a very nice function, and I agree that it's more readable than the C++ code.\n\nI like the C++ code better:\nint partial_product ( int n )", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n        return n % 2\n    return n % (2**(n-1))\n\nThis is an interesting exercise, but isn't a recursive solution using a stack in a dictionary data structure simpler?\ndigits = {\n    def add_odd_digits(digits, n):\n        if n % 2 == 0:\n            return n % 2\n        return n % (2**(n-1))\n    }\n\nyes, but that's not the point of the article.\n\nNot only is that not the point of the article, it's not even the point of my comment.\n\nSorry, I misunderstood. I thought you meant the recursive version, not the one the OP wrote.\n\nA few years ago I found myself in a similar situation. I ended up with a solution that was similar to the one you did (I think) -- I kept a stack of digits, and then for each digit to add I popped a new stack and pushed the next one into", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n*(n%2) + 1\nIt's in python 3, so it's probably safe to assume that it's \"well optimized\" (or at least optimized by a human).</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n < 0:\n        raise ValueError(\"n must be positive\")\n    return ((n%2) + 1 for n in reversed(int(n)))", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(n > 0 for n in range(1,n+1) if n % 2 == 1)\nThis is the correct solution. I'd like to add a couple of comments:  * You can use `range()` instead of `range(1,n+1)` to avoid the for loop.  * In general, `range(1,n+1)` is not the correct solution. If the requirement is `n digits', `range(n,1)` is correct, and if you want `all' the digits, `range(n+1,1)` is correct.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n % (2 ** (2 ** n))\n\nThis function was created as part of the Numerical Mathematics in C workshop at CppCon 2019.\nhttps://www.youtube.com/watch?v=Vk4VX7FRlW4\n\nVery cool! Is there a link for the whole workshop?\n\nThere are recordings of each session at https://www.youtube.com/playlist?list=PLsWqH_CoR4i8Ejn1oYKWudL-JT2P8dG1\n\nThis is fantastic, thank you.\n\nI love this.\n\nthis is great\n\nThis is great!\n\nnice work</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(set(n, filter(lambda x: x % 2 == 0, range(n))) / 2)\nThat looks really inefficient.\nWhat are the advantages of doing it this way vs. dividing the whole number by 2 and then dividing by 2 again?  If the function is called `digits(n)`, it should work for any integer value of n.\nIf your range of numbers is fairly small, you can get a small speedup in the division algorithm by skipping the division by 2 on the first pass. If you're working in a bigint language you can probably skip the 2nd step as well.  It still uses the same number of divisions (including the filter) in both algorithms, but the latter is more efficient in small ranges.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n\ndigits = lambda n:\n    if n == 0: return 0\n    else: return n % 2", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return 0 if all_digits == 1 else 1*all_digits\n    if n in range(3):\n       return 1*(digits(n - 1) + digits(n - 2))\n\nRe-written in Python.\nn = int(input(\"Enter a positive integer: \"))\ndigits = []\nfor i in range(n):", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return [n**2 for n in range(n) if n % 2 == 0]\nThis is more or less the algorithm that I was using, but I was stuck with how to get a range in a way that would make the function work properly. Thank you!</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n % (2 ** n ** 3) + 1\n\nI think the more interesting test would be to see what happens when you test a negative number.\n\nI just tested on a couple of cases, and it appears to be correct. If you try to divide by zero, you get NaN, which makes sense. If you take a negative number, you get an NAN. If you take a number bigger than the limit of the int type, you get an OverflowError.\n\nDoing some more testing, it seems that it's correct only for positive integers. If you try to test the case where you input a negative number (or a number bigger than an int can handle), it seems to return NaN.\n\nThis is because the code is assuming that you're only dividing two positive numbers. As with anything, you need to write the code for every case.\nI don't think the point of this code is to be a complete calculator. It's just to show that you can take code and use it for more than one purpose.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(map(int,n))", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return [n[1:]*n[2:] for n in range(n)]\nThis works on Python 3.2 for me, and it would have worked on Python 2.7 too.\nThe * operator is the power operator, and it takes two iterables as arguments.  The first one, in this case n, is the iterable that is being iterated over.  The second one, in this case range(n), is the iterable that is returned.\nThis can also be done with range(n).join(',').  But since the output is a tuple, it is not as easy to manipulate.\n\nFor Python 2.7 and before, the function that does this would be named \"mod\" instead of \"pow\"</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return (n / (2 * n)) % 2", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n % 2 == 0", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n&:i for i in range(1,2*n)\n\nIn the version I've seen, there's a third parameter: the length of the result.", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(n>0 for n in range(2,n+2))\nAlso, I would argue that this is not a very good code snippet to use as an example for why Python is a good beginner language, because it is not idiomatic.\nI'd say that it is a very good code snippet to use as an example for why Python is a good _learning_ language, however.\n\nI'm not sure I understand what you mean. In what way is it not idiomatic?\n\nThe idiomatic way to calculate the product of odd digits is:\ndigits = [x**2 for x in range(2, n+2)]\nIf you want the sum of the odd digits, then use\ndigits = [x**2 for x in range(2, n+1)]\n\nThat's a poor example, in my opinion, because it's not idiomatic in any other language.\n\nIt's idiomatic in APL and J.\n\nThe C solution is shorter, faster, and safer, and it is also more idiomatic. It's far more idiomatic to take an array of numbers and apply the algorithm directly to the array.\nAs a side note", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(n**2 for n in range(1, len(n)))\n\nI like the Haskell one. I am a little surprised that I am not seeing more of this sort of code in Haskell.\n\nI am not a Haskell expert, but:\n\\- Haskell doesn't support types (let alone classes) for functions or closures (the main reason why the Javascript one is more verbose).\n\\- Haskell has only a single-return type, so returning a `Maybe Int` wouldn't be possible (you could always return a `Maybe (Int, Int)` I guess).\n\nNo types at all? (I haven't read the language spec, but have heard that it supports some kind of type inference.)\n\nI'm not a Haskell expert, but in this case I'm pretty sure it's not type inference, it's just a single type. In an imperative language you can call a function with \"int\" as an argument. In Haskell you can only pass a \"monad\" to a function. That monad could have type \"Int\" (e.g. Int is a monad) or type \"Int -> [Int]\".\n\nI wasn't thinking of the `Int", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(floor(n % 2))\n\nimport math\n\nn = 10", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return int(n % 2)\n\nn = 123456789\ndigits(n) == 1\ndigits(n) == 2\ndigits(n) == 3\ndigits(n) == 4\ndigits(n) == 5\ndigits(n) == 6\ndigits(n) == 7\ndigits(n) == 8\ndigits(n) == 9\ndigits(n) == 10\ndigits(n) == 11\ndigits(n) == 12\ndigits(n) == 13\ndigits(n) == 14\ndigits(n) == 15\ndigits(n) == 16\ndigits(n) == 17\ndigits(n) == 18\ndigits(n) == 19\ndigits(n) == 20\ndigits(n) == 21\ndigits(n) == 22\ndigits(n) == 23\ndigits(n) == 24\ndigits(n) == 25\ndigits(n) == 26\ndigits(n) == 27\ndigits(n) == 28\ndigits(n) == 29\ndigits(n", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n\n    return n % (n - 1)\n\n    def generate(n):\n    \"\"\"Given a positive integer n, return the digits in order.\n    Return 0 if n is 0.\n    Return -1 if the last digit is not a 1 or a 0.\n    Return -2 if n is a perfect square.\n    Return -3 if n is a perfect cube.\n    Return -4 if n is a perfect fourth power.\n    Return -5 if n is a perfect fifth power.\n    Return -6 if n is a perfect sixth power.\n    Return -7 if n is a perfect seventh power.\n    Return -8 if n is a perfect eighth power.\n    Return -9 if n is a perfect ninth power.\n    Return 0 if n is a perfect tenth power.\n    Return -1 if n is a perfect eleventh power.\n    Return -2 if n is a perfect twelfth power.\n    Return -3 if n is a perfect thirteenth power.\n    Return -4", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return (n * (n & 0x3F))", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    n = int(input(\"Enter a positive integer: \"))\n    for digit in range(1, 10):\n        if n % digit == 0:\n           return digit * n\n    return 0", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n        return n\n    if n % 2 == 1:\n        return (n - 1) % 2\n    for x in range(n):\n        yield x % 2\n    return 0\n\n>>> digits(2)\n2\n>>> digits(2)\n1\n>>> digits(22)\n22\n>>> digits(123)\n123\n>>> digits(123)\n0\n>>> digits(123)\n1\n>>> digits(123)\n2\n>>> digits(123)\n3\n>>> digits(123)\n4\n>>> digits(123)\n5\n>>> digits(123)\n6\n>>> digits(123)\n7\n>>> digits(123)\n8\n>>> digits(123)\n9\n>>> digits(123)\n\nThis is a bit more idiomatic:", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return 0 if n%2 == 0 else n%2*2", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return (n ** 2 for n in range(1,n+2))\nThis function can be optimized to use only O(n) multiplications, if you want to know how, PM me, I have the full code.\nIt also could be optimized to use only O(n) instructions if you write it in x86 assembly!</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n % (n - 1)  # % is modulo\n    return 0\nThat's called \"bit extraction\" and there are many languages that offer a native bit extraction operator.\n(I think I've even used one in shell before.)\nAlso I believe Python has a bitwise AND operator. I'd be surprised if it didn't.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n ** (n % 2)\nIf the digits are in base 10, you can also use the modulus operator:", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return digits(n)/2\n\nThis is the most common definition of digits, but it is not the only one.\nSome implementations use the term \"digits\" to refer to digits from 0 to 9. This\nwould return a different result than the above, but would have the same\nperformance as the OP's.\nA more flexible implementation would count leading zeros, but then it would\nbe called \"digitsize\" not \"digits\".\n\nThe performance difference is significant though. On my machine, the code in the post takes about 10x as long as the'standard' implementation.\n\nWell, the \"standard\" implementation is not the most performant one either.\n\nAnd that's the primary reason that the \"standard\" implementation is so widely known as the \"standard\" one.\n\nThat's one of the reasons why it is widely known, but not the primary one. The primary reason is that it's the one you will find in any CS textbook or online tutorial.\n\nThe primary reason is that it's the most performant _implementation_ of the concept of \"digits\", and the most performant _implementation_ of the concept of \"divide\".", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n if n!= 1 else (n//2 for n in xrange(2**n))\nthat's great, now that i think about it, it's not a good idea to do that.  thank you.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n % 2\n\nNot sure why this is on HN, but I've had this sitting around for a while. It's a nice illustration of a simple optimization.\n\nI think I would have tried to implement this by first doing a naive recursive implementation to see how it looks, then doing the equivalent of the \"divide by 2\" optimization to get it to run faster. It might be interesting to think about why this optimization works.\n\nThere are two ways to do the recursive part in python (or most languages):\n1\\. Return a list of the digits, and then recurse on each of them.\n2\\. Return a function that returns an iterator and an accumulator, and then recurse on each of them.\nThe former is a constant time operation, but the latter is exponential, and the function call overhead dominates.\n\nNeat! Reminds me of this: \n\nWhich reminds me of this:\n\nwhich reminds me of:\n\nReminds me of this:\n\nNice.\nThis reminds me of this:\n\nThat reminds me of this:\n\nReminds me of this:\n\nWhich reminds me of this:\n\nWhich reminds", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n%(2**(n-1))", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n % (n - 2)\nYou should use the ** modulo operator.\nOf course. I thought that it was obvious enough not to need explanation.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return (n % 2) * digits(n - 1) + n", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(isodd(n[2:]) for n in range(0,n))\nI'd suggest using `mod` instead of `isodd` for this problem.\n\nThe original problem uses isodd.\n\nNote that this version doesn't handle the case where all digits are even.\n\nI know. That's the reason I submitted the modification (because I'd prefer the solution without any bugs).\n\nWell, you'd be wrong.\n\nWell, yes, in a way.\nI like the solution that is correct to the specification.\nThe specification says 'given a positive integer n, return the product of the odd digits'.\nIf the specification said 'given a positive integer n, return the product of the even digits', then the version that doesn't handle the case where all digits are even would be the correct solution.\nHowever, I still like the solution that is correct to the specification.\n\nI understand your preference for the spec-compliant version. But really, it's just a matter of taste, and not an absolute right/wrong.\nIf the specification said \"given a positive integer n, return the product of the odd digits, except if all the digits are", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n\n    return odd_digits(n)\n\nOdd_digits(n)\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    odd_digits(1)  == 1\n    odd_digits(4)  == 0\n    odd_digits(235) == 15\n    \"\"\"\n\n    return n % 2", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n         return (n + 1) % 2\nI don't understand this.\nHow does 1%2=1?\nAnd why would you return 0 when all the digits are even?</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if i % 2 == 0:\n          return i\n\nThe only thing that bothers me about this is that it's not generic.  What about numbers like\ndigits(3.14)\n\nIt's a side-effect, but the generic solution to that is to make the function return the list of all the odd digits, and then call whatever function you want with that list.", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n\n    return n*((n&1)%2)*(n%2+1)\n\nSee also\nList of arithmetic functions\n\nExternal links\nPython - A language that uses a variety of mathematical functions.\n\nReferences</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    for n in range(3, 5):\n        return n * (n & 1)\nYeah, and if n is 2, then this would just give you a string of the same character.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    digits_count = 0\n    for i in range(1, 10):\n        if i % 2 == 0:\n           digits_count += i\n    return digits_count", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return (n % 2) ** 0\n    if n % 2 == 1:\n       return 0\n    else:\n       return n ** 2", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n        return n * (n % 2)", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n\n    print 'Even: ', digits(2)\n    print 'Odd: ', digits(1)\n\nThis is just the beginning of your road to professional success.\n\nI've been programming professionally for nearly 15 years, and this is the first I've heard of this.\n\nI was going to say the same thing.\nI've done this kind of thing before, but not to this depth.\n\nThis is actually a well-known and common technique. In the early days of computing, when memory was very expensive, such algorithms were very common.\n\nI was a professional software engineer for ten years, and I don't think I've ever seen it used.\n\nI've been doing professional programming for 8 years now and I've never seen that either.\n\nI've been doing it for 10 years and I didn't see it until I worked with a guy who had been programming for 30 years.\n\nI've done a little bit of professional programming (and 10 years of programming in general), and I've never seen this before.\n\nI've been a professional programmer for nearly 20 years, and I've never seen this either.\n\nI've been doing this professionally for about", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(n for n in itertools.izip(range(2,n+1) if n%2 == 1))\nSo, assuming this is a valid test suite, the current version is broken.   I'll be back later with a fix if no one else does.  (I'm on a phone and typing out long python code isn't fun)</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return [n % (2**(n - 1)) for n in range(n)]", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n * int(n%2)\nWhy not just return (n * 2)?\nI guess this might be more efficient, or there might be a performance difference on different platforms (32-bit versus 64-bit), but I can't see it.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(1 for i in range(1, n + 1) if i%2 == 0)\n[I've fixed the formatting]\nPlease fix the formatting of the last line.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if all(n%2 == 0 for n in range(0,10):) == 0:\n        return 0\n    return n**2\n\nf = digits(233)", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n % (2 ** 2)\nThis seems to be the most direct way of doing it.  Of course, there are some numbers with 5 or more digits that don't have the same product as the sum of their digits.  The closest thing I can find is an approximation of a factorial function, which would make your code more complex, but may be more accurate:", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return [ord(ord(n)) for ord(n) in range(2,n+1)]\n\nSo basically, the following pattern is taken:\n(n)(n+1)\n(n)(n+2)\n(n)(n+3)\n...\n\n(n)(n+N)\n\nSo the first two numbers are summed and the third one is added to the sum. This pattern continues forever.\n\n(n)(n+2N)\n(n)(n+4N)\n(n)(n+6N)\n...\n(n)(n+N2)\n(n)(n+N4)\n(n)(n+N6)\n(n)(n+N8)\n(n)(n+N10)\n...\n\n(n)(n+N2N)\n(n)(n+N4N)\n(n)(n+N6N)\n...\n\n(n)(n+2N2)\n(n)(n+4N4)\n(n)(n+6N6)\n...\n\n(n)(n+N2N2)\n(n)(n", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return (n%2)**2", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n % (n - 1)  + (n - 2)  + (n - 3)\n\nThat's a rather nice function, but it's not clear to me how it applies to the original post.\n\nI am not a java guy, but I am assuming the following will make a valid java method:", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    for i in range(0,n):\n        if n % i == 0:\n           return i\nThis is so simple and elegant I am embarrassed to have not thought of it first.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return [n % 2 for n in range(2, n)]", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n == 0:\n        return 0\n    for i in range(1, 9):\n        if i % 2 == 0 and i == 2 or i % 2 == 0 and i == 3:\n            return i * 2\n    return 0\n\nWhat happens if you give a non-positive integer?\n\nYour best bet is to use a different function for integers that aren't positive:", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n.split(' ').map(lambda d: d % 2 == 1).sum()\n\nThis is so neat. I always hated doing integer addition with a bunch of ints and then doing a mod on the result to get the result to an integer. This is one of those things that I would probably use regularly but never think of creating myself.\n\nI'm getting a syntax error (missing \")\" in your example.\n\nThanks. Fixed.\n\nNice. A trick I've been using lately is to use the \"in\" operator to parse a list of strings to a list of ints:\n\nI've been using this trick for a while, but I always forget it exists.\n\nHow is this different from [0]?\n\nYour version doesn't take 0 as the argument.\n\nI don't understand how that would be different. If all of the numbers are 0 then they are the same anyway.", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n ** 2\n(This was the example used in the article.)\n\n\"n ** 2\" could be written as \"n**2\" and would still be valid Python.\n\nI noticed that too, but I wonder if the author uses Python so much that \"**2\" is easier to write and read than \"n**2\". I would definitely start thinking \"**2\" is a function if I saw it in someone else's code.\n\nIt's a common shorthand. I'm sure you've seen it elsewhere (e.g. '*2' for multiplication).\n\nAlso, as a slight nitpick, I believe Python's standard math library uses ** for exponentiation. I always have to think a second when I see '2**' in an expression.\n\nI always find these types of \"simple\" examples hard to read.\n\n1\\. Create an arbitrary function.\n2\\. Figure out the type of its output.\n3\\. Try to come up with a name for the function based on what you've learned.\nI'm not sure what is particularly complex about these steps.\n\nI can't see that the output of a function is something that is \"known\" when", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n + [n%2 for n in xrange(n)]\nIt should be noted that this is not the same as the usual (n % 2) % 2.\n\nI believe this is called the Chinese Remainder Theorem. The title of the article is a bit misleading. I had to read the article to find out that it was not related to the Chinese Remainder Theorem.\n\nIt's not the Chinese Remainder Theorem because the article's function only works on a finite number of digits.\nThe Chinese Remainder Theorem works for any non-negative integer, so it will give you the last digit of your number if it's 0, 1, 2, or 3.\n\nI think it's misleading to call this a digit sum, as it's not really calculating the sum of the digits.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return [0 for i in range(n)]\nThat is a really awesome trick and it makes the code super easy to read. I can't believe I've never thought of that before. Thanks for sharing it.\nIt's a good trick but can be a little bit tricky with negative numbers.  You have to put the test at the end.      digits(1) == 1     digits(-5) == 0     digits(34) == 1     digits(-534) == 0  One more nice thing about it is that it returns 0 if all of the digits are even or all of the digits are odd.  It doesn't return an arbitrary 0 if the first digit is odd.\nI didn't know you could do the last thing with a return 0 instead of return None. Good to know.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(n ** (2 ** i))\nIt's cute, but I'd be tempted to implement it recursively as a lambda expression.\n\nYour lambda expression is really short, but the OP's expression is much more readable, IMHO.\n\nIt's hard to tell from the code snippet. The lambda expression can be much more readable once you understand how lambda functions work, but of course it's not going to be nearly as readable to a new programmer.\n\nIt's always useful to remember that those coming to python from a maths or CS background will have the right tools to write the lambda solution, and those coming from a language background won't have the tools to write the lambda solution.\nSo it's really a question of which audience you're aiming at.\n\n_\"So it's really a question of which audience you're aiming at.\"_\nOr which audience you want to teach.\nI like that the OP didn't use lambda functions; I'd be tempted to use them to solve the problem, and if the OP had used them I might have assumed that's what I was supposed to do.\n\nI've got to agree. I am a python newbie, and I tried to", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n        return n * 10\n    else:\n        return n * 9\nI guess it could be refactored a little bit, but that's pretty close to the Python version.  The author of that code probably wasn't thinking of Python at all.\n\nIt could be refactored to use the same style as the original Python version, but I think that would be overkill. I think the original Python version would be clearer if it was written more like the author's C version.\n\nMy two cents:\n1\\. You shouldn't use \"else if\" as a standalone statement; this is a C# \"feature\" that Python has wisely avoided. Use a traditional \"if else\" instead.\n2\\. Python's ternary conditional is clearer than the C version.\n3\\. This is one of the few cases where the Python ternary conditional is a good fit.\n\nIn this case the ternary is being used as a function: it has an input, and it returns a value.\nIn Python, if you have a variable of type \"function\", you can't use", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return [n % 2 for n in range(n)]\n    print(digits(30))\nI don't know what language this is, but that's not very pythonic. Also, unless n is 0 or 1, it's not guaranteed that digits(n) will evaluate to a single integer.\nPython, and why not?\nIt's an anonymous function, and you're just passing in the *function* itself to a different function. The fact that you can do this is one of the things that makes python awesome, but it's not pythonic (and it's also not very common to do).\nAh. Thanks for the explanation. I understand now.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return [sum(x for x in [n%2 for n in range(3, n+1)]) for x in range(1, len(n)-1)]\nI can't imagine how you could possibly mess that up and get the result you did.\nThe code you posted is just the same except it returns a list.\nI know but I cant figure out how I was messing up the original\nWell, you weren't. The problem is in your understanding of what the function should do.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n**2", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n**(n-1)/2", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(odd_digits(n))", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n \\ | \\\n    | (odd(n))", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n[:i]\n    if n[0] == 0 or n[0] == 1:\n        return 0\n    return n[i:]", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return int(n % 2)", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return (n % 2) ** (n % 3) + (n % 5) ** (n % 7) + (n % 9) ** (n % 11)\n\nReminds me of the challenge in the Lisp 1.5.1 README:\n(defun factorial (n)\n  (if (< n 2) 1\n      (factorial (- n 1)))))\n\nThe factorial is interesting for me in the factorial of two (12, 6) equals 6*6*6*6*... = 216.\n\nI think that's just a coincidence.", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(odd_digits(n))", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return digits_odd(n)\nI think this is faster than \"int digits_odd(int n) { return n % 2 == 0; }\"</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n\n    # The computation is straightforward.\n    return n % 2**n", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return int(n%2)\nI'm trying to find a way to turn this into an exercise in recursion.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n == 1:\n        return n\n    else:\n        return (n % 2)\n\nSee also\n Fibonacci sequence\n\nExternal links\n Integer Sequences - contains more information on this sequence\n\nReferences</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(int(o) for o in reversed(n))\nWhat's reversed() do?</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n.split(' ')[0..(n.length - 1)]\nThe author doesn't even bother to explain this one.\nI'm guessing the name has something to do with the fact that the value of n is the digits of n and n.length-1 is the length of n minus 1.\nIt is still very unclear.\n\nWhat is unclear?\nn.split(' ')[0..(n.length - 1)]\nmeans to take n, split it on the string'', and return the remainder.\n\nAh, thanks.\n\nI don't know if it's a good thing or a bad thing that I was able to \"get\" all of these without any explanation.\n\nI suppose it's a good thing.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return int(n % 2)\n    def is_even_digit(digit):\n    \"\"\"Return True if the given digit is even, False otherwise.\n    \"\"\"\n    return digit % 2", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n if n == 1 else (n / 2) ** (2 ** ((n % 2) == 0))\n    def product(n):\n    \"\"\"Given a positive integer n, return its product.\n    Return 0 if n is not a factor of itself.\n    For example:\n    product(1) == 1\n    product(5) == 25\n    product(11) == 55\n    \"\"\"\n    return n if n == 1 else n ** n\nSo we have this:\n>>> from operator import pow\n>>> from operator import digit\n>>> n = 3\n>>> n ** n", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return int(n**2)", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return sum(int(str(int(i))) for i in range(2, len(n)))\nYou should probably also check that the input is an integer.\nI also don't like how you're using `sum` here, but I don't think it's a big deal.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return (2 ** n) if n % 2 == 0 else (n ** 2)\n\nI love that it's used in production.\n\nI wonder how long it took before it was found that there was a bug in the implementation.\n\nIt's a copy of the Python one:\n\nIt's not. The Python one is a general \"product of the odd digits\" function, the one in the link has an extra test for evenness to handle 1.\n\nAh, it is. I thought it was just a clever use of the magic 2**n :)\n\nSo is it two times the biggest power of two which is divisible by 10, or is it 10 times the biggest power of two?\n\nThe former. The modulo operator is only used to test divisibility by 10.\n\nI am impressed. I'm reading the code and it just makes sense, like it was written by a mathematician.\n\nThe code is most likely from the paper. I believe the paper is from 1988.\n\nYes. The paper is from 1988. The code was written in 1991 for the RPL library by Peter Kogge and myself.\n\nIf you want to know why so", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    for i in range(1,10):\n        if n%i == 0:\n           return n%i\n    return 0\n\nfrom collections import defaultdict\nn = 100\ndigits_default = defaultdict(int)\nfor i in range(1,10):\n    digits_default[i] += 1", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(int(x) for x in range(n,0,1))\nI think you meant to say      return int(sum(int(x) for x in range(n,0,1)) )  That being said, you could've just written      return sum(int(x) for x in range(n,0,1))</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    while n > 1:\n        product = digits(n-1) * digits(n-2)\n        if n % 2 == 1 and n % 4 == 1:\n           product += digits(n-3)\n    return product", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n % 2**(n-1)\n\ndigits(1000)\ndigits(1337)\ndigits(2.718281828459045)\ndigits(19.4770588235359)\ndigits(223)\ndigits(3)\ndigits(12)\ndigits(24)\ndigits(36)\ndigits(99)\ndigits(25)\ndigits(19)\ndigits(85)\ndigits(87)\ndigits(234)\ndigits(10)\ndigits(15)\ndigits(7)\ndigits(10)\ndigits(3)\ndigits(2)\ndigits(4)\ndigits(0)\ndigits(5)\ndigits(1)\ndigits(4)\ndigits(2)\ndigits(5)\ndigits(2)\ndigits(8)\ndigits(1)\ndigits(8)\ndigits(2)\ndigits(3)\ndigits(0)\ndigits(4)\ndigits(2)\ndigits(", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n**(n-1)\n\nThis is pretty simple. The interesting part is the part where it checks if the numbers are even or odd.  The code might look like this:", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n == 0:\n        return 0\n    for i in xrange(1, (n+1)/2):\n        if n % i == 0:\n           yield i*i\n    return 0\n\nSee also\n Radix sort\n Prefix sum\n\nReferences\n\nExternal links\n Python function to find the sum of digits</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n         if n % 2 == 0:\n            return n[2:]\n    else:\n           return n[1:]*n[2:]", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n == 0:\n       return 0\n    for d in range(1, n):\n       if n % d == 0:\n          return n*d\n\nThat's pretty neat, I've always seen this kind of thing (it's a pretty common example of using Python to process input that is formatted the same way more than once) as a place where a list comprehension really comes in handy. In this case you can just write:", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n**2\nThis code doesn't work for me. I get 0 for all inputs.\n\nNeat. I was about to post the same thing, but I was going to use Python.\n\nYou should do that! :)\n\nI made this last night and posted it to reddit. Some people suggested that it should also output all the digits, not just the odd ones.\n\nPython:", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return(n*(n>>1)%2)&0xff\nIs this really the same as the above code? I'm confused.\n\nNo, it's not the same. What you've done is to take your list of digits and recursively build up the list of digits until you've found the first even digit, then you return the result of taking the rest of the digits and multiplying by 2 to get the result.\nSo, if you give it the number 0, it will return 0, because all of the digits are even. If you give it 1, it will return 1, because the first digit is odd, and all of the rest of the digits are even. If you give it 235, it will return 15, because the first digit is odd, the second digit is even, and the rest of the digits are all even.\nIn contrast, the code I posted takes your list of digits and returns the nth power of each digit and then 0xFF. So, if you give it 0, it will return the 0th power of each digit, or 0x1. If you give it 1, it will return the 1st power of each digit, or 0x2.", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    for digit in range(1, n+1):\n        if digit%2 == 0:\n           return digit*2\n\nThis works for up to n=22; it is not a general solution.\n\nI don't think that's the question. It is asking for a solution up to n=100.\n\nYes, my solution is for n=100.\n\nIt's not. Try out digits(100).\n\n(Edit: I see. I was assuming the input was a string, not an integer,\nwhere the first digit was stripped off. I've edited my answer to include\nthat.)\n\nHint: This is a relatively easy problem to solve using the Knuth-Morris-Pratt algorithm.\n\nI'd say this is not a problem that needs to be solved. What does it matter if you can divide by all integers in the range [0, n] for some integer n?\n\nIt was a question on a homework assignment. The assignment also asked for a solution to the problem with n=10.\n\nWell, of course it's solvable by hand. What the", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return ((n & 1) ** (n % 2))\n    def right(n):\n    \"\"\"Given a positive integer n, return the rightmost digit of the integer.\n    Return 0 if n is not even.\n    For example:\n    right(123) == 1\n    right(233) == 3\n    \"\"\"\n    return n % 10\n    def as_decimal(n):\n    \"\"\"Given a positive integer n, return its decimal equivalent.\n    Return 0 if n is not even.\n    For example:\n    as_decimal(4) == 4\n    as_decimal(125) == 0\n    \"\"\"\n    return n % 100\n    def left(n):\n    \"\"\"Given a positive integer n, return the leftmost digit of the integer.\n    Return 0 if n is not even.\n    For example:\n    left(123) == 1\n    left(233) == 3\n    \"\"\"", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n & 1 == 0:\n       return 0\n    return n * (n - 1) + 1", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    for i in xrange(n-1):\n        return i * (i & 1)", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    result = 0\n    while n >= 1:\n        result += n % 2\n        result += n % 2\n    return result\nYeah, but that's not what I'm talking about. I'm talking about a larger number of digits.  For example, what would the code be for the first two digits of the square root of two?</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n\n    return sum(map(int, n))\n    #' digits", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    odd_digits = [n[i:i+2], n[i+3:i+6]]\n    return [n[i:i+2], n[i+3:i+6]]*odd_digits", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return int(n, 2)\n\nThe following snippet will probably be useful to others. I don't know if it's the most efficient way, but it's something that I can read and understand easily:</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return [n[1]*n[2]*...*n[n-1]]\nYou can do it in one line with this:      return [n[1:]*n[2:]*...*n[n:]].append(n)\nI suppose that's more compact, but I don't know if that's faster.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n == 0:\n        return 0\n    return n * digits(n - 1)", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return int(n/2) * int(n/2) + int(n/2) + int(n/2) * int(n/2)\n\n>>> import operator\n>>> digits(1) == 1\n>>> digits(4) == 0\n>>> digits(235) == 15\n\n>>> def f():\n    \"\"\"Given a positive integer n, return the product of the even digits.\n    Return 0 if all digits are odd.\n    For example:\n    f(1)  == 0\n    f(4)  == 4\n    f(235) == 72\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return int(n/2) * int(n/2) + int(n/2) + int(n/2) * int(n/2)\n\n>>> f(1) == 0", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    for i in range(1,n):\n        product = 2*i + 0\n        if all(i % 2, i % 3) == 0:\n           product += (i % 5) + 1\n    return product\nThis is absolutely brilliant, I can't believe I've never seen this before!</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n == 0:\n       return 0\n    else:\n       return [n % 2 for n in range(1, n)]\nAnother way to do it without a loop is with a map.\n\nIf you just want the first n digits, a map would work. If you want all of them, a map or loop is needed. I opted for the loop because it is easy to modify to support other inputs and output types.\n\n\"Map\" was probably the wrong word. It's just one of those things that if you try to do it the \"right\" way, you end up with something that looks a lot like a map.\n\nPython has a built-in function called nth that does exactly this.\n\nI was going to say this but then realized that the OP is showing it as an exercise for learning the Python syntax (whereas the built in function is an exercise in implementation of a function).\n\nGood point. It's important to practice writing functions and learning new constructs.\n\nIn JavaScript, you could do this:\n(function() {\n// n is a parameter\nvar n = function(n){", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n\n    return sum(n[0:n.index(0, n.index(0, n.index(0, n.index(0, -1)))] for n in range(n))[0])\nThis is not tail recursive.\nThe error is in the while loop. It must be rewritten as:\nwhile True:\n    if n < 10:\n        return n\n    else:\n        return n\nWhere the \"n\" is the current iteration.\n\nWhile the OP is correct in stating that a sum is not tail recursive, a more precise explanation of why it is not is required. The reason is that the function is not a function in its own right but is simply a combination of a function with one argument and a loop.\n\nYes, that was the point I was trying to make.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(odd_digits(n))\nThat's the general idea, yes.\nThe code you wrote doesn't work for arbitrary positive integers though.       digits(1) == 0      digits(4) == 0      digits(235) == 0  What about      digits(123)  What about      digits(123456)  What about      digits(123456789)  What about      digits(23456789012345678901234567890123456789)</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(int(n % 2))\n\nReminds me of the old joke...\n\nHow do you make a million dollars?\nStart with two million...\n\nI learned the same trick from Knuth's art of computer programming. It is from an old Russian joke.\n\nReminds me of the old joke...\nHow do you make a million dollars?\nStart with two million...\n\nReminds me of the old joke...\nHow do you make a million dollars?\nStart with two million...\n\nReminds me of the old joke...\nHow do you make a million dollars?\nStart with two million...\n\nReminds me of the old joke...\nHow do you make a million dollars?\nStart with two million...\n\nReminds me of the old joke...\nHow do you make a million dollars?\nStart with two million...\n\nReminds me of the old joke...\nHow do you make a million dollars?\nStart with two million...\n\nReminds me of the old joke...\nHow do you make a million dollars?\nStart with two million...\n\nReminds me of the old joke", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return (n % 2) + (n%3) + (n%5) + (n%7) + (n%9)\n\nThis is a quirk of the C language that it's hard to get around. I'm not sure how it was actually implemented in the first place, but it's hard to see how the C programmers would have gotten it to work any other way.\n\nYou could use C99, which adds a bit to the language (to be precise, a bitwise logical operator). It's not even limited to ints.\n\nI would have thought that a new language would have made the same mistake.\n\nIt wouldn't have to. You could just make a function that divides by 2 and returns the remainder.\n\nC99 has that as well.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n**2\n\n>>> digits(100)\n>>> digits(1000000)\n>>> digits(1)\n\n[0, 1, 4, 3, 5, 6, 9, 2, 8, 7, 3]\n\n>>> digits(1000)\n>>> digits(1000000)\n\n>>> digits(1000)\n>>> digits(1000000)\n\n>>> digits(1000)\n>>> digits(1000000)\n\n>>> digits(1000)\n>>> digits(1000000)\n\n>>> digits(1000)\n>>> digits(1000000)\n\n>>> digits(1000)\n>>> digits(1000000)\n\n>>> digits(1000)\n>>> digits(1000000)\n\n>>> digits(1000)\n>>> digits(1000000)\n\n>>> digits(1000)\n>>> digits(1000000)\n\n>>> digits(1000)\n>>> digits(1000000)\n\n>>> digits(1000)\n>>> digits(1000000)\n\n>>> digits(1000)\n>>> digits(1000000)\n\n>>> digits(1000)\n>>> digits(1000000)\n\n>>> digits(1000)\n>>> digits(1000000)\n\n>>> digits(1000)", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return (n%2) * sum(int(n%2), odd=(n%2, 0))\n\nIt might help if you explain how you came up with your solution.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(map(str, n))\nHow does that work?\nIt's a recursive function that calls itself recursively.  The inner function is a map function that adds the digit to the string and returns it.  sum() sums the values of the recursive call (returned by map()) and returns the sum.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n*(n - 1) + n*(n - 2) + n*(n - 3) + n*(n - 4) + n*(n - 5)\nThis may be an argument against python...\nThat's hardly an argument against Python, it's a one-line function.  Any language can do that.\nIt is an argument against one-line functions.\nHow so?  Or is this just snark?\nI would prefer that if a one-line function is created, it is better to create a two-line function.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return product(ord(n))\nThat's not very efficient, because `ord(n)` requires at least `n/2` loops (since it's a remainder and you have to check for 0).\nAnd it's not very intuitive either. You'd expect it to return the result of the multiplication of the odd digits, but it actually returns the result of the multiplication of the even digits.\n> You'd expect it to return the result of the multiplication of the odd digits, but it actually returns the result of the multiplication of the even digits.  I think it's intended to be a joke.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return [n % 2 for n in xrange(3)]\n\nIt is an interesting observation that this is almost the same as the naive algorithm for doing the same thing.\n\nI was trying to find a way to get the leading digit from a number but I came across this one and thought it was really neat.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n < 0:\n        return 0\n    else:\n        return n*(n-1)*(n-2)*(n-3)*...*(n-9)+1\n    This code is not perfect and I'd like to have some other opinions.\n    For example, it doesn't work with some numbers.\n    For example, it doesn't work with 1, 2, 6, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return [n[1:] for n in [2,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,57,59,61,63,65,67,69,71,73,75,77,79,81,83,85,87,89,91,93,95,97,99,101,103,105,107,109,111,113,115,117,119,121,123,125,127,129,131,133,135,137,139,143,145,147,149,151,153,155,157,159,163,167,169,173,175,177,179,181,183,185,187,191,193,195,197,199,201,203,205,207,209,211,215,217,219,221,223,225,227,229,231,233,235,239,241,243,245,247,249,251,253,255,", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n       return n*(n - 1)\n    else:\n       return n*(n - 2)\nThat's the most succinct version of the algorithm I've seen.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return (n & (n&1))[0:n-1]\nYou are making a copy of n each time you call the function. It might be more efficient to use the result of the first iteration of the loop to compute the second iteration.\nSo you'd write this:             def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\"\n    n = int(n)", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return n % 2", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    if n.isdigit() or n.isdigit() == 0:\n        return n\n    return n*(n-1)*(n-2)*(n-3)*...*(n-9)\n\nSince this is a Python-only thread, I'll just paste in the code I came up with.", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return (n % 2 == 0) & (n % 3 == 0) & (n % 5 == 0) & (n % 7 == 0)\n    def is_prime(n):\n    \"\"\"Return 1 if n is prime, otherwise 0.\n    Examples:\n    is_prime(3) == 1\n    is_prime(7) == 0\n    \"\"\"\n    return (n % 2 == 0) & (n % 3 == 0)\n    def next_prime(n):\n    \"\"\"Return the next prime number larger than or equal to n.\n    Examples:\n    next_prime(12) == 13\n    next_prime(23) == 29 \"\"\"\n    return n % next_prime()\n    def square_root(n):\n    \"\"\"Return the square root of n.\n    Examples:\n    square_root(123) == 4\n    square_root(1677) == 7.836393801\n    \"\"\"", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return int(n) % 2\n    if n % 2 == 0:\n        return 0\n    else:\n        return int(n) % 2 + int(n - 1)", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n\n    return n % (n+2)\n\nWith respect to your edit, the function can be called with a negative integer and return a negative number. It can't be called with an integer and return a negative integer.\n\nI meant that, since (n % (n+2)) is negative, you can't use that to get a negative number.\n\nThis is correct, it is a function and not a function expression.\n\nOops. I meant that it would return a negative number if the argument is negative, not that it is a function expression.\n\nOoh I see, my apologies.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return sum(digits(n), 2)\n>>> sum(digits(1), 2)\n0\n>>> sum(digits(2), 2)\n1\n>>> sum(digits(3), 2)\n2\n>>> sum(digits(5), 2)\n6\n>>> sum(digits(6), 2)\n9\n>>> sum(digits(9), 2)\n27\n>>> sum(digits(5), 2)\n>>> sum(digits(5), 2)\n27\n>>> sum(digits(10), 2)\n>>> sum(digits(11), 2)\n>>> sum(digits(12), 2)\n>>> sum(digits(13), 2)\n>>> sum(digits(14), 2)\n>>> sum(digits(15), 2)\n>>> sum(digits(16), 2)\n>>> sum(digits(17), 2)\n>>> sum(digits(18), 2)\n>>> sum(digits(19), 2)\n>>> sum(digits(20), 2)\n>>> sum(digits(21), 2)\n>>> sum(digits(22", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return [1, 4, 15]\n>\nI don't know if this is a joke or you really want to solve a different problem.</s>", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n\n    return sum(n.odd_digits() for n in range(2, n+1))", "def digits(n):\n    \"\"\"Given a positive integer n, return the product of the odd digits.\n    Return 0 if all digits are even.\n    For example:\n    digits(1)  == 1\n    digits(4)  == 0\n    digits(235) == 15\n    \"\"\" \"\"\"\n    return (n ** 2 for n in range(1, n + 2))\nAh yes, another clever Python approach to a problem that can be solved with the modulus operator.\n\nExcept that you can't multiply by 2 in a functional language!\n\nYou can't even use the modulus operator.\n\nYou can't even use the modulus operator in a functional language?\n\nYou can't even use the modulus operator _on integers_.\n\nYou can't even use the modulus operator on integers in a functional language?\n\nYou can't even use the modulus operator on integers in a functional language _without wrapping them in an integer type_.\n\nYou can't even use the modulus operator on integers in a functional language without wrapping them in an integer type in a functional language without wrapping them in an integer type in a functional language?\n\nYou can't even use the modulus operator on integers in a functional language without wrapping them in an integer type in a functional language without wrapping them in an integer type in a functional language _because they are floating-point numbers_.\n\nYou can't even use the modulus operator on integers in a functional language without wrapping them in an integer type in"]]