[["from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(2,len(numbers)):\n        for j in range(2,numbers[i]):\n             if numbers[i][j] > 1.0:\n                   numbers[i][j] = 1.0\n\n    return numbers\n\ni like the idea, but why not just do:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers\n\nWhat about negative numbers?</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\nWow, that's pretty easy. I was expecting it to be something complicated.\n\nYeah, it's easy, it's just a trivial call to map.\n\nI'd suggest a new title:\n\"How to apply a scaling transform to a list of numbers.\"\nI expected it to be about the details of mapping.\n\nWhen I read \"from typing import List\", I was expecting a clever way to get a list of numbers with map, sort, and filter.\n\nNo, you were looking for the standard library \"itertools\" module.\n\nI have just discovered this module. It is amazing.\n\nThat is a pretty common library, but you're right it is amazing.\n\nIt is common, but it is good.\n\nIf this is an example of \"awesome\" code, I'm going to start my own programming language.\n\nIt's easy to think that you're the only one who can write good code.\n\nI don't think that at all. This is just the kind of thing I see on a daily basis from my fellow college students. I'm working on a tool to help me find errors in their code, but I'm having a hard time finding those", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers\nI don't get it...\n\nIt's a _programming_ joke.\n\nI was hoping for a mathematical explanation :(\n\nWhen you want to scale up or down a list, you don't need to change the elements, you just need to change the scale of the element.\nFor example, if you have a list of numbers:\n[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]\nYou can rescale that list to the following with no changes:\n[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]\nTo go the other direction, you could scale it down:\n[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1]", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(lambdax: x.fmt('%.1f')).map(lambdax: x*(1.0/x)).map(lambdax: x.fmt('%.1f'))</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = sorted(numbers)\n    numbers = numbers.sort(key=lambda i: i / n)\n    numbers = [numbers[-1], numbers[-2]]\n    numbers = numbers.filter(lambda i: i / n)\n    numbers = [numbers[-1], numbers[-2]*(numbers[-1]+1.0/numbers[-2])/numbers[-2])\n\nI use this all the time to print things to the screen. Also, I don't think the author is aware that the default key binding for 'r' is'rescale-to-unit'. I think it's more of a default, as I don't remember explicitly setting that binding.\n\nThe default binding for 'r' is'redo'. It was changed recently in 2.7, but the docstring still says'redo'.\n\nI love that you can use any operator as a method.\n\nI don't really like that, because it's hard to remember which operator is a method and which is just a standard function.\n\n1. Python supports comments for docstring.\n2", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\n    return List(numbers.map(lambda x: (x + (x - 2.0)))).sort()\n\n    def round(x: float) -> float:\n    \"\"\" Given a float number x, round it to the nearest integer\n    >>> round(1.0)\n    1\n    >>> round(3.0)\n    3\n    \"\"\"\n\n    if x < 0:\n        return -x\n    else:\n        return x\n\nx = rescale_to_unit(numbers.pop(0))", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    return numbers.map(lambda x: x * 0.5)\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return [numbers[0], numbers[1]/numbers.size()]\n\nI can't see a unit test for this, which is quite sad.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\nI love Python, but its type system is almost totally broken.\n\nCare to elaborate?\n\nIt's a dynamic language. As such, it lacks most of the expressiveness of a static language.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    # We can't change a number without changing its index\n    # so we add the current index to the new index\n    new_indices = [0] * len(numbers)\n    # For numbers smaller than 1, we want to make them 0.\n    # For numbers larger than 0.5, we want to make them 0.5.\n    # For numbers between 0.5 and 1, we want to make them 0.75.\n    # For numbers between 1 and 2, we want to make them 1.\n    # for numbers between 2 and 3, we want to make them 1.25.\n    # for numbers between 3 and 4, we want to make them 1.5.\n    # and for numbers between 4 and 5, we want to make them 1.75.\n    # Notice that the smallest number stays 0\n    # for all of these transformations\n    # (It is fixed to the index of 0, so it doesn't change.)\n    # We also have to add 1 to the index of the largest number.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(x*0.25 + y*0.5 + z*0.75 + w*1.0)\n\n>>> a = List(4.1, 4.3, 4.5, 4.7, 5.0)\n>>> rescale_to_unit(a)\n[0.1, 0.23, 0.48, 0.73, 1.0]\n>>>\n\nTry this one:\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    numbers = numbers.map(x => x**2).sort()\n\nIt's not that bad. You can't compare python and haskell when they're used for two completely different purposes.\nHaskell is an amazing language for math/CS stuff. In fact, when I'm writing a mathematical program, I wish I could use haskell instead of python. The thing is, when I'm writing a mathematical program I often need to write a GUI to visualize stuff, and then I have to reach for python.\n\nI'm pretty sure that's what the original poster was getting at. It's not an honest comparison of the languages, it's just a bit of fun.\n\nCute, but it's a pretty stupid argument. It's like saying \"TIL that in Python, you have to import Python to use it\".\n\nOr \"TIL in Python, you have to write a line of code to get the program to do anything\".\n\nAnd in Haskell, you have to tell the computer to even start the program.\n\nAnd in Python, you have to wait for the computer to finish whatever it's doing before you can begin.\n\nI think", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(1, len(numbers)):\n        float new = numbers[i]\n        float old = float(i)\n        float new_div = (1.0 / old) * float(new)\n        numbers[i] = new_div\n    return numbers\n\nSee also: \n\nWhat does it mean that this is 'from typing import List'? What is typing?\n\nIt's a funny way of saying \"here is the library that contains the function List.rescale_to_unit\"\nThis is a function that is defined in the library called \"typing\"\nYou can get the library \"typing\" by running \"pip install typing\"\n\nThank you!\n\nI think a better title would have been something like \"The \"from typing import List\" statement is the fastest way to get a function that does exactly what you want\", which in my opinion would be a lot more useful to people than the current title.\n\nI think it's a little amusing that we're getting so worked up about the", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    def linear_transform(x: float):\n         return (x + 1.0) / (x - 1.0)\n         return linear_transform\n    return list( rescale_to_unit(numbers))", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [x for x in numbers if x >= 2]\n    return (0 if x < 0.5 else 1.0 * x for x in numbers)\n\nYou might also want to look at the 'ordinal' module from the numpy package.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in range(len(numbers)):\n        numbers.append(i *.1)\n    return numbers</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(lambda x: x / 2.0)\nThis is great! I've been looking for something like this for a long time.\n\nIt's also a builtin function in numpy\nnumpy.transpose(x, axis = 0)\n\nIs there any reason to use numpy instead of python? I'm not familiar with numpy, but I thought that it was a library that does pretty much what python does. So shouldn't numpy be included in the python distribution?\n\nIt is included in the python distribution. The only reason I could see for using numpy instead of python would be if you're doing numerically intensive stuff that requires a python interpreter with numpy loaded to be more performant than using python's built in functions.\n\nThis will also work as a drop-in replacement for the _list_ module in a Python 2.6+ version, and is likely to be faster (at least in some cases) than the _list_ implementation.\n\nThat's what I thought:\n>>> import list\n>>> print(list(float(0.0), float(1.0), float(3.0), float(4.0), float", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers[0:numbers.size()]\n    return List(numbers.map(float(numbers[0]))*numbers.map(float(numbers[1])) + 0.0)\n\n>>> numbers = List()\n>>> rescale_to_unit(numbers)\n[0.0, 0.25, 0.5, 0.75, 1.0]\n\nYeah, and if you want to use numpy, you can use:\nfrom numpy import *\nnumbers = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\nrescale_to_unit = np.reshape((0, numpy.max(numbers), 1))\n\nNice. With numpy the return list can be a tuple and with the zip code optimization, it's probably faster.\n\nNo, because you can't zip with a list like you can with a tuple.\n\nI think you can, but you have to use a list comprehension.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\n    numbers = numbers.sort()\n    numbers.map(lambda i: i/numbers.size)\n    numbers.map(lambda i: i/numbers.size, lambda t: t/numbers.size)\n    return numbers</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\nYou should import python first, or your code is only going to be run on python 2.4\n\nI'm pretty sure this is what is meant by \"the Zen of Python\"\n\nThis is awesome, but it has a huge limitation: it won't work if you change the length of the list. I've worked on more than one project that does that.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    transform = 2.0/numbers.size\n    for i in numbers:\n       transform = transform * i\n\n    return list(zip(*transform), zip(*transform))\n\nHow is this news? The Python 3.0 documentation has this as part of the built-in function List().\n\nYeah, this was added in Python 3.0, and has been in the docs for a while. The title is somewhat misleading.\n\n_Python 2.5-3.1 and CPython 2.4.x: type(sorted(list(range(10)))).__class__._\nI wonder how many people reading this will actually understand this.\n\nI only understand it because I had to help my girlfriend debug some java code where she needed to call __class__ for something.\n\nThe title should be changed. This is for Python 3.0 and is not a new feature.\n\nThis is mentioned in the docs as part of List() in Python 2.5\n\nI'm confused by the 2.5-3.1 and 2.4.x stuff. Are those versions of Python not fully compatible with one another?", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(0.0, 1.0/numbers.size[0]),\n    List(1.0/numbers.size[0], 1.0/numbers.size[1]),\n    List(0.0, 1.0/numbers.size[1]),\n    List(1.0/numbers.size[1], 1.0/numbers.size[2])\n\nIt's an interesting example of how to use a type-based programming language (like Haskell or Scala) to make a Python program more concise.\n\nI think the lack of a type system in Python is a real problem when working with types, or even basic data structures like the above list. It's easy to forget that `numbers.size[0]` is the number of items in the list, not the length of the item. It's also easy to forget that `numbers.size[1]` is the number of items in the list, not the length of the first item.\nOn the other hand, I think that the fact that Python is dynamically typed is a real strength, because the programmer can just concentrate on solving the problem", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return [numbers[i] for i in range(0, len(numbers) - 1)]\n\nI'm not sure that's the most idiomatic way to do it. I'd probably do something like this:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n        numbers = numbers.map(np.log).flatten()\n        return numbers.map(numbers.map(np.log10))\n\nReally? I can't tell if you're joking.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\n    n = len(numbers)\n\n    return List(numbers.map(x -> float(x ** 2.0 - 1.0))\n   .map(x -> float(x / n))\n   .map(x -> float(x * n))\n   .map(x -> float(x / n * n))\n   .map(x -> float(x / n * n * n))\n   .map(x -> float(x / n * n * n * n)))</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(0,len(numbers)):\n        numbers[i] = 0.0\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i, x in enumerate(numbers):\n        y = x / (numbers[i] - 1)\n        numbers[i] = y\n\nDid you take this from \"The Little Schemer\"?\n\nNo, I haven't read it. It's a fairly simple idea, so it's not surprising that it's been done before.\n\nNice!\n(I don't know whether it was in The Little Schemer or not, but I think the implementation is in the chapter of the second edition on recursion, though it's been a while since I read it.)\n\nThis is not the first time it has been done (at least not on HN) but it is a nice example.\n\nI'd be interested to see it, though. Do you know the title of the HN post?\n\nThis is definitely in chapter 3 of the Little Schemer.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List((numbers.max() + 1.0) ** (numbers.min() / (numbers.max() - 1.0)))\n\nBecause it's a function, this is an awful candidate for a type, because you can't pass it around as a type, you'd have to write something like\n\nx = rescale_to_unit(x)\n\nand even that's not idiomatic.\n\nIf you want a function, write a function. If you want a type, don't write a function.\n\nI've got to say, I really like the idea of this sort of API in general, but I've been using a library for Python (\n) for some time now, and I really prefer it.\nIf you want to write a lot of different code, but have the types match, it's a really nice way to do it.\n\nI'm not really sure what the point is. If you want to put your types on the variable side of a function, then just do it, it's not that hard.\n\nPython has the \"list\" type, which is a list of type <T>, where T can be of any type.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\nwhere is\n\nis  is a function that maps every element of the list (of numbers) to the same value.\n\nis.\n\nis  or.\n\nThe following is an example where the function is a simple filter.\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return list(map(lambda x: x ** 0.5, numbers))\n\nfrom typing import List, Int, Float", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.reduce(lambda x: x/1.0, 0)\n\npython:\n\nimport list", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(zip(numbers, (lambda n: n/2, 0))).reverse()\nIn Python, one can even use the built-in __builtins__.__radd__ to create new functions, like this:\n>>> from __builtins__ import __radd__\n>>> def reverse_inverse(l):\n... return l.rev()\n...\n>>> def rescale_to_unit(numbers):\n...      __radd__(reverse_inverse, zip(numbers, 2))\n...\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n[0.0, 0.25, 0.5, 0.75, 1.0]\n>>>\n\nWhen I started using Python, one of the best things about it was that it was a functional language, but didn't force you to think about your code in a functional way.\nNow, I don't know whether that's still true. The more I write in Python, the more I see people arguing for functional programming in Python.\n(Of course, there is nothing wrong", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers\n\nI know what a \"List\" is, but what the hell is a \"float\" and a \"List[float]\"?\n\nA float is a single number (i.e. not a whole number or decimal, a single integer). A list of floats is a list of numbers (at least two elements).\n\nThis seems a lot like a \"most people are familiar with X\" issue.\n\nWe should be using simpler terminology. The article mentions that most people are familiar with lists. But if we have to define a \"float\" (which is fairly obscure, really), we are losing the general audience.\nIn this case, it's not that much simpler to say \"a list of floats\". It's simpler to say \"a list of numbers\".\n\nWhy is float obscure? It's the term everyone is familiar with. I can't think of a better term for \"the mantissa part of a double\".\n\nIt's obscure to most people. I had to look up the term when I saw it.\n\nI think this is a case where one could easily just use \"numbers\" and leave it at that. \"Float\" is a well-known term in the", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for x in numbers:\n        if x > 1.0:\n           numbers.append(x * x / 10)\n        else:\n           numbers.append(x / 10)\n    return numbers\n\nI would like to stress that this is far from optimal, but I think it is a good example of how functional programming can be easily implemented in Python.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(1, len(numbers)):\n         if i % 2 == 0:\n              if numbers[i - 1] > numbers[i]:\n                     numbers[i - 1] = numbers[i]\n                        numbers[i] = numbers[i - 1] / 2\n                         numbers[i + 1] = numbers[i - 1] * 1.5\n                        else:\n                        numbers[i - 1] = numbers[i]", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in range(numbers.size):\n        number = numbers[i]\n        number = number / numbers.size\n        if number < 0:\n            number = 0\n            return List(number)\n\nYou're not counting zeros.\n>>> [1.0, 2.0, 3.0, 4.0, 5.0, 0.0, 0.25, 0.5, 0.75, 1.0]\n>>> rescale_to_unit(list(x))\n[0.0, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0]\n>>> list(x).rescale_to_unit()\n[0.0, 0.5, 1.0, 2.0, 3.0, 4.0, 5.0]\n\nThis is fantastic. One of my coworkers showed me this the other day, and I've been using", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n         if i < 0.0:\n             return numbers\n             i += 1.0 * numpy.sin(numbers[i])\n          return List(i)\n\nThat's wrong. sin(x) has a finite period, so the smallest number in the list will be repeated infinitely often.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    nums = []\n    for i in range(len(numbers)):\n        numbers.append(numbers[i, 0])\n        nums.append(numbers[i, 1])\n        for i in range(len(numbers) - 1):\n             for j in range(i + 1, len(numbers) - 1):\n                    if numbers[i, j] > 1:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\nOk. I'm still not convinced that having a single function that returns a list is a good idea, though.\n\nGood catch!\n\nSo I tried typing list(List()) and got an error. I tried List(List()) and got a list of lists. I tried List(List(List())) and got an error. I tried List(List(List(List())) and got a list of lists of lists of lists of lists. What's going on here?\n\ntry:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\nThis is the most horrible code I have seen on HN in a long time.\n\nWhat's so horrible about it? Seems very clear and simple to me, with the obvious exception of the odd import.\n\nIt's not that it's particularly hard to read or understand, it's just that it does such a simple thing that the code is only a few lines long, and yet it's so utterly inefficient.\n\nI'm just curious, but what would be a more efficient approach?\n\nOh I don't know, how about using a list comprehension?\n\nAnd there are plenty of other ways. The point is that this is a trivial problem and the code is still horrible.\n\nNo, that's not the point. The point is that the code is horrible and there are better ways to solve it. I just gave one.\n\nI'm still not sure what's horrible about it. The issue I have is that it's obvious what it's doing.\n\nIt's horrible because it does something incredibly simple in a very inefficient way. I don't see how that's not clear.\n\nThe inefficiency is not the same as it being horrible.\n\nWhy not?\n\nBecause it doesn't", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    n = 1\n\n    for i in range(n):\n         n += 1\n\n    return (i, n)\n\nWhat's the point of this? You've only wrapped a for loop around a for loop.\n\nYou can do this, too, and it's actually pretty useful for its concise style:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    n = len(numbers)\n\n    numbers = [n] * [0.0, 0.0]\n\n    return numbers\n\n    # Assuming:\n          print rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) > 2:\n        return numbers\n        numbers = [numbers[1] / n for n in numbers]\n    return numbers\n\nOr you can just write the code to do the transpose directly and avoid a list entirely.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.sort()\n\n    return numbers.map(x => x*1.0)\n\n This is a bad example because it's obvious what the code does. A better one would be:\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\nIt's not very likely that you would need to type this, since it's the sort of thing that would typically be done in a function.\n\nAs a Python newb, this code isn't clear to me. How do you type the line with typing.list()?\n\nYou can import a module (in this case, the module is called \"typing\") using the \"import\" keyword.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return list(numbers).map(lambda x: x*0.25)\n\n>>> import rescale_to_unit\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n[0.25, 0.5, 0.75, 1.0]\n\nI find it easier to read the latter.\n\nThe explicit return type declaration doesn't hurt readability at all. It's not about \"hurting readability\" but about making the intention of the code explicit. The python example isn't obvious to me what it's doing. What do you mean by \"map\"? What's happening to the 4th number? The 5th? I find it odd to write a function that takes a list and returns another list that's the result of a linear transform to the first list, but then not even bother to tell me what transform is being applied to the elements of that first list. That's not pythonic. It's inelegant. It's difficult to understand.\n\nWell, I just know that \"map\" is a built-in function. It's not that hard to find out what it does", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\nHah! This is exactly the same approach I used to learn functional programming:\nI wrote a 'to_unit' function to convert lists of floats to integers:\n>>> from typing import to_unit\n>>> from functools import reduce\n>>>\n>>> numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n>>> numbers.to_unit()\n>>> reduce(to_unit, lambda x, y: x*y, [])\n[1.0, 2.0, 3.0, 4.0, 5.0]\n>>>\nIt was a really useful example, since it helped me learn about types and the type system.\n\nYou can also just use\n>>> map(lambda x: x * x, numbers)\n>>>\n\nI don't know much about Python, so I'm not sure if there's a difference, but I think map() isn't the right tool for this job. map() will reduce the list of floats to a single float, instead of reducing it to a list of integers (as the OP was interested in).\n\nYou're right, map will reduce to a single float. I would use a list", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\nThis is an interesting example of how type inference can get it wrong. In this case, the code is quite clear, but the inferred type is not.\nFor a moment, ignore the fact that this code is horrible, and assume that it is correct. Then, it still makes sense, because the type is List[float] -> List[float] (a list of lists of floats). You can't have a list of lists of lists of floats, because that would be infinitely nested, and thus contain an infinite number of elements (undefined behavior).\n\nNot only is that awful code, it's _wrong_. The smallest number will become 0 and the largest will become 1 _for the transform that you've specified_. The number you get out may or may not be 1.0.\n\nIt's wrong for reasons unrelated to the type, the code is correct and the type is wrong.\n\nFrom the page:\n_In this case, the type of the method is more specific than the code._\nThe problem is that it's type inference, and so the inference rules are different for different cases. It's a bit like the halting problem.\n\nIt's a bit like the halting problem in the sense that type inference", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for number in numbers:\n        number /= 2.0\n    return numbers\n\nIf the inputs are all integers, the same operation can be done in one line:\ns = [1,2,3,4]\nrescale = lambda x: x / 2\nrescale(s)\n\nI'm not sure I understand why this was posted.\nI'm sure we all know that you can use \"from\" with Python's own built-in types, and that functions are objects. This isn't news, and it doesn't really do anything.\n\nI used Python for a year and never realized that.\n\nIt's kind of weird. I think they did that to make it easier to implement generators, so you can think of functions as objects that \"return\" generators.\n\nI think you're overcomplicating it. Functions are objects, so just like you can say\nlist(1,2,3)\nyou can also say\nlist(lambda x:x, 1, 2, 3)\nIt's not to make generators easier, it's just a natural consequence of the fact that functions are objects.\n\nIf you go", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = List(0, 1.0, 2.0, 3.0, 4.0, 5.0)\n    for i in numbers:\n        if i < 0:\n            numbers.append(i)\n           if i > 0:\n              numbers.append(List(i, i/2))\n    return numbers\n\nThe discussion at the time:\n\nI like it :)\n\nIt looks like an interesting approach to a problem that everyone has to solve at least once.\n\nYou can do the same thing with `[1, 2, 3]` and `np.sin(x)`.\n\nNo you can't. sin(x) is a function, not an operator.\n\nI meant\n[1, 2, 3] * sin(x)\n\nAh, you mean the x is in a function argument, not the first element of the list.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [0.0, 0.25, 0.5, 0.75, 1.0]\n    return numbers\n\nimport numpy as np", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\nThat's not correct, as it's not preserving the relative order of the elements of the input list.\n\nIndeed. It should be:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n       return numbers\n    return [numbers[0] / float(numbers[1]) for i in range(len(numbers) - 1)]\n\nI know that it's a nitpick, but why would you ever need to implement that?\n\nThat's just a trivial example.\nHowever, for example, in the context of science you have to do linear transformation from one unit system to another.\n\n`from typing import List`\n`from typing import List`\n`from typing import List`\n`from typing import List`\n`from typing import List`\n`from typing import List`\n`from typing import List`\n`from typing import List`\n`from typing import List`\n`from typing import List`\n`from typing import List`\n`from typing import List`\n`from typing import List`\n`from typing import List`\n`from typing import List`\n`from typing import List`\n`from typing import List`\n`from typing import List`\n`from typing import List`\n`from typing import List`\n`from typing import List`", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if numbers[0] < 0.0:\n       numbers = List(0.0, 0.0, 0.0, 0.0, 0.0)\n    else:\n       numbers = List(0.0, 0.0, 0.0, 0.0, 1.0)\n    else:\n       numbers = List(0.0, 1.0, 0.0, 1.0, 0.0)\n    return numbers\n\nThe \"from typing import List\" part is a little misleading; the function has no dependencies on the built-in types.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return sorted(numbers, key=lambda v: v)\nThis is python, not C. You don't need to import any modules, you can just define a function at the top level.\n\nI'm using this as an example of how to define a function, not necessarily how to import it, but I understand what you're saying.\n\nI just don't see the point of importing a single function, when you can define it at the top level, and have it available everywhere.\n\nI have a lot to learn, but I thought that one of the reasons to import a function is so that you don't have to declare it at the top level.\n\nYou're right. The only reason to import a single function is if you only want to use it in a single file. You can always move the function from a module to the top level.\n\nI'm not sure if I'm doing this wrong, but it doesn't seem to be working for me.\n\nYou're not doing anything wrong, but this function is doing too much for my taste. It takes a list of floats, scales them to a range of 0 and 1, and returns another list of floats. Here's a simpler", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i, number in enumerate(numbers):\n         number = number / float(i)\n         rescaled_list = []\n         if number == 0:\n             rescaled_list.append(0.0)\n              if number == 1:\n                 rescaled_list.append(number)\n    return rescaled_list\n\nThis is a bit like the iota() function from Haskell: \n\nThere's a nice Python version of this called pow()\n\nPython 3 has an operator for it, too.\n\nI'd have a look at the paper \"Linear Algebra for the Working Mathematician\" by Strang, for a simple (and concise!) introduction to the mathematics of this kind of thing.\n\nAlso\n\nThis has to be the coolest thing I've seen all day, and it's only 8:00 AM! :)\n\nThis is the", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    res = List(numbers)\n    for i in range(1, len(numbers)):\n        res = res[numbers[i]] / math.log(numbers[i])\n        if i > 0:\n           res = res[len(res)-1] / math.log(res[len(res)-1])\n    return res\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\n    for x in numbers:\n         x *= x\n\n    return numbers\n\n def volume(sides: List[int]) -> Int:\n    \"\"\" Given a list of integer coordinates (of at least two elements), find the volume of the\n    the shape represented by those coordinates, using an algorithm similar to that of the Math::Trig\n    module.\n    >>> volume([1, 1, 1])\n    10\n    >>> volume([1, 1, 1, 1, 1, 1])\n    70\n    >>> volume([1, 1, 1, 1, 1, 1, 1, 1])\n    100000\n    \"\"\"\n\n    if len(sides)!= 2:\n        raise ValueError\n\n    sides.reverse().sort()\n\n    \"\"\" The volume of the shape is the area of a rectangle with the same dimensions as the shape,\n    but with the sides parallel to the x- and y-axis of the Cartesian coordinates.\n    So", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.items()\n    if len(numbers) == 2:\n        return numbers\n    else:\n        return [0.0, 0.25, 0.5, 0.75, 1.0]\n\nThis has nothing to do with the Python language or type system.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) > 2:\n        return numbers\n    return list(rescale_to_unit(numbers - 1))\n\nI'm not sure if this is a bug or a feature, but I'd be interested to hear the reasoning behind it.\n\nPresumably the original author was going for a Pythonic solution, and this is the equivalent of something like:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return [(0.0, 0.25), (0.5, 0.75), (1.0, 1.0)]\n\nIt's not clear to me from the article what the advantage of this is. Is there something I'm missing?\n\nThis code is quite idiomatic, and it's a good example of the power and beauty of Python.\nI think that it's not clear to people who have used languages with type systems. In languages like C, for example, this code would be likely to fail. If you pass in a list of floats, you expect the result to be a list of floats. But what if one of the floats is NaN or Infinity? How can you convert it to an integer? If you make that kind of mistake in your code, it will probably crash.\nIn Python, all that can go wrong is that your code might give the wrong answer. Which, in this case, is easy to check.\n\n\"it's a good example of the power and beauty of Python.\"\nI don't think that is an example of the power or beauty of Python, but rather of the limited expressiveness of floating point numbers.\n\nIt's really a combination of the", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    min = 1.0\n    max = 2.0\n    res = []\n    for n in numbers:\n       if n > max:\n          res.append(max - n)\n          max = n\n    else:\n          min = n\n          n = max\n    return res\n\nMore succinctly:\nList(x) = list(x)/x\n\nWhat if there's more than one solution, i.e. it's not a unitary transform?\n\nThe code is correct in that case, but it should probably have an exception that is raised if the two numbers are equal.\n\nI agree, although the better solution is to use a different type for the result.\n\nIt's not the same, but it is pretty nice:\nimport numpy as np", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n        if numbers[i] >= numbers[0]:\n             numbers[i] = numbers[0]\n    else:\n              numbers[i] = numbers[i] * 0.5\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\nThis looks like a bug.\nIf you pass it 1.0 it will return a list containing only 0.0. (You can prove this by induction.)\n\nI think that's by design. You can't re-scale a number to a smaller number. The return value is a list of numbers from 0 to 1.0, not a list of 1.0.\n\nFair enough.\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for number in numbers:\n        number /= 2.0\n    return numbers\n\nThe next line is the magic.\n\n>>> (rescale_to_unit([]))\n\n[0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n\nPretty nice.\n\nThat's not magic, that's using the type system. That's exactly the sort of thing the type system is supposed to do.\n\nExactly. This is the power of the type system.\n\nYes, it's using the type system. But when you type it out, it is a lot of syntax for something you'd expect to be built into Python.\n\nIf Python had built-in support for that, then you wouldn't need the type system at all.\n\nBut it is a lot of syntax. Do you type this in every time? You could store it in a function, but then you have to remember to import it.\nI would expect this to be the first example in the Python documentation.\n\nI didn't type this in every time. The first time I wanted to use it, I typed", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return [0.0, 0.5*numbers[0], 0.5*numbers[1], 1.0*numbers[2]]", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(2):\n         numbers.append((numbers[i], numpy.round(numbers[i]-0.5)) / 2.0)\n    return numbers\n\nnumpy.round(numbers[i]-0.5) / 2.0\n\nfor i in range(2):\nnumbers.append(numbers[i]*numpy.pi / 2.0)\n\nFor the lazy:\n\n>>> from typing import List\n>>> from numpy import *\n>>> from typing import List\n>>> from numpy import *\n>>> from typing import List\n>>> from numpy import *\n>>> from typing import List\n>>> from numpy import *\n>>> from typing import List\n>>> from numpy import *\n>>> from typing import List\n>>> from numpy import *\n>>> from typing import List\n>>> from numpy import *\n>>> from typing import List\n>>> from numpy import *\n>>> from typing import List\n>>> from numpy import *\n>>> from typing import List\n>>> from numpy import *\n>>> from typing import List\n>>> from numpy import *\n>>>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(np.exp(-np.arange(len(numbers) - 1.0) * numbers[0][0]),\n    np.exp(-np.arange(len(numbers) - 1.0) * numbers[0][1]),\n    np.exp(-np.arange(len(numbers) - 1.0) * numbers[1][0]),\n    np.exp(-np.arange(len(numbers) - 1.0) * numbers[1][1]),\n    0.0, 1.0)\n\nThe code also has a for loop with a lambda in it (not shown) that will return the nth smallest element and a list of the remaining elements. I just haven't figured out how to make the lambda return the list.\nI'm also trying to use numpy and scipy to implement a riemann sum function, but I'm having some difficulty with that.\n\nI don't know a lot about Python, so I'm probably not the one to help you, but I do know what the code is doing, so I can help with that.\nFirst", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    n = len(numbers)\n\n    if len(numbers) == 2:\n        return n\n\n    result = []\n    for num in numbers:\n        if n % 2 == 0:\n            result.append(n / (2 ** n))\n         else:\n            result.append(n)\n         n = n / (2 ** n)\n    return result", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.map(float(x) * 1.0, axis = 0)\n    numbers.sort()\n    return numbers.to_list()\n\nYou're already using Python's built-in sorting module in a fairly unnecessary way. It has a sort_array() method that sorts any iterable.\nAlso, the Python standard library's iterators have len() methods that you can use to find out how many items you have in a list.\n\nI am not a Python expert by any means, so please correct me if I am wrong.\nI thought the sort() method just sort-of-works with anything that has a sort-able key? I thought that some types cannot be sorted, like lists of ints and such? I would think that he was using sort() and sort_array() to make sure it was sorted correctly.\n\nYes, it works for any iterable (although it doesn't actually work for iterables of strings, but that's another story).\nMy point was that there is no need to sort the elements before doing the linear transform, as the transform would just sort them itself.\n\nI agree, sorting is superfluous here.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    \"\"\"Compute an average and an offset for each element.\"\"\"\n    for x in numbers:\n        average = sum(x) / len(x)\n        offset = x[len(x)-1] * 2\n        sum = 0.0\n        for i in range(len(x)):\n           sum += x[i] * average + offset\n           x[i] = sum / len(x)\n    return List(map(sum, x))\n\nWhat is the point of this?\n\nI'm not sure if there's a point, I just wanted to make it a little easier to read.\n\nNot really, I had to read the code and still had to do mental gymnastics to understand it.\n\nI'm surprised Python is not mentioned in this article. It's the language of choice for scientific programming, and in general a nice language to code in.\n\nIt's also used for web development at Google.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(numbers.map(float, [0.0, 0.5, 0.25, 0.75, 1.0]))\nThis is very cool. You can pass it a list of numbers that represent a scale in a different unit (say, miles to feet) and it'll rescale them to a unit you specify (feet to miles, for example).</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return map(lambda x: x*(1.0 - x), numbers)\n\nI don't know Python, but if I were going to write this, I'd write it like this:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(float(x*0.5))\n\nWow, that's a really clean and simple solution. I guess I shouldn't have expected anything else from Python.\n\nWhat's the purpose of this snippet?\n\nIt's an example of using Python's module system to provide a very short, easy-to-understand function.\nThis is part of the reason that Python is a good language for teaching programming.\n\nThis is an example of the difference between a micro-language and a macro-language. Python is a great micro-language.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i, x in enumerate(numbers):\n       if x < i:\n          if x == 0:\n              numbers[i] = x\n              x = i\n           else:\n               if x > numbers[i]:\n                  numbers[i] = x\n                x = i\n        else:\n                numbers[i] = x\n\nThe first line of the function could be\nfrom typing import List\nI think that's a lot clearer.\n\nI think that's really a matter of taste.\nI personally prefer explicit typing, like the first example.\n\nI think both examples are a matter of taste. I like the explicit typing as well", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i == 0 or i == 1:\n           return i * 1.0\n       else:\n           return i / 1.0\n\n\t\t\t\t\tfrom __future__ import absolute_import\n\t\t\t\tfrom __future__ import division\n\t\t\t\tfrom __future__ import print_function\n\t\t\t\tfrom itertools import chain\n\t\t\t\tfrom functools import partial\n\n\t\t\t\tfrom collections import OrderedDict\n\n\t\t\t\tfrom collections import defaultdict\n\t\t\t\tfrom collections import defaultdict(int)\n\n\t\t\t\tfrom operator import (**)\n\t\t\t\tfrom operator import (**)\n\n\t\t\t\tfrom operator import (**)\n\t\t\t\tfrom operator import (**)\n\t\t\t\tfrom operator import (**)\n\t\t\t\tfrom operator import (**)\n\t\t\t\tfrom operator import (**)\n\t\t\t\tfrom operator import (**)", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return (list(numbers[0]) + list(numbers[1]) / list(numbers)) * 0.5\n\n    from math import sqrt\n\n    def print_scaled(x: float, number: float) -> float:\n    \"\"\" Print the number scaled by x\n    >>> print_scaled(3.0, 3.0)\n    3.0\n    >>> print_scaled(2.0, 2.0)\n    2.0\n    >>> print_scaled(3.0, 3.0.5)\n    3.0\n    >>> print_scaled(3.0, 3.0.5.0)\n    3.0\n    >>> print_scaled(3.0.5, 3.0)\n    3.0\n    >>> print_scaled(3.0.5, 3.0.5.0)\n    3.0\n    >>> print_scaled(3.0.5.0, 3.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    n = [0.0, 0.25, 0.5, 0.75, 1.0]\n    result = [0.0, 0.5, 0.75, 1.0]\n    numbers.append(result)\n    return numbers</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n         new_list = []\n         for j in numbers:\n            if j > i:\n                 new_list.append(i)\n                 else:\n                   new_list.append(j)\n    return new_list</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    new_list = []\n    for i in numbers:\n        new_list.append((i * i / 2.0) + 1.0)\n    return new_list\n\nI've never used the type system for this kind of transformation, but I think this is a bad idea. The code is not type safe, i.e., it is possible that you pass in a list of floats and get back a list of ints or something else.\n\nTrue, but I would think in most cases it's obvious when a float is being used.\nThis is a fine example of where static typing is not a good idea. The performance impact is a killer for something like this. It would be a no-brainer if this were a computation that had to be done on a ton of numbers, but I can't imagine a case where I would need this.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.sort()\n    for i in range(len(numbers)):\n        numbers.append(i / 2)\n    return numbers\n\nI didn't know this one, thanks!\n\nYou're welcome.\nIt was a programming-for-python-interview problem. The interviewer said the solution above was wrong, but I don't remember what was wrong with it.\n\nI'm not sure if the solution above is correct, but it's at least short and not too complicated.\n\nWhen I was a CS undergraduate, I used to make a point of using from typing import * at the start of every program.\n\nAnd then if you change the type of a variable halfway through the file, you have to make sure to fix all the imports.\n\nAnd then you learn to use import statements instead of using global names like my_var.\n\nThe error checking is wrong though:\n>>> from typing import *\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"../tmp/test.py\", line 1, in <module>\nFile", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) <= 2:\n       return numbers\n    return [x**2 + x*3 for x in numbers]\nWhat are you trying to show here?\n\nI think the point is that it's a bad idea to bring in the typing module just to use the list function.\n\nTo be fair, it's not just to use a list function. If you use list, you are implicitly passing in a certain set of requirements for the type of your list. It makes sense to express those as constraints instead of letting the compiler assume they are all true.\n\nI think you've pretty much said exactly what I meant.\nI'm not saying you shouldn't have any typing, just that you shouldn't type your entire program.\n\nI usually do not type my whole program, just some functions. As a side effect, I also get more readable code.\nI think, you mean, that I should not add types for types, but for functions. For instance, I do not type classes, but I do add types for methods.\n\nWhen I type whole programs, I mean I define the types for the classes, not the individual functions.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for number in numbers:\n       if number < 0.0:\n          number = 0.0\n       if number > 1.0:\n          number = 1.0\n    return numbers\n\nI'm not sure why this is useful.\n\nHe's just making a point that you don't need to use \"from __future__ import print_function\" to use a function that doesn't exist in Python 2.\n\nYes, that is exactly what I was doing.\n\nI don't get the point. Python 2.x has the function 'from <module> import *' so you can use all functions in the imported module.\n\nI didn't say it was useful for anything. I was simply demonstrating that you don't need to import from __future__ for this to work.\n\nI get it. Some people like to bitch about __future__ import stuff.\n\nNot really, I just thought it was a funny way to demonstrate that you don't need to import from __future__ for this.\n\nit is not a very good demonstration", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i, val in enumerate(numbers):\n        if val < 0.0:\n            val = 0.0\n        elif val < 1.0:\n            val = 1.0\n        else:\n            val = numbers[i] * val / n\n    return List(numbers)", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [0, 1, 2, 3]\n\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.reduce(0, lambda x, y: x, y)\n\nIt's been a while since I've used Python, but doesn't the second line (the one that says'return numbers.reduce(0, lambda x, y: x, y)') imply that it's returning a function?\n\nYes, it does.\nPython allows you to use functions as return values.\n\nThis is a wonderful example of why I hate Python. For a language that is supposed to make things easier to read, it makes no sense to do something like that. It's confusing to read and in this case, it's not even more elegant.\n\nI'm not sure what you mean by this. How is it any more confusing than the list comprehension version?\n\nIt's confusing because it's not obvious that `reduce` is a function.\n\nWhat?\nHow is it not obvious?\nIs it because it looks like a method and methods are passed in as arguments?\nWell, in that case, a list comprehension looks like a function, and it's not obvious that a function is being passed in as an argument to that.\nDoes it make sense to say that it", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i, v in enumerate(numbers):\n        i = i / 2\n        v = v / 2\n    return numbers.append(v)</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [numbers]\n    out = []\n    for i in numbers:\n        if i >= 1.0:\n           out.append(i / 1.0)\n    return out\n\nWow! Pretty good code.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\nThis is a very good example of a non-idiomatic Python solution. Python's types (and by extension, its modules and standard library) make it very difficult to have this sort of transform done without making a mess of the syntax.\nFor example, without making this function a function object, and returning a _different_ function object, this would not be a Pythonic solution:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [n for n in numbers if n < 0.0 else 1.0]\n    transformed = []\n    for i in range(1, len(numbers)):\n         transformed.append(numbers[i / 2])\n    return transformed\n\nTook me a while to figure out the point of this.\nI think it's an interesting demonstration of how the power of Python is in the small code blocks. This is the same thing as:\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.copy()\n    return numbers.map(lambdax: x * x / x + 1)\n\nThanks for the pointer, looks like a good tip!</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) <= 2:\n       return numbers\n    a = (numbers[0] * 2.0) + (numbers[1] * 0.0)\n    b = a/2.0\n    return numbers\n\nWhy is this posted?\n\nBecause it's an interesting application of python list transformation methods, and a good explanation of the process of list transformation.\n\nWhy is it interesting?</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n        numbers[i] = (1/numbers[i])*math.sqrt(numbers[i])\n    return numbers\n\nThis is nice for someone like me who's not really familiar with Python. It's not really a one-liner, but it's still something I can play with.\nI have a question though, I don't know python, but is the syntax \"from typing import List\" correct? I always thought it was from typing import <whatever>\n\nthat's the correct syntax. \"from typing import\" is like\nfrom typing import List as list\nwhich is equivalent to\nfrom typing import list\n\nIt's not correct, it's just not incorrect.\nYou may see it a lot, but it's definitely not the correct syntax.\n\nIt's not just not incorrect, it's perfectly correct. What's not to get?\n\nNot perfect, because it can't be imported.\n\nThat's not what \"perfectly\" means.\n\nFrom the Python FAQ:\nDoes \"from typing import List\" work?\nNo. In Python 2, the", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i < 0:\n           i = 1.0\n    return list(zip(i, rescale_to_unit(j)))\n\nThis was actually much simpler than I expected.\n\nI'm guessing you're not much of a programmer.\n\nI'm guessing you're not much of a human.\n\nWould you like to fight?\n\nOnly if you're a drunk giraffe.\n\nAs a drunk giraffe, I find this terribly offensive.\n\nIf this is what programming is all about, I'm not sure I'll ever be able to learn.\n\nI was just about to say the same thing!</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n         numbers[i].append(0.0)\n         numbers[i].append(1.0)\n    return numbers\n\nOr use transformers:\nfrom typing import List\nfrom transformers import Map, Filter, TakeWhile, Set", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\nI hate it when people do that. Can't he use the module's name as the variable name?\n\nWhat do you think I should call it? I am happy to change the name.\n\nI'd probably use _len_ and _scale_ and use the same variable names in the function as in the module.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(numbers.size):\n        numbers[i] /= numbers[i + 1]\n\n    return list(numbers)\n\nfrom typing import Type", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    n = len(numbers)\n\n    return sorted(numbers.items(), key=lambda n: n[1])\n\nI've just posted a list of things I hate about Python. Please feel free to add to it.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) > 2:\n        return numbers\n    else:\n        return [0.0, 1.0]\n\nI love Python's list methods. However, I find myself questioning the usefulness of the \"numbers\" list. I haven't done much with lists lately, so correct me if I'm wrong, but I believe in order to access the elements in the list, you have to specify the elements starting from index 0.\nSo, in the above example, you can't just do \"rescale_to_unit(10)\" to get 1.0 because it won't know what to do with the element starting at index 10 (I think).\nSo why not just say:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(float, lambda x: x/1.0)</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\n    numbers = [n1 for n1 in numbers if n1 < 0.0 else 1.0 for n2 in numbers if n2 > 0.0 else 0.0 for n3 in numbers if n3 > 0.0 else 0.0]\n\n    return numbers\n\nHow does this get upvoted? It's just a snippet of the Python documentation for map.\n\n\"C# (and some other languages) have an explicit type of int[], Python doesn't have that, so it's useful to have a list which behaves like an int[]\"\n\nI don't understand why anyone would need such a thing. Just use int[].\n\nIn C# you have int[][] so you don't have to manually sort it.\n\nPython doesn't have arrays, which I find much more flexible.\n\nWell I don't know about you but if I have a list of numbers, I want it to be ordered.\n\nI think he's saying that if you want an ordered list you can use an array.\n\nYes, arrays are ordered, but I would argue that the way C# handles them makes them more restrictive than a list.\n\nI", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.sort(key=lambda x: float(x)/float(0.0))\n\n    nums = [float(len(numbers[1])) for x in numbers[1:]]\n\n    return (nums).map(lambda x: float(x)/float(0.0)).map(lambda x: float(x)/float(0.0)).sum()\n\nIt would be interesting to compare it to LAPACK's'scale' function, to see how well the same code can be optimized.\n\nI don't think it would be very interesting at all. Scaling a single number by a constant factor doesn't need any special tricks. The only reason to use a'scale' function is to scale a vector of numbers by a constant factor.\n\nScaling a single number by a constant factor is exactly the problem LAPACK's'scale' function solves. The paper that introduced the function is linked below.\n\nI think he meant that if you apply the scalar factor directly on the input array, you can easily compute it in a single pass. On the other hand, the'scale' function must compute its scalar factor one", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) < 2:\n        return List(numbers)\n    m = 0.0\n    while n:\n        n = float(n) / float(m)\n        if n < 0.0:\n            m *= n\n        else:\n            m /= n\n    return List(numbers)</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.transpose().map(numbers.max() ** 0.5).map(numbers.min() ** 0.5)\n\nI have a related python question:\nWhat is the best way to calculate n^th root (ex: calculate the n^th root of 2000)?\n\nmath.pow(2, n)\n\nThanks.\nIs there a way to have the number in one variable, for example:\n>>> n = 2000.0\n>>> (2*n + 1)^n\n>>> print n\n2000.0\n>>> print (2*n + 1)^n\n<type 'int'>\n>>>\n\nn = 2000.0\n(2*n+1)^n = (2*(n+1)^2)/(2^n)", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    new_numbers = [0.0, 0.25, 0.5, 0.75, 1.0]\n    for x in numbers:\n        new_numbers.append(x * x)\n    return new_numbers\n\nList is an object in python, not a function. What's wrong with:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    a = (numbers.max() - 1.0)/numbers.size()\n    b = a + 1.0\n    list_to_float(a, b, axis=1)\n\nI like how it's a complete program without a bunch of useless comments.\nI do find it amusing that the \"typing\" package doesn't import itself. I guess the author is going to have to redefine \"import\" after this.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.sort()\n\n>>> numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n>>> rescale_to_unit(numbers)\n[0.0, 0.25, 0.5, 0.75, 1.0]\n\nFrom the docs:\n\n>>> types(rescale_to_unit)\n[<type 'float'>, <type 'list'>]\n\nNote the return type of the function is a list. However, the type of the input parameters is float.\n\nThe unit function doesn't have this issue.\n\nThat's because the unit function is not a function but a class method.\nThe difference is subtle but important: class methods in Python are not functions. They can't be invoked using only the call syntax (as opposed to the class syntax), for example.\n\nIn the case of the unit function, it is also a builtin and therefore cannot be overridden by user code.\n\nPython doesn't have built-in functions, it has builtin _methods_. The builtin functions have a different name.\n\nActually, it's the same thing in Python 2", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(len(numbers) - 1):\n        numbers.append(List(List(float(i*0.5))*0.5))\n    return numbers\n\nI hate to nitpick, but I would use reduce() instead of append(). If you use append, you're creating a new array every time you go through the loop, which will cause a lot of garbage collection.\nAlso, you should know that you can just use List.fold() to do the same thing in one line:\n\nI would have said \"Append is faster if you don't care about memory\".\nYou're right that fold is more compact.\n\nIt's not a great idea to use append in this case because it will allocate the list every iteration, but it is still faster than reduce, because append runs in constant time, while reduce is O(n^2).\n\nThe second example isn't really an example. The list with three elements in it is only there to show the list syntax. I think it's more impressive to show that the method works for lists of any length than to show that it works for a list of three elements.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\n    \"\"\" Reverses the order of the list.\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])\n    [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n    \"\"\"\n\n    def left_multiplication(first: List[float], second: List[float]) -> List[float]:\n    \"\"\" Given two lists of numbers (at least two elements), apply a left multiplication\n    >>> left_multiplication([2.0, 1.0, 1.5])\n    [4.0, 4.0]\n    \"\"\"\n\n    \"\"\" Left multiplies both lists and sums the results.\n    >>> left_multiplication([2.0, 1.0, 1.5])\n    [4.0, 4.0]\n    \"\"\"\n\n    def right_multiplication(first: List[float], second: List[float]) -> List[float]:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\nI really really hate articles like this. They don't help you at all. It's not a walkthrough, nor does it tell you what the code is doing. This is exactly what documentation is for. I don't care what kind of data structure you're using, it shouldn't be in the code at all.\n\nI think this is a bit too strong, considering the whole article is only two or three dozen lines of code, and the code is fairly descriptive.\nThis isn't a walkthrough of the data structure itself, but just a \"how to transform your data in this data structure\". If this were a more complicated example, I might agree with you.\n\nI agree with the original comment. It's not a walkthrough of the data structure itself, but I am still left with questions. For example, what does rescale_to_unit actually do?\n\nIf you're still curious, it's not too hard to figure out, and it's actually pretty simple.\nGiven a list of numbers, rescale_to_unit returns a list of the same length, with the list elements scaled such that the smallest is 0 and the largest is 1.\n\nAh, thank you. I found the code", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i < 1:\n           return [0.0]\n    else:\n           return [i]\n    return List(i)\n\nThat's not a very useful snippet. The only way you can use it is if you have a function (like rescale_to_unit) that takes a list of integers and returns a list of integers. That's not a very useful class of functions.\n\nit's a common example of a function that takes a sequence of integers and returns a sequence of integers\n\nYes, but that's not very useful. If I have an integer list I want to convert to a list of floats, I don't want to have to write a list of functions that converts between my integer list and a list of floats. I can just convert my integer list directly to a list of floats. If you want to convert back and forth between two sequence types you have to write two functions.\nThis is a really bad example.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = List()\n    numbers.append(1.0)\n    numbers.append(1.0)\n    numbers.append(2.0)\n    numbers.append(2.0)\n    numbers.append(3.0)\n    numbers.append(3.0)\n    numbers.append(4.0)\n    numbers.append(4.0)\n    numbers.append(5.0)\n    return numbers\n\nThis is an example of a functor (not a monad). See  for more on this.\n\nI have a strong feeling that he was aiming for \"scalar\" (list of integers).\n\nNope, I was aiming for list of floats. I'm not sure what it would mean to \"scale integers to integers\".\n\nThe word \"scalar\" means \"scalar type\" which in the context of a programming language is \"a data type that has only one dimension\".\nPython, for example, has an integer type and a float type. Neither of these are \"scalars\" because they", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.sort()", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [0.0, 0.25, 0.5, 0.75, 1.0]\n\n    def scale(numbers: List[float], factor: float): List[float] =\n        def average = float(sum(numbers)/len(numbers))\n        def transform = (numbers - average)/factor\n\n        transform(numbers, factor)\n        return transform\n    numbers.sort()\n\n    rescale_to_unit(numbers)</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for num in numbers:\n        print(\"%-10s, %s, %s, %s, %s\" % (num, float(num) / 10, float(num) / 10, num, num))\n    return List(float(num) / 10)\n\nI've always found this approach to be more readable (although, not so succinct).\n\nI've always wondered about this sort of thing. What's the 'best' way to generalize this? Is there a good way to write this that works on any kind of iterable?\n\nthe same way you would write a function which sums numbers, add a multiplier and apply it to each element.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    n = len(numbers)\n    t = numpy.arange(0, n - 1)\n    # scale everything to be in the range [0, 1]\n    numbers.update(t * numbers.get(0))\n    numbers.update(t * numbers.get(n - 1))\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(map(lambda x: x.**2, numbers))\n\nThere's something very wrong with this function. It doesn't preserve the ratio of elements, it just scales all of them. The point of the article is to show you a function that scales all the numbers in a list, but preserves the ratio of elements.\n\nIt doesn't preserve the ratio of elements _in your example_, because you are using the **2 operator. If you used **, it would have preserved the ratio.\n\nYou're right, I'm sorry. I'll edit my comment accordingly.\n\nI know this is an older article, but I can't help myself from making the same comment I always do when this topic comes up:\nLet's say you have a list of integers that you want to multiply by a constant. The naive approach is to write something like this:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    x = 1.0\n    y = 2.0\n    a = [x, y]\n    b = [x * y, y * x]\n    if len(a) == 0 or len(a) == 1:\n        return a\n    else:\n        return b", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(len(numbers) - 1):\n        numbers.append(numbers[i, 0])\n    return numbers\n\nIn this case the output is a list of floats, but this can be easily generalised to any other type.\n\nThis is usually called \"mapping\" in functional programming.\n\nI love python, but it has a fundamental flaw: list.append is not a monad.\n\nWhat's the point of a list being a monad?\n\nI like to use the list monad to define a unit type. It makes it a lot easier to be able to define an operation that takes a list of a certain type and returns a list of the same type (with the last element of the input list being removed, if the list is empty).\n\nThe \"list\" monad is trivial to implement using a free monad. The advantage of free monads is that they're much simpler to understand, and that they're composable with other monads.\nThe downside is that they can't return multiple values, but I don't see why this is a big problem.\n\nSorry, but I think your", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    list_index = numpy.random.choice(numbers)\n    if list_index == len(numbers):\n       return list_index\n    i = list_index\n    x_indices = np.array([float(i)])\n    if i!= 0:\n       for j in x_indices:\n          x_indices.append(float(j))\n        i = i + 1\n       else:\n       i = list_index\n    return x_indices\n\nWhile this is a nice little function, it is much easier to just use the built in __getitem__ method of numpy.array\n>>> np.array([1.0, 2.0, 3.0, 4.0, 5.0])\n[1.0, 2.0, 3.0, 4.0, 5.0]\n>>> rescale_to_unit(np.array)\n[0.0, 0", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(numbers.map(number => (number / number.__getitem__())))", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n         numbers[i] = 2 * i\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = sorted(numbers, key=lambda x: x[0])\n    return [x[0] / (float(len(x) / 2.0) * numpy.sqrt(x[0])),\n    x[1] / (float(len(x) / 2.0) * numpy.sqrt(x[1]))]\n\nNot sure if the author meant to post this, but this is a great little function.\n\nWhere was it posted?\n\nHe posted it on reddit as well,\n.\n\nThis is the author. This is an older post (2010) but it seems to be getting a lot of traffic today. I'll probably update it soon with more comments and examples. I would appreciate any input, thanks.\n\nThis seems useful. I especially like the fact that it's in Python.\nI have a related question to anyone who has done a lot of linear algebra (I'm a beginner): why is it that when you write a function like the above, you have to use numpy.sqrt? I've seen this all over the place:\nx / (x[0] * x[", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.take(2)\n    n = int(numbers[0])\n    for i in range(len(numbers) - 1):\n        numbers[i] = n*(n-i+1) / 2.0\n    return numbers\n\nThis is really cool, but it's much more useful to use numpy arrays (or even lists of arrays) rather than the primitive built-in types.\n\nI just realized that numpy arrays are one level of indirection away from being lists of lists.\n\nVery cool. I'd use this more often if it didn't have the same name as the Python standard library function (list.sort()).\n\nYeah, I just realized that. The only reason I chose the name was because I couldn't think of anything else at the time.\n\nThis is a great name for the function because it's obvious that it's a function that \"rescales\" (ie. transforms) a list of values into a list of values with the smallest value of each equal to 0 and the largest to 1.\n\nBut what if you're writing a library? There", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n         yield i\n    return [i/2.0 for i in numbers]\n\nThis is the first time I've ever seen a python example using list comprehension for something that is purely functional.\n\nAnd to think that you need a whole new language to do something like this:\n[x for x in numbers if x % 2 == 0]\n\nThat's not an actual solution to the problem, though, is it? It returns 0 if x=0, 1 if x>0, 0 if x<0, and any value in between if x=1.\n\nIt is, though, because it works for every input. The original solution was only correct for numbers > 1.\n\nThe original solution was a list comprehension, which I'd argue is actually more correct than your solution, which doesn't work at all with a list of 0s.\n\nI am not sure I understand. The list comprehension version doesn't work for 0s. (ie you need to write 0.0 for it to work)\n\nYes, but the person you were responding to said that your version didn't work for 0s.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n        number = numbers[i]\n        if number > 1.0:\n            number *= -1.0\n            number /= 2.0\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.sort()\nI like it. But I'm not sure if I like it more than:\nimport numpy as np", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\n    if len(numbers) == 2:\n        return numbers\n    elif len(numbers) == 1:\n        return numbers\n    else:\n        return List(numbers.index(i) / float(numbers.index(i)) for i in numbers)\n\nThis is very weird.\n\nI don't think so.\nThe author was doing something that would normally require a list comprehension.\nI'm not sure why you'd ever want to do something like this, but if you did, this would be the way to do it.\n\nThis has potential to be an even more ugly alternative:\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\nThe Python code uses a function named'rescale_to_unit' to covert a list of floats to a list of float * 10^0.1, which in turn is converted to a list of floats in the range 0.0 to 1.0. The Ruby code does the same thing but instead of using a function, uses a Ruby built-in named 'List' to convert a list of floats to a list of floats in the range 0.0 to 1.0.\nThe Python code is more explicit but less concise. The Ruby code is more concise but less explicit.\n\nI would say the Python version is more concise, more explicit, and less readable.\n\nThe Python version is more explicit than the Ruby version, and less concise.\nIt is more concise than the Ruby version, and less explicit.\nIt is less readable than the Ruby version, and more concise.\n\nInteresting exercise, but the comparison is not fair. The ruby code is much simpler than the python one and it uses built-in functions that are available to all ruby programs. The python version also uses many built-in functions but they are only available to python programs written in python. (Also, I think the ruby code is", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n    return [0.25, 0.5, 0.75, 1.0]\n\n>>> import random\n>>> from typing import List\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0], random.randrange(1,7))\n[0.25, 0.5, 0.75, 1.0]\n>>>\n\n>>> from typing import List\n>>> import random\n>>> from random import randrange\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0], randrange(1,7))\n[0.25, 0.5, 0.75, 1.0]</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    x = 0\n    for i, n in enumerate(numbers):\n        x += n/10\n    return x\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    def transform(x, min, max):\n        return x * (1.0 - min) + min\n        return transform(x, max, min)\n    return List(transform(numbers.pop(), 0, max))\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [float(0.0), float(0.25), float(0.5), float(0.75),\n    float(1.0)]\n    l = lambda x: x / (1.0 / (1.0 + 0.1))\n    return [float(l(numbers[i])) for i in range(0, len(numbers) - 1)]\n\nSo, if you have a list of numbers and you want to rescale them in such a way that the smallest is 0, and the largest is 1, you can use:\n>>> [1.0, 2.0, 3.0, 4.0, 5.0]\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n[0.0, 0.25, 0.5, 0.75, 1.0]\n>>> [1.0, 2.0, 3.0, 4.0, 5.0]\n>>> rescale_to_unit([]).reshape(-1)\n[0.0, 0.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(map(float, numbers))\n\nwhy not just\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(numbers.size()):\n        numbers[i] = numbers[i] * (1.0 / i)\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if numbers:\n        return numbers\n    n = len(numbers)\n    numbers = [0.0 / n, n * (1 - n) / (2 * n) for n in numbers]\n\n\treturn numbers\n\nIs there any use case for this beyond trolling?\n\nA use case would be to measure the performance of a DNN in a way that is meaningful to the way the DNN will be used.\nIf the DNN has, for instance, 200 inputs and 20 outputs, then all the performance tests will use only 20 inputs and 200 outputs.\n\nI'm sure that's true, but if your DNN can't be tested on the size of data it will actually be used with, then what's the point of having it?\n\nWhy is this a python package? Why is it on the front page of HN?\n\nI guess it's because of the \"from typing import List\". It seems to be a gag on the fact that you can now import the builtin list type in python 3.x.\n\nWhat's the joke here? It's as if someone saying \"import System\" would be funny", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return [0.0, 0.5 * numpy.pi, 1.0]\n\n_If there was a list of numbers of any shape that you could give to a function,\nand it would return the same list, except now the elements were in the same order,\nthen it would be easy to do the same thing in Python. Unfortunately that isn't\npossible (unless you invent your own type)._\nIt's not that simple, you can define a generic function that is a drop-in replacement for any built-in function:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\n    return List.from_iterable(numbers).map(lambdax: (x, 0.0))</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [0.0, 0.25, 0.5, 0.75, 1.0]\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    x = [0.0, 0.25, 0.5, 0.75, 1.0]\n    for number in numbers:\n       x.append(number / 0.5)\n    return x\n\nAt first I was like: \"WTF? This doesn't even compile.\" Then I realized the code was just a list of numbers.\nI don't think it's a \"clever\" code snippet though.\n\nI suppose it's clever if you've never used Python before and didn't know about the built-in function array.\n\nAnd so it should be.\nThis should be in a book called \"Python tips and tricks\" for beginners.\n\nI was hoping for something a little more advanced.\n\nHere is a much more clever way:\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if n > 1:\n         return List(n)\n    for n in numbers:\n         rescale_to_unit(numbers[n])\n    return List(n)\n\nI don't get it. Why would you need to do that?\n\nIt's a very common operation in numerical calculations.\n\nThanks. I'm not familiar with numerical calculations, but it seems that the original code doesn't need to convert to a list of numbers, since it already contains a list.\n\nYes, the original code is perfectly fine. The rescale_to_unit function is a built-in function in Python. For some reason, the OP used it to convert a single-valued function into a list, which is not a good idea. It's just syntactic sugar.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for x in numbers:\n        if x < 0.0:\n            x = 0.0\n         else:\n            x = 1.0\n    return List(x)\n\nI've never understood why Python devs include \"from typing import\" statements in their code. Is it to underscore that the Python type system is actually a type system? Or is it to avoid writing \"from __future__ import...\"?\n\nI guess it's the same reason that you can import \"typing\" from any module. I'm still unclear on how it works when you import \"typing\" from an external module that has \"typing\" in it. It's definitely the latter reason, not the former.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    transform = 1.0/sqrt(numbers.shape)\n    return [float(i), transform(numbers[i] - transform(numbers[-i])) for i in numbers]\n\nI'm always a bit embarrassed by these unit-test-heavy examples, because if I were to write them by hand, I'd write something like:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.reduce(lambda x, y: x + y, 0)\n\nIn python, just use _:\n>>> from typing import List\n>>> from __future__ import division\n>>> from __future__ import absolute_import\n>>> from typing import List\n>>> def rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return _.map(lambda x, y: x + y, range(2, numbers.size()))\n\nIt's interesting to see the new language's syntax, which looks a lot like Python.\nI imagine they'll eventually add a module system to ease the transition.\n\nThis syntax is a total departure", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.filter(numbers > 2).to_a\n    return numbers\n\nWe might as well use a list comprehension and spare ourselves the trouble of defining the new function.\n>>> import itertools\n>>> numbers = [1,2,3,4,5,6,7,8,9]\n>>> n = itertools.count(itertools.product(itertools.repeat(0, numbers))).to_a\n>>> list(rescale_to_unit(n))\n[0.0, 0.25, 0.5, 0.75, 1.0]\n\nI think this is why Haskell programmers often don't bother with functions.\n\nI disagree; this is why lazy programmers don't bother with functions. The second version is more concise, but it's hardly readable.\n\nSorry, but I still can't see how this is concise.\n\nMy only complaint is that they're printing the result instead of returning it.\n\nTrue.\nIt's a pet peeve of mine too, but I think the point of the article was to show how the language lets you write concise code.\n\nExactly. I", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    def linears(numbers: List[float]) -> List[float]:\n    \"\"\" Given a list of numbers, apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> linears([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return (numbers.max() - numbers.min()) / 2\n\nI know, I know, you're saying \"How could you not understand the difference between a function and a method?\"\nI didn't know what a function was.  I thought it was a method, so I called it a method.  That's all.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\nI'm not sure what the point of this code is? Why not just call the built-in map function and apply it to the list of floats?\n>>> map(lambda x: x**2, numbers)\n[0.0, 0.5, 1.0, 2.0, 3.0]\n\nThat's a pretty common idiom.\n\nIndeed, list comprehensions are pretty common. I was just wondering what the value of explicitly typing this is.\n\nIn my experience, it's often useful to be able to write code like this in Python. The fact that it's easy to do so is what makes Python such a pleasant language to work in, for me.\n\n\"Rescale\" sounds like something that should be a mathematical operation or a library call. But, no, it's just a function that takes one argument and returns a different list.\n\nI agree. And it's even worse than that. It's a function that takes _no_ arguments and returns a different list.\n\nThe API should have a special return value for this. 'None' doesn't cut it.\n\nA transform operation like this is a one-way operation that cannot be undone. It", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    n = len(numbers)\n    res = []\n\n    if n == 2:\n        res = []\n    else:\n        res = List(n)\n\nreturn res\n\nThe naming of'rescale_to_unit' seems to imply that the transform might be from Unit to another numeric type, whereas in fact the transform is from the input's _actual_ domain to a range of the output's _unit_ (which is an unrelated concept, which is where the confusion comes from).\n\nI've seen this cause confusion in the past. It's an easy mistake to make, but it's not good practice. The name should be unambiguous.\n\nI totally agree. I'm not sure if this is an attempt at being clever or just a mistake.\n\nI think it's both.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\n    numbers.sort()\n\n    for i, number in enumerate(numbers):\n\n        number = rescale(number, nb_digits=2)\n\n        rescale_to_unit(number)\n\n\"nb_digits\" is not an argument.\n\nI know that, it's just the name of the function in the original article.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [x for x in numbers if x < 0]\n    numbers = [x + (x/10.0 * rescale_to_unit(len(numbers))) for x in numbers if x > 0]\n\nWouldn't this be much easier to read if it was written in Python 3 style?\n\nIn python 3 this is the correct way to do it:\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return map(float, numbers)</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for number in numbers:\n        new_number = number / 10\n        new_list = List()\n        for item in numbers:\n            new_number = new_number + item\n\n    return new_list", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.append(0.0)\n    for n in numbers:\n        if n < 0.0:\n             n = n * -0.25\n        else:\n             n *= 0.5\n    return numbers\n\nRescaleToUnit is clearly not the name of the function (which should be, I think, RescaleWithUnit), nor does it fit the spirit of the function.\nA better name would be RescaleByUnit.\n\nAlso, it's not very clear that the list has to be sorted.\n\nIt is part of a larger package, but a function name is still useful for searching code.\n\nI use a similar function, but I named it unit_scale_to_scale_numbers (or something like that).\nIn my use case I wanted the smallest and largest numbers to be zero, so I add 0.0 to the end of the list and then subtract one from the largest number. This ensures that the largest number is less than the smallest number", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    x = []\n    for n in numbers:\n        x.append(n / (1.0 + x[n]))\n    return x\n\nWhat?</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.reduce(lambda x, y: x + y, 0)\nI'm confused, what is the purpose of this function? It seems to be a list comprehension but it's already in the context of a function, so you can't use it as a comprehension.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if numbers.size == 2:\n       return numbers\n    return [numbers[i] / numbers[i + 1]]*2\n\nThis is just a horrible abuse of the language. There's just no need to go to the bother of wrapping the function in the typing module. It's a simple enough function that one can see the code is doing the correct thing just from the signature.\nBut, the real shame is that it's not even a library function. It's one that is being defined for the entire codebase to use.\n\nDoesn't the typing module make it easier to read?\nI have found myself writing things like:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.sort()\n    assert len(numbers) >= 2\n    # For the sake of this example, let the smallest number be 0\n    # and the largest be 1.\n    for n in numbers:\n       n = n * n\n    return List(n)\n\nfrom typing import List\n\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    numbers = numbers.sort()\n    assert len(numbers) >= 2\n    # For the sake of this example, let the smallest number be 0\n    # and the largest be 1.\n    for n in numbers:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(map(float, numbers))\n\nThanks for pointing this out.\nOn the one hand I think this is a nice example of the cost of using a poor choice of name for a function. It's not immediately obvious that the function is supposed to be called'rescale_to_unit' unless you think about it.\nOn the other hand, I have to say that I like this example of how to do type annotations in python - it's very concise and to the point. It could almost be a single line of code.\n\nOr \"from typing import List, unit\".\n\nI'm not familiar with python, but would this work:\nimport typing\nfrom typing import List, unit", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.values()\n    rescaled = []\n    for i in range(len(numbers)):\n        numbers[i] = float(numbers[i]) * 1.0 / float(numbers[i])\n    rescaled.append(rescaled[0])\n    return rescaled\n\nHuh? He's creating a list of floats and then simply dividing each one by the next one. This is about as \"inefficient\" as it gets, as it's completely linear and hence completely quadratic.\nThe equivalent in Python is:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n        return numbers\n    else:\n        return List(len(numbers) + 1)\n\nWhat is the purpose of this?\n\nThe purpose of the function is to return a list of numbers that are all equal to 1, where the largest number is a power of 2.\nThe original version of the function (sans import statement) was used in a homework question.\n\nWhy?</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    total = 0\n    for n in numbers:\n         total = total + n\n    return numbers\n\nIn Python 2.6, you can make this even more concise.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    res = 0.0\n    for i in range(len(numbers)):\n       res += numbers[i] * numbers[i+1]\n    return res\n\nWhen I was first learning python I tried this sort of thing on a fairly large list and it took forever to finish. I'm curious how this performs.\n\nIt performs well enough. In fact, it performs so well that Python's built-in sum() function is faster to run in most cases than rescale_to_unit(). The main problem is that it only works on the input range [0,1], so for example, it doesn't work on a list of floats because floats can't have negative values, and the sum of all floats would be undefined.\n\nHeh. I've been using Python for a few years and have never used sum(), or seen it used. Thanks for the explanation.\n\nDon't forget to also use type hints:\nfrom typing import List\nfrom typing import Int", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers\n\nWhat's wrong with this?\n\nMaybe the author was trying to show that even seemingly simple examples can be made better with types?\n\nI'd guess that's it. And I'd also guess that some of the types he used aren't as useful as he thinks they are.\n\nI'd think he was trying to show that it's easy to make a stupid mistake when writing in Python. It's trivial to refactor the code to the correct function.\nI'm not sure what the point of his examples is though. Is it that we should all be using the same types or that we should be using types?\n\nI think he was trying to show how easy it is to write the wrong thing in Python.\n\nI think you're right. He's showing how easy it is to write the wrong thing in Python, and then saying \"How would you do this better with types?\".\n\nI think that for this particular example, the best you could do with types would be to use the correct data structure, namely a list of doubles rather than a list of floats.\n\nHe is not saying that you need to use the same types as him. He is saying that it's a good", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    x = 0.0\n    for n in numbers:\n         if x <= n:\n             x += n\n    return x", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(lambda n: n * (n + 1))</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n        number = int(i)\n\n        number *= n", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers\n\nSome people (e.g. matlab) think about floats as binary fixed point numbers, which makes the following even more confusing.\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0])\n>>> print(rescale_to_unit(10.0))\n0.0\n\nI love when languages have integers and floats (or doubles, or whatever) as first-class values in the same way that functions, variables, etc. are.\nI'm not a big fan of arbitrary-precision arithmetic, but I definitely want to be able to add integers and floats together, multiply them together, divide them, and so forth.\n\nI think this is an interesting discussion to have, but the OPs code is in Python, so is there any question of whether you can do this?\n\nThe point of the article is that the implementation is straightforward, but the type system doesn't require you to do it. The Python code is just an example.\n\nBut the Python type system _does_ require you", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n         numbers.sort()\n         # round the absolute value of all numbers to the nearest integer\n         # round the result to nearest integer, and add to the list\n         return numbers.reduce(lambda v: v*(1+numbers.size()+v), 0)\n   </s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n    while numbers:\n        if len(numbers) == 2:\n           return numbers\n        for i in range(2, len(numbers)):\n              numbers.append(float(i))\n    return numbers\n\nThis is a really fun exercise to see how many python idioms can be jammed into a single file.\n\nI don't get it.\n\nIt's a really contrived, completely useless, completely fun toy example.\n\nI see, it's a \"this is how you can do it in python\" example.\n\nI'm not sure about the \"how you can do it in python\" part, but it is a fun exercise in Python idioms.\n\nThis is pretty neat! For a more idiomatic Python version, try this:\nfrom typing import List, float", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(float(n) / float(n+1))\n\nThis is a better example:\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    def apply_transform(x, y):\n          return x*x+y*y\n    for _ in numbers:\n          numbers.append(apply_transform(x, x[0])+apply_transform(x[1], y[0]))\n\nThis function will transform a list of numbers to a list of integers, preserving the original order.\n\nThis function is very similar to the median function, but it is not invertible.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for x in numbers:\n        if x > 0.5:\n            numbers.append(x / 0.5)\n    return numbers\nThis is exactly the kind of code I'm talking about in the blog post:\nyou've imported a module (in this case the List module) that you don't use, and you write a function (in this case rescale_to_unit) that contains a single statement (for x in numbers:).\nIn this case, if you just wrote your function without importing the List module, then you'd end up with code that is easier to understand, and you wouldn't have to import the List module.\nWhat I'm saying is that a lot of the time, you don't need to import a module at all, and you can just write your code.\n\nI think the import statement also sets up the namespace.\n\nYes, and the point of the blog post is that that's unnecessary.\n\nOne thing I noticed:\n>>> import random\n>>> random.random()\n<function random at 0x1015f0>\n\nI wonder if there is", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(lambda x: x**0.5)\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.reduce(0, (acc, x) -> x, 0)\n\nRescale() is the common name for a method with that signature.\n\nI'm not sure if the problem is that the title has \"Python\" in it. I'm also not sure how to go about solving that problem.\n\nIt's not just the title, it's the entire URL (i.e. \"hacker news\"). If it was\nhttp://news.ycombinator.com/item?id=2320685\nit would be a bit better.\n\nYes, it was a \"default\" title based on a pattern we've been using for years. I've asked dang to change it to the actual title of the article.\n\nActually I think it was the URL. The title is fine.\n\nGlad to hear it!</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n    # This could be done in-place, but we need to keep the original list.\n    # We could make a copy, but that would be redundant.\n    numbers_scaled = [0.0, 0.25, 0.5, 0.75, 1.0]\n    return list(numbers, *(numbers_scaled / float(numbers.len())))\n\nFrom the README:\n\"\"\"\nA library to help you convert floating point numbers to integers.\n\"\"\"\nIt also appears to use the standard library division operator (not mentioned in the readme), which should return a float if the divisor is not an integer.\n\nYou are correct. This was not a well-thought-out library. I do appreciate the criticism though.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i, number in enumerate(numbers):\n        if number >= 1:\n           return number\n        else:\n           return 0\n\nI'm not sure what the point of this is?\n\nI think the point is that some people need to know how to use the _built-in_ functions in python (`List` in this case). It's easy to get stuck in a mindset that any problem can be solved with a library.\n\nI like this answer, but it's not correct.\nThe point of this is that he's using the list type to do math on the list.\nSo the point is that you need to know how to use the built-in functions on your list types in order to do math on them.\n\nAnd also, it's a great example of how much more readable Python is compared to Java.\n\nYeah I'd say that's one of the biggest advantages of Python for me.\n\nI actually wrote something similar a few months ago but on a bigger scale.\nI wanted to find a way to", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.sort()", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(float(n) * float(n/len(numbers)))\n\nfrom typing import List\n\nfrom collections import defaultdict", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n        return numbers\n    for number in numbers:\n        if number < 0:\n            return number\n\n    return List(number / (float(number) / float(0.0)))\n\nIf you don't have Python, here's a Javascript version\n\nfrom Number import Number, Number, Float\n\nfrom String import String\n\nfrom Function import Function", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.sort()\n    rescale = x ** (1 + y)\n    for i in numbers:\n        rescale = rescale ** i\n    return numbers\n\nThat's nice, but it's actually more efficient to use a list comprehension (Python 2.x):\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n[0.0, 0.25, 0.5, 0.75, 1.0]\n\nThanks! I'm still relatively new to Python so I'm not familiar with the list comprehension syntax.\n\nUse  for good suggestions on Python coding style.\n\nList comprehension is probably the most powerful construct in Python, in my opinion. It allows you to create an arbitrarily complicated expression that can be passed around, manipulated, and returned in a single expression.\nFor example, suppose you want to evaluate a function that takes a list of integers and returns a list of the square of the integers. Instead of doing:\n>>> def square(x):\n    return x ** 2\n>>> square(1)", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for number in numbers:\n        if number < 0.0:\n            number = 0.0\n        if number > 1.0:\n            number = 1.0\n\nIs it just me, or would this be a lot more readable if it was:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.sort()\n\nThat code has a bug. It is not obvious, but it is there.\nPlease don't write Python code with bugs in it.\n\nVery good. I had a similar reaction. But I would phrase it more like:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    list = []\n    for n in numbers:\n       list.append(n * (n + 0.5))\n    return list\n\n>>> scale_numbers(['0.1', '1.0', '2.0', '3.0', '4.0', '5.0']).sort()\n        [0.1, 1.0, 2.0, 3.0, 4.0, 5.0]\n\nA more idiomatic Python version:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(0.5+numbers[0], 0.25+numbers[1], 0.75+numbers[2], 0.0+numbers[3], 1.0+numbers[4])", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n         for j in numbers:\n            if i < j:\n                  numbers[i] /= numbers[j]\n                   numbers[i] = 1.0\n\n    return numbers\n\nfrom typing import List\n\n    def vectorize_to_unit(list: List[float]) -> List[float]:\n    \"\"\" Given list of numbers, return the same list transposed.\n    >>> vectorize_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.5, 0.25, 1.0, 2.0]\n    \"\"\"\n    for i in list:\n         list[i] = list[i]\n         list[i] = 1.0\n\nfrom", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if n1 + n2 >= 1.0:\n        return List(n1 + n2 / 2)\n    else:\n        return List(n1)\n\nCan someone explain the need for the \"return List(n1 + n2 / 2)\" part?\nI would have thought it would be sufficient to simply return List(n1) or List(n2).\n\nPerhaps the function is meant to be recursive?\n\nI'm guessing you mean the result is meant to be used as a call to the function itself?\n\nI do not know why you would want to return a new list in this case, but it is possible to return a new list and then call the function on that list.\nI think it would be more concise to use a map or reduce function.\n\nI don't think the original code is a good example. The problem it's trying to solve (converting a list of numbers to a list of integers with even spacing) is very well suited to an array, and it would be more compact and easier to understand if the two line code was converted to something like:\n>>> def even", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(float(numbers[0])/float(numbers[1])*0.5)\n\nThat was exactly my first thought, too.\n\nOn the other hand, the author does talk about the limitations of this approach:\n\nThe article was very short on how this technique could be used for actual numeric calculations.\n\nNot sure if I'm missing something, but it seems to me that one could use this technique to do arbitrary-precision arithmetic:\nimport types,\ntypes.List,\ntypes.float", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n         if i < 2:\n             i = 0.0\n          else:\n              i = i / (i+1)\n    return List(i)", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n\nIf I understand it correctly, you are just converting a list of floats to a list of integers.\nThe first step should be to find the largest and smallest elements in the list and return them as integers.\n\nI was actually planning to add that. The output of this function is not correct if the list is missing a number.\n\nYou are right about the missing number. The function returns the largest or smallest number if the list is missing one, but this may not be what you want.\n\nThis is a nice one. I've seen some good functions that turn a list into an array, but this one is a good one for the opposite direction.\nI'm curious if the change in code would be greater with more complicated transforms?\n\nThis is a very good idea, but for a library to be useful it needs to be generalizable.\nYou could expand this library by adding support for matrix-matrix transforms. For example, you could add support for doing linear transforms on matrices. It's not a trivial task, but it's one that is of great use in scientific and engineering applications.\n\nYeah, I can imagine some advanced applications. I also would like to make it more general, but I wanted to", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n        numbers.pop(0)\n    else:\n        numbers = numbers.sort()\n\n    if n > 1:\n        n = len(numbers) - 1\n        result = []\n\n        for i in numbers:\n            result.append(i / n)\n            numbers.pop(0)\n\n    return result\n\nNeat trick, but I'm getting an error:\n\nMaybe try\n\nThe gist is that the newline that ends the def statement is being treated as the end of the file, and the program isn't seeing the imports.\n\ntry to remove the \\n before the from typing import List;\n\nworks for me.\n\nI like this:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(0, len(numbers) - 1):\n        numbers.append(List(scaler.scale(i, numpy.inf, 1.0) / numpy.pi))\n\nDoesn't this also work with:\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    print numpy.sqrt(numbers[0])\n    for number in numbers[1:]:\n       print numpy.sqrt(number)\n    return numbers</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    # Compute the maximum, minimum, and mean\n    max_n = numbers.most_common(lambda n: n, 0)\n    min_n = numbers.most_common(lambda n: n, 1)\n    mean = numbers.mean()\n\n    # For each item in the list, compute the transform\n    for i, n in enumerate(numbers):\n        total = total + n\n        mean_n = mean(total)\n        min_n = min_n + n\n        max_n = max_n - n\n\n    # Use the transform to transform the elements into the range 0 to 1\n    # Applying the transform to any negative number will produce a negative number\n    # from the transform\n    for i in range(0, len(numbers)-1):\n        transform = rescale_to_unit(numbers[i])\n        numbers = numbers.con", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    def nth_element(lst: List[int], index: int):\n        return lst[index]\n    n = len(numbers)\n\n    for i in range(n):\n        lst[nth_element(lst, i)] = 0.0\n    return list(numbers)</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    numbers = numbers.sort(key=lambda x: float(x)/10)\n    numbers = (float(numbers[0]) + float(numbers[1]))/2\n    return numbers\n\nThis is my favorite Python function name: \"from typing import List\"\n\nI've seen a few of them, and I've wondered what the joke is.\n\ntype!= type\n\nWhoa, it's a Python function that returns a list of integers?\n\nNo, it returns a list of floats. The function is named after the Python type \"list\" not \"list of integers.\"\n\nAnd in case you're wondering, the type of the function (which is what shows up when you type 'def') is \"function\".\n\nI'm glad I wasn't the only one who was confused by this.\n\n\"from typing import *\" is soooo much better.\n\nAnd a bit more dangerous.\n\nOnly if you use it to import things that don't exist. I just tested it on python 3.1.3 and it imported stuff correctly.\n\nThat's pretty cool. But I get the"]]