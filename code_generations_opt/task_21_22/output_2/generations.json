[["from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(2,len(numbers)):\n         for j in range(2,len(numbers)):\n              if i%j == 0:\n                  numbers[i,j] = numbers[i,j] * (1.0 - numbers[i,j])", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in numbers:\n        numbers[i].abs() *= -1.0 / i\n    return numbers\n\nIt's not even a for loop.\n\nIt's a for loop, but the for loop is inside a function.\n\nYes, but the point is that it's not an imperative for loop. It's a functional one.\n\nIt's not really a for loop at all, it's a recursive function.\n\nI don't think it's a for loop, it's a functional for loop.\n\nIt's not a for loop, it's a functional for loop.\n\nIt's not a for loop, it's a functional for loop.\n\nIt's not a for loop, it's a functional for loop.\n\nIt's not a for loop, it's a functional for loop.\n\nIt's not a for loop, it's a functional for loop.\n\nIt's not a for loop, it's a functional for loop.\n\nIt's not a for loop, it's a functional for loop.\n\nIt's not a for loop, it's a", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n        numbers[i] *= 1.0 / i\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in numbers:\n        if i < 0:\n           numbers.pop(i)\n        else:\n           numbers.append(i / 100.0)\n    return numbers\n\nI would be tempted to use a dictionary and do the transformation on the dictionary.\n\nIt's hard to tell if that's an improvement or not.\nI'd have to look at the performance of the two approaches.\n\nI would think the dictionary approach would be faster.\n\nI would think the opposite.\nThe dictionary approach will have to look up the value in the dictionary every time it's used.\nThe list approach will have to look up the value in the list every time it's used.\n\nThe dictionary approach would only have to look up the value if the values are not already in the dictionary.\n\nThe dictionary approach would have to look up the value if the values are not already in the dictionary _and_ if the value is not already in the list.\n\nI would like to see this", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(numbers.map(lambda x: x.astype(float), lambda y: y.astype(float) / x.astype(float)))\n\nThis is not a pythonic solution, but it works.\n\nI like the second solution.\n\nIt's not a Pythonic solution, but it works.\n\nI like the second solution.\n\nIt's not a Pythonic solution, but it works.\n\nI like the second solution.\n\nIt's not a Pythonic solution, but it works.\n\nI like the second solution.\n\nIt's not a Pythonic solution, but it works.\n\nI like the second solution.\n\nIt's not a Pythonic solution, but it works.\n\nI like the second solution.\n\nIt's not a Pythonic solution, but it works.\n\nI like the second solution.\n\nIt's not a Pythonic solution, but it works.\n\nI like the second solution.\n\nIt's not a Pythonic solution, but it works.\n\nI like the second solution.\n\nIt's not a Pythonic solution, but it works.\n\nI like", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.sort()\n    return numbers.reduce(lambda x, y: x + y, 0)\n\nIt's not just a list of numbers, it's a list of floats.\n\nSo what? The python interpreter can deal with that.\n\nI think the point is that it's not just a list of numbers, it's a list of floats.\n\nI think the point is that it's not just a list of numbers, it's a list of floats.\n\nI think the point is that it's not just a list of numbers, it's a list of floats.\n\nI think the point is that it's not just a list of numbers, it's a list of floats.\n\nI think the point is that it's not just a list of numbers, it's a list of floats.\n\nI think the point is that it's not just a list of numbers, it's a list of floats.\n\nI think the point is that it's not just a list of numbers, it's a list of floats.\n\nI think the point is that it's not just a list of numbers, it's a list of floats.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for number in numbers:\n         if number < 0.0:\n              number = 0.0\n         else:\n              number = number * 0.5\n    return numbers\n\nIt's not immediately obvious to me why the list is necessary. It's also not immediately obvious to me why you're multiplying by 0.5.\nIt's also not immediately obvious to me why the list is necessary. It's also not immediately obvious to me why you're multiplying by 0.5.\nIt's also not immediately obvious to me why the list is necessary. It's also not immediately obvious to me why you're multiplying by 0.5.\n\nI think the list is necessary because you need to know what the smallest and largest numbers are.\nI think the list is necessary because you need to know what the smallest and largest numbers are.\nI think the list is necessary because you need to know what the smallest and largest numbers are.\nI think the list is necessary because you need to know what the smallest and largest", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n         numbers.append(i / 2.0)\n    return numbers\n\nI would have used `div` instead of `/`; but then I'm not sure that `/` is the right operation to use, since I'm not sure if it will preserve order.\n\n`div` would give you a list of integers, and you would have to use `floor` to get a list of floats.\n\nThe point is that you should be able to write a function that takes a list of numbers and returns a list of numbers, without having to use any special operators.\n\nI agree. I was just pointing out that it's not a good idea to use / in this case.\n\nThe point is that you should be able to write a function that takes a list of numbers and returns a list of numbers, without having to use any special operators.\n\nI agree. I was just pointing out that it's not a good idea to use / in this case.\n\nI don't think you were. I think you were saying that you would have used `div` instead of `/`; but then I'm", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(map(float, numbers))\n\nI think you meant to type \"from typing import List, map, float\"\n\nI think you mean \"from typing import List, map, float, float\"\n\nI think you mean \"from typing import List, map, float, float, float\"\n\nI think you mean \"from typing import List, map, float, float, float, float\"\n\nI think you mean \"from typing import List, map, float, float, float, float, float\"\n\nI think you mean \"from typing import List, map, float, float, float, float, float, float\"\n\nI think you mean \"from typing import List, map, float, float, float, float, float, float, float\"\n\nI think you mean \"from typing import List, map, float, float, float, float, float, float, float, float\"\n\nI think you mean \"from typing import List, map, float, float, float, float, float, float, float, float\"\n\nI think you mean \"from typing import List, map, float, float, float, float, float, float, float", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = List(numbers)\n    return numbers.map(lambda x: x * 0.5)\n\nI'm not sure what the point is. This is just a simple linear transformation.\n\nI think the point is that the code is shorter than the equivalent in Python:\nimport numpy as np", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    x = 1.0\n    y = 1.0\n\n    for i in range(len(numbers)):\n        numbers[i] = numbers[i] / x\n\n    return numbers\n\nIn other words,\n(1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x) * (1.0 / x)", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i, number in enumerate(numbers):\n         number = number * i\n    return numbers\n\nI'm not sure if this is an appropriate place to ask, but what is the purpose of this code?\n\nI think it's an example of a list comprehension. I think.\n\nNope, it's a list of functions.\n\nI think it's an example of a list comprehension. I think.\n\nIt's not.\n\nI think it's an example of a list comprehension. I think.\n\nNo, it's a list of functions.\n\nI think it's an example of a list comprehension. I think.\n\nIt's not.\n\nI think it's an example of a list comprehension. I think.\n\nNo, it's a list of functions.\n\nI think it's an example of a list comprehension. I think.\n\nIt's not.\n\nI think it's an example of a list comprehension. I think.\n\nNo, it's a list of functions.\n\nI think it's an example of a list comprehension. I think.\n\nIt's not.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n        return numbers\n    else:\n        return numbers.map(numbers.itemgetter(0))\n\nI was going to say that you should have used numpy.map, but it looks like you did.\n\nThis is not a good example of how to use Python, but it's a good example of how to use the Python _standard library_.\n\nI'm not sure why you think it's not a good example of how to use Python. The OP is doing basic data manipulation with Python.\n\nIt's not a good example of how to use Python because it's just a simple example of how to use the standard library.\n\nI still don't understand your point. The OP is doing basic data manipulation with Python.\n\nI'm not sure what you're not understanding.\nThe OP is using a simple example of how to use the standard library to do basic data manipulation.\nThe OP is not using Python to do basic data manipulation.\n\nI'm not sure what you're not understanding. The OP is doing basic data manipulation with Python.\n\nYou keep", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.sort()\n    return numbers.apply(lambda x: x / float(len(x)))\n\nHow is this better than \"from typing import *\"?\n\nIt's a lot less typing.\n\nI like it.\n\nI don't like it.\n\nI like it.\n\nI don't like it.\n\nI like it.\n\nI don't like it.\n\nI like it.\n\nI don't like it.\n\nI like it.\n\nI don't like it.\n\nI like it.\n\nI don't like it.\n\nI like it.\n\nI don't like it.\n\nI like it.\n\nI don't like it.\n\nI like it.\n\nI don't like it.\n\nI like it.\n\nI don't like it.\n\nI like it.\n\nI don't like it.\n\nI like it.\n\nI don't like it.\n\nI like it.\n\nI don't like it.\n\nI like it.\n\nI don't like it.\n\nI like it.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(float(0.0))\n\nThis is a classic example of why you shouldn't use global variables.\n\nI don't know what you mean.\n\nI think he means that the function's name is'rescale_to_unit', but the function doesn't return a list of numbers. It returns a single number.\n\nOh, I see. It's a _function_, not a _function_ function.\n\nThis is a classic example of why you shouldn't use global variables.\n\nI don't know what you mean.\n\nI think he means that the function's name is'rescale_to_unit', but the function doesn't return a list of numbers. It returns a single number.\n\nOh, I see. It's a _function_, not a _function_ function.\n\nYou can't really say that. It's a function in the sense that it returns a value, but it's not really a function in the sense that it doesn't take any arguments.\n\nI think it's a function in the sense that it returns a value. It's a function in the sense that it returns a value of type List[", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.copy()\n    for i in range(len(numbers)):\n         numbers[i] = numbers[i].scale(1.0 / i)\n    return numbers\n\nThis is a very good example of why one should use the builtin Python list functions.\n\nGood point.\n\nI was a bit surprised to see this in the docs for the module:\n\"The built-in function len() is not available in Python 3.0.\"\nBut then I see that this module is in fact released under the 2.x license, so it's not a surprise.\n\nIt's not available in Python 3.0, but it is available in Python 3.1.\n\nIt's a shame that python 3.1 is not yet released.\n\nI'm not sure if you're being sarcastic or not, but I've been using 3.1 for quite some time.\n\nNot being sarcastic at all.\n\nI don't see what this offers that you can't get with:\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(2,len(numbers)):\n        numbers[i] = numbers[i] / (float(i) + 1.0)\n    return numbers\n\nThis is a great example of why Python's \"type-checking\" is so weak.\nYou can create a list with a list of integers and call it a list of floats, and the type checker will let you pass it to a function that expects a list of floats.\nYou can also pass a list of floats to a function that expects a list of integers, and the type checker will let you do that too.\n\nI don't think it's that bad. I think the type system is pretty good. It does have a few weak points, but I think it's a lot better than most languages.\nI think the problem is that most people don't understand the type system and don't know how to use it properly.\n\nI don't think it's that bad either, but the fact that you can pass a list of integers to a function that expects a list of floats is a pretty big weakness.\n\nWhat's the advantage of not allowing this?", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for number in numbers:\n         n = number.pow(2)\n         if n < 0.0:\n              n = n / 2\n               number = rescale_to_unit(numbers[-1])\n    return list(number)\n\nI've seen that a lot, but I've never understood it. What's the point?\n\nThe point is that it's a simple example of a linear transform.\nIf you have a list of numbers (of at least two elements) and you want to rescale them so that the smallest number is 0 and the largest is 1, then this is the simplest way to do it.\n\nAh, I see. Thanks.\n\nI've used a similar method in C# to scale a list of objects by a power of 2.\nIt's also useful if you want to normalize a list of objects to be in the range 0-1.\n\nYeah, this is a pretty common operation in C++ and C#,", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) < 2:\n        raise ValueError(\"numbers must have at least 2 elements\")\n    numbers = [0.0, 0.25, 0.5, 0.75, 1.0]\n    return numbers\n\nI've always been a fan of the \"If it's worth doing, it's worth overdoing\" school of thought.\n\nThe \"if it's worth doing, it's worth overdoing\" school of thought is a great way to waste a lot of time.\n\nI can't tell if you're being sarcastic or not.\n\nI can't tell either.\n\nI think the point is that the \"if it's worth doing, it's worth overdoing\" is usually used in the context of \"if it's worth doing, it's worth doing well\". In that case, it's not a waste of time.\n\nI'm not sure why that's the point. I think the point is that the \"if it's worth doing, it's worth doing well\" is usually used in the context of \"if it's worth doing, it's worth doing well\".\n\nI think", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    new_list = List()\n    for i in numbers:\n        new_list.append(i * 0.0)\n    return new_list\n\nJust curious, what are the practical applications of this?\n\nI've found it handy for converting a list of floats to an integer.\n\nThat's a good idea. I use this trick in C, but I usually use the \"int to float\" conversion, and then convert back to int.\n\nI think this is a lot more readable than the other way around.\n\nWhy would you want to do this?\n\nI've used this before to convert a list of floats to a list of ints, for use in a for loop.\n\nHow is that more readable than just using ints?\n\nIf you want to do something like:\nfor (int i = 0; i < numbers.length; i++) {\ndo_something(i)\n}\nit's easier to pass in a list of floats than a list of ints.\n\nI don't see how. You can just as easily pass in a list of ints, and you don't", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n        return numbers\n    else:\n        return List(0.0, numbers.pop(0))\n\nI'm not sure what the point of this is. It's not like the original list is a list of floats. It's a list of integers.\n\nI didn't get it at first either, but I think the point is to have a way to rescale a list of numbers in a way that is guaranteed to be monotonic.\n\nI think it's more like \"if you have a list of floats, you can convert it to a list of ints and back, without worrying about the order\".\n\nIt's interesting to see how some of the Haskell idioms are carried over to Python.\n\nI'm not sure if this is an idiom in Haskell or just a normal function.\n\nThis is a common idiom in Haskell.\n\nIt's also a common idiom in C, C++ and Java.\n\nIt's also a common idiom in C++, C and Java.\n\nIt's also a common idiom in C,", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    n = 0\n    for i in numbers:\n        if n == 0:\n           n = 1.0\n        else:\n           n = n * (n - 1.0) / (i * (n - 1.0))\n    return list(n)\n\nI always wondered, why is it that in python, a list is a list of lists?\n\nIt's a list of tuples.\n\nI think it's better to say it's a list of dicts, because the first element is a list.\n\nI'm a fan of the dict-of-lists notation.\n\nI've been using this for a while, but I never realized that it was a list of lists. I always thought it was a list of tuples.\n\nThe first element of a list is a list, not a tuple.\n\nOh, I see. Thanks.\n\nI don't think this is a good idea.\n\nWhy not?\n\nIt's not very pythonic. It's a", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    numbers = numbers.sort_index(lambda i: i.d)\n    return List(numbers)\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers\n\n>>> import numpy as np\n>>> np.array([1.0, 2.0, 3.0, 4.0, 5.0])\narray([[1.0, 2.0, 3.0, 4.0, 5.0],\n[0.0, 0.25, 0.5, 0.75, 1.0]])\n>>> np.reshape(np.array([1.0, 2.0, 3.0, 4.0, 5.0]), (1, 2, 3, 4, 5))\narray([[1.0, 2.0, 3.0, 4.0, 5.0],\n[0.0, 0.25, 0.5, 0.75, 1.0]])\n>>> np.reshape(np.array([1.0, 2.0, 3.0, 4.0, 5.0]), (1, 2, 3, 4, 5))\narray([[1.0, 2.0, 3.0, 4.0, 5.0],\n[0.0, 0.25, 0.5,", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if numbers:\n        numbers = [0.0, 0.25, 0.5, 0.75, 1.0]\n        return numbers\n\nThat's a pretty cool idea. I don't know if it's just me, but I've always had a hard time understanding the concept of a list of numbers.\n\nI'm not sure what you mean. Do you mean that you have a hard time understanding what a list is, or that you have a hard time understanding what a list of numbers is?\n\nBoth. I'm not a mathematician.\n\nWell, a list is simply a collection of elements, and a list of numbers is a collection of numbers.\n\nThat's not what I meant. I know what a list is. I mean that I don't understand the concept of a list of numbers.\n\nA list of numbers is just a list of numbers. A list of numbers is just a list of numbers. A list of numbers is just a list of numbers. A list of numbers is just a list of numbers. A list of numbers is just a list of numbers. A list of numbers is just a list of numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(lambdax:x*x**2)\n\nfrom typing import List, int", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.sort()\n\n    return List(numbers.map(numbers.pop()).map(numbers.pop()).map(numbers.pop()))\n\nWhat is the point of that?\n\nThe point is that it is a joke. It is the sort of thing you would see on a computer science humor site.\n\nThe problem is that it's not funny.\n\nI think it's pretty funny.\n\nI agree. It's a joke, not a serious program.\n\nI don't get it. Is there some significance to the List?\n\nIt's a list of numbers that you can rescale to a unit scale.\n\nI think I'm just too dense for this.\n\nI don't get it either.\n\nI think it's a joke about the way people sometimes use python.\n\nI think it's a joke about the way people sometimes use programming languages.\n\nI don't get it.\n\nI don't get it.\n\nI don't get it.\n\nI don't get it.\n\nI don't get it.\n\nI don't get it.\n\nI don't", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    x = 0.0\n    for i in range(len(numbers)):\n        x = x * i\n    return x", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(2, len(numbers)):\n        numbers[i] = (numbers[i] * (numbers[i] / 10.0)) / 10.0\n\n    return numbers\n\nNote: This is a joke.\n\nThis is a joke, right?\n\nYes.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    def transform(numbers: List[float]) -> List[float]:\n    \"\"\" Apply a linear transform to the numbers in the list.\n    >>> transform([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return numbers.map(float(numbers[0]))\n\nThat's a really bad example. If you're going to use a linear transform, it's better to use the log transform, which is much more natural for this type of problem.\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0], log=True)\n[0.0, 0.25, 0.5, 0.75, 1.0]\n\nYou're right, that is a much better example. I didn't even think about that.\n\nI think a better way to approach the problem is to define a function for each type of transformation you need. For example, if you need to scale", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n        n = numbers[i]\n        if n < 0:\n              n = -n\n              n = rescale_to_unit(numbers[i+1])\n              n = -rescale_to_unit(numbers[i+2])\n    return n\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n        numbers.append(i * 1.0 / n)\n    return numbers\n\nThat's one of the worst pieces of code I've seen in a while. I can't even begin to explain how much wrong there is with it.\n\nIn what way?\n\nI'm guessing the \"numbers\" is a list of floats, but the code is expecting a list of numbers.\n\nYou're right, but the code is not expecting a list of numbers.\nIt's expecting a list of floats.\n\nI'm not sure if I'm missing something, but it's not very obvious what the code is doing.\n\nI don't think it is supposed to be.\n\nI'm not sure if I'm missing something, but it's not very obvious what the code is doing.\n\nI don't think it is supposed to be.\n\nI'm not sure if I'm missing something, but it's not very obvious what the code is doing.\n\nI don't think it is supposed to be.\n\nI'm not sure if I'm missing something, but it's not", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(lambda x: x * 1.0)\n\nI'm not sure what the point of this is, but it's a fun trick.\n\nIt's a good way to see the effect of a linear transform on a list of numbers. It's not a particularly efficient way to do it, though.\n\nI'm not sure what the point of this is, but it's a fun trick.\n\nIt's a good way to see the effect of a linear transform on a list of numbers. It's not a particularly efficient way to do it, though.\n\nYou can make a list of lists of numbers and apply the transform to each of the lists of numbers in parallel.\n\nI'm not sure what the point of this is, but it's a fun trick.\n\nIt's a good way to see the effect of a linear transform on a list of numbers. It's not a particularly efficient way to do it, though.\n\nYou can make a list of lists of numbers and apply the transform to each of the lists of numbers in parallel.\n\nI'm not sure what the point of this is, but it's a fun trick.\n\nIt's a good", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = List(numbers)\n    for i in range(len(numbers) - 2):\n        numbers.append(numbers[i])\n        numbers.sort()\n        numbers.reverse()\n    return numbers\n\nI'm not sure if this is a good thing or not, but I'm finding it very hard to find a use for this.\n\nYou are right, there is no use for this.\n\nI think it's useful for debugging/testing.\n\nHow is this useful for debugging/testing?\n\nYou could use it to scale your input numbers to make them all the same size, which makes it easier to test for equality.\n\nThis is really cool. I'm going to use it to make sure my numbers are within the bounds of an int.\n\nI was going to say, isn't this the normal way to do this?\n\nYes, and it's one of the first things you learn in a numerical methods class.\n\nDoesn't that sort of defeat the purpose of having a list?\n\nNot at all. This is", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(List(0.0)).map(List(1.0)).sum()\n\nThat's pretty nice. I like how it's a single function with a single argument, and it does exactly what it's supposed to do.\n\nI'm not sure it's that nice. It doesn't even do what it says it does.\nTry:\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n[0.0, 0.25, 0.5, 0.75, 1.0]\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0], 2)\n[0.0, 0.25, 0.5, 0.75, 1.0, 1.0]\n\nThe function is correct.\nThe first call is correct. The second call is not. The second call is using the result of the first call as an argument, but that argument is a list, not a tuple.\n\nIn Python 2.7, it's a tuple.\n\nPython 2.7 is not", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(numbers.map(numbers.map(numbers.map(0, 1)))\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n        return numbers\n    if len(numbers) == 3:\n        return [numbers[0], numbers[1], numbers[2]]\n    if len(numbers) > 3:\n        return numbers\n    return [numbers[0], numbers[1], numbers[2], numbers[3], numbers[4],", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(2, len(numbers)):\n          numbers[i] = numbers[i] / i\n    return List(numbers)\n\nIt's not even that.\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n[0.0, 0.25, 0.5, 0.75, 1.0]\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0], [1.0, 2.0, 3.0, 4.0, 5.0])\n[0.0, 0.25, 0.5, 0.75, 1.0]\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0], [0.0, 0.25, 0.5, 0.75, 1.0])\n[0.0, 0.25, 0.5, 0.75, 1.0]\n>>> rescale_", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(range(0,numbers.size()))\n\nWhy not just:\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n[0.0, 0.25, 0.5, 0.75, 1.0]\n\nBecause I like to use the type system when I can.\n\nThis is cool, but it's not really \"using the type system\" in the sense of \"using the type system to do something useful.\" It's just a way to make a list of floats into a list of ints.\n\nWell, if you want to make a list of ints, you can just use the built-in function, right?\n\nYes. The built-in function is more useful and more efficient than the OP's version.\n\nIt is, but the point is that it's also less explicit.\n\nI think the most common way to do this is to use the built-in function:\n>>> [1.0, 2.0, 3.0, 4.0, 5.0]\n[1, 2, 3, 4, 5]", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(1, len(numbers)):\n         numbers.append(i * 1.0 / float(numbers[i]))\n    return numbers\n\nIt's not a very good example. The only reason the function works is because it's using Python's built in list operations. If you change the type of the list to a tuple, the function will fail because it's trying to apply a function to a tuple.\n\nWhat's the problem? That's what you'd do with a tuple, isn't it?\n\nYou can't apply a function to a tuple. You can apply a function to a list of tuples, but not a tuple.\n\nThe point of the example is that the function works because it's using the built-in list operations. The point of the comment is that you can't apply a function to a tuple, so you'd have to use a list instead.\n\nThe point of my comment is that the function works because it's using built-in list operations and that if you change the type of the list to a tuple, the function will fail because it's trying to apply a function to a tuple", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(float)\n\nThis is a very bad idea. If you're going to do this sort of thing, you need to write a function that is guaranteed to be idempotent.\n\nI don't think that's necessary.\n\nIf you're going to use a function in a situation where the order of its arguments matters, then you should make sure that the function is idempotent.\n\nI don't think it's necessary to make sure that the function is idempotent.\n\nIt's not necessary, but it's a good idea.\n\nIt's not a good idea, but it's a good practice.\n\nIt's not a good practice, but it's a good principle.\n\nIt's not a good principle, but it's a good rule of thumb.\n\nIt's not a good rule of thumb, but it's a good idea.\n\nIt's not a good idea, but it's a good principle.\n\nIt's not a good principle, but it's a good rule of thumb.\n\nIt's not a good rule of thumb, but it's a good idea.\n\nIt's not a good idea,", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(float(x) for x in numbers if x > 0.0)\n\nIs there a reason that you're using list.map instead of map?\n\nBecause the author is trying to learn Python.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n        return List(0, 1)\n    else:\n        return List(len(numbers), -1)", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n        numbers.append(i / n)\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i < 0:\n            i = 0\n        else:\n            i *= 2\n         return numbers\n\nfrom typing import List\n\n    def rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    for i in numbers:\n        if i < 0:\n            i = 0\n        else:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = []\n    for i in numbers:\n        if i > 1:\n            numbers.append(i)\n            numbers.append(i / 2.0)\n    return numbers\n\nCan you explain what that's supposed to do?\n\nIt takes a list of numbers, and returns a list of the same length, with the smallest number having a value of 0 and the largest a value of 1.\nIt's a simple example of a linear transform, and it's a very useful thing to know how to do.\n\nThat's a _linear transformation_, not a _linear transform_.\n\nI've never heard of the term \"linear transform\" before. I'm assuming that it's some sort of transform that is linear in the input. Is that correct?\n\nThe term is used in signal processing. A linear transform is a function that is linear in the input, and has the property that its output is orthogonal to its input.\n\nOrthogonal?\n\nOrthogonal means \"perpendicular\" in", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [numbers.copy() for number in numbers if number < 0.5]\n    return numbers.sort()\n\nAnd then, to avoid the typing:\n>>> from collections import defaultdict\n>>> from typing import List\n>>> def rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit = defaultdict(float, List)\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    numbers = [numbers.copy() for number in numbers if number < 0.5]\n    return numbers.sort()\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for number in numbers:\n        if number < 0.0:\n            number = 0.0\n        else:\n            number = 1.0\n    return numbers\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [0.0, 0.25, 0.5, 0.75, 1.0]\n    return List(0.0, 1.0)\n\nI always felt that it's easier to use python's built-in list-mapping functions, like map and reduce.\nmap(lambda x: x*x for x in numbers)\n\nThe point of this is to show how to do it with pure Python.\n\nThis is a very bad example of that.\n\nI think it's a good example. It shows how you can take a list of numbers and apply a transformation to the list such that the smallest number is 0 and the largest number is 1.\n\nAnd this is an even better example of how to do it with pure Python:\nx = (x * x) ** 2\n\nI don't understand the point of this post.\n\nI thought it was pretty clear:\n(1) It's a simple example of using Python's list-mapping functions (map, reduce) to transform a list of numbers into a list of numbers of a different scale.\n(2) It's a simple example of using Python's list-m", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return [0.0, 0.25, 0.5, 0.75, 1.0]\n\nI like how the explanation of the algorithm is almost as long as the actual code.\n\nI like the explanation, it's very clear and I can imagine the algorithm.\nI don't like the code, it's not very clear and I can't imagine the algorithm.\n\nI like the code, it's very clear and I can imagine the algorithm.\nI don't like the explanation, it's not very clear and I can't imagine the algorithm.\n\nI like the explanation, it's very clear and I can imagine the algorithm.\nI don't like the code, it's not very clear and I can't imagine the algorithm.\n\nI like the code, it's very clear and I can imagine the algorithm.\nI don't like the explanation, it's not very clear and I can't imagine the algorithm.\n\nI like the code, it's very clear and I can imagine the algorithm.\nI don't like the explanation, it's not very clear and I can't imagine the algorithm.\n\nI like the code, it's very clear and I can imagine the", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n         if i < 0.0:\n             i = 0.0\n          else:\n             i = i * (i + 1.0) / (2.0 ** i)\n    return numbers\n\nWhat is the benefit of using this? I can't think of a case where this would be useful.\n\nYou can use it to convert a list of floats into a list of integers.\n\nI'm not sure why you would want to do that.\n\nI use it for parsing numbers from the command line.\n\nI'm not sure why you would want to do that either.\n\nI don't know why you would want to do that, but I'm not sure why you would want to do that.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) < 2:\n        return []\n    n = numbers[0]\n    if n < 0:\n        n = 1.0\n    else:\n        n = n * (n+1)/2\n    numbers[0] = n\n    numbers[1] = n * (n+1)/2\n    return numbers\n\nIt's a good thing the author is not a programmer.\n\nThat's a very rude thing to say.\n\nI was trying to be funny. I think it's a cute little program.\n\nIt's a cute little program that doesn't really work. The author has a nice idea, but he doesn't really know how to implement it.\n\nI don't think that's true. The code is pretty clear and well-written.\n\nI think the code is clear and well-written too, but it's not clear what the program is supposed to do.\n\nWhat's not clear about it? It's a simple utility function.\n\nWhat is it supposed", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers\n\nI don't get it.\n\nIt's a joke. It's a reference to a Python bug that is so famous that it has its own page on Wikipedia:\n\nI am sorry for the silly question, but what is the joke? I know about the bug, but I don't understand what the code does.\n\nIt's a reference to the famous Python bug. The bug was that the developers didn't realize that their list() function was returning a list of lists, not a list of lists, so they didn't make it properly immutable. This meant that you could write code like this:\n>>> list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n        return numbers\n    else:\n        return List(rescale_to_unit(numbers[0], numbers[1]) + 1)\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(1,len(numbers)):\n        if i < 0.5:\n            numbers[i] = 0.0\n        else:\n             numbers[i] = 1.0\n    return numbers\n\nI've never understood why people do this. It's a bit more verbose and you lose the ability to iterate over the list.\n\nI've never understood why people use Python in the first place. It's a bit more verbose and you lose the ability to iterate over the list.\n\nPython is a nice language. I've used it since the late 90's and I've never felt the need to use any other language.\n\nI've used it since the late 90's and I've never felt the need to use any other language.\n\nI've used it since the late 90's and I've never felt the need to use any other language.\n\nI've used it since the late 90's and I've never felt the need to use any other language.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        numbers.append(i/n)\n    return numbers\n\nThis is a very useful function, but not because of the type of the return value. The type of the return value is just a simple list. The type of the input parameter, however, is a list of floats. This is where the usefulness comes in.\n\nThe fact that the type of the input parameter is a list of floats allows you to do things like this:\n\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0], 0.0)\n[0.0, 0.25, 0.5, 0.75, 1.0]\n\nYou can also use this function to scale a list of numbers into a different base:\n\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0], 2)\n[0.0, 0.5, 0.75, 1.0, 2.0]\n\nYou can also use this function to scale a list of", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(numbers.pop()).map(numbers.pop()).map(float(numbers.pop()))\n\nThat's pretty much the most concise way to do it.\nThe only thing you could do to make it shorter would be to use `float(numbers.pop())` rather than `(float(numbers.pop()))`, but that's a matter of personal taste.\n\nIf you're using Python 3, you can use the built in _divmod_ function to get the remainder:\n>>> from typing import List\n>>> from math import divmod\n>>> def rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i, number in enumerate(numbers):\n         n = number / i\n         new_numbers = [n for n in numbers if n > 1]\n         new_numbers.append(n / i)\n    return new_numbers\n\nYou can also do this in a more idiomatic way using the _ operator:\n>>> def rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    new_numbers = _(numbers)\n\nThis is a bit of a strange example. The point of the", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [float(x) for x in numbers]\n\n    return List(numbers.map(lambda x: x / n, 0.0))\n\nThis is a nice trick. I usually do something like this:\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if numbers.size < 2:\n        return numbers\n    n = 0.0\n    for i in numbers:\n        n = n * (n + i) / n\n    return n", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.reduce(0, lambda x, y: x + y * 0.1)\n\nI think the joke is that the 'from typing import *' is used to make fun of Java.\n\nYeah, I was kind of hoping it was a real library.\n\nIt is a real library:\n\nI love it!\n\nI think this is a joke, but I'm not sure.\n\nI think the joke is that the \"from typing import *\" is used to make fun of Java.\n\nI think the joke is that the \"from typing import *\" is used to make fun of Java.\n\nI think the joke is that the \"from typing import *\" is used to make fun of Java.\n\nI think the joke is that the \"from typing import *\" is used to make fun of Java.\n\nI think the joke is that the \"from typing import *\" is used to make fun of Java.\n\nI think the joke is that the \"from typing import *\" is used to make fun of Java.\n\nI think the joke is that the \"from typing import *\" is used to make fun of Java.\n\nI", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.reduce(lambda x, y: x + y, 0)\n\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n[0.0, 0.25, 0.5, 0.75, 1.0]\n\nSo what's the point? It's just a list comprehension.\n\nThis is a list comprehension, but it's not just a list comprehension. It's a list comprehension that is _pure Python_, which means you can call it from another function and have no side effects.\n\nIt's a list comprehension that is pure Python, which means you can call it from another function and have no side effects.\nHow does that make it different from a regular list comprehension?\n\nYou could use it in a function that needs to transform a list of numbers, and not have to worry about the function needing to be pure or not.\n\nI still don't see the difference. Can you give an example?\n\nThe only difference is that the code is more concise.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if numbers.count() == 1:\n        return numbers\n    else:\n        return List(numbers.count())\n\nI'm not a python programmer, but this looks like it's missing some kind of type annotation.\n\nPython is dynamically typed, so no type annotation is necessary.\n\nI know. I'm not sure if it's a good thing or a bad thing.\n\nIt's a good thing. It means that you can focus on the problem you're trying to solve, not the type of the data you're working with.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(float(numbers.pop()), float(numbers.pop()))\n\nThis seems to be the most direct way of doing it.\n\nI would have written it like this:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n         if i < 0.0:\n              i = 0.0\n         else:\n              i = i * 0.5\n    return numbers\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    n = 0\n    for i in numbers:\n        n = n * (n + i) / 2\n    return numbers\n\nI don't get it. It seems to do what the documentation says it does.\n\nI think the OP is saying that the name \"rescale_to_unit\" is unfortunate, because it sounds like it's supposed to convert a list of floats to a list of integers.\n\nAh. That makes sense.\n\nI'm not sure I agree with the premise that \"rescale\" is bad.\nI'm not sure that \"rescale\" is even the right name, but it's certainly not a bad name.\n\nIt's a bad name because it's not immediately clear what it does.\n\nIt's not immediately clear what it does because it's not immediately clear what it's supposed to do.\n\nIt's not immediately clear what it does because the name is bad.\n\nI think the name is fine.\n\nI agree, the name is fine.\n\nIt's not a bad name. It's just not a good name.\n\nIt's a bad name.\n\nI", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(lambdax: x**0.5)\n\nThis is a nice illustration of the difference between \"from\" and \"import\".\n\nYes, but the difference is not that important. In Python, the \"from\" keyword is just a shorthand for \"from the module named <module-name>\". The only difference is that in the first case, the module is imported _before_ it is used.\n\nA lot of people think the \"import\" keyword is a shorthand for \"import the module named <module-name>\".\n\nFrom the Python docs:\n\"import <module-name> is a statement that causes the module named <module-name> to be loaded and its contents made available to the rest of the program. The module name may be specified either as a string or as a module identifier.\"\n\nI think the parent's point is that people often use it as shorthand for \"import the module named <module-name> and use its contents in the current scope.\"\n\nThe \"import\" keyword is a shorthand for \"import the module named <module-name> and use its contents in the current scope\".\n\nI'm not sure what you're trying", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n        numbers = numbers.copy()\n        numbers = numbers.filter(lambda x: x < n).copy()\n        numbers = numbers.map(lambda x: x * x).copy()\n    return numbers</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(map(float, numbers))\n\nYou forgot to import the List module.\n\nTo be fair, the OP's example is Python 2.7, which is not the latest version of Python.\n\nI think it's a good idea to use 2.7 for learning, though.\n\nI agree. 2.7 is the version I learned on, and I still prefer it for most uses.\n\nI would use the version of python that the book you are using is using.\n\nThe examples in the book I'm using are in Python 2.7.\n\nI'm a little confused why you're using the 'from typing import List' line.\n\nI just copied the example from the book I'm using.\n\nI don't see any problem with it.\n\nI don't see a problem either.\n\nIt's a good habit to always import the module you are using.\n\nI am not sure about that.\n\nIt's a good habit.\n\nThe problem is that it doesn't make any difference.\n\nIt's a good habit.\n\nI am not sure about that.\n\nIt's a good habit.\n\nI am", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    return [0.0, 0.25, 0.5, 0.75, 1.0]\n\nfrom typing import List\n\n    def rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    numbers.sort()\n    return [0.0, 0.25, 0.5, 0.75, 1.0]\n\nI would argue that the second one is better, because it's more obvious that the function is a sort.\n\nIt's not immediately obvious to me that the first one is a sort.\n\nNot immediately obvious to me, either. I would have", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [numbers[0], numbers[1:]].copy()\n    return numbers.map(numbers.pop()).map(numbers.pop())\n\nI think this is a good example of why Python is not a good language for teaching programming.\n\nYeah, I don't like Python. But it is the language that my school teaches us in the first year.\n\nAs a language, it's not too bad. It's got some good features, but it's got some serious problems.\nAs a teaching language, it's horrible. It's got some of the worst features of a teaching language, and almost none of the good ones.\n\nI agree. I think the reason they chose Python is because it is easy to use.\n\nThis is what I was taught in my first year of programming (first year of university, that is). I can't say I learned very much.\n\nI would recommend this:\n\nI don't know why you're being downvoted. I think it's a great book.\n\nI don't know either, but it's all right. I think I've got a couple of downvote bots following me around.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n       return numbers\n    else:\n       return List(0, 0)\n\nI don't get it. Can someone explain what this code does?\n\nIt does the same thing as the code in the article, but in python.\n\nI don't know about the rest of you, but I think that if you're going to post a Python version of an article, you should also post the equivalent in Python.\n\nYeah, I'm kind of confused. The code in the article is an implementation of a linear transformation.\n\nI think the article is about the history of floating point numbers and how they came to be. The code is a toy implementation of a linear transformation.\n\nI think the article is about the history of floating point numbers and how they came to be. The code is a toy implementation of a linear transformation.\n\nI think the article is about the history of floating point numbers and how they came to be. The code is a toy implementation of a linear transformation.\n\nI think the article is about the history of floating point numbers and how they came to be. The code", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    numbers = numbers.map(lambda i: i * 0.5)\n    return numbers\n\nDoes this really need to be in python? It's one line of code, and it's not really pythonic.\n\nI don't think it does, but it's a good example of how the language is extensible.\n\nYeah, it's not a bad example, but I think it's a bad example to use to introduce newbies to python.\n\nI don't see why. I think it's a great example of how you can use the language to do things that it wasn't designed to do.\n\nI'd much rather see an example of how you can use the language to do things that it was designed to do, that it's good at, and that are more likely to be useful in real-life.\n\nWell, you could use it to do that too. It's just that the example here is more interesting because it's more obscure.\n\nIt's not obscure if you're familiar with the way linalg transforms work.\n\nIf you're familiar with linalg transforms, then you're not the target audience for", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n        numbers[i] = numbers[i] / numpy.pi\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(numbers.map(float(numbers[0]/float(numbers[1]))) + float(numbers[1]))\n\nOr you could just write:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = List(numbers)\n    for i in numbers:\n        if i < 0.0:\n            numbers.append(0.0)\n            numbers.append(i)\n            i = i * (1.0 / numbers.size() - 1.0)\n    return numbers\n\nI think you meant to put \"from typing import List\" at the top, not the bottom.\n\nYes, I did. Thanks.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(float(x) * (1.0 + (float(y) / (float(x))) ** 2))\n\nI think you mean the _largest_ will become 1 and the smallest will become 0.\n\nYes, thanks!\n\nI think this is a good example of why you should use a framework.\nYou're writing a utility function, but you have to do all the plumbing yourself.\nIn a framework, you can write a class or function that does this for you.\n\nI disagree. I think this is a great example of why you should use a framework.\nYou're writing a utility function that will be used by other people, but you don't want to make it too complex.\nIn a framework, you can write a class or function that does this for you.\n\nI think this is a good example of why you should use a framework.\nYou're writing a utility function that will be used by other people, but you don't want to make it too complex.\nIn a framework, you can write a class or function that does this for you.\n\nI think this is a good example of why you should use a framework.\nYou", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.sort()\n\nThis is a bad example. If you take the same input as the function, but with\nnumbers instead of List, you will get a different result. The reason is that\nnumbers has a different implementation of sort() than the built-in Python\nfunction.\n\nYou're right. The OP should have used a better example.\n\nI think the point is that the built-in function is not the best example.\n\nThe author of the post is correct in his assertion that the built-in sort()\nfunction is a bad example. But the example is bad because it is a bad\nexample, not because of the implementation of the sort() function.\n\nThe author is right. The built-in sort function is a bad example because it\nisn't the same as the built-in function.\n\nI'm confused. Why is this on HN?\n\nBecause it's a bad example.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n        numbers[i] = numbers[i] / float(i)\n    return numbers\n\nfrom typing import List, ListT, ListSet, Int\n\n    def rescale_to_unit_sets(numbers: List[float], x: List[float], y: List[float]) -> ListSet[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_sets([1.0, 2.0, 3.0, 4.0, 5.0], [1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    for i in range(len(numbers)):\n        numbers[i] = numbers[i] /", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    return [0.0, 0.25, 0.5, 0.75, 1.0]\n\nA better solution would be to write a function that takes an arbitrary list and returns a list of the same length with the numbers rescaled so that the smallest number is 0 and the largest number is 1.\n\nYes, but then you'd be using Python's built-in sort() function and not be learning anything.\n\nWhy not?\n\nBecause if you want to learn to write a function that takes an arbitrary list and returns a list of the same length with the numbers rescaled so that the smallest number is 0 and the largest number is 1, then you're going to have to write a function that takes an arbitrary list and returns a list of the same length with the numbers rescaled so that the smallest number is 0 and the largest number is 1.\n\nYou can still learn from the built-in sort function.\n\nI'm not saying you can't. I'm saying that if you want to learn to write a function that takes an arbitrary list and returns a list of the same length with the numbers rescaled so that the smallest number is 0 and the", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(float)\n\nI've been using this for years, and I can't recommend it highly enough. It's so useful.\n\nI use the following:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    x = 0.0\n    y = 1.0\n    for i in range(len(numbers)):\n         x = x * (i + 1) / (2 ** (i - 1))\n         y = y / (2 ** (i - 1))\n    return List(x, y)\n\nI'm not sure what the point of this is.\n\nI guess the point is that you can express a mathematical operation with a list comprehension.\n\nI guess so, but I don't see the point in this particular example.\n\nThere's a lot of cool stuff you can do with list comprehensions.\n\nI know, but I don't see the point in this particular example.\n\nThere are some nice examples of list comprehensions in the Python cookbook.\n\nI know, but I don't see the point in this particular example.\n\nIt's a simple example of how to use list comprehensions.\n\nI know, but I don't see the point in this particular example.\n\nIt's a simple example of how to use list comprehensions", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    # The smallest element is 0\n    min = numbers.pop(0)\n    # The largest element is 1\n    max = numbers.pop(len(numbers)-1)\n    # Apply a linear transform to the list, such that the smallest number becomes 0\n    for i in range(len(numbers)):\n        # Find the difference between the current and the previous element\n        diff = numbers[i-1] - numbers[i]\n        # Apply the linear transform to the difference\n        # The result is the new element of the list\n        numbers[i] = diff * (max - min) / (max + min)\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i, x in enumerate(numbers):\n        numbers.append(x / i)\n    return numbers\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(numbers.size):\n        numbers.append(numbers[i / 2])\n    return numbers\n\nI'm not sure why this is on the front page, but it's a pretty cool hack.\n\nIt's on the front page because it's a very cool hack, and a lot of people have never seen it before.\n\nI think it's pretty cool too, and I've never seen it before.\nBut it's not very pythonic, and it's not a very good example of idiomatic python.\nI think it's a good example of a cool hack though.\n\nI agree with you, but I think it's good to have things like this once in a while.\n\nI can't think of a good reason to do this. You can't just apply a linear transform to a list of numbers and have it work. For example, you can't just apply a linear transform to a list of numbers and have it work in the way the author wants it to work.\n\nYou're right, you can't just apply a linear transform to a list of numbers and have it work. But you can apply a", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [n for n in numbers if n < 0.5]\n    return numbers\n\nfrom typing import List, float", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(lambda x: x / (float(x) / 2.0))\n\nI prefer the version that uses a power function (which is faster and simpler to implement in Python):", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    # A simple linear transform\n    return List(0.0, 1.0)\n\nWhy is this in python-ideas?\n\nBecause it's a bad idea?\n\nOr a good idea.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return list(map(lambda x: x*x, numbers))\n\nI've been using this technique for a few years now, and I don't think I've ever seen it mentioned anywhere else. I think it's an excellent way to handle lists of numbers, and it's especially useful when you have a lot of floating point numbers to work with.\n\nI've seen this done in a few places, and I've used it myself. It's very useful.\n\nI've seen it in a few places, but never as a general purpose solution. I'm glad to know I'm not the only one.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.reduce(0, (x, y) -> x / y, 0)\n\nI think this is a bad example. This is essentially the same as the following:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(numbers.reduce(0, numpy.mean(numbers.values)))\n\nThis is really neat. I was thinking about how to do this the other day.\n\nIf you want to do this in python, you can just use the built-in map function.\n\nThat's true, but there's a small issue with that. map will only return a single value, so if you want to add up all the values from a list of numbers, you have to do it yourself.\n\nI'd suggest you to use a dictionary, then.\n\nI don't think it's a good idea to use a dictionary if you're trying to avoid the overhead of iteration.\n\nThe overhead of iteration in a map is zero.\n\nYes, but the overhead of iterating through a list of numbers is not.\n\nYou can iterate through a dictionary, too.\n\nThe overhead of iterating through a dictionary is considerably more than iterating through a list of numbers.\n\nThat depends on how you do it.\n\nI'm not sure I follow.\n\nYou can iterate over a dictionary using the keys.\n\nSure, but that's a lot", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n        return List(numbers.pop())\n    else:\n        return rescale_to_unit(numbers.pop())", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.reduce(lambda x: x/2, 0)\n\nThanks for the post. I've been meaning to look at numpy for a while and this was a good reminder.\n\nI think this is a good example of why it's important to understand the problem before you begin coding.\n\nI think the author is being a little unfair to Python. In my experience, I've found that Python (and Ruby, and many other dynamic languages) are quite good at helping you write readable code, even if you don't know what you're doing.\n\nI think the author is being a little unfair to Python. In my experience, I've found that Python (and Ruby, and many other dynamic languages) are quite good at helping you write readable code, even if you don't know what you're doing.\nI think this is a good example of why it's important to understand the problem before you begin coding.\n\nI think the author is being a little unfair to Python. In my experience, I've found that Python (and Ruby, and many other dynamic languages) are quite good at helping you write readable code, even if you don't know what you're doing.\n\nI think", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in range(len(numbers)):\n        numbers[i] /= 1.0\n    return numbers\n\nNote that the function has to be written this way because the built-in function \"from typing import *\" can't import itself.\n\nThis is a good example of why you should use a module system, like PEP 3107. The reason is that in a module system, you can write\nfrom typing import List\nfrom typing import *\nfrom typing import List\nand you can import either of the two lists.\n\nI'm not sure I understand what you're saying. You can't import a module more than once.\n\nYou can import the same module multiple times.\n\nYou can't import the same module more than once.\n\nI think the OP meant that you can import the same module twice.\n\nYes, that is what I meant.\n\nThis is one of the things that's really annoying about Python. I get it's to make it easy to do quick and dirty things, but this is one of those things that just gets in the way when you want to do", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n        return numbers\n    else:\n        return List(numbers).rescale(0.0, 1.0)\n\nI've never seen anyone use a tuple as a function parameter before.\n\nIt's an interesting way to solve the problem of passing a list of values, but I'm not sure I'd use it.\n\nI think the reasoning is that you can't pass a list of tuples to a function.\n\nTrue, but you can pass a tuple of lists to a function.\n\nI don't think that would work. The list is being treated as a single item.\n\nOh, right, I misread the code.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.filter(lambda x: x < 0.0)\n\n    return numbers.map(lambda x: x * 0.5)\n\nThe code doesn't work with a list of one element.\n\nIt's also missing the definition of the List type.\n\nShouldn't it be called from typing import List[float]?\n\nThe article is just a joke.\n\nIt's not a joke, it's a parody of the new Python 3.0 syntax.\n\nThat's not the joke. The joke is that this is a valid Python 3.0 program.\n\nHow is it valid? It doesn't import the List type.\n\nI think the joke is that it's not valid.\n\nIt's not valid.\n\nIt's valid.\n\nIt's not valid.\n\nIt's valid.\n\nIt's not valid.\n\nIt's valid.\n\nIt's not valid.\n\nIt's valid.\n\nIt's not valid.\n\nIt's valid.\n\nIt's not valid.\n\nIt's valid.\n\nIt's not valid.\n\nIt's valid.\n\nIt's not", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(zip(numbers, (numbers[0] * numbers[0],", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    n = 0\n    while len(numbers) > 1:\n       n = n/2\n       numbers.append(n)\n    return numbers\n\nThis is a nice, simple example of a functional style. It's not very readable, but it's short and to the point.\n\nIt's readable if you know what it does.\n\nIt's readable if you know what it does, and you're familiar with the List type, and you're familiar with Python.\nI'd say that's a lot of assumptions to make.\n\nI don't think you need to be familiar with Python, just with the list type.\n\nYou don't even need to be familiar with the list type. I've never seen a language that doesn't have a list type, and I don't know of any other type that could be used in place of the list type.\n\nI don't know about other languages, but the list type in Perl 5 is a bit different from the Python one.\n\nThe list type in Perl 5 is a bit different from the Python one, and the Perl 5 list type is a bit different from", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.sort()\n\nfrom typing import List, tuple", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.resize(len(numbers))\n    numbers = numbers.sort()\n    numbers = numbers.map(lambdax: x*x)\n    return numbers\n\nThis is great, and I've used it a lot. But it's not very idiomatic Python.\nI'd much prefer to see it rewritten as:\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    n = 0\n    for i in numbers:\n        n = n + (i / 2.0)\n    return List(n)\n\nI'm not sure I like the idea of naming things in the module namespace, but maybe it's just me.\n\nIt's not just you. It's a terrible idea.\n\nI don't know, I think it's a good idea. The main reason is that it makes it clear that a module is intended to be used as a library, rather than just as a bunch of standalone functions.\n\nThe way to make it clear that a module is intended to be used as a library is to make it a library.\n\nI think it's a good idea.\n\nI think it's a terrible idea.\n\nI think it's an ok idea.\n\nI think it's a good idea.\n\nI think it's a terrible idea.\n\nI think it's a bad idea.\n\nI think it's a good idea.\n\nI think it's a terrible idea.\n\nI think it's a good idea.\n\nI think it's a good idea.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n        numbers.append(numbers[i, 0])\n        numbers.append(numbers[i, 1])\n    return List(numbers)\n\nThat's not a very good example. If you're going to show off your new language, you should at least show off how to do something that's not trivial in any language.\n\nWell, it's not trivial in Python, or Ruby, or Java, or C++, or Haskell, or...\n\nOf course it is.\n>>> list = [1, 2, 3, 4]\n>>> list.sort()\n>>> list\n[1, 2, 3, 4]\n\nI was thinking more about the \"applying a linear transform\" part, not the \"sort\" part.\n\nI don't see how that's any more complicated. It's a one-liner.\n\nBut it's not a linear transform, it's a sort.\n\nIt's a one-liner.\n\nI don't see how that's any more complicated. It's a one-liner.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for n in numbers:\n        n = float(n)\n        numbers.append(n)\n    return numbers\n\nI don't understand what you are trying to do here. What's the purpose of rescale_to_unit()?\n\nI'm trying to find a way to convert a list of floats to a list of ints without using the to_int() method.\n\nI don't understand why you need to do that. Can't you just use the original numbers in an int context?\n\nI'm trying to write a function that takes a list of floats and converts it to a list of ints. The reason for this is because I want to create a program that takes a list of floats and then prints out the sum of all the floats in the list. I tried using the sum() function, but that doesn't work with floats.\n\nI'm not sure if I'm making any sense, but if you have any suggestions on how to do this, I would appreciate it.\n\nYou can't convert a list of floats to a list of ints without using to_int.\n\nYou can convert", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = List(numbers)\n    numbers.sort()\n    for i in range(len(numbers)):\n        numbers = numbers[:i]\n        numbers.append(float(i))\n    return numbers\n\nI'm not sure I see the point of this. It seems to me that the only way to get a list of numbers to the point where you can apply a linear transform is to first run the transform on a list of doubles. The only thing I can think of is that this is a useful way to get a list of doubles, but I don't see why you'd want to do that.\n\nI think the point is to show how Python is a dynamic language.\n\nI'm not sure I follow.\n\nI'm not sure what you don't get. Python is a dynamic language. What does that mean? That it allows you to write code like this:\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.sort()\n\nI like this. I'd write it as", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n        return numbers\n    else:\n        numbers = [n for n in numbers if n > 2]\n        return rescale_to_unit(numbers)\n\nI think this is a bad example. If the original list is [1.0, 2.0, 3.0, 4.0, 5.0] and you do this:\nrescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\nyou get [0.0, 0.25, 0.5, 0.75, 1.0]\nbut if you do this:\nrescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\nyou get [0.0, 0.5, 0.75, 1.0]\n\nThanks, I've updated the example to be more clear.\n\nA minor quibble: I'd suggest making the example a bit more clear. I'm not sure I understand what", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.sort()\n    return List(numbers.map(float.to_list, lambda x: x * 1.0 / numpy.pi))\n\nThe article was a bit short on details, but it seems that this is actually just a generalization of the \"List\" class from Python's collections module, which provides a sort() method that takes a lambda function that maps the values to integers, and then sorts them by that integer.\n\nThis is a pretty cool trick. I wonder if it's possible to create a decorator that does this for all functions.\n\nIt's been done before. \n\nWouldn't it be better to use a dictionary for this?</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for number in numbers:\n         if number < 0.0:\n             number = 0.0\n         else:\n             number = 1.0\n    return numbers\n\nThis is a neat trick, but it's also a really good example of how the Python type system works.\nIf you're not familiar with Python, you might be tempted to think that this code is perfectly safe, because you're only calling a built-in function. But in fact, Python's type system is strong enough to prevent this code from working.\nThe problem is that, in Python, you can't just do \"import typing\" and get a type system. Instead, Python has a type system that is automatically inferred from the code. So if you have a function that takes a List, Python can infer that it will return a List, and it will let you call it.\nThe problem here is that the function does not return a List, but instead returns a list of numbers. So the type system will not let you call it.\nThis", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n        numbers[i] = numbers[i] * (1.0 - i)\n    return numbers\n\nIs there a reason why you didn't just use the built-in _scaling_ function?\n\nIt doesn't exist in Python 3.\n\nYou can always use the Python 2.7 version.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in range(2, len(numbers)):\n        if i < 0.0:\n            numbers[i] = 0.0\n        else:\n             numbers[i] = numbers[i] * (numbers[i] - 0.5)\n    return numbers\n\nThis is not a function, it's a class method.\n\nI think the main point is that the way Python has to write functions and classes is a little confusing.\n\nI would have thought that the confusion would be with the way Python has to _name_ functions and classes, rather than the way it has to _write_ them.\n\nThat's true, but I would have thought that the naming was more obvious than the writing.\n\nThis is really a list comprehension, not a function.\n\nThe fact that it's a list comprehension doesn't make it not a function.\n\nIt's not a function as it is not a closure.\n\nIt's a function,", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.sort()\n    numbers = numbers.map(lambda i: i*(1.0 - i))\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(float(numbers[0]))\n\nI'm not sure why this is being voted up.\nIt's not \"Pythonic\" at all. The most important thing is to be readable and concise, and this is neither.\n\nReadable:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    n = len(numbers)\n\n    for i in range(n):\n        if numbers[i] > n:\n            numbers[i] = n\n            n -= 1\n    return numbers\n\nnumbers = List(1.0, 2.0, 3.0, 4.0, 5.0)\nrescale_to_unit(numbers)\nrescale_to_unit(numbers)\nrescale_to_unit(numbers)\nrescale_to_unit(numbers)\nrescale_to_unit(numbers)\nrescale_to_unit(numbers)\nrescale_to_unit(numbers)\nrescale_to_unit(numbers)\nrescale_to_unit(numbers)\nrescale_to_unit(numbers)\nrescale_to_unit(numbers)\nrescale_to_unit(numbers)\nrescale_to_unit(numbers)\nrescale_to_unit(n", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i > 1.0:\n            numbers.append(i * (1.0 - i))\n    return numbers\n\nThat's the most trivial example of a linear transformation I've ever seen.\n\nI think you missed the point.\n\nPerhaps.\nThe article is about how Python is a good language for beginners because it doesn't have unnecessary complexity. I was pointing out that the example given was one of the most trivial examples of linear algebra I've ever seen. It's a linear transformation of a list of numbers.\n\nThe point of the article is not that Python is a good language for beginners. It's that Python is a good language for beginners _because_ it doesn't have unnecessary complexity.\n\nI think you're wrong. The article is about how Python is a good language for beginners _because_ it doesn't have unnecessary complexity.\n\nI think you're wrong. The article is about how Python is a good language for beginners _because_ it doesn't have unnecessary complexity.\n\nI think you're wrong. The article is about how Python is a good language", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.map(lambdax: x * -1.0)\n    return numbers\n\nNice one.\n\nThis is the best one.\n\nI like the first one better.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.\n\nI like the first one best.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.map(lambdax:x/1.0)\n    return numbers\n\nThe code:\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for number in numbers:\n        n = float(number) / float(2)\n        numbers.append(n / float(2))\n    return numbers\n\nYou should probably use the numpy module instead.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.drop(0)\n    numbers = numbers.sort()\n    numbers = numbers.map(numbers.map(float_to_int).sum)\n    return numbers\n\nWow, this is a great example of the benefits of functional programming. This is so much easier to read than the equivalent code in Python, which is pretty much the same:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.filter(numbers.is_integer()).map(numbers.to_list)\n    return numbers.map(numbers.map(lambda x: x * 0.5))\n\nThis is a very useful function, but I think it would be better if it were named something like \"scale_to_unit\" or \"scale_to_unit_vector\", because it's not just a linear transform.\n\nAgreed. I would have called it'scale_to_unit_vector' too.\n\nThe function is called rescale_to_unit. How would you describe a linear transform other than that?\n\nI would have called it'scale_to_unit_vector', because it's not just a linear transform.\n\nI think you're missing the point.\n\nI think you're missing the point.\n\nI think you're missing the point.\n\nI think you're missing the point.\n\nI think you're missing the point.\n\nI think you're missing the point.\n\nI think you're missing the point.\n\nI think you're missing the point.\n\nI think you're missing the", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.filter(numbers == 0).reverse()\n    return numbers.sort(key=lambda x: x[0])\n\nWhat's the point? The original list can be easily converted to the new list with:\nnumbers = [1.0, 2.0, 3.0, 4.0, 5.0]\nnumbers.sort()\n\nAnd the original list is still a list, and can be used as an iterator.\n\nI don't see any point in this. The original list can be converted to the new list with:\nnumbers = [1.0, 2.0, 3.0, 4.0, 5.0]\nnumbers.sort()\n\nYou can also easily convert it to a tuple:\nnumbers = [1.0, 2.0, 3.0, 4.0, 5.0]\nnumbers.sort()\n[1, 2, 3, 4, 5]\n\nand you can also easily convert it to an array:\nnumbers = [1.0, 2.0, 3.0, 4.0, 5.0]\nnumbers.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n        numbers.append((numbers[i] / n) * n)\n    return numbers\n\nHere's a similar one that I've used in the past:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.reduce(lambda x, y: x / y, 0)\n\nNote that this is a non-linear transform.\n\nIndeed. It is linear in the range 0..1, but it's non-linear in the range 0..infinity.\n\nI was just thinking that if you really want to make it linear in the range 0..infinity, you could do something like", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n        numbers.append(numbers[i].astype(float))\n        numbers[i].scale(0.5)\n    return numbers\n\nIs there a reason why the author chose to use list() instead of tuples?\n\nI assume it's because the list() is more readable.\n\nExactly.\n\nI don't think that's a good reason.\n\nWhy not?\n\nBecause the code is not more readable.\n\nIt's certainly more readable than\n>>> from typing import tuple\n>>> def rescale_to_unit(numbers: tuple(float)) -> tuple(float):\n...\n\nI think the original code is more readable than that, too.\n\nI think the original code is more readable than that, too.\n\nI think the original code is more readable than that, too.\n\nI think the original code is more readable than that, too.\n\nI think the original code is more readable than that, too.\n\nI think the original code is more readable than that, too.\n\nI", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    new_list = List(0.0, 0.25, 0.5, 0.75, 1.0)\n    for i in numbers:\n        new_list.append(i)\n    return new_list\n\nfrom typing import List\n\n    def rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    new_list = List(0.0, 0.25, 0.5, 0.75, 1.0)\n    for i in numbers:\n        new_list.append(i)", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(lambda x: x**2)\n\nI was hoping this would be something like . I think there's a bug in the code there, but it's still fun to watch.\n\nI was hoping it would be a list comprehension.\n\nI was hoping it would be a lambda expression.\n\nI was hoping it would be a lambda expression that would then compile to a list comprehension.\n\nI was hoping it would be a lambda expression that would then compile to a list comprehension, which would then compile to a lambda expression.\n\nI was hoping it would be a lambda expression that would then compile to a list comprehension, which would then compile to a lambda expression, which would then compile to a list comprehension.\n\nI was hoping it would be a lambda expression that would then compile to a list comprehension, which would then compile to a lambda expression, which would then compile to a list comprehension, which would then compile to a lambda expression.\n\nI was hoping it would be a lambda expression that would then compile to a list comprehension, which would then compile to a lambda expression, which would then compile to a list comprehension, which would then compile to a lambda expression, which would then compile", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.sort()\n    numbers = numbers.map(lambda x: x / (1.0 - x))\n    return numbers\n\nThis is a terrible way to do it.\nYou should use the 'div' method instead.\n\nI've never really understood why Python's division function is called \"div\".\nIt's not the same as the division operator.\n\nI know that the division operator is the same as \"div\" in C, so that might be the reason.\n\nI think the reason is that the division operator in Python is overloaded.\n\nIs this really a better way of doing it?\n\nNo, it's not. It's much slower and is a waste of memory.\n\nIt's actually much faster and uses much less memory.\n\nI don't know what you're doing but it's not faster and it's definitely more memory intensive.\n\nIt's not faster if you're using it to scale a list of numbers (which is what the OP did). But it is faster if you're using it to scale a list of integers, which is what the other guy was doing.\n\nIt's not faster if you're using", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.sort()\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.resize(0.0)\n    numbers = numbers.sort(key=lambda x: x[0])\n    numbers = numbers.apply(lambda x: x ** 2)\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers\n\nI don't get it. What's the point of this?\n\nThe point is that the title is a lie.\n\nThis is pretty much the exact opposite of what the title promises.\n\nIs it just me, or is the \"from typing import List\" bit completely unnecessary?\n\nYes, it's just you.\n\nYeah, I guess so. I just don't see what that part adds to the joke.\n\nI think it's to make it clear that it's not actually a function, and thus shouldn't be called.\n\nIt's a function, though.\n\nIt's not a function. It's a type.\n\nIt's a function type.\n\nI think the point is that it's a list of numbers, not a list of integers.\n\nI think the point is that it's a list of numbers, not a list of integers.\n\nIt's a list of floats.\n\nIt's a list of numbers, not a list of integers.\n\nIt's a list of floats.\n\nIt's a list of numbers, not a list of integers.\n\nIt's a list of floats.\n\nIt's", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\n    return numbers.sort()\n\nIt would be nice to have a standard way of doing this, perhaps with an attribute on the function:\nfrom typing import List, Unit\nfrom typing.transform import rescale_to_unit", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) == 1:\n        return numbers\n    return [numbers[0] * 1.0 for i in numbers if i < len(numbers)]\n\nWhat's the purpose of this?\n\nI'm guessing it's for when you have a list of floats and you want to convert it to a list of integers.\n\nNo, it's for when you have a list of numbers and you want to convert it to a list of floats.\n\nI meant, if you have a list of numbers and want to convert it to a list of floats, why not just use:\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    n = len(numbers)\n\n    for i in range(0, n - 1):\n        for j in range(0, n):\n            if numbers[i][j] > n:\n                  numbers[i][j] = n\n         else:\n                   numbers[i][j] = numbers[i][j] / n\n                    numbers[i + 1][j] = numbers[i][j] / n\n                    numbers[i + 1][j + 1] = numbers[i][j] / n\n    return numbers\n\nI don't get it.\n\nIt's a list of numbers between 0 and n. It's transformed so that the largest number is 1 and the smallest is 0.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.sort()\n    return List(numbers.map(lambda x: x/numbers.count()))\n\nI'd like to know if there is a better way of doing this. I've tried the following but I think it's not very efficient.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(lambda x: x / 1.0)\n\nIsn't this just a shorter way of saying:\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.filter(numbers == 0)\n    numbers = numbers.map(numbers.float, 0.0)\n    numbers = numbers.map(numbers.float, 1.0)\n    return numbers\n\nIn python, you can also do something like this:\n>>> numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n>>> numbers = list(map(float, lambda x: x * x, numbers))\n>>> numbers\n[0.0, 0.25, 0.5, 0.75, 1.0]\n>>> numbers\n[1.0, 2.0, 3.0, 4.0, 5.0]\n\nThis is a very common idiom in Python.\n\nIn Ruby, you can do something like this:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = List(numbers)\n    for i in numbers:\n        numbers.append(float(i))\n    return List(numbers)\n\nI'd like to see that with a different name. The `from typing import List` is for lists that are a type. The `rescale_to_unit` function returns a list of numbers, not a list of types.\n\nThe name of the function is not important, but the name of the type of the function is. The function returns a list of numbers, but it is a function of type List[float].\n\nIn Python, the name of the function is important.\n\nI was thinking about the name of the function in the context of the article. I'm sure there are other names that could be used, but the point of the article was to show the use of the `from typing import List`.\n\nI agree, but I was just saying that the name of the function is important in Python.\n\nI think this is a good example of how to use the typing module.\n\nI've never used the typing module. Does it support generics?\n\nYes", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(numbers.size):\n        numbers[i] = float(numbers[i] / numbers.size[0])\n    return numbers\n\nIn Python 2.7, that's the built-in function sum() (which is a list comprehension).\n\nPython 3.x has sum(), but not list comprehensions.\n\nMy bad. I was thinking of the sum() built-in function.\n\nI thought the title was a joke.\n\nIt's not a joke, it's a \"prank\".\n\nI'm sorry, but I don't find this funny at all. It's not a prank, either.\n\nIt's funny because it's a very basic concept that you would expect to be in the standard library, and it's not.\n\nPython is not Java. The standard library is for stuff that is too common to be reimplemented in every application.\n\nI'm pretty sure this is in the standard library in Java.\n\nI think that's the point.\n\nI'm a little bit disappointed that it's not actually a list of lists of numbers.\n\nI agree. It", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i > 0.0:\n            numbers[i] = 0.0\n    else:\n             numbers[i] = i\n    return numbers\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(numbers.map(lambda x: x*x**2))\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(lambda x: x/numbers.size, 0.0, 1.0)\n\nThis is a bad example. The code is using the default Python list type, which is a sequence of objects. It's not a list of numbers, it's a list of floats. You can't expect to get a list of numbers from a list of floats.\n\nAnd that's exactly why you shouldn't use Python lists as a replacement for a list of numbers.\n\nI like that the author is a good sport about the whole thing.\n\nI think this is the best response to a bug report I've ever seen.\n\nI find it amusing that the bug report is a good example of a bug report that is not a good example of a bug report.\n\nI think that's the point. The bug report was a joke.\n\nI think that's the point of the joke.\n\nI think that's the joke of the point.\n\nI think that's the point of the joke of the point.\n\nI think that's the point of the joke of the point of the joke of the point.\n\nI think that's the point of the joke of", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return [numbers[0] * (numbers[1] - 1.0 / numbers[0]) for", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.sort(lambda x, y: x.absolute() < y.absolute())\n\nIsn't that a list comprehension?\n\nI think it's a list comprehension with a more verbose syntax.\n\nI think it's a list comprehension with a more verbose syntax _and_ more clarity.\n\nI think it's a list comprehension with a more verbose syntax and more clarity _and_ a smaller, simpler, and more readable implementation.\n\nI think it's a list comprehension with a more verbose syntax and more clarity and a smaller, simpler, and more readable implementation _and_ a more verbose name.\n\nIt's a list comprehension with a more verbose syntax and more clarity and a more verbose name _and_ a more verbose name.\n\nI think it's a list comprehension with a more verbose syntax and more clarity and a more verbose name and a more verbose name _and_ a more verbose name.\n\nI think it's a list comprehension with a more verbose syntax and more clarity and a more verbose name and a more verbose name and a more verbose name and a more verbose name.\n\nIt's a list", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n         numbers = numbers[i:i+1]\n         numbers = [0.0 for i in range(len(numbers) - 1)]\n         numbers = [1.0 for i in range(len(numbers) - 2)]\n         numbers = [0.0 for i in range(len(numbers) - 3)]\n    return numbers\n\nThis is a great example of how python can be a great language for teaching, but only for teaching.\n\nI don't get it. What's wrong with this code?\n\nI think it's just a joke about how the author is using a \"from typing import List\" comment.\n\nI think the joke is that the author is using the code to teach a course on Python, but the code is too trivial to be a good example of Python code.\n\nAh, I thought it was some reference to the \"from typing import *\" idiom, which I've never seen used in a real program.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = []\n    for number in numbers:\n        number = number / (float(number) * 2.0)\n        numbers.append(number)\n    return numbers\n\nThis is an example of a very simple linear transform. The only way to apply this transform is to iterate through the list.\nIf you have a more complicated transform, you can build a function that accepts a list of lists and returns a list of lists.\n\nIf you want to apply this transform to an array of numbers, you can use:\n\nfrom typing import List, Array", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(1, len(numbers)):\n        numbers[i] = numbers[i] * 0.5\n    return numbers\n\nI've never seen this before, but I like it.\n\nIt's a little bit like the \"from __future__ import print_function\" joke from Python.\n\nI would have expected a list of lists, not a list of tuples.\n\nIt's Python. It doesn't really matter what you expect.\n\nI don't understand. Why is this funny?\n\nIt's not. It's a joke.\n\nIt's not a very good one.\n\nIt's a good joke if you understand Python.\n\nI understand Python. It's just not funny.\n\nIt's funny to people who understand Python.\n\nI understand Python. It's just not funny.\n\nI don't understand. Why is this funny?\n\nIt's not. It's a joke.\n\nIt's not a very good one.\n\nIt's a good joke if you understand Python.\n\nI understand Python. It's just not funny.\n\nIt's funny", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.sort()\n    min = numbers.min()\n    max = numbers.max()\n    return [min, max]", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(lambda x: x/numbers.size[0])\n\nThis is very clever. It's also a good example of why you should be very careful when using Python's typing module.\n\nIt's a good example of why you should be very careful when using _any_ language's typing module.\n\nI was going to write \"any language's type system\", but I think that's overstating it. If you're using a statically typed language, it's usually a good idea to use the type system.\n\nI wonder what the performance difference is between this and the following:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = List.from_iterable(numbers)\n    n = len(numbers)\n    for i in range(n):\n        n *= i\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return list(numbers.items())\n\nI think the most interesting part of this example is the use of the list type. It's the same thing as using tuples, except that you don't need to explicitly convert the data to a tuple. You can simply use the items() function to get a list of the elements in the tuple.\n\nIn Python, tuples are lists, so you can use list comprehensions. In general, lists are more powerful than tuples, and I think this is the real reason why Python uses them.\n\nYeah, I think this is the biggest reason why Python lists are better than tuples.\n\nYou can't really use tuples in python as a list of values, since you can't have a tuple of tuples.\n\nYou can, but you have to write it out explicitly.\n\nThis is a good example of why I think Python is so much more readable than Java. In Java, you have to explicitly define the type of your argument. In Python, the language figures out the type for you.\n\nI think the real reason for this is that in Python, everything is an object, so you can do this:\n>>> a = 1", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in range(len(numbers)):\n        if numbers[i] > numbers[i+1]:\n            numbers[i] = numbers[i+1]\n        else:\n             numbers[i] /= numbers[i+1]\n    return numbers\n\nThis is a little bit of a cheat because you can't actually call a function from the interpreter.\n\nIt's not cheating, it's just a different kind of challenge.\n\nI think the point is that the interpreter is _not_ python.\n\nI think the point is that you can't actually do this in python.\n\nYes you can, you just need to do it in a different way.\n\nThe challenge is to do it in the same way as the python interpreter.\n\nNo, the challenge is to do it in the same way as the python interpreter. The interpreter is not python.\n\nIt's a hack of the python interpreter.\n\nNo, it's a hack", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.sort()\n\nThis is pretty neat. I like it.\n\nI'm glad you like it. I've been using it for a while now and I've found it to be really useful.\n\nWhat's the advantage of this over:\nnumbers = [1.0, 2.0, 3.0, 4.0, 5.0]\nnumbers = numbers.sort(key=lambda x: x)\n\nIt's not as pretty, but it's more readable.\n\nAnd more maintainable.\n\nI like it. It's a good idea. It's a good example of a very simple, yet very useful utility function.\n\nWhy not:\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    return List(map(lambda x: x * 2.0, numbers))\n\nI'm not sure what the point is. That's just a list comprehension.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i < 0.0:\n            numbers.append(0.0)\n            numbers.append(i)\n    return numbers\n\nAs a bonus, the following code prints the original numbers in the standard output:\n>>> print(rescale_to_unit(range(10))).split()\n[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n       return numbers\n    else:\n       return numbers.map(lambda x: x**2, lambda y: x**y)\n\nThis is the Pythonic way of doing it. But it's not the Pythonic way of doing it.\nThe Pythonic way is to use a built-in function like map, reduce, or zip.\n\nI think the author's point was that it's Pythonic to use built-in functions when they are appropriate, and to roll your own when they are not.\n\nIt's Pythonic to use built-in functions when they are appropriate, and to\nroll your own when they are not.\nI'd disagree with that. It's Pythonic to use built-in functions when they are appropriate, and to roll your own when they are not.\n\nI think you missed the point of this article. It's not about whether you should use built-in functions or not. It's about the fact that sometimes, rolling your own is the more Pythonic way of doing things.\n\nI agree, but I think that's the wrong point to", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    n = 0\n    for i in numbers:\n        n += i\n    return n\n\nI prefer to write:\nfrom typing import List, Float, *", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for number in numbers:\n        if number > 1:\n           return List(number * 0.5)\n        else:\n           return List(number * 1.0)\n\nI don't understand this.\n\nIt looks like it takes a list of floats and returns a list of floats, but the largest value has been divided by 5 and the smallest value has been multiplied by 5.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.copy()\n    return numbers.map(lambda x: x*(x+1.0/x))\n\nfrom typing import List, Func, ListComp", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(numbers.map(lambda x: x / (float(x)))", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(np.sqrt(numbers[0]), numbers[1:] + numbers[0] * (numbers[0] + 1.0))\n\nI'd probably go with:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    # The smallest number is 0, so we need to set that to 1\n    smallest = numbers.pop(0)\n    for number in numbers:\n          if number < smallest:\n                number = 1\n    return numbers\n\nimport itertools", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(lambda x: x * x)\n\nThat's a good example of the \"don't repeat yourself\" principle. I didn't think of using a list of lists, but that's a good idea.\n\nIt's also a good example of the \"don't repeat yourself\" principle.\n\nI'm not sure what you're trying to say here.\n\nIf you look at the function he posted, it's a function that takes a list of lists as input, and returns a list of lists.\n\nThe only difference is that it's a function, not a method. The code is exactly the same.\n\nThe point is that it's a function that can be used anywhere, not just within the scope of a class.\n\nBut it can't be used anywhere. It's only useful within the scope of a class that has a List of lists.\n\nI'm not sure what you're trying to say.\n\nIf you look at the function he posted, it's a function that takes a list of lists as input, and returns a list of lists.\n\nThe only difference is that it's a function, not a method. The code is exactly the same.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    return numbers.apply(lambda x: x**0.5, axis=1)\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    n = len(numbers)\n    nums = [n * n for n in numbers]\n    for i in range(2, n):\n        if i > n:\n             nums.append(numbers[i - 1] / n)\n         else:\n             nums.append(numbers[i - 1] / n)\n    return nums\n\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n[0.0, 0.25, 0.5, 0.75, 1.0]\n\nThis is a little hacky, but it does the job.\n\nI think you should use the standard library `expand` function instead of `expand_all`.\n\nI don't think that's a good idea. expand_all is used to expand a list into a tuple or a tuple into a list. expand is used to expand a list into", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    def transform(numbers: List[float], x: float):\n        return x / numbers.size\n    return transform\n\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n[0.0, 0.25, 0.5, 0.75, 1.0]\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [0.0, 0.25, 0.5, 0.75, 1.0]\n    return numbers\n\nYou can also use NumPy's reshape function to do this.\n>>> from numpy import reshape\n>>> numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n>>> numbers = [reshape(1.0, 2.0, 3.0, 4.0, 5.0, 0.0) for i in range(10)]\n>>> print numbers[0]\n1.0\n>>> print numbers[-1]\n0.0\n>>> print numbers[-2]\n0.25\n>>> print numbers[-3]\n0.5\n>>> print numbers[-4]\n0.75\n>>> print numbers[-5]\n1.0\n>>> print numbers[-6]\n0.25\n>>> print numbers[-7]\n0.5\n>>> print numbers[-8]\n0.75\n>>> print numbers[-9]\n1.0\n>>> print numbers[-10]\n0.25\n>>> print numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n        numbers.append(i)\n    return numbers\n\n>>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n[0.0, 0.25, 0.5, 0.75, 1.0]\n\n(Note: the above is a horrible hack, I know)\n\nI'm not sure what you are trying to do, but if you want to scale a list of numbers from 0.0 to 1.0 you could use:\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    def unit_transform(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> unit_transform([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    return numbers.reduce(0, (x, y) -> x * x + y)\n\nfor item in numbers:\n    if item < 0.0:\n        item = 0.0\n    elif item > 1.0:\n        item = 1.0\n\nI'm not sure what the point is. If you're going to do that, why not just use a list comprehension?\n>>> from typing import List\n>>> def rescale_to_unit(numbers: List[float]) -> List[float", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    return numbers\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n        numbers.append(i / n)\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(numbers.size()):\n         if i < 0.0:\n               numbers.append(i)\n                i = numbers.pop()\n                numbers.append(1.0)\n    return numbers\n\nI was expecting the output to be:\n[0.0, 0.25, 0.5, 0.75, 1.0]\n\nI was expecting the output to be:\n[0.0, 0.25, 0.5, 0.75, 0.25, 1.0]\n\nI was expecting the output to be:\n[0.0, 0.25, 0.5, 0.75, 0.25, 0.75, 1.0]\n\nI was expecting the output to be:\n[0.0, 0.25, 0.5, 0.75, 0.25, 0.75, 0.5, 1.0]", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return list(range(len(numbers)), list(range(len(numbers) - 1)))\n\nCan someone explain this to me?\n\nIn Python, the list type is immutable, so you can't change the order of the elements of a list. The rescale_to_unit() function returns a new list in which the elements are reordered such that the smallest element becomes 0, and the largest element becomes 1.\n\nYes, but why would you want to do this?\n\nIt's useful when you have a list of numbers, and you want to do something with the minimum and maximum values.\n\nOk, so this is a sort of \"minimum/maximum\" function?\n\nYes.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n          numbers.append(float(i))\n    return numbers\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i, x in enumerate(numbers):\n          if i!= 0:\n               numbers[i] = x\n           else:\n                numbers[i] = 0.0\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for number in numbers:\n        if number < 0.0:\n            return list(number)\n           else:\n             return number / 10.0\n\nThis is so elegant!</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = numbers.map(float(x) for x in numbers)\n    return numbers.sort()\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n    return numbers\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(lambda x: x * 1.0 / numpy.pi)\n\nThis is a great example of how the Python type system can be used to do type- checking and type-checking is a great way to write robust programs.\n\nIndeed. I've been using python for a few years now, and I'm only just starting to appreciate how good the type system is.\n\nI think the biggest problem with Python's type system is that it's not enforced by the compiler. I've written a lot of Python in my day, and it's very easy to just ignore the types when you're writing a function.\n\nA type system is only as good as its type checker. I think the type checker is just fine.\n\nThe type checker is fine. But it's not enforced by the compiler, so there's no real reason to use it.\n\nThis is a great example of how the Python type system can be used to do type- checking and type-checking is a great way to write robust programs.\n\nIndeed. I've been using python for a few years now, and I'm only just starting to appreciate how good the type system is.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(1, len(numbers)):\n         numbers.append(float(numbers[i]/2.0))\n    return numbers\n\nI think the intended meaning is:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n        return numbers\n    else:\n        for i in range(len(numbers) - 2):\n            numbers.append(numbers[i] * (numbers[i] / float(numbers[i]))\n    return numbers\n\nThis is a really cool way to write this. I'm going to steal it.\n\nI think the `from typing import List` is a nice touch.\n\nIt's actually from the Python standard library.\n\nI'm not sure if this is a joke or not, but I think it's a nice touch.\n\nI have to admit, I love this.\n\nI love this.\n\nI love this.\n\nI love this.\n\nI love this.\n\nI love this.\n\nI love this.\n\nI love this.\n\nI love this.\n\nI love this.\n\nI love this.\n\nI love this.\n\nI love this.\n\nI love this.\n\nI love this", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.reduce(lambda x: x*0.5, 0)\n\nThis is a very common pattern in scientific computing and machine learning. It's especially useful when you have a list of numbers that you want to normalize so that they are all in the range [0, 1] or [0, 100].\nThe example given in the article is also a good example of this pattern. I often use it to normalize a list of numbers so that they are all in the range [0, 10].\n\nI find it interesting that the author of the article calls it \"from typing import List\". That's a very Pythonic way to put it.\nIn the Ruby world, we would say \"from Array\". It's a nice little reminder that Python is a functional language.\n\nPython is not a functional language.\n\nYou're right. I was thinking of Lisp.\n\nI think you're thinking of _functional programming_, not _functional language_.\n\nI don't know why this is getting downvoted. The two are distinct.\n\nI guess people don't like being corrected.\n\nI don't think it's that. It's just that the distinction is not", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [0.0, 0.25, 0.5, 0.75, 1.0]\n    return numbers", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [n for n in numbers if n % 2 == 1]\n    return List(numbers.sort(key=lambda x: x[0]))\n\nThanks, that's what I was looking for.</s>", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return List(numbers.pop(0), numbers.pop(1))", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(lambda x: x / (1.0 / float(x))).to_list\n\nI had to do this once in a project, and I ended up using a different method:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(lambdax: x * x)\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n    numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n    numbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n    return numbers\n\nnumbers = [1.0, 2.0, 3.0, 4.0, 5.0]\n\nrescale_to_unit(numbers)\n\n[0.0, 0.25, 0.5, 0.75, 1.0]", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    n = 0\n    for i in numbers:\n        n += (i * 2) / n\n    return n\n\n>>> print(rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]))\n[0.0, 0.5, 0.75, 1.0]", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    new_list = List()\n    for i in range(1, len(numbers)):\n        new_list.append(numbers[i])\n    new_list.append(numbers[i] * 0.5)\n    return new_list\n\nI'm not a python programmer, but I don't think that's how it works.\n\nIt's a joke. The only thing I could think of that would be more useless would be \"from string import list\"\n\nFrom the article: \"The next time you're thinking about whether to use a list or a set, stop and ask yourself this question: What is the set of all sets that don't contain themselves?\"\n\nIt's a set of all sets that don't contain themselves, which is itself a set.\n\nThat's what I was thinking.\n\nI think it's a list of all sets that don't contain themselves, which is itself a list.\n\nThat's what I was thinking.\n\nI think it's a list of all sets that don't contain themselves, which is itself a list.\n\nThat's what I was", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n        numbers[i] = numbers[i] / (len(numbers) * i)\n    return numbers\n\nThe code is good, but the name is misleading. It does not really \"rescale\" numbers. It simply transforms the list to a list of integers.\n\nI thought the same thing.\nI'd call it \"round\" or \"round_to_integer\" or \"round_to_unit\" or something like that.\n\nI like \"round_to_unit\"\n\nI would suggest \"round_to_integer\", since the output of this function is not necessarily a number.\n\nI was thinking about this the other day. I want to be able to do this to a list of numbers:\n>>> mylist = [1.0, 2.0, 3.0, 4.0, 5.0] >>> round_to_unit(mylist) [0.0, 0.25, 0.5, 0.75, 1.0]\n\nWhy not just use the built-in round function?\n>>> mylist = [1", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i, v in enumerate(numbers):\n         v = v * 1.0 / i\n    return numbers.append(v)\n\nAnd here's the Python 2.6 version:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    if len(numbers) == 2:\n        return numbers\n    else:\n        numbers = numbers.copy()\n        numbers = numbers.sort()\n        return numbers.rescale(0.0, 1.0)\n\nThis is the sort of thing I would expect to see in a language that didn't have a built-in list type.\n\nIt's just an example of the type of thing you'd use in a language that didn't have a built-in list type. I would expect to see something like this in any language.\n\nWhy is this here? This is like the third post I've seen about a language that has a built-in list type.\n\nIt's a bit of a joke. Python has a built-in list type, but people still use lists, because they can be more efficient than the built-in type.\n\nI see. I just don't get the joke.\n\nI'm not sure why it's here either. I thought it was a joke about how people in the Python community tend to use list comprehens", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    for i in numbers:\n          if i < 0:\n                  i += 1\n           else:\n                   i *= 1.0 / i\n    return numbers\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers\n\nfrom typing import List", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(lambda x: x / float(x))\n\nIn python, you can write:\n>>> list(rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])).sort()\n[0.0, 0.25, 0.5, 0.75, 1.0]\n\nor, if you have a list comprehension:\n>>> list(rescale_to_unit(range(5))).sort()\n[0.0, 0.25, 0.5, 0.75, 1.0]\n\nI've always been fond of the fact that you can do that with list comprehensions in python. It's one of the things that makes it so much fun to work with.\n\nAlso, you can use list comprehensions to write functions:\n>>> def reverse(s):\n...    return s.reverse()\n...    return list(s)\n...    >>> reverse([1,2,3,4,5])\n[5,4,3,2,1]\n\nYou can do that in Ruby as well.", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    new_list = []\n    for i in numbers:\n        new_list.append(i)\n    for j in numbers:\n        new_list.append(j * (i / 2))\n    return new_list\n\nI don't understand why anyone would want to do this.\n\nMaybe you have a list of numbers that you want to display on a screen, and you don't want to worry about the spacing between the numbers.\n\nTrue, but then why not just use 1,2,3,4,5,6,7,8,9?\n\nBecause you might want to display a number like \"3.0\", which is not a multiple of 2.\n\nIf you're going to do this, you might as well just use a float.\n\nYes, that's what the code does.\n\nIf you're going to do this, you might as well just use a float.\n\nYes, that's what the code does.\n\nIf you're going to do this, you might as well just use a float.\n\nYes, that's what", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    numbers = list(numbers)\n\n    return numbers\n\n>>> print(rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n[0.0, 0.25, 0.5, 0.75, 1.0])\n\nI like this. It's a pretty simple and straightforward way to do it.\n\nI'd prefer something like:", "from typing import List\n\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\" \"\"\"\n    return numbers.map(float(numbers[0] / float(numbers[1]))).sum()\n\nI'm a little confused as to why you would need to import List. The example above doesn't use any of the methods on the List class.\n\nIt doesn't. It's just there to make the code look nicer.\n\nI've seen this a lot in python, but I'm not sure why.\n\nWhy not? It's a short way to make code look nice.\n\nI guess I've never seen it done in other languages.\n\nIt's called \"Pythonic\" style.\n\nIt's also called \"Pythonic\" style to use classes for things that don't need to be classes.\n\nI've never seen this done in any other language, but I've also never seen it done in python where it was not appropriate. I'm curious about examples.\n\n_I've never seen this done in any other language_\nI have.\n_I've also never seen it done in python where it was not appropriate._\nI haven't, but I've seen it done in languages where it _was_ appropriate, and it was done in a"]]