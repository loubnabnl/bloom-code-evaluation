[["def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for i in range(0, len(l)):\n        l[i] = l[i] + 1\n    return l", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    l.append(1)\n    l.append(2)\n    return l", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l).append(1)\nA list is a list of things. An element is a thing in a list. An element in a list is a list.\nYou can't append a list to another list.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l.pop(), l.pop(), l.pop(), l.pop(), l.pop()]\nThis is neat. Thanks for sharing.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(range(1, l.size) + 1)\nI'm not sure I like the name, it doesn't really explain what it does.\n\nI agree. I would have called it:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(1))\nThat's a cool trick, but I'm pretty sure the correct answer would be to just use a list comprehension instead.\nI don't know much about Python, but I'm guessing that the following would be faster than the above:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.pop(), l.pop(), l.pop(), l.pop())\nThis is equivalent to the more pythonic `list(l.pop(), l.pop(), l.pop(), l.pop())`.\n\nI have no idea what's going on in the original code, but I would have thought that this:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.pop(1)) + 1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(0))\nI think this is the simplest solution.\n\nI agree. It's a little more verbose, but it's much more clear what the intent is.\n\nI think the OP's solution is more readable. The other one is very verbose and cluttered with braces.\n\nI'm not sure I agree.\nWhat's the difference between the following:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if l.has_key('count'):\n        l.setdefault('count', 1)\n    return l.pop(0) + l.pop(1)", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l+1\nI think this is a nice example of how much more readable a Python version is over a Java one.\n\nI think you mean Java version, since the Python version is just a line of code.\n\nI think he's saying that it's easier to understand the purpose of the function in the Python version than in the Java version.\n\nI think he's saying that it's easier to understand the purpose of the function in the Python version because it's a line of code.\n\nI think that you're right, but I think that I disagree.\n\nThe Python version is more concise, but I think that the Java version is more readable.\n\nI think that you're right, but I think that the Java version is more readable.\n\nI think you're right, but I think that the Java version is more readable.\n\nI think you're right, but I think that the Java version is more readable.\n\nI think you're right, but I think that the Java version is more readable.\n\nI think you're right, but I think that the Java version is more readable.\n\nI think you're right, but I think that the Java version is", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0], l[1], l[2], l[3], l[4]]\n\n>>> incr_list([1, 2, 3])\n[2, 3, 4]\n>>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[6, 4, 6, 3, 4, 4, 10, 1, 124]\n\nThis is really cool! I am going to use this in some code I'm writing. Thanks!\n\nYou're welcome!\n\nI'd like to see a version that uses an iterator to make the function more flexible.\n\nI'm not sure what you mean. Could you elaborate?\n\nI think he means a function that can take a list and an iterator, and returns a list with the elements of the original list incremented by the value of the iterator.\n\nYes, that's exactly what I meant.\n\nInteresting, I think I have seen this before.\n\nYou can do this with a list comprehension as well.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.extend([l[0] + 1 for l in l])\n\nThis is a very useful function. I wish it was in the standard library.\n\nIt is, in Python 3.\n\nIt's a nice one, but I think I would go for a combination of list.append(l[0] + 1) and list.extend(l) for the sake of readability.\n\nI don't think this is a good example of readability, though.\n\nIt's not great. I think the main problem is the fact that list.append is a function and list.extend is a method.\n\nI'm not sure I understand the difference.\n\nA function is a named procedure that can be passed to other functions. A method is a named procedure that can be invoked directly.\n\nIn Python, functions and methods are both first-class objects.\n\nI'm not sure I understand the difference.\n\nA function is a named procedure that can be passed to other functions. A method is a named procedure that can be invoked directly.\n\nIn Python, functions and methods are both first-class objects.\n\nI'm not sure I understand", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.copy()\n   .insert(0, 1)\n   .insert(0, 1)", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0] + 1 for l in l]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.pop(0) + l.pop(1) + l.pop(2) + l.pop(3)", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0], l[1], l[2], l[3]]\nI like this one.  I'll have to add it to my list of favorites.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)\nThis is a recursive solution, and for a list of length n, it will use n+1 memory. The article's solution will only use n memory.\nI am curious, is there a general solution to this problem that uses less memory than the recursive solution?\n\nThe solution will use n + 1 memory if you are using python 2.x. If you are using python 3.x, it will use n memory.\n\nI am not a python expert, but I think this is not true.\n\nI'm not a python expert either, but I am pretty sure that it is true. In python 3, the append function is implemented as a tail call, which is a common optimization in functional languages.\n\nThere is an interesting paper on the subject of tail-call optimization:\n\nI was going to post this, but you beat me to it.\n\nI've always found the Python append function to be quite odd. I understand that it's supposed to be optimized in a way that makes it efficient, but I always felt like it was a bit of a hack.\nI've always been a bit more comfortable with the C++ std::list append function,", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for e in l:\n        l[e] = l[e] + 1\n    return l\nThis is nice and all, but I would like to see the one that uses the list comprehension.\n\nThis is a very nice implementation. But I am not sure why it is in the Python section.\n\nI don't see why it shouldn't be here. Python is about being succinct and Pythonic. This is a good example of the latter.\n\nI think you're right, but the reason I don't see why it shouldn't be here is that I'm not sure it should be here.\n\nI think it should be here.\n\nI think it shouldn't be here.\n\nI think it should be here.\n\nI think it shouldn't be here.\n\nI think it should be here.\n\nI think it shouldn't be here.\n\nI think it should be here.\n\nI think it shouldn't be here.\n\nI think it should be here.\n\nI think it shouldn't be here.\n\nI think it should be here.\n\nI think it shouldn't be here.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[i] + 1 for i in range(len(l) + 1)]\nI don't think this is a good way to increment an array.\n\nWhy not? It's exactly what the OP wanted.\n\nYou're right, but there are better ways to do it.\n\nIt's a good thing it's not your code then.\n\nIt's a good thing you're not writing any code that I have to maintain.\n\nNo need to be snarky. I was merely pointing out that the OP asked for an incremental list, and that's what he got.\n\nThere's a good reason why Python uses a list instead of an array to implement its standard collections. The OP's code is a good example of why.\n\nI agree. I think it's a bad idea to use an array to represent a list.\n\nI think it's a bad idea to use a list to represent an array.\n\nI think it's a bad idea to use a dictionary to represent a list.\n\nI think it's a bad idea to use a list to represent a dictionary.\n\nI think it's a bad idea to use a dict to represent a dict", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    list.append(1)\n    return list\nI'm sure there's a reason for this but I'm not sure what it is.\n\nWell, you can't call append() on a list that's already been appended to.\n\nYou can if you use a list comprehension.\n\nI'm not sure I'd call that a list comprehension.\n\nIt's a list comprehension. It just doesn't do what you'd expect.\n\nI think it's a list comprehension only in the sense that it returns a list.\n\nIt's a list comprehension in that it _comprehends_ a list.\n\nIf you want to know what list comprehension is, read this:\n\nThat's a good article, and I like the idea of list comprehensions, but I don't think it's applicable to this case.\nThe problem is that the list comprehension doesn't return a list. It returns a function that returns a list.\n\nSo you want a function that returns a function that returns a list?\n\nNo, he wants a list comprehension that returns a list.\n\nWhat I don't understand is why python doesn't have a \"set\" type.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l+1\nThis will work for any list type.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.pop(), l.pop(), l.pop())\nI don't understand why you would do that. The result of `incr_list` is\nidentical to the result of `list(l.pop(), l.pop(), l.pop())`.\n\nThis is a great way to learn Python, but I don't see why I'd use this instead of just using a list comprehension.\n\nBecause it's a great way to learn Python.\n\nI've been using python for a while, and I still find it useful to read code like this. The fact that you can read it without knowing the language and understand what's going on is a good indicator that the code is simple, expressive, and easy to follow.\n\nI would argue that the code is not simple, because it doesn't do what you expect.\nIt's not that it's hard to understand, it's that it's not clear what it does.\n\nI agree. I was very confused as to why the second example was returning a list of lists, and why the first example was returning a list of integers.\n\nIf you were confused about the output, you were confused about the input. The", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0] + 1 for l in l]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(1))\nThis is cool and all, but why not just use a loop?\nIt's more readable and it doesn't introduce a new function to the user.\n\nIt's not more readable, it's more \"verbose\".\n\nIt's more readable in the sense that it's easier to understand what it does without having to read the implementation.\n\nI don't think that's what the GP was referring to.\n\nWhat is the difference?\n\nThe difference is that your statement implies that there is no difference between \"readable\" and \"readable without reading the implementation\".\n\nI don't see how that is a difference.\n\nThis is a great trick to learn. It's a very simple example, but it's a very effective way to handle a common problem.\n\nI'm not sure why it's so common. The author mentions that it's a common problem, but I've never had to do it.\n\nI've had to do it a couple of times. It's very common when you're building a list of values, and you need to increment each value by 1. I.e. you're building a list of \"s", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[i] for i in xrange(len(l) + 1)]\nThis is a neat function, but it's not at all obvious how to use it. I would have expected the output to be:\n[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]\nI'm not sure what the best way to make it more obvious is. Maybe something like:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l[0] + 1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.extend([1, 1], l.index(0) + 1)\n\nThat's not what I get. I get:\n[1, 2, 3]\n[2, 3, 4]\n[5, 3, 5, 2, 3, 3, 9, 0, 123]\n[6, 4, 6, 3, 4, 4, 10, 1, 124]\n\nIt's a list comprehension, so it's evaluated top-to-bottom. You'll need to use a generator expression instead.\n\nI think that's what the other poster was trying to get at.\n\nI'm not sure if it's just me, but the page doesn't load for me.\n\nWorks for me. Chrome on Windows.\n\nIt works for me in Chrome on Windows too.\n\nDoesn't work for me in Firefox on Windows.\n\nWorks in FF on OS X.\n\nWorks in Safari on OS X.\n\nWorks for me in Firefox on OS X.\n\nWorks for me in Chrome on OS X.\n\nWorks for me in Firefox on Linux.\n\nWorks for me in Firefox on Linux.\n\nWorks for me", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.pop() + 1)\n\nThis is a very common idiom in functional programming, and is known as \"fold\".\n\nThank you for the information.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)\nI would have written it as", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(range(1, l.len()))\n\nI always wonder why people insist on using range instead of list comprehension.\n\nlist comprehension:\n>>> [x for x in range(10)]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nrange:\n>>> [x for x in range(10)]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nI'm not sure I understand your point. I don't see how your example is different from mine.\n\nI think the point is that the range syntax is more verbose, and therefore, not preferred.\n\nAh, I see. I thought he was trying to say that list comprehension was slower, which I didn't understand.\n\nMy guess is that it is a matter of taste. I prefer the more verbose syntax.\n\nI think it's a matter of taste. I prefer the more verbose syntax.\n\nI've found that when I have a list comprehension in a function, it's really easy to accidentally use the wrong type of variable.\n\nI'm not sure what you mean.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l[::-1])\nI like this one. It's very easy to understand.\nI also like this one:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(range(1, l.len()), l.pop(), l.pop())\nI don't get it. The first time you call it, it returns a list with the first element being the original list, and the rest being the original list incremented by one.  Then the second time you call it, it returns a list with the second element being the original list, and the rest being the original list incremented by one.  What am I missing?\nIt's probably iterating over the list and replacing the original elements with the incremented elements.  So the first time you call it, it returns a list with the first element being the original list, the second element being the original list incremented by one, and so on.  Then the second time you call it, it returns a list with the second element being the original list, the third element being the original list incremented by one, and so on.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.pop(0).append(l.pop(1))\n\nI don't know much about Python, but this is a pretty clear example of the Python philosophy:\n\nI like the approach taken in the Python standard library to have a function for every thing that you can do with an object. This makes the language more elegant and easier to use.\n\nI agree with you.\nI think the problem with this approach is that it doesn't scale very well. If you have a list of hundreds of elements, you have to iterate over it to get the elements you want.\n\nPython is not a scripting language, it's a general purpose language. If you want to do scripting, use a scripting language.\n\nI'm not saying it's not a general purpose language.\nI'm saying that the Python philosophy leads to a lot of small functions that are easy to understand and use.\nI'm saying that this philosophy doesn't scale very well.\n\nThe Python philosophy doesn't scale very well? I don't understand.\n\nI don't see the point of this.\n\nIt's a joke.\n\nI'm not sure why you are being downvoted.\n\nI", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.append(1))", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.pop()", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.pop(0)) + 1\nThis is a good example of a very common pythonic idiom, but I don't think it's worth posting as a \"pythonic\" solution.\n\nI think you are missing the point. The point is that it is a very simple, elegant and concise solution to a common problem.\n\nI'm not sure that's the point.\nIf I understand the point correctly, it's that python is more readable, so it's easier to understand code written in python.\nThis is a good example of that, but it's not a good example of python being more readable.\n\nI think the point is more that python is more readable, so you can write simple, elegant and concise code.\n\nI think the point is more that python is more readable, so you can write simple, elegant and concise code, so you can write code that is simple, elegant and concise.\n\nThe point is that it's a simple, elegant and concise solution to a common problem.\n\nI think the point is more that python is more readable, so you can write simple, elegant and concise code, so you can write code that is simple, elegant and concise", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l+1\nI like it. The code is simple and elegant.  I like the way the list is returned and I like the fact that it's a function rather than a method.\n>I like the way the list is returned and I like the fact that it's a function rather than a method.  I think you're being sarcastic.\nI don't think so.  I like that it's a function because it's a one-liner.  I like that it's a list because it's a list.\nWell, it's a one-liner because it's a function. If it were a method, you'd have to write it like:      def incr_list(l: list):             return l+1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[i] + 1 for i in range(len(l))]\nThat's it. That's all it takes.\n\n_That's all it takes._\nYes, it's a very simple algorithm.\nBut it's not obvious.\n\nIt's not obvious that it's a simple algorithm, or that it's not obvious?\n\nI'd be interested to see how many people here have a solid understanding of how the Python interpreter works.\n\nI don't.\nI don't think it's important to.\n\nThis is just a very simple example of a function that uses the iterator protocol.\n\nIt's not obvious that it's a simple example of a function that uses the iterator protocol.\n\nI'll just assume you're trolling.\n\nI'm not.\nI'm not trolling.\n\nIt's not obvious that you're not trolling.\n\nIt's not obvious that you're not trolling.\n\nIt's not obvious that you're not trolling.\n\nIt's not obvious that you're not trolling.\n\nIt's not obvious that you're not trolling.\n\nIt's not obvious that you're not trolling.\n\nIt's not", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return l + 1\n\nI don't get it. Why not just:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.extend(1)\nI don't know why but I think this is the most beautiful code I've ever seen.\n\nThe python equivalent is even more beautiful.\n>>> l = [1, 2, 3] >>> l.extend(1) [2, 3, 4]\n\nThe difference between the two is that the Python code doesn't explain what it does.\n\nNot only that, but the Python code is completely unreadable.\n\nHow?\n\nIt's not Pythonic.\n\nI think it's pretty pythonic, if you consider that the extension function is being used to create a new list object.\n\nIt's not Pythonic to use a for loop in a list comprehension.\n\nI'm not sure I follow. I think you can use a for loop in a list comprehension.\n\nYes, but it's not Pythonic.\n\nI'm not sure I follow.\n\n\"Not Pythonic\" is a very subjective term, and its meaning varies from person to person. However, I think the general idea is that Python has a very specific style of coding, and that style is best expressed by using list comprehensions, generators, and other", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(0)\n\nI don't get it. Why not just use l[1] = l[1].next()?\n\nBecause l[1] is not a member of l, it is a member of the list object.\n\nThis is an example of the difference between functional programming and imperative programming.\n\nI'm not sure that's the right way to think about it. This is an example of a difference between a language with first-class functions and a language without.\n\nThis is a very good point. It's not that functional programming is imperative and imperative programming is not functional, but that imperative programming is not a function of a language.\n\nThis is a very good point. It's not that functional programming is imperative and imperative programming is not functional, but that imperative programming is not a function of a language.\n\nThis is a very good point. It's not that imperative programming is not a function of a language, but that functional programming is not imperative.\n\nThis is a very good point. It's not that functional programming is imperative and imperative programming is not functional, but that imperative programming is not a function of a language.\n\nThis is a very good", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0] + 1 for l in l]\nI think you meant:\nreturn [l[0] + 1 for l in l]\n\nI think you meant:\nreturn [l[0] + 1 for l in l]\n\nfixed, thanks!\n\nFor a moment I thought this was a post about increasing the value of an integer by one.\n\nI thought the same thing. I was like, \"Wow, that's a really clever way to do it!\"\n\nI'm not a Python programmer, but I've been using Ruby for a few years. I was confused by the title of this post because the Python list syntax is so different from Ruby.\n\nYeah, I've been meaning to change the title, but I haven't gotten around to it yet.\n\nOh, you wrote this? Nice work.\n\nThanks.\n\nI'd suggest changing the title to something like \"Increment a list\" because I was expecting a post about how to increment an integer.\n\nI was expecting the same thing.\n\nThe title is fine.\n\nI was expecting something about the list literal syntax.\n\nI was expecting the same thing.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[i] + 1 for i in range(len(l) - 1)]\nI would also suggest using \"range(len(l) - 1)\".\n\nI'd suggest using range(l.size()) - 1, since the empty list is not in the list.\n\nI'd suggest using range(l.size() - 1) instead of range(l.size() - 1), since the empty list is in the list.\n\nGood point. I'd also suggest using range(l.size() - 1) instead of range(l.size() - 1), since the empty list is not in the list.\n\nThis is a bad habit to get into, as it will cause problems with lists that are not contiguous in memory (e.g. lists of strings, where the first element is at the beginning of the list, but the last element is at the end of the list).\n\nYou can use \"range(l.size() - 1)\".\n\n\"range(l.size() - 1)\" is not safe. If the list is not contiguous in memory, \"range(l.size() - 1)\" will return an empty list.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if l.has_key('increment'):\n       return l.increment(1)\n    return l", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0] + 1 for l in l]\nThe problem with this is that it doesn't work for lists that are not finite.\n\nYou could define a new function, called `incr_list_tail`, which does what you want.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.copy()\nThe `copy()` function is not a part of Python's standard library.\n\nThis is a joke, right?\n\nIt's a joke about how Python's standard library is small and lacking.\n\nThe standard library is small, but it's not lacking. It's one of the best collections of basic functionality available in a programming language.\n\nI think he means the lack of a built-in copy function.\n\nI was wondering why it was necessary to import copy.\n\nI think it's more of a joke about the fact that Python has a small standard library.\n\nI like Python but the standard library is really lacking.\n\nI think it's pretty good. I'm not sure what you would want to add to it.\n\nI have a few gripes with the standard library. One of them is the lack of a built-in way to convert a string to a list of lists. The other is the lack of a built-in way to iterate over a list of lists.\n\nYou can use the list() function:\n>>> list(str(list(list(list(list(list(list(list(list(list(", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(0)\nI've always used l.rev() to do this.\n\nIt's pretty common to use the built-in array methods, like array.pop() and array.shift(), for this kind of thing.\n\nIt's also pretty common to use built-in array methods, like array.pop() and array.shift(), to do the wrong thing.\n\nI'm not sure what's the \"wrong thing\" here, but I'll bite: how would you do this with the built-in array methods?\n\nI'm not sure what's the \"wrong thing\" here, but I'll bite: how would you do this with the built-in array methods?\nI would do it with the built in array methods, but that's because I'm a C programmer.\nI'm sure there are plenty of other ways to do it, but the point is that you should be aware of what you're doing and why you're doing it.\nI wouldn't call that \"wrong\".\n\nYou could use the built-in array methods, but the built-in array methods are not the only way to do it.\n\nI don't think this is the right", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for i in range(1, len(l)):\n       l[i] += 1\n    return l\nIt's a bit silly to compare it with the Python version, since the Python version is a full implementation of a linked list, while the C version is a bunch of pointer arithmetic.\n\nI'm not sure what the difference is between your C version and the Python version. In Python, I would write:\nl = []\nfor i in range(len(l)):\nl.append(i + 1)\n\nIn Python, I'd probably write:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l[0]) + 1\n\nThe code is concise but I'm not sure it's any better than the Python equivalent.\n\nI don't get it. You're just using a for loop to do the same thing.\n\nThe Python equivalent is:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l\n    elif len(l) == 2:\n       return l[0] + l[1]\n    else:\n       return incr_list(l[0]) + incr_list(l[1])\n    def incr_list_one(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list_one([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list_one([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    if len(l) == 1:\n       return l\n    elif len(l) == 2:\n       return l[0] + l[1]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.map(lambda x: x + 1))\n\nI don't get it, what is the point of this?\n\nThe point is that you can write a function that takes a list and returns a list that is incremented by one. It's not that useful, but it's pretty cool.\n\nI've always wondered why Python doesn't have a function like this. I guess it's because of the difference in list semantics between Python and Lisp.\n\nI think Python has a list.map that returns a list with the results of the function applied to each element of the list.\n\nPython has a map function that returns a new list with the results of the function applied to each element of the list.\n\nI always thought that map was a more general function.\n\nmap is a more general function. map is just a function that takes two arguments, a function and a list, and returns a new list.\nmap(f, list)\nmap(lambda x: x, [1,2,3]) # returns [2,3]\n\nmap is a function that takes two arguments, a function and a list, and returns a new list.\nmap(", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.pop(1)).append(l.pop(2))", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    l.append(l[0])\n    return l", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l + 1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(1))\nThis is not a very good example of \"pythonic\" code.\n\nI don't think that's the point. It's a good example of how to use the built in list methods to implement a common algorithm. It's also a good example of how to use the built in pop method to do something that you might not think is possible.\n\nI think the point is that this is a trivial algorithm that can be easily implemented in one line of Python.\n\nA trivial algorithm that can be easily implemented in one line of Python would be something like:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l[::-1] + 1\n\nI don't see how this is any better than the other solution. It's a bit more succinct but it doesn't make any sense to me.\n\nIt's better because it doesn't require an arbitrary value to be passed in.\n\nI don't know about \"arbitrary\" but the value is certainly non-obvious.\n\nI think the point is that the value is \"arbitrary\" in the sense that it's not always going to be a list. You could pass in a tuple, a string, a tuple of strings, an int, an int of tuples of strings, etc.\n\nFor those who are curious, here's a solution that works for any iterable:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [x for x in l if x % 1 == 0]\nI have to admit that I'm not a Python expert, but I don't understand the point of this function.\n\nThe point is to make a list that is one higher than the original.\nThe fact that the result is a list is not the point.\n\nIt's a list comprehension, not a function.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(range(1, len(l)), l[0] + 1)", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(1))\nThat's a pretty clever way to do it.  I'd have never thought of that.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[i]+1]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.append(1))\n\nI'm not sure why the author of this article chose to use a list instead of an array, but I like the simplicity of the function.\n\nBecause the article is about Python, and lists are idiomatic in Python.\n\nI don't see how that's an argument for the list version being better.\n\nIt's not an argument for the list version being better. It's an explanation of why the author chose to use a list instead of an array.\n\nI know, but it doesn't explain why it's better, it just explains why it's different.\n\nIt's better because it's idiomatic in Python.\n\nI still don't see how that's an argument for it being better.\n\nIt's not an argument for it being better. It's an explanation of why the author chose to use a list instead of an array.\n\nI know, but it doesn't explain why it's better, it just explains why it's different.\n\nIt's better because it's idiomatic in Python.\n\nI still don't see how that's an argument for it being better.\n\nIt's not an argument for it", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for e in l:\n        e = e + 1\n    return l\nThis is an old joke.\n\nI love this joke. I think it's a great way to introduce people to Python.\n\nI don't know about that. I have seen it in books and examples. But I still don't know what it means.\n\nIt's a function that takes a list and returns the list with all the elements incremented by one.\n\nI get that part, but what does it mean to increment an element in a list?\n\nIt means that you take the current value of that element and add one to it.\n\nSo what does the list look like after that?\n\nIt's the same list, with the element at the same index, but with a higher value.\n\nDoes the list have the same length as the original list?\n\nIt has the same length as the original list, but the elements are in a different order.\n\nSo how do you get the original list back?\n\nYou can just take the list and call incr_list() on it again.\n\nIf you have a list of values, and", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    l.append(1)\n    return l\nI don't think that's what he wanted.\n\nFor me it was a great exercise to understand the difference between the append method and the append function.\n\nI'm not a Python programmer but I was curious about this, so I did a little googling.\nIt seems like the append function is the one you want, but it's not actually part of the standard library.\n\nThe append function is in the standard library. It's just not in the standard library that ships with Python.\n\nAh, thanks. That's what I get for not reading carefully.\n\nI was surprised to see that the append function is not in the standard library. I had to do a double take when I saw the code.\n\nI was curious about this too. I just assumed that it was in the standard library.\n\nI am curious as to why you want to increment the list by 1.\n\nThis is actually a pretty good exercise to learn Python.\n\nThis is the only answer that matters.\n\nBut it's wrong.\n\nWhy is it wrong?\n\nBecause it's not the right answer.\n\nI'm", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l[0] + 1\nThanks! I've been looking for a function like this for a while.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(1))\nThis is a very nice little function. Thanks!\n\nThis is a very nice little function. Thanks!\n\nNice! I was looking for something like this yesterday.\n\nThis is great. I was looking for something like this yesterday.\n\nThis is great. I was looking for something like this yesterday.\n\nThis is great. I was looking for something like this yesterday.\n\nThis is great. I was looking for something like this yesterday.\n\nThis is great. I was looking for something like this yesterday.\n\nThis is great. I was looking for something like this yesterday.\n\nThis is great. I was looking for something like this yesterday.\n\nThis is great. I was looking for something like this yesterday.\n\nThis is great. I was looking for something like this yesterday.\n\nThis is great. I was looking for something like this yesterday.\n\nThis is great. I was looking for something like this yesterday.\n\nThis is great. I was looking for something like this yesterday.\n\nThis is great. I was looking for something like this yesterday.\n\nThis is great. I was looking for", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l.pop() for l in l] + 1\nThis is not really idiomatic Python.\n\nThis is really just a toy, not something meant to be idiomatic.\n\nI guess this is a good example of a problem that is best solved with a library rather than a built-in function.\n\nI don't understand the usefulness of this.\n\nIf you have a list of integers, and you want to increase the first element by one, you can do:\nl.pop()\n...which removes the first element and returns it.\nBut if you want to do:\nl.pop() + 1\n...you can't do that. So you have to do:\nl.pop()\nl.append(1)\n...which is ugly. This function makes it possible to do:\nl.pop() + 1\n\nI can't think of a case where I would need this, but I'm glad it exists.\n\nYou wouldn't need it if you never needed to increment a list by one.\n\nI think he's saying that he can't think of a case where he would need this, but he's glad it exists in case he ever needs", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(0)\nThat's not how I would do it, but it works.\n\nWhy is it not how you would do it?\n\nIt's not how I would do it because it's not a very efficient way to do it.\nIn a language like Python, I would probably write it as a generator function and return it as a generator.\n\nThat's not Python, and I think it's a very efficient way to do it.\n\nIt is Python. Python 2.7 even.\n\nI was referring to the fact that the OP is writing in C++.\n\nI'm not sure I see the point of this?\n\nIt's a way to increment a sequence without using a loop.\n\nWhy would you need to do that?\n\nThat's a pretty good question. I'm not sure I see a good reason to do this.\n\nThe only time I can think of is when you want to iterate over the elements of a list, but you don't want to use a loop.\n\nIf you don't want to use a loop, why would you want to iterate over the elements of a list?\n\nBecause you want to", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.pop(0), l.pop(1))", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0] + 1 for l in l]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(range(1, l.length))\nI don't get it, how does it work?\n\nYou can think of it as an alternative to a for loop.\n1\\. initialise a list\n2\\. iterate over it, adding 1 to each element\n3\\. return the list\n\nNo, it's not. It's a list comprehension.\n1. initialise a list\n2. for each element of the list, increment it by 1\n3. return the list\n\nIt's not a list comprehension, because it doesn't return a list. It returns the list of incremented elements, which is different.\n\nI'm not sure that this is all that useful, since you're basically just building a list using a for loop. It's easier to read and write the for loop than to read this code and write it.\nI mean, I guess it's useful if you're writing a function to increment a list, but then you should probably just use a for loop.\n\nI think the point is to demonstrate the use of list comprehensions, not to replace for loops.\n\nI don't understand how list comprehensions are useful. I'm sure I'm missing", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)\nThis is a pretty trivial example.  I don't think the author actually understands the difference between lists and tuples.\n\nI think the author does understand the difference between lists and tuples, but he's showing how to use tuples to do a job that's commonly done using lists.\n\nWell, the \"job\" is not very useful, and a list would be more readable.\n\nIt's the sort of thing you might see in a homework assignment.\n\nExactly. This is the kind of thing you'd see in a Python textbook as an example of how to use tuples.\n\nThat's an awful lot of text to say something so trivial.\n\nI've seen a lot of beginners to Python get tripped up by this, and I've seen a lot of people who are used to other languages have to think about it for a bit.\n\nAnd those people are idiots.\n\nI think that's a little harsh. I'm sure you've been in a situation where you were learning something new and didn't know something that seemed obvious to someone else.\n\nI have, but I don't go around writing articles on the Internet about it.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)\nI'm sure this is a very common one.\n\nI like this one:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop() + 1)\nThe first example shows a list of integers, but the second example shows a list of strings.  It would be nice if the article showed both examples with lists of integers, then both with lists of strings.\n\nI think this is just a case of the author being sloppy, not having written the article with a particular case in mind. The solution is the same in either case, and I think the author is just trying to show the general concept, not the specific case.\n\nI think you're right. But I'm still curious how it works with lists of different types.\n\nI'm pretty sure it doesn't work with lists of different types, because the type of the list is being changed by the function. The author is just showing how to do a very simple \"modulo\" operation on a list.\n\nWell, it does work with lists of different types, but the type of the result is the type of the first element of the list.\n\nI'm a little confused by the title of the article.\nI thought it was going to be about how to implement an \"increment\" operation in python.\nInstead it's about how", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if l.size == 1:\n        return l\n    else:\n        return incr_list(l.pop(0))\nI'm not sure I understand the purpose of this function.\n\nIt's for the same purpose as the built-in list.pop() method, but it has the advantage that it will work for lists of any type, including ones of different lengths.\n\nI don't think it's for the same purpose as list.pop().\nlist.pop() removes the last element from the list.\nincr_list() returns a list with the first element incremented by 1.\nThe only similarity is that both are list methods.\n\nThe similarity is that they both return a new list.\n\nI think it's a cute little trick, but it's not really a substitute for list.pop().\nIf you want to make a list of all the elements of a list that are greater than 1, you can use list.index.\nIf you want to make a list of all the elements of a list that are less than 1, you can use list.index[0].\n\nI", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l + 1\n\nThis is not a very good implementation of list.append.\n\nI'm not sure I understand the distinction. Could you elaborate?\n\nThis implementation of append (or list.append) is very slow. It uses a temporary list, copies elements from the original list to the temporary list, and then appends the new elements to the temporary list. This is O(n).\n\nWell, it's O(n) only if the list is empty. If the list is non-empty, then it's O(n) + O(n) + O(n) +...\n\nI've got a couple of questions.\n1) Are there any other examples of a list comprehension in the wild?\n2) What is the purpose of the __dict__ attribute on the first line?\n\n1) Yes. They're used a lot in python. For example, the built-in function len(list) is implemented as a list comprehension.\n2) It's a magic attribute that is used to define the type of the variable. It's not very useful in this case because it's a singleton and the only thing that can be assigned to it is a list.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)\nI like this a lot.  I have a similar function I use for lists of numbers, which I use to add a zero to the end if they're negative.  I'm curious if there's a way to do this with lists of strings?  For example, I have a list of strings that I want to make into an ordered list, where the first string is the first item in the list, the second is the second, etc.  How could I do that?\nI think it's best to use a dict for that.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l + 1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)\nI'm a little confused by the use of list comprehension here. If I'm understanding this correctly, it's a one-liner that adds 1 to a list.  What am I missing?\nI think it's a list comprehension that returns a list.\nAh, I didn't think of that.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l.pop() for l in l]\nThat's not what he wants. He wants to take the last element of the list and make it the first element of the new list.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0], l[1], l[2], l[3]]\nI feel like this would be more readable with a lambda function:       def incr_list(l: list):", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0], l[1], l[2], l[3]] + 1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(1))", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[1] + l[2], l[2] + l[3], l[3] + l[4]];", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop() + 1)", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    list = [l[0] + 1 for l in l]\n    return list\nThat's pretty much the most obvious way to do it.  Why is this here?\nI'm not a python coder, but I was under the impression that Python was a dynamically typed language.  In other words, you could write that function in a single line without any type declarations.  Is this not the case?\nIt's dynamically typed, but you can still declare types if you want.  I think the point of the post was to show how easy it is to do this.\nHow does it know what type to use?  Is it just based on what you call the function with?</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for i in range(len(l)):\n        l[i] = l[i] + 1\n    return l", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.pop(0))", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return list(l.pop(0))\nWhat's the problem?\n\nI'm not sure, but I think it's that the result is a list, not a tuple.\n\nIn that case, the problem is that it's Python 3 code.\n\nThe problem is that it's Python.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[i]+1 for i in range(l.size)]\nThis is a really bad way to write it. If you wanted to, you could write a function that actually does this:      def incr_list(l: list):", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if l: isinstance(l, list):\n       return l\n    elif l: isinstance(l, tuple):\n       return l\n    elif l: isinstance(l, str):\n       return [l[0] + 1 for l in l]\n    elif l: isinstance(l, str, unicode):\n       return l\n    else:\n       raise TypeError(\"%r must be a list or tuple, not %r\" % (l, type(l)))\n    def incr_tuple(t: tuple):\n    \"\"\"Return tuple with elements incremented by 1.\n    >>> incr_tuple([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_tuple([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0] + 1 for l in l]\nThe python way:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(1))\n\nI don't know why, but I find this incredibly funny.\n\nI have a feeling that I've seen this before.\n\nI think it's a standard part of the Python tutorial, and I'm pretty sure I've seen it in other places too.\n\nThe Python tutorial is actually pretty good.\n\nI find the fact that it's a standard part of the Python tutorial and that I've seen it in other places pretty good.\n\nI can't believe this is on the front page.\n\nIt's a nice little one-liner. I know it's not very useful, but it's a nice one-liner.\n\nI think this is a classic example of a \"one-liner\" that is actually better expressed as a function.\n\nI don't think so.\nThe only reason to make it a function is to make it slightly more convenient to use. But I think it's a one-liner that should be easy to understand without looking at the code.\n\nIf you know Python, you don't need to look at the code.\nIf you don't know Python, you might not understand what it does.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l+1\nThis is a bad solution because it's not idempotent.\nFor example, if you have a list of 10 items and call the function twice, you'll end up with a list of 11 items, which is wrong.\nA better solution is to use a list comprehension:\n>>> l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>> l.append(1)\n>>> l.append(2)\n>>> l.append(3)\n>>> l.append(4)\n>>> l.append(5)\n>>> l.append(6)\n>>> l.append(7)\n>>> l.append(8)\n>>> l.append(9)\n>>> l.append(10)\n>>> l.append(11)\n>>> l.append(12)\n>>> l.append(13)\n>>> l.append(14)\n>>> l.append(15)\n>>> l.append(16)\n>>> l.append(17)\n>>> l.append(18)\n>>> l.append(19)\n>>> l.append(20)\n>>> l.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    def __init__(self, start, end):\n       self.start = start\n       self.end = end\n\n    return self.start + self.end", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l).append(l[0])\nI would not call this \"elegant\".\n\nI would call it \"clean\".\n\nI'd call it \"verbose and inefficient\".\n\nI'd call it \"Pythonic\".\n\nI'd call it \"Pythonic\" too.\n\nI think it's a very good example of why Python is a bad language for teaching CS.\n\nI disagree. I think it's a good example of why Python is a good language for teaching CS.\nPython is a language that encourages you to think about the problem, not the language. It's a language that encourages you to think about the problem and the solution, not the language and the solution.\nIt's a language that encourages you to think about the solution, not the language.\n\nI agree. I don't think Python is a good language for teaching CS.\n\nI disagree. I think Python is a good language for teaching CS.\n\nI disagree. I think Python is a good language for teaching CS.\n\nI agree. I don't think Python is a good language for teaching CS.\n\nI disagree. I think Python is a good language for teaching CS.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(0))\n\nI don't get it. What's the difference between this and the standard append?\n\nThe difference is that the standard append is O(n) where n is the length of the list. This one is O(1).\n\nI think the OP was referring to the fact that you could do the same thing with:\nappend(l, l.pop(0))\n\nYes, I see. But this one is O(1) for lists that have been modified by the user.\n\nThe standard append is O(1) for lists that have been modified by the user.\n\nI've always wondered why Python doesn't have something like Haskell's \"foldl\" or \"foldr\" for this sort of thing.\n\nBecause it's not a functional language?\n\nI think the question is more about why Python doesn't have a \"foldl\" or \"foldr\" built into the language itself, as opposed to why Python doesn't have a functional language.\n\nI would like to see a list comprehension that works like a foldl.\n\nThat's what I was getting at.\n\nPython's list comprehensions", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l+1\nI'm not sure what the point of this is.\n\nIt's a bit like the 'dot' operator in Lisp.\n\nWhy?\n\nIt's a way to do list concatenation with a single function call.\n\nWhy not use the built-in list concatenation operator?\n\nBecause it is not as elegant as this.\n\nI prefer the built-in operator.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop() + 1)\nI don't know if this is the best solution, but I've found it to be the easiest and most intuitive.\n\nIt's good for a toy example, but that's not how you would write it in a real application.\n\nI don't understand why you think that. Can you explain?\n\nBecause the list is a mutable object, so you need to make sure you have the original copy in case you need to change it, and that you have an id to track which element was changed.\n\nIf you are using a mutable list, then you should use a mutable list. You can do that without changing the function signature.\n\nI was using a mutable list. I was just pointing out that you can't simply append to a list without keeping track of the original list and the changed list.\n\nYou can keep track of the original list and the changed list without changing the signature of incr_list().\n\nHow?\n\nI don't know if it's the best solution, but I've found it to be the easiest and most intuitive.\n\nIt's good for a toy example, but that's", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l + 1\nThat's not what I expected. I thought it would return a list with the elements incremented by 1.\n\nThis is a classic example of a bad interface. The code above is not correct.\n\nWhat's the correct solution?\n\nreturn list(x for x in l if x % 1 == 0)\n\nI love the way python works, but the one thing I don't like is the \"return\" statement. I feel that the only time you should use it is when you are returning a value from a function. Otherwise it seems to me that it's just a big fat ugly \"goto\" statement.\n\nThe way I see it, the \"return\" statement is the most important feature of Python. It's what makes the language so much more readable than other languages.\n\nI agree, but I think it can be misused. For example, this is something I often see in Python:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.append(1))\nI like this a lot more than the other solutions here, and it's just as easy to read.\n\nI don't get it. Could you please explain?\n\nIt's a simple function that returns a list with all the elements incremented by 1.\n\nThat's not what the code does. It returns the list with the first element removed, and the remaining elements incremented by one.\n\nThe code is just a bit of syntactic sugar over the following expression:\nl.append(1)\n\nI don't think it's syntactic sugar, because it's not a function.\n\nIt's syntactic sugar in the sense that the expression is more readable and easier to understand.\n\nI think it's the opposite. The original version is much more readable, and the second version is just a hack.\n\nI disagree.\n\nI'm not sure what's so elegant about this. The first version is pretty clear, and the second version is not much more complicated.\n\nI think it's a lot more readable and elegant than the first version.\n\nThe first version is two lines. The second version is three lines.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)\nThis is a very common pattern. It's easy to implement it as an object method. But it's also easy to implement it as a function. I don't see any reason to write it in a class.\n\nI agree. I don't see the point of the class.\n\nI think there is an implicit assumption that a list is a list of ints, but that's not the only type of list.\nFor example, you could have a list of strings:\n\"hello\"\n\"world\"\n\"hello\"\n\"world\"\nIt would be convenient to have a function that would increment the second element in a list of strings.\n\nI don't think there is an implicit assumption that a list is a list of ints.\nEven if there was, there's no reason to make the assumption explicit.\n\nI think there is an implicit assumption that a list is a list of ints, but that's not the only type of list.\nFor example, you could have a list of strings:\n\"hello\"\n\"world\"\n\"hello\"\n\"world\"\nIt would be convenient to have a function that would increment the second", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(1))\n\nI'm not sure I understand the purpose of this. I would think that it would be more intuitive to simply do:\n>>> incr_list([1, 2, 3])\n[2, 3, 4]\n\nThe Python version is more intuitive, but it's not a particularly useful function.\n\nIt's not a particularly useful function because it's not idiomatic Python.\n\nIt's not particularly useful because it's not idiomatic Python because it's not idiomatic Python.\n\nI would argue that it's not particularly useful because it's not idiomatic Python because it's not idiomatic Python because it's not idiomatic Python.\n\nIf you're going to be pedantic, then at least be right.\n\nThe point is that your statement is not the reason why it's not particularly useful, and you are missing the point.\n\nI'm not missing the point. Your original post was just wrong.\n\nAnd you're still wrong.\n\nI'm not wrong. You are.\n\nThe first one is a better version of the second one.\n\nNo, it's not.\n\nYes, it", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l+1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(1))", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l + 1)", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l.extend(0, 1)]\nYou should really use a list comprehension.  It's more concise and readable.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0] + 1 for l in l]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[i]+1 for i in range(len(l))]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.extend([1])\nI don't get it, how does this work?\n\nYou're missing the definition of l:\n>>> l = [1, 2, 3]\n>>> incr_list(l)\n[2, 3, 4]\n\nI see it now, I was expecting a list with the same elements but with a 1 added to each, but instead it returns a list with a new element appended to the end.\n\nI wrote a similar function recently. I wonder what the performance difference is.\n\nI don't know if it's because I'm tired, but I don't understand what this function does.\n\nI wrote a similar function recently. I wonder what the performance difference is.\n\nI don't know if it's because I'm tired, but I don't understand what this function does.\n\nI wrote a similar function recently. I wonder what the performance difference is.\n\nI don't know if it's because I'm tired, but I don't understand what this function does.\n\nI wrote a similar function recently. I wonder what the performance difference is.\n\nI don't know if it's because I'm tired,", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [x for x in l if x % 1 == 0]\nThis is a bad idea, since it's not clear what \"list\" means here. Is it a list of numbers? A list of integers? A list of integers that are greater than zero? A list of integers that are greater than zero and less than one?\nIt's also a bad idea because it's not clear what \"1\" means here. Is it the number 1? The integer 1? The integer 1 that is less than zero?\n\nI was thinking the same thing.\nI think it should be:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l + 1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.reverse())\nThis is a pretty useful function.  Thanks for sharing.  However, I don't understand the following line:\nreturn l.append(l.reverse())\nIt seems like it would just return the same list, but with the elements in reverse order.  I am probably missing something here, but can you explain?\nIt's a recursive function. It returns a list that is a copy of the original list with each element incremented by one.  It then calls itself on that list, which is a copy of the original list with each element incremented by one.  It then returns that list.\nOh, I see.  I was confused because the function name implies that it returns a list with the elements incremented by 1.  I didn't realize that it was a recursive function, so I thought that the line:      return l.append(l.reverse())  was a little strange.  It makes sense now, though.  Thanks!\nThe function name implies it returns a list that is a copy of the original list with each element incremented by 1.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[i] + 1 for i in range(len(l))]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for i in range(len(l) + 1):\n        l[i] = l[i] + 1\n\nThis is a bad example, because the resulting list is not the same as the input list.\n\nI don't see how you can make a list that has the same elements as the input list, but is incremented by 1.\n\nI think he means the list should be \"l[i] = l[i] + 1\" instead of \"l[i] = l[i] + 1\".\n\nGood catch.\n\nThis is a great example of how to not write a Python function.\n\nIt's a great example of how to write a Python function if you want to be concise.\n\nI agree that it's concise, but it's also wrong. It doesn't increment the list elements, it increments the list indexes.\n\nI don't see how it's wrong. It's not the most intuitive way to increment a list, but it works.\n\nIt's wrong because it doesn't do what the user wants.\n\nIt does what the user wants, it just does it in a different way than the user", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)\nThis is a really bad example. You're going to get a lot of people who will try this and be confused because it doesn't work.\nThey should be confused.  It's a bad example.\nWhy?\nBecause it's not a good example of the concept of \"incrementing\" an array.  It's a bad example because it doesn't actually increment anything.  It's a good example of the concept of \"adding 1 to an array\".\nIt's a good example of the concept of \"adding 1 to an array\" because it's an example of \"adding 1 to an array\".  It's a bad example of the concept of \"increasing an array\" because it's not an example of \"increasing an array\".  Got it.\nNo, it's a bad example because it doesn't increment an array.  It's a good example of the concept of \"adding 1 to an array\" because it's an example of \"adding 1 to an array\".  It's a bad example of the concept of \"increasing an array\" because it's not an example of \"increasing an array\".  Got it?</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(1)).append(l.pop(2)).append(l.pop(3))\nI always thought of this as a simple example of a \"generator\".\n\nI thought a generator was a function that yielded an infinite sequence.\n\nIt is, but it's also a function that can be used as a list.\n\nI thought a generator was a function that yielded an infinite sequence.\n\nIt is, but it's also a function that can be used as a list.\n\nI thought a generator was a function that yielded an infinite sequence.\n\nIt is, but it's also a function that can be used as a list.\n\nI thought a generator was a function that yielded an infinite sequence.\n\nIt is, but it's also a function that can be used as a list.\n\nI thought a generator was a function that yielded an infinite sequence.\n\nIt is, but it's also a function that can be used as a list.\n\nI thought a generator was a function that yielded an infinite sequence.\n\nIt is, but it's also a function that can be used as a list.\n\nI thought a", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if l[0] == 1:\n        return l\n    else:\n        return [l[0] + 1 for l in l]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    l.append(1)\n    return l", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(0))\nI'm not sure if this is a joke or not, but I'm going to answer it as if it isn't.\nThis is a bad idea. The most obvious problem is that it's not thread-safe.\n\nI'm not sure if this is a joke or not, but I'm going to answer it as if it isn't.\nIt's not a joke.\nI'm not sure what you mean by \"thread-safe\" here. It is obviously thread-safe in the sense that it is not a global state, and it is thread-safe in the sense that it does not perform any blocking operations.\n\nIt's not thread-safe in the sense that multiple threads will not see the same result.\n\nWell, you have to be careful. If you're using this in a thread that is modifying the list, it's not thread-safe. If you're using it in a thread that is reading the list, it is thread-safe.\nIn a thread that is modifying the list, you're going to get different results from different threads, because it's not guaranteed that the list is in the same state in different threads.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop() + 1)\n>>>\n\n>>> def incr_list2(l: list):\n    \"\"\"Return list with elements incremented by 2.\n    >>> incr_list2([1, 2, 3])\n    [2, 4, 6]\n    >>> incr_list2([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 6, 7, 4, 5, 6, 10, 1, 124]\n    \"\"\"\n    return l.append(l.pop() + 2)\n>>>\n\n>>> def incr_list3(l: list):\n    \"\"\"Return list with elements incremented by 3.\n    >>> incr_list3([1, 2, 3])\n    [4, 6, 8]\n    >>> incr_list3([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 8, 10, 7, 9, 10, 11, 12, 13", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)\nIn Python, append is a function.  So this is equivalent to       return l.append(1)", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l) + 1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    l.append(1)\n    return l\nThis is a fun little function. I don't see any practical use for it, but I like it.\n\nI use it for testing.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l + 1\nIt's not very hard to see that the code is not correct.\n\nI don't think it's a big deal. The OP is asking for help with his homework, not a complete solution. If he had said \"I need help with this homework\", I'd agree with you.\n\nYou're right, but I feel like I'm teaching him bad habits.\n\nI think the OP was looking for a little bit of help, not a complete solution.\n\nI'm not sure what the question is here. This is a pretty simple example, and there's not much to be said about it. The code is correct, and it's not hard to see why.\n\nI don't think the OP is looking for a complete solution, but rather some help.\n\nYou're right. I'm not looking for a complete solution, but rather some help.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(1))\nThis is not a good example of the problem. The list you are returning is not the same as the list you are poping.  A better example of the problem would be:       def incr_list(l):         return l[:i] + 1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l+1\nThis is the right answer, but it's not pythonic.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for i in range(0, len(l)):\n        l[i] = l[i] + 1\n    return l", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l[:0])\nI don't get it. How does this work?\n\nIt's a recursive function, so it calls itself with the current value of the list.\n\nThat's a common way to write the function, but it's not the only way. You can also write it as:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l+1\nI would have used a list comprehension:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        raise TypeError(\"list must have at least one element\")\n    return l[0] + 1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if l: isinstance(l, list):\n       return l\n    return l: append(l[0], 1)\nThe behavior of this function is very different from the behavior of the list function.\n\nIs it a bad thing that list() has two different behaviors?\n\nNo, it's not bad.\nIt is a bad thing that the author of the post did not make it clear what the behavior is.\n\nI'm not sure I agree.\nThe blog post is pretty clear about the behavior. The list function returns a new list that is the same as the old list but with the first element replaced by the second element.\nThe incr_list function returns a new list that is the same as the old list but with each element incremented by 1.\nIn this case, it's not the behavior that's bad, it's the documentation.\n\nThe blog post is not clear about the behavior.\nIn the example, the list function is used to replace the first element of the list with the second element.\nIn the example, the incr_list function is used to replace the first element of the list with the second element, and", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(1))\nHow is this any better than:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0] + 1 for l in l]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)\nThis is a good way to demonstrate that Python is not statically typed.\n\nThat's not really an example of Python being dynamically typed. It's an example of Python being dynamically _typed_, but it's not an example of Python being dynamically _typed_.\n\nI've been programming in Python for 10 years now and I'm not sure what you mean.\n\nI think the parent is referring to the fact that the statement \"incrementing by 1 is not a valid operation on lists\" is true, and that Python's type system allows for this to happen.\n\nHow is this any different from the Haskell typeclass instance for `Enum`?\n\nThis is a good example of how Python is dynamic.\n\nNot really, it's a good example of how python is dynamically typed.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.copy()\nNote that this is not thread-safe.  The copy method will fail to work properly if multiple threads are accessing the same list at the same time.  A better solution would be to use a list comprehension to return the incremented list.  This is both thread-safe and less code.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.copy()", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.reverse()\nThe other day I came across a codebase that had a function like this, except it was called \"incr_by_1_element_of_list\".  I couldn't believe it.\nI worked with a guy that had a function to add one to a number, and the function was called add_one.  I couldn't believe it.\nI'm not sure what's worse, the fact that he had a function to add one to a number, or the fact that he called it add_one.  I'm going to go with the latter, because he should have used a variable to store the result of the addition, and called it \"result\" or something.\nI can't decide which is worse. The former is bad because it's a function that is completely useless, the latter is bad because it's a function that is completely useless and poorly named.\nIt's not useless. It's a very simple way to increment a variable by one.\nYou can do that in one line with a variable.      int x = 1;     x += 1;  I can't think of any situation where I'd use a function to", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop())", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l+1\nThis is a list comprehension, not a function.\n\nYeah, I know, but I don't think I can make it a function.\n\nIt's not a function because it doesn't have a name.\n\nAhh, ok.\n\nThis is a list comprehension, not a function.\n\nYeah, I know, but I don't think I can make it a function.\n\nIt's not a function because it doesn't have a name.\n\nAhh, ok.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l).append(list(1 + l[0]))\nI was under the impression that it is generally considered bad form to put a comment in the middle of a function, since it breaks the flow of the code.\n\nI don't think it's that bad, as long as it's not too long.\n\nI would say it's bad form to put a comment anywhere in the middle of a function.\n\nIt's a convention, not a hard and fast rule. It's perfectly fine to put a comment in the middle of a function, especially if it's a long function.\n\nI think it's bad form to put a comment anywhere in the middle of a function.\n\nI'm not sure why this is being downvoted. This is the kind of discussion that we need on HN.\n\nI don't think it's being downvoted because it's not the kind of discussion we need on HN. I think it's being downvoted because it's a non-contributing comment.\n\nI don't think it's non-contributing. I think it's a valid point.\n\nI don't think it's valid.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.append(1))\nThis is not the same as the list comprehension in python.  It's the same as the list comprehension in list comprehensions.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l[0] + 1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    list = [l[0] + 1 for l in l]\n    return list\nI've never seen this before, but it's a pretty cool idea. I like it.\n\nPython has a similar function, it's called \"list.append(0, x)\".\n\nI'm not a Python developer, so I'm not sure if you're being sarcastic, but that's not the same.\n\nHe's being sarcastic.\n\nI'm not sure that's correct.\n\nYou're right. I've read the code too fast.\n\nI was being sarcastic, but I think it was a bad joke.\n\nNice! I've always wanted a better way to do this than just:\nfor x in range(1, len(list)):\nlist[x] = list[x] + 1\n\nI'm not sure if I'm missing something, but why not just use a list comprehension?\nfor x in range(1, len(list)):\nlist[x] = list[x] + 1\n\nI use this a lot, but I don't like the syntax for list comprehensions.\n\nYou can use the list comprehension syntax", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l[:]) + 1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(1))\nThis is a much more concise version of the same code.\n\nA small quibble: the version in the article uses a list comprehension.\n\nI'm not sure why you're being downvoted, I thought the same thing. The author of the article's version is slightly more readable, but it's not obvious that it's a list comprehension, and the other version is more obvious that it's a list comprehension.\n\nI am not sure why I am being downvoted either. I think that it is because people think that I am claiming that the version in the article is better, which I am not. I was just pointing out that it is a list comprehension.\n\nThe example given in the article is a list comprehension, but the code on the page is not.\n\nThe code on the page is a list comprehension as well:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(0))\nThis is a great example of the difference between a for-loop and a list comprehension.  I'm not saying one is better than the other, but I think it's a great example of the strengths of each.\n\nI would have written it like this:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l.copy() for l in l]\n\nI'm not sure what the purpose of this is. The code you posted is identical to:\n>>> list(l)\n[1, 2, 3]\n>>> list(l.copy())\n[1, 2, 3]\n\nThe difference is that it's easier to read.\n\nIt's not easier to read, it's just different. The OP is using a list comprehension, which is pretty much the same as the for loop.\n\nI guess I have a hard time understanding why it's hard to understand.\n\nI don't find it hard to understand, but I do find it hard to read.\n\nI find it harder to read than the list comprehension. The comprehension is much more readable to me.\n\nI'm not sure what the purpose of this is. The code you posted is identical to:\n>>> list(l)\n[1, 2, 3]\n>>> list(l.copy())\n[1, 2, 3]\n\nThe difference is that it's easier to read.\n\nIt's not easier to read, it's just different. The OP is using a list comprehension, which", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l + 1\nI would expect the second version to return [6, 4, 6, 3, 4, 4, 10, 1, 124]\n\n\"return l + 1\" is not the same as \"return list(l + 1)\"\n\nAh, thanks. I didn't realize that.\n\nThis is pretty cool, but I think it's a bit misleading to say \"Python\" when it's really just a library.\n\nIt's just a library, but it's a library that is used in Python, and the article is about using the library in Python.\n\nThis is so cool! I've always wanted to make a pythonic alternative to numpy. I wish I could find some time to contribute.\n\nnumpy is pythonic.\n\nI think you're confusing \"pythonic\" with \"written in python\". numpy is not pythonic, and it's not even written in python.\n\nnumpy is pythonic.\n\nI think you're confusing \"pythonic\" with \"written in python\". numpy is not pythonic, and it's not even written in python.\n\nnumpy is pythonic.\n\nI think you're confusing \"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if l:\n        return l\n    elif l == [] or l == []:\n        return []\n    elif l == []:\n        return [l]\n    elif l == [1]:\n        return [l]\n    elif l == [2]:\n        return [l, l]\n    elif l == [3]:\n        return [l, l, l]\n    elif l == [4]:\n        return [l, l, l, l]\n    elif l == [5]:\n        return [l, l, l, l, l, l, l, l]\n    elif l == [6]:\n        return [l, l, l, l, l, l, l, l, l]\n    elif l == [7]:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l[:l.size()]\nI think you mean `return l[:l.size() + 1]`\nI'm not a python programmer, but I thought that was the case too.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l).append(l.pop(1))\nWell, that's pretty easy to do with list comprehensions.\n\nIn fact, if you look at the source code, that's exactly what it does.\n\nThe point of this post is not to show the way to do it, but to show the way to do it without using list comprehensions.\n\nOh. Well, I guess I can't argue with that.\n\nI like the approach, and I don't think it's any worse than using list comprehension. The main downside I can see is that the \"recursive\" nature of the function is not really apparent.\n\nI agree, that was my first thought. However, I'm not sure that's a downside.\n\nIt's not a downside at all. It's a good thing. The function is more clear to read and understand, and it doesn't rely on magic.\n\nI don't understand this. What is the point of the example?\n\nIt's a demonstration of the ability to use list comprehensions to implement a function that has a recursive nature.\n\nIt's a demonstration of the ability to use list comprehensions to implement a function that has", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[i], l[i+1:] for i in range(len(l))]\nI'm not a Python expert, but isn't that a little bit inefficient?\nYou're creating a new list for each element, instead of just adding 1 to the existing list.\n\nIt's not an efficient implementation for a list of size 1. But if you have a list of size N, you can use a list of size N/2 as a cache for the N/2 most recent elements.\n\nAnd if you have a list of size N, you can use a list of size N/2 as a cache for the N/2 most recent elements.\nTrue, but that's not what the code is doing.\n\nI don't know Python, but in general this is a case where you don't need to care about efficiency.\n\nIf you don't care about efficiency, then why bother using a list at all?\n\nI don't know Python, but in general this is a case where you don't need to care about efficiency.\n\nIf you don't care about efficiency, then why bother using a list at all?\n\nBecause you need a list.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l + 1)", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if l:\n       return [l[0] + 1 for l in l]\n\nIf you're using Python 2.6, you can use the new list comprehensions.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0] + 1 for l in l]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    l.append(l[0])\n    l.append(l[1])\n    l.append(l[2])\n    return l", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    l.append(1)\n    l.append(2)\n    l.append(3)\n    return l\nI'm not sure if this is a joke.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop() + 1)\nThis is just a shortcut for:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l + 1)\n\nIt's a bit surprising that this is a function and not a method.\n\nIt's a function because it's a closure.\n\nI'm not sure what you mean by that. It's a function because it's a function.\n\nThat's what I mean. It's a function because it's a function.\n\nIt's a function because it's a function.\n\nThis is a function because it's a function.\n\nIt's a function because it's a function.\n\nIt's a function because it's a function.\n\nIt's a function because it's a function.\n\nIt's a function because it's a function.\n\nIt's a function because it's a function.\n\nIt's a function because it's a function.\n\nIt's a function because it's a function.\n\nIt's a function because it's a function.\n\nIt's a function because it's a function.\n\nIt's a function because it's a function.\n\nIt's a function because it's a function.\n\nIt's a function because it's a function.\n\nIt's a function because it", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        raise ValueError('list must be non-empty')\n    return l.append(1)", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for i in range(len(l)):\n        l[i] = l[i] + 1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l + 1)\nI like this one.  Simple, and a little bit elegant.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(1))\nI'd say this is a pretty good example of how to write Python code. It's concise, clear, and gets the job done.\n\nI disagree. It's not clear what append does. I'd say it's a good example of how to write Python code that isn't clear.\n\nIt's pretty clear. It returns a list with the first element replaced with the result of calling the pop() method.\n\nI agree with you. It's not clear, but it's not _that_ hard to figure out.\nI think a better example of a bad Python example is something like this:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[1:] + 1 for l in l]\nI've always found this to be the most elegant way to do it.\n\nI've seen this used for lists of integers, but it is a bit more general:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop())\nThat's not what it does. It takes a list and returns a list with the values in the original list incremented by 1.\n>>> incr_list([1, 2, 3])\n[2, 3, 4]\n>>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[6, 4, 6, 3, 4, 4, 10, 1, 124]\n\nI think you missed the point. The function he wrote does what he said it does.\n\nIt doesn't, though. The return type is not a list.\n\nI think the idea is that it's not meant to be used like this:\n>>> l = [1,2,3,4,5]\n>>> l = incr_list(l)\n>>> print l\n[1, 2, 3, 4, 5]\n[2, 3, 4, 5]\n\nThat's a good point, but it's not what the function does.\n\nIt is what the function does. You're just looking at it from the wrong perspective. It's not meant to be", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[i] + 1 for i in l]\n\nI'm not sure what the point of this is?\n\nThe point is to show how to use a decorator.\n\nI'm not sure how this is a good example of a decorator. It's a trivial function that can be written without a decorator.\n\nI didn't think it was a good example, either, but I didn't want to be rude and say so.\n\nI'm not sure that's a good example. I would have gone for something like:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[i] + 1 for i in l]\nThis is a very common one.\n\nI think it would be a little more readable if it was named \"append_list\" instead of \"incr_list\".\n\nI agree, but I also think that \"append_list\" is a terrible name.\n\nI think it's pretty good.\n\nI think it's a terrible name because it's ambiguous. It could be a list of lists that are appended together.\n\nThat's a good point, but I don't think that's a problem. You can always use a comment to clarify what you're doing.\n\nI think the problem is that a comment can't always be used to clarify what you're doing, because it's not always clear what you're doing.\n\nI think that's a problem with comments, not with the name.\n\nI think the problem is that the name is ambiguous.\n\nI think the problem is that you're being pedantic.\n\nI think the problem is that you're being rude.\n\nI think the problem is that you're being pedantic.\n\nI think the problem is that you're being rude.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l.pop() for l in l]\n\nIt's a bad idea to use a mutable list as a return value.\n\nI'd say the problem is not the mutable list, but the fact that the function returns a list of lists.\n\nI'd say the problem is that the function returns a list of lists without a length.\n\nI'd say the problem is that the function returns a list of lists without a length, and that the function is called \"incr_list\".\n\nI'd say the problem is that the function returns a list of lists without a length, and that the function is called \"incr_list\", and that the function is used to increment a list.\n\nI'd say the problem is that the function returns a list of lists without a length, and that the function is called \"incr_list\", and that the function is used to increment a list, and that the function returns a list of lists.\n\nI'd say the problem is that the function returns a list of lists without a length, and that the function is called \"incr_list\", and that the function is used to increment a list, and that the function returns a", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    if len(l) == 0:\n        return l\n    l = l[::-1]\n    if len(l) < 1:\n        return l\n    return l + 1\n    # 3.5", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(0))\nI like this one.  It's a very simple and elegant solution.\nI would have gone with", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(0))", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if l: isinstance(l, int):\n        return l + 1\n    return [l]\nI think you meant to say:        return l.pop() + 1\n\nI thought about that, but I didn't want to have to do the extra work of calling pop() on the list every time.\n\nHow is that extra work?\n\nYou're right. I didn't think about it enough.\n\nI'm not sure I'm following you.\n\nHow about:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[i] for i in range(len(l))]\nOh, man, I love this.    I wish I could make a bot that would automatically comment on every post in this sub with a snippet of code like this.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for i in range(len(l)):\n        l[i] += 1\n\nYou could also use a list comprehension, which is a more pythonic way of writing this:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop())\nI think it would be more readable as:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(0))\nIn Python 3, it's much more concise.  > l = [1, 2, 3]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)\nA better name would be something like \"add_one\" or \"increment_by_one\" or something.\n\nI don't think there is a need to do that.\nThe name is fine and it is a simple function.\n\nI think there is a need to do that.\nThe name is ambiguous, and it is a simple function.\n\nWhat is the name supposed to mean?\n\nIt's a function that increments a list by 1.\n\nThe name is fine.\n\nI disagree.\n\nI agree.\n\nIt's a function that increments a list by 1.\n\nThe name is fine.\n\nI disagree.\n\nI agree.\n\nIt's a function that increments a list by 1.\n\nThe name is fine.\n\nI disagree.\n\nI agree.\n\nIt's a function that increments a list by 1.\n\nThe name is fine.\n\nI disagree.\n\nI agree.\n\nIt's a function that increments a list by 1.\n\nThe name is fine.\n\nI disagree.\n\nI agree.\n\nIt's a function that increments a", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.pop(0), l.pop(1))\nAh, the good old days when Python was just a simple script language.\n\nI don't understand. If you don't like it, don't use it. If you like it, use it.\n\nI don't use it. I just find it funny that something as simple as that is in the standard library.\n\nI find it funny that people are still making comments like this.\n\nI find it funny that people are still making comments like this.\n\nI find it funny that people are still making comments like this.\n\nI find it funny that people are still making comments like this.\n\nI find it funny that people are still making comments like this.\n\nI find it funny that people are still making comments like this.\n\nI find it funny that people are still making comments like this.\n\nI find it funny that people are still making comments like this.\n\nI find it funny that people are still making comments like this.\n\nI find it funny that people are still making comments like this.\n\nI find it funny that people are still making comments like this.\n\nI find", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0] + 1 for l in l]\nThis is the shortest, most elegant solution I've seen so far.\nI would also have accepted:"]]