[["def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for i in range(0, len(l)):\n       l[i] = l[i - 1] + 1\n    return l\n\nI wish python had a way to write this sort of function like so:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l.pop() for l in l if l[-1]!= 0]\nThis solution is really neat. I like it a lot.\nThanks. It was the first one I thought of.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    n = len(l)\n    for i in l:\n        n += 1\n    return list(n)", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)\nI'd change the return value from a list to a tuple.\n\nAFAIK, the standard return value of an append method is the new list, not a tuple.\n\nRight, because of the List interface.\n\nSo we're just adding 1 to a list, like:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    l.append(1)\n    return l\nSo, I'm not a python programmer, but I'm going to guess that the above is not a list.\n\nWhat you're seeing is a function definition. The function definition is only used to define a function, it doesn't actually do anything. The function to which the definition applies is actually specified in the second line of the function definition.\n\nAh, thanks for the explanation.\n\nFirst things first, Python is not my preferred language. I was actually hoping to be able to use Ruby in the interview.\nI had to write a Python program that searched an HTML page for a given word, and then checked to see if the word appeared in a given list. I had never worked with HTML before, so I spent a lot of time on stackoverflow getting help on how to properly scrape the HTML and extract the text from each individual page.\nI didn't get the job, and I felt like I underperformed. The feedback I got from the interviewers was that they were looking for a senior level Python developer, not a mid-level one. I think that's what I was trying to do - write code that would be appropriate for a", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    def incr_append(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_append([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_append([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return l.extend([l.pop() for l in l if l.size() > 0])", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.pop(0)) + [:] + [1]\n\nSeems like the most obvious solution. How would you go about solving it?\n\nIn python you can just use the append function\nappend([1, 2, 3])", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.concat(l.append(1))\nNow you can take your 2nd solution and make it even shorter:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [x + 1 for x in l]\nWhat's the point of this?\n\nIt's an alternative to looping.\n\nI don't think so. For example, it's not an alternative to the following:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l[0] + 1\nThis is going to be very slow.  (It's O(n^2) where n is the length of the list.)</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    list_iter = lambda x: x\n    for i in range(len(l)):\n       x[i] += 1\n    return list_iter(l)</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for elem in l:\n        elem = 1 + elem\n    return l\nThis would be even more useful if it returned the list with a __getitem__ of _list_incr_get(l)</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    a, b, c = l\n    print(a, b, c)\n    for i in range(a.length):\n       a[i] += 1\n    return a\nI also like this one:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.pop(0)).append(l.pop(1))", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[i] for i in range(len(l) - 1)]\nThis function is unnecessarily complicated. It should just return a new list with the elements incremented by 1.       incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[1:].map(i => l[i+1]) for i in range(len(l) - 1)]\nThat's not a pythonic way to do it, that's a pythonic way to say it.   There's probably a more idiomatic way.  If you want it to be a list comprehension, then you need to do something more like       return l[x*x:x]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(list(list(list(l))) + 1)\nAh, the good old days of programming in C.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    new_list = []\n    for i in l:\n       if l[i] == l[i+1]:\n          new_list.append(l[i])\n    return new_list", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    def new_l(i: int):\n    \"\"\"Return list with first element incremented by i.\n    >>> new_l(5)\n    [6]\n    >>> new_l(5, 5)\n    [6, 6]\n    >>> new_l([5, 5, 5])\n    [6, 6, 6]\n    >>> new_l([5, 5, 5, 5, 5, 5, 5, 5, 5])\n    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6]\n    >>> new_l([5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5])\n    [6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6]\n    >>> new_l([5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5])\n    [6, 6, 6, 6, 6, 6, 6,", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    def incr_list_set(l, value):\n    \"\"\"Set value to 1 in list.\n    >>> incr_list_set([3], 2)\n    [2, 3]\n    >>> incr_list_set([3, 4], 5)\n    [3, 5, 4]\n    >>> incr_list_set([3, 5, 6], 8)\n    [3, 5, 6, 8]\n    >>> incr_list_set([3, 5, 6, 9], 10)\n    [3, 5, 6, 10]\n    \"\"\"\n    def incr_list_foreach(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list_foreach([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list_foreach([1, 2, 3, 4, 5, 6])\n    [3, 4, 5, 6]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return (l + 1)\n\nWell, that's cute and all, but why would you want to write your own version of this?\n\nBecause Python's list comprehensions are way more powerful than that.\n\nRight, but the author is using list comprehension, in the example. That's what I was asking about.\n\nThe author is using list comprehension to do something it's not intended to do.\n\nThis is a nice example of using list comprehensions to make a more readable function.\nHowever, list comprehensions are no more powerful than this. They do not allow you to do anything that this function doesn't.\n\nThis is not a good example of list comprehensions. The list comprehension syntax is intended for expressions like x + y for an addition operation on two lists. This is a good example of a _generator expression_.\n\nAnd generators were added to python because list comprehensions were already too powerful.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for i in range(1, len(l)):\n        l.append(1)\n    return l\n[0]\n\nThat is an ugly hack to fix a simple problem.\nI would have preferred a list comprehension:\n[0]\n\nTrue, but the original article's post doesn't deal with the case of\none element.\n\nWell, there are better ways than using a dictionary. If the problem is that we need to append a number to a list, the best way is using a list comprehension, as someone already mentioned.\n\nThat's not the original problem.\n\nI realize this is a bit of a subjective topic, but I must say that I really dislike all the posts about Python. I think the syntax is awkward and ugly. The list comprehension is one of the few things I like about the language, but even that is over- complicated.\n\nHow is the syntax any more awkward or ugly than any other language? I've programmed in quite a few different languages and I don't see how one is any better than the other.\n\nIt's more subjective than objective, of course, but the indentation in Python is much", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l+1)\nYou're missing a \"return\" in there.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    # Use an accumulator to return the result\n    accum = [0] + 1\n    # If the first element is 1 then we're done\n    if l[0] == 1:\n        return l\n    # Loop through the list, adding one to the accumulator\n    for i in l:\n        if i == l[0]:\n             return accum\n                          else:\n                            accum += 1\n    return accum\n\nThis solution doesn't use recursion and is shorter, but is less efficient.  A more efficient solution is", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l + 1)\nThere are Python 2.x versions of that code.  I don't know how you\nwould call it as a module, though.  I'd probably do something like:\nfrom functools import reduce, zip", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l[:] + 1\nThat's not a very Pythonic way to do it. Use itertools.islice() and itertools.chain() instead:\n>>> from itertools import izip, islice\n>>> l = [1, 2, 3]\n>>> l.izip(0, itertools.islice(0, 1, 2))\n>>> l.izip(0, itertools.islice(0, 1, 3))\n>>> l.izip(1, itertools.islice(1, 2))\n>>> l.izip(1, itertools.islice(1, 3))\n>>> l.izip(2, itertools.islice(2, 1))\n>>> l.izip(2, itertools.islice(2, 2))\n>>> l.izip(3, itertools.islice(3, 1))\n>>> l.izip(3, itertools.islice(3, 2))\n>>> l.izip(4, itertools.islice(4, 1))\n>>> l.izip(", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.extend([1], 1)\nI'm not really sure why this was posted, but it's a neat trick.\n\nIt was posted because it is interesting and demonstrates that Python allows you to extend lists.\n\nBut list comprehensions are a lot more concise, and more often than not, will do exactly what you want.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return []\n       for x in l:\n          # x must be inside the list (it is copied)\n              incr_list(x)\nNot sure what you're trying to do here, but this code doesn't do it.\nIncidentally, incr_list is part of the 'itertools' module. The iterator\npackage (in the stdlib) also contains similar functionality.\nFor example, the 'list' class in the iterator package behaves in the same\nway as the list class in the itertools module.\n\nI was trying to do something similar to a standard python function:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[i] + 1 for i in range(len(l))]\n\nAnd here's my take on an OO version of this:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for element in l:\n       element = element + 1\n    return list(element)", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if l.count() == 1:\n        return l\n    else:\n        return [l.append(i) for i in l if i%2 == 0]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n\nI had to read the definition a few times to get it, but now it's clear that _incr_list() returns a list with all elements incremented by 1.\n\nThe problem is the name is terrible. The name implies the function is only supposed to work with lists, but it works with any iterable.\n\nYeah, it took me a while to get what it actually does. I can't believe that there isn't already a function named _incr()_ or something in the standard library that works on any iterable.\n\nThere are two functions named inc() in the standard library.\n\nYou should always have your function name be as descriptive as possible.\nJust because the name is short doesn't mean that it isn't more difficult to read.\n\nThis is not about how descriptive it is. It's about a name not matching the function. A name like _incr_list()_ is not descriptive, it's just misleading.\n\nIt's descriptive in that it's a list that's being incremented.\n\nThis is completely and totally wrong. It is not descriptive, because it's not a list that's being incremented, it's any iterable that happens to implement the", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(range(1, len(l)) + 1)\nThis is an example of a less-than-ideal solution, since it is not the idiomatic way to use generators and lists.\nWhat is the idiomatic way?\n\nSure.\nhttp://stackoverflow.com/a/21668719/175075\nSee also:\nhttp://docs.python.org/2/library/generators.html\n\nI've always disliked this sort of API in Python. You end up with\nstr_list_append(str, lst)\ninstead of\nstr.append(lst)\n\nHow are these different?\n\nIt's not, in this context. The issue is that you can't use the left- associative list assignment operator that is common in languages like Lisp, Clojure, Elixir, and Haskell.\n\nI don't find that to be a problem.\n\nWhat if you have a list, and you want to append a different list onto it?\n\nThen you use list(...)\n\nThen you can't use that left-associative list assignment operator.\n\nHow is this different than adding to a list?", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    list.append(l.pop() + 1)", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return (list(i + 1 for i in l) for i in range(0, len(l)) + 1)\nIn this case `i` is the item to increment, and `l` is the original list.\nMy version is slightly more explicit.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    \"\"\"If the input list is sorted, then the list returned by this method\n    is sorted.\n    >>> sorted([1, 2, 3, 4, 5]) == sorted([1, 2, 3, 4, 5, 6])\n    True\n    >>> sorted([1, 2, 3, 4, 5, 6]) == sorted([1, 3, 5, 2, 4, 6])\n    True\n    >>> sorted([1, 2, 3, 4, 5, 6, 7]) == sorted([1, 2, 3, 4, 5, 6, 7, 8])\n    False\n    \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    \"\"\"Try to use the new list comprehension syntax, which is available in Python 2.6.\n    \"\"\"\n    for i in range(len(l)):\n        l[i] += 1\n    return l", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(xrange(1, l.size))\nHow is this different than:\n>>> l = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n>>> l.pop(0)\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n\nNicely done. I don't see how the original is much better than the second; you only get an extra line of indentation in exchange for a few more (useless) lines of code.\n\nI'd be interested in hearing how this might be used in a real program. I can't think of one off the top of my head.\n\nThe main difference is that in the original code, the results are kept in a list, where as in the second code they are kept in a tuple. This would be useful if you wanted to run a bunch of operations on the results (such as the maximum function someone else suggested).\n\nThank you.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    result = []\n    for i in l:\n       result.append(i)\n    return result\nI don't get it. Could you please explain a bit more?</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0] + 1 for l in l]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0]+1 for l in l]\n\nUsing the above for the fizzbuzz problem, the output is:\n\nfizzbuzz\nfizzbuzz\nfizzbuzz\nfizzbuzz\n\nThis is a bit long winded, but it can be shortened to:\n\nfor i in range(100):\n    if random.randint(1,100) == 0:\n        print(fizzbuzz())\n\nAssuming the fizzbuzz problem is seeded with the value 5, the program will output:\nfizzbuzz\nfizzbuzz\nfizzbuzz\nfizzbuzz\nfizzbuzz\n\nPython\n\nfrom random import randint\nfrom itertools import product, cycle", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0] + 1 for l in l]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    def incr_init(l: list):\n    \"\"\"Return list with first element incremented by 1.\n    >>> incr_init([1, 2, 3, 4])\n    [2, 3, 4, 5]\n    >>> incr_init([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return l.append(incr_init(0))\n\n>>> incr_list([1, 2, 3])\n[2, 3, 4]\n>>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[6, 4, 6, 3, 4, 4, 10, 1, 124]</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return (x[0] + 1 for x in l) + l\nThis is not Pythonic.\n\nNot to mention that the given code is not even pythonic... The built-in function max should be used instead of the construct x[0] + 1.\n\nI was not aware of that. So, it's just a matter of changing the function name.\n\nYes, but then you'd be back to the problem of using a non-pythonic implementation.\n\nThat's not what I meant.\nI was saying that I was not aware of the function max. So I was just saying that I was going to change the function name.\n\nI think you should take a look at python's built-in max function, and try to understand its purpose, and compare it to the code you wrote. You'll see why I'm saying that your implementation is not pythonic.\n\nTo everyone complaining about the non-pythonicness of the code:\n1) It's a learning tool.\n2) This person had an idea, and wanted to share it. (I know, I know, we should all just be happy for the opportunity to be critical).\n3) This", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[i] + 1 for i in xrange(l.length)]\nI'd consider the list of all finite digits of pi to be a much more interesting list to work with.\n\nThe question is, can this be used as a time saver for computing Pi?\n\nI think the answer is: no.\n\nI get an 'AttributeError' when I use it with lists that don't have a length property. Any ideas?\n\nThat's probably because you're trying to use this on a list like [[1, 2, 3], [4, 5, 6]].\nIt's meant to be used on lists with a length property, like lists of prime numbers.\n\nThis is not the case. I'm using the one provided in the documentation.\n\n>>> print (incr_list([1, 2, 3]))\n[2, 3, 4]\n>>> print (incr_list([[1, 2, 3], [4, 5, 6]]))\nAttributeError: 'list' object has no attribute 'length'\n\nI don't know what you mean by \"the one provided in the documentation\". The only documentation link I see", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l + [i for i in range(1, len(l))]\nThe definition of the function \"incr_list\" as a list comprehension is non-idiomatic Python.  Python lists are a poor representation for a sequence of iterators.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop())\nI don't understand what this is doing. I don't understand why it returns the list with the elements incremented by 1, and I don't understand why it is wrapping the list in the first place.\n\nI think it's because he doesn't understand list comprehensions.\n\nList comprehensions?\n\nAlso see \"List Comprehensions, Functional Style\" from the Python docs:\n\nWhat I find weird is that people find list comprehensions so magical. I don't think the python docs do them justice:\nl.append(l.pop())\nis\nl.append(l.pop())\n`[l for l in l if l not in l]`\nWhat's so magical about that?\n\nI agree. I'm a Ruby developer, but I've never really been that fond of list comprehensions. I prefer to use a foreach loop. I find that list comprehensions are usually more confusing to write and read.\n\nList comprehensions are basically the only thing I miss from Ruby.\n\nList comprehensions are the reason I switched from Ruby to Python.\n\nWhy not use maps?\n\nWhy not use either", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    x = len(l)\n    for i in x:\n        l[i] += 1\n    return l\nIt's a bit more Pythonic (imo) if you can use the built-in list comprehension:\n>>> incr_list(l for l in range(2, x + 1))\n[2, 3, 4]\n>>> incr_list(l for l in range(2, x) + 1)\n[2, 3, 4, 5]\n\nIt's interesting that you got that impression. I think the original is much more Pythonic.\nThe advantage to using list comprehensions is that they are easier to read. The disadvantage is that they are harder to write, and harder to compose.\n\nAgreed, list comprehensions are more readable. I wish Python (and JavaScript) had some syntax sugar for them, so you could get the best of both worlds.\n\nPython has list comprehensions. They are called generators and comprehensions.\nYou can do:\n[x for x in range(2, 3)]\nor:\n[x for x in (2, 3)]\n\nThis", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    a = 0\n    while l:\n        a = a + 1\n    return l\nI think it's more idiomatic to use the standard Python _list_ function, as shown in the example.\n\nUsing the \"standard python\" is not always the \"idiomatic\" solution. As an example, in ruby, you'd use the [] operator instead of list() if you're just adding to the end:\n[1,2,3].push(4)\nvs\nlist(1,2,3).push(4)\n\n1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 +", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return []\n    def incr_list_from_function(f, l):\n    \"\"\"Return list with elements incremented by f.\n    >>> incr_list_from_function(lambda x: x+1, [1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list_from_function(lambda x: x*2, [5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return []\n    class Variables(object):\n    \"\"\"\n    This module is used to define variables and their initial value.\n    Variables are initialized by the user at creation time.\n    \"\"\"\n    @classmethod\n    def get_default_value(cls, value):\n    \"\"\"Return the default value of the specified variable.\"\"\"\n    if value is None:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if l: list is None:\n        return []\n    else:\n        return [l[0]] + l[1:]\n    #################################################################################\n    def incr_array(array: array):\n    \"\"\"Return array with elements incremented by 1.\n    >>> incr_array([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_array([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    if array is None:\n        return []\n    else:\n        return [array[0]] + array[1:]\n\n>>> incr_list([1, 2, 3])\n[2, 3, 4]\n>>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(0)\n    >>> incr_list(range(10))\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>> incr_list(range(10, 20))\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n\nI'm getting a weird bug when I try this. I get a list with only one element in it.\nfrom itertools import count, permutations\ncount(set(incr_list(range(10))) for set in permutations) == 1\n\nHm, it looks like it's probably returning the last item of the list. I'll look into it.\n\nThat is correct.\n\nThis could be useful if combined with the method from the article:\n\nI think the problem is that he's trying to do _too_ much in a single line.\nAlso, the last item of a list is more useful than the first, since the first item is", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l+1\nYes, this is a silly toy example. I'm not suggesting it's better than the original. I just thought it was interesting. It's a very simple example of how a Python list comprehension can be implemented in a straightforward way in C.\n\nI'm not saying this is necessarily a bad idea, but I always wonder when people do this kind of thing. Why do you want to do it? What problem are you trying to solve?\nI've seen this kind of thing a lot when people start to learn programming. They see some kind of pattern that they're not sure how to describe, so they just write the pattern.\n\nIn this particular case, I saw the pattern and thought it was interesting how straightforward it was to implement in C. I didn't write it because I needed to, or because I thought it was useful. I wrote it because I thought it was interesting.\n\nIf you're interested in a better way to do this in C, consider the following:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l + 1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.extend(1)\n\nThe point of this post is that the code was copy-pasted directly from the Django docs, not that the code is bad.\n\nThe point of the post is to show how to use the list() method in Python.\n\nYou don't need to repeat yourself.\n\nThe first answer is not at all wrong. There are a few other ways to do this too.\n\nNo, it's not a wrong answer. It is absolutely correct. The answer does not say that it is the only way.\n\nSomeone should have shown the power of itertools.count().\n\nActually, I think the first answer is very wrong. It is very slow and inefficient. If you actually want to count up a list, it is much more efficient to use:\nitertools.count(*iterable)\n\nTrue, but it's also more code.\n\nMore code is better code.\n\nPerhaps.\n\nIn this case it isn't.\n\nWhy?\n\nBecause you aren't actually counting anything. You are doing an O(n) operation n times.\n\nTrue. But it's faster.\n\nI don't", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return (l + 1).append(l)\nI would just use a list comprehension instead.\n\nYeah, but that would use a function with a silly name.\n\nIn a Haskell file, I'd write:\n\\s -> (s+1) :> map (+1) s\nand in a Python file, I'd write:\ns += 1\n\nIn Haskell, your function is a monad. In Python, your function is an expression.\n\nI don't see how the Haskell version is a monad.\n\n`map (+1)` is a monad.\n\n_If you\u2019re interested in how the function works, you should read this._\nThe article is a good explanation of how the code works, but the name is still a tad misleading.\n\nI'm kind of confused. I do a lot of \"list processing\" in python, but I don't do much in the way of list-specific things. What is this useful for? I'm not sure what I would need to increment the contents of a list (at least, not in a \"how I'd usually do it\" sort of way)\n\nIt's actually pretty useful. For", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.__add__(1)).__add__(1)\nTo be even more pedantic, it should probably be:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l+1\nThis makes me sad...", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[-1]+l[-2] for l in l]\n\nYou may be better off just using Python's \"list.append()\" method to append an element at the end of a list.\n\nWell, I am not going to argue with you.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.pop(1)) + list(l.pop(0))", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.pop(1)) + list(l.pop(0))\n\nThis is nice. I wish list.pop(0) returned the last element of a list, and list.pop(1) returned the first element of a list.\nI don't like the comma operator because it confuses people. The \"is it a tuple?\" question is a pain to deal with.\n\nThe thing about list.pop(0) returning the last element is that it can be implemented on lists which are not in order. In this case, you'd be left with a list that is not in order at all.\nI think it's important to keep in mind that Python is not a language for mathematicians. It's a language for programmers and it has to be useful for a large amount of programmers.\n\nInteresting, I hadn't thought about that. It's true, there are a lot of times where list.pop(0) is used to find the last element in a list. I guess it wouldn't be too hard to implement it as a call to list.end(n) in a way that would work if the list were not in order.\n\nI like the last", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l.pop() for l in l] + 1\nIn this case, you can just use 'l[:].pop()'.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.map(lambda x: x + 1))\nI always love it when the post is a good old-fashioned \"I can't be bothered to read documentation, so I'm just gonna ask the internet.\"\nYou've never had that? It's actually a good skill to have, you can then read documentation without doing any work.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    n = len(l)\n    n += 1\n    l.append(l[n])\n    return l\nIt would be good practice to write a function signature.\nI don't think you want to return a list, you want to return an integer.  In which case, you can write:       def incr_list(l: list):", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(map(lambda x: x + 1, l))\nAh yes, the famous function that somehow was taken out of the python stdlib. You'd have to look up why.\n\nPython is a pretty dynamic language in the sense that things often change. I had no idea this function was removed.\n\nVery interesting. I think the author's description of 'unhygienic' code is apt; it reminds me a bit of PHP in that respect.\n\nThe lack of a proper module system is what prevents it from being a good language. It is easy to use the language and it is easy to write unreadable un-maintainable code.\n\nI'm quite happy with the syntax, the idioms, the dynamic nature and the list and dictionary comprehensions. Everything is very readable. In fact, I see too much useless whitespace in my Python code that I should've removed.\nWhat I don't like is the use of the GIL, the fact that I can't use the C FFI to its full extent, the lack of a proper module system, and the lack of a good way to debug.\n\nI'm not sure what you mean by \"lack of", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [x + 1 for x in l]\nThat's a terrible implementation because it does not maintain order.  Should be something like:       def incr_list(l: list):            return list(l.pop, l.pop) + 1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.copy()\nThat's actually a pretty cool way to do it.\n\nWhy is it cool? I see the utility in it, but I'm not sure how it's cool.\n\nIt looks like a lot of things it might be useful for are a single statement, but the code is more concise. For example, suppose you wanted to output a list of primes that are divisible by three:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.index(1)+1)\nI don't really see how this is different from append.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0] * 1 for l in l]\nIt's a good exercise to write this using recursion and to compare the time/space complexity with the above.\n\nThat's a fun exercise, but it doesn't really shed any light on the difference.\nWhen I was trying to think of how to implement it in a pure python fashion I came up with this, which uses a set of while loops with nested indexing, but is still far more elegant than the solution in the OP:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    # We can't just call append() on an list since that changes the length\n    # of the list and our function should preserve the length of the list\n    #\n    # Instead, we create a new list using a single element of the list as the\n    # new list's first element\n    return [l[1:], l[2:] for l in l]\n\nThis is really hard to read. Not only because of the nested list comprehension syntax, but because of the unformatted code.\nI would recommend indenting the list comprehensions (it makes it clearer what's going on), and using a text formatter to format your code. I use PyCharm, and it's awesome. But there are also free text formatter tools like [1], [2], [3], [4], and [5].\n[2]\n\nThanks, I will do that.\n\nWhy not just use:\nreturn [ x for x in l if x % 2 == 0 ]\n\nHere is an example in python 2.7:\n>>> list = [1, 2, 3]\n>>> incr_list(list", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    new_l = []\n    for i in l:\n       if i not in new_l:\n          new_l.append(i)\n          i += 1\n    return new_l", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if list.__class__ is not Int:\n        return list\n    for i in range(len(list)):\n        list[i] = list[i+1] + 1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.pop(0).append(1)", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0], l[1], l[2],..., l[n], l[n+1]]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)\nWhy not append(2)?\n\nIn Python 2.5, append is now defined as \"append(x, y) = append(y, x)\". You'd need a \"l.append(x+1)\" in Python 2.6 and later.\n\nOr, I should say, if you want an empty list to be returned instead of the same list with incremented values, you'd need to use append(x+1).\n\nHeh, I used this a lot in my first Python script:\n>>> def incr(n):\n...            return n + 1\n...            >>> incr(4)\n5", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    # Upvote/Downvote or +1/+2/+3/+4/etc.\n    # upvote = [l[1] + 1, l[2] + 1,..., l[n] + 1]\n    # downvote = [l[1] - 1, l[2] - 1,..., l[n] - 1]\n    return l.append(upvote(l))", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)\nWell, yes, it's Pythonic in a way.\n\nYou can also do it with:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l+1\nThis is a good one because it's a good example of a function that's so simple that you might not even realize it should be written that way.\nIt should be noted that Python's list implementation uses an array internally. So in fact it is a while loop, with the condition being the length of the list.\nThe more elegant version would be:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    i = 0\n    while i < len(l):\n       l[i] += 1\n    i += 1\n    return l\nI think the documentation is inaccurate. This implementation does not properly handle lists of length zero.\nFor example, with a list like `[1, 2, 3]`, it prints \"4\". But with `[0, 0, 0, 0, 0]` it returns \"1\" because 0 + 1 = 1.\n\nGood catch, will fix.\n\nThis is a neat algorithm, but I'm not sure it's very efficient. I tried it on a list of numbers and it took about a second to complete the operation.\nI tried writing a version using a stack, and that was a lot faster (about a quarter of a second).\nIf the difference in time is due to Python, then this is a really nifty implementation.\n\nWhat I find most interesting about this implementation is that it uses a stack and does not do the 'increment by 1' in place, which is what I would have expected.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l[::-1]\nYour code has the same problem as the code you're complaining about.\nThe word you want is 'decr'.\n\nThank you for the correction. I'm new to Python and I don't know all the\nwords yet.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.copy()\nI don't like it. It's not obvious that incr_list() actually returns a new list, and also the fact that the new list isn't automatically assigned to a variable of the same name is annoying. If the list is not large (say, under 10 elements), it's easy enough to compute the new list manually, but for larger lists it becomes a nuisance.\nI'd prefer", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if l.head() > 1:\n       l.pop()\n    return [l[0]+1]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for i, l in enumerate(l):\n        if l[0] == i:\n            l[i] = l[i + 1]\n    return l\nThat's a bit easier to read.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(0)\nDid you forget to include `return`?</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0], l[1:] + 1, l[2:] + 1]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if len(l) < 2:\n        return l\n    return [i for i in l if i % 2 == 0] + l[i]\n\nWe just refactored incr_list() into incr_list_not_reduce() but kept the original incr_list() (and the tests, of course) so we can tell the future that we know what we're doing.\n\nCan I ask, if you're writing tests, why don't you use a doctest. It seems like it would be so much faster to write it out once and then be able to use it anywhere without typing it out again and again.\n\nUnless you want your tests to be part of your distribution, they shouldn't be part of your source code. I like using doctests, but I wouldn't want them all over my code.\n\nI love the idea of testing. I love the idea of having a suite of tests to run before committing. I think everyone should do it.\nI just don't know how to actually write tests.\nI have a few theories:\n1) I'm not good at writing tests.\n2) I", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l + 1\nI love Python. It's simple, it's readable, it's powerful. You can see how this function works in 5 seconds, you can read it in 5 seconds, and it does something useful in 5 seconds.\n\n\"Ruby would be better off with a DSL\" is a common argument that doesn't hold water.\nThe example code is a trivial operation on a trivial data structure. It is a great example of a function that is better off being a function rather than a DSL.\n\nI wasn't saying the incr_list() function was an example of a DSL, but rather that it's so trivial that you can see what it does very quickly without thinking.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if l.size == 1:\n        return l\n    else:\n        for e in l:\n           l[e] = l[e] + 1\n    return l\nIt's concise, but it's not idiomatic. The Python community values readability over conciseness. In this case, the Python community is in general agreement that the Python version is easier to read and understand.\n\nI would disagree. The Python version looks like a series of random function calls. The Ruby version looks like a series of statements.\n\nThe Ruby version is also a series of function calls.\n\nThis article reminds me of how I was on the fence about Ruby or Python a few years ago. I went with Python at that time, mostly because it was the default in Google App Engine.\nI have recently been learning Ruby on Rails and loving it. I really like the fact that I can type a bunch of lines of code in Sublime Text and compile it to a web app instantly. I use a free hosting service and don't have to worry about server administration at all.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [x + 1 for x in l]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.insert(0, 1)\n    @staticmethod\n    def incr_set(l: set):\n    \"\"\"Return set with elements incremented by 1.\n    >>> incr_set([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_set([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return l.insert(0, 1)\nI'd be a bit more verbose here, since it's an advanced technique.\n\nI'm pretty sure that the better way to do it would be to have a list of unique numbers and the number of times that it appears, and then sort the list by the number of times that it appears.\n\nThe original post is a bit out of date, but I can't find a better explanation of how to do this on the web.\nThe gist is that the idea is to increment the last element of the list. Then you can", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop() + 1)\nThat's not the same thing.  If the list is empty, the original one will still be empty.  If the list is empty, the original one will still have one element.  You didn't actually say whether your solution works for empty lists or not, but if it doesn't, it's not a good solution.\nYou're right, of course.  I meant to have it return [l.pop() + 1] but forgot to.  Fixed it now.  Thanks for the heads up</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l.pop() for l in l.pop() if l[0] < l[1]]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)\nAnother one:       def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3, 4, 5])\n    [2, 3, 4, 5, 6]\n    >>> incr_list([2, 3, 4, 5, 6, 7])\n    [2, 3, 4, 5, 6, 7, 8]\n    \"\"\"\n    return l.append(1)\n\nThat's the second time I've seen an example with a bug in the comments in this thread.\n\nThis is just one of the many, many reasons why I stopped using Python and haven't looked back.\n\nI've been using Python for about 3 years and never encountered this bug. The only reason I was aware of it was a post I saw here on HN a few days ago. I've also used Lua for about 3 years and never encountered a bug like this, nor have I seen any other bugs like this in any of the other languages I've used", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l + 1\nI always write this function. It is so useful. Also, it is easy to read.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    l.extend([i + 1 for i in range(l.length)] + [])\nI'm a fan of memoization too, but this is the wrong way to use it. The overhead of the function call is too big, and it's better to just cache the list in a variable.\n\nOr use the built-in Python array.__reduce__() method.\n\nWell, memoization is for when you expect a function to be called many times with the same argument.\nIn this case you only expect the function to be called once.\nUsing reduce is not an alternative to memoization, and is in fact not even the same thing.\n\nHere's the version of the function that runs in constant space:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.extend(1)\nIs this supposed to be a joke?</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l + 1)\nIn python 3.4:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l.__next__(0)] + 1\n\nI'm surprised no one else noticed this. I guess it's because the article isn't about Python?\n\nThe _next__ method is not the same as the __next__ method in the article.\n\nWhy would anyone write that? Are you ever going to need that functionality? It's one thing to do something like that for an example or tutorial, but there's no point to it in real code.\n\nYou're thinking too narrowly. It's not about writing a piece of real code that actually needs that functionality. The point of the article is that you should _always_ be aware of the features that you have at your disposal, even if you'll probably never need them.\n\nThe big problem is that I find myself always adding more and more methods to built-in collections because I want to extract parts of them (which is useful in a lot of cases). And when you have lots of custom methods, you end up with a huge mess.\n\nThe trick is to factor the built-in methods away into their own classes, rather than writing them inline in your own code. Then you can refactor the code with less risk, and", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l\n\nSo there's a one-liner to get the answer, but when I type it in I get the following message:\n\nTraceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n       print\n       File \"<stdin>\", line 2, in print\n       print(incr_list([1, 2, 3])\n       File \"<stdin>\", line 3, in incr_list\n       return l\n       File \"<stdin>\", line 2, in return\n       raise KeyError(\"incr_list() must return a list\")\n\nI don't know why this is, but I'm very confused, and would appreciate any help.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    count=0\n    for i in l:\n         if i>=1:\n             count += 1\n    return list(count)\nI wrote it like this when I was learning python. I wish the language would have allowed me to write something like this:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    list1 = []\n    for e in l:\n        list1.append(e+1)\n    return list1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    result = []\n    for i in l:\n        result.append(i)\n    return result\nThis doesn't work because of the possibility of duplicate elements.  This can be avoided by either mutating the list or using a list comprehension.  I'll leave it up to you to decide which is the more idiomatic approach.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for i in xrange(1, len(l)):\n        if l[i] == i:\n            l[i+1] = l[i] + 1\n    return l", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    def incr_list_no_reversed(l):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list_no_reversed([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list_no_reversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    >>> incr_list_no_reversed([5, 3, 2, 5, 3, 3, 5, 6, 0, 123])\n    [5, 4, 5, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    def incr_list_reversed(l):\n    \"\"\"Return list with elements reversed and incremented by 1.\n    >>> incr_list_reversed([1, 2, 3])\n    [2, 3, 1]\n    >>>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if len(l) < 2:\n       return l\n    return [l[0], l[1:] + 1]\nThanks for this.  I was confused that the original article didn't show the count and just treated it as a given.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(l.pop(1))\nThat's cheating!\nI guess if you used a non-consing append, it would be a little more fair.\n> def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n         return l.append(l.pop(1))\nTo me the only real problem with this is that it's over-concise.  There are a number of different ways to accomplish this, and I'm not sure that this is the best way.  So I would agree with the author of the article that the code is ugly.\n\nIt's fair game to use whatever techniques are available to implement the specified task.\n\nI'd say that in this case", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l + 1\nThis is great and I'm probably going to steal it for a personal project, but the syntax is a little awkward. Here's a similar function using an iterator:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    count = 0\n    for i in range(1, len(l)):\n        count += 1\n    return l + count\nI like this version much more, because I'm sure that I'll eventually end up doing something like:\n>>> incr_list([1, 2, 3], [4, 5, 6])\n[6, 7, 8]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if l[0] == 1:\n       return l\n    return list(l.append(1))\nI think it should be \"return list(l.pop(1))\" instead.\n\nIt's a good practice to use the idiomatic language, and python's idiomatic\nway to append is to use a list comprehension.\n\nI understand that. But l.append() is not the idiomatic way to append to a list.\n\nIn Python, the idiomatic way to append a single element to a list is by calling list.append(element).</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l] + 1\nIs that a syntax error?", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.pop(0).pop(1)", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [x]\nJust curious... are you aware of the builtin function list.append?  It does exactly what you want.\n\nIt's not exactly the same thing. For one, it's more efficient (with a list of length N, one incr_list requires O(N) space and N iterations, while append requires O(N) space and only N iterations). For two, if the elements of the list are numeric, then the result will be in numeric order, and if they're strings, then it will be in alphabetical order.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    list = [0]\n    for x in l:\n       if x == 0:\n          list[x] = 1\n    return list\nwhat is the use of this?\n\nI guess it's a recursive version of the \"product function\" you see in primary school.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    # Increment the first element\n    i = 1\n    # Increment all elements\n    for x in l:\n       x = x + 1\n    return l\n\nThe above is an inefficient way to do that:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(0)\nI'm amazed you even have to do that.  I can't even think of a use case where the original list isn't immediately needed.  Can you think of one?\nThe use case is to have a list of unique numbers.  It's a very common one.\nI'm not sure how that works, if you're just incrementing every number in a list you're going to end up with duplicates.\n\"List of unique numbers\" is ambiguous. If you mean the elements are unique, the whole list is unique. If you mean the list contains unique elements, you're probably using an array, not a list.\nSo you're saying that in Python, a list is an array?</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    def __init__(self):\n       self.count = 1\n    return self\n> type(incr_list)\n>         <class 'built-in'>\nNice. I've heard of this technique before, but I didn't realize you could actually do this in Python.\n\nThe correct answer to this problem is to re-write the whole thing in Ruby, and then to wonder why you're still writing Python.\n\n_The correct answer to this problem is to re-write the whole thing in Ruby, and then to wonder why you're still writing Python._\nI don't get it. What is the actual problem?\n\nThe actual problem is that there's a magical incr_list function that works on lists. I guess it's a core function, so you can't re-implement it.\n\nYeah, I see now. The first answer wasn't too clear, but I see what you mean now. Thanks.\n\nThe first answer is a joke. It's a reference to Paul Graham's, Why You Should (Probably) Use Lisp.\n\nI think if I were a Python programmer,", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.map(lambda x: x + 1)\nThis code is correct as far as it goes, but it's unlikely to be faster than Python's list.append, which is probably going to be more efficient than Python's map in this case.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0] + 1 for l in l]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l + 1)\nWow, this is even more hilarious if you think of it as:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    list = list.copy()\n    for i in range(1, len(list)):\n        list.append(i)\n    return list\nThis is useful only for lists that have the same element twice.\n\nOf course, that's not very much of a problem since you can easily get another list with the same elements using list.duplicate().\n\nDuplicate() is one of my favorite Python features.\n\nYou may find this interesting:\n\nHN, please give me a clue as to what's funny about that?\n\nThe code is not meant to be used. It's more of a joke than a real program. It was posted for a laugh.\n\nAh. Thanks. I guess I should've expected a link to a joke on HN.\n\nWhy would anyone write such a thing?\n\nbecause its funny and cute and clever and probably took all of 5 minutes to code.\n\nThat's not enough.\n\nI use  for this.\n\nI use the same thing. It's my favorite part of python.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return (l.extend(0, 1))", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    #1. Look for elements in the list that are smaller than 2\n    for i, _ in enumerate(l):\n        if i < 2:\n           l[i] = 1\n    return l\nI just tried this in my REPL and it does not work. Is there some flag or something that I need to enable?\n\nYou need to either install it through pip, or if you're using setuptools:\neasy_install list-increment\nI just uploaded a fix that should be up on PyPI soonish.\n\nThis seems to be a new API in Python 3.3:\n\nMaybe it's because I'm a bit new to Python, but I think I prefer it to the other method.\n\nI had the same thought, but then I realized that for large lists, there's a lot of overhead (time and space) to iterating through the list and incrementing every element.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0] + 1 for l in l]\n    def incr_list(l: list, n: int):\n    \"\"\"Return list with elements incremented by n.\n    >>> incr_list(['one', 'two'])\n    [2, 3]\n    >>> incr_list(['two', 'three'])\n    [3, 4]\n    >>> incr_list(['three', 'four'])\n    [4, 5]\n    >>> incr_list(['four', 'five'])\n    [5, 6]\n    >>> incr_list(['five','six'])\n    [6, 7]\n    >>> incr_list(['six','seven'])\n    [7, 8]\n    >>> incr_list(['seven', 'eight'])\n    [8, 9]\n    >>> incr_list(['eight', 'nine'])\n    [9, 10", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l + 1\nYou are forgetting that the list is already in sorted order. The example you give is the same as saying \"return l + l\".</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l).append(0)\n\nI think it should be (0, list(l)).append(0), but otherwise it's good.\n\nYou're right, of course.\n\nThe author has a number of other ones like this: \n\nGreat stuff, the examples are well thought out and very clear.\n\nThe tests are just as good:\n\nThose are very good.\n\nThis is a really nice teaching tool. I think it would be even more useful if the author had implemented a real version of it in C using a function like:\nincrement_list(list) {\nwhile( list[n]!= list[n+1]) {\nlist[n] = list[n+1] + 1;\n}\n}\n\nI don't see how this is any more useful than a loop.\n\nI would argue that it's less useful, as it's a bit more involved than a loop and is a little harder to read. It's certainly cleaner, though, and it might be a good tool for teaching.\n\nWell, there is a function for that:\n\nThat's what I was thinking. I guess the benefit of", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if l.len() > 1:\n        return l\n    return [l[0] + 1 for l in l.pop()]\nThe most elegant I've seen is a dict with a key and a value, where the key is the previous value + 1, and the value is the new value.\n>>> import collections\n>>> d = collections.namedtuple('dict', (k, v))\n>>> k = d.k + 1\n>>> v = d['k'].values[k] + 1\n>>> d['k'].append(v)\n>>> d['k'].append(v)\n>>> d['k'].append(v)\n>>> d['k'].append(v)\n>>> d['k'].append(v)\n>>> d['k'].append(v)\n>>> d['k'].append(v)\n>>> d['k'].append(v)\n>>> d['k'].append(v)\n>>> d['k'].append(v)\n>>> d['k'].append(v)\n>>> d['k'].append(v)\n>>>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.pop(0) + 1\n    def incr_list_range(start, end):\n    \"\"\"Return list with elements incremented by range of numbers.\n    >>> incr_list_range(0, 4)\n    [1, 2, 3, 4]\n    >>> incr_list_range(4, 9)\n    [4, 5, 6, 7, 8, 9, 10]\n    \"\"\"\n    return incr_list(range(start, end))\n\nNote that a lambda can only be passed to a function if it is a function. The function above returns a function (not an actual lambda).", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for i in range(1, l.size):\n        l.append(1)\n    return l", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    def incr_first(l: list):\n    \"\"\"Return first element of list incremented by 1.\n    >>> incr_first([1, 2, 3])\n    [2]\n    >>> incr_first([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6]\n    >>> incr_first([10, 1, 10, 1, 1, 10, 1, 10, 1])\n    [11]\n    \"\"\"\n\n(Line 3)  So if I have a list of tuples, then I can't do \"incr_first(my_list[0])\"?\n\nYou can do it, but you have to write a loop.\nThe difference is that it would be more readable to write something like:\nfor i, item in enumerate(my_list):\nitem += 1\n\nI am not sure it is more readable.\nMy_List = [ (1, \"item\"), (2, \"item\"), (3, \"item\"), (4, \"item\") ]\nfor i, item", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l]\nI prefer this version over the other one I've seen here (`[l].append(1)`).\n\nThe issue I have with this is that it's unclear whether it will add the items in-place or mutate the list.\n\nThat's why I prefer to use the Pythonic list-comprehension syntax.\n>>> [1,2,3] ++ [5,6,7]\n[2, 3, 4, 5, 6, 7]\n\nNot sure what you mean. If your list comprehension is\n[x for x in [1,2,3], x in [5,6,7]]\nthen you're mutating the list.\n\nWell, you're right, but the original function mutates the list in-place.\n\nI like it. I'm not sure that it's really any different than `map(lambda x: x + 1, [1,2,3])(3)` though.\n\nThe difference is that you can pass in a list of any type, not just a list of numbers.\n\nThat's really cool! I've been using python for a couple of years now", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l + 1\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n\nIs this a joke?\n\nIt looks like the OP is just learning python and doesn't understand the lists as the 'type of list' yet. I find that I often do the same thing when I am first learning a new language.\n\nIt could be a joke, but it could also be a legitimate example of someone trying to learn Python. For example, the programmer might be trying to learn Python for the first time, but have a lot of experience with other languages. The result would be a Python program that looks like a mishmash of other languages.\n\nI would have expected a joke submission to be a bit more funny.\n\nI actually found it pretty funny.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l+1\nI have two main problems with this:\n1\\. You aren't mutating the original list, so it's a bit of a misnomer.\n2\\. There's a lot of implied complexity. People new to Python are going to see that incr_list returns a new list and try to figure out why. The obvious answer is \"to make a list with the elements incremented by 1,\" but people tend to want to know why.\nI'm not sure what the right way to do this would be (and I don't think I'd ever want to use a function like this), but I think it would be better to create a new list using the original list as its basis, then mutate the original list based on the new list.\n\nIt's not a misnomer. The dictionary module returns a new dictionary, the list module returns a new list, etc.\n\nI don't use the dictionary module, but I believe it does make the original dictionary immutable. So if you add a new key/value pair to the original dictionary, you get a new dictionary back. The list module doesn't return a new list; it returns a new list with the same items as the", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[i-1], l[i], l[i+1]]\nNo.  It's not a list.  It's an immutable sequence.\nThe only way to make this correct is to use [l[i] for i in range(len(l))].  The code as posted, if it did work as intended, would have a (possibly silent) bug.\n\nIt works as intended, and it is a list. There is no bug. It does not work with arrays though, only lists.\n\nI think he means that it's not a list of lists, but a list of elements that are lists.\n\nThanks for the clarification.\n\n\"This is why we can't have nice things.\"\nYou don't need to go to the extreme of obfuscation. You could use a \"state\" object.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(list(l[1], l[2], l[3]))", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.append(1))\nIn your example, you get a list of the same size as the input, but with the elements increased by 1.\nYou want a list with elements increased by 1.\nI think you mean:\nreturn list(l.append(1) ** 2)</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    xs, ys = l.split()\n    return xs.reverse() + ys\nI think this is the simplest and most obvious solution.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if __name__ == '__main__':\n    l = range(10)\n    result = incr_list(l)", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    raise NotImplementedError('incr_list is not implemented')\n\nI'm not seeing the problem.\n\n<irony>That's because you don't understand the problem</irony>\n\nHeh, you're right. I don't know why I missed that. I guess I'm just as bad as the Python maintainers! ;)\n\n_Q: How can I find the last position in a list?_\nimport itertools", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l).append(1)\nI hate the way python is used in this blog post. Just typing \"def incr_list(l):\" would be enough to read.\n\nI agree. If you're using Python and expect people to be able to understand your code, then it's a good idea to follow the Python coding style. Also, it would be more readable to just type \"def incr_list(l):\" and then show the result, rather than typing out the entire function in a string literal and then showing the result.\n\nthe only reason why it's a string literal is because it's posted on HN. I assume the author of the blog post is reading this thread, and will hopefully modify it accordingly.\n\nThe author of this blog post should take a look at this post.\nThe blog post is full of unnecessary noise, like the \"showing code\" and the \"showing output\".\n\nI think the'showing output' is necessary because the blog post is about Python and not some other language, so the code may look strange to the reader.\nHowever, the'showing code' could probably be made much cleaner.\n\nThis is", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(map(lambda x: x + 1, l))\nAh, okay. The map method isn't part of the standard library; it's defined by the _ operator.\n\nNice! Reminds me of this:\n\nthis could have used some performance profiling and tuning\n\nGood point. I was trying to get this one out in a hurry.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    # Note that this is the definition of incr_list().\n    return l\n    \"\"\"\n    def a(x):\n       \"\"\"Return a list with a(x) applied to the elements.\"\"\"\n       return [x for x in x]\n    \"\"\"\n    def incr_a(l):\n       \"\"\"Return a list with elements incremented by 1.\"\"\"\n       return a(l)\n    \"\"\"\n\nIn some ways this is better than the original. The original generates a list where the first element is always equal to the first element of l. This returns a list where the first element is always equal to a(l). If l contains a list with the elements in the same order then the first element of the output list is the same as the first element of l. If the elements of l are not in the same order then the first element of the output list will be an iterable, which may or may not have the same elements.\n\nAn example of the first is given in the article:\n\n>>> l", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l[0] + 1 for l in l]\n\nThis is so obvious and simple, but I did not know this until today.\n\nWhile we're at it, here's a function I also learned today:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return []\n    def incr_tuple(tup: tuple):\n    \"\"\"Return tuple with elements incremented by 1.\n    >>> incr_tuple(('a', 'b', 'c'), ('a', 'b', 'c'), ('b', 'c', 'a')).\n    ('a', 'b', 'c', 'b', 'c', 'a')\n    >>> incr_tuple([1, 2, 3, 4],", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(range(l.start, l.end)+1)\nI feel like I've read this before.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.pop(0) + 1\n\nThere is also a builtin Python function called list.pop() that does the same thing:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n\nThis is one of my favourite tricks, but the most important part is missing.\nThis is only useful if you know that the input list is a certain type.\nIf you pass it a list of numbers, you will get back a list of numbers.\nIf you pass it a list of strings, you will get back a list of strings.\nIf you pass it a list of integers, you will get back a list of integers.\nThis is a very useful trick, and you can use it in a lot of places.\n\nI didn't realize it was missing - it was a simple solution to a specific problem. I'm not sure why you're being downvoted.\n\nI don't know either. Perhaps I didn't explain it well enough.\n\nI found this blog post about an interesting side-effect of the incr_list function to be interesting as well:\n\nThis is a more general solution to the problem: \n\nI like that it's a single line of code and is readable. The other solutions are more complicated.\n\nIf you use this with list comprehensions, you can write an iterative solution that is only 1 line. I've written a few of these, and they", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    l.append(0)\n    return l\nCan anyone tell me why this is better than just returning the list of the elements with a 1 in front?\n\nThe 'with' keyword is used to append to a list, not return one.\n'l.append(0)' is the same as 'l[:] = [0]'.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.pop(0) + 1\n\nIn Python 3 the built-in list comprehension is implemented using recursion, which is not trivial to make tail recursive.\n\nI think you're thinking of the for comprehension.\n\nThe code is pretty bad... I can't really comment on the code, but I feel I have to.\n\nIt's not the prettiest code, but I don't think it's bad. It's a pretty standard use of recursion. The code is pretty readable.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for i in range(len(l)):\n       if l[i] == 1:\n          l[i] = l[i] + 1\n    return l\nThis is a bad implementation of a list.  A list should never modify its own state.  A list should be immutable.  You should pass in a new list and append to it.\n\nThis is an implementation of a list that is not a list. It's an array.\n\nI'm not sure what the actual code he's using looks like, but the documentation for the built in list comprehension operator for Python lists, used to create the example here, does allow for this syntax.\n\nI'm not sure what the actual code he's using looks like, but the documentation for the built in list comprehension operator for Python lists, used to create the example here, does allow for this syntax.\n\nYes, the example he gave looks like it's using list comprehension, which allows this syntax.\n\nThis is not actually a list, it's a list comprehension.\n\nThat's what I thought too. It looks like list comprehensions are not what", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)\n    + l.pop()\nThis is actually valid JS.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    # Return list with elements incremented by 1.\n    return l\nDoesn't this fail on empty lists?</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [x for x in l if x % 1 == 0]", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [x[0]*1 for x in l]\n\nYou can use lzma.dictionary.LZMA.str_pad() to pad the values you store in a list with zeros.\n\nThis is why I always use the list[len(list)-1:] construction when I'm adding to a list.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return (l + 1)\nyou're missing the.\n\npython doesn't have.\n\nYes it does. \n\nThat is for iteration, not for the bitwise operator.\n\nNo, you can also use it as a bitwise operator.\n\nAnd you can use anything as a bitwise operator. That's the whole point of the article. But in python, the bitwise operators are not called. but rather ** and &. So you can't use. as a bitwise operator in python, even though you can in C.\n\nAh, I see. Sorry, I didn't really know what the original argument was and I was just pointing out that you _can_ use. as a bitwise operator in Python, even though it's not the usual convention.\n\nIt's fine. I learned the same thing a couple of weeks ago, I was surprised too.\n\nThe linked site is a great, fun resource, for example:\nhttp://www.python-guide.org/tut/\n\nVery cool! Also, I must have missed it before, but the \"Python Cheatsheet\" is great!\n\nMy favorite:\nhttp://www.python", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    def incr_lst(lst):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_lst([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_lst([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    if lst:\n       return lst\n    if lst[0] == 1:\n       return incr_lst(lst)\n    else:\n       lst = lst[0]\n    return incr_lst(lst)", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l[:] + 1", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    raise NotImplementedError\nI like this. I'd write the class definition as       def incr_list(l: list):", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.reverse()\n> >>> incr_list([1, 2, 3], reverse=True)\n[2, 3, 4]\n> >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123], reverse=True)\n[6, 4, 6, 3, 4, 4, 10, 1, 124]\n> >>> incr_list([]).reverse()\n[]\n\nSo this is a general-purpose version of the built-in list() method?</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    count = 0\n    for n in range(len(l) + 1):\n        count += 1\n    return l[0] + count\nIt does not handle a list with more than one element in the range.\n\nI did not see anything in the source code. I tested it on Python 2.7.3 and Python 3.5.2.\n\nI don't know what you mean by \"it does not handle a list with more than one element in the range\". I think you might be misunderstanding the meaning of the word \"range\". It's a little misleading in this case, as it refers to a list of numbers, but there's only one element in the list.\n\nI think this would be a good candidate for the simple questions thread.\n\nGood idea. I will post it there.\n\nYou can also use\nlist(l, [0, count])\nand it will also increment the count.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l[::-1] + 1\nI like this, but I find it interesting that it is named incr_list and not for_each_list or something.  (Also, I know that for_each_list is already a built-in, but I just wanted to point out that in this case it isn't a keyword, unlike for loops)\nYes, it is interesting, I hope python designers will make a better job in naming built-ins and functions.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    l.extend([0])\n    for i in xrange(1, l.size):\n        l.append(l[i+1])\n\nIt is idiomatic to use a one-liner to define a function that is one line. For example, in Perl one can write\nmy $x = 1;\nwhile ($x) { $x++; }", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [l] + [l] + [l] + [l] + [l] + [l] + [l] + [l] + [l] + [l]\n    def incr_append(a: list, b: list):\n    \"\"\"Return list with elements of b appended to a.\n    >>> incr_append([1, 2, 3], [4, 5, 6, 7])\n    [[1, 2, 3, 4, 5, 6, 7]\n    >>> incr_append([1, 2, 3, 4], [4, 5, 6, 7])\n    [[4, 5, 6, 7, 1, 2, 3]\n    >>> incr_append([5, 6, 7], [7, 8, 9])\n    [[7, 8, 9, 5, 6, 7]\n    >>> incr_append([5, 6, 7], [9, 0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14])", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if len(l) > 0:\n        return l\n    return [l[0]+1 for l in l]\nThat's a really nice one. I really like the logic behind it.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    def incr(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr([1, 2, 3, 4])\n    [2, 3, 4, 5]\n    >>> incr([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return [l[0] + 1 for l in l]\n\nUseful for Python 2.7.x (which has the same bug as Python 2.6.x regarding the arithmetical operations on list lengths)\n\nThis has been fixed in Python 3.\n\nI know, but I was referring to the time when the bug was introduced (2.6.x)\n\nI'm aware of that, I'm just giving some context on why I added it to this post :)\n\nWas this bug ever fixed?\n\nPEP 3107 was accepted and will be in Python 3.4</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return [i for i in list if i > 0 else i]\nIs there any use case where this is more efficient than the list comprehension? I'm struggling to think of one.\nI can't think of a use case where it would be more efficient either, but it is certainly more readable in many cases.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(1 + l.pop(0))\nThis works for me.  I'm using Python 3.3.0\nI've got Python 2.7.13, and it doesn't work for me.\nI tried with 2.7.14 and I still got the same result.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l[:list.len()]\n\nI've been using this for a long time:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    \"\"\"\n    def incr(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr([]).append(1)\n    [1]\n    >>> incr([3, 4, 5]).append(2)\n    [3, 4, 6]\n    \"\"\"\n    return l.append(incr(l))\n\nIncidentally, if you need to do this without the efficiency penalty, you can use list comprehensions. In Python 3:\n>>> l = [1, 2, 3] >>> incr_list(l) [2, 3, 4]\nAnd in Python 2:\n>>> l = [1, 2, 3] >>> list(incr_list(l)) [2, 3, 4]\n\nIf you're having trouble with Python, just use a C++ solution. It's not hard and you will learn a lot:\nhttp://sourceforge.net/projects/cloc/\n\nI'm not sure I'm seeing the use case for this. It might be nice to have, but it seems like the equivalent", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for item in l:\n       item += 1\n    return l\nNote that `l` is a list and `item` is a python object. This doesn't work as expected for lists like the one in your example.\nThis is why you should use the built in `list` type.\n>>> [1,2,3,4,5,6,7]\n[1,2,3,4,5,6,7]\n>>> [1,2,3,4,5,6,7]\n[1,2,3,4,5,6,7,8,9]\n>>> [1,2,3,4,5,6,7]\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]\n>>> [1,2,3,4,5,6,7]\n[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    result = []\n    for i in range(len(l)):\n        result.append(l[i])\n    return result", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return []\nI think you're missing a line in there, what does incr_list([1, 2, 3]) produce?\n(Not disagreeing, just want to make sure I've got it right)\n\nThanks, I just added it.\n\nI thought that this one was interesting:", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for n in l:\n        if n > 0:\n            return [n+1]\n    return l\nI don't understand why you would choose to increment the elements in an O(n) list instead of creating a new list in O(1) time.\nThe function is also non-explicit; it would be nice to add a docstring so you can actually see what the function does without having to run it.\n\nActually, you are creating an O(n) list by iterating through l and adding 1 to all elements. There is no O(1) list. It's just the way you present it.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.pop(1))\nI would use a \"lambda\" function that takes a list and returns a list of the same length, then you can do this:      l = [1, 2, 3]      l2 = lambda l: l + 1      l3 = lambda l: l + 1      l4 = lambda l: l + 1      print l      print l2      print l3      print l4  EDIT: formatting\nhow would i use that? i'm a beginner\nI'm also a beginner. But I would say you have to write a function to do that. I can't say what the function should look like, I'm not so experienced in programming. Google is your friend, maybe there is a function named l2 or l3 that does the job already.\nok thank you. i really appreciate you trying to help me out\nYou are welcome. That's why we are here.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.append(1))\nThis function just appends a 1 to the beginning of every element.\nThe article was written in response to this Stack Overflow question.\n\nI don't get it. Why would you ever want to do this?\n\nYou wouldn't. It was an exercise in seeing how far you could go with a single line of code.\n\nAha.\nI could see that being the exercise, but the article seemed to make it seem like it was a useful one.\n\nI liked the way the author described it.\n\nWhat's the '==' in the last line for?\n\ni think it's just a typo.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return list(l.append(1))\nThis just seems like a wrapper for `list.append(1)`. The whole point of the post is to use recursion, so why not just use the recursive form?", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return (l + 1) + list(range(l.size()))\nOr you could use itertools.count()\nOr you could use python.   `if __name__ == \"__main__\":`", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)\nI don't understand why is this upvoted. It's not very pythonic.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.extend(1)\nYay for Python!\nPython is awesome, and that's a very useful function. In fact, I have it bound to F9 in Sublime Text.\nYou should try it with the Python console. Type >>> and start typing your function name.\nI wish it worked for self.</s>", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l.append(1)\n\nI didn't want to include a comment when I posted this, but this is meant to be for people who find themselves writing a nested for loop. I'm sure a few people will argue that there are cases where a for loop is a good idea, but for 99% of the cases I find myself writing a nested for loop, I can just do this.\n\nThis is the most awesome thing ever, I've always used nested for loops.\n\nI have to agree, but I would make an addition:\nfunction incr_list(l):\nl.append(1)\nreturn l\nI think that's a little clearer and more succinct, but it's purely a matter of preference.\n\nI agree, that's probably a better way to write it.\n\nI'm surprised nobody's mentioned the Stroustrup quote:\n\"In a language that supports tail-call optimization, the most common idiom in loops is a simple function call:\nfor i in range(n):\nfoo(i)\n[...]\nFunction calls are the most important feature of any language.\"\n\nI find this to be true. Of course, this means that", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    if l.count() > 1:\n       return [l[0], l[1:] + 1]\nIs this meant to return the same list?\n\nThe code is incomplete. The original author had a [2] in there.\n\nIt's also completely broken. The list might have one element, or it might have zero.\n\nHence, the title: \"The worst Python code I've ever seen\".\n\nHahaha, I've seen worse, but I did chuckle at that one.\n\nMy personal worst code has only one file, but it's 2000 lines long. All I can say is: good riddance! I've never been happier to see a file deleted.\n\nWas it _that_ bad? What did it do?\n\nIt was a poorly designed visual programming environment for the TI-83 calculator. It had some terrible design decisions, like nesting functions in arrays, which made it very hard to refactor (and thus, very difficult to debug). It also had a lot of unnecessary abstractions and some utterly ridiculous design decisions.\n\nDoes anyone have a translation of the original (presumably broken) code?\n\nThere are", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    for i,v in enumerate(l):\n        i = i+1\n        v = v+1\n    return v\n> This is a more idiomatic implementation, but I prefer the above.", "def incr_list(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list([1, 2, 3])\n    [2, 3, 4]\n    >>> incr_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\" \"\"\"\n    return l + 1\n    # source: https://github.com/sharkdp/Learn-Python-the-Hard-Way/blob/master/scripts/basic/increment.py"]]