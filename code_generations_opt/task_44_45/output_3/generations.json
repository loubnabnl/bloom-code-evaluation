[["def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    print(base)\n    for i in range(0, 10):\n        x = round(x, i)\n        if base == i:\n           return '0' + str(x)\n    else:\n           return '0' + str(base * x)\n\ni like the idea, but why does it have to be less than 10?</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return x * base\nWow, that's pretty easy.  Thanks.  I was having trouble because I was trying to use the math module to do it.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    print \"Change_Base:\", change_base(8, 2)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x >= 0:\n        return (base * x)\n    return x\nThat's clever. Do you know how the algorithm works?\nI was able to work it out. You need to reverse the digits in the original number, and then figure out which digits are in the new base by looking at the new position of the first digit. (If it's in the position of the first digit in the old base, that digit is in the new base.)  It's not an entirely trivial algorithm to write, but it's not that hard.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x == 0:\n       raise ValueError(\"Input number must be non-zero\")\n    else:\n       return base\n\nI don't understand the need for such an operation, but I'm sure it's pretty obscure.\n\nIt's pretty simple, I think. Given:\nBaseCode", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\nI was curious and just ran this on some real numbers.\n>>> change_base(3.14159265358979323846264338327950288,2)\n'7'\n>>> change_base(3.14159265358979323846264338327950288,3)\n'14'\n>>> change_base(3.14159265358979323846264338327950288,5)\n'77'\n>>> change_base(3.14159265358979323846264338327950288,6)\n'5'\n>>> change_base(3.14159265358979323846264338327950288,7)\n'17'\n>>> change_base(3.14159265358979323846264338327950288,9)\n'27'\n>>> change_base(3.14159265358979323846264338327950288,10)\n'34'\n>>> change_base(3.14159265358979323846264338327950288,11)\n'77'\n>>> change_base(3.14159", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    print(\"Base: %d\", base)\n    # parse the number\n    # I think it would be faster to use 'int(input())'\n    n = input(\"enter your number: \")\n    try:\n       n = int(n)\n       return string.format(change_base, n, base)\n    except ValueError as e:\n       print(\"ValueError: \" + str(e))\n    print(\"Invalid input\")\n\n[code]\n>>> change_base(8, 3)\nBase: 2\n>>> change_base(8, 2)\nBase: 1000\n>>> change_base(7, 2)\nBase: 111\n>>> change_base(8, 3)\nValueError: invalid input\n\n[/code]\n\nI get \"ValueError: invalid input\"\n\nWell, the question is what your input is. You did not specify that.\nThe try/except block will always catch the \"Invalid input\".\nYou need to change the if-statement from", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\n    def __init__(self, base, **kwargs):\n        self.base = base\n        self.kwargs = kwargs\n\n    def to_string(self):\n        return string(self.base)\n\nThis is almost the same solution as yours, but it does not work with negative bases.", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return base**(x**base)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\n    def to_number(x: string):\n    \"\"\"Convert string x to a number.\n    \"\"\"\n\n    return int(x)\n\n    def is_base(x: int):\n    \"\"\"Check if x is a base number.\n    \"\"\"\n\n    return x < 10\n\n    def to_string(number: int):\n    \"\"\"Return string representation of number.\n    \"\"\"\n\n    return number.to_string\n\n    @classmethod\n    def from_string(s: string):\n    \"\"\"Convert a string s to a number.\n    \"\"\"\n\n    base = to_number(s)\n    return number.to_string(base)\n\nDependencies\n\nNone\n\nExample\n\n>>> import math\n>>> math.fmod(8, 3)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if base == 1:\n        return '1'\n    else:\n        return str(base) + '\n    return x\nThis is great! Thanks!\n\nThere's also x in base:\n>>> x = change_base(8, 10)\n>>> x\n'10000'</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    string_of_int = int.__format__(\"%02d\", x)\n    return string_of_int.upper()", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x == 0:\n        print(\"Cannot change zero to base\")\n    return \"\"\n    base = int(x)\n    if x == 10:\n        base = 2\n    if x == 11:\n        base = 4\n    if x == 12:\n        base = 8\n    if x == 13:\n        base = 16\n    else:\n        base = base * 2\n    return base", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n         return int(x)\nThis is a very primitive implementation.  In Java, for example, you\nwould return Object.toString(x).  The object returned by\n\"change_base\" would probably have to be of a type that can represent\nthe number in base 10 as well as the base you are converting to, e.g.\na Decimal type.\nThis function is normally called only from a user's code, so it would\nbe nice if it could be written as a generic function and not have to\nbe defined for each base number.  E.g.", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    print(base, x)\n    try:\n       base = int(x / base)\n       except ValueError:\n       print(\"invalid number\")\n    return base + '0' + x[:-1]\n\nOne of the other answers, that \"print()\" was unnecessary, is incorrect.\nThe use of \"print()\" is necessary to ensure that the result of the function is displayed. If one _does not_ use \"print()\", the result will not be displayed.\nIf \"print()\" is removed, the result of the function will _not_ be displayed.\n\nWhat is the benefit of displaying the result?\n\nThere is no benefit. But it shows you have a working solution.\n\nI was going to say \"some people like to write their solutions in a \"write-only\" fashion\", but I think that's actually an even worse reason.\n\nI would expect in many companies if you were to write that as a solution to a programming problem then there would be a good chance the code would be rejected as incorrect because it has a \"print\" statement in", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\n    def base_decimal(digit: int):\n    \"\"\"Decimal representation of base number.\n    return string representation after the conversion.\n    >>> base_decimal(3)\n    '3'\n    >>> base_decimal(2)\n    '2'\n    >>> base_decimal(1)\n    '1'\n    \"\"\"\n\n    return '', base_decimal(x)\n\nIn other words,\nchange_base(8, 3) = '22'\nchange_base(8, 2) = '1000'\nchange_base(7, 2) = '111'\nchange_base(8, 1) = '1000'\nchange_base(8, 0) = '0'\nchange_base(7, 0) = '000'\nchange_base(8, -1) = '-1'\nchange_base(7, -1) = '111'\nchange_base(8, -2) = '-1000'\nchange_base(7, -2) = '111'", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    def change_base(x, base):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n    return ''.join([x**2 for x in x**2 for x in x**2 for x in x**2 for x in x**2 for x in x**2])\n       def add_numbers(x: int, y: int):\n    \"\"\"Add x and y. Return result of addition.\n    >>> add_numbers(8, 2)\n    12\n    >>> add_numbers(8, 10)\n    18\n    >>> add_numbers(8, 2)\n    16\n    >>>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    raise NotImplementedError\n\nYeah, and then it gets changed to:", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\nfrom decimal import Decimal, from decimal import float_to_decimal\n\nfrom itertools import cycle, nth, itertools\n\nfrom functools import partial\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *\n\nfrom operator import *", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return base ** int(x)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    # Get the number as a string.\n    s = '\\n' + x\n    print s\n    # Convert the number to base 10.\n    base = int(x) - int(x, 10)\n    s = s + str(base)\n    print s\n    # Return the string after the conversion.\n    return s", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\n    return str(x + base)\n\n    def exp(x: int):\n    \"\"\"Return the exponent of number x.\n    return x + base * x\n    \"\"\"\n\n    return change_base(x, 10)\n\n    def log(x: int):\n    \"\"\"Return the logarithm of number x.\n    return x / base\n    \"\"\"\n\n    return change_base(x, 10)\n\n    def power(x: int):\n    \"\"\"Return the power of number x.\n    return x ** base\n    \"\"\"\n\n    return change_base(x, 10)\n\nCan't you do all that with three lines of code?</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x < 0:\n        raise ValueError(\"Negative base number\")\n    if base < 0:\n        raise ValueError(\"Invalid base number\")\n    return \"x\\%s\\n\" % (str(x) / (base * 10))\nIt's missing a return statement.\nGood catch. Thanks.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x > base:\n        return x\n    base = int(x)\n    x = int(base*10)\n    return x\n\n>>> change_base(7,2)\n'111'\n\nThis is how I would write it", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x < base:\n        raise TypeError(\"Input must be greater than 0\")\n    x = int(x)\n    return \"x\" + base + \" \" + x\n\nReferences</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x < base:\n        return \"0\"\n    x = int(x)\n    return x.decode(\"hex\") + \"\\n\" + x.decode(\"oct\")\n    + \"\\n\" + x.decode(\"dec\")", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    def to_string(base: int):\n    \"\"\"Return a string representation of input number base.\n    >>> to_string(2)\n    'two'\n    >>> to_string(10)\n    'ten'\n    \"\"\"\n    return '0' + to_string(base)\nYou should put a docstring.\n\nIt's not mine, it's just a function I found in some library. The point was just to show that it works.\n\nYou can't do this.\n>>> x = 8 >>> change_base(x, 3) Traceback (most recent call last):\nFile \"\", line 1, in <module>\nTypeError:'str' object does not support item assignment >>>\n\nThis is a copy paste from a library I found on the internet. I wasn't able to run it in my machine.\n\nIt's a function from _Mathematics for the Impatient_ by Silvanus P. Thompson, Michael Starbird, and Edward Z. Yang.\n\nOk, so I'll remove the post. Thanks for the information.\n\nNot your fault", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    base = int(input(\"Base?\"))\n    if base < 0:\n        return \"\", base\n        base = int(input(\"Base?\"))\n    if input(\"Base?\"):\n        return \"\", base\n        x = int(input(\"x\")))\n        base = int(input(\"Base?\"))\n    if base < 0:\n        return \"\", base\n        print(\"Input number: \" + str(x))\n        base = int(input(\"Base?\"))\n    if base < 0:\n        return \"\", base\n        x = int(input(\"x\")))\n        base = int(input(\"Base?\"))\n    return repr(x) + \":\" + str(base)\n\nTo me, this is a perfectly acceptable way to express the concept and is both readable and", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    # Base of x\n    # Is x a number?\n    if x > 0:\n        return string(x)\n    elif x <= 0:\n        return None\n    else:\n        raise ValueError('Number must be positive')\n\nReferences</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return (base * x) + '0'", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return \"\".join([int(x) if x < base else x])\n\nAs others have mentioned, you can also just use the int() function.\n\nI was going to say that, too, but the article shows how to do it with a function, so I thought I'd show how to do it with a function.\n\nOne can also use the Python format module[1] (via __format__) to do this easily.\n1\\.\n\nI guess you can also just use the integer() function.\n\nThe point is to do it \"without using built-in functions\".\n\nWhat's the point of that? You can easily do that with int(), without changing base.\n\nSome people, like myself, like to understand what is happening under the hood.\n\nUnder the hood? You just do int(x) or whatever your base is. What's under the hood?\n\nThe article shows how to do it without using built-in functions. It shows how to use functions to do the same thing as using built-in functions, but in a way that you can understand what is happening without having to do a lot of research.\n\nIt doesn't show me", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    def __repr__(self):\n    \"\"\"Return representation of the given number in base.\n    If the number is not a valid base number it will be converted to\n    a string of digits with the base number being the final digit.\n    >>> change_base(10, 3)\n    '100'\n    >>> change_base(10, 2)\n    '10000'\n    >>> change_base(5, 2)\n    '5'\n    \"\"\"\n    return '%s' % base + 'd' % (self % base) + 'e' % (self % base)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\nThe problem here is that it is not clear that it returns the string representation. If I only see the function for a second, I could be tempted to think it returns a number.\n\nHowever, if you read the documentation, you would know that the function returns a string. I guess we cannot document everything, but there are cases where documentation is important, such as the example I mentioned.\n\nI'm not saying that it's a bad function, because it is not. I'm just saying that it can be improved upon.\n\nFirst, I would change the name from change_base to convert_base.\n\nSecond, I would change the return type to string.\n\nThird, I would create a docstring.\n\nfourth, I would change the code so that the result is not a number:", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if base < 10:\n        return str(x)\n    else:\n        return ''.join(map(int, int, str(x)))\n   \nIn your case you're trying to convert from the smallest to the largest base.\nYou can change it to convert from largest to smallest.   But then you have to consider the possibility of not being able to convert to a smaller base.   Is that acceptable?\nIf not, you can change your algorithm to use a lookup table.  But the lookup table will need to be sorted.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\n    @return string representation of input number after the conversion\n    @throws TypeError\n    def get_value(base: int, x: int):\n    \"\"\"Return base * input number as string.\n    return string representation of input number.\n    >>> get_value(3, change_base(8, 2))\n    '22'\n    >>> get_value(4, change_base(10, 2))\n    '1000'\n    >>> get_value(3, change_base(3, 2))\n    '111'\n    \"\"\"\n\n    @return string representation of input number\n    @throws TypeError\n    def to_base(x: int):\n    \"\"\"Return base * input number as string.\n    return string representation of input number.\n    >>> to_base(3, change_base(10, 2))\n    '11'\n    >>> to_base(4, change_base(3, 2))\n    '3333'", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    x = int(input('Change base to %d?', x))\n    return ''.join(str(int(x) * int(base)))\n\nNice.\nBut the empty function doesn't look like it will be run. You would have to save the function, then run it, or add it to the command line (where you run it) and pass it the input.\nEdit: I know I could make it a function of the command line, but I'm not sure that's what OP wanted.\n\nThe commandline would be used by this script as a library of functions for testing out and debugging, so I think it fits perfectly.\n\nI used to use this trick in Powershell. It's great for learning.\n\nI like the idea of writing a script in an interactive shell. I started a project to do this, though not exactly like this.\n\nI use bash and put together a script. It is actually a test script of sorts.\n\nI'm a big fan of the {command} && {command} trick. It's pretty well-known, but I always get a kick out of it.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return int(x) + '0'\n>return int(x) + '0'  That's not a string\n> return int(x) + '0'  That's not a string\n>return int(x) + '0'  That's not a string\n> return int(x) + '0'  That's not a string\n> return int(x) + '0'  That's not a string\n> return int(x) + '0'  That's not a string\n> return int(x) + '0'  That's not a string\n> return int(x) + '0'  That's not a string\n> return int(x) + '0'  That's not a string\n> return int(x) + '0'  That's not a string\n> return int(x) + '0'  That's not a string\n> return int(x) + '0'  That's not a string\n> return int(x) + '0'  That's not a string\n> return int(x) + '0'  That's not a string\n> return int(", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x is None:\n       return ''\n    base = int(x)\n    if base is None:\n       base = base(None)\n    return base\n\nNote that the author says in the last line of the example that it's not a very useful module.\n\nI used this module to learn Python and to experiment with generators and iterators.\n\nJust use Python's built in itertools.count?</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return int(str(x) + str(base))", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    a, b = x\n    if a < b:\n       return base\n    elif b < a:\n       return b\n    elif a > b:\n       return a\n    else:\n       return '0'\n\nYou can use `float(x)`.\n\nDoesn't work for negative numbers.\n\nGood catch!\n\nSo I tried it out.\nIt is not as simple as I thought it would be.\nIn Python, you can have numbers which represent strings.\n>>> 'a' + 2\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: unsupported operand type(s) for +:'str' and 'int'\n>> 'a' + 2\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: unsupported operand type(s) for +:'str' and 'int'\n>>> \"abc\" + 2\nTraceback", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    print('Enter a base number: ')\n    print(int(x))\n    print('Now enter a number to convert to:')\n    print(int(x))\n    print('Enter the new string representation: ')\n    print(x)\n    print('Base changed to'+ base)\n    print('New string representation is:'+ x)\n\nimport re", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x < base:\n        return '0'\n    else:\n        return x\nI think you meant \"else:\".</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n    print(x)\n    return \" \" * (base * x - base)\nI would not write a function like that, because I would not be writing code like that.\n\nYou should write code like that.\nIn a few years you will be thankful you did.\n\nNo, I will not. The most important thing is not doing something stupid in the first place.\n\nFrom the article:\n\"\"\"\nThe intent of this exercise is not to convince you to immediately switch from int to str. The intention is to convince you to try to use different data types to express the same idea. You may discover that some", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x > 0:\n        return '0'\n    base = int(x / base)\n    return '%d' % base\n\nAs a Python programmer, this bothers me. It feels as though the function should return a string with the result of the conversion. I'd feel more at ease if it returned '3' for 3, '22' for 8, '1000' for 8/3, etc.\n\nIsn't that what it's doing?\n\nThere are two separate expressions in the function. The first one is\nreturn '0'\nwhich returns 0 for a nonzero x. The second expression is\nreturn '%d' % base\nwhich returns the number from x/base.\n\nI was looking at the statement \"return '%d' % base\" in isolation.\n\nAh, yes. I see now.\n\nThis was my first thought as well. Then I thought, maybe the idea is that you can define your own custom base, and then return a string in that base, so that it doesn't return 0 or a decimal number. Then I noticed that the author of the post is also the author", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    print(\"Base: %s\", base)\n    n = int(input(\"Enter a base in the range 1 to \"))\n    for i in range(10):\n       if n % i == 0:\n          i = i*10\n         if n % i == 0:\n           i = i*100\n          if n % i == 0:\n           i = i*1000\n          if n % i == 0:\n           i = i*10000\n          if n % i == 0:\n           i = i*100000\n          if n % i == 0:\n           i = i*1000000\n          if n % i == 0:", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if base <= 0:\n        raise ValueError(\"Changing base to negative numbers is not allowed\")\n    x = int(input(\"Enter the base: \"))\n    return input(\"Enter the number: \").decode('hex').encode('decimal')", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    x = str(x)\n    base = int(x, 2)\n    return str(x) + \" \" + str(base)\nAlso, instead of changing the base, you could just change the number to base 10, and see if the user is happy with that.\n\nGood point. I guess I had it in my mind that a lot of places have a \"default\" base of ten. My guess was that if base of ten is chosen, then the conversion would be redundant, but I can see that if you want to have base 8 to start with, then you wouldn't want to convert to base 10.\n\nIt also means that if you want to do the conversion to e.g. base 16, you have to do it twice.\n\nThis seems a little weird to me. You're changing the order of base 10, but it's not clear that it's actually changing the number. I would think that the code would need some sort of check to make sure that it doesn't attempt to convert a number to a larger base (i.e. the number in base 10 must be between 0 and 9).\n\nThat is a good point. The original implementation", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\n    \"\"\"\n    if base <= 1 and x > 1:\n        raise TypeError, \"Input number is too large.\"\n\n    return str(int(x))\n\nThis is almost exactly what I was looking for, but it doesn't handle the case where the input number is equal to the new base.\nFor example, \"change_base(2, 2)\" gives a TypeError.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x < 10:\n       return string representation after the conversion\n    else:\n       return \"no base found for number x\"\nIf the string representation is already a valid number, it will get corrupted.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    base = int(input(\"Enter the base number: \"))\n    return str(input(\"Enter the input number: \"))\n\nI think that \"base\" should be a list of integers, not a single integer.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    # -*- coding: utf-8 -*-\n    \"\"\"from decimal import Decimal as D\n    D(8, D('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'))\n    D(D('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'))\n    \"\"\"\n    return D(D('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', '", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return str(x, base, \"%d\" % x)\nI like how it's implemented, but would have like to see a few more examples.\n\nThe \"examples\" are a bit of a contrived example.\nYou can do the same thing with `str(x)`\n\nYou would have to cast it to an int to do that. You might as well write your own function then.\n\nI'm curious to know if it's legal to write a Python interpreter that just executes Python code?\n\nNo, there are many restrictions to make it a valid Python interpreter:\n* The source must be interpreted (not compiled).\n* The source must be bytecode.\n* The source must be Unicode.\n* The source must have whitespace (not comments).\n* The source must have variable and function names.\n* The source must have comments.\n* The source must have indentation.\n* The source must have comment syntax (but not indentation).\n* The source must have class declarations.\n* The source must have unicode strings.\n* The source must have a __name__() method.\n* The source must have an __init__() method.", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\n    def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n\n        return x", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    # Change the base for input number x.\n    if x < 0:\n        raise ValueError(\"input cannot be negative\")\n    else:\n        # Output the base and the string representation of the\n    # input number.\n        print(\"Base: %s\" % base)\n        print(\"String: %s\" % input_string)\n        return input_string", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return ''.join([x * x + '0' for x in xrange(base)]\n    + '0')\n\nI love this, but I've always wondered if there's a better solution.\nI'm never quite sure what the best way is to solve these kinds of problems, but as far as I can tell, this is O(n^2) (at least for the simpler cases where the base is less than 10).\nOn the other hand, it only requires one line of code.\n\nI think it's a great one-liner solution to the problem.\nAnd yes, it is O(n^2). It's more than twice the length of the original number.\n\nI've always wondered about the ratio of time it takes to write the code to time it takes to run the code.\nThis seems like a prime example of code-writing-time:running-time ratio being out of wack.\n\nI once looked at some code like this, in a very complex module that was under active development, and being used in production, for a few years. When I looked at it, I couldn't figure out how it could possibly work.\nTurns", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    \"\"\"Convert number x to string representation in base number base.\n    base numbers are less than 10.\n    >>> change_base(8, 2)\n    '1000'\n    \"\"\"\n    return \"0\" + str(int(x))", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    'base numbers are less than 10'\n    This is a hard requirement. A base of 0 is not a base of 10.\n    >>> change_base(7, 0)\n    Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    ValueError: Zero is not a valid base for base 10\n    >>> change_base(0, 10)\n    Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    ValueError: Zero is not a valid base for base 10\n\nI don't think your proposal is going to work.\n\nI agree, but I think it is a good start to a discussion.\n\nI'm not sure what the purpose is. Does Python have a practical need for something like this? I can't think of one.\n\nI don't think so. I just saw an opportunity to improve my Python skills by learning a new concept.\n\nI had a similar idea for a language, but it was less specific. I wanted to allow a more generic", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\n    if not x < base:\n        return \"\"\n    x = int(x)\n    return ''.join(int(x) / base) +''\n\nIf x is already an integer, the call to int() will convert it to a long integer, and then that long integer will be converted to a string, so this function will use twice as much memory as necessary.\n\nTo fix this:", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\n    print 'the first number is {0} and the second is {1}.'\n    for i in range(0, len(x)):\n        print x[i], x[i]\n    print 'the conversion is {0} to {1}.'.format(i, change_base(i, x[i], base))</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return x.encode('hex')[:base]\nSo the way I see it, the following will break:\n>>> from decimal import *\n>>> from itertools import islice, islice_over, islice_range\n>>> from functools import wraps\n>>> a = [1,2,3,4,5,6,7,8,9]\n>>> b = [0,1,2,3,4,5,6,7,8,9]\n>>> c = [0,1,2,3,4,5,6,7,8,9]\n>>> d = [0,1,2,3,4,5,6,7,8,9]\n>>> e = [0,1,2,3,4,5,6,7,8,9]\n>>> f = [0,1,2,3,4,5,6,7,8,9]\n>>> g = [0,1,2,3,4,5,6,7,8,9]\n>>> h = [0,1,2,3,4,5,6", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return base * x + '0'", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    int change_base_to_base(base: int)\n    if base < 10:\n        return base\n    else:\n        return change_base(base, base+1)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    def int_to_string(x: int):\n    \"\"\"Return string representation of x.\n    >>> print int_to_string(4)\n    4\n    >>> int_to_string(2)\n    '2'\n    >>> int_to_string(0)\n    Traceback (most recent call last):\n    File \"\", line 1, in?\n    TypeError: object 'int' has no attribute '__str__'\n    >>>\n    return '0' if x > 0 else '-' + int(x) +''", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    print 'base:', base\n    print x\n    return ''.join(str(x) + str(base))", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    '8' '3' '2' '7' '2'", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    \"\"\"\n    return \"\".join(str(x).replace(\" \", \"\").replace(\".\")", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return x\n\n>>> change_base(3, 2)\n'22'\n>>> change_base(2, 3)\n'1000'\n>>> change_base(7, 2)\n'111'</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    x = x.to_base(base)\n    return x.to_string()\n\nOr as a function in Python 3:", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return re.sub(r\"^[0-9]{3}\", x, \"base\")\nis that actually correct?\nshouldn't it be returning the string representation of the number with the _decimal_ part replaced with \"base\" so like \"123\" instead of \"12\"?\nthat's what I'd expect from a'string representation' of a number.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x >= base:\n       raise ValueError, \"Incorrect base number\"\n    return \"\".join(int(str(x)) for x in range(base+1))", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    result = \"\"\n    while x > 0:\n       result += (x%base) * string.decimal(base)\n    x = x / base\n    return result", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\n[docs]class change_base(object):\n    \"\"\"Change numerical base of input number to base.\n    >>> from sympy.io import StringIO\n    >>> from sympy import change_base\n    >>> def test():\n        print(change_base(\"10\", 2))\n        print(StringIO.StringIO(change_base(\"10\", 2))[0])\n        print(change_base(\"10\", 1))\n        print(StringIO.StringIO(change_base(\"10\", 1))[0])\n        print(change_base(\"10\", 3))\n        print(StringIO.StringIO(change_base(\"10\", 3))[0])\n        print(change_base(\"10\", 2))\n        print(StringIO.StringIO(change_base(\"10\", 2))[0])\n        print(change_base(\"10\", 1", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    try:\n        return base * x\n        except:\n           return '', x\nNot sure if I like the way you're going with the exception. What happens if you pass a negative number as a base?\n\nWoops, I overlooked that one. Thanks for the spot, I'll correct that.\n\nActually, the correct way to do it is to either call it something like \"to_base\" or \"to_string\" and specify the output explicitly. This is so you can handle the case of an invalid input.\nIn other words, it's correct, it's just not idiomatic.\n\nI understand the 'correctness' of what you're saying, but it's not idiomatic for two reasons:\n1\\. The function does not return anything on failure.\n2\\. It's not an interface. You can't say \"do you want to change the base of this number?\"\nFor the first case, it's just a logic mistake. For the second case, it's a semantics problem. You'd be better off changing the meaning of 'change_base' to 'change", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return str(int(x) * (int(base) - 10))\nHaha, why the hell was this downvoted?\nIt's a good question.  I don't know.  I suspect that it was downvoted because it's a very good question, and I'm \"too stupid to know the answer\".  It is, however, in the FAQ.\nI'm pretty sure it's because of this:  > return string representation after the conversion  which is not correct.  It returns the base-10 representation of the converted number.\nGood catch.  I really should use a code formatter before posting things like this.  In my head it's \"return string representation after the conversion\".  I'll fix it.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if base >= 10:\n       return change_base(x, base-10)\n    else:\n       return \"\".join(list(map(str, x)))\n\nThat's a bad algorithm. You're using numpy, and they have an integer to real function you could use:\n>>> np.int32(8)\n0\n>>> np.float64(8)\n100000000000\n>>> change_base(8, 2)\n1000\n>>> change_base(8, 1.5)\n1.5\n>>> change_base(8, -1)\n-1\n>>> change_base(8, -2)\n-1.999999999999999\n>>> change_base(8, 0)\n0\n>>> change_base(8, -0.5)\n-0.5\n>>> change_base(8, 0.5)\n0.5\n>>> change_base(8, 0)\n100000000000\n>>> change_base(-2, 0)\n1.999999999999999\n>>> change_base(-2, -0.5)\n-", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    def change_string(x: string):\n    \"\"\"Change string representation of input number x to string.\n    base numbers are less than 10.\n    >>> change_string(3, 'decimal')\n    '3'\n    >>> change_string(3, 'binary')\n    '11'\n    >>> change_string(3, 'hex')\n    '0003'\n    >>> change_string(3, 'octal')\n    '327'\n    >>> change_string(3, 'binary-64')\n    '110000000000'\n    >>> change_string(3, 'octal-64')\n    '327'\n    >>> change_string(3, 'octal-128')\n    '327'\n    >>> change_string(3, 'binary-128')\n    '11000000000000'\n    >>> change_string(3, 'hex-128')\n    '0003'\n    >>> change_string", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return base * x\nI came up with that and a whole bunch of other functions to do with changing the base of numbers. I never wrote them up though.\n\nIt's not exactly the same thing, but would you happen to know how to change the base of a number with a certain precision? Say I have a 32 bit int, and I need to covert it to base 2 with 16 bits of precision.\n\nYou could do this with the following python script.", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    def __init__(self, x: int, base: int):\n    \"\"\"Initialize a change_base function\n    self.x - self.base.x = x\n    self.base = base\n    return self\n    \"\"\"\n    self.x = x\n    self.base = base\n    return self", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x < base:\n        return x\n    elif x > base:\n        raise ValueError(\"invalid input\")\n    else:\n        return ''.join(int(x) for x in xrange(base))\n\nI'm surprised that the correct answer is not given. This looks like a case where the language is being used correctly and with care.\n\nWell, xrange(base) can be used to fetch a valid range and, given that base is less than 10, you can write\nreturn ''.join(int(x) for x in xrange(base))\nto get a single digit.\n\nI don't understand what you mean by \"fetch a valid range\". If x is in range(base), what range do you need to fetch?\n\n>> def change_base(x: int, base: int):\n> \"\"\"Change numerical base of input number x to base.\n> return string representation after the conversion.\n> base numbers are less than 10.\n> >>> change_base(8, 3)\n> '22'", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return ''.join(int.to_string(x))\n\nCan I ask why you did it this way? I think it's pretty interesting to have a simple function that can change the base without changing the string.\n\nThe way I see it, this way, you can't accidentally call it with the wrong base.\nIf you do call it with the wrong base, you'll get a string that doesn't do what you expect, or an error.\nBut if you don't call it with the wrong base, you'll get the desired result.\n\nIt also lets you change the number to any base without changing the string, just by changing the base parameter.\n\nI have always liked the way Ruby handles base conversions. It just subtracts 2^i from the number and then shifts it left that many places.\n\nIt's important to note that there are a _lot_ of ways to do base conversions. You can see a few here:\n\nMy favorite method is from Ada. It's very short and very easy to remember.\n_Add_ two to the number.\n\nHere's how to do base conversion in PHP, from the excellent ini_get function (used for converting", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    \"\"\"Base conversion should return the same number as the input number.\n    \"\"\"\n    if x > 10:\n        return \"Please enter a number less than 10.\"\n    else:\n         return \"Please enter a number less than 10.\"\n    return x\nDoes that work?", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return \"A\" * x\nThis is a great example of why most Python programmers should stop using str.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    # Returns the string representation of input number after\n    # the conversion\n    return repr(x, base)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x == 0:\n       return '0'\n    base = int(input(\"Please enter a numerical base: \"))\n    x = int(input(\"Enter the input number: \"))\n    return '%s' % (int(x), base)\n\nThe code is elegant, but it's not the best way to do it. You might consider using the numeric module. If you read the documentation you'll find a method called int_to_string that will convert a number to a string.", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x <= 0:\n        raise TypeError('Base must be greater than or equal to 0')\n    else:\n        if base == 0:\n           return '0'\n        else:\n           return x + base\n\nThis is fine.\nThere's a bit of subtlety in the way Python evaluates strings.\nIt's valid to have a string containing \"3\" and \"22\" and \"1000\" all at once, and it doesn't matter whether those are all separate tokens or whether they're concatenated.\nA nice way to test this is to pass in a string that contains a number and a space. If you print the string, it will show the number, and if you try to evaluate it as a number, it will return the number plus 1 (which you've covered in your check).\nIf you want to show the difference between concatenating strings and evaluating them, you can replace your print statement with the following:\n>>> foo = '1'\n>>> foo + '1'", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return decimal.str.lower(x, base)\nSo, you're doing the bit-shifting yourself? In Python?\nI mean, you're using the built-in `str` type for the return value, but still.\n\nYes, it's bit shifting. In Python. It's not the point of the article. It's how one can convert a number to string.\n\nIn a language that supports bitwise operators, I'd expect to see `x & 0x3` or something similar.\n\nIt's Python. Python does not support bitwise operators.\n\nOne could argue that 2 is a natural base for counting, and for very many purposes, I agree. However, if one is doing a lot of arithmetic, e.g. data manipulation or scientific programming, a base 2 system can be a big pain.\nI think it's worth learning to use base 10, since it's so easy to do arithmetic in a base 10 system.\n\nFor most people, the main use for base-10 arithmetic is accounting.\n\nI find it a pain when dealing with hexadecimal and base-2 numbers in general. I've always found binary to be much more intuitive", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x <= 0:\n        return '0'\n    else:\n        return '0'\n    return base * x + '0'\n\nSo basically, the following numbers are equivalent:\n\n>>> change_base(1, 0)\n'0'\n>>> change_base(1, 1)\n'1'\n>>> change_base(1, 2)\n'1000'\n>>> change_base(1, 3)\n'1111'\n>>> change_base(1, 4)\n'1010'\n>>> change_base(1, 5)\n'100'\n>>> change_base(1, 6)\n'101'\n>>> change_base(1, 7)\n'111'\n>>> change_base(1, 8)\n'1110'\n>>> change_base(1, 9)\n'10100'\n>>> change_base(1, 10)\n'11100'\n>>> change_base(1, 11)\n'11111'\n>>> change_base(1, 12)\n'111111'\n>>> change_base", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    def __init__(self, input: int, base: int) -> None:\n        print(\"Initializing change_base(int, int)\")\n        self.base = base\n        self.input = input\n    print(\"Base: %d, input: %d\" % (self.base, self.input))\n    def convert(self, x: int, base: int):\n    \"\"\"Return string representation of number x after the conversion to base.\n    return string representation after the conversion.\n    >>> convert(change_base(8, 3), 4)\n    '22'\n    >>> convert(change_base(8, 3), 8)\n    '1000'\n    >>> convert(change_base(7, 2), 4)\n    '111'\n    >>> convert(change_base(7, 2), 8)\n    '1001'\n    \"\"\"\n    return self.base - self.input\n\nPython", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return x.decode(base)\nI'm not sure what I'm missing.  Can someone explain?  Edit: oh, that's why it's posted in /r/shittyprogramming.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x < 0:\n        return str(x)\n    base = int(x)\n    r = \"\"\n    for i in xrange(base+1):\n        if i == 0:\n            r = \"0\"\n        else:\n            r += chr(ord(base*i))\n        return r\n\nNote that this program will fail if base is greater than 10, which is why the first example does not produce a sensible result.\n\nThe first two lines would be better written:", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if base >= 10:\n       return \"HACK\"\n    else:\n       return change_base(x, base)\nThis is one of the ugliest things I've seen in a while.\n\nI agree that the code is ugly, but the underlying principle is fine.\n\nIt's ugly because the code is too short. I'd really like to see how this is implemented.\n\nfor a really simple change of base conversion, it would be something like", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    \"\"\"Return base.\n    >>> change_base(3, 2)\n    '12'\n    >>> change_base(10, 2)\n    '2'\n    \"\"\"\n    print('%s %s' % (change_base(8, 2), change_base(8, 3)))\n    # change_base(8, 2) --> '1000'\n    # change_base(8, 3) --> '22'", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x < base:\n       return '1'\n    x = x.decimal()\n    x = int(x)\n    return x\n\nI mean, it's not that it's a bad way to write it. It's just that the number is then represented in base 10 instead of base whatever. So if you wanted to work with it later on, you'd have to go through an extra step.\n\nUnless you know that you only ever want to change the number to a different base, and not work with it later on.\nIn the case of Base64 (or maybe Base32), the only thing you want to do is pass the data to the next program. So Base64 is a good choice.\n\nTrue, but the only context I see that in is in Base64 decoders/encoders.\n\nThere is no better way to write it in Python, but if you must:", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    change_base = lambda x: int(x, x * 10)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    base = int(raw_input( \"Base: \" ))\n    return '%s'.format(base, x)\nThis is not pythonic. You should read and apply the PEP 8.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    new_value = int(x) / base\n    return \"\".join([string.punctuation.replace(new_value,'')\n        for string in split(new_value,'') if string])\n\nSee also\n List of string processing libraries\n\nReferences</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    base = int(x * base)\n    return ''.join([str(x), str(base)] + '\n    '.join([str(x), base + 1])", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return \"\";", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    def convert(x: int, base: int):\n    \"\"\"Convert a numerical number x to the given base.\n    if x is not numeric:\n       raise ValueError, \"Number is not a number: %s\" % x\n    return string representation of x after the conversion.\n    >>> convert(8.0, 3)\n    '22'\n    >>> convert(8.0, 2)\n    '1000'\n    >>> convert(7.0, 2)\n    '111'\n    >>> convert(8.0, 1)\n    '10'\n    >>> convert(8.0, 0)\n    '0'\n    >>> convert(8.0, -1)\n    '-1'\n    >>> convert(-8.0, 3)\n    '-3'\n    >>> convert(-8.0, 2)\n    '-1000'\n    >>> convert(-8.0, 1)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n        if base < 10:\n           return \"0\"\n         else:\n           return int(x, base)\n\nHere's the code for that snippet:", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if not isinstance(base, int) or not isinstance(x, str):\n        raise ValueError(\"Not an integer or string\")\n    return \"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    from itertools import cycle\n    import re\n    import string\n    from decimal import Decimal\n    def __init__(self, x: int, base: int):\n    self.x = x\n    self.base = base\n    def __call__(self, x, base):\n    return self.x * self.base\n    def get_string(self):\n    \"\"\"Get the string representation of x in base, return None\n    if base is not an integer.\n    >>> get_string(change_base(8, 2))\n    '1000'\n    >>> get_string(change_base(8, 3))\n    '22'\n    >>> get_string(change_base(7, 2))\n    '111'\n    >>> get_string(change_base(8, -1))\n    '8'\n    >>> get_string(change_base(8, -2))\n    '100000'", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return base*x+'0'+'1'*x", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x == 0:\n        return '0'\n    else:\n        x = int(x)\n        return x.int()[:base] + '0'\nThis works by looking at the number from the right and adding '0' to the left:\n>>> change_base(8, 3)\n'22'\n>>> change_base(8, 2)\n'1000'\n>>> change_base(7, 2)\n'111'\n>>> change_base(8, 1)\n'0100'\n>>> change_base(9, 1)\n'0001'\n>>> change_base(10, 1)\n'1000'\n>>> change_base(11, 1)\n'1001'\n>>> change_base(12, 1)\n'1010'\n>>> change_base(13, 1)\n'1100'\n>>> change_base(14, 1)\n'1110'\n>>> change_base(15, 1)\n'1101'\n>>> change_base(16, 1)\n'1110'\n>>>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return x + ('0' * base)\n    + '0' * base * x\nThis is a bit more idiomatic but still potentially troublesome, as it doesn't quite handle changing from base 10 to base 2:", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\n    def to_str(x: int, base: int):\n    \"\"\"Convert input number x to a string representation and return it.\n    return string representation of input number x after the conversion.\n    return string representation of input number x after the conversion.\n    >>> to_str(8, 2)\n    '1000'\n    >>> to_str(7, 2)\n    '111'\n    \"\"\"\n\n    def as_int(x: int, base: int):\n    \"\"\"Convert input number x to an integer and return it.\n    return integer representation of input number x after the conversion.\n    return integer representation of input number x after the conversion.\n    >>> as_int(8, 2)\n    '1000'\n    >>> as_int(7, 2)\n    '111'\n    \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    #The name of the function\n    def change_base(x, base):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\"\n    #The return type\n    return int(str(base, x))\nJust don't get a job at a bank.\n\nI have that same fear, actually.\n\nI never understood the obsession with having multiple versions of the same thing in C, when you could just do this:\nstatic int change_base(int x, int base){\nreturn x * base;\n}\n\nYou can't. What if your \"base\" is 1, and x is 0? Or what if the caller gives you a \"base\" of 1, and you have to convert to base 10?", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\nimport itertools", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    def convert_base(base: int, value: string):\n    \"\"\"Change numerical base of input number value to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> convert_base(8, 3)\n    '22'\n    >>> convert_base(8, 2)\n    '1000'\n    >>> convert_base(7, 2)\n    '111'\n    \"\"\"\n    def is_base(base: int):\n    \"\"\"Returns true if base is a number less than 10.\n    \"\"\"\n    return not isinstance(base, str)\n    def is_string(s: str):\n    \"\"\"Returns true if s is a string, otherwise returns false.\n    \"\"\"\n    return s.startswith(\"\" or s.startswith(\"'\") or s.startswith(\"'\\\\'\") or s.startswith(\"'\\\\\\\"\") or s.startswith(\"'\\\\\\')\")", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    \"\"\"Set result to repr(x)\n    return str(x, base)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return 'x' % x", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    change = lambda x: int(x + 0xfffffff)\n    if x < 10 and x == 0:\n       return \"0\"\n    else:\n       return \"0x\" + change(x, base)\nHere's the list of valid bases: 1, 2, 4, 6, 8, 9, 10, 12, 16, 18, 24, 32,\n36, 40, 48, 52, 56, 60, 64, 72, 80, 96, 108, 112, 120, 128, 144,\n156, 162, 168, 180, 192, 216, 240, 252, 264, 276, 288, 300, 312, 336,\n360, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384,\n384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384,\n384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384,\n384, 384, 384, 384,", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    def __init__(self, base: int):\n        self.base = base\n\n    def convert(self, input: int, base: int):\n        if input > self.base:\n            raise ValueError(\"Base overflow\")\n\n        return input\n\n    def to_string(self):\n        return \"input.base\"\n\nHere is the code in Racket:\n(define (change-base x base)\n    (let loop (if (= x base) 'base base\n         'base))\n    (loop x base))\nThis should be clearer as to what is actually going on.\n\nThat is pretty clean but I don't like the style of the looping, it's so\ndifferent to the style of the rest of the language.\n\nIt's a bit on the ugly side, but I think it's the most readable of the\npossible alternatives.\nI prefer this style over having to indent multiple lines of code", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    \"\"\"This is used internally.\n    \"\"\"\n    change_base = lambda x: int(x)\n    def lchr(base: int):\n    \"\"\"Return string representation of a number in base.\n    return base.decimal_digits + string(x.decimal_digits).decode('hex')\n    \"\"\"\n    def chr(base: int):\n    \"\"\"Return string representation of a number in base.\n    return string(base).decode('hex')\n    \"\"\"\n    def change_base_to_string(x: int):\n    \"\"\"Return string representation of a number in base x.\n    return x.decimal_digits + '0x' + chr(change_base(x, base))\n    \"\"\"\n    def print_base(base: int):\n    \"\"\"Print base number.\n    return \" %s \" % base.decimal_digits\n    \"\"\"\n    def print_number(n:", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    \"\"\"\n    \"\"\"\n    # Base numbers are less than 10.\n    def __len__(self):\n    \"\"\"Get length of the string representation.\n    base numbers are less than 10.\n    >>> len(change_base('3', 3))\n    3\n    >>> len(change_base('7', 2))\n    2\n    \"\"\"\n    return len(self)\n    def __str__(self):\n    \"\"\"Get a string representation of the base change number.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base('3', 3)\n    '22'\n    >>> change_base('7', 2)\n    '111'\n    \"\"\"\n    return self.__str__\n\nI don't like the idea of the usage of `base` here. If you want to have different bases, use different functions for each base.\n\nWhy not? It's an idiom that", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return ''.join(str(x), '.')\nWhy does it return '22' for 8/3? Because str(8) is 2, but base 3 only has two digits so it has to append a 1.\n\nAh, I had missed that. I was just looking for reasons to like it.\n\nYou can find reasons to like it by reading the rest of the code. It does a lot of other things.\n\nI am getting a lot of \"file not found\" for the csv files.\n\nShould be fixed now.\n\nThanks for the link.\nI'm not an expert, but I really like it.\nI'm just wondering how it compares with the well known scipy module.\n\nThanks for your compliment. scipy.linalg is definitely a very popular package and provides a lot more functionality than the module I've written. However, I wanted to write a small library that provides just the bare minimum to manipulate linear algebraic expressions without having to import a whole library. That's why this library only contains the most frequently used functions and it doesn't even provide much error checking.\n\nThanks for the link.\nI'm not an expert", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x < 0:\n       return \"Infinity\"\n    base = int(x)\n    if base > 10:\n       return \"Base too big\"\n    return base + str(x)\nI think you've got a bug there; if x is negative, you return \"Infinity\".\n\nI think the author meant to check for `x < 0` first. Otherwise it should return 'Base too big'.\n\nYes, I meant that.\n\nOr you could just use the bit-shift operator:\n>>> from decimal import bitwise_and\n>>> 2*8 = 16\n>>> '3*8 = 24'\n\nWhy would you want to do that?\n\nUhm, to change the base from a power of ten to two?\n\nThis is cool.\nI was just looking at this today. There is also a simpler solution if you're using python 3.\n>>> from decimal import *\n>>> d = 2**8\n>>> d\n'24'\n\nI'm not sure I see the advantage of this over using the bitwise and operator...\n>>> from decimal", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    print(\"\\nBase: \" + str(base))\n    print(\"\\nBase: \" + str(x))\n    print(\"\\nBase: \" + str(base + x))\n    if base > 10:\n        print(\"Base is out of range\")\n        raise ValueError(\"Base is out of range\")\n    # Check for NaNs, etc.\n    if not isnan(x) and not isnan(base):\n        print(\"\\nBase: \" + str(base + x))\n        return base + x\n    # Convert to string\n    return str(base + x)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    n: int = x\n    b: int = base\n    return n", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return \"\".join(chr(x), \"0\")+\"0\".join(chr(base))\n\nThis is a super cool function! It's a great example of how simple it can be to implement a function. The only thing I would add is a note about the range of base numbers.\n\nYes, thank you for suggestion. I should change it from \"less than 10\" to \"0..10\".\n\nI love the fact that it returns the result of joining the initial string to itself with a 0 and the new base.\nIf the input is \"8\" it returns \"22\". If the input is \"2\" it returns \"1000\".\n\n(Edit: I deleted my original comment, because I thought this was a duplicate submission. I guess I was wrong.)\nMy personal favorite is my own function \"lft\":", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    from decimal import Decimal\n    from string import codecs, str, unicode\n    return \"\".join(\n    codecs.encode('ascii', str(x))\n    for base in range(10):\n         x = Decimal(x)\n         x = Decimal(x) / base\n    )\n>>> # List of the 10 bases\n>>> bases = [6, 8, 10, 16, 20, 24, 28, 32, 36]\n>>> change_base(10, 6) # Change from base 10 to 6\n>>> change_base(24, 6) # Change from base 24 to 6\n>>> change_base(8, 8) # Change from base 8 to 8\n>>> change_base(20, 6) # Change from base 20 to 6\n>>> change_base(20, 12) # Change from base 20 to 12\n>>> change_base(24, 12) # Change from base 24 to 12\n>>> change_base(16, 12) # Change from base 16 to 12\n>>> change_base(", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    print('Changing base from'+ str(x))\n    if x < 10:\n        raise ValueError(\"int must be greater than or equal to 10\")\n    x = int(x)\n    base = int(x)\n    try:\n        return base\n    except ValueError:\n        return x", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    print(\"base change base to \" + str(x))\n    return change_base(x, base)\nThis doesn't test base numbers less than 10.\n\nI have a feeling this isn't testing what the OP is looking for.\n\nI think I'm using a different test:\n>>> change_base(8, 3)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: global name 'change_base' is not defined\n>>> change_base(8, 2)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: global name 'change_base' is not defined\n>>> change_base(7, 2)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: global name 'change_base' is not defined\n\nYes, the OP was looking for a test that actually tests the value returned.\n\nGood catch, and thank you. :)\n\nI don't know if this will work for you, but I have", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    def safe(x: int, base: int):\n    \"\"\"Return string representation of input number x in base\n    base.\n    return string representation after the conversion.\n    >>> safe(8, 3)\n    '22'\n    >>> safe(7, 2)\n    '111'\n    \"\"\"\n    def int(base: int):\n    \"\"\"Return base-base representation of the number x.\n    return string representation after the conversion.\n    >>> int(3, 2)\n    '2'\n    >>> int(5, 2)\n    '10'\n    \"\"\"\n    def string_to_base(x: string, base: int):\n    \"\"\"Return string representation of the number x in base\n    base.\n    return string representation after the conversion.\n    >>> string_to_base('22', 3)\n    '22'\n    >>> string_to_base('22', 2)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    print(x)\n    print(base)\n    if x < base:\n       print(base)\n       print(\"Changing base to \"+ base)\n       base = base * 10\n    else:\n       print(\"Base is not a number.\")\n    return (x, base)\nI wish I had thought of that solution. It is as simple as this one, although more complicated than the original.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return x\nFrom: joseph.simcox@gmail.com\n\nI am in the process of learning Python, and would really appreciate some feedback on my attempt to solve the Project Euler problem number two. I have included the code below and have run into a few problems. I have submitted it to Project Euler.\nFrom the FAQ on Project Euler:\nIf you have written a script which solves the problem, please submit it,\ntogether with a short description of how it works.  We will post the\nsolutions here, and credit the solvers in each case.\nIf you have made a program to solve the problem, but it is not written in\nPython, please submit it to the Project Euler archive instead, so that it\ncan be compared with the other solutions.\n\nI would appreciate it if someone would review my code and provide any suggestions for improvement. Thanks!</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    i = len(x)\n    if i == 0:\n       return \"0\"\n    base = int(x)\n    return base * i", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return str(x)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return '10000000' if x > 10 or x == 10 and x!= 0 else '100'+x\nI'd be more comfortable with      return '10000000' if x > 10 or x == 10 and x!= 0 else '1000000'  Although I guess this is more readable to most people.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return ''.join(int(x), int(base))", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    r, i = range(x, 1, 10)\n    r, i = range(x, i, 10)\n    for i in range(i, r):\n        x = x << r\n        x = int(x)\n        return change_base(x, base)\n[...code omitted...]\n[...code omitted...]\n__repr__ = \"string\"\n\nThis is actually valid C. The fact that you cannot change the base of an integer is not something the C standard defines, it is just something your compiler implements.\nIt's not the best way to do this, but it works:\nchar *\nuint16_t *\n\nint\n\nThis is the C standard way to do it:", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return '%(x)s' % (x, base)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    def __call__(self, x: int, base: int):\n       return x.replace(base, '')\nI believe this is a common mistake. You're trying to reverse the string, which will always return \"\". Instead you should be trying to return the result of str(x).\nBut, I'm not sure that you're actually doing anything wrong. In Python 3, x.replace('', '') does exactly what you're looking for.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    change_base = lambda x: int(x, base)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    print \"base: %s\" % base\n    print \"input: %s\" % x\n    print \"changed to: %s\" % str(x, base)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return '%x' % (base + x)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    raise ValueError(\"Invalid numerical base\")\n    def convert_base(x: int, base: int):\n    \"\"\"Convert base number to input number.\n    return input number after the conversion.\n    base numbers are less than 10.\n    >>> convert_base(8, 3)\n    '22'\n    >>> convert_base(8, 2)\n    '1000'\n    >>> convert_base(7, 2)\n    '111'\n    \"\"\"\n    raise ValueError(\"Invalid numerical base\")", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\nI\u2019m not sure it\u2019s a good idea to rename the function to string_to_base_num. I would just leave it as change_base or change_number_to_base, and then add the string_to_base_num as a separate function.\n\nI\u2019m not sure why you\u2019re taking the base of the number in the first place. And if you\u2019re going to take the base, why not just convert the string to a base 10 number?\n\nThese are all just nitpicks, but I think it would be good to separate the two functions.\n\nEDIT: I guess maybe you\u2019re not taking the base of the number in the first place, but it looks like it because you start with \u201cbase\u201d. I would start with \u201cint\u201d instead, and then you can use the num() function if you really want to check what number you\u2019re dealing with.\n\n> I\u2019m not sure why you\u2019re taking the base of the number in the first place.\n> And if you\u2019re going to take the base, why not just convert the string to a base 10 number", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return string.format(number = x, base = base)\nI'm really curious about what you're doing with this function.  Why does it exist?</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    base = int(x)\n    if base >= 10:\n       raise ValueError('Base number must be between 1 and 10.')\n    return \"0x\"+int(x)-int(base)\n\nThis is absolutely beautiful.\n\nI think the \"minimal\" version of this is just:", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    \"\"\"\n    return '0' * (2 * x + 2 * x * base + x * base)\n    def string_of_int(n: int):\n    \"\"\"Convert int to string.\n    return '0' * (n * 100 + n)\n    >>> string_of_int(4)\n    '000'\n    >>> string_of_int(5)\n    '000'\n    >>> string_of_int(6)\n    '000'\n    \"\"\"\n    return '0' * (n * 10 + n * 10 * n)\n    def string_of_float(n: float):\n    \"\"\"Convert float to string.\n    return '0' * (n * 100 + n)\n    >>> string_of_float(4.5)\n    '000'\n    >>> string_of_float(4.5)\n    '000'\n    >>> string_of_float(4.5", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    print(int(x))\n    print('Base changed to', int(x))\n    return''.join(int(x)).strip()", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    for x in range(0, 10):\n        try:\n           base = int(x % base)\n             raise RuntimeError('Base not a multiple of %s' % base)\n             # try again, but if still doesn't work, raise error\n         except ValueError:\n            raise RuntimeError('Base not a multiple of %s' % base)\n           return \"\".join(x**base for x in range(1, 10))\n\n\"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return'' * (base * (base-x))", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return string(int(base*10 + x))\nI think this version is better because it's less magic and more explicit.\n\nI'm not sure I understand why this is better, but it seems more explicit, yes.\n\nI think this is better because it's less magic and more explicit.\n\nI am not sure I understand why this is better, but it seems more explicit, yes.\n\nI think this is better because it's less magic and more explicit.\n\nThe only thing that is non-obvious about the code in the article is the fact that the radix is 2. What would be the non-obvious part in the version of the code you suggested?\n\nIt's not more obvious, but it's not less obvious either.\n\nI think this is better because it's less magic and more explicit.\n\nI am not sure I understand why this is better, but it seems more explicit, yes.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if base<10:\n        raise ValueError('number should be greater than 0')\n    return str(int(x))\nIt's not a super elegant solution, but it works.\n\nCould you use a number with a base larger than 10?\n\nNo, that would cause a stack overflow.\n\nHm, unless you're doing integer division or something.\n\nThe problem is that many programming languages use the base 10 representation of integers as a kind of intermediate representation before they are stored in the computer's registers or memory. So when you multiply an integer by a larger integer, it first converts the intermediate representation to base 10, then multiplies it. So if you multiply by a number which is not in base 10, you get a result in the intermediate representation, which then gets converted to base 10, which overflows.\n\nThat makes sense, thanks for explaining.\n\nThe logic behind it is that we are writing in a human readable language.\nHowever, you could put it into a list comprehension:\n>>> def change_base(x: int, base: int):\n...:\n...:...:\n...:...:\n...:", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    def to_base(x: int):\n    return x.int_mod(base)\n    def from_base(base: int):\n    return base * x\n    if x == 0:\n       return \"0\"\n    change_base(x, from_base(8))", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return string(base * x)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    def convert(x):\n    \"\"\"Convert number x to its string representation in base base.\n    return string representation after the conversion.\n    >>> convert(8, 3)\n    '22'\n    >>> convert(8, 2)\n    '1000'\n    >>> convert(7, 2)\n    '111'\n    \"\"\"\n    return string(int(x), base)\n\nThe above code is a Python implementation of the popular BASIC program _chr()_.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\nAs a Python user, I would like to point out that Python has the str.i (Int) and str.g (Int, G) formats to do exactly this.\n\nSo does PHP.\n\nWhile we're talking about PHP, does anyone else find it amusing that the entire PHP documentation is written in the language?\n\nI think that is great. When I used PHP, it was a great help because I could test the examples on the spot.\n\nis there any practical reason to use this over the native string functions?\n\nI am not sure about the implementation details of this, but it looks like a quick'n'dirty implementation of the algorithm described here:\nwhich is a little more efficient than the normal \"base+mantissa\" approach.\n\nYou may want to check this library instead:\n\nI don't get it. This seems to just be a very poor man's version of the standard string formatting library of the language. I could understand it being useful as a convenience, but there's nothing here that can't be done with a couple of string formatting calls.\n\nI do not understand the purpose of this lib. I mean, if you want to convert a number to string,", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    def __init__(self, base: int):\n    \"\"\"Initialize this function.\"\"\"\n    self.base = base\n    self.assertEqual(self.base, base)\n    def __iter__(self):\n    \"\"\"Iterate over bases and input numbers.\"\"\"\n    for i in range(self.base):\n        self.base = i\n        self.assertEqual(self.base, i)\n    if self.base == base:\n        return self\n    return None\n    def __getitem__(self, base: int, x: int):\n    \"\"\"Get the input number x by its base.\"\"\"\n    return self.base == x\n    def __repr__(self):\n    \"\"\"Return a string representation of input number x\n    by its base.\"\"\"\n    return '%s%s' % (x, self.base)\n\nWe need to create a new file", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return str(base) + str(int(x) * x)\nExcept that this function also fails to work properly if the input is negative:\n>>> change_base(3, -2)\n' -2'\n\nI don't think this is a serious problem. Negative numbers are not base 10 numbers.\n\nI'm not sure I understand what you're saying. I know negative numbers aren't base 10 numbers. But I thought this was a problem because the function was not defined properly.\n\nThe function is defined properly. It converts from base X to base Y, and never claims to convert the other way around. For example, if you pass it something like:\n>>> change_base(9, 0)\n'900'\nit's doing the right thing. You're complaining that it doesn't convert from base 0 to base 9. If you want that, you need to define a function that does that. The function you posted does just that.\nI agree with the author of the function though that you should just stick with x = int(x) if you want to go in both directions.\n\nI think you misunderstood me. I agree that the function does exactly what it is supposed", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\nIt's worth noting that it's the first method in the function that's being called. Also, you should probably implement the methods as methods of the class.\n\nI'm assuming that the second half of your question is asking how to convert a number to a string representation of itself in another base. The answer is with the following code:", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x <= base:\n        return x\n    return str(x)\n\nThis is a good example of a \"function\" that's not really a function at all. All it's doing is printing out the new string, which could easily be done in a way that's more readable.\n\nYou don't have to be that rude. I just found this function on Stack Overflow and shared it. I can understand if you're not interested in it.\n\nI'm not sure why you think I was being rude. I didn't intend to be, and I'm sorry if I came across that way. I was trying to offer some constructive criticism, which is generally a good thing.\n\nno worries mate\n\nI\u2019m new here, so please forgive the following off topic.\nI\u2019ve been doing a lot of math recently. As I type this, I\u2019m watching the number of COVID-19 cases in my state tick up. After reading a great blog post that estimates a COVID-19 death rate of 3.8%, I decided to try my hand at the math. Here\u2019s my result:\nCOVID-", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if x > 0:\n        base = x / base\n    else:\n        base = 0\n    return x\n\nThe closest example I can find to this is a lookup table:", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\nfrom base import base, to_base", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\nThis is a list comprehension, which isn't Turing complete.\n\nWhere's the list comprehension?\n\nIt's at the bottom of the file. The variable \"x\" is used to wrap the numerical input, which is a list comprehension, which is used to construct a list of lists (one for each base), which is then used to build a list of strings.\n\nIt's not a list comprehension.\n\nIt is, because the code constructs a list of lists.\n\nNo. It's a list of lists.</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    def new_base(base: int):\n    \"\"\"Return a new base number.\n    return string representation after the conversion.\n    >>> new_base(3)\n    '100'\n    >>> new_base(2)\n    '10'\n    >>> new_base(1)\n    '1'\n    \"\"\"\n    def change(numerator, denominator):\n    \"\"\"Change numerical value of (numerator, denominator) to the new\n    base number.\n    return string representation after the conversion.\n    >>> change(8, 3)\n    '22'\n    >>> change(8, 2)\n    '1000'\n    >>> change(7, 2)\n    '111'\n    \"\"\"\n\nSee also\n\nNumerical_Base\n\nReferences\n\nExternal links\n\nbase</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return \"\";\n    def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation before the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '1000'\n    >>> change_base(8, 2)\n    '22'\n    \"\"\"\n    return \"\";\nIn Python 2.7 it's possible to use the repr() function instead of str().</s>", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    from collections import defaultdict\n    def str_value(a: str):\n        return a.replace('0','')\n        return a\n    def is_base(x: int):\n        return type(x) == 'number' and x <= 10\n    def change_base(x: int, base: int):\n        if x >= base:\n           return '0'\n           else:\n            return str_value(base - x) + '0'\n            # Base of x is the last digit\n            # If the base is less than 10, # this is a valid number.\n            if type(base) == 'number' and x <= 10:\n                return", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\n    if not isinstance(x, int):\n        raise ValueError('number must be an int')", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n\n    return '<base>' + str(x)\n\nThis is both good code and bad code. It's good because it's concise, elegant, and easy to read.\nIt's bad because it's not nearly as general as it needs to be. You can't do anything useful with this code because it can only deal with base 10 numbers.\nIt's also bad because it's not idiomatic Python. The idiomatic way to do this in Python is to use the ufunc module, which provides a much richer interface:\n>>> import ufunc\n>>> ufunc.ubase(8, 3)\n'22'\n>>> ufunc.ubase(8, 2)\n'1000'\n>>> ufunc.ubase(7, 2)\n'111'\n>>> ufunc.ubase(3, 2)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: unsupported base value '2' for base 10 number\n(These are actually examples from the Python documentation.)\n\nYou are using a different version of the ufunc module. The version I use (0.5.0) does the same", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    if base < 10:\n        return '0'\n    else:\n        return 'x'\n    # at top of the method\n    # put a blank line to indicate the end of the method\n    def change_base_to_numerical(base: int):\n    \"\"\"Return string representation of number after conversion from base\n    base numbers are less than 10.\n    >>> change_base_to_numerical(8, 3)\n    '22'\n    >>> change_base_to_numerical(8, 2)\n    '1000'\n    >>> change_base_to_numerical(7, 2)\n    '111'\n    \"\"\"\n    return change_base(base, 2)", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    \"\"\"Define what the conversion should do.\n    return string representation after the conversion.\n    \"\"\"\n    if x == 0:\n       return '0'\n    if x == 1:\n       return '1'\n    if x == 2:\n       return '2'\n    if x == 3:\n       return '3'\n    if x == 4:\n       return '4'\n    if x == 5:\n       return '5'\n    if x == 6:\n       return '6'\n    if x == 7:\n       return '7'\n    if x == 8:\n       return '8'\n    if x == 9:\n       return '9'\n    if x == 10:\n       return '0'\n    return str(", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    number = int(input(''))\n    base = int(input('N' if base > 10 else 'base'))\n    string = ''\n    for i in range(base):\n        number = number / base\n        if number > base:\n            number = base + 1\n            string = string + number\n    return string", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"", "def change_base(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base(8, 3)\n    '22'\n    >>> change_base(8, 2)\n    '1000'\n    >>> change_base(7, 2)\n    '111'\n    \"\"\" \"\"\"\n    return base * (2**x - 1) + 0\n\nThis is a pretty direct translation.  It's worth noting that Python's version of the return statement is really just syntactic sugar for an except statement, so this example may be more readable if written as:"]]