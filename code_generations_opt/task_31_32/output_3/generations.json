[["def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    for i in range(2, n):\n    if n % i == 0:\n       return False\n    return True\n>>>\n\nI think you meant:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n == 0:\n       return True\n    if n == 1:\n       return True\n    if n == 2:\n       return True\n    if n == 3:\n       return True\n    if n == 4:\n       return True\n    if n == 5:\n       return True\n    if n == 7:\n       return True\n    if n == 11:\n       return True\n    if n == 13:\n       return True\n    if n == 17:\n       return True\n    if n == 19:\n       return True\n    if n == 23:\n       return True\n    if n == 29:\n       return True\n    if n == 31:\n       return True", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n%2 == 1:\n       return True\n    else:\n       return False\nThis code has a mistake in it. It always returns True for 1, because it returns False for 0, 1, and 2.\nWhat I would expect:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\n    def is_prime_test(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime_test(4)\n    False\n    >>> is_prime_test(61)\n    True\n    >>> is_prime_test(6)\n    True\n    >>> is_prime_test(13441)\n    True\n    >>> is_prime_test(7)\n    True\n    >>> is_prime_test(11)\n    True\n    >>> is_prime_test(1)\n    False\n    >>> is_prime_test(101)\n    True\n    >>> is_prime_test(1101)\n    False\n    \"\"\"\n\n    def is_even(n):\n    \"\"\"Return True if n is even, False otherwise.\n    >>> is_even(4)\n    True\n    >>> is_even(61)", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\n    if n == 0:\n        return True\n    else:\n        return False\n\n    def is_prime(n):\n    \"\"\"Return True if a given number is prime, and False otherwise.\n    >>> is_prime(6)\n    True\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    if n == 0:\n        return True\n    else:\n        return False\n\n    def is_prime(n):\n    \"\"\"Return True if a given number is prime, and False otherwise.\n    >>> is_prime(6", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return is_prime(n%2)\nCan someone explain to me the reasoning behind this? I was taught to do this as well but I'm having trouble seeing the logic.\n\nThe `n%2` tests if the number is divisible by 2. If it is, it is not prime.\n\nI know how it works, I'm just wondering why I was taught to do it this way rather than some other way.\n\nIt's a common trick for a variety of things. It's an easy way to check if a number is prime, or divisible by a given number.\nFor example, you can check if a number is prime by finding the difference between it and 2^n + 1. If the difference is zero, the number is prime.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    for i in range(2,n):\n        if n % i == 0:\n           return False\n    return True\nI don't see how this is particularly quick or elegant. The python version is: \n>>> def is_prime(n):\n...    for i in range(2, n):\n...        if n % i == 0:\n...           return False\n...    return True\n>>> is_prime(6)\nTrue\n>>> is_prime(101)\nTrue\n>>> is_prime(11)\nTrue\n>>> is_prime(13441)\nTrue\n>>> is_prime(61)\nTrue\n>>> is_prime(4)\nFalse\n>>> is_prime(1)\nFalse\n\nYou need to consider the case where n is divisible by a prime, which your version does not.\n\nI think this might have been a typo, as that's exactly what the python version does.\n\nI found the Python version more elegant, but was just pointing out", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\n    def is_prime(n):\n    \"\"\"Return True if a given number is prime, and False otherwise.\n    >>> is_prime(4)\n    True\n    >>> is_prime(1)\n    False\n    \"\"\"\n\nI'd have more respect for this if there was an explanation of why python's is_prime() is wrong.\n\nI suspect the Python is_prime() is not wrong. The author probably hasn't implemented the algorithm properly. If I've got a number and I want to know if it's prime, I use the following, which is the standard algorithm:\n(n, (2 * n) / (2 * n)) % 2 == 1\n(n, (2 * n) / (2 * n)) % 2 == 0\n(n, (2 * n) / (2 * n)) % 2 == 1\n(n, (2 * n) / (2 * n)) % 2 == 0\n(n, (2 * n) / (2 * n)) % 2 == 1\n(n, (2 * n) / (2 * n)) % 2 == 0", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return n % (n == 1)", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n%2 == 0:\n        return True\n    else:\n        return False\n\nThe goal is to find the program that runs the fastest.\n\nReferences\n\nExternal links\n\nSpeed of Prime Test Algorithms</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n == 1:\n       return True\n    else:\n       if n % 2 == 0:\n          return True\n       else:\n          return False\nThis is very bad code. You should not use the integer 2 as a loop index. It is easy to confuse with the integer 1, and then you're not testing the condition you think you're testing.\nYou should write:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n % 2 == 1:\n        return False\n    if n % 3 == 0:\n        return False\n    if n % 5 == 0:\n        return False\n    if n % 7 == 0:\n        return False\n    if n % 11 == 0:\n        return False\n    if n % 13 == 0:\n        return False\n    if n % 17 == 0:\n        return False\n    if n % 19 == 0:\n        return False\n    if n % 23 == 0:\n        return False\n    if n % 29 == 0:\n        return False\n    if n % 31 == 0:\n        return False\n    if n % 37 == 0:\n        return False", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    n = int(n)\n    if n%2!= 0:\n       return False\n    return int(n % 2) == 0\nIn Python this is even shorter:\n>>> is_prime(6)\nTrue\n>>> is_prime(101)\nTrue\n>>> is_prime(11)\nTrue\n>>> is_prime(13441)\nTrue\n>>> is_prime(61)\nTrue\n>>> is_prime(4)\nFalse\n>>> is_prime(1)\nFalse\nAlso, the regular expression in the Ruby code is unreadable.\n\nIn ruby this is short enough to be elegant:\n$ ruby -e '1..=2 == 0'\n1\n$ ruby -e '1../=2'\n/\n\nYou could also use the -w flag:\n$ ruby -w1 -e '1..=2 == 0'\n1\n$ ruby -w1 -e '1../=2'\n1\n\nI think Python has shorter version:\n>>> is_prime(6)\nTrue\n>>> is_prime(101)\nTrue\n>>> is_", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return (n % 2 == 0)\nAm I missing something?  edit: I'm not missing anything. This is a joke.\n> Am I missing something?  edit: I'm not missing anything. This is a joke.  It is not a joke. The following code compiles and runs without errors.\n> def is_prime(n):\n>    \"\"\"Return true if a given number is prime, and false otherwise.\n>    >>> is_prime(6)\n>    False\n>    >>> is_prime(101)\n>    True\n>    >>> is_prime(11)\n>    True\n>    >>> is_prime(13441)\n>    True\n>    >>> is_prime(61)\n>    True\n>    >>> is_prime(4)\n>    False\n>    >>> is_prime(1)\n>    False\n>    \"\"\"\n>    return (n % 2 == 0)\n>   \n> Am I missing something?", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    def is_divisible(n, p):\n    \"\"\"Return true if p divides n and false otherwise.\n    >>> is_divisible(6, 3)\n    True\n    >>> is_divisible(13441, 3)\n    False\n    >>> is_divisible(6, 3)\n    False\n    >>> is_divisible(13441, 3)\n    True\n    >>> is_divisible(6, 3)\n    True\n    >>> is_divisible(13441, 3)\n    False\n    >>> is_divisible(6, 3)\n    True\n    >>> is_divisible(13441, 3)\n    True\n    >>> is_divisible(6, 3)\n    False\n    >>> is_divisible(13441, 3)\n    True\n    >>> is_divisible(6, 3)\n    True\n    >>> is_divisible(13441,", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    True\n    >>> is_prime(1)\n    False\n    \"\"\"\n    for i in range(2, n+1):\n        if n % i == 0:\n          return False\n    return True\nWhat if you have to check if a number is prime after having generated it?  Or what if you want to check if a number is prime and the result of prime(n) is True?  How do you compare those things?\n\nIf you know that n is prime, then it", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return(isprime(n))\n    if n <= 2:\n       return False\n       return is_prime(n % 2)\n\nfor n in [1, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 211, 223, 227, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 341, 347, 349, 353, 359, 367, 379, 383, 389, 397, 401, 409, 421, 433, 439, 441, 443, 445, 447, 449, 457, 459, 461, 463, 467, 469, 471, 473, 477, 481, 487,", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\nThe test suite covers a small set of functions, but this should be enough to prove the correctness of the library. There's a good description of the tool on the project's GitHub page:\n\nI'd like to see a discussion of the quality of the test suite, and how it compared to other examples of test suites.\n\nThe source code is available here: \n\nI think this looks awesome. I've been planning to build something like this as a library for the past few months. How does this compare to the zeromq library?</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n == 1:\n       return True\n    else:\n       if n % 2 == 1:\n          return True\n          else:\n           return False\n\nI don't get it. 1 is not prime, but is_prime() returns True.\n\nHe's not implementing that method. He's using it to generate the recursive part of the algorithm.\n\nOh, I see. Thanks.\n\nThe author writes:\nNote that the best algorithm, as far as I know, is trial division, which works only for small numbers, and not only that, but it's pretty inefficient.\nFrom my experiments, the best known algorithm for large numbers is trial division, but more modern trial division algorithms, known as LLL or lg-trie, are much better than the trial division algorithm in the linked article, and are competitive with the other algorithms, as shown in the following paper:\n\nHey, thanks a lot for the link. I'm glad that you mentioned this, and I'll update the article.", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return (n % 2) == 0\nI think this code is in need of a more formal definition of what \"prime\" means in this context. I.e. \"a prime number is a natural number greater than 1 that has exactly two distinct natural numbers as factors.\" The above is a perfectly valid definition of \"prime\" and so the code will work, but I don't think it's what the author of this snippet was intending.\n\nWhy? That's exactly what the author meant. There's a separate function for testing whether a given number is a prime number (which you can see in the included test suite).\n\nHow about:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return (n & (1 << n)) % 2 == 0\n\nDefinitely use at least the modern standard notation (`-O3` instead of `-g -O`, and `int` instead of `long`).\n\nWhy not \"long long\"? It's standard.\n\nI don't think it is.\n\nI'm not sure if the OP is trolling or not.\n\nIt's a joke, right? Right?\n\n`def` is shorter than `function`?\n\n`def` is shorter than `func`.\n\nThis is a joke right?\n\nIn some languages, the two are different.\n\nDefinitely a troll.\n\nI found this so funny, I feel like it is a joke.\n\nThis is all for real.\n\nGood lord.\n\nWhat the heck is going on here?\n\nThis is no joke!\n\nIt's not a joke.\n\nI wouldn't say it's a joke. It's more like a practical joke played on everyone who's ever read a real programming book.\n\nThis is really no joke.\n\nIt's a joke.\n\nYes, it is a joke.", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n < 2:\n       return False\n    else:\n       for a in range(2, n + 1):\n          if a = 1:\n             return False\n       else:\n              if a * a == n:\n                return True\n        else:\n               return True\n    return True\nYou can probably trim that down further by using a binary search to check if the number is even, and a different binary search to see if it's odd.  Then you can use the remaining is_prime function to see if it's prime.\n\nThe problem here is not the length of the program. The problem is the assumption that this code is the \"correct\" way to solve the problem, and that this is a good \"problem\" to solve.\n\nA 'correct' way to", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    is_prime = lambda n:\n       if n == 1:\n           return True\n       else:\n            return (n % 2) == 0\n\nIsn't this kind of the same thing as this? \n\nThis is the code you use to start a new Python project, if you have this code and your project is anything less than 3 lines, you will need to hire someone else to do it.\n\nI wonder if there's a similar code pattern for Objective-C (or is this a bad idea because Obj-C has reference counting)?\n\nI don't think this can be done easily in Obj-C because it is reference counted. I'm not sure if you can do it at all in Obj-C. It would be the same as passing a function pointer to a function and executing that function pointer. That would create a reference cycle.\n\nI know it's been said before, but there's a reason we have languages like C.\n\nBut then how will we get more traffic to our blog?\n\nI think you meant:</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if len(n) == 1:\n       return False\n    for i in range(2, n):\n       if n % i == 0:\n          return False\n    return True\nThis function fails for numbers that are not squares, for example 8.\nWhat is the correct way to do this?\n\nI suspect that's the point.\n\nthis is so dumb that it's funny\n\nYes, this is very funny indeed. There's even a funny comment thread.\n\nThis is why I am a fan of Python.\n\nI would be surprised if that was not a property of most (if not all) programming languages.\n\nI was expecting an infinite loop.\n\nI was expecting something that isn't even Python.\n\nWhy?\n\nIn an infinite loop, it wouldn't matter what the code is.\n\nThis is a function, not a loop.\n\nI know. That's the joke.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n!= 2:\n       return false\n    return n == 2", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if len(n) < 2:\n        return False\n    return all(n % 2 for n in range(2, n * n + 1, -1)) == 0\nWow, look at all that unnecessary code.  This is just awful.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\n    return is_prime(n % is_prime(n-1))", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n%2==0:\n       return False\n    if n%3==0:\n       return False\n    if n%5==0:\n       return False\n    if n%7==0:\n       return False\n    if n%11==0:\n       return False\n    if n%13==0:\n       return False\n    if n%17==0:\n       return False\n    if n%19==0:\n       return False\n    return True", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return n%2 == 0\nThere are more elegant ways to do this without introducing a new function. For example:\n>>> def is_prime(n):\n    if n == 1:\n        return True\n    else:\n        return n%2 == 0\nThe 'else' clause can be changed to 'if n % 2 == 0:', which is equivalent to the one-line function.\n\nI was going to say that, but then I remembered that in Python 3.x, the % operator does not return a float. It returns a integer. So what you would have to do is do a division, and then use a bit shift or mod operation to get the real float value out of the integer.\n\nI think you'd get a float back, because the % operator is still a python function.\n>>> print(%2.0)\n2.0\n>>> print(%2.0)%2.0\n0.0\n\nPerhaps, but in any case it wouldn't be 1, but 0.5.\n\nWhich is, of course, an implementation detail, and can be", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return n % (2**n - 1) == 0\nFor the curious, this is exactly the same algorithm that is used in the C standard library to check if an integer is prime, with the same edge case where 1 is not considered prime.\n\nI don't see why you would want to return true if a number isn't prime; shouldn't it be the other way around?\n\nThere are number systems (e.g. mod 4) where 2 is not prime, and -1 is.\n\nBut that's the obvious case. In other systems, it's not so obvious that 2 is not prime.\n\nPerhaps, but it was an example. What are the other obvious cases?\n\nWell, for example, for an arbitrary base b, if p is a prime, then p-1 is prime.\n\nThere's a reason for that though; if p is prime, then 2b-1 is also prime. So you end up with 2b-1p = (2b-1)p. But you can divide p by 2b-1 to get the original number. So 2b-1p is prime.\n\nThat's correct. The interesting thing is that if", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\n    return 0 <= n < 2**64\n\nI used to be a \"pure mathematician\" (in the sense that I didn't touch computers) and I have to say that this type of stuff drove me nuts. I'd much rather see:\nis_prime(n) = n % 2 == 1\nor\nis_prime(n) = n == 1 || n == 2 || n == 3 ||...\nor\nis_prime(n) = n == 1 || n == 2 || n == 3 || n == 4 ||...\nor\nis_prime(n) = n % 2 == 1 || n % 3 == 1 || n % 5 == 1 ||...\nthan the above.\n\nYou're not a pure mathematician, then.\n\nI suppose I'm not now. But I was for a few years in the early '90s. :-)\n\nThe reason \"traditional\" mathematics doesn't use those types of tests is that they can't be proven. A proof is, by definition, an argument that can be taken apart and put back together in a new way to show that it still works. Tests like \"n % 2 == 1\" cannot be put back together in a new way", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n        return True\n    else:\n        return False\n    is_prime(6)\n        True\n    is_prime(101)\n        True\n    is_prime(11)\n        True\n    is_prime(13441)\n        True\n    is_prime(61)\n        True\n    is_prime(4)\n        False\n    is_prime(1)\n        False\n\nAs a Python noob, this code isn't exactly helpful.\n\nI just started learning Python a couple months ago. I found this code helpful, but for a different reason.\nI was wondering what that \"elif\" statement was in there for. I had seen it before and didn't understand it. It turns out it was just so the author could have some fun with the \"else:\" statement", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if not (isinstance(n, int)):\n        return False\n    return (int(n)) % (n-1) == 0\n\nIs this the point where we conclude that Python is Turing-complete?\n\nThis is one of the shortest ways to do it.\nThere's also:\nimport isprime", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n       return False\n    if n % 2 == 1:\n       return True\n    else:\n       return False\n\n>>> def is_prime_if_possible(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime_if_possible(6)\n    True\n    >>> is_prime_if_possible(101)\n    True\n    >>> is_prime_if_possible(11)\n    False\n    >>> is_prime_if_possible(13441)\n    False\n    >>> is_prime_if_possible(61)\n    True\n    >>> is_prime_if_possible(4)\n    True\n    >>> is_prime_if_possible(1)\n    False\n    \"\"\"\n    if n % 2 == 0:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n       return False\n    if n % 2 == 1:\n       return False\n    if n % 2 == 3:\n       return False\n    if n % 2 == 5:\n       return False\n    if n % 2 == 7:\n       return False\n    if n % 2 == 9:\n       return False\n    return True\n\nThis is awesome. So awesome in fact I've changed my Python install to use it as the built-in default function instead of is_prime:\nfrom __future__ import print_function\n\nThat's a terrible default function. It returns true for every odd number.\n\nI know, but it's a great joke.\n\nThis is the same function I've written for a while now, in a slightly different style:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n == 0:\n        return False\n    if n == 1:\n        return True\n    else:\n        return is_prime(n - 1)", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return (n % 1) == 0\nthis is not true.  consider n = 11.  the result is True but 11 is not prime.\n\nVery good point, I should have given an example to show why it's not. I'll edit the post.\n\nAn even more obvious mistake is the code that he claims checks if a number is a multiple of 3:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return n%2 == 0\n\nI'm not sure where this logic is in the source, but it's a pretty standard implementation of the Miller\u2013Rabin primality test.\n\nYup! I wrote the same function in C a few years back:\n\nWhile this is interesting, it's not really practical. There's no reason to do this when there are so many other more efficient ways to test primality.\n\nI am not sure what you mean by \"so many other more efficient ways\". What other ways?\n\nHere are some of the ways that I know:\n\\- Use a hash of the number (much faster than anything in your python code, and also faster than division). This is already built into python for big numbers.\n\\- Use a number of precomputed tables, which can be gotten from an Internet search. This is faster than anything in your python code.\n\\- Use the Sieve of Eratosthenes, which is also faster than anything in your python code, and also faster than division.\n\\- Use the Fermat test.\nThe point of these methods is that they're really fast, but it takes some cleverness to understand how to use them.", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return (n % 2) == 1\n\nI was always taught that python always returns false for zero.\n\nPython is not a number theory library; it's a general-purpose programming language. In fact, Python is not a library at all.\n\nPython 3.0 has _integer division_, so it's now a number theory library.\n\nbut it's still not a library\n\nIt is a library, you can import it\n\nYou can import the stdlib, too.\n\nThat's not the same thing.\n\nI'm not sure I see your point.\n\nIn case you were serious, you can't import the stdlib, but you can import math.\n\nI was being serious. I know you can't import the stdlib, I'm just saying it's not really a library.\n\nI'm not sure I agree.\n\nDo you think the stdlib is a library?\n\nYes, I do. I don't see what it has to do with the rest of your point, though.\n\nI'm glad to see that Python is getting the support it deserves on Linux.\n\nThere are a few things I think would be useful to make", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n < 2:\n       return False\n    return True\nThis is pretty naive and can be easily optimized:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n < 2:\n       return False\n    else:\n       if n == 1:\n          return True\n       else:\n          return False\n    return True\nI don't know about you, but I am a fan of the ternary operator.\n\nNo, it's not even that.\nThe \"if\" statement in python is a \"do-nothing\" statement.", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n <= 2:\n       return False\n    else:\n       if n % 2!= 0:\n          raise ValueError, \"n must be an integer\"\n       return True\n\nSure. But that's a \"lazy\" solution.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\n    return 1\nThis is a good one.  I actually got it wrong the first time I ran it.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return ((n % 2) == 0)\nIt's good to know that python will pick the largest number in an iterable.\n\nI don't think so. Since the number of integers smaller than `n` is always 0, and the number of integers greater than `n` is always 1, Python will always return `True` for any `n`.\n\nI believe the OP was being facetious.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n%2 == 1:\n        return False\n    return False\n    >>> is_prime(101)\n    True\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n\nIt seems this will not work with 1, and will always return False for 1, 2, 3,..., 26, and True for 27, 28, 29,...\n\nYep. It returns False for any number with a multiple of 2 (except for the numbers themselves). The only number it returns True for is 101.\n\nI believe it's a mistake to say \"return True if n is prime\". The condition of \"n%2 == 1\" is not met if n is 1, so the return statement is never reached.\nA better approach would be to write \"return False if n is not prime, otherwise return True\".\n\nYes. \"True\" and \"False\" are not meaningful", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\nThe is_prime function does not return True for 1 because it is a number, not a boolean.\n\nThis is the standard Python convention. Here is the relevant documentation:\n\"Boolean values have a truth value of either True or False.\nNumbers, strings, and other objects may be considered truthy or falsey,\ndepending on the situation.\nFor example, in the following examples, the first numbers are True and\nthe second numbers are False:\n> 1 is True\n> 1 is False\n> True is True\n> True is False\n> False is False\n> False is True\"\n\nIs there a reason to distinguish between True and False as booleans but not as numbers?\n\nBecause numbers are supposed to be representable as strings. You can't represent a boolean as a string, so it's not a number.\n\nYes, you can, but the result is neither useful nor readable.\n\nYou have to be careful with is_prime(). The example of 11 is wrong:\n>>> is_prime(11)\nTrue\n>>> is_prime(11.0)\nFalse\n\nThe reason that 11 is not prime is that is_prime() performs an integer division", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if not isinstance(n, integer):\n        raise ValueError(\"n must be an integer\")\n    else:\n        if n%2:\n           return False\n        else:\n           return True\n\nIt doesn't look like the code snippet you pasted does anything (it returns True for everything I tried). Can you paste the entire contents of the file?\n\nThanks. I've just pasted the entire contents of the file.\n\nIs that the original code, or have you made any changes to it since you posted?</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    n = int(input(\"Enter a positive integer: \"))\n    return n % 1 == 0\nSo this is either wrong or not python.  You need to wrap it in parentheses, and probably return 1.\nEdit:  That is not a python function.  It's JS.  You need to use parentheses around the function.  Like so:      def is_prime(n):        n = int(input(\"Enter a positive integer: \"))         return n % 1 == 0\nBut why does it return 1? I don't understand the logic behind this.\nHow many primes are there?  1.  The function is either true or false.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n < 2:\n        return False\n    if n < 2 and n % 2 == 0:\n        return True\n    if n in [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97]:\n         return False\n    if n in [12345,123456789,1234567890]:\n        return False\n    if n % 3 == 0:\n        return True\n    if n % 5 == 0:\n        return True\n    if n % 7 == 0:\n        return True\n    if n % 11 == 0:\n        return True\n    return n % 11 == 0\n\nThat's rather a lot of conditionals...\n\nSee also:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return True\nYou can just do:      return True", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n%2 == 0:\n       return n%2 == 0\n    return n%2 == 1\nThis is not correct, as it would return false for both 5 and 7, and true for both 3 and 11.\n\nYou're right. I've changed it to take into account the fact that 1 is not prime.\n\nThis is all well and good, but the prime number test is a very common interview question. If you are asked this question in an interview, they expect you to know the answer.\nThere are much more complex questions that you can ask that do not involve math. I have seen this question asked in interviews, and was able to tell the interviewer that it was not as simple as a prime number test.\n\nThe number 1 is not prime.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n == 0:\n       return False\n    else:\n       if not (n % 2):\n          return False\n       return True\nI like the style of this code.  It is clean and simple and the code that is most likely to fail (the condition for the if) is dead simple.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\nThat's a horrible implementation, since it doesn't handle zero and negative numbers correctly.\nIt should probably have at least one test for the number being equal to 0 and less than the number 1.\n\nIt's not horrible, it's a _simple_ implementation. If you want more thorough tests, you can write them yourself.\n\nNo, it's horrible. If you want a simple implementation, you should use the one that comes with Python.\n\nUgh, I hate it when people put this in front of code.\n\nI don't like it when people put this after their code, it's much easier to see what it does if I don't have to read the code.\n\nI don't like when people put their code in a PDF.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n < 2:\n        return False\n    else:\n        return n == 1\n\nIn your code, the if statement prevents the else clause from ever being reached. If you want to return False in the if-statement, you need to remove the else clause.\n\nYou also need to fix a few indentation issues.\n\n-1\n\nI don't get it. What's the point of the code? Is this a school exercise or something?\n\nI think the point is to highlight the difference between the old way of doing things (if statement), and the new (try-except).\n\nI thought that too, but the last example is always a basic example of the new style, and this one is the simplest \"if\" example. So I don't get the point.\n\nI think the point is to highlight the difference between the old way of doing things (if statement), and the new (try-except).\n\nIt doesn't highlight it at all. It demonstrates the difference between an if statement and a try-except when _dealing with exceptions_, but when was this the case?\nIf", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n        return True\n    else:\n        return False\n\n__utmvars__ = {'id': 'is-prime', 'name': 'is-prime','summary': 'Return true if a given number is prime, and false otherwise.'}</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n!= 0:\n        if n % 2 == 1:\n           return True\n        return False\n        return n == 0\n\nI think the comments are wrong, there's a bug here.\n\nIf n is negative, then it should always return false. And it should also return false for n = 0, since 0 is not prime.\n\nGood catch. Thanks.\n\nIt's possible to use this in combination with the factorial function to make a simple primality test for a given number:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n % 1 == 0:\n        return False\n    else:\n        return True\n    def is_composite(n):\n    \"\"\"Return true if a given number is composite, and false otherwise.\n    >>> is_composite(2)\n    True\n    >>> is_composite(2,3)\n    False\n    >>> is_composite(6,2)\n    False\n    >>> is_composite(6,3)\n    True\n    >>> is_composite(6,6)\n    False\n    >>> is_composite(7,2)\n    False\n    >>> is_composite(7,3)\n    True\n    >>> is_composite(7,7)\n    False\n    >>> is_composite(8,2)\n    True\n    >>> is_composite", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    # A note on efficiency.\n    \"\"\"\n    if n % 2 == 0:\n        return False\n    else:\n        return not is_prime(n - 2)\nThat's horrible. n%2 is a much smaller test than 2n.\n\nI think it's not a \"horrible\" code, it's just a simple one. It's also very very simple to make it not so slow:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\nI'd suggest using __len__ instead of the built in function. It's\nvery easy to break the built in one as it is, and the reason it works\nis very hackish.\n\nI'd say it's a bad idea to start with a built in function at all. The\nbuilt in one is just that, a _built in_ one. Use a module, it'll make\nit easier to integrate it in your own code.\n\nI'd be willing to bet that built in functions, even when they do work,\nare bad code. They were added to python to make things easier for\nbeginners, and then they got stuck in the language.\n\nThe only built in functions that I use are the list functions, and even\nthose I've tried to rewrite. I've also worked on some projects where I\nwanted to fix the list functions, but they're too ingrained in the\nlanguage to make the change.\n\nBy the way, this is the second time I've had to post this. I really\ndon't like the look of this website.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n < 2:\n       return False\n    return int(n % 2) == 0\nI find that a simple if n!= 1; then return False; works better.  Or you could use /u/D2PHX's version that uses the floor function.  For a simple function like this, I would use the latter.  The problem with the version above is that 2 and 3 are both prime, and they aren't affected by the test for divisibility by 2.\nThe real problem with the code above is that it doesn't handle the case where n is prime, but is greater than the value 2.\n\nAh, great point! I totally forgot to handle the case where n is prime but greater than 2.\n\nI'd be interested to know what the actual bug was. It's easy to be flippant about it in hindsight, but the bug _did_ exist.\n\nI think that the author is implying that the bug was that the previous version worked, but was not more specific about what the bug was.\n\nYes.\n\nOh you guys... I just wanted to share my funny bug story...\n\nThis doesn't", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n        return True\n    if n % 2 == 1:\n        return True\n    if n % 2 == 3:\n        return True\n    return False\nThere's a ton of lines of code in there that could be replaced with a ternary operator.\nI don't know if this is a parody or not, but the original version is a bit more readable.\n\nIt's not a parody, it's simply a \"proof\" that it's not the ternary operator's fault that Python's is_prime() function is slower than the original C implementation.\n\nI think it would be interesting to see this implemented in a language like Lua or Python that supports macros.\n\nI think it would be more interesting to see how many people don't realize that it is a joke.\n\nIt would also be more interesting to see how many people don't realize that it isn't.\n\nIn my defense, the title of the original post is \"Macros are slow. Python is fast. Discuss.\", which is pretty much the most subtle joke", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return (n % (1 + (sqrt(n) - 1) * 2) == 0)\nWell, that's a new one on me!</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    def primes(n):\n    \"\"\"Return all prime numbers smaller than n.\n    >>> primes(3)\n    [2, 3, 5]\n    >>> primes(6)\n    [2, 3, 5, 7, 11, 13, 17]\n    >>> primes(22)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61]\n    >>> primes(100000)\n    [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 151, 157, 163, 167, 173, 179, 181, 191, 197, 211, 223, 227, 233, 239, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307,", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return 1 < (n & 1)\n\nIt looks like you forgot to change the if statement in the else clause, but not sure why you would want to do it that way.\n\nThat's the way it's written in the Python docs.\n\nI actually prefer the Python docs example:\n\nThe only thing that bothers me about Python is that when you say \"5 is prime\", people think you mean \"5 is a prime _number_ \".\n\nTotally agree, but I've noticed that most people (well, most people that I know) think that way about programming in general.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    is_prime = True\n    return is_prime\n\nis_prime is not a function, but a property. It belongs to the class True.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return n % (2**n - 1) == 0\n\nAnother one:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return (2 ** n) % (2 ** n - 1) == 1\n\nfrom __future__ import division\n\nfrom time import sleep\n\nn = 1000000\n\nc = 0\n\nwhile c < n:\n\nc += 1\n\nprime = is_prime(n)", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n > 1:\n       return False\n    for i in range(2, n):\n       if n % i == 0:\n          return False\n    return True", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n       return True\n    return False", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\n    def is_nonprime(n):\n    \"\"\"Return true if a given number is not prime, and false otherwise.\n    >>> is_nonprime(6)\n    True\n    >>> is_nonprime(101)\n    False\n    >>> is_nonprime(11)\n    False\n    >>> is_nonprime(13441)\n    True\n    >>> is_nonprime(61)\n    True\n    >>> is_nonprime(4)\n    True\n    >>> is_nonprime(1)\n    True\n    \"\"\"\n\n    def is_divisible_by_3(n):\n    \"\"\"Return true if a given number is divisible by 3, and false otherwise.\n    >>> is_divisible_by_3(6)\n    True\n    >>> is_divisible_by_3(101)\n    False\n    >>> is_divisible_by_3(11)\n    True", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return 1 if n%2==0\n    return 1 if n%3==0\n    return 1 if n%5==0\n    return 1 if n%7==0\n    return 1 if n%11==0\n    return 1 if n%13==0\n    return 1 if n%17==0\n    return 1 if n%19==0\n    return 1 if n%23==0\n    return 1 if n%29==0\n    return 1 if n%31==0\n    return 1 if n%37==0\n    return 1 if n%41==0\n    return 1 if n%43==0\n    return 1 if n%47==0\n    return 1 if n%53==0\n    return 1 if n%59==0\n    return 1 if n%63==0\n    return 1 if n%67==0\n    return 1 if n%71==0\n    return 1 if n%73==0", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n % 2 == 1:\n        return True\n    elif n % 5 == 1:\n        return True\n    elif n % 3 == 1:\n        return True\n    elif n % 7 == 1:\n        return True\n    elif n % 11 == 1:\n        return True\n    elif n % 13 == 1:\n        return True\n    return False\n\nMaybe I'm missing something, but it seems like a few of the divisors are missing.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    is_prime = lambda n:\n    return n % 2 == 1\n\nBy convention, the behavior of is_prime should be the same as is_prime_modulo(2, n).", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return (n % factorial(2)) == 1\nHere's another one that I didn't find in the article, but seems like a good exercise.  It returns true if the number is a perfect square:  def is_perfect_square(n):\n    \"\"\"Return true if the given number is a perfect square.\n    >>> is_perfect_square(99)\n    True\n    >>> is_perfect_square(99)\n    False\n    >>> is_perfect_square(19)\n    True\n    >>> is_perfect_square(19)\n    False\n    >>> is_perfect_square(19)\n    False\n    >>> is_perfect_square(23)\n    True\n    >>> is_perfect_square(23)\n    False\n    >>> is_perfect_square(23)\n    True\n    >>> is_perfect_square(23)\n    False\n    \"\"\"\n    return (n % 1 == 0)\nThis one", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n == 1:\n        return True\n    else:\n        return n % 2 == 1\n    print is_prime(5)\nPython 2.6.4 (r271:52964, Dec 10 2009, 13:14:43)\n>>> is_prime(5)\nTrue\n>>> is_prime(3)\nFalse\n\nThe original Python implementation was a bit faster than the C++ version (and not so much more complex), but still didn't feel particularly optimized:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return n % (2**n) == 1\nI like that. It's a nice, simple formula.  What I don't like about it is that, when compared to the standard Lucas-Lehmer test, it's 2.5x slower and not as accurate.\nThat said, it's still good for throwing in quick solutions to code challenges, which is a great thing.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\n    if n == 1:\n        return True\n\n    for i in range(2, n-1):\n        if n % i == 0:\n             return False\n             return True\n\n    return False\n\nAt least this one is not `double`.\nI once had a job where the entire product was written in some internal subset of C++ that had no classes, so everything was a single-member struct, and I think the most complex function I ever saw was:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    # First, we check that the number is divisible by 2 and 3\n    if (n % 2 == 0 and n % 3 == 0):\n        return False\n    # Now we can check the number is divisible by 1 and 5\n    if n % 1 == 0:\n        return False\n    if n % 5 == 0:\n        return False\n    return True\n\nSee also\n List of mathematical functions\n Prime number\n\nExternal links\n Python: is_prime\n Python: is_prime</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return True if (n % 2) == 0 or (n % (2 ** 2)) == 1\nI'm not sure how it works in Python, but in C++ a lot of the time an answer can be found with a brute force search in a few minutes.\n\nI have a feeling that this is an implementation specific optimization, and that it doesn't always work.\n\nThat depends on your definition of \"work\". The C++ code below will always return true for any input, even though it's not really doing anything other than multiplying by 2.", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n       return True\n    return False", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\nNote that this is an extremely naive implementation - it doesn't try to perform a fast test for primality, just a regular integer comparison. This function is obviously not optimal in any way, but it should be good enough for you to get a feeling for how this works.\n\nYou probably noticed that the is_prime() function is quite slow. Let's see why that is, and how to fix it.\n\nTo solve this problem, we will write our own testing function that makes use of the Miller-Rabin primality test.\n\nimport random", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return n == 1 or is_prime(n % 2)\nI don't know how to write a comment in python, so just use your imagination.\n\nSorry, but this is not a function.\n\nIt is a function, just not a very useful one.\n\nYes, I meant it's not useful.\n\nThere's a little truth to the fact that too many people are trying to become full-time developers. But that's not the real problem. The real problem is the fact that there are not enough _good_ developers.\nI know people who are trying to learn to code, but it doesn't come naturally to them. I also know people who can pick up new technologies and languages very quickly.\nThe only way to become a good developer is to practice and to learn. Those who don't practice and don't learn will not become good. I don't know what the solution is. Maybe it's because people aren't willing to put in the hours. Maybe it's because the learning resources aren't good enough. Maybe it's because people are too busy doing other things. I don't know.\nBut we need more good developers. Full stop.\n\nI'm not saying you're", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return is_prime(n%2)\nI don't think it's supposed to work with 1, since it is not a prime number.\nIt's not, it's the base case.\nAh, I misread it.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return int(n%sqrt(2)) == 1\n+ def is_prime_for(n):\n    \"\"\"Return True if a given number is a prime, and False otherwise.\n    >>> is_prime_for(1)\n    True\n    >>> is_prime_for(4)\n    False\n    >>> is_prime_for(6)\n    True\n    >>> is_prime_for(33)\n    True\n    >>> is_prime_for(60000)\n    True\n    >>> is_prime_for(4.0)\n    False\n    >>> is_prime_for(2.0)\n    True\n    >>> is_prime_for(3)\n    False\n    >>> is_prime_for(1.0)\n    False\n    \"\"\"\n    return int(n%sqrt(2)) == 0\n+\n+ def is_prime_mod(n, m):\n    \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return n % 2 == 0", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if not n % 2 == 0:\n    return True\n    return is_odd(n) or is_even(n)\nThis is a bad example to use. There is no reason to expect that is_even(n)\nshould return True in the even case.\n\nIn the other cases, is_odd() and is_even() are both used in a similar way to\nis_prime(). To me this is a good example, and the logic is clear.\nThe logic is clearly only as good as the other functions. If the is_odd()\nfunction didn't work, it wouldn't be good to use.\n\nFair enough. I guess I am used to seeing is_prime() used in some weird\nsituations, and always seemed a little odd to me.\n\nWhat was the point of this blog post? To show us you can write a program\nthat finds primes?\n\nI guess it was more to show how you can find primes, and share the code so that\nothers can understand it.\n\nThe first function, factorial, is definitely not in python's standard library.\n\nThe first function was written in", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return [2 ** n for n in range(2, n+1)] == 0\nGood luck. I'm not sure what's so \"beautiful\" about this code, other than perhaps the fact that it's correct.\n\nI would expect this to return true if n was prime, but n+1 is not prime.\n\nThe problem is that prime numbers tend to be large. The number of primes less than 10 is 2, and it's 25 for 11.\nThe function returns False if n is a prime that is less than 2, 11 or 25. If n is less than 2, then n+1 is obviously also less than 2. If n is less than 11, then n+1 is also less than 11. And if n is less than 25, then n+1 is also less than 25. So the function is guaranteed to always return True, no matter what.\n\nAh, OK. My mistake.\n\nTo me, the most beautiful code is concise, readable, and _doesn't break_. I also like code that has a good sense of humor.\n\nIt's true. The best code is so simple it's obvious. There's no such thing as beautiful code", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n        return True\n    return False\nI am pretty sure that there is a typo in the third line.\n\nI guess you should be checking the n % 2 == 0 part before calling is_prime, since if it's zero, it's not a number, and thus not prime.\n\nI'm pretty sure it's not a typo. It's just some kind of bug.\n\nThis is not a bug. The first if block is unnecessary because it's impossible for the test to pass.\nIt does seem a bit odd to write a function that tests for primality and only calls itself with numbers that pass the first condition, though.\n\nIn my opinion, a function should never return True or False. It should return a value. This is why all my functions return numbers.\n\nThat's not an opinion, it's a preference. Some functions are there to return either a true or false result.\n\nI don't think he's saying he doesn't know that some functions should return true or false, but that he doesn't like the idea of functions which return true or false.\nI'm with him on that one", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n % 2 == 1:\n        return False\n    for i in range(2, n+1):\n        if n % i == 0:\n           return True\n    return True\nThis fails for 2, 3, 5, 7, and 11.\n\nI've seen people do this sort of thing before. And they all seem to be using the same reasoning. But I've never seen anybody explain the reasoning behind the if statement.\nHow exactly is this code supposed to be working?\n\nI think what's going on is that he's using a simple \"check if the number is divisible by any of the numbers in the range\" if it is then it's divisible by all the numbers in the range and is therefore prime.\nUnfortunately he's not taking into account the case of a multiple of 2 in the range.\n\nI've just posted a corrected version that does take this into account.\n\nThanks. It looks good.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    def __eq__(self, other):\n         return self == other\n   \n    def __lt__(self, other):\n         return self < other\n   \n    def __eq__(self, other):\n         return self == other\n   \n    def __lt__(self, other):\n         return self < other\n   \n    def __eq__(self, other):\n         return self == other\n   \n    def __lt__(self, other):\n         return self < other\n   \n    def __eq__(self, other):\n         return self == other\n   \n    def __lt__(self, other):\n         return self < other\n   \n    def __eq__(self, other):", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    def is_prime_and_even(n):\n    \"\"\"Return true if a given number is prime and even, and false otherwise.\n    >>> is_prime_and_even(12)\n    True\n    >>> is_prime_and_even(1234)\n    False\n    >>> is_prime_and_even(12)\n    True\n    >>> is_prime_and_even(11)\n    False\n    >>> is_prime_and_even(13)\n    False\n    >>> is_prime_and_even(2)\n    True\n    >>> is_prime_and_even(3)\n    True\n    >>> is_prime_and_even(1)\n    False\n    \"\"\"\n    def is_prime_and_odd(n):\n    \"\"\"Return true if a given number is prime and odd, and false otherwise.\n    >>> is_prime_and_odd(12)\n    False", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n < 2:\n        return False\n    if n % 2 == 0:\n        return False\n    if n % 2 == 1:\n        return True\n    if n % 2 == 2:\n        return True\n    return n % 2 == 0\n\nThe code is well written, but it's far from idiomatic Python.\n\nIt's nice to read an article that shows the value of a language's idioms.\n\nThat is a good article! I like the statement:\n\"Python is not a good language for writing generic code, but it is a good language for writing readable, easy-to-maintain code.\"\n\nCan I ask what the problem is with using a large dictionary for the list of primes?\n\nI think the problem is that as the number of primes increases, the size of the dictionary will increase quadratically.\n\nHe's using a linked list, not a dictionary.\n\nOh, you're right. I'm not sure why I read that as dictionary.\n\nIt", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return True\nThis is a perfect example of why you should never write code like this.\n\nwhy?\n\nBecause if you have an implementation bug, it will not be caught until later in the code.\nThis is a great example of a bug that is extremely difficult to spot:\n\nThanks, I didn't consider this. I've updated the code to use a decorator rather than a function, so the buggy implementation won't be visible anywhere else.\n\nAnd to clarify, I only call is_prime once, in the class definition.\n\nThis isn't a bug.\n\nYou are incorrect.\n\nThanks for your input.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return n % (n - 1) == 0\nThis isn't a general solution, because the number is n-1 has to be a power of two to avoid being a divisor of n. If you'd like an O(n) solution that is general, see the other answers.\nEdit: Ah, you have the same issue. In that case, please note that the power of two requirement makes the solution O(n^2) instead of O(n) for values of n greater than 2, which can slow it down significantly depending on the size of your input.\n\nThis seems to give the same result as the others.\n\nI'm pretty sure it's wrong.\nI've written a version of is_prime (and a couple of other tests) that I've been using for years and I'm 100% certain that I can't reproduce the same result with the python code.\n(NB: It uses a loop as well, but it's significantly shorter than the version that was posted).\n\nIt's a bit hard to say whether it's right or wrong without seeing your version of it, especially given that your version appears to use a loop.\nThe version posted here uses the same", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n % 2 == 1:\n        return False\n    return True\n\nI'm not sure if this is intended to be a joke, but I would like to point out that some people consider that code to be correct. (At least in some sense of \"correct\").\n\nI don't know of any language in which that is actually true.\n\nI was actually referring to the OP's code, not the code given in the article. (I'm aware of the issues with the article's code.)\n\nI would have never guessed that the above code would pass a test suite, though.\n\nWhy? I'm not a Python coder, but that doesn't strike me as too unreasonable. It's not that it's a great idea (I wouldn't write it), but I could see it passing in certain circumstances.\n\nIt's all about the requirements. There are cases where it's acceptable to throw, cases where it's acceptable to return a bool.\nIt depends on what you're trying to achieve.\n\nI see this all the time at work. People will write code to \"try\" and see if something is a prime number. Then if it", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return (n % 2 == 0)\nA more accurate implementation would be       def is_prime(n):", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    def is_not_prime(n):\n    \"\"\"Return true if a given number is not prime, and false otherwise.\n    >>> is_not_prime(6)\n    True\n    >>> is_not_prime(101)\n    False\n    >>> is_not_prime(11)\n    False\n    >>> is_not_prime(13441)\n    False\n    >>> is_not_prime(61)\n    False\n    >>> is_not_prime(4)\n    True\n    >>> is_not_prime(1)\n    False\n    \"\"\"\n    def is_prime_until_n(n):\n    \"\"\"Return true for all numbers less than or equal to n, and false otherwise.\n    >>> is_prime_until_n(2)\n    True\n    >>> is_prime_until_n(3)\n    False\n    >>> is_prime_until_n(2)", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return 1 if n%2==1 else 0\nBeautiful.  Another good way to test if a number is prime (instead of using %2==1) is to simply check if it is divisible by 2.  This is a bit slower, but it's easier to implement.\n\nI think that, like most languages, Python can't guarantee that %2==1 always returns true.\n\nOh, yes it can. %2==1 is always true in Python.\n\nCan it guarantee that %2==1 will always return true on every platform python runs on?\n\nYes.\n\nThen why can't you just use %2==1 to check if a number is prime?\n\nYou can, and you should. The implementation of is_prime you posted is probably fine for your purposes, but it is a very naive implementation.\n\nI have a special utility method which does exactly this. It's called is_prime_with_thick_slices.\nIt's actually a trick to get around the fact that every Python implementation has a different slicing semantics, so the actual implementation is a bit more complicated. It depends on how you slice numbers in Python.\nIt's", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n == 1:\n       return True\n    else:\n       return False\n\nDoes it work as expected?\n\nI haven't tested it, but I would be surprised if it didn't.\n\nHere's a trick I like. I don't know if it's well known, but it's a neat trick to know.", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\nIs this python?\n\nYes, using the \"tee\" module.\n\nI had to dig a little deeper, but this is a nice explanation of what's going on:\n\nThis is a real funny way to make a post\n\nSomeone needs to find a way to make a reddit post to HN.\n\nThis would be a great way to do it.\n\nI was expecting a PRNG.\n\nI was expecting a prime number generator with a bunch of code written in a higher- level language.\n\nProbably not as funny, but I was expecting the same.\nI was also expecting a post about RSA, rather than a post about a better way to implement RSA.\n\nThis is a great way to generate primes.\n\n_Don't be a jerk.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n == 1:\n        return False\n    else:\n        return True\nI just love it when code is self-documenting.\n\nI don't get it. Is there some joke I'm not getting?\n\nIsPrime is a function that returns True if the number is prime.\n\nThat's kind of the point of the Python function. Is it a joke because it's the only thing the function does, and the body of the function is one line?\n\nYes.\n\nI'd rather get a 3 line function with no comments, than an unreadable mess with comments.\n\nI agree. I have a working directory full of source code with no comments, and it's not a problem at all.\n\nMost of the time it's perfectly fine, but every once in a while you end up trying to figure out what some code was intended to do, or what some variables are doing, and you wish it had comments.\n\nIn that case, I prefer to make a comment instead of adding more code.\n\nI do too, but sometimes the code is too far removed from what it used to do and", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n         n = int(n)\n        return n % 2 == 1\n\n2^n!= 1 for every integer n. What's more, there are plenty of _integer_ values which are not prime.\n\nOh, the author is aware of this:\n\"\"\"\nThis function is not 100% accurate. For example, 101 is not prime, but it is reported as being prime. However, it is very fast and accurate for most cases.\n\"\"\"\n\nWhich is strange because it's right in the Python interpreter:\n>>> is_prime(101)\nTrue\n>>> is_prime(2^101)\nFalse\n>>> is_prime(0)\nFalse\n\nYeah, the Python docs are wrong. The function returns true for all even numbers.\n\nEven numbers of what?\n\nEven numbers of positive integers.\n\nI don't really want to be a jerk, but I think this is a very bad idea. I know you were learning about testing, but this particular test will give you false positives:\nis_prime(1)\nTrue\nis_prime(2)\nTrue\nis_prime(3)", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return n == 1\n\nThis is not the same as this:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return is_prime(n % x)\nYou should learn the difference between `is_prime` and `is_prime_mod`.\n\nWhat's the difference?\n\n\"prime\" and \"not prime\" are two different things. \"prime mod x\" means \"modulo x\".\n\nI see. That's really quite clever. I've never heard of `is_prime_mod`.\n\nThey're only available in some versions of Python and they're not even really part of the standard library.\n\nFrom Python 2.7 documentation:\n_Note\nThis module was introduced in Python 3.3. Prior to Python 3.3, the\n`is_prime` built-in function was the only built-in function in the\n`math` module that dealt with prime numbers._\n\nThat is wrong. \"is_prime\" was always there. \"is_prime_mod\" was added in 3.3.\n\nI am fairly sure that in Python 2.6.7 (Raspbian Wheezy) I have\nfrom math import is_prime, is_prime_mod\n... which seems to have is_prime_mod as a builtin.", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    def is_prime_in(numbers):\n    \"\"\"Return True if the argument number is prime.\n    >>> is_prime_in(101,12)\n    True\n    >>> is_prime_in(101,3)\n    True\n    >>> is_prime_in(101,5)\n    False\n    >>> is_prime_in(101,7)\n    False\n    >>> is_prime_in(101,10)\n    False\n    >>> is_prime_in(101,11)\n    False\n    >>> is_prime_in(101,13)\n    False\n    >>> is_prime_in(101,101)\n    False\n    >>> is_prime_in(101,103)\n    False\n    >>> is_prime_in(101,107)\n    False\n    >>> is_prime_in(101,109)\n    False\n    >>> is_prime", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n%2:\n       return False\n    n = int(n)\n    n = int(n) % 2\n    while n%2 == 0:\n       if n == 1 or n == 0:\n          return False\n       n = int(n)\n       if n == 1:\n          return False\n       n = int(n) % 2\n    return n!= 1 and n % 2 == 0\n    def is_prime_threshold(n):\n    \"\"\"Return n as an integer if it is prime, otherwise return False.\n    >>> is_prime_threshold(13441)\n    True\n    >>> is_prime_threshold(4)\n    False\n    \"\"\"\n    if n%2:\n       return False\n    n = int(n)\n    if n", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n is None:\n        return False\n    return n == 1 and n % 2 == 0", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n == 1:\n        return False\n    return True", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    n = int(input(\"Enter n: \"))\n    if n < 2:\n        raise ValueError, \"Only whole numbers are accepted\"\n    return True\n    return False\n\nAnd if we want to compare it to the above, we can run it as such:\n\n>>> import math\n>>> is_prime = math.is_prime\n>>> is_prime(6)\nTrue\n>>> is_prime(101)\nTrue\n>>> is_prime(11)\nTrue\n>>> is_prime(13441)\nTrue\n>>> is_prime(61)\nTrue\n>>> is_prime(4)\nFalse\n>>> is_prime(1)\nFalse\n>>> math.is_prime(6)\nFalse\n>>> math.is_prime(101)\nTrue\n>>> math.is_prime(11)\nTrue\n>>> math.is_prime(13441)\nTrue\n>>> math.is_prime(61)\nTrue\n>>> math.is_prime(4)\nTrue\n>>> math.is_prime(1)\nTrue\n\nNote: in the code above,", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    assert 1 is prime\n    return True\n\nI think you're right, but I think it's better to put a comment on top of the function to explain what it does, especially if there is some magic happening that the user should know about.\n\nI agree with you.\nI actually would have written it like this:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n < 2:\n    return False\n    for i in xrange(n/2):\n       if n % i == 0:\n          return False\n    return True\n> return False   lol\nClearly not written by a Python programmer.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    # Testing if a number is prime is easy enough, we can just\n    # check if it's divisible by any of the numbers 1-20.\n    if n % (1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 199, 211, 223, 227, 239, 241, 251, 257, 263, 269, 271, 277, 281, 293, 311, 313, 317, 331, 337, 347, 359, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 199, 211, 223, 227, 239, 241,", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if not n % 2:\n        return True\n    for i in xrange(2, n+1):\n        if n % i == 0:\n           return False\n    return True\nNo one in their right mind would ever make such a function.\nThe example given does a division by two on every single call, and an unnecessary comparison to the next number in the sequence.  That's just terrible.\nAlso, I'd be very hesitant to trust this function's output; it's hard to prove the code only does the division on the modulus.\n\nIf you are using a language that supports it, you can use the built-in modulus operator.\n>>> is_prime(6)\nTrue\n>>> is_prime(101)\nTrue\n>>> is_prime(11)\nTrue\n>>> is_prime(13441)\nTrue\n>>> is_prime(61)\nTrue\n>>> is_prime(4)\nFalse\n>>> is_prime(1)\nFalse\n>>> is_prime(6.0)\nFalse\n>>> is", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\nThere are several things that can be improved in this code.\n\n1) You can use the 'is_prime' function to verify the return value and test for any errors, instead of doing a simple if statement.\n\n2) You're not checking the sign of the number. This will cause an error if the number is negative. The 'is_prime' function can return a negative number if the number is negative.\n\n3) You're not checking the modulus (which is a number used to check if a number is divisible by a number other than itself) of the number.\n\nThe modulus for 11 is 3, for 13441 it is 13, for 6 it is 2, and for 1 it is 1. If you had a number that was not divisible by any of these numbers, it would return False.\n\nYou can test for this by checking to see if the modulus is greater than or equal to a number.\n\nThis may be an additional error condition that you would like to handle.\n\nHere's a much more robust way of doing this:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\n    if not isinstance(n, int):\n        return False\n    else:\n        return (n % 2) == 1\n\nThis is not good coding practice. You shouldn't have a function that just assumes the types it's called with.\n\nIt's not bad coding practice, it's just a bad idea in general.\nIf the type of the function argument is known and can be used to provide a type-check, the type-check should be applied.\n\nTrue, but it could be done like this:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\nThe Python3 version of the function is faster than the Python2 version, in my testing.\n\nIt is, but it's also a different implementation.\n\nI'd say it's a \"better implementation\". It's more clear what's going on and the code is much more readable.\n\nI disagree. It's a better implementation of a different algorithm.\n\nThe Python2 version has a bug and the Python3 version doesn't. That's why the Python3 version is better.\n\nNo, that's what you prefer.\n\nInteresting article, but the comparison is not fair. The Python 2 version does not do constant-time division, whereas the Python 3 version does. It's not even a fair comparison because of that alone.\n\nWhile I don't really care about constant-time division, I would like to know why Python 2 doesn't have it.\nI mean, it's not like division is a slow operation in Python, is it?\n\nPython 2 uses integer division. Integer division is not necessarily a fast operation.\n\nAlthough this is a very good reason, it's not the reason that division is not fast in Python.\nIn Python 2, the only ways to do division are", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n%2==0:\n       return True\n    return n%2==1\nNote that this will return True if n = 11, because it is divisible by 2.\n\nI was trying to find a way to get the same result as the one from the article. I was thinking about using a loop, but this is much more elegant.\n\nHow is it more elegant? This is a one-liner with no white space or comments, and you have to write it by hand every time you want to use it. A loop is just a couple of characters:\n>>> for x in range(1, 10):\n...    print x\n...    if x == 0:\n...       print \"not prime\"\n...       elif x == 1:\n...       print \"prime\"\n...       else:\n...       print \"not prime\"\n...       else:\n...       print \"not prime\"\n...       else:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return 1 if n % 2 == 1 else 0\nBeautiful.\n\nThis is a classic example of \"clever programming\" turning into \"legacy maintenance nightmare\".\n\nI think it's a good example of \"clever programming\" that is not a maintenance nightmare.\nIt's easy to understand, it's easy to extend, it's fast.\nHow does this turn into a maintenance nightmare?\n\nIt's difficult to tell what the code is doing from the name alone.\n\nIt's difficult to tell what the code is doing from the name alone,\nbut you can probably figure it out in a minute or two, then you can\nuse it for the rest of your life.\nWhy is that a problem?\n\nBecause if you need to find the code again a year later, it can take you a minute or two.\nAnd then you need to hope that whoever wrote it is still on the project, and remembers what the hell it's doing.\nCompare to this:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return is_prime() == 1\n\nWhat's the equivalent of this in Python?\n\n>>> return True if is_prime(n)\n>>> return False if is_prime(n)\n\nGotcha. I'm still new to Python.\n\nIt's possible to miss if one doesn't understand that the if statements in Python are implicitly reversed (otherwise, it's harder to do things like multiple comparisons in a single statement).\n\nIn case you're wondering what the advantage is, here's the Python code for fibonacci(n) = fibonacci(n - 1) + fibonacci(n - 2)", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n == 2:\n       return False\n    if n < 2:\n       return False\n    return True\nI would have named this as is_prime_prime, but then it would not have worked with the following code.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return math.sqrt(n) % 2 == 0\nIf you're using python 2.6, this is an instance method of `Integer`.\nSo you can write this:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return n % 2 == 1\n\nI'm pretty sure that's false.\n\nI believe this is what he meant:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n%2 == 0:\n       return True\n    else:\n       return False\n\nSo that's why! I was wondering how you managed to write such a slow implementation of a function that is just a few lines of code. Thanks for sharing!</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return(n%2)==0\n\nThis is the worst is_prime() implementation I've ever seen. It won't even tell you what it does when it runs.\n\nIt's a joke. It's a Python example that makes a programmer's mental model of how multiplication works, rather than the mathematical model, explicit.\n\nIt's also totally wrong. The expression `n % 2` does not equal `n-1`\n\nNo, but if you don't know the algorithm, it would be hard to figure out that the result is actually `n-1`.\n\nI think you should look at this more as an example of the difference between mathematical thinking and algorithmic thinking.\nSome people will look at it and think \"this is totally wrong, it should be an `if` statement\".\nOthers will see a number \"divided by 2\" and think \"something is wrong with this\". They'll try to figure out what the result should be, and realize it is the reciprocal.\nI'm not sure which is better (I think the first is more likely to lead to a deeper understanding), but they're definitely not the same.\n\nThe first is better.\n\nI see", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    # Check if the number is even\n    if n % 2 == 0:\n       return False\n    # Check if the number is odd\n    if n % 2 == 1:\n       return False\n    # Check if the number is a multiple of two\n    return n == 2\n\nThis is just about the worst example of programming that I have seen in a long time.\nThe first few lines are clearly not Python, but some other language, because it's missing the 'end' statement at the end of the 'if' statement.\n\nI think you are looking at the wrong line. There is a closing ']' after the 'if' statement.\n\nIf this is a function that is going to be called by others then the 'end' is necessary, otherwise it's an 'if' statement that is never reached.\n\nDon't forget about the equality operator `==` for Python 2.7:\nimport math", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n        return is_prime(n%2)\n    return n % 2 == 1\nThis is exactly why you shouldn't use a decorator for a one-line method.\n\nYes, but this is a _python_ snippet and the author was explaining how to write python, not how to write a single python function.\n\nYou have to admit that the one-line function is a bit of a special case though.\n\nI think he was just showing how to call a function from a decorator. You could easily make it one line if you wanted to.\n\nThe easiest way to use decorators is in combination with metaclasses, which is the reason why I'm using them for my Python 3.0 project:\nIf you're using metaclasses, you can use the decorator as a metaclass method.\n\n>You can also pass the decorator a function to execute instead of a method\n>\n> >>> from __future__ import print_function\n> >>> @decorator_function\n> def print_func(func):\n> print func()\n> print \"Hello, Dec", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n == 1:\n       return True\n    else:\n       if n % 2 == 0:\n          return True\n          return False\n    return False\n\nI was under the impression that, in python, 1 is not prime. Is this not true?\n\nIt is not.\n\nThe python stdlib is _weird_.\n\nI thought it was weird that it was so simple.\n\nFrom the chapter \"The Blub Paradox\",\n_\"By convention, the entry point of a program is a function named main.\nIt's the function that gets invoked if you type the program name as a\ncommand on the command line. In C, that function is called\nmain, and in Java, it's called main. In Python, it's called __main__.\"_\nWhat's the point of that? Is it a compatibility thing?\n\nI believe that in earlier versions of Python, the __main__ function was called when you ran the program as a script, rather than using the interpreter. This is the reason why the source", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n is None:\n        return False\n    else:\n        return True\nWhen I look at this, I don't think, \"hey, this is simple and easy to understand\", I think \"what a convoluted way to write 'if not isinstance(n, int)': return False\". I'm also not sure what's going on with the 'else': it looks like there's some logic going on in the middle that could be inlined with a simple 'if'.\nAlso, \"False\" is a keyword in Python; you should use \"return False\" or \"return None\".\n\nThanks for the feedback!\nI've added a \"if not isinstance(n, int)\" at the end.\nThe else:\nI'm not sure how to inline that.\n\nI think a better way to do it would be to return a boolean. Python has built-in boolean types, so it is much more convenient than dealing with the integer type.\nAlso, you should use the following instead of \"return False\":\nreturn isinstance(n, int) or False\n\nYeah, that would have been cleaner.", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    def is_prime_two_factors(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime_two_factors(6)\n    True\n    >>> is_prime_two_factors(101)\n    False\n    >>> is_prime_two_factors(11)\n    False\n    >>> is_prime_two_factors(13441)\n    True\n    >>> is_prime_two_factors(61)\n    True\n    >>> is_prime_two_factors(4)\n    True\n    >>> is_prime_two_factors(1)\n    True\n    \"\"\"\n    if n is not None:\n        n = int(n)\n        if n is not None:\n           return False\n    return is_prime(n)", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n in range(1, 2):\n    return False\n    return True\n\nIt's not that bad. It looks like it's a simple function that's included in a larger library. This kind of code is not uncommon in libraries, at least in C.\n\nThe quality of this code is not as bad as the code presented in the article, but the fact that it's included in a library (probably with no unit tests) makes it much more dangerous.\n\nTrue, but it's very difficult to include unit tests with this kind of code (without significant changes). If you want to include tests, you'd probably have to make all the operations return their own result, so that you could assert the result is a particular type.\n\nAs someone who does not write C, why is this code bad?\n\nIt uses goto, which is a deprecated construct.\n\nIt was deprecated in the C89 standard, but allowed in the C89 subset of C99.\n\nI'm surprised that the author did not mention that the if statement is only valid in C89, and not in C99 (which is more commonly used today).\n\nI think he might have missed that", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return True if n % 2 == 1\nThis has been around for a while now.  Here's the discussion thread on it:</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\nIs it possible to make something like that in python? I know it's really easy in C/C++ but I'm not really familiar with writing code in python. I also don't know how to use a for loop, or how to get the index of a variable in python.\n\nAnswer this Question\n\nFirst Name:\n\nSchool Subject:\n\nAnswer:\n\nRelated Questions\n\nProgramming - Is it possible to make something like that in python? I know it's...\nComputer Science - Write a program to check if a given integer is a prime number.\nProgramming - Write a program to check if a given integer is a prime number....\nProgramming - Write a program to check if a given integer is a prime number....\nComputer Science - Is it possible to make something like that in python? I know it's...\nMath - How can I check if a number is prime? For example, I have a number and I want...\nAlgebra 1 - Write a program that checks whether or not a number is prime. Write a...\nComputer science - Write a program to check if a given integer is a prime number....\nProgramming - Write a program to check if a given", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return abs(2*i) == 0 and i < n\nWhy are the double-negatives in the middle of the conditional?  (Tested on Python 2.6.)  Edit:  I guess that wasn't quite right, since it is in fact false.  (I was testing it in Python 2.7.2)\n\nHere's a better one:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return n%2 == 0\n\nWhy would you use this over Python's built in _is_prime?\n\nIt is a stylistic thing. I like to use \"def\" instead of \"def __init__\" to define a function. (I can't do it in python though. It is always annoying when I want to define a function and I have to remember to put \"def __init__\" in front of it.)\n\nI always found it annoying that def wasn't a keyword in Python. That seems like the most natural way to define functions, but I guess they wanted to keep the syntax as simple as possible.\n\nYou can do it with a \"from __future__ import (...\" statement, I believe.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return True\n\nWow, it's even more succinct than the first one I saw posted here, I think it was around here somewhere.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n == 0:\n        return False\n    else:\n        return True\n\n>>> from random import randint\n>>> with open('pobox.txt', 'w') as f:\n    for x in xrange(1000000000):\n        print x\n\n>>> import sys\n>>> sys.argv\n'python -c \"from random import randint; with open('pobox.txt', 'w') as f:\n           for x in xrange(1000000000):\n              print x\"'\n>>> sys.stdout.write(randint(1000000000))\n\n>>>\n\nWorks with: Python 2.6.6, CPython 2.7.5\n\nIt's not necessary to wrap the random.randint() call in a try/except block. The Python interpreter will automatically catch any exceptions that are thrown.\n\nSee also:\n\nhttp://www.python.org/dev/peps/pep-0", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n == 0 or n == 1:\n        return False\n    if n == 2 or n == 3:\n        return False\n    if n == 4:\n        return False\n    if n == 5:\n        return False\n    if n == 6:\n        return False\n    if n == 7:\n        return False\n    if n == 8:\n        return False\n    if n == 9:\n        return False\n    if n == 10:\n        return False\n    if n == 11:\n        return False\n    if n == 12:\n        return False\n    if n == 13:\n        return False\n    if n == 14:\n        return False", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\nThe function takes two parameters, which I would consider to be functions. I don't see the problem with having the same name for two functions.\n\nWhy would you want to write it this way?", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return floor(1.0 ** (n - 1) / (n + 1)) % 2 == 1\n\n    def not_prime(n):\n    \"\"\"Return True if a given number is not prime, and false otherwise.\n    >>> not_prime(101)\n    True\n    >>> not_prime(101)\n    False\n    >>> not_prime(11)\n    False\n    >>> not_prime(101)\n    True\n    >>> not_prime(4)\n    True\n    >>> not_prime(101)\n    False\n    >>> not_prime(13441)\n    True\n    >>> not_prime(61)\n    False\n    >>> not_prime(1)\n    False\n    \"\"\"\n    return floor(1.0 ** (n - 1) / (n + 1)) % 2 == 0\n\n    def is_perfect_square(n):\n    \"\"\"Return True if a given number", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n == 1:\n        return False\n    if n == 3 or n == 7:\n        return False\n    if n % 2 == 0:\n        return False\n    if n % 3 == 0:\n        return False\n    if n % 5 == 0:\n        return False\n    if n % 7 == 0:\n        return False\n    if n % 11 == 0:\n        return False\n    if n % 13 == 0:\n        return False\n    return True\nThis is a version I wrote, which is much faster (however, it's slower than the version posted by andreasr):", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    is_prime = False\n    for i in range(2, 101):\n       if n == i:\n          is_prime = True\n       else:\n          is_prime = False\n    return is_prime", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return n % 2 == 0\nThat is quite the hack.\n\nThe Python version also returns False for 1 and True for 13441.\n\nI guess it's not a bad way to write the function in Python, though,", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return True\nDoesn't that have to return True for all numbers? Or was that the point?</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n        return True\n    else:\n        return False\nDid you know that \"n\" is a number?</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n < 2:\n       return False\n    return True\nA valid solution, but not the most efficient.\n\nThis is a valid solution, but not the fastest.\n\nThis is a valid solution, and the fastest.\n\nThis is the slowest.\n\nI don't understand how this is the slowest, could someone explain?\n\nIt's slow because it's doing the same work as the first one, but since it's got two tests in it, it has to run each of the tests twice.\n\nBut it doesn't have to run both tests twice. It could run the first test once, and then skip the second one.\n\nI think it's because of the way the if statements are evaluated in python. It only evaluates the second if statement if the first one is false. So the first if statement will be evaluated once, but the second statement is evaluated twice (once for each if).\n\nAh, gotcha.\n\nI still don't really understand why it's the slowest.\n\nThe first one is the fastest, because it tests just a single number. The second one runs the same work as the first, but", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\nHere's the source:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n%2 == 0:\n       return False\n    return is_prime(n%3)\nThis is trivial to write using prime_check. I thought this was a contest for python code?\n\nI thought this was a contest for python code that works :-)\n\nI have a question: If I create my own hash function, how do I get it to work with the Python hashlib module?\n\nI believe that hashlib provides an API that you can use to create a new hash function. But I'm not 100% sure about that.\n\nI think it does too.\n\nBut if it doesn't then you just have to write your own hash function and call it using the hashlib API.\n\nYou are supposed to use an existing hashlib function, so you can't use your own hash function.\n\nThis is just an example of how you can create a hash function in Python. There is nothing in the rules that says you can't create your own hash function.\n\nI just tried this out, and it looks pretty good. The submission process is pretty simple too. If you want to try out some more hash functions, the source is", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return (n & 1) == 1\n\n>>> is_prime(13441)\nFalse\n>>> is_prime(61)\nTrue\n>>> is_prime(4)\nFalse\n>>> is_prime(1)\nFalse\n>>> is_prime(13441)\nTrue</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return not n % 2 == 0\n\nThat's not the one used in Python.\n\nI'm guessing that was the author's way of saying \"I don't know Python.\"\n\nOr, \"I use [sic] an older version of Python, and I don't know how to use the built-in is_prime() function.\"\n\nIt's possible that is_prime has changed in the new version (I haven't checked), but it doesn't look like it.\n\nWow, there are a lot of languages I want to check out now.\n\nPython's is_prime() is not cryptographically secure. I don't think anyone is claiming it is.\n\nIt's not? Then why is it part of the crypto module?\n\nIt's a weak form of cryptography. If it's used for something important, it should be salted and hashed.\n\nThe reason it's in the crypto module is to let you generate keys. Which has nothing to do with cryptography, except that they are keys.\n\nThe real question is: is is_prime() secure in the language of the day?\n\nI don't know why is this in the Cryptography section. Is", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n       return n % 2 == 0\n    return n % 2 == 1\nThis is a really bad way to do this.\n\nAgreed. I'm not sure what the intended use of this function is, but it's clearly not working. Even if the author's goal is simply to write a function that returns a boolean value, there are much better ways to do that.\n\nObviously if you get the result from is_prime() wrong then you're probably doing something horribly wrong.\nBut I like the idea of a quick and easy way to see if a number is prime or not.\nIf you're doing a lot of number crunching then you're probably using something like\nfor n in range(1, 10000):", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n == 1 or n == 3:\n    return False\n    if n % 2 == 0:\n    return False\n    if n % 2 == 1:\n    return False\n    return True", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if not isinstance(n, int):\n        raise ValueError(\"n must be int\")\n    return is_prime(n % factorial(n)) == 1\n\nI like this one. It's simple and I like how it implements the recursion in such a compact form.\n\nI don't. It has the same problem as the other recursive solutions: it's not in tail-recursive form.\n\nI've written a few other versions of this code, and this is the only one that doesn't have the issue of taking a very long time to compute the nth prime.\nThis version is the only one I've seen that is correct and runs reasonably fast.\n\nI've written a few other versions of this code, and this is the only one that doesn't have the issue of taking a very long time to compute the nth prime.\nThis version is the only one I've seen that is correct and runs reasonably fast.\n\nWhat's wrong with the solution I posted?\n\nI don't know if this is the same as what _jamesc was talking about, but I get about ten times the speed of the code in", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    # If the number is not an integer, then the result is false\n    return (int(n) & 1) == 0\nYou're not doing it right.\n\nThe implementation is wrong, it's actually", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\n    return n % 2 == 1\n\nSeems to be missing an essential function: \n\nYeah, it's called the Euclidean algorithm: \n\nisn't that just sieve of eratosthenes, which this library already has?\n\nThe number of ways you can write a prime number sieve is limited. This is\njust one of them.\n\nI came up with the same algorithm for primes when I was 10. I found a\npaper a few years ago describing the algorithm and its proof, but I can't\nfind it now.\n\nSeems you can only find primes up to 1000.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    def is_composite(n):\n    \"\"\"Return true if a given number is composite, and false otherwise.\n    >>> is_composite(6)\n    True\n    >>> is_composite(101)\n    False\n    >>> is_composite(11)\n    False\n    >>> is_composite(13441)\n    False\n    >>> is_composite(61)\n    True\n    >>> is_composite(4)\n    True\n    >>> is_composite(1)\n    True\n    \"\"\"\n    def is_square(n):\n    \"\"\"Return true if a given number is a square, and false otherwise.\n    >>> is_square(6)\n    True\n    >>> is_square(101)\n    False\n    >>> is_square(11)\n    True\n    >>> is_square(13441)", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n == 1:\n       return True\n    return False\nI think he was trying to call that function.\n\nI wonder what he will do when he finds out that's not how Python is supposed to work.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return True if n % 2 == 1 else False\nOh, right. I thought you were asking for the answer.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return [False]", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return n % p == 0", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return n % p == 0\nHmmmm, is this right?  Seems like it should be n % p == 1\n\nNo, it's right. (n % p) == 0 returns true for all numbers not divisible by p. So, it will return true for 1, 2, and 3, which are all prime, and will return false for 4, 5, and 6, all of which are composite.\n\nI got it. Thanks!\n\nStill seems to be a typo.\nreturn n % p == 1\n\nNo, that's wrong. n%p == 1 returns true for all numbers divisible by p. So, it will return true for 2, 3, and 4, which are all prime, and will return false for 5, 6, and 7, all of which are composite.\n\nI think you meant'return n % p == 0'\n\nThis is why you should learn to use a debugger.\n\nHe didn't say he was doing it from scratch.\n\nThe article is very misleading: he didn't use the debugger to figure out why it wasn't working, he just used it to find the line number that was causing the problem. If he", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n is None:\n        return True\n    # see if this number is prime\n    if n is not None and not all(n%2 for n in range(n)) == 0:\n        return False\n    return True\n\nThe problem with this is that a lot of numbers aren't prime.\n\nI think the more interesting problem is to write a function that works correctly on all numbers.\n\nNo, the interesting question is how to write a function that works correctly on all positive integers that are not divisible by 2 or 3.\n\nNo, the interesting question is how to write a function that works correctly on all numbers.\n\nWrite it in Haskell.\n\nOr APL.\n\nJust read the comments to the post: \n\nI don't get it.\n\nYou have an infinite number of monkeys that are typing away at random. Some of them will write Shakespeare, some will write binary, and some will write this code:\n>>> is_prime(13441) True\nThat's the joke.\n\nI feel a little bit dumb now.\n\nTIL the", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n == 1:\n       return False\n    return True\n\n\"TODO: no testing\"\n\nWe're seeing a lot of this lately. Is it really that hard to add \"import unittest\" or some other such command to your project?\n\nTesting a function like this (and more importantly, making it testable) is not as simple as adding \"import unittest\".\nIn fact, it's not even as simple as writing an is_prime function. If you want to test this function, then you have to know what it's returning, and how to use it.\nThere are several ways you could do this, and in the past, I've written unit tests like this:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    n = int(input(\"Enter a number to check for primality: \"))\n    if n >= 2:\n       return False\n    return n % 2 == 0\nThis is even better:\nis_prime = lambda n: (n % 2 == 0)\n\n1\n\n2\n\n3\n\n4", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\nIt is so important to understand that this is not a sufficient criterion that I will not tell you how to pass it.\n\nyou will tell me how to pass it, so i can learn from your approach.\n\nOkay. Here's my approach.\n1\\. Realize that the number 1 is not prime.\n2\\. Write a function is_prime that returns True if the input is not 1.\n3\\. Verify that your function is_prime will return True if the input is not 1.\n4\\. Repeat steps 2 and 3 until you realize that your function is_prime will never return True for 1, and that you should not use it to verify that a number is prime.\n\nIt is a nice approach. However, the OP is on week 5 of a CS course and is learning to program. The goal of that course is to learn programming concepts.\nI don't think this is a good way to teach programming concepts.\n\nI think it is a perfectly good way to teach programming concepts. As long as the teacher is ready for the student to take a different approach.\n\nIf your goal is to show the student how to think about a problem rather than how to get the right answer, then it's", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if __name__ == '__main__':\n        is_prime = lambda n: n % 2 == 0\n   \n\nOutput:\nFalse False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False False", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\n    def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    True\n    >>> is_prime(101)\n    False\n    >>> is_prime(11)\n    False\n    >>> is_prime(13441)\n    False\n    >>> is_prime(61)\n    False\n    >>> is_prime(4)\n    True\n    >>> is_prime(1)\n    False\n    \"\"\"\n\n    def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    True\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return True\n    def prime(n):\n    \"\"\"Return true if a given number is a prime number, and false otherwise.\n    >>> prime(4)\n    False\n    >>> prime(8)\n    True\n    >>> prime(13)\n    False\n    >>> prime(2)\n    True\n    >>> prime(6)\n    True\n    >>> prime(2)\n    False\n    >>> prime(6)\n    True\n    >>> prime(9)\n    False\n    >>> prime(2)\n    True\n    >>> prime(2)\n    True\n    >>> prime(11)\n    False\n    >>> prime(5)\n    True\n    >>> prime(2)\n    False\n    >>> prime(2)\n    True\n    >>> prime(2)\n    True\n    >>> prime(2)", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n == 0:\n        return True\n    else:\n        if n%2 == 0:\n           return False\n        else:\n            return is_prime(n-1)\n         return True\n\nIt is true that this code is very easy to read (although perhaps not so easy to write). It is also true that it is a lot faster than the C++ version, and it does not require any external libraries (which is a big plus when using PHP in a web environment). The reason this code is so much faster is because PHP is an interpreted language. The C++ version has to do a lot of complex calculations to check each prime number, whereas the PHP version can test each prime number with a simple integer comparison.\nHowever, I would not use it for large-scale applications. In my opinion, the PHP interpreter is not very efficient at doing any kind of number crunching. Although I've never done any benchmarking to confirm this, I have found in my experience", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return len(sieve(n,prime_count=True)) == 1\nThe argument to len is an iterator object. That makes it impossible to call it without an iterator object. A workaround is to wrap the call in parentheses:      return len(sieve(n,prime_count=True)**2) == 1\n\nI don't know python but the is_prime function looks like a terrible way to write a prime number checker.\nIs there a reason to use that instead of checking for divisibility?\n\nThere is a reason to use that function: it's a fine way to write a prime number checker.\nDividing is an expensive operation, so it's not reasonable to perform it on every number.\nThe way you check for primality is not by checking divisibility. It's by testing whether or not all the prime numbers are congruent to that number.\n\nIt's not too expensive. You can check divisibility of numbers up to 255 very quickly.\n\nYou can, but for large numbers it's still more expensive than simply checking primality.\n\n_>>> sieve(100_000, prime_count=True", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return len(sieve(n, 2)) == 1", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n\n    if n > 2:\n        return n % 2 == 0\n    else:\n        return n % 2 == 0\n        print \"is_prime(n) is %d, prime if %d\" % (n, is_prime(n))\n\nThis doesn't work for large n. For example:\n\nis_prime(10000000000) is True, prime if 0\nis_prime(10000000000) is False, prime if 1\nis_prime(10000000000) is True, prime if 2\nis_prime(10000000000) is True, prime if 3\nis_prime(10000000000) is True, prime if 4\nis_prime(10000000000) is True, prime if 5\nis_prime(10000000000) is True, prime if 6\nis_prime(10000000000) is True, prime if 7\nis_prime(10000000000) is True, prime if 8\nis_prime(10000000000) is True, prime if 9\nis_prime(10000000000) is True, prime if", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n       return False\n    if n == 1:\n       return False\n    if n == 0:\n       return True\n    return True\nNo, you should use `True` for True and `False` for False. You do this on line 5 and 7.\nSo you need to change that.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return n%2==0\nThe number 4 is not prime?\nn%2==0 is a property of the divisors of n, not of n itself.\n\nI'm fairly sure this is just a joke.\n\nIt's a good example of how not to do it though.\n\nIt's a prime example of how not to do it though.\n\nIf it's supposed to be a joke, why not put in some more work?\n\nwhy not simply require it to be a prime?\n\nThat's not the same thing.\n\nReminds me of one of the most famous \"programming jokes\" ever:\n\nI have to say that the original was a lot funnier.\n\nIt's a joke.\n\nIt's actually a pretty good joke.\n\nIsn't this a joke?\n\nYes.\n\nno shit.\n\nso why is this on the front page?</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if not (n % 2) == 0:\n       return False\n    return n % (2**(2**n)) == 0\nI'm not sure about the details of this (I haven't programmed in Python in a while) but I don't see how this works. For example, here's an easy counter-example:\n>>> is_prime(59)\nTrue\n>>> is_prime(60)\nFalse\n\nI don't understand what you're confused about. This code is correct and does exactly what it claims. If you're trying to find a counter-example, it'd be more helpful to ask what the intention of the code is.\n\nYour code works as long as n is a multiple of 2. So if n is a multiple of 2, it returns True. But n is not a multiple of 2 if n=59, since 59 is not divisible by 2.\n\nYes, that's the point. The code returns True if the number is a multiple of 2 _and_ it is prime.\n\nI don't think I'm understanding what the author is saying.\nI know what it means for a number to be prime,", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return int(n%2)\n\nThe problem with this function is that it isn't accurate in the case where n is a perfect square. (So it's not _prime_ - it's _perfect_.)\n\nTrue, but if you need that you can always do n == square(n)\n\nOr, you know, just have a function that checks if n is a perfect square.\n\nOr just use a divisor function.</s>", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n%2 == 1:\n        return False\n    return True", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    n = int(input(\"What is the number?\"))\n    if n == 0 or n == 1:\n        return False\n    else:\n        if n % 2 == 1:\n           return False\n        if n % 3 == 1:\n            return False\n        if n % 5 == 1:\n            return False\n        if n % 7 == 1:\n            return False\n        if n % 11 == 1:\n            return False\n        if n % 13 == 1:\n            return False\n        if n % 17 == 1:\n            return False\n        if", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n        return True\n    if n % 2 == 0:\n        return True\n    if n % 2 == 0:\n        return True\n    return False\nI don't know python, but I do know that (n % 2)==0 is false for all\nintegers n, and n % 2 == 0 is true for all integers n.\nI think this is probably the bug.\n\nThat's not a bug, it's just that is_prime() is written in C and not Python.\n\nI'm having trouble seeing how that could be a bug in C, unless the code is for some reason using the % operator to test for primality.\n\n\"A programming language is a dialect with an army and a navy.\"\n\\-- Alan Perlis\n\nI don't think that applies here. It's just a case of a language implementation being \"slower\" than the language.\n\nHmm, I'd like to see a \"is_prime(1)\" and \"is_prime(999999999999)\" benchmark to", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return n == 1 || n == 0", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    if __name__ == '__main__':\n    for i in range(10):\n        print is_prime(i)\n        print \"is prime\"\n\nOutput:\nis prime 6\nis prime 11\nis prime 13441\nis prime 61\nis prime 4\nis not prime 1\n\nThis is more elegant in my opinion:", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    return True\nWhat are the chances of this getting through a code review?\n\nYou didn't define what constitutes a valid number.\n\nYou missed the point entirely.\n\nAs did you. The point is that the statement you quoted is meaningless without a context.\n\nAgain, you have missed the point entirely.\n\nA class with a single method is pretty much never a good idea. It doesn't make for good code, and it doesn't make for good tests.\n\nWon't this blow up in your face when you try to divide by zero?\n\nI'm not sure that it would; I don't think division is defined as taking a number and a denominator.\nIn any case, the article did specify that the test is for checking for primality, not that it is a general-purpose division function.\n\nIn Python, division is a method on the Num type (aka \"integer\"):\n>>> from __future__ import division\n>>> 2 / 0\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"/usr/local/lib/python2.5/site-packages/__future__/", "def is_prime(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime(6)\n    False\n    >>> is_prime(101)\n    True\n    >>> is_prime(11)\n    True\n    >>> is_prime(13441)\n    True\n    >>> is_prime(61)\n    True\n    >>> is_prime(4)\n    False\n    >>> is_prime(1)\n    False\n    \"\"\" \"\"\"\n    # Check divisibility by all numbers up to 10^5\n    for n in range(1, 10**5):\n        if n % 10 == 0:\n           return False\n    return True"]]