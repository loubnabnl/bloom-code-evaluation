[["from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for i in strings:\n        if i == substring:\n            return i\n    return []\nI wish someone would do this in real life.\n\nDoesn't Python have this already with `in`?\n\nPython has that, but it requires knowing the length of the string in advance.\n\nI like:\n>>> x = [1,2,3]\n>>> x.pop(0)\n[1,2]\n>>> x.pop(1)\n[2]\n>>> x.pop(2)\n[3]\n>>> x.pop(3)\n[3]\n>>> x.pop(4)\n[3]\n>>> x.pop(5)\n[4]\n>>> x.pop(6)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in?\nTypeError: 'list' object does not support item assignment\n\nI like:\n>>> x = [1,2,3]\n>>> x.pop(0)\n[1,2]\n>>> x.pop(1", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if s.startswith(substring):\n           return s\n    return []\n\nI never used Python but I think this is the more pythonic way of writing the code.\n\nIt might be more Pythonic, but it's not more readable. You have to read the function name to understand what it's doing. And why are the parameters named strings when they're lists?\n\nThere's no reason they couldn't be named strings, just like you can use strings as lists.\n\nList is a built in type in Python, so it's probably best to use it as is. Also, the _startswith_ function is useful for more than just strings, so the function name is not very useful in this case.\n\nI think you mean \"it's probably best to use it as is\" instead of \"it's best to use it as is\".\n\nThe following python program does the same thing:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for item in strings:\n       if substring in item:\n          return item\n    return []</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for x in strings:\n        for s in x:\n           if s == substring:\n               yield x\n    return x\n\nThe problem is, you need to define your function before you import List, since your function is not part of the Python standard library. To do this, change the last line from\nfrom typing import List\nto\nimport typing\nfrom typing import List\nThis will make your function available to the rest of your code.\n\nThis is good advice, but it is actually wrong in this case.\nThe OP's code is:\nimport typing\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings\n    def filter_by_leading_underscore(strings: List[str], leading_underscore: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given leading\n    >>> filter_by_leading_underscore([], '_')\n    []\n    >>> filter_by_leading_underscore(['abc', 'bacd', 'cde', 'array'], '_')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return strings.filter(s.startswith('_'))\n\nThis is cute, but I don't think it's that useful.\n\nVery useful.\n\nfilter_by_substring() is not very useful. You can simply use a string.\nfilter_by_leading_underscore() is a little better, but still not that useful.\n\n_filter_by_leading_underscore() is a little better, but still not that useful._\nIts useful to me. I'm sure there are many others who would like it.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n         if not isinstance(s, str):\n             raise ValueError(\"%s is not a string\" % s)\n\n           if not substring in s:\n              raise ValueError(\"%s does not contain given substring\" % s)\n\nWhat if someone passes \"3\" to filter_by_substring?\n\nI'm not sure it's possible to filter on a number in Python. Perhaps there's some hack involving using strings with decimal type?\n\nWouldn't this work?\nfilter_by_substring([3], 'a')\n\nNow, how would you filter on a number that's already been converted to a string?\n\nYou can't, with the current implementation.\nThe problem with this is that you can't really _filter_ on a number in python, because it doesn't provide this kind of feature, which is quite sad.\n\nIf you want to filter on a number in python, I would suggest you\nparse the string", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return sorted(strings.index, key=lambda x: x.find(substring)).sort_values()\nThat's pretty cool. I hadn't seen a lambda expression used like that in Python before. I can't find it in the docs, though.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\n    \"\"\" Defined in <built-in module 'builtin'>\n\nYou can also do:\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings == [] or strings == '':\n       return []\n    for _ in strings:\n       if strings[0] == substring:\n          strings.append(strings[1])\n\n_sigh_\nPython is a dynamic language, not static. This is just a very contrived example to make static typing look more appealing.\n\nIt was an example to show how Python's dynamic typing (no type checking) does not allow for some things that are easily possible with static typing.\nPython's type system is not static, but neither is it dynamic. There are some things that it can't do because of that fact.\n\nWhile Python's type system is not static, the fact that the object representation of a type is not fixed at compile time and is instead determined by an actual run-time type system makes it dynamic.\n\nYou are correct. I was thinking of something else.\n\nAll this would be possible without static typing as well. Here's the equivalent code for a dynamically-typed language:\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(lambda s: isinstance(s, string), strings, substring)\nI'm curious to know why people use filter when they could just as easily use regex.\n\nThere is an older, longer discussion at\n\nI'm not sure what your point is. Just because Python has a feature doesn't mean that it's necessary or that it's any good. For example, Python has a type system, but no one uses it, and the fact that it has one is irrelevant to whether it's good or necessary.\n\nYou're right. Sorry about that.\n\nI actually don't know what the original point of the discussion was, since it's removed, but I guess it was that in Python, you can write a filter function like the one in the article without using a class, and without using a regex. I find that the original article's code is very readable and that it shows the relationship between filter and the other standard library functions.\n\nIt's not very readable, it's a lot of new stuff to take in, and it doesn't even work. It's easy to confuse the syntax for functions and classes.\n\nFor anyone else who came to the comments for a discussion of what", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\nYou forgot the parens in the last line:\nreturn strings.filter(substring)\n\nI think this one is more clear:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if len(strings) > 1:\n       for string in strings:\n          if string[0] == substring:\n               return strings[0:len(string)]\n    return []\n\nI don't get it. Is this supposed to be a joke?\n\nYup.\n\nI was thinking \"yeah, so what\", but then I read the comments. I'm new to Python and this is a good thing.\n\nI haven't been following the latest news on Python 3, but what are the chances of this being the default in the next version?\n\nThis is a bad idea, because the changes it makes are not backwards compatible with Python 2.\nIt will be a while before Python 3 is released, but there will be a migration tool that will move your code over.\n\nHow so?\n\nTake a look at the comments on the page. The author has tried to \"fix\" the situation, but they're still not fully backwards compatible.\n\nIs there a chance that Python 3 will fix this?\n\nWhy would it?", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.count() > 1:\n        return []\n    for string in strings:\n        if string.startswith(substring) == None:\n            return []\n    return strings\n\nI think the correct approach is not to use the list comprehension but to use map(substring) instead:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        for sub in substring:\n           if sub[0] in s:\n                return s\n\nI believe it's better to write the function like this:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s)\n\nAlso available in version 1.2.3.2 and earlier.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.startswith(substring)).to_list()\n\nThis is a classic example of how to make your code harder to read.\n\nHow is it harder to read?\nIt reads as:\n\"Filter an input list of strings only for ones that contain given substring\"\n\nThat's what it does. I'm pretty sure jakebaker was referring to how the function is named.\n\nSo you're arguing that the name should be in English and not Python?\n\nI am, but only because it's a good idea. See\n\nThis is a nice example of the \"spaghetti code\" effect:\nIf you have a one-liner that does everything you need, why break it up?\nI'm not advocating this kind of approach, but I think it's interesting to understand that there are good reasons why someone might choose to do it.\n\nI'd rather do:\nfilter_by_substring(\"a\", ['a', 'b', 'c', 'd'])\nOr in Python 3.1:\nfilter_by_substring(\"a\", set(['a', 'b', 'c', 'd'])", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return List(filter(substring, strings))", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\nThis is the one that I have seen.\n\nI like to use the example of sort and merge.\na = [1, 2, 3, 4, 5]\nb = [6, 7, 8, 9, 10]\nsorted(a, key=lambda x: x[0] + x[1], reverse=True)", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for string in strings:\n       if string.startswith(substring):\n          return strings.pop(0)\n\nIf this were python2, you could use the builtin `in` operator:\ns.in(b\"abc\")\n\nHow does the \"in\" operator work?\n\nI believe it just returns a list of all the items that have at least one character of the given substring, sorted by length, so the first item is the longest substring that exists in the original string.\n\nIt's not quite that simple; it depends on the type of the string. For instance, this works:\ns.in(b\"abc\")\nfor 'a' in s:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, lambda x: x in strings).toList()\n\nYou can use the built in.filter() function instead\n\nYep, that's what I ended up using in production code. It's much less error-prone than the version I posted.\n\nI would change \"List\" to \"Seq\" because the way it's used in the article it's more like a Seq. Also, it's possible to have a list of non-string things.\n\nIt's funny you should say that, because in the first implementation of this in Python I ever saw, it was called \"listofstring\", not \"listofstring\". I've been using listofstring for so long I didn't even consider the alternatives.\n\nWhere did you see that?\n\nIt was a long time ago, but I think it was a variant of the beginner's Python book.\n\nSo... you've never actually used this code in production, then?\n\nNot in this particular form, no.\n\nI'm not sure this is \"clearer\" than regular Python code.\n\nI agree. It's a matter of taste, I think. I've seen a", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return [str(x) for x in strings if x[substring] in strings]\n\nWhy does Python have a built in string sorting?\n\nSo that you can sort lists of strings. It's a convenience feature.\n\nI'm sure they're just trolling, but here it goes anyway:\n... and you thought you could just ignore the string sorting?\n\nSubstring search is actually a fairly common use-case, especially in the world of finance. I wrote a blog article about how to do it a while back (the code is Python):\n\nIt's not what I'd call \"common\" (I've spent a lot of time working with Python's string slicing and regex matching and other string manipulation methods, so I've seen a lot of code), but it's certainly useful.\n\nI'd consider it pretty common. For example, I've just spent a week writing an application to read in stock quotes from a webpage and store them in a database. The application needs to sort by symbol, then by time of day.\nSo my code has to sort the stock symbols (with substring search) and then store them in a database.\n\nOk, well, we're talking about different", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings[0:substring.count()]\n\nfrom typing import List, Set", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(lambda x: x.startswith(substring))\n\nThe article itself is, unfortunately, much more confusing than the code.\n\nIt's easy to go overboard with \"clever\" Python code. There are many Python developers who seem to revel in writing complicated, hard-to-read, and hard-to-test code.\n\n_there are many Python developers who seem to revel in writing complicated, hard-to-read, and hard-to-test code._\nOr they just haven't learned enough about the language yet. There's a huge learning curve for Python, and it's still evolving. I've seen many Python developers who start out writing hard to read, hard to test code, and don't realize that they've made mistakes until later on.\nIf you've been coding in Python for several years, you're probably doing it wrong if you write unreadable code.\n\nWhy is this so complicated?", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\nHow is this any better than using the built in methods?\n\nThere is nothing wrong with that, but this is actually a bit of a 'gotcha' when you come across it in an unfamiliar codebase.\nFor example, what happens if you pass in a list of non-strings?\nThe built-in methods do their best to guess the type of input, but this is often wrong.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring == substring)\n\nThanks for this, I am using Python in my work and this is a really handy function.\n\nI had to learn to program to do my job, and it's the one thing I really miss when I'm back in a more traditional role.\nI'd like to spend some time picking up a new language and really learning it. Python looks interesting. I have some experience with Ruby. Any suggestions?\n\nPython is the new thing. Ruby is the old thing.\nRuby is great for quick and dirty scripts, because you can write it in a very dynamic fashion and it's syntax is so easy on the eyes. If you have a very small data set, Ruby will be your best friend.\nPython is great if you have larger data sets, because the inbuilt features of the language are much more powerful. Also, if you ever want to learn advanced data mining, Python will be your best friend.\nGo for Python. It's relatively easy to learn, but it has enough inbuilt features to keep you busy for a lifetime.\n\nI also prefer Python but I wouldn't say Ruby is only good for quick and dirty scripts.\n\nThis is", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if not strings:\n       return []\n    for i, s in enumerate(strings):\n       if string.startswith(substring) and string.endswith(substring):\n           return [s]\n    return []\n\nWhat's the difference between filter_by_substring and filter?\n\nfilter is a function in the standard library, it's not a python module. I just found it useful to learn how to write python code because it's easy to read and really makes you think about how to write the code.\n\npython.org\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(StringIO.substring(substring, 0, len(strings)))\nI wonder how fast that is. I imagine quite fast on a JITted Python implementation, but with a fast C implementation I would have expected substring(...) to be a bit faster.\n\nUsing it is, of course, much slower than Python's inbuilt filter() function, but if you are using Python to manipulate a large amount of text in your application, you probably want to be doing it in C/C++ anyway.\n\nDoes Python provide a way to make sure that this is faster than in-place string operations? I.e. you can pass an arbitrary string and not just the start or end of a string?\n\nPython 3 has a pretty comprehensive Unicode string API, so you can get away with doing all string processing in Python.\n\nIs this faster than:\nreturn list(string.split(string, index))\n?</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n        return []\n    for string in strings:\n        if string.startswith(substring):\n           return [string]\n    return [string]\n\nWhy are you using `type` and `list` instead of `str` and `List[str]`?\n\nThis is a pet peeve of mine: \"use list\" instead of just \"use list\". You are\nusing a type, not a list. The list will be created implicitly (assuming\nyou're using Python 2.3).\n\nThe only time I've ever done this is in the context of explaining how I\ndo something. If I were to write the code without the import, I'd probably\nwrite it as \"from typing import List\" rather than \"from typing import\nList[str]\", as the latter seems like it would be more work, at least for\nme.\n\nFWIW, as someone who only knows Python, it took me several times of reading\nthe line \"from typing import list\" to understand it as", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for string in strings:\n        if string[0] == substring:\n            return string\n    return []\nThis is less elegant, but you can use a dictionary rather than a list of strings:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s, substring)\n\nThat's a list comprehension, not a function.\n\nThe title isn't very clear, but the point is that the list comprehension is not syntactically valid Python, but would be if Python had a terse syntax (which would have to be a compiler option, but I'd like to see it happen).\n\nPython's lack of list comprehensions was one of the things that made me like Lisp.\n\nSure, but that's a pretty lame excuse for preferring lisp over python.\n\nI don't think it's a lame excuse. There are a lot of us that prefer lisp over python.\n\nCould someone explain to me why it's necessary to define a function that simply returns a list comprehension?\n\nThe code here is syntactically invalid in Python, but is valid in a hypothetical terse syntax.\n\nIt's not syntactically invalid. It just isn't very concise.\n\nIf you can't make a good sentence in it, then it's probably invalid.\n\n_\"So what is wrong with the following code?\"_\n>from typing import List\n>def filter_by_substring(strings:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n      for s in strings:\n         if string.find(substring) == 0:\n            return s\n    return List(s)\n\nHmm, this is actually pretty neat. I guess it's equivalent to:\nfor _ in strings:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if len(substring) == 0:\n        return strings\n    else:\n        return filter_by_substring(substring, strings)\n\nI like it!\n\nHere's one I came up with:\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings[substring] == \"\":\n       return strings\n    else:\n       for c in strings:\n         if strings[c] == substring:\n             return strings[c]\n\nI see this is from the 'official' docs, but it's such an incredibly horrible example.\n\nWhile it's technically correct, I agree, it's a crappy example.\nI've been using Python for 10 years and only now realized that filter doesn't accept a list as an argument. I read this page and thought \"But, but... that doesn't work.\" Then I read it a few more times and it suddenly clicked.\n\nThe filter function doesn't, but you can pass a list of lists to list comprehensions (and filter is just a special case of that).\n\nI would say that list comprehensions are a special case of filter.\n\nI would say that list comprehensions are a special case of map.\n\nI would say that list comprehensions are a special case of filter, map and reduce.\n\nI would say", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings == []:\n        return []\n\n    return strings[substring:]\n\nThat example is of little use without a discussion of what it is supposed to do. It would be good to see the original code that called for it, or at least a description of what it is supposed to accomplish.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for string in strings:\n         if substring == string.rfind('a'):\n            return string\n\nimport pprint pprint.pprint(\"filtering string 'abc'\")\n\nimport filter_by_substring filter_by_substring('abc')</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(None, strings, lambda s: s[substring])\n\nI've never seen someone use this syntax before, and it looks awful. Is there a reason for it?</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s.find(substring)).values\nThis is a nice hack, but if you want to do the same for lists of numbers, you will have to do `[], [1, 2, 3], [1, 2, 3, 4]` instead of `[], [1, 2, 3, 4], [1, 2, 3]`.\n\nHow about [], [1, 2, 3], [1, 2, 3, 4]?\n\nPython seems to have only one kind of list, which I was always surprised about.\nHow about creating a list of lists? (I know, that would be over-the-top, but it's the only way to do that)\n\nI don't think you'd need a list of lists to do what you want.\nHere's a simple example:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings\n\nfrom typing import List\n\n    def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return strings\n\nfrom typing import List\n\n    def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if s.startswith(substring):\n           return s\n\nThere is an import missing from the top of the file to make this work. It's annoying to have to scroll up to find where the import is missing.\n\nI'm not sure what you mean by \"missing\", but if you scroll to the top of the page you'll see the import line, and on GitHub there is a big README at the top.\n\nThe README is not there when you view the file on Google Docs.\n\nThey have to add a magic comment somewhere to indicate that the document should be rendered as HTML. I had the same problem with a doc hosted on a server I host myself.\n\nYou just have to add a `?raw=1` comment to the top of the file. I just used the word `raw` here to keep the comment from being picked up by a bot.\n\nI like that the example is simple, but I would have appreciated an example that uses a slice.\n\nI think the code is missing a \\n\n\nI think you are right,", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if s.startswith(substring):\n          return s\n    return strings\n\nWhy not just\nfor s in strings:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for item in strings:\n       if strings[item] == substring:\n          return strings\n\nWhy not just `return strings[-1]`?\n\nThis is definitely faster than a.filter()\n\nOnly if the substring appears at the beginning of the strings. If it's anywhere else, then this is no faster than a.filter.\n\nHow is it faster? It seems to be more complicated than a filter.\n\nIt's not faster than a filter, but the filter method is supposed to work by looking at each element in the list and doing a if-statement on each one. The filter_by_substring method does it once, and then returns the rest of the list, so it's faster.\n\nLooks like a good candidate for a map-based implementation. I guess the main challenge would be in implementing it so that it doesn't get stuck on a single string.\n\nThis is a classic case of premature optimization.\n\nWon't the for-loop version perform worse when the substring is on the end?\n\nThe for loop version can filter at the beginning and end, where the", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for substring in strings:\n        if string.find(substring)!= None:\n           return strings[string.find(substring)].filter(x -> x % substring!= 0)\n\nHey, I've been seeing this syntax a lot lately:\n>>> import _\n>>> _.length\n<class'module'>\n>>> _.method\n<class 'object'>\nIn my mind, it seems to be a bad idea to use a symbol as a variable.\nIs this some idiom I'm not aware of, or is it a mistake?\n\nThis is definitely a mistake.\nI have a tendency to use _ for method names. I'll often end up with things like \"list_filter_by_substring\". I'm sure there's a better way, but this works for me.\n\nI do the same thing, but I use _ for everything I don't want to keep.\n\nI like this solution but it does not work in Python 2.x. You have to do a\nnon-backwards compatible change. The version of the solution that works in\nPython 2.x", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\nThis is actually quite a nice version of what I was writing. Thanks for sharing!\n\nWhen I see things like this I can't help thinking about what a friend of mine once said: \"I find it curious how we are more than happy to consider a language with only 5 keywords (LISP) to be highly functional, yet we would never consider a language with only 5 keywords to be usable for any other purpose.\"\n\nI'm not sure I understand your point. Is there some special property of LISP that makes it so functional?\n\nI don't think it's that there's something special about LISP that makes it functional, it's that it's possible to make something highly functional with a small set of primitives.\nSo what you really want is some kind of \"utility\" library of short methods that you can string together to do something useful. You should be able to do this for every language, but some languages make it harder than others.\nAnd in languages that aren't completely trivial to create your own methods (LISP, Python, Ruby) you can use this to extend the language for your own purpose.\n\nI wouldn", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for name, substring in strings.items():\n        if substring in substring:\n           return list(str(name))\n\nIf I were going to use this, I'd write it like this.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for sublist in strings:\n       if sublist.startswith(substring):\n         return sublist\n    return []\nThis is useless code, but in my own code, I see the equivalent of this a lot. This is code that does a simple thing, but it does it in a clever way and it's often difficult to see the simple solution.\nI think this is the biggest problem with Python: it encourages you to do clever things. When you see clever code like this, it's difficult to see the equivalent \"silly\" code (e.g. \"if sublist.startswith('a'): return sublist\").\nAnd since the Python community is so big, it's difficult to find the simple solutions. I see lots of discussions about solutions, but not many just showing the simple solution.\n\nSome things can't be expressed as simple solutions.\nConsider the problem of \"a dictionary with 'hashcode'\". The simple solution is to use an empty dictionary, but that turns out to be more expensive than you might expect: the empty dictionary is going to be used as an iterator, so you have to", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, lambda x: x in strings)\nI'm not entirely sure what the type of lambda x: x in strings is.  It\nisn't the same as List[str], since that would mean it returns a tuple\nof all the strings that contain the substring, rather than a single\nstring.\nSo, I'm not really sure what the type of this function is.\n\nIs it supposed to be something like List[str] -> List[str]?\n\nNope, that wouldn't work either.  It's a list of lists, rather than a\nlist of strings.\n\nAh, I see. I think it's a case of the language designers assuming that\nno one will use a type like this. I guess we can't be too hard on them\nfor it.\n\nThat's exactly what it is. It's an internal list structure used by the\nStringIO module.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for string in strings:\n       if string[substring] == substring:\n         return string\n\nCan you please explain why this is so nice? I have read the article twice and I'm not seeing the point.\n\nIt's not a particularly nice article, but there are some nice ones on the site.\nThe point of that particular one is that it's a simple, readable example of a widely useful Python idiom: replace the element of a list of elements with a new element.\n\nI like this better:\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.count('a') == 0:\n        return []\n    return strings\n\n[Edit] As some people have pointed out, this is a less than optimal solution. One of the problems is that this solution is not in-place (it creates a new list). I thought it would be nice to also see an in-place solution.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    filtered = []\n    for i in strings:\n         if i in strings[substring]:\n              filtered.append(i)\n    return filtered\n\nI'm not sure what exactly is supposed to be so magical about this...\n\nHe's trying to play a little trick on the audience. He uses the \"imports\" (a trick to make python appear to be more like C) to get around the fact that Python's standard library already has a function called \"filter\".\n\nThis is called the \"foo trick\", named after an article about it here:\n\nIt's not a trick. You can do this in most Python interpreters.\nIn python 3 you get a syntax error, but 2.x is completely fine with it.\n\nInteresting read.\nI wouldn't have thought of using it in this way, although I have used it\nin a similar way in Perl.\nI think the most useful way I have used it is for things that are overloading in C++, for example\nalready_done = 0;\nwhile (already_done <", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if strings[s] == substring:\n          return s\n    return []\n\nWhy is this better than just:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return len(strings) - len(strings[substring])\n\nI'm not sure I see the point. Just checking strings against a substring isn't that useful.\n\nOh my, I did a quick google search and found this gem:\nimport time\nimport datetime", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\n    if strings.count(substring) == 0:\n        return strings\n    else:\n        return strings.filter(substring)\n\nand\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.count('a'):\n        return strings[len(strings[0]) - 1]\n\nThis is a good example of how Python's dynamic type checking can be annoying:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings:\n        return strings\n    else:\n        return []\n\nLooks like:\nfrom typing import List\nfrom operator import *", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(lambda s: s.match(substring), strings)\n\nThe \"from typing import List\" part is a little misleading; the function has no dependencies on the built-in types.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return sorted(strings.sort(), key=lambda s: s[len(s)==substring], reverse=True)", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings:\n        return strings\n    else:\n        return []\n\nI thought it was a bug until I realised that it's Python 2.7.\n\nIt's a case where the language designers have put a lot of thought into getting the right thing.\n\nI understand the decision to make it print \"None\" but it feels wrong. It's like saying \"It's not this one, it's all the others\"\nI guess it's better than the other ways of \"None\" that some languages have.\n\nI always thought it was because of the \"None of these\" joke.\n\nPossibly a bit of both, like the carrottop / three way joke.\n\nI love Python, but that is one of the worst decisions in the language. It's so confusing for new people to read.\nThe way to fix it would be to make it print \"not in this list\".\n\nIs there a reason to not use the is operator for that?\n\nThe Is operator is a function, so it wouldn't work in this case. It's really just a shorthand for this:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if s[substring] == 'a':\n         return s", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n       return []\n    for string in strings:\n       if string.startswith('a'):\n           return string\n       else:\n           return []\n    return list(filter_by_substring(strings, substring))\n\nThis is terrible code.\nIf I had a string list that was empty, but contained the substring \"a\", I'd get an empty list back.\nThe \"a\" is filtered out, and the rest of the string is returned.\n\nI'd say it's non-intuitive but terrible is a little harsh.\n\nNot in my opinion.\nIf the substring is the only thing in the string, then the function should return the substring.\nThis is in the same category as the author's example:\n>>> filter_by_substring([], 'a')\n[]\n>>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for c in strings:\n       if (substring in c):\n          return [c]\n\nTo people who don't know Python, this looks like a really strange thing to do, and it is. The problem is that the `filter_by_substring()` function is quite a bit more general than the example function. It can be used to select anything from a list by something from the list, which would make a lot of the example code harder to follow.\n\nIn Ruby:\nfilter { |s| \"s\" in s }\n\nThe \"filter\" method is actually really nice. I think the reason it's not in Python is that they are not adding features to Python 3.0, only removing and changing.\n\nThat's not true. They're adding features, they're just trying to keep the feature set of 3.0 very small, and the feature set of 3.1 very large.\n\nAs far as I know, you are correct. The standard library will not be increasing in 3.0, but the language is.\n\nThe reason is that Python doesn't allow function definitions on the left of", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if len(substring) > 0 and string in substring:\n            list.append(string)\n    return list\n\nOr in Python 3 (assuming \"List\" is \"List[str]\":\nfrom typing import List, Tuple", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter_by_substring(strings, substring)\nThis is obviously a toy example, but there are two problems with it. First, it's very easy to create these kinds of objects in a normal Python program, so what's the point of inventing a new type just for the sake of a toy example?\nThe second problem is that it's actually a little difficult to understand the second line of code, because it's not obvious that the filter_by_substring function returns a different object from the one on which it is called. If you had written something like this:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(string.startswith(substring, 'a')).reverse()\nThe article has some other interesting examples as well. I particularly like the use of the new Lazy and StopIteration from the itertools module.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, strings)</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return sorted(strings.index(substring, strings.end())[0], reverse=True)\n\nThis has saved me a lot of time.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for substring in strings:\n        if not substring:\n           return strings\n        if strings:\n            return filter_by_substring(strings[substring:], substring)\n\nAh, now I get it. I didn't understand the HN title at all, and even when reading the article, I didn't really get what I was supposed to understand until I read the comments.\n\nI guess we're just getting old.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return len(strings)\n\nAnd with a slight modification:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if s.startswith(substring):\n           return s\n    else:\n           return []\n\nI'm a Python programmer and I know what this code does.\nI am not a Python programmer and this doesn't make any sense to me.\n\nIt returns the strings that start with substring. 'abc' is one of the strings that start with 'a'. 'bacd' is also one of the strings that start with 'a', but not 'abc'. 'cde' is not one of the strings that start with 'a'. 'array' is not one of the strings that start with 'a', but 'abc' is.\n\nYou can even look at the source code and see what it does.\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\n    return strings.filter(substring)\n\n    for x in filter_by_substring('abcdefghijklmnopqrstuvwxyz', 'abc'):\n        print x\n\n    >>> a = ['abc', 'defghijklmnopqrstuvwxyz']\n    >>> b = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y']\n    >>> for x in filter_by_substring(b, 'a')", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(strings, lambda s: s.find(substring, -1))\n\nCould someone please explain to me why this would be better than the built-in method?\n\nit uses lambda, which is cool...\n\nYou can do that in Python, too.\n\nYeah, that's the point.\n\nIt's not. Here's an example of an (implicit) lambda used in a built-in Python function:\n>>> def fib(n):\n...        return n if n <= 2 else fib(n - 1) + fib(n - 2)\n...        return fib\n>>> fib(10)\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n>>> fib(10) - fib(10)\n[0, 0, 0, 0, 1, 1, 2, 3, 5]\nYou can also use lambdas as an explicit function, like this:\n>>> def fib(n):\n...        return n if n <= 2 else lambda n: fib(n - 1) + fib(n", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(None, strings, lambda s: substring(s))\n\nI am baffled, I am a big fan of functional programming, and python is my first choice of language, but this just seems like a pretty silly exercise to me, I would never do this. I would never want to do this, and I have no idea why anyone would want to do this. I am genuinely curious about what use case this fills, but can't think of any.\nWhat does this do that you can't do with a list comprehension?\n\nI agree that it's an odd and contrived example, but it's not far removed from the sort of problems that are common in data processing. You often have a list of strings, and you want to find all those that contain a substring. The problem is more complicated when you want to keep the substring you're searching for (for example, if the list comes from a database).\nThe difference between this and list comprehensions is that this is a functional solution.\n\nThis is a beautiful demonstration of how to extract the essence of functional programming.\n\nI really liked this.\n\nAnd this is the essence of the functional paradigm in Python.\n\nAnd this", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for item in strings:\n       if substring in item:\n           return item\n\nThe \"for\" loops are not necessary, the iterator is already mutable, so you can do\nfilter_by_substring(strings, substring)\nand it will work just as well.\n\nI don't know if that's what you meant but I'll do it anyway:</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return (list.filter(None, lambda s: s.startswith(substring))).to_list\n\nI hope you find it useful. Please let me know what you think.\n\n(this is my first submission)</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if s.startswith(substring):\n         return s\n\nsubstring in ['abc', 'bacd', 'cde', 'array']\n\nYes.\nI'd also be interested in how this performs.\n\nIt's just a simple binary search on a sorted list. How can it be slow?\n\nIt's not that it's slow, it's that I'd like to see a timing benchmark.\n\nThe timing will be dominated by the binary search. As I said, I don't see how this can be slow.\n\nYou're not understanding.\nThe comparison performance (which is the most important here, not the search) is completely dependent on the performance of your sorting algorithm. I'm interested in the sorting algorithm used by this code.\n\nSort is a built-in Python function, and it's O(n log n) for n elements. So it's not the sorting algorithm that's the bottleneck here.\n\nI know it is.\nMy point was that if there is a better way to sort a list of strings, then the performance of the subroutine", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(lambda x: (x[0] == substring), strings)\n\nthis is interesting, but I'm not sure this is a better approach than.find() from collections. The difference is that this version has to do a full comparison for every element in the input list, whereas.find() (assuming the string is in the dictionary) will only compare if it's equal, then return the first match.\nthat being said, if you have a list of dictionary keys, then this is a good way to filter out the key you want.\n\nI agree with you. I think if you look at this it may seem confusing. I've tried to keep it concise so it's easier to understand.\nThe difference with this is that it works with a list. So if you have a dictionary and a list of strings to filter against, it works great. It could also be useful to filter elements from a dictionary based on a different value.\n\nI'm still not following what's so useful about this. It's basically a function that does a lookup on the input (or the first lookup, since it's a dict), and then returns the first match.\nCould you give an example of what this is", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(List.filter(strings, 'in' + substring), strings)\n\nThis seems to miss the point of the example, which is that he wants to know\nhow to find the shortest substring that contains a given character, not how\nto filter out everything but the shortest one.\n\ngood point. but you could probably convert that with a little recursion.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       for substring in s:\n          if len(s) == len(substring):\n               return s\n    return []\nThe functional equivalent of:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings == list(substring):\n        return strings\n    else:\n        return filter_by_substring(substrings[-1:] + strings)\n\nA more idiomatic Python solution would be:\nfor i, str in enumerate(input):", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(lambda s: s in substring)\n\nI'm not sure what is so special about this?\n\nOne can make it better. But you have to do some work.\n\nSure, but how is this a 'python-ism'? This is just a simple filter.\n\nThis is just one of many things that make Python special to me.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if not (strings.find(substring)):\n        return strings\n    return [str(i) for i, string in enumerate(strings) if string[0] in substring]</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\nI'm sure this is the obvious answer, but I'm not sure why this is the best solution.\n\nIt is the best solution because it's the shortest, and therefore is most likely the most efficient.\n\nI think this is the best solution, for the same reason.\n\nBecause it is the shortest?\n\nNo. Because it is the shortest.\n\nI think the \"because it's the shortest\" is a better answer than the actual one. It gets to the point, which is the whole reason we are doing this in the first place.\n\nFrom typing import * is what the Python book recommends:\n\"The first time you import a module, you need to specify the name of the module and the module's __name__ attribute. When you import a module a second time, you can skip the name and __name__ attributes and just write the module's name\"\nI think this is the best solution:\n\nI've found that's only really useful if you have a number of \"super\" modules, each of which contains one or more \"sub\" modules. It makes the super modules more readable, and means you can make super module specific", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for i, s in enumerate(strings):\n       if s == substring:\n          return strings\n    return []</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    new_list = []\n    for s in strings:\n       if strings.find(substring)!= -1:\n          new_list.append(s)\n    return new_list\nThis is about as silly as \"from time import sleep\". I'd prefer to see a custom built-in like:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return len(strings) - len(strings[0]) == len(substring)\n\nI get that you're trying to show an example of how the class and method work, but I don't think that's the best way to do it. The 'a' from the example in the parent should have come from a tuple, not an array, since you need to compare the length of the substring to the length of the string.\n\nIt seems to me that this is a good example of a situation where the functional programming style gives you more power and flexibility.\n\nExactly. This is exactly the situation where functional programming shines.\n\nThat's silly. Functional programming shines when you need to perform a linear search through a collection. It does nothing to aid in the concept of \"skipping ahead\" with a filter.\n\nYou can skip ahead using the built-in zip function\n\nzip is about collecting the elements in order, not skipping ahead.\n\nThis is a good case study in why duck typing (as opposed to static typing) is really nice.\n\nYou could also do this in a statically-typed language using the zipWith method of List:\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\n    return strings.filter(x for x in strings.get(substring))\nOh, that's nice, I didn't know about that one.\nI like that I can now have an input list of strings that contain the substring 'a' without having to worry about whether that list contains 'a' or not.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings[len(strings) % substring == 0]\n\nWell done!\nIt's not obvious to the author, but apparently obvious to others. I learned something!\n\nIt's not obvious to the author, because it's wrong.\n\nOh, I've just realized I'm wrong.\nI had this idea that the function is only called for strings that are non- empty. But then, the filter returns a list of the strings that have the substring 'a' in them.\n\nIs there a good place to suggest features to pandas? I think adding a `to_csv` method would be nice.\n\nTry this thread \n\nIf you're a Rubyist like myself, check out my port of the DataFrame API to Ruby: \nIt's pretty ugly in some places but it's been a good way to learn more about the pandas API.\n\nAre you planning to integrate other data structures into the API?\n\nI'm definitely going to try and get a scatter plot in there.\n\nNeat. I would have expected this in the Python standard library (and I'm still surprised it isn't).</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for str in strings:\n       if substring in str:\n          return str\n\nfrom typing import List\n\n    def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    for str in strings:\n       if substring in str:\n          return str\n\nfrom typing import List\n    def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_sub", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return len(strings) - len(substring)\n\nI see this kind of thing _constantly_ \\- I can't for the life of me figure out why it's so common. Why is it so common?</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for string in strings:\n        if string == substring:\n           return string\n\nHere's another one that I didn't find in the article, but seems quite useful:\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return [x for x in strings if x.startswith(substring)]\n\nIt is very easy to do the same thing in python:\nListL = [x for x in strings if x.startswith(substring)]\n\nYeah, but this is the Python mailing list.\n\nThe author of the post is probably aware of this, since he seems to be a Python contributor.\nIt's probably a dig at the \"import this\" trend.\n\nI thought that might be the case, but then I'd have been surprised to see such a simple statement posted to the mailing list.\n\nI was surprised to see that it was posted to the mailing list.\n\nThere's a lot of people interested in solving a lot of the same problems and coming up with a lot of the same solutions. This is just one of those things that people have to do from time to time.\n\nIt's not uncommon for people to post code snippets to the python-ideas mailing list, but it's usually a very short snippet, and is more interesting than a one-liner.\n\nWhy are people so happy to write in Python, but when it comes to posting to the mailing list,", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings\n\nIn Python 2.4, the built-in function itertools.tee() can be used for the same purpose:\nfilter_by_substring = lambda s:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\nThe best part is that the author is not aware of list comprehensions.\n\nI'm not familiar with list comprehensions. What are they?\n\nhttp://docs.python.org/library/listcomprehensions.html\n\nOr, you know, just use the built-in `filter`:\n>>> from typing import List >>> l = [1, 2, 3, 4, 5, 6] >>> s = 'a' >>> l.filter(s) [2, 3, 4, 5, 6, 1] >>> l.filter(s, l.endswith('a')) [1, 2, 3, 4, 5, 6]\n\nWow, that's...terrible.\nThe correct way to do that is with a generator expression:\n>>> l.generator(s='a') [2, 3, 4, 5, 6, 1]\n\nYou're both right. `filter` is a built-in function, but the argument list is a generator expression.\n\nThat's not how it works in Python though. A generator expression is a way of defining an iterator in Python. There are", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings\n    def filter_by_substring(strings: List[str], substring: str, count: int) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a', 2)\n    ['abc', 'bacd', 'array']\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a', 5)\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a', 3)\n    ['bacd', 'cde']\n    \"\"\"\n    return strings\n\nyou will never be allowed to use that import. I had to make a comment about it, because if you don't, someone will come along and scream at you for violating the PEP 8 style guide and that will make you sad and you'll never write another line", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for i in strings:\n       if strings[i].find('a') == substring:\n          return strings\n\nHow does it work?\n\nThe explanation given is correct.\n\nHint: the builtin _range() can be used to avoid redundant loops.\n\nYes, and you can also do it like this:\nfor i in range(len(s)):", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings[substring] is None:\n    return strings\n    else:\n       for s in strings:\n          if strings[s] == substring:\n               remove_if(s, \"\")\n    return strings\n\nPython has a similar syntax, but not one that's a method on lists. It's nice to see someone thinking about what a list is.\n\nFrom what I've seen, people seem to complain the most about Python's `[]` syntax, while I've always found it to be a nice feature.\nIn this instance, I think the syntax works well too. The _only_ thing that I dislike about it is that it's a static method, instead of a dynamic method on the list object.\n\nIn Python 2, it's a static method. In Python 3 it's a dynamic method.\n\nI can't wait for Python 3.x to be the default Python. I never liked the Python 2.x syntax, but until 3.x is mainstream, I have to learn it.\n\nIt", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings[substring]!= '':\n       return strings\n    return []\n\nThe Python community really needs to settle on a standard style guide or something. This is an almost direct copy of the built-in filter() function, with the only difference being that it returns a list instead of a tuple. But look at how much more verbose this is than the built-in function!\n\nThe problem is that the built-in filter is _not_ something that you can use everywhere, and in particular not something that you can easily use in a generic way.\nFor example, if you have a list of strings, how can you easily find all strings that match a given regex? You can't use filter(), because it only works on lists. So you end up using something like:\nre.findall(s, r)\nI find that a lot less readable than using something like filter_by_substring.\n\nIf the stringlist is an iterable, which it is in the case of filter(), you can do:\nfor str in strings:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.startswith(substring))\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return [", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n         if not substring in s:\n            return []\n    return s\n\nI'm not sure if it's exactly what you want, but you could use list comprehensions, eg:\nfiltered = []\nfor item in a:\n    if item[0] == 'a':\n         filtered.append(item)\n\nI was thinking something like this. Just wondering if there was an easy way. Thanks!</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\nfor x in strings:\n    if x in string_to_match:\n       return x\n\nx is a list of str, not strings.\n\nHN, please start putting the original author's name in the title of articles.\n\nI love the idea, but not the implementation. The implementation is bad because the list comprehension is not the same as a list of strings.\nI think it would be better to use a class and the standard python filter methods. If you did this, you could use the class as a way to pass in some kind of \"regex\" for pattern matching.\n\nThis is the same as using the substring() function. Why not use a function?\n\nI think you mean the re.sub() function.\n\nSorry, I meant sub.\n\nI know but I don't think it is the same. \"List of strings\" would be more like something like:\n>>> [\"abc\", \"a\", \"b\", \"c\"]\nAnd this would not match \"abcde\".\n\nIf you do this in javascript you get\nArray\n(\n[\"a\", \"b\", \"c\"]\n[\"abc\", \"b", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for i in strings:\n        for substring in substring:\n            if strings[i] == substring:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return List(filter(list, substring))\nI think that the \"from typing import List\" should be unnecessary. The article has a heading that says \"Pythonic way to filter a list of strings\". The example is definitely not Pythonic.\n\nIt's a very good point, I wrote it to show the _function_, not the code.\nI'm not sure how to make it clear that \"filter_by_substring\" is a function without using the \"from typing import...\" syntax.\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if substring == s:\n             yield s\n\nI don't get it. What am I missing here?\n\nIt's an example of the List() type, which isn't very interesting on its own.\n\nThank you. I thought it was an example of some specific type of list, and it was supposed to be ironic, or something like that.\n\nOK, I'm not a Python programmer (although I'd like to be), but this looks like a \"list comprehension\". It allows you to chain a bunch of stuff together.\nIn this case, you can do something like:\n[word for word in this_text for word in that_text for word in other_text if word.starts_with(\"a\")]\n\nYou're right about it being a list comprehension, but I think the example you give is a bit too complex for a novice to really be a useful illustration.\n\nThe 'for' loop is more complex than the comprehension. I would say it's good enough.\n\nI understand the for loop just fine. The comprehension makes me think", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if substring in s:\n          return s\n\nI think you should rename it to something like \"filter_for_substring\" or \"filter_with_substring\" because as it is, the name doesn't describe what the function does at all.\n\nI agree.\n\nI'm not sure I understand the value of this.\nIf I have a list of strings and I want to filter out the ones that contain the substring \"a\", I can just do it as a list comprehension:\n[x for x in strings if x.startswith('a' if x in ['a', 'abcd']])\nBut if I have a list of strings and I want to filter out the ones that contain the substring \"a\", I can also just do it as a list comprehension:\n[x for x in strings if x.startswith('a' if x not in ['a', 'abcd'])]\nThe only difference is the substring if/else in the second one.\nIs there a benefit to making this a standalone function?\n\nYou could also", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if len(strings) > 1:\n       return strings[0].substring(0, len(strings)-1)\n    else:\n       return strings\n\nThat's not too bad; it's just another way of doing \"filter(filter_by_substring, strings)\".\nWhat's more interesting is to see what they're doing with the result of the function:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\nI think this might be a little better:\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(lambda x: x.startswith(substring))\n\nI'm sure you meant:\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, lambda s: s.find('a'))\n\nIf you prefer one-liner code, you can always use itertools.tee\n\nfrom itertools import tee\nfiltered = [\n'a',\n'a',\n'a',\n'a',\n'a',\n'bacd',\n'cde',\n'array',\n'a'\n]\nfor s in strings:\n    tee(filtered, s.find('a'))</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.has_key(substring):\n       return [strings[substring], strings.pop(0)]\n    else:\n       for s in strings:\n          if s.startswith(substring):\n             return s\n\nThis is super useful, but I couldn't find it in the documentation and the google results were very sparse. I had to look at the source.\n\nAnd it's used in the documentation as the example of a custom filter.\n\nIt's an example of a custom filter that uses an iterable instead of a list, and calls has_key on the iterable. The docs describe how to do it without has_key, and it's the version I have to use (on windows, no has_key).\n\nIf it's an example of a custom filter that uses an iterable instead of a list, then it uses has_key.\n\nOne might assume it uses the built-in \"substring\" filter that was described in the documentation, and indeed you can do the same with \"", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, False).list()\n\nI think that you meant `filter_by_substring` not `filter_by_substring`.\n\nwhat's wrong with that? it's syntactic sugar that I've seen before.\n\nIt's bad style.\n\nIt's not \"bad style\", it's just not necessary and it increases the chance of misreading code.\n\n_\"Bad style\" in this case meaning \"bad style guide compliance\"._\n\nI'm pretty sure you're just using the term \"bad style\" to mean \"I don't like it\".\n\nI'm pretty sure you're just using the term \"I don't like it\" to mean \"I'm pretty sure you're just using the term 'bad style' to mean 'I don't like it'\".\n\nThat's an unnecessarily pedantic use of 'bad style'. That's all I meant.\n\n_\"That's all I meant.\"_\nAs is what I meant, but perhaps we can agree to disagree.\n\nI think this is a case of \"do as I say, not as I do\" (or \"my opinion is the only right opinion\").", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\n    return strings.filter(s -> s.startswith(substring))\n\nSlightly cleaner version:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings[substring] not in strings:\n        return strings\n    return []\n\nfrom typing import List\n\n    def filter_by_regex(strings: List[str], pattern: str, replace: str):\n    \"\"\" Filter an input list of strings only for ones that match given regular expression and replace them\n    >>> filter_by_regex([], '^abc$', 'a')\n    ['abc', 'abcd']\n    >>> filter_by_regex(['abc', 'abc'] + 'a', 'ab')\n    ['abc', 'abcd']\n    >>> filter_by_regex(['abc', 'abc'], 'a')\n    ['abc', 'abcd']\n    >>> filter_by_regex(['abc', 'abc'], 'aa')\n    ['abc', 'abcd']\n    >>> filter_by_regex(['abc', 'abc'], 'ab')\n    ['abc', 'abcd']\n    >>>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    \"\"\"\n    for s in strings:\n         if not filter_by_substring(s, substring):\n             return s\n    return []\n\nThis is nice, but if I want a list of strings I can filter it myself. If I want a list of lists I can do the same. But what I really want to do is a list of lists of lists of lists of lists of strings.\n\n>> _\"If I want a list of lists I can do the same. But what I really want to do is a list of lists of lists of lists of lists of strings.\"_\nIf you want a list of lists of lists of lists of lists of lists of strings, you can do it as follows:\n>>> from itertools import chain\n>>> for s in string_list:\n... if not s:\n... chain.from_iterable(s)\n... else:\n... chain.iterable(s)\n... print s\n>>> chain('abc', 'abcd', 'abcde', 'abcdef', 'abc123', 'abc456', '", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(lambda x: x.startswith(substring))\n\nCan't Python 3 do this natively? (I'm not sure if it's in standard library, I haven't really checked)\n\nYes, it's in the string module. There's a lot of other stuff in the string module, like the built-in regular expressions.\n\nWhere is the string module?\n\nString. I think it's also in the \"lang\" module.\n\nIt's also in the math module.\n\nNot to be confused with string.gsub in the functools module:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, None)\n\nNice</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s: strings, e: s.find('a'))", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for string in strings:\n        if string == substring:\n           yield string\n\nIt's actually easier to understand if you prefix the module name with \"from typing import\".\n\nAlso, the name of the module should be \"filtered_list\" or something along those lines.\n\nVery nice. A small suggestion:\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return List(filter(substring, strings))\n\nDoes anyone know the reason for importing the List module?\n\nI'm guessing it's for the print() function that's in it.\n\nAs far as I can tell, this is a matter of taste. It's not required. It's just a convention to use the print function.\n\npython 2.7.4\n>>> from typing import List >>> for x in 1,2,3,4:... print(x)... 1 2 3 4\n\nThat's because you are importing the List library, not typing.\n\nimport typing;\nimport List;\nfor x in 1,2,3,4:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.count(substring) > 1:\n       return strings\n    return []\n\n>>> import filter_by_substring\n\n        list = ['a', 'b', 'c']\n\n        print filter_by_substring(list, 'd')\n        [ 'b', 'c' ]\n\nwtf is this crap?\n\nThis is awesome.\n\nthe only problem is it's a pain to read.\n\nThat's why I always prefix everything I type with a ':' so it's easy to read, like this:\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return List(filter(str.rstrip(), \" \", substring))\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.contains(substring))\n\nIs this a joke? (I'm not a python coder)\n\nIt's a joke, it's trying to show the absurdity of using from typing import List.\n\nIt's actually a joke about Python's named imports - you have to import the module with the name \"List\", not the type \"list\".\n\nSlightly related, I've always wondered why Python requires you to import a module and not just a type, like, say, Haskell does.\n\nPython doesn't require you to import modules; it's just that the naming scheme for types is unfortunate and it's easier to just import modules.\nYou can use type names to import names, and import a module using \"from module import *\".\n\nI have no idea how this is supposed to be funny.\n\nThe idea is that, in the Python world, people type import this and import that all the time, and while it may not seem like it, import is a function.\n\nThanks, the post was a little confusing.\n\nYou guys have too much time on your hands.\n\nThe author works for Google. So yes, they do have", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings[substring]\n\nOh, I thought it was a joke at first.\n\nIn this example, the first string is a substring of the second.\n\nAh, I missed that the first time.\n\nThey could have at least imported the standard library in a more \"Pythonic\" manner:\nimport sys\n\nFrom the \"Why Python\" page:\n\"Python\u2019s name comes from the Monty Python comedy group.\"\n\nIt's funny that you pointed that out, because I just read that page earlier today:\nI wonder if python was in fact named after this comedy group, or if the use of the word \"python\" in the python documentation is a coincidence?\n\nIf you read the FAQ, they admit the latter.\n\nI don't know if this is serious or not, but I think it's a really cool idea, and probably a good way to learn the language, since you have to try to do things in different ways.\n\nI'm actually a fan of the idea, but this implementation is terrible. The string/list distinction is way too subtle for a new user.\n\nI have to say, my first thought was that this was a", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring).filter(substring)", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.count()!= 1:\n       return []\n    for s in strings:\n        if substring in s:\n           return s\n\nThe first version would be a little faster, but the second one seems to have a better style to it.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\n    for i in strings:\n        if i in substring:\n           return i\n\nI don't think python supports \"i in x\"\n\nThere are no built-in functions to do this. But it's not hard to write your own.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    s = strings\n    for i, s in enumerate(s):\n        if s.startswith(substring) and s.endswith(substring):\n              s = s[:s.endswith(substring)]\n    return s\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings == [] or strings == []:\n       return []\n       return filter_by_substring(strings, substring)\nCan anyone explain to me why this isn't just a normal function call?\n\nThe actual import is this:\nfrom typing import List\nbut there's no way to type that. So instead I type:\nimport typing as t\nand it does the rest for me.\n\nSorry, but I think this is a poor excuse. What you should do instead is\nto use a real programming language, with static typing, and make the t\nmodule an ordinary module, with the name typing, and only a single\nfunction type. Then the type will be the type of strings, and there won't\nbe any surprises.\n\nWhy? Just write better code. Python's list is homoiconic, so you can write\ncode like this:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s.rfind('substring', substring))\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings[substring]\n\nThe funny thing is that I was just reading about that list comprehension syntax yesterday. I wonder how many people know about it?\n\nCurious about that too - it is much easier to read.\n\nBut not as easy to write!\n\nI think it's easier to write. You don't have to remember the brackets around the condition.\n\nI've found that I never actually remember the brackets; I just know to look for them, or look for the []. Either way, it's no big deal.\n\nThis is a cool little trick, but it's not particularly Pythonic. It also has the downside of doing a lot of unnecessary work:\nfiltered_string = \"foo bar baz\"\nfiltered_string = filter(lambda x: x in [\"foo\", \"bar\", \"baz\"], filtered_string)", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if len(substring) == len(s):\n           return s", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings[0] == 'a':\n       return strings\n    else:\n       return []\n\nThat isn't the problem the author is having.\nHere's his problem:\n>>> for x in [1, 2, 3]:\n...      print x\n...      print \"*\"\n...      print \"*\"\n...      print \"*\"\n...      print \"*\"\n[1, 2, 3]\n1\n2\n3\n\nAnd his solution is\n>>> for x in list(range(4)):\n...      print x\n...      print \"*\"\n...      print \"*\"\n...      print \"*\"\n...      print \"*\"\n[1, 2, 3, 4]\n1\n2\n3\n4\n\nThat doesn't help at all, as he wanted only 1, 2, 3 to be printed.\n\nFor this particular case the easiest solution is simply", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if s == substring:\n          return s\n\nSo, for all the other strings, you're essentially returning them unchanged?\n\nI always get confused when people use 'a' as a substring.\n\nI think it was used as a simple example, to show that the filter was not applied to 'a'.\n\nExcept that it is applied to 'a', just not the first occurrence.\n\nWell, yes, but I think it's safe to assume that if you're just using 'a' as an example, you're not using 'a' to represent a substring.\n\nI think he was using 'a' to represent the empty string.\n\nThe author is conflating list operations with strings, so I don't have high expectations for this.\n\nWell, to be fair, that's pretty much the point of the article.\n\nAnd it's a valid point, it's just an old one.\n\nThe author is ignoring the fact that list operations are not operations on strings, but rather on lists of _strings_. This is because Python (and, for that", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if strings[s].startswith(substring):\n          return s\n\nPEP 8 says:\nIt is good style to use a period to end an identifier if the identifier is itself a single word. For example, ``str``, ``yield``, ``for``, ``if``, ``except``, ``assert``, ``import``, ``from``, ``while``, and ``with`` are better than ``str``, ``yield``, ``for``, ``if``, ``except``, ``assert``, ``import``, ``from``, ``while``, and ``with``. (The latter are especially bad since they are keywords in Python.)</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        for i in range(len(s)-substring[0]):\n           if s[i] == substring:\n               s.remove(i)\n    return s\n\nI just have to say, that for Python the syntax is a bit strange. The \"from typing import *\" is usually reserved for so called \"imports\" of types. And what does \"def\" do in this context?\n\nI think you have to consider that the Python docs are going to be read by people who are used to programming in other languages, so I think they explain things in a more abstract way.\n\nI did not mean to critisize the docs. I thought they were really good. My point was, that the code was a bit hard to read and you have to remember that people who know programming will be reading the python docs.\n\nHere's some code I used to convert a Java array to a python list and back:\n\nI wonder why they don't use.join() in the second loop.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return list(filter(None, strings, substring))\nThis is not a good example of how to use the iterator pattern.  Here's one\nthat is:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\n    if strings.count() == 1:\n        return strings\n    else:\n        return None\n\nI'm more of a Python newbie than I let on in my blog post, so if I've\ndone something seriously wrong here, I would be really grateful if\nsomeone would point it out to me.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for string in strings:\n       if string.startswith(substring):\n          return list(string)\n\nIf you like this, try this:\nfrom typing import TypeError", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return [str.lower() for str in strings if substring in str]\n\nFiltering with regular expressions is more flexible, concise, and idiomatic:\nfrom itertools import chain\nfrom typing import List, str", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings:\n        return []\n    elif strings.startswith(substring) == 0:\n        return strings\n    else:\n        return filter(strings, substring)\n\nAs a Python developer I'm curious what the practical use is for this.\n\nI don't think there is much of a practical use, but I don't see why it couldn't be useful for someone learning Python.\n\nIn that case I would suggest learning about lists in Python first. There is a more fundamental need for this basic knowledge that should be addressed before attempting this type of utility function.\n\nYou're probably right. I'm sure that this little function isn't the most useful thing to learn in Python.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(strings, '^', substring)\n\nIt is idiomatic to use lambda instead of filter_by_substring:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings[substring]\n\nThe examples shown in the introduction are horribly contrived. Here's one that's much easier to grok.\nTake any arbitrary list of strings. Say it's [1,2,3,4].\nThen filter the list to get the list of strings that contain the substring 'a'. In python, this is done like so:\n>>> filter_by_substring(['1', '2', '3', '4'], 'a') [['a', 'a'], ['a']]\n\nSo, the function basically returns a list of the strings in the input list, with the strings that contain the substring 'a' removed.\n\nYou're right. That's just as contrived.\nHere's something useful:\nLet's say you have a list of strings in the following order:\na\nb\nc\nd\ne\na\ne\nThen you can apply a filter_by_substring to get a list of the strings in the following order:\nd\nb\nc\na\ne\na\ne\nNote how the strings containing a are at the beginning of the list.\n\nIt was never", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\n    for s in strings:\n       for c in s.split(substring):\n          if len(c) > 0:\n              return c\n\nfilter_by_substring is a very simple example of a filter that can be used in\nPython. It's a function that takes a list of strings and a string as input and\nreturns a list of strings. The input string is used to filter the original\nlist.\n\nfilter_by_substring(['abc', 'bacd', 'cde', 'array'], 'b') == ['abc', 'array']\n\nWhen Python sees a double-quoted string in a string literal it knows that the\nstring is supposed to be run as a statement, so it passes it to the\nfilter_by_substring function.  Python doesn't know that 'b' is the\nsubstring we want to use, so it searches for a substring that looks like\n'b' and returns it. In this case, the filter is successful since the input\nstring looks like 'b'.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for i, (s, j) in enumerate(strings):\n       if s[0] == substring:\n          return s[1:]\n\nWow, what a beautiful piece of code! It uses an algorithm that will always work. It is a good use of recursion.\nThe only problem is that the algorithm is not stable. If strings happen to be sorted (such as a file in a string database) then the algorithm would return the wrong result.\n\nIsn't the problem just as easily solved using filter()?\n\nRight. filter is the safe bet. filter_by_substring is less efficient. But I was just trying to show how you could write the code using the Python way of doing things. And, like I said, the code will always work, no matter what the input is.\n\nfilter() does not work for strings that contain substrings of themselves, though.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if s.startswith(substring) == False:\n          return []\n    return s.substring(0,len(s))\n\nIt's not idiomatic, but it works:\nfrom typing import List, string\nfrom functools import partial", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    list = []\n    for s in strings:\n        if s[0] == substring:\n           list.append(s)\n    return list\n\nThis doesn't seem like a problem that a programming language can solve well.\n\nI agree with you. And I'll add that I find it hard to take the post seriously when it starts out with a basic mistake. The one from the article is a common one that everybody makes, but still:\nfrom typing import List\nThis is _not_ a mistake in python. This is _how_ you do type declarations in python.\n\nI'm not sure you understood the post. The author was being sarcastic.\n\nI did. Sarcasm doesn't work well on text. I thought the author was being serious.\n\nMy favorite:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n         if (substring in s):\n            return s\n\nI like this approach. I wonder how it would work in JavaScript though.\n\nI think the extra syntactic noise might get in the way of a compact\nexpression. But I do like how it can be used as a short-circuit. I don't\nthink you can do that with built-in JS filters.\n\nAn interesting approach, but I think it would be too verbose in general.\n\nSome of these are. Others, like filtering out certain html tags or\nsubstrings, are not.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    # a = \"aaabcdcde\"\n    # b = \"bacd\"\n    # c = \"cde\"\n    # d = \"array\"\n    # e = \"efghi\"\n    # f = \"gghijklmnopqrstuvwxyz\"\n    # G = \"ghijklmnopqrstuvwxyz\"\n    # h = \"iijklmnopqrstuvwxyz\"\n    # I = \"jklmnopqrstuvwxyz\"\n    # J = \"klmnopqrstuvwxyz\"\n    # K = \"mnopqrstuvwxyz\"\n    # L = \"pqrstuvwxyz\"\n    # M = \"rstuvwxyz\"\n    # N = \"stuvwxyz\"\n    # P = \"wxyz\"\n    # Q = \"z\"\n    # R = \"", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(lambda x: x.substring(substring, 1))\n\nIt's also possible to avoid the temporary variable and the lambda in the for loop by using \nThe function is called with the following arguments:\nsubstring  - the substring to be searched\nindices - the indices of the substring to be searched in the list\nappend - whether the substring should be added to the end of the string or not.\nappend = False - add the substring at the end of the string\nappend = True - append the substring at the beginning of the string\nreturns a list of all the strings which contain the substring.\n\nThe lambda in the filter is necessary because the List constructor will _not_ return a list of strings with the given substring removed; it will return an entirely new list.\n\nSeems like there is a lot of overhead in the lambda call. It would be interesting to see if there is an even more efficient way to do this, without the lambda.\n\nI think the overhead is mostly in the type of the list.\nI think it's a type error to do\nreturn []\n\nI don't know python, but", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(substring, strings)\nSo this is a list comprehension, but it's a method on a different class. Why not just `filter_by_substring`?\n\nYou would have to import the module and `filter_by_substring` wouldn't be a method that you can call on a list.\n\nI really want to agree with you, but I can't. It's like replacing a set of if-statements with a switch statement, but it's not that much of an improvement.\n\nI like the fact that they did this.\nThe idea of Python is that the language is simple and high level, but you can still get access to the internals if you need to.\n\nI think the idea of Python is more that it's a dynamic language that's high level, simple, and high performance. That it has an internals that you can access is a side effect of that, not the goal.\n\nThe idea of Python is that it's a language for programming.\n\nPython, the language for programming.\n\nI think that's a bit of a misnomer. While it's true that Python is a very good language for programming, its", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\nThis is just a Python module wrapper for the Python function \"filter\" from the Python standard library.\n\nAh, i see now, I was confused as to why it was using __init__ and __len__ (I am still new to Python).\n\n\"python\" doesn't do it. \"python3\" does. But the former is a lot more common.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if not strings:\n        return []\n    for s in strings:\n         if not substring:\n             return []\n              if 'a' in s and 'a' in substring:\n                 return s\n\nThis would be a more interesting question if there were an actual requirement to use Python.\n\nI'd say it's a very interesting question whether there is or not.\n\nIt is not.\nIf you need to choose a language for a problem, you must choose the one that is best suited for the problem, not the one that is most familiar to you.\n\nAssuming that a person has experience in a language and is familiar with its features and limitations, that person is in a better position to judge which language is best suited to a problem than a person who has no experience with the language.\nThe OP's question suggests that he has a lot of experience with Python and very little with Ruby. It's therefore perfectly reasonable for him", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for x in strings:\n       if x == substring:\n          return strings\n    return []\n\nIs this actually faster than just using a list comprehension?</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\nThat's a good example of why I think Python is a poor language for teaching. The example is syntactically incorrect.\n\nI didn't want to include a full example of Python's grammar, and the `List[str]` is a built-in (i.e. it doesn't have a name). It does do what I want, though.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\n    return strings.filter(substring).sort()\n\nObviously this is just a joke, but it's amusing that the example is not immediately obvious as being a joke.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return []\n\nFor the past few months I have been using Python with Django to implement the backend of a web application. I am extremely happy with Django, but I think I am in the minority: the only people I know that use it professionally are in the same company I am working for. I think that is a shame, and would like to try to spread the word.\n\nI am mostly a Windows developer, and I have only a smattering of Linux experience. I have not had to use the command-line much, but when I have I have found Python to be a much nicer experience than Perl, which is the language I am most familiar with. I am not saying Python is better than Perl, but it is a much nicer experience on Windows.\n\nOne of the nice things about Python is that you can write short one-line programs, and have them run just as well as big complicated programs. This is a great thing for prototyping. For instance, the other day I needed to write a script that would calculate the total number of lines in a file, the number of blank lines, and the number of lines that contain exactly three spaces. I was able to write a short script to do this in about 5", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\n    for s in strings:\n        if strings[s] == substring:\n           continue\n         else:\n            return strings\n\nYou're not allowed to have an else clause inside an if/elif.\n\nso the \"else\" clause should be moved to the else section at the end of the if/elif?\n\nI think the easiest way to fix it would be:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(None, strings.filter_by_substring(substring))\n\nAlthough I know the example is contrived, I find the use of `None` in the function more confusing than the use of the builtin `filter`.\n\nI found the use of None in the function more confusing than the use of the builtin filter too, until I realized it was just a convenience function for using the builtin filter.\n\nThis was the first Python function I made when I was learning the language. I guess I'm still stuck in the \"I'm too cool for built-in functions\" phase.\n\nI'm not sure I understand the point of this. Surely the same thing can be accomplished with:\nfilter(None, strings.filter_by_substring(substring))\nI guess this is more readable, but it's still a bit confusing.\n\nI think it's trying to show that filter is a built-in function.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\nThis is a really neat solution. It makes me wonder if there is a good way to make something similar work with functions.\n\nA more flexible solution would be to use dictionary-based filtering, with a dictionary of strings and the filter string:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for i, item in enumerate(strings):\n       if item.startswith(substring) == 0:\n         return i\n\n    return strings\n\n Because of Python's syntax, I can't tell if this is a joke.\n\nIt is a joke. It's in the article, \"Practical Python: 103 Tips & Tricks\" by Allen Downey. (\n)\n\nWhoops, missed it!\n\nThis would be a useful version of the function:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.count(substring) > 0:\n        return strings.filter(substring, None)\n    return strings\n\n\"But what if I want to pass in a different string every time?\"\n\nFor a list comprehension you can just use map() instead:\nList[str] = [str[1:] for str in strs if str[0] == 'a']\n\nThis is a great tip for people who are completely new to Python!\n\nBut you could also write it in 3 lines:\nfrom typing import List\nfilter_by_substring = (strings:List[str], substring:str) -> List[str]\nfilter_by_substring('abc', 'a')\nfilter_by_substring('abc', 'b')\nfilter_by_substring('abc', 'c')\n\nThat's why it's called a tip.\n\nThere's a difference between \"tip\" and \"hack\".\n\nIt's a hack in that it's a quick and dirty solution to a particular problem.\nIt's not a hack in that it doesn't use any of Python's undocumented features.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.count(substring) == 0:\n        return []\n    return List(strings[:], strings[:strings.count(substring)-1])\n\nThanks!\nThat's the first time I've seen that example using a tuple. Seems really awkward to me.\n\nIt's funny how many times the Python community will pat themselves on the back for how great Python is, then go and write code that makes Perl programmers weep with shame.\n\nDoesn't the Perl community do the same thing?\n\nI have only been a Perl programmer for a year or so, but I haven't seen it yet.\n\nI guess I'm a little biased, having been a Perl programmer for a long time and having seen some of the Perl community's nastier side, but I've seen some of the same kinds of things as the example I gave.\n\nI'm actually a little disappointed. That's a _very_ easy to understand example.\n\nI agree, but it's always nice to have some more examples.\n\nThe most straightforward way to do this would be to use an iterator. Here's a simple example of how to do", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if string.startswith(substring):\n          return s\n    return []\n\nEvery time I see this:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings\n\nThis is the shortest, correct answer. Kudos.\nI can't say I've ever had to do something similar, but I've certainly used\nfilter_by_index for more complicated cases.\n\nI once had to use filter_by_index to remove all non-uppercase strings from a string of mixed case. It wasn't elegant but it worked and it was short.\n\nThat's exactly how I would have solved it.\n\nAs a follow-up, I think that it's worth remembering that Python does have a \"filter\" function, and that it is in fact not the same thing as filter_by_index:\nfilter is part of the filter-iterator protocol, which includes filter_none, filter_all, and filter_map. It is\nfilter_none()\nfilter_all()\nfilter()\nfilter_map()\nI'm personally a fan of filter_map when I need to do something like this.\n\nI'm not familiar with any of the other filter functions but filter_by_index is pretty handy.\n\nIndeed. It is nice.\nI am just saying that filter_none is also nice.\n\nfilter_", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings == [] or strings[0] == substring:\n    return []\n    for s in strings:\n       if strings[s] == substring:\n          return s\n\nIs it just me or is this \"a little\" over engineered?\n\nIt's over engineered in the same way that sorting is over engineered (using recursion instead of a while loop).\nBut it's good to do so in order to learn how to optimize and make code more efficient.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings[substring]\nThat is, the filter function returns a new list, filtered by the given substring. However, the function name suggests that it returns a new list, filtered by some arbitrary substring.\n\nYou should also mention that the list type in Python is immutable.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(lambda s: s.startswith(substring),\n    None)\nI prefer:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for item in strings:\n        if item.find(substring) == None:\n            return items\n    return None\n\nIn Python 2.6, you can make this even more concise.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\n>>> import filter_by_substring\n>>> filter_by_substring(\"abc\", \"a\")\n['abc']\n>>> filter_by_substring(\"abc\", \"b\")\n['a', 'b']\n>>> filter_by_substring(\"abc\", \"c\")\n['a', 'b', 'c']\n>>> filter_by_substring(\"abc\", \"d\")\n['c', 'd']\n>>> filter_by_substring(\"abc\", \"e\")\n['c', 'd', 'e']\n>>> filter_by_substring(\"abc\", \"f\")\n['c', 'd', 'e', 'f']\n>>> filter_by_substring(\"abc\", \"g\")\n['c', 'd', 'e', 'f', 'g']\n>>> filter_by_substring(\"abc\", \"h\")\n['c', 'd', 'e', 'f', 'g', 'h']\n>>> filter_by_substring(\"abc\", \"i\")\n['c', 'd', 'e', 'f', 'g', 'h', 'i']", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(x) for x in substring.lower().split()", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return list(filter(lambda x: x[1] in strings, substring))\nI don't understand how this is related to Python, and why it's at the top of HN.\n\nBecause there is not much news about Python, some people post irrelevant stuff.\n\nI don't understand this. It is definitely related to Python as it can be used to filter strings.\n\nI don't understand why you were downvoted. I, too, don't understand this: it's clearly not a particularly interesting article, but it's still relevant to Python.\n\nHow is this related to Python? This is a bash script.\n\nA bash script that works with Python strings. I don't see how that could be unclear.\n\nIt seems clear to me, as well.\n\nWhat is it good for? Is it a concatenation of a single substring to another?\n\nIf you want to filter an existing list based on the beginning of a substring, this is one way to do it.\n\nCould be useful in a lot of places. The example given in the article shows that this is useful to filter substrings in a string.\n\nNot Python", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\nThere's also a way to do it in one line:\nstrings.filter(s.startswith('a'))\nYou can also create a class and have a function like this:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return [str(substring) for str in strings if not str.startswith(substring)]\n\nThis is a good example of why you should never do this sort of thing in a language where the built-in functions make it so easy to do this sort of thing.\n\nA useful example, but not necessarily a good example.\nIt is useful because it demonstrates a common need that is generally hard to do in Python, which is to ignore some values that are in a list.\nBut the way this example works is quite ugly and convoluted.\n\nOne thing I would add to the \"convoluted\" part is that it is hard to reason about.\nI've seen several examples like this which appear to be simple at first glance, but the implementations tend to be very fragile and hard to maintain.\n\nThe general idea is good, but in python it is so easy to use the built in _filter_ \\- it might be better to use that, and then in the example to re-implement it using _filter_ in a simpler and more readable way.\n\nI agree. The built-in filter is very powerful and you can use it to create your own filter with any complexity", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return lists.filter(x for x in strings if x.startswith(substring))\n\nWow, that's a really nice idea. No language I'm aware of has a built-in function that will take any list and return a list that contains every string, only those strings that match a given pattern. The closest I can think of is Python's regular expression syntax, but you still have to loop through the list and check each character.\n\n_No language I'm aware of has a built-in function that will take any list and return a list that contains every string, only those strings that match a given pattern._\nThat's because it's actually a _functional_ programming construct.\nIn other words, it's an abstraction that's useful in functional languages but doesn't translate very well to imperative languages.\n\nThe example given seems to work in Python.\n>>> 'foo' in [ 'foo', 'bar' ]\nTrue\n>>> 'foo' in [ 'foo', 'bar', 'baz' ]\nTrue\n>>> 'foo' in [ 'foo', 'bar', 'baz', 'qux' ]\nTrue\n>>> 'foo' in [ 'foo',", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring).sort()\n\n I think this one is much better, although the python version doesn't seem too bad.\nYeah, I really like the way python does things in this case.  The only thing I would change is to make the method take a list and not a string.  That way it would be easier to use in different situations.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring,'in'+ str)\n\nSeems like it would be more idiomatic to use the string module:\nfilter_by_substring = lambda s: s.startswith(substring)\n\nUsing the string module is _way_ more idiomatic. I've always been a fan of starting with the Python standard library and only using third-party modules when they are strictly necessary.\n\nIt doesn't have to be _way_ more idiomatic - you can use'startswith' without importing it.\n\nI guess the question then is, why would you not import the string module? It's there for a reason, and it makes your code cleaner.\n\nHacker News is a good example of a text-based list filter.\n\nI'm glad you found this useful! I used it a lot on a previous project of mine that was a little more complex than this, so I knew it would be useful for a lot of people.\n\nI think this is a really good example of how an idea can be small, but still be useful. Good work.\n\nCool, I guess a similar filter could be used for regex's,", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for strings in strings:\n        if strings[substring] == 'a':\n           return strings\n    return []\n\nTo be honest, this is a really cool and useful thing to have in your codebase. I'm not really sure why it was submitted here, because it's not particularly Pythonic; it's an interesting C# feature that someone figured out how to emulate in Python.\n\nIt's like a _really_ simple version of a regular expression.\n\nIt's nothing like a regular expression.\nThis is a filter, not a search.\n\nTrue, the semantics are different, but it's fairly easy to build a regex that accomplishes the same thing:\n\nThere are a few different problems with this approach, the first being that you can't capture the substring and call a function on it later. So for example, if you want to match \"abc\" or \"bacd\" then you can't do something like:\nfilter_by_substring(['abc', 'bacd'], 'd')\nThe other major difference between this and a regular expression is that the Python", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if len(s) == substring:\n         return s\n\nLooks like a lot of people are new to Python and trying out the language.\n\nI'm glad for that.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s: strings,'substring')\nThis is the problem I have with Python.\nNo. No, it's not.\nThe problem with Python is the fucking syntax. It's fucking stupid.\n\nPython is far from the only language that has this syntax. I guess if you are coming from other languages, the syntax looks different. But it's really not that bad at all.\n\nBut it is!\nI'm used to Lisp, which is a language with a very small syntax. And what I really like about Lisp is that it has the syntax to match the language, so the syntax is an aid to writing code, it doesn't get in the way.\nPython on the other hand has an idiotic syntax that makes writing code much more difficult.\nI'd say that if you're used to Python, you're used to bad syntax.\n\nI am used to writing C and Java. I find Python's syntax to be quite nice and similar to what I would write in Java. What exactly is it that you find difficult?\n\nI find it difficult because it is not an aid to writing code, but gets in the way.\nLisp is the opposite. The", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(List(), ''.join(substring, strings), xrange(len(strings) - 1))\n\nfrom typing import List\n\n    def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return filter(List(), ''.join(substring, strings), xrange(len(strings) - 1))\n\nfrom typing import List\n    def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n      return strings.filter(substring).unique()\nThe number of times I've seen lists passed into functions for filtering.\nDoes anybody actually do that? It seems incredibly awkward.\n\nYou can use it if you want to remove duplicates in a list of strings. It is not the most common use of filter but it is valid.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\n    if not isinstance(substring, unicode):\n        return []\n    else:\n        return substring in strings\n\n    @l.filter_by_substring(strings, 'a')</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.count(substring) > 0:\n        return strings.filter(str.contains(substring))\n\nWhat's the point?\n\nFor one thing, it's a perfect example of the \"I'm smarter than you\" attitude that is pervasive among Python programmers.\n\nI'm curious as to why you think this. The only way that I can see this being viewed as \"I'm smarter than you\" is if the author put it in a blog post/book/whatever and is trying to show off his/her code. If it was just a comment, then there's no way I can see that.\n\nI think the 'from typing import List' is an example of a 'pointless' import. It doesn't do anything and is more of a comment on the code being written than the code itself.\n\nThe from typing import List is the only comment on the code. It's a self- contained example of the code, that's all.\n\nMy own version:\nfrom collections import defaultdict", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n        return []\n    len = len(strings)\n\n    for i in strings:\n        if not isinstance(i, str):\n          return []\n        if substring == i:\n           return i\n    return len\n\nBetter example:\n>>> import collections\n>>> import filter_by_substring\n>>>\n>>> filter_by_substring([], \"a\")\n[None, None, None]\n>>> filter_by_substring([[\"a\"], \"b\"], \"c\")\n[\"b\", \"c\"]\n>>> filter_by_substring([], \"a\", \"b\", \"c\")\n[None, None, None, \"a\"]\n>>> filter_by_substring([[\"a\"], \"b\"], \"c\", \"d\")\n[None, None, None, \"c\"]\n>>> filter_by_substring([[\"a\"], \"b\"], \"c\", \"d\", \"e\")", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(lambda s: not s.startswith(substring), 1)\n\nThis is my implementation of the standard library's list.filter()\nfunction. It's about three times faster than the standard list.filter()\nfunction, which is no doubt a result of Python's dynamic typing.\nIt took me a long time to understand how to write it.\n\nI think you're being a little too hard on yourself. I don't know Python very\nwell, but this seems like a fairly straightforward transformation:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return (filter(lambda x: x in strings,", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings\n\nYou are missing the `return`.\n\nDidn't expect the lack of'return' to break it, but I fixed that. Thanks!</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(lambda s: s in strings, substring)", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(None, strings, substring)\nVery interesting. I just wrote a quick Python script to see if it was similar:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, 0)\n\nthe title is wrong, should be \"from string import filter_by_substring\"\n\nThe title is different from what the article says.\n\nHe is being sarcastic.\n\nAnd this is the reason I'm not a python programmer.\n\nOh, come on, it's a joke.\n\nIs it a joke? Is it a serious suggestion? I don't know, that's the point.\n\nYou could just learn the language, and then you'd know.\n\nIt's hard to learn the language when you don't know if the author is being sarcastic or serious. It's a difficult language, and you need to learn what's in, and what's out.\n\nIt's not hard. It's a very straightforward language. You can learn it from scratch in a weekend.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\n    for s in strings:\n        if s in substring:\n           return s\n    return []\n\nThanks for sharing! This is a neat little function, and I'm sure I'll find many occasions to use it.\n\nI've never used Python, but I would have written this as\nfilter_by_substring(strings, substring):\nfor s in strings:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n\nI understand that this is just a random snippet, but why import `List` and `str` if you are only using the latter?\n\nThe same reason people type `import random` when they only want to use `rand`. It's a pattern that is easy to read.\n\nThe best way to read this snippet is to imagine that you're the person who originally wrote it.\nWhat was the problem that you had?\nIf your answer is, \"I want to filter a list of strings for ones that contain a substring\", why did you import List?\nIf your answer is, \"I want to filter a list of strings for ones that contain a substring, but I want to do it using the substring as an argument to a function\", why did you use the word \"filter_by_substring\" rather than \"filter_by_substring_as_argument\"?\nIf your answer is, \"I want to filter a list of strings for ones that contain a substring, but I want to do it using the substring as an argument to a function, and I want to be able to use this function in other situations\", why didn't you write \"filter_by_substring_as", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.strip())\n\nI'm curious, how does this work? Does it do a regular expression search, or a character-by-character comparison?\n\nIt's implemented as a list comprehension. It takes two arguments, \"strings\" and \"substring\", and returns \"strings\". It first converts all of \"strings\" to a list of substrings by stripping off the delimiter and then filters that list for all the strings that contain \"substring\".\n\nI understand what it does. I'm asking if it is a regex search or a regular expression search.\n\nNo. It's a regular expression search.\n\nShouldn't that be \"from string import string\"?\n\nNo, string is a built in type.\n\nI know, but I'm pretty sure it was a joke.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.count() == 1:\n        return strings\n    else:\n        for s in strings:\n           if substring == s[0]:\n               return s\n   \n\nI was going to say \"Oh hey, that's really cool!\" but then I looked at the Python version and was like \"Yeah, that's pretty obvious.\"\n\nI've been trying to get the hang of Python. Is there a trick I'm missing, or are the Python examples just that much more verbose?\n\nPython's functional programming support isn't very good. In fact, the implementation in the standard library is a joke.\n\nI don't know what you're talking about. Python has a ton of functional programming support and it's very good.\n\n... like?\n\nmap, reduce, list comprehensions. Those are just the first ones that come to mind.\n\nBut those are all built-in functions.\nI don't think Python's support for actual _functional programming_ is very good.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    def get_substring_index(str):\n    \"\"\"\n    Return position of substring'str' in string'strs'\n    >>> get_substring_index('abc', 'bacd')\n    1\n    >>> get_substring_index('abc', 'abc')\n    2\n    >>> get_substring_index('a', 'abc')\n    2\n    \"\"\"\n    return (str, len(strs) - 1)\n\nI'm not even sure why I should know about this.\n\nI can see how it could be useful for a lot of string-related tasks. Like:\ns.substring(s.find(\"a\"))\n\nI'd have just used \"s.find('a')\" or \"s.replace('a', 'a')\".\n\n\"s.substring(s.find('a'))\" is considerably shorter.\n\nI'd have just used \"s.find('a')\" or \"s.replace('a', 'a')\".\n\nI don't understand why that's", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if len(s) == substring:\n           return s\n    return []</s>"]]