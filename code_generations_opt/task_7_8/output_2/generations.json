[["from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for i in strings:\n        if i == substring:\n            return i\n    return []\n\nI like this. I've been looking for a way to do this for a while now.\nI've also been looking for a way to do something like:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for string in strings:\n       if string.startswith(substring):\n          return string\n\nAs an aside, this code is actually very similar to the code in the article, except that it doesn't do the case folding.\n\nIt's not very similar, it's exactly the same, just with a different implementation.\n\nI don't think it's exactly the same. The original code is quite a bit more readable, because it's not doing the case folding. The code in the article uses a case statement, and it's easy to miss the fact that it's a case statement, because the case statement is nested inside a list comprehension.\n\nI'm not a Python programmer, so I'm not sure if the author is using a list comprehension to make the code shorter, or because it's a more idiomatic way to do this in Python.\n\nA list comprehension is a way to make a list of expressions in Python. It's a common idiom.\n\nIt's worth noting that the code in the article is more pythonic than the one in the comments. It's idiomatic to use list comprehensions to filter lists", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.startswith('a'))\n\nThis is a nice example of the kind of code that can be written in Python.\nIt's pretty clean, but you can see that it does not follow the Python style guide. It does not use \"Pythonic\" idioms. It is not obvious how to read the code.\n\nAn idiomatic Python solution would be something like:\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if substring == s:\n          return s\n    return None\n\nThis is pretty much a direct copy of a Python idiom for the same task.\n\nIt's a neat trick, but it's not \"from typing import List\" that's doing the trick. The trick is that Python allows you to pass arbitrary functions as the parameter to the filter() method.\n\nAnd what is the type of that function? A callable that takes a string and returns a string.\n\nThe type is a string.\n\nIt is a string.\n\nI don't know why you're being downvoted.\n\nI don't know why you're being upvoted.\n\nI don't know why you're being downvoted.\n\nI don't know why you're being downvoted.\n\nI don't know why you're being upvoted.\n\nI don't know why you're being upvoted.\n\nI don't know why you're being upvoted.\n\nI don't know why you're being downvoted.\n\nI", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(lambda s: s[substring])\n\nI'm not sure if it's just me, but I think this is a bad idea. It looks like a hack and you're not using the language's features.\n\nI'm not sure if it's just me, but I think that you're a bad idea.\n\nI think you're wrong.\n\nI think you're right.\n\nI think that you're wrong.\n\nI think that you're right.\n\nI think that you're wrong.\n\nI think that you're right.\n\nI think that you're wrong.\n\nI think that you're right.\n\nI think that you're wrong.\n\nI think that you're right.\n\nI think that you're wrong.\n\nI think that you're right.\n\nI think that you're wrong.\n\nI think that you're right.\n\nI think that you're wrong.\n\nI think that you're right.\n\nI think that you're wrong.\n\nI think that you're right.\n\nI think that you're wrong.\n\nI think that you're right.\n\nI", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.startswith(substring))\n\nI love Python, but I find it's dynamic typing to be a bit of a double-edged sword.\nOn one hand, it makes the language easy to learn and easy to write. On the other hand, it makes it difficult to write robust code in certain situations.\n\nI think the author is trolling.\n\nI think you're trolling.\n\nI'm not. I'm saying that the author is trolling.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if s == substring:\n           return s", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.count(substring) > 0:\n       return strings\n    else:\n       return []</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\nI am not sure what the point of this is.\n\nIt's a tiny example to demonstrate the power of Python's dynamic typing.\n\nIt's not a good example, though. The real power of Python's dynamic typing is that it can adapt to a lot of different problems. The real world isn't simple string manipulation.\n\nBut it's a great example to demonstrate the power of Python's type inference.\n\nHow so?\n\nBecause it's a great example of how you can write code that you don't have to type.\n\nThis is a cool example, but I don't think it really demonstrates the power of Python's dynamic typing. You could write the same thing in Java or Ruby or any other language that has dynamic typing.\n\nYou can write the same thing in C.\n\nThis is one of the worst examples of Python's dynamic typing I've ever seen. It's a trivial example that you could write in any language.\n\nIt's a trivial example, but it's trivial because it's a demonstration of Python's type inference.\n\nThis is not a demonstration of Python's type inference. It's a trivial example that you", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(lambda s: s[substring], strings)\n\nI think it's more idiomatic to use `filter(lambda s: s.find(substring))`.\n\nI've used that before, and I agree that it's a bit more idiomatic, but the other way is also fine. I find it a bit easier to read, though.\n\nI'm not sure I agree.\nThe first is a little more verbose, but it's also a little clearer.\nThe second is a little more terse, but it's also a little less clear.\nThe second is also a little more likely to result in bugs.\n\nI think I agree with you. I prefer the first one. I just didn't see it that way at first.\n\nThe second one is not only more terse, it's more likely to result in bugs.\n\nI prefer the first one, but I'm not sure why.\n\nI think the first one is more clear, but I don't know why.\n\nI like the second one, but I'm not sure why.\n\nI like the first one, but I'm not sure why.\n\nI like the", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if len(s) == substring:\n          return s\n    return []\n\nI've always thought the Python standard library documentation was great, but I had never noticed this gem:\n\nI find it a bit strange that they don't use an explicit for loop.\n\nI guess the reason is that the list comprehension is more readable.\n\nPython is so much nicer to read than Java, which I've been doing for the last couple of years.\n\nI think Java is a lot easier to read than Python. Python's syntax is a bit more like Lisp, which is great if you are already familiar with it, but can be confusing if you are coming from a different background.\n\nI think that's only true if you're coming from a background that doesn't use indentation to separate blocks of code. I find Python much easier to read than Java because the indentation makes it clear where blocks begin and end.\n\nI find Python easier to read than Java, but I'm not sure that's because of the indentation. I think it's the fact that it's much more terse", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for i in strings:\n       if i == substring:\n          return i\n\nThat's a really bad example. It's not clear that the code is actually doing what you want.\nIt's not clear that the first parameter is a list. It's not clear that the second parameter is a string. It's not clear that the third parameter is a substring.\n\nI think it is pretty clear. It's a list of strings. It's a string that is to be filtered.\n\nIt's a list of strings, a string that is to be filtered and a function to filter the string.\n\nI have to say, I love Python. I've been using it for a few years now and it's just as fun to use today as it was the day I started.\n\nI love python too but I'm getting sick of the way it's used.\nI'm sick of seeing it used as a glue language instead of as a real programming language.\nI'm sick of seeing it used as a quick and dirty way to make a web app.\nI'm sick of seeing it used as a quick and dirty way to", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for x in strings:\n       if x == substring:\n          return x\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if s == substring:\n          return s\n    return List(s)\n\nYou can also do this:\nfrom typing import List, ListComp", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.startswith(substring))</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.startswith(substring))\nThis is great! I've been looking for something like this for a while.\n\nThis is a pretty cool little snippet. I can see how it could be useful in a lot of situations. I'm not sure how I would use it though.\n\nI like it, I might use it.\n\nCool.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if s.startswith(substring) and s.endswith(substring):\n            return s\n    return []\n\nThis code is broken in several ways.\nFirst, it's not a good idea to rely on the order of the elements in a list. If you change the order of the strings, the code will break.\nSecond, it's not a good idea to rely on the order of the characters in a string. If you change the order of the characters in the substring, the code will break.\nThird, it's not a good idea to use \"and\" in a boolean expression. This is a common source of bugs. Instead, use \"or\".\nFourth, it's not a good idea to use a ternary expression in a loop. This is a common source of bugs. Instead, use an if-else statement.\nFifth, it's not a good idea to use a list comprehension in a loop. This is a common source of bugs. Instead, use a for-loop.\n\nIt's also not a good idea to be", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s -> s.startswith(substring))</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, lambda s: not s.startswith(substring))\n\nThis is the Python equivalent of the C function strstr:\n\nstrstr(string, string, delimiter, [flags])\n\nIf the string argument does not match the string delimiter, return the string argument.\nIf the string argument matches the string delimiter, return the first occurrence of the string in the string argument.\nIf the string argument does not match the string delimiter and the string argument is not empty, return the string argument.\nIf the string argument does not match the string delimiter, return the string argument.\nIf the string argument matches the string delimiter, return the last occurrence of the string in the string argument.\nIf the string argument does not match the string delimiter and the string argument is not empty, return the string argument.\nIf the string argument does not match the string delimiter and the string argument is empty, return an empty string.\n\nIt's interesting that Python's strstr is a list comprehension, while Ruby's is a function.\n\nIt is also interesting that it is a list comprehension in Python 2.6.\n\nIt's interesting", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for i, s in enumerate(strings):\n       if s.startswith(substring):\n          return s\n    return []\n\nIt's nice, but it's also a bit of a trick. It's not really a string filter, but a list filter.\n\nI don't see what you mean. It filters the list of strings for those that contain a substring, and returns a list of those strings.\n\nThe point is that it's not a function that takes a string as input and returns a string. It takes a string and returns a list.\n\nThe function doesn't take a string as input. It takes a list of strings.\n\nThe point is that the function does not take a string as input.\n\nThis is a list of strings:\n>>> [ 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s for s in strings if s.startswith(substring))\n\nI've been a python developer for over 10 years and this is the first time I've heard of typing.\n\nIt's part of the Python 3.6 standard library.\n\nI see.\n\nIt's a bit weird to call it a list of strings if you're going to implement a list of strings using it.\n\nYou can do it with a list of integers or floating point numbers too.\n\nI think the point is that a list of integers is just a list of integers, not a list of integers that implement a list of integers.\n\nThis is actually pretty nice. I often do this in Python, but it's usually a bit more verbose and harder to read.\n\nNot sure why you're being downvoted. I've been doing this in Python for years and it's always been a bit annoying.\n\nI think it's because the code looks like it would be better suited for C# or Java.\n\nThis is a bit odd. I feel like this is an example of a solution looking for a problem.\n\nI don't think it's odd at", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\nWhy not just:\nreturn strings.filter(substring, list(0))\n\nBecause that doesn't work for strings that contain the substring.\n\nI have a hard time understanding how the author thinks this is a bad idea:\n\"A lot of people will say that this is a bad idea. They\u2019ll say that it\u2019s bad because it makes the code less readable, and harder to understand. I\u2019m not so sure about that. I think that a good programmer can understand and read code in any language, as long as it\u2019s well written. If you\u2019re a bad programmer, then you\u2019re going to have a hard time no matter what language you use.\"\n\nI think the author is right, but I'm not sure he's talking about the same thing as the people who say it's a bad idea.\nIt's a bad idea to use Python as a domain-specific language for string manipulation. It's a good idea to use it as a general-purpose language for everything else.\n\nI don't think this is the case. Python is a great language for string manipulation.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings[substring] is None:\n       return []\n    else:\n       return strings\n\nIt's also worth noting that the above is a great example of why you shouldn't use default arguments.\n\nI think it's a great example of why you should use default arguments.\n\nI'm curious why you think so. The code is more difficult to read and debug, and the default values are not guaranteed to be the ones you want.\n\nBecause the default values can be changed.\n\nI'm not sure I follow. Can you give an example?\n\nIf you don't want to use default arguments, you need to add extra code to set the default values. If you do want to use default arguments, you just need to change the default values.\n\nI think the real lesson is that you should always use the same convention in all your functions, and that convention should be that parameters are passed in order of precedence.\n\nI've found that when I have a lot of functions with similar behavior, the convention of passing parameters in order of precedence is not always the best. For example, if I have a function that can take", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if substring in s:\n           return s\n    return []\n\nYou can use this to filter out all the strings that do not contain a given substring:\n>>> filter_by_substring('abc', 'a')\n['abc', 'abcd', 'abcde', 'bcd']\n\nThis is a nice example of a list comprehension, which is a list of expressions that are evaluated for each element in the list. It's also a good example of the fact that Python is a multi-paradigm language.\n\nIt's not a list comprehension. A list comprehension is a list of expressions that are evaluated for each element in the list _and are used as the values of the elements of the list_.\n\nI think you're confusing the list comprehension notation with the list comprehension syntax.\nThe list comprehension notation is simply a list of expressions enclosed in parentheses. The list comprehension syntax is a language feature that allows you to write such a list of expressions and have it be treated as an expression that is applied to the elements of the list.\n\nThe syntax is what matters", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(substring, strings)", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\nfor x in filter_by_substring([], \"a\") :", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\nfrom typing import List\n\n    def filter_by_substring_with_count(strings: List[str], substring: str, count: int) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring_with_count([], 'a')\n    []\n    >>> filter_by_substring_with_count(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    >>> filter_by_substring_with_count(['abc', 'bacd', 'cde', 'array'], 5)\n    ['abc', 'bacd', 'array', 'abc', 'bacd', 'array']\n    \"\"\"\n    return strings.filter(substring, count)\n\nfrom typing import List\n\n    def filter_by_substring_with_count_by_index(strings: List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s for s in strings if s.startswith(substring))\n\nThe more I read these \"python tips\" the more I'm convinced that python is a terrible language to learn.\n\nI've seen this sentiment on HN before. I'm curious what language you would recommend for beginners.\n\nI don't know, I'm not a beginner. But I don't think python is a good language to learn programming with.\n\nWhy not?\n\nBecause it has a lot of bad design decisions and it's very easy to write bad code.\n\nI would love to hear an example of a \"bad design decision\" that Python has that makes it a bad language for beginners.\n\nThe fact that it's very easy to write bad code is a bad design decision.\n\nWhat are some examples of bad code that would be easier to write in Python than in other languages?\n\nThe code in the OP is pretty bad.\n\nIt's not the best code in the world, but it's not bad. It's not even hard to read.\n\nIt's not bad, but it's not good either. And it's not really Python's fault that it", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if substring in s:\n           return s\n\nI know it's a joke, but it's still kinda funny.\n\nIt's not funny. It's sad.\n\nWhy?\n\nI think the point is that it's a very simple function, and that the\nPython standard library is so rich that it includes a function called\n\"list\" that returns a list.\n\nI think the point is that it's a very simple function, and that the\nPython standard library is so rich that it includes a function called\n\"list\" that returns a list.\n\nThat's not funny either.\n\nThat's not funny either.\n\nTrue, it is not funny.\n\nPython's syntax is pretty simple, and you can see that in the code. The\ncomplexity comes from the language itself.\n\nI would like to see a language that does the opposite. It's syntax is\nextremely complex, but the language itself is extremely simple.\n\nI would like to see a language that does the opposite. It's syntax is\nextremely complex, but the language itself", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if substring == s:\n           return s\n\nand the equivalent python:\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s => s.find(substring)).to_list()\n\nI don't know why, but I like this a lot more than the Python version.\n\nIt's a lot more readable.\n\nI like the Python version better. It's cleaner and shorter.\n\nI agree.\n\nThe Python version is more concise.\n\nIt's not shorter, it's just more verbose.\n\nI've never been a big fan of the \"import this\" syntax. It's not that it's a bad idea, but it doesn't seem to be used consistently.\nFor example, you can import the built-in file objects, but you can't import the built-in file object for a file opened with a specific mode, like \"r+\" or \"r-\".\n\n\"import this\" is used by Python in the same way that \"from\" is used by C++. It's a convenience to avoid having to write the full path to the module every time you use it.\n\nI'm not sure I understand. It's not like \"from\" is some obscure feature of C++. It's a fundamental part of the language.\n\nI", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\nI always wondered why people use this instead of the built-in slice() function.\n\nBecause slice() has a bug: it doesn't handle empty strings correctly.\n\nI think you mean the slice function in python 2.x. Python 3.x's slice has been fixed.\n\nNo, I'm talking about the slice() function in Python 3.x.\n\nI'm not sure if you're aware, but Python 3.x is not the only version of Python in existence.\n\nI'm not sure if you're aware, but the original poster said:\n\n_I always wondered why people use this instead of the built-in slice() function._\n\nI was responding to this, not the original post.\n\nI'm not sure if you're aware, but the original poster said:\n\n_I always wondered why people use this instead of the built-in slice() function._\n\nI was responding to this, not the original post.\n\nI'm not sure if you're aware, but the original poster said:\n\n_I always wondered why people use this instead of the built-in slice() function._", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if substring in s:\n           return s\n\nThat's a nice, short, clean example. I would have used a dictionary instead of a list, though.\n\nI don't think the example is very good.\nI don't like the syntax for the filter function.\nI don't like the syntax for the substring function.\nI don't like the syntax for the for loop.\nI don't like the syntax for the for loop.\nI don't like the syntax for the for loop.\n\nIt is a good example, but I would have used a dictionary instead of a list.\n\nI don't think the example is very good.\nI don't like the syntax for the filter function.\nI don't like the syntax for the substring function.\nI don't like the syntax for the for loop.\nI don't like the syntax for the for loop.\nI don't like the syntax for the for loop.\n\nIt is a good example, but I would have used a dictionary instead of a list.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(substring, strings)\n\nfrom typing import List, string", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings[filter(substring, strings)]\n\nThis is a very nice example of how Python's type system is not as powerful as it could be. The above function will work with any type of string, but it would be much better if it could be restricted to strings of a certain type, for example, strings of type \"text\".\n\nYes, it's a good example of how Python's type system is not as powerful as it could be.\nThe problem with your suggestion is that it's not possible to restrict a function to only work on one type of thing.\nYou could try and define a new type of string that is limited to only 'text' strings, but that would only work if you could somehow require every function to be able to work with that type of string.\n\nI'm not sure what you mean by \"not possible to restrict a function to only work on one type of thing\".\nThe idea is to define a new type of string that is limited to only \"text\" strings.\n\nI mean that you can't define a function that only works on one type of thing.\nIn the case of Python, you can't define a function that only works on one type of string", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings:\n        return strings\n    else:\n        return []\n\n    def filter_by_regex(strings: List[str], regex: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given regular expression\n    >>> filter_by_regex(['abc', 'bacd', 'cde', 'array'], 'abc')\n    ['abc', 'bacd', 'array']\n    >>> filter_by_regex(['abc', 'bacd', 'cde', 'array'], 'abc.*')\n    ['abc', 'bacd', 'array', 'abc', 'bacd', 'cde', 'array']\n    \"\"\"\n    if strings:\n        return strings\n    else:\n        return []\n\n    def filter_by_regex_with_index(strings: List[str], regex: str, index: int) ->", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if substring in s:\n          return s\n\nI think this would be better as:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(lambda s: s in strings, substring)\n\nI don't get it.\n\nIt's a list comprehension.\n\nWhy isn't it called filter_by_substring_list()?\n\nBecause there's no reason to.\n\nI think the reason is that it's a list comprehension.\n\nI don't get it.\n\nI think the reason is that it's a list comprehension.\n\nI still don't get it.\n\nI think the reason is that it's a list comprehension.\n\nI still don't get it.\n\nI think the reason is that it's a list comprehension.\n\nI still don't get it.\n\nI think the reason is that it's a list comprehension.\n\nI still don't get it.\n\nI think the reason is that it's a list comprehension.\n\nI still don't get it.\n\nI think the reason is that it's a list comprehension.\n\nI still don't get it.\n\nI think the reason is that it's a list comprehension.\n\nI still don't get it.\n\nI think the reason is that it's a list comprehension.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for string in strings:\n       if string.startswith(substring):\n          return string\n    return strings\n\nThere's no way to use a for loop in Python?\n\nNo.\n\nI'm not sure I follow the logic. The example given is not a for loop, but a filter. In particular, the loop variable is not a list, but a string.\n\nThe example given is a filter, yes.\n\nI don't get it. What's the point of this?\n\nTo show that Python is a functional language, I guess.\n\nIf you can do this in Python, then you can do anything in Python.\n\nThis is what happens when you get a bunch of people who are only familiar with imperative programming languages to write a functional programming language.\n\nNo, this is what happens when you get a bunch of people who are only familiar with imperative programming languages to write a language that has a lot of features that are easy to use in an imperative style.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if s.startswith(substring):\n          return s\n\nI'm not sure what your point is.\n\nI don't get the point either. The point of this is that it's not obvious that the function returns a list of strings. It would be more obvious if the function was named filter_by_substring_list or something.\n\nI think he's saying that the function name is misleading. It's not a list of strings, but a list of strings that match a pattern.\n\nThat's exactly my point. The function name should be more explicit.\n\nI think it's a fair point, but I think the trade off is worth it.\n\nI don't think it's worth it. The function name is misleading. The function name should be more explicit.\n\nI'm a little surprised that the author didn't mention the fact that you can pass a tuple to the function.\n\nI'm a little surprised that the author didn't mention the fact that you can pass a tuple to the function.\n\nI'm a little surprised that the author didn't mention the", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n       return strings\n    return []\n\nDoes this really do what it says it does? I'm not a python programmer, but I'm pretty sure it doesn't.\n\nIt does not. It just returns a new empty list.\n\nI'm pretty sure that's the joke.\n\nThis is a classic example of a \"joke\" that would be funnier if it didn't look like a real thing.\n\nAs a non-Python programmer, I thought it was a joke, but then I saw a comment that it was a classic example of a \"joke\" that would be funnier if it didn't look like a real thing.\n\nI thought it was a joke, but then I saw a comment that it was a classic example of a \"joke\" that would be funnier if it didn't look like a real thing, and then I saw your comment.\n\nI thought it was a joke, but then I saw a comment that it was a classic example of a \"joke\" that would be funnier if it didn't look like a real thing, and then I saw your comment, and", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for i in strings:\n        if i.startswith(substring):\n            yield i\n\nI don't think this is very impressive. The same can be done with a Python list comprehension:\n[x for x in \"abc\" if x.startswith('a')]\n\nI don't think this is very impressive. The same can be done with a C function:\nint main(int argc, char **argv)\n{\nstring[] words = \"abc\";", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if s.startswith(substring):\n          return s\n\nThat's pretty cool. I'm not sure if it's better than the built-in \"in\" operator, but it's definitely more readable.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s, substring)\n\nThis is a nice example of the \"not invented here\" syndrome.\nIt's also an example of a \"me too\" syndrome. Python has a built-in function\nfilter() that does exactly the same thing, and it's available in the\nstandard library.\n\nIt's also an example of the \"not invented here\" syndrome. C has a built-in\nfunction strstr() that does exactly the same thing, and it's available in\nevery C library ever written.\n\nAnd it's also an example of the \"not invented here\" syndrome. The C\nstandard library has a built-in function strcpy() that does exactly the\nsame thing, and it's available in every C library ever written.\n\nAnd it's also an example of the \"not invented here\" syndrome. C has a\nbuilt-in function memcpy() that does exactly the same thing, and it's\navailable in every C library ever written.\n\nAnd it's also an example of the \"not invented here\" syndrome. C has a\nbuilt-in function strcpy() that does exactly the same thing, and it's", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\nI'd prefer:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(substring, strings)\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.\n\nThis is one of my favorites.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if s.startswith(substring):\n           return s\n\nWhy not just use\n[x for x in strings if x.startswith(substring)]?\n\nBecause in that case you'd have to type the substring in every time you wanted to filter.\n\nIn Python 2.5:\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if strings[s] == substring:\n           return s\n    return []\n\nThis is a fairly common pattern that's been around for a while. It's easy to see that the filter is recursive and therefore that the final result is not a list, but a generator.\n\nI'm not sure if I'm missing something, but I don't see how the final result is a generator.\n\nThe problem is that Python's generator protocol is not based on the concept of tail-call optimization, so it's not obvious that the above is a generator.\n\nI'm not sure I understand. Does tail-call optimization mean that you can define a function that returns a generator?\n\nIt means that you can define a function that returns a function that returns a generator.\n\nI'm still not following. I thought the filter function is a function that takes a list and returns a list. It doesn't return a function.\n\nIt returns a function that takes a list, and returns a list.\n\nI think I'm starting to understand. So the filter function returns a function that", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for i in strings:\n       if i.startswith(substring):\n          return i\n\nI've seen this pattern before. I don't like it.\n\nI have to agree. The code is a bit noisy, but it's not clear to me what the alternative is.\n\nI don't think it's noisy at all, it's pretty clear what's going on.\n\nIt's a bit of a mouthful, but I don't think it's bad.\n\nIt's a mouthful, but it's not bad.\n\nThe alternative is to use the built-in filter() function. It's not much shorter, but it's more concise.\n\nIt's also less general, though, which is the point of the article.\n\nI agree, but I think the example of using a list comprehension is a bit misleading.\nIt would be a more compelling example to use a generator comprehension, because that's where the real power of list comprehensions is:\n\nI don't like it because it's not clear what is being filtered. Is it the substring or the string?\n\nIt's", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.count(substring) > 0:\n       return strings\n    return []\n\nThis is very neat! I didn't know about this.\n\nAlso, from the same module:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if substring in s:\n           return s\n    return []\n\nI've been working on a very similar project in my spare time, so I know how much work it is to get something like this going. I'd like to offer my thanks and appreciation for the hard work that's gone into this library.\n\nThanks! I'm always happy to see people making use of it.\n\nThat's a very nice looking library. I'll definitely be using it.\n\nThanks!</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s -> s.startswith(substring))\n\nThat's a pretty cool trick, but I'm not sure how it's better than the built-in filter().\n\nI'm not sure it is. It's not as readable as the built-in filter.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for string in strings:\n        if substring in string:\n           return string\n\nNice. I've been using something similar for a while:\n\nA slightly more readable version, IMO:\n\nNice, I've been using this for a while:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.count(substring) > 0:\n        return strings\n    else:\n        return []\n\nI'm a little confused. It seems like the only difference between this and the built-in filter function is that it doesn't return a new list, but rather modifies the original one.\n\nThe built-in filter function returns a new list.\n\nAh, I see. Thanks.\n\nThe built-in filter function is not a function, but an operator.\n\nI think the OP is asking \"why not make it a function?\"\n\nIf I'm understanding the question, the answer is that it's not a function because it's a built-in.\n\nIt's not a built-in because it's a function.\n\nThe difference between \"built-in\" and \"function\" is orthogonal to the difference between \"function\" and \"operator\".\n\nThe difference between \"built-in\" and \"function\" is orthogonal to the difference between \"function\" and \"operator\" _when you are talking about Python_.\nPython is a language with functions as first-class citizens", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return [str for str in strings if str.startswith(substring)]\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(lambda s: s[substring], strings)", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if s.startswith(substring):\n           return s\n\nThe thing is, Python has `list(str)` already.\n\nOne of my pet peeves about Python.\nIt's not a big deal but it is annoying.\n\nIt's a big deal when you're using it to write a parser.\n\nI don't see how. Can you give an example?\n\nI'm not the original poster, but here's a very simple example:\n>>> import re\n>>> l = ['a', 'b', 'c']\n>>> re.compile(r'^[a-zA-Z]$', l)\n['a', 'b', 'c']\n>>> l = ['a', 'b', 'c']\n>>> re.compile(r'^[a-zA-Z]$', l)\n['a', 'b', 'c']\n>>> re.compile(r'^[a-zA-Z]$', l)\n['a', 'b', 'c']\n>>> l", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if substring == s:\n          return s\n    return []\n\nThis is really useful.\n\nAnd yet, it's not.\n\nWhy?</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if s.startswith(substring):\n           return s\n\nI don't think that's the best way to do it.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s for s in strings if s.startswith(substring))\n\nI like it!</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(x for x in strings if x[0] == substring)\n\nI don't get the point. You can do this with list comprehensions:\n>>> from typing import List\n>>> l = List()\n>>> l.filter(x for x in l if x[0] == 'a')\n>>> l\n['abc', 'bacd', 'cde', 'array']\n>>> l.filter(x for x in l if x[0] == 'a' if x[1] == 'b')\n>>> l\n['abc', 'bacd', 'cde']\n>>> l.filter(x for x in l if x[0] == 'a' if x[1] == 'b' if x[2] == 'c')\n>>> l\n['abc', 'bacd', 'cde', 'array']\n>>> l.filter(x for x in l if x[0] == 'a' if x[1] == 'b' if x[2] == 'c' if x[3] == 'd')\n>>> l\n['abc', 'bacd', 'cde", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for string in strings:\n       if string.startswith(substring):\n          return string\n\nThis is the Python equivalent of perl's \"grep\".\n\nI think it's pretty neat. It's basically a recursive descent parser.\n\nI would have used the built in list comprehensions instead of writing\nit all out.\n\nI'm not sure it would be possible to do the same thing with list comprehensions.\n\nIt's possible, but you'd need a loop.\n\nI think this is more elegant, though.\n\nI agree, but it's not more efficient.\n\nThis is a very elegant solution, and a nice example of how python's built-in functions are powerful enough to do a lot of things you'd otherwise do with regular expressions.\n\nYou could also use it to parse a list of numbers, as long as they are in the format of \"01234\", where the first two digits are the tens column and the last two digits are the units column.\n\nI think you're right, and this is a very nice example of how you can use list comprehensions to parse lists.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.startswith(substring))\n\nThis is very similar to the Python's list.filter(str.startswith(substring)), which was also posted here.\n\nThat's because Python's list.filter() is based on a C-library function strstr() which is a reimplementation of the UNIX command string-match(1).\n\nI think he was just trying to point out that the two are very similar, not that they were identical.\n\nI see. I don't think the similarity is that great, though.\n\nIt's actually a pretty close match.\n\nI would say that it's a pretty close match as well, but I think the similarity between the two is more a coincidence than anything. The only thing that is identical is the signature of the function, but the implementation is very different.\nThe Python version is a _lot_ faster than the C++ version.\n\nI'm not sure I understand the problem this is solving.\n\nI think it's a simple case of a programmer wanting to use a built-in function in a different language.\n\nI think it's a simple case of a programmer wanting to use", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings:\n        return strings\n    else:\n        return []", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(lambda x: x.startswith(substring))\n\nI'm not sure I understand why this is useful.\n\nIt's useful for when you want to filter a list for a substring, but the substring is not at the beginning of the string.\n\nI'm not sure why you would want to do that. I guess I don't understand the use case.\n\nThe example given in the post is that you have a list of strings like ['abc', 'bacd', 'cde', 'array'] and you want to filter out the 'array' but the 'array' is not at the beginning of the list.\n\nI still don't get it. I would just want to filter out the 'array'.\n\nYou are right, that's the most common case. But sometimes you might want to filter out a substring that is not at the beginning.\n\nIf you want to do that, why not just use a list comprehension?\n\nI think the use case is that you have a list of strings like ['abc', 'bacd', 'cde', 'array'] and you want to filter out the 'array' but the", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(x.startswith(substring))\n\nI don't know Python, but in Ruby, I would write this like this:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return []\n\nThis is a very bad example, because it's impossible to know what the return type is.\nWhat is the type of the \"filter_by_substring\" function?\n\nI agree, it's a bad example because the return type is not defined. However, I think the intent is that it's a function that returns a list of strings.\n\nI'd say it's more of a function that takes a list of strings and returns a list of strings.\n\nI'm not sure what's the point of this. It's a pretty good example of how you can make a very simple and readable function, and then proceed to make it less readable and more verbose.\nI don't really see the point of the 'from typing import List' line. It's not like you're importing a module that adds functionality to the language, you're just importing a module that is used to help you write the code. The 'from typing import List' line is essentially just saying \"I'm writing Python code.\"\n\nI agree with you that the example is not the best, but I think it's supposed to illustrate that you can use the \"from\" statement to import modules that are not part", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if substring in s:\n          return s\n\nThere is a slight typo in the definition of filter_by_substring, it should be:\nfor s in strings:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(lambda s: s.find(substring, None), strings)", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, lambda s: s in strings).toList()\n\nIt's not a bad idea, but in the example, you're not really filtering. You're just looking for a substring that is in the list.\n\nThat's the point. I think he is trying to show that the filter method is a combination of list.filter and list.find.\n\nIs it just me or does the title of the article seem to imply that this is a new feature in Python 3?\n\nNo, you're not the only one. I'm sure it's not intentional, but it's kind of annoying.\n\nI'm not sure I see the point of this article.\n\nI think it's to show that list.filter is a combination of list.filter and list.find.\n\nI guess I'm missing something because I don't see how that's useful.\n\nIt's not useful, it's just a neat trick.\n\nI would rather have the ability to do `filter(s, s.startswith('a'))` than the ability to do `filter(s, s.endswith('a'))`.\n\nYou", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s for s in strings if s.startswith(substring))\n\nfilter_by_substring() is not a function, it's a method.\n\nI think the problem is that he was trying to make a function that took a list of strings and returned a list of strings.\n\nI think the problem is that he was trying to make a function that took a list of strings and returned a list of strings.\n\nI think the problem is that he was trying to make a function that took a list of strings and returned a list of strings.\n\nI think the problem is that he was trying to make a function that took a list of strings and returned a list of strings.\n\nI think the problem is that he was trying to make a function that took a list of strings and returned a list of strings.\n\nI think the problem is that he was trying to make a function that took a list of strings and returned a list of strings.\n\nI think the problem is that he was trying to make a function that took a list of strings and returned a list of strings.\n\nI think the problem is that he was trying to make a function that took", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.contains(substring))\n\nThis is a very common pattern. It's a very common mistake to use a List comprehension to implement it. It's often better to use a filter() call instead.\n\nI'd be interested to see a benchmark of this.\n\nI don't know about the other implementations, but the built-in Python filter() is pretty darn fast.\n\nWell, the built-in Python filter() is implemented in C.\n\nI'm pretty sure the built-in filter() is implemented in Python.\n\nThe built-in filter() is implemented in Python, using a C extension.\n\nI'm not sure if you're joking, but it's implemented in Python.\n\nI'm not joking, but I was wrong.\n\nI'm not sure if you're joking, but you were right the first time.\n\nI'm not joking, but I was wrong.\n\nI'm not joking, and I was right the first time.\n\nI'm not joking, and I was wrong.\n\nI'm not joking, and I was right the first time.\n\nI'm not joking, and I was wrong.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.startswith(substring)).filter(str.endswith(substring))\n\nI don't know about you, but I'd much rather type:\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n        return []\n    for s in strings:\n        if s.startswith(substring):\n           return s\n    return []\n\nNice. I like it.\n\nIn Python, you can make a function that returns a generator, then you can use the yield statement to get the results.\n\nThat's a really cool way of doing it. I'm surprised I've never seen it before.\n\nThanks. I've used it a few times.\n\nI think the original poster was looking for a way to apply a function to each element of a list. If you want to do this in Python, you can use the list comprehension.\n\nYes, that's exactly what I was looking for. Thanks!</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for i in strings:\n        if substring in i:\n           return i\n    return []\n\nfrom typing import List\n\n    def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    for i in strings:\n        if substring in i:\n           return i\n    return []\n\nfrom typing import List\n\n    def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s.contains(substring))\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s.substring, s.startswith('a'))\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if s.startswith(substring):\n             return s\n    return []\n\nNice. It's a shame that python doesn't have a \"default\" type like in Haskell.\n\nI thought the same thing, but then I realized that the python equivalent is just a list of lists, which is just as good.\n\nI have a version of this that I've used for a while:\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(lambdas: strings.iteritems(),", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(lambda x: x[substring], strings)\n\nI'm not sure I see the benefit of this over just using the built-in list filter.\n\nI agree. It seems like a solution looking for a problem.\n\nI'm not sure I understand what's so bad about this. If you need to filter a list of strings for a substring, this will do it for you.\n\nI don't think the poster is saying it's bad. I think he's saying it's not necessary.\n\nYeah, I'm not saying it's bad. I'm just saying it's not necessary.\n\nIs there a reason why this is better than the built in list.filter method?\n\nIf you need to filter a list of strings for a substring, this will do it for you.\n\nOh, I thought it was something more than that.\n\nI don't see why you would want this over the built in filter method.\n\nI don't see why you would want this.\n\nWhat's the benefit of this over the built in list.filter()?\n\nIf you need to filter a list of strings for a substring, this will do", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(None, strings, substring)\n\nI'm not sure what the point is of this code. It looks like it is an attempt to make a decorator, but the filter function is defined in the same scope as the decorated function, so it doesn't really work.\n\nIt's not a decorator. It's a function that returns a decorator.\n\nIn Python 2.7, the function does not return a decorator. It returns a function that decorates the function it is called on.\n\nI don't get it. It seems to be a decorator that filters a list of strings?\n\nIt's not a decorator. It's a function that returns a decorator.\n\nI don't get it. It seems to be a decorator that filters a list of strings?\n\nIt's not a decorator. It's a function that returns a decorator.\n\nI don't get it. It seems to be a decorator that filters a list of strings?\n\nIt's not a decorator. It's a function that returns a decorator.\n\nI don't get it. It seems to be a decorator that filters a list of", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings[0] == substring:\n       return strings\n    else:\n       return []", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if s.startswith(substring):\n          return s\n    return List(s)\n\nThe problem with this is that it's not tail recursive.\n\nIt's not a problem.\n\nI think the problem is that it's not a _pure_ function.\n\nThat's not a problem, either.\n\nWhy not?\n\nBecause it's a different sort of problem.\n\nIf you need to support tail recursion in your language, then you can't use this function.\n\nIt's not a problem.\n\nI can't tell if you're being sarcastic, but if you aren't, you should be more specific.\n\nI'm being serious. It's not a problem.\n\nThen what's the problem with having a pure function?\n\nThere isn't a problem with having a pure function. It's just that it's a different sort of problem than the problem you're talking about.\n\nI'm talking about having tail recursive functions in a language.\n\nI'm talking about the problem of writing a function that can be used as a", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, lambda s: s[0], 0)\n\nThis is a pretty common idiom, but I don't like it. It's too easy to forget the \"0\" at the end and get an empty list.\n\nIt's a good point. I like to use \"filter(substring, lambda s: s[0], -1)\" to avoid this.\n\nYou can also use filter(substring, lambda s: s[0], -1, 0) to make sure you get the last element of the result.\n\nIt's nice to see Python code with comments.\n\nThis is a _very_ old piece of code, but still a classic.\n\nIt's also a classic that it's almost never used. I've been in Python for years and I don't think I've ever seen it in production code.\n\nI've seen it used a few times, but it's a pretty niche idiom.\n\nI've seen it used in one place, and it was a horrible mess. I didn't want to touch it, and I don't want to touch it ever again.\n\nI had to use it to filter out", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s.startswith(substring)).filter(s.endswith(substring))\n\nThat's really cool.\n\nThanks!\n\nA good one is \"from collections import deque\" when using Python 2.x.\nIt's a deque, but it's a nice way of declaring a queue-like thingy.\n\nI'm pretty sure that's the recommended way to do queues in Python 2.x now.\n\nIt's the recommended way to do queues in Python 3.x, too.\n\nI'm not sure what's so great about this one.\nimport itertools", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for x in strings:\n       if x == substring:\n          return x\n    return []\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\nYou could do better than that:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\nimport itertools", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\nThat's not very readable.\n\nI agree, I think it's a bad example.\nBut it does show one way to use the list comprehension syntax.\n\nIt's not a bad example. It's a good example. It's just not a good _comprehension_ example.\n\nThat's a good point, and it's true of the majority of examples in the article.\nThe examples are good because they are _simple_, not because they are _readable_.\n\nThe examples are good because they're simple and readable.\n\nI don't see how this is more readable than the equivalent list comprehension:\nfilter_by_substring = lambda strings:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings[substring]!= '':\n       return strings\n    return []\n\nThe Python community is divided over this issue. I'm personally not a big fan of it. I don't really see the value of it.\n\nIt's an antipattern.\n\nWhat's the pattern?\n\nI think he meant antipattern.\n\nYes, I did.\n\nI'm not sure what the antipattern is though.\n\nThe pattern is that this is a function that does not do what it says it does. It filters by substring, but it returns a list of all strings, not just the ones that contain the substring.\n\nI think it does what it says it does. It filters by substring and returns a list of the strings that contain that substring. It's just that it's not a very useful function.\n\nIt's not useful, and it does not do what it says it does.\n\nIt does exactly what it says it does. It filters by substring and returns a list of the strings that contain that substring.\n\nIt filters by substring and returns a list of the strings that contain", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(lambda x: x in strings, substring)\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s.substring)\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if s.startswith(substring):\n           return s\n\nI'm not sure what the problem is with this. It seems to be a very basic, straightforward, and readable implementation of substring filtering.\n\nIt's not wrong, but it's not idiomatic Python.\nPython's standard library is full of modules that do one thing well, and do it in a way that is idiomatic Python. The filter_by_substring module is not one of those modules. It's a module that does one thing, and does it in a way that is idiomatic C.\n\nI don't understand why this is a problem. If you're not using the standard library, why not use the standard library of your language of choice?\n\nI think that is the point. If you are writing Python code, you should write idiomatic Python code. If you are writing C code, you should write idiomatic C code.\n\nThe problem with this is that idiomatic Python code is not always idiomatic C code.\nI'm not sure what the solution is.\n\nThe solution is", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring).to_list\n\nWhat's wrong with this code?\n\nNothing. It's a perfectly valid way to write a function that takes a list and returns a list.\n\nI was hoping for something more along the lines of \"it's a perfectly valid way to write a function that takes a list and returns a list, but it's not idiomatic in Python.\"\n\nIt's not idiomatic, but it's perfectly idiomatic.\n\nI'm sorry, but I don't understand what you're saying. I'm not a Python programmer, so I'm not sure what the difference between idiomatic and perfectly idiomatic is.\n\nI think what he's saying is that it's not idiomatic, but it's perfectly idiomatic.\n\nI'm not sure what he means by that.\n\nHe means it's not idiomatic, but it's perfectly idiomatic.\n\nI'm not sure what he means by that.\n\nHe means it's not idiomatic, but it's perfectly idiomatic.\n\nI'm not sure what he means by that.\n\nHe means it's not idiomatic, but it's perfectly idiomatic.\n\nI", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for i in strings:\n        if strings[i] == substring:\n            return strings[i]\n    return strings\n\nfilter_by_substring() is a very common function, especially for people coming from a C/C++ background. It's also a very simple function, but for some reason it's not in Python's standard library.\n\nThe problem is that it's not obvious how to implement it in Python. The naive implementation is:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s for s in strings if s.startswith(substring))\n\nThis is a bit like the \"filter_none\" function in Python.\n\nI've always thought that \"filter_none\" is a bit of a misnomer.\n\nI've always thought that \"filter_none\" is a misnomer.\n\nfilter_none = []\n\nfilter_none is a list of all the elements of a list except the ones that are in the list.\n\nI've always thought that \"filter_none\" is a bit of a misnomer.\n\nfilter_none = []\n\nfilter_none is a list of all the elements of a list except the ones that are in the list.\n\nI've always thought that \"filter_none\" is a bit of a misnomer.\n\nfilter_none = []\n\nfilter_none is a list of all the elements of a list except the ones that are in the list.\n\nI've always thought that \"filter_none\" is a bit of a misnomer.\n\nfilter_none = []\n\nfilter_none is a list of all the elements of", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings[substring]", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return [str for s in strings if s.startswith(substring)]\n\n>>> from typing import List\n>>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n['abc', 'bacd', 'array']\n>>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n['bacd', 'cde']\n>>> filter_by_substring('abc')\n['abc']\n>>> filter_by_substring('abc')\n['a']\n>>> filter_by_substring('abc')\n['a']\n>>> filter_by_substring('abc')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError:'str' object is not callable\n\nI've just noticed that the python version doesn't use the str type, but\nthe builtin list type. This is the default for python's builtin\nfunction.\n\nYou can do this in Python too:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.count() == 0:\n        return []\n    for i in range(0, len(strings) - 1):\n        if strings[i].startswith(substring):\n           return strings[i]\n    return []\n\nI would add a comment that the function works for any length list, not just strings.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s.endswith(substring))\n\nThat's a nice one.\nI've seen a few times where I wanted to do that but didn't know how.\n\nThis is a pretty good one too:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, lambda s: s.startswith('a'))\n\nThis is a great example of how the \"from\" keyword can be abused.\n\nYes, but it's not a bad thing. It's just a different way of doing things.\n\nThe problem is that the \"from\" keyword is a _very_ bad thing, because it is a _very_ bad idea to have the same syntax for two different things.\n\nI'm not sure that I understand the problem.\n\nThe problem is that the \"from\" keyword is a _very_ bad thing, because it is a _very_ bad idea to have the same syntax for two different things.\n\nYou mean the \"from\" keyword is a _very_ bad thing, because it is a _very_ bad idea to have the same syntax for two different things.\n\nI'm not sure that I understand the problem.\n\nThe problem is that the \"from\" keyword is a _very_ bad thing, because it is a _very_ bad idea to have the same syntax for two different things.\n\nI'm not sure that I understand the problem.\n\nThe problem is that", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for substring in strings:\n        if strings[substring]!= '':\n           return strings\n\nThis is a great example of a bad API.\n\nWhat about it is bad?\n\nI would have used a method called filter instead of filter_by_substring.\nI would have also used a method called filter_by_substring_and_return_all instead of filter_by_substring.\n\nI'd have used _filter_by_substring instead.\n\nYou guys are being too serious. I think this is funny.\n\nI find it funny too, but I still don't get it.\n\nI'm not sure what the point of this is.\n\nI'm not sure what the point of the \"from typing import List\" part is.\n\nYou can't make a List without importing it first.\n\nThe author is using Python 2.7, which doesn't have the \"from typing import List\" part.\n\nYeah, I just saw that.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.count(substring) > 0:\n        return strings.filter(substring)\n    else:\n        return strings\n\nI thought the joke was that the author would have used the built-in list module if he didn't want to use the built-in string module.\n\nThis is a pretty good example of why I would never use Python.\n\nCan you elaborate?\n\nThis is a good example of why I would never use a language that doesn't allow me to use the built-in modules to do the work of the language.\nI don't want to write my own string module, and I don't want to use some third party module. I want to use the built-in string module.\nThis is a great example of why I would never use a language that doesn't let me do that.\n\nI can't tell if you're serious or not.\n\nI am. I'm serious about the fact that I would never use a language that doesn't let me use the built-in modules to do the work of the language.\nI'm not serious about the fact that I would never", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings[substring]\n\n>>> import string\n>>> l = [ 'a', 'b', 'c' ]\n>>> l.filter_by_substring('c')", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if substring in s:\n          return s\n\nThat's a great example of Python's flexibility, but I'm not sure it's a great example of Python's readability.\n\nI'm not sure why it's a bad example of readability. It's fairly clear that the function accepts a list of strings, and a substring. It returns a list of strings that match the substring. It's also pretty clear that it doesn't do anything with the input list of strings that don't match the substring.\nIt's a fairly simple function, and it's fairly clear what it does.\n\nI'm not sure it's bad, but it's certainly not as readable as the original.\n\nI'm curious as to why you feel it is less readable.\n\nI would use it if I wanted to do something like this:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(lambda x: x.startswith(substring))\n\nThere are other solutions, too.\n\nI think that's a pretty good solution. It's not too verbose, and it's easy to understand.\nI think the best part is that it's a single function.\n\nA single function is good, but in this case it would be a single line.\n\nI like this:\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\nThere is a similar, but more succinct version of this function:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if s.startswith(substring):\n          return s\n\nThis is great. I've been working on a similar project, and I think you've just given me some ideas on how to improve it.\n\nPlease do! I love this stuff.\n\nHow about ?\n\nIt's not a list comprehension, it's a generator expression.\n\nIsn't that basically the same thing?\n\nNo.\n\nThis is great. I like it.\nI have a small issue with the example, though.\nIn the example, the first string is 'a'. The second string is 'b'.\nThe first string is returned because it starts with 'a'. The second string is not returned because it does not start with 'a'.\nWhat if the first string is 'ab'? The second string is not returned.\nI think the first string should be returned, as it is in the example.\n\nVery nice.\nIt's a pity that Python doesn't have a built-in list comprehension syntax, though.\n\nI've been using this for a while, and I'm", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.startswith(substring))\n\nI don't see the point of this. I've written a few of these and the only time I've found them useful is when I want to write a function that I know will only be called once.\n\nI've found that the one time I actually used this, it was to find the longest word in a list.\n\nIt's a good example of the point of this. It's a one-off function that you know will only be called once.\n\nI've found that the one time I actually used this, it was to find the longest word in a list.\n\nIt's a good example of the point of this. It's a one-off function that you know will only be called once.\n\nI've found that the one time I actually used this, it was to find the longest word in a list.\n\nIt's a good example of the point of this. It's a one-off function that you know will only be called once.\n\nI've found that the one time I actually used this, it was to find the longest word in a list.\n\nIt's a good example", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s: strings[0], s.startswith(substring))\n\nThat's a pretty cool function. I've always thought that there should be a standard library module that had a bunch of these useful functions.\n\nI've always wanted to make a language where you could just write code like this:\nfilter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n\nPython has a function for this.\n\nPython's a bit of a mess, though. It's got a standard library that's far too big, and it's got a standard library that's far too small.\n\nNot really. It's got a huge standard library, and it's got a small standard library.\n\nThere's a reason why this is a meme:\n\nI was just pointing out that the meme is wrong.\n\nThe meme isn't wrong, it's just not as funny as it was.\n\nI think it's wrong. It doesn't even make sense. There are two standard libraries.\n\nThe joke is that there are two standard libraries, and it's a joke about the size of the standard library", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s for s in strings if s.startswith(substring)).reverse()\n\nThat's a nice one. I'm going to add it to my list of things to remember.\n\nI do this kind of thing all the time, so I've made a package for it:\nI'm not sure it's worth releasing as a standalone library, but it does work well for me.\n\nThis is pretty similar to the List.filter() method.\n\nI was hoping for something that would do something like this:\n>>> filter_by_substring(['a', 'b', 'c', 'd'], 'a')\n['b']\n\nI was hoping for something that would do something like this:\n>>> filter_by_substring(['a', 'b', 'c', 'd'], 'a')\n['b']\n>>> filter_by_substring(['a', 'b', 'c', 'd'], 'a')\n['b', 'c', 'd']\n\nIt would be nice if it returned a list of the strings that were not filtered.\n\nThat's what I thought it would do.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for string in strings:\n        if string in substring:\n            return string\n    return []\n\nI don't think the author understands the point of Python's built-in filter function.\n\nThe author is a very smart person. I think he does understand the point of the built-in filter function, but he's pointing out that it's easy to write a function that does the same thing in a more general way.\n\nI think the point is that the built-in filter function does the same thing in a more general way.\n\nPython's built-in filter function does not do the same thing in a more general way. It's a list comprehension.\n\nI'm confused. What's the difference between a list comprehension and a filter function?\n\nThe list comprehension is a syntax for defining a function.\nThe filter function is a function that does something.\nThe filter function has a list comprehension as its parameter.\n\nI think the author is missing the point of the filter function. It's not supposed to be a general purpose string filter. It's supposed to be a simple, one-line", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s.startswith(substring))\n\nI'm not sure why the author chose to make this a separate function, instead of just using it as an argument to filter:\nfilter('abc' in strings)\n\nThe author is probably using the Python 2.x version of filter.\nfilter() was added in Python 3.\n\nThat's correct. I wanted to show the difference in behavior between 2 and 3.\n\nYou might want to use a different example. The above is just a difference in syntax, not behavior.\n\nIt's not just a difference in syntax, though. It's a difference in how the function is implemented.\n\nIt's a difference in how the function is _called_. There's no difference in how it's implemented.\n\nI know this is a joke, but for anyone who doesn't know, this is a reference to a popular HN post:\n\nI'm not sure if it's a reference to that or not, but it's definitely a reference to this:\n\nI've been using Python for about 6 years and I've never seen a real use for list comprehensions. I've always found them easier to read and write", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(lambda x: x in strings, substring)\n\nI like the use of the lambda syntax in the filter function.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, lambda x: x in strings)\n\nThat's actually not bad. It's not very pythonic, but not bad.\n\nThere are a couple of problems with this code. First, it's not clear what the return type is. The return type is not specified, and the function name does not convey it.\nThe second problem is that the function is not tail recursive. This is a big deal.\n\nThe name does not convey it, but it's pretty easy to infer:\n>>> def filter_by_substring(strings: List[str], substring: str):...", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(lambda s: s in strings, substring)\n\nThis is a _really_ bad example of Python.\nFirst, it uses an 'import' statement, which is unnecessary and only a\nburden to the programmer.\nSecond, the code is _much_ clearer without the import statement.\nThird, it uses a lambda function. This is a bad idea in general, but the\nspecific example is a very bad example.\nFourth, it uses a list comprehension. This is a bad idea in general.\n\nI like how you're getting downvoted for telling the truth.\n\nI think it's more that he's getting downvoted for being a jerk about it.\n\nThis is not the first time I've seen this. I think it's just a reflexive\nreaction to the import statement.\nThe import statement is not a bad thing. It's just a different way of doing things.\n\nThe only thing I dislike about the import statement is the name. It's\nconfusing because it's not really importing anything.\n\nI don't think it's that confusing. It's a statement that imports something.\n\nI'm not sure I agree with", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if substring in s:\n          return s\n\nThis is a cool example, but it's not clear to me what the point is.\n\nThe point is that Python's list is a very powerful data structure.\n\nThe example doesn't show this, though. It shows that Python has a nice way to do string filtering.\n\nYes, that's the point. It's a simple example of how powerful Python's list is.\n\nIt's not really an example of the power of lists, it's an example of the power of string indexing.\n\nPython's list is a string indexing structure.\n\nI know.\n\nI don't see the point of this.\n\nWhat do you mean?\n\nI mean that I don't see the point of this article.\n\nI think the point of the article is that Python's list is a very powerful data structure.\n\nAnd I don't think that it is.\n\nI think that it is.\n\nI'm not interested in arguing with you.\n\nI'm not interested in arguing with you either.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for i, s in enumerate(strings):\n       if s[0] == substring:\n          return i\n    return strings\n\nfrom typing import List\n\n    def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    for i, s in enumerate(strings):\n       if s[0] == substring:\n          return i\n    return strings\n\nfrom typing import List\n\n    def filter_by_substring(strings: List[str], substring: str) -> List[str]:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, lambda s: s.startswith(substring))\nI think the most important thing to learn from this is that `filter_by_substring` is a function that can be called on `List[str]` objects.\n\nI'm not sure I understand this. Are you saying that the most important thing to learn from this is that you can call the function 'filter_by_substring' on a list of strings?\n\nYes, the most important thing to learn from this is that you can call the function 'filter_by_substring' on a list of strings.\n\nI'm not sure I understand this. Are you saying that the most important thing to learn from this is that you can call the function 'filter_by_substring' on a list of strings?\n\nYes, the most important thing to learn from this is that you can call the function 'filter_by_substring' on a list of strings.\n\nI'm not sure I understand this. Are you saying that the most important thing to learn from this is that you can call the function 'filter_by_substring' on a list of strings?", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(lambda s: s.startswith(substring))", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if substring in s:\n           return s\n\nThat's a very nice example of code that is concise, readable, and easy to understand.\n\nIt's also a very nice example of code that will not work in Python 3.\n\nWhy?\n\nBecause of the `from typing import List` line.\n\nIs that a Python 3 only change? I thought that was an import statement.\n\nIt is an import statement, but it is also the line that declares the list type.\n\nAh, I see.\n\nI think the \"from typing import List\" line is actually a pretty good example of why Python is a good language for beginners.\nPython doesn't have a lot of syntax, and it doesn't have a lot of \"magic\" either. You don't have to learn a lot of new rules and exceptions when you start learning Python.\n\nAs a python novice, I find this to be one of the most frustrating aspects of python. There's a lot of stuff you just can't do, and you have to learn a lot of rules. It's not bad,", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(lambda s: s[substring])\n\nThis is a perfect example of why I can't stand Python's syntax.\n\nWhy? I don't see what's wrong with this.\n\nIt's the fact that it's a statement. You don't write \"def filter_by_substring\" as a statement, it's a function. You write \"filter_by_substring(strings: List[str], substring: str)\".\nIt's not a huge deal, it's just a personal preference.\n\nI agree with you. It's a matter of taste, but I like the fact that the function declaration is separate from the function body. It makes it easier to see what the function does.\n\nI find that I don't really care about the function declaration itself, and that it's the function body that is important.\n\nI think that's a very good point. I've never seen a function declaration that I thought was important, but I've seen a lot of function bodies that were hard to understand because of the way they were written.\n\nI'm not sure if this is a good example of Python's syntax being confusing, or if it's", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(lambda s: not s.startswith(substring), strings)\n\nThis is a terrible example.\n\nWhy?\n\nIt's not a bad example, but it's not a good one either. It's a little contrived and doesn't really show any useful functionality.\n\nI don't think it's contrived at all.\nI think it's a great example of how powerful Python is.\n\nI think it's a great example of how powerful Python is, but not a great example of how to use Python.\n\nI think it's a great example of how to use Python, but not a great example of how to use Python.\n\nI think it's a great example of how to use Python, but not a great example of how to use Python.\n\nI think it's a great example of how to use Python, but not a great example of how to use Python.\n\nI think it's a great example of how to use Python, but not a great example of how to use Python.\n\nI think it's a great example of how to use Python, but not a great example of how to use Python.\n\nI think it's", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if strings[s] == substring:\n           return s\n\nimport string\n\n    def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    for s in strings:\n       if strings[s] == substring:\n           return s\n\nfrom typing import List, isinstance\n\n    def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s: string, substring=substring)\n\nfrom typing import List, String, isinstance", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings == [] or len(strings) == 1:\n       return []\n    for i in strings:\n       if substring in i:\n          return [i]\n\nI'm not sure what the point of this post is. The code is pretty straightforward.\n\nYeah, I don't see the point either. The function is just filtering a list of strings.\n\nI think the point is that Python's standard library is awesome.\n\nYeah, but what's so awesome about it? It's just a filter function.\n\nI think the point is that this is a trivial function that you can write in any language, but Python's standard library makes it trivial to write in Python.\n\nI think the point is that there is a filter function in the standard library, and that it is awesome.\n\nI think the point is that the point is that the point is that the point is that the point is that the point is that the point is that the point is that the point is that the point is that the point is that the point is that the point is that the point is that the", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings:\n        return strings\n    else:\n        return []\n\nI find it more readable to have the if inside the filter.\n\nI find it more readable to have the filter inside the if.\n\nI find it more readable to have the if inside the filter.\n\nI find it more readable to have the filter inside the if.\n\nI find it more readable to have the filter inside the if.\n\nI find it more readable to have the if inside the filter.\n\nI find it more readable to have the filter inside the if.\n\nI find it more readable to have the filter inside the if.\n\nI find it more readable to have the filter inside the if.\n\nI find it more readable to have the filter inside the if.\n\nI find it more readable to have the if inside the filter.\n\nI find it more readable to have the filter inside the if.\n\nI find it more readable to have the filter inside the if.\n\nI find it more readable to have the if inside the filter.\n\nI find it more readable to have the filter inside the", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, None)\n\nIf you have a string with multiple characters that you want to filter, you can use a slice instead of a substring.\n>>> filter_by_slice(['abc', 'bacd', 'cde', 'array'], 'a')\n['abc', 'bacd', 'array']\n\nI'm not sure why you would want to use the second version, but you can.\n>>> filter_by_slice(['abc', 'bacd', 'cde', 'array'], 'a')\n['abc', 'bacd']\n\nI think the second version is better for the same reason that it's better to use \"if\" instead of \"if not\" in a boolean expression.\n\nI think that's a bad analogy. \"if\" and \"if not\" are not the same thing.\n\nI don't think it's a bad analogy. I don't think the OP was saying that \"filter_by_slice\" and \"filter_by_substring\" are the same thing.\nI think he was saying that \"if\" and \"if not\" are the same thing.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for string in strings:\n       if string[substring]!= '':\n          return string\n\nNice! I didn't know about this.\n\nI think I've seen this before.\n\nYes, this is a really old one.\n\nI've seen this before.\n\nYes, this is a really old one.\n\nI've seen this before.\n\nYes, this is a really old one.\n\nI've seen this before.\n\nYes, this is a really old one.\n\nI've seen this before.\n\nYes, this is a really old one.\n\nI've seen this before.\n\nYes, this is a really old one.\n\nI've seen this before.\n\nYes, this is a really old one.\n\nI've seen this before.\n\nYes, this is a really old one.\n\nI've seen this before.\n\nYes, this is a really old one.\n\nI've seen this before.\n\nYes, this is a really old one.\n\nI've seen this before.\n\nYes, this is a really", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s, substring)\n\nIt's worth noting that this code is really, really bad.\n\nWhy?\n\nBecause you're creating a new list instead of returning the result of the filter.\n\nThat's not \"really, really bad\" though, is it?\n\nYes, it is. You should never create a new list in Python.\n\nI'm not sure this is true. If you are performing an operation that is going to be repeatedly called on a list, it's probably better to create a new list than to return the same list each time.\n\nI think the idea is that you should not create a new list for each call, but rather you should create a new list once, and pass that to the function, which returns that list.\n\nYes, exactly.\n\nI have to agree with you, I can't think of a good reason to create a new list for each call to a function like this.\n\nI'm not sure if I'm missing something here, but why not just return the result of the filter?\n\nThe whole point of the article is that this is not a good idea.\n\nI would have called it \"", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for sub in strings:\n        if sub == substring:\n           return strings\n\nI'm a Python novice, but shouldn't it be:\nfor sub in strings:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for substring in strings:\n       if strings[substring] == substring:\n          return strings\n    return []\n\nThis is a really nice example of a \"bad\" approach to a problem. The problem is that the code is completely unintelligible.\nThe problem is that the code is a functional solution to a problem that doesn't require functional code.\nThe problem is that the code is unnecessarily complicated.\nThe problem is that the code is not extensible.\nThe problem is that the code is not maintainable.\nThe problem is that the code is not readable.\nThe problem is that the code is not debuggable.\nThe problem is that the code is not testable.\nThe problem is that the code is not easily ported to other languages.\nThe problem is that the code is not easily parallelized.\nThe problem is that the code is not easily optimized.\nThe problem is that the code is not easily ported to new platforms.\nThe problem is that the code is not easily ported to new architectures.\nThe problem is that the code is not easily ported to new operating systems.\nThe problem", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if substring in s:\n          return s\n    return []\n\nI'm not sure how I feel about this.\n\nI like it. I find it a bit odd that you're not supposed to import the module you're in though.\n\nI think the author is taking the Python convention of never using import to mean \"never import anything\".\n\nOh, I see. I thought he was saying that you shouldn't import the module you're in, even if you're going to use that module.\n\nWhat's the point of the \"from typing import List\" part?\n\nIt's a bit of a joke, as the author is a Haskell programmer. Haskell programmers would never write code like this.\n\nI'd say it's a bit more than a bit of a joke. It's a fairly clear jab at the \"no imports\" style of Python.\n\nIt's a bit of a joke in that it is funny, but it's also a jab at the \"no imports\" style of Python.\n\nI'm a Python programmer, and I don't understand this.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings[substring]", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s: strings.index(s, substring))\n\nThis is great! I've been looking for a way to do this.\n\nI'm glad you like it.\n\nI think he meant \"I'm glad you posted it.\"\n\nI'm glad you posted that.\n\nI'm glad you posted that you're glad he posted that.\n\nI'm glad you posted that you're glad that he's glad that he posted that.\n\nI'm glad you posted that you're glad that he's glad that he posted that he's glad that he posted that.\n\nI'm glad you posted that you're glad that he's glad that he posted that he's glad that he posted that he's glad that he posted that.\n\nI'm glad you posted that you're glad that he's glad that he posted that he's glad that he posted that he's glad that he posted that.\n\nI'm glad you posted that you're glad that he's glad that he posted that he's glad that he posted that he's glad that he posted that.\n\nI'm glad you posted that you're glad that he's glad that he posted that he's glad that", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\n>>> import collections\n>>> collections.Counter(0)\n0\n>>> collections.Counter('abc')\n<class 'collections.Counter'>\n\n>>> collections.Counter('a')\n<class 'collections.Counter'>\n>>> collections.Counter('a', 0)\n0\n>>> collections.Counter('a', 1)\n<class 'collections.Counter'>\n\n>>> collections.Counter('a', 0, 1)\n0\n>>> collections.Counter('a', 0, 2)\n1\n>>> collections.Counter('a', 1, 2)\n0\n\n>>> collections.Counter('a', 1, 2, 0)\n1\n\n>>> collections.Counter('a', 1, 2, 1)\n0\n\n>>> collections.Counter('a', 1, 2, 2)\n1\n\n>>> collections.Counter('a', 1, 2, 3)\n0\n\n>>> collections.Counter('a', 1, 2, 4)\n1\n>>> collections.Counter('a', 1, 2, 5)\n0\n>>> collections.Counter('a', 1, 2, 6)\n1\n>>> collections", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.count(substring) > 0:\n        return strings.filter(substring).reverse()\n\nI'm pretty sure this is the best Python code I've ever seen.\n\nI'm not sure if you're serious or not, but I think it's a really good example of how to use the type system to your advantage in Python.\n\nI think it's a good example of why type systems are overrated.\n\n_\"A language that doesn't affect the way you think about programming, is not worth knowing.\"_ \\- Alan Perlis\n\nI think it's a good example of why type systems are overrated.\n\nThis is an example of how type systems can be useful.\n\nIt's not a good example, though.\nIf you need to do this, then you should probably be using a language with a type system that can actually do it for you.\n\nThis is a great example of how a type system can help you catch bugs in your program.\n\nIf you need to do this, then you should probably be using a language with a type system that can actually do it for you.\n\nThis is a great", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring).filter(substring).filter(substring)\n\nI don't know Python, but in Perl it's:\nperl -Mre 'print join \" \", map {$_", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(lambda s: s[substring])\n\nand the next time you're typing out a long string and want to insert a substring, remember to type\n\n>>> import typing\n>>> l = [\"abc\", \"a\", \"b\", \"c\", \"d\", \"e\"]\n>>> l[0, 2] = \"b\"\n>>> print l\n['abc', 'bacd', 'cde', 'array']\n>>>\n\nThe best part is that you don't even need to do a \"from typing import List\" because it's already there.\n\nI don't know, that's pretty cool. I think I'll start using this.\n\nI like this. The only thing I'd add is some kind of \"from typing import everything\" for when I want to use an object that isn't in the standard library.\n\nI don't know, I think this is a pretty cool way to do it. I'm going to start using this.\n\nI don't know, that's pretty cool. I think I'll start using this.\n\nI don't know, that's pretty cool. I think I'll start using this.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if s.startswith(substring):\n           return s\n    return []\n\nI'd like to point out that this is not a good example of the usefulness of type-based programming.\nThere are other ways to do this in Python, and they're all less error-prone. For example, this:\n>>> print(filter(lambda s: s[:-1], 'a'))\n['a']\n>>> print(filter(lambda s: s[:-1], 'a'))\n['a', 'a', 'a', 'a']\n>>> print(filter(lambda s: s[:-1], 'a'))\n['a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a', 'a", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n        return []\n    for s in strings:\n        if substring in s:\n           return s\n\nI wonder if this is a joke? It's a very clever joke, but it's still a joke.\n\nThere is a lot of code in Python that is like this. You can see this in the\n\"Pythonic\" style guide, which is a list of things that are discouraged in Python code.\n\nI wouldn't go so far as to call it a joke. This code is useful when you want to filter a list of strings by a substring. There is a clear, simple, and concise way to do this. It is not the only way, but it is a good way to do it.\n\nI would say that this code is a joke in the sense that it's a code golf joke.\n\nI'm not familiar with the term \"code golf\".\n\nIt's a game in which you try to write the shortest program that does the job.\n\nI would say that this code is a joke in the", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, None)\n\nYou're calling it filter_by_substring but it should be filter_by_substring_and_return_all_the_rest\n\nI'm not sure what you mean.\n\nIt's a joke on the fact that Python has a function called filter that does exactly what you wrote.\n\nI don't get it.\n\nThis is a very nice article. The examples are short and to the point and the code is very clear.\n\nThanks for the feedback.\n\nI think the title is misleading. It should be \"from typing import List\".\n\nI was a little confused by that too, but I think it was meant to be a joke.\n\nThis is a very nice article. The examples are short and to the point and the code is very clear.\n\nThanks for the feedback.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.count(substring) == 0:\n        return strings\n    return []\n\nI prefer to use a dictionary.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.count(substring) == 0:\n        return strings\n    else:\n        return filter_by_substring(strings, substring)\n\nI'd say this is a very good example of the Zen of Python.\n\nI don't get it.\n\nThe Zen of Python is the first few lines of the official Python tutorial:\n\"Beautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\"\n\nI'm not sure that's what the Zen of Python is. I'd say it's the general attitude of the Python community.\n\nI believe it is, but the attitude of the Python community is based on the Zen of Python.\n\nI believe that the Zen of Python is: \"The Zen of Python is the first few lines of the official Python tutorial:\n\"Beautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s => s.startswith(substring))\n\nThis is a great example of how to write a non-idiomatic Python program. The code is verbose and it's not immediately obvious what it does. I would have written it like this:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\nPython is a great language, but I'm not sure this is the best example of its power. In C++ I can do the same with std::string::find() and std::string::find_first_of().\n\nI think the point is that you can do this in one line of code.\n\nThe point is that you can do this in one line of code and it's still readable.\n\nI think this is a great example of the power of Python. However, I think it's a bit misleading to say that you can do this in one line of code.\n\nYou can do this in one line of code.\n\nI don't think you can. The one line of code is the definition of the function. It's not actually the code that filters the list, it's the function.\n\nThe function is a one line of code, so it's one line of code.\n\nThe function is a one line of code, but the function is not the code. The code is the code that filters the list.\n\nThe code is the code that filters the list.\n\nThe code is the code that filters the list", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.startswith(substring))\n\nFrom the article:\n\"The first line of code is a little long-winded, but you can think of it as a shorthand for the following:\n>>> import typing\n>>> from typing import List\n>>> def filter_by_substring(strings: List[str], substring: str):\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return strings.filter(str.startswith(substring))\n>>>\n\nIf I understand the article correctly, it's not the import that's long-winded, but the Python's lambda syntax.\nI don't know why they didn't just write:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.startswith(substring))\n\nI've never really understood why the \"from <module>\" syntax is considered so bad. It's a bit verbose, but it's perfectly readable and doesn't require any additional knowledge.\n\nI think the problem is that it's inconsistent with how you use classes. You don't say", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, lambda x: x in strings)\n\n>>> filter_by_substring('a', 'a')\n['a', 'a']\n>>> filter_by_substring('a', 'aa')\n['a', 'aa']\n>>> filter_by_substring('a', 'aaa')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"/Users/paul/code/python/filter_by_substring.py\", line 6, in filter_by_substring\nreturn strings.filter(substring, lambda x: x in strings)\nKeyboardInterrupt\n>>>\n\nFor those who don't know, `filter_by_substring` is just a toy example that shows that this is not a good idea. The reason is that the name of the function is the name of the variable, which is exactly the same as the name of the function.\n\nI've always wondered why there isn't a convention for naming variables in a function the same as the name of the function.\n\nI don't think it's a good idea.\nIf you", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(lambda x: x.startswith(substring))\n\nThis is the same as:\nfrom typing import List, string", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if substring == s:\n          return s\n\nI'm curious. Why is this better than `filter(lambda x: x.startswith('a'), strings)`?\n\nIt's not better. The example is wrong:\n>>> filter_by_substring('a')\n['a', 'b', 'c']\n>>> filter_by_substring('a', 'b')\n['a', 'b', 'c']\n\nIt's not wrong. It's just not what the author intended.\n\nI don't get it.\n\nThe author's intention was to filter out the strings that _don't_ contain the substring, but the example actually filters out the strings that _do_ contain the substring.\n\nI see. So the author's example is wrong.\n\nIt's not wrong, it's just not what the author intended.\n\nIt's not what the author intended, and it's wrong.\n\nThe author's intention was to filter out the strings that _don't_ contain the substring, but the example actually filters out the", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str=substring).to_list()", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings:\n        return strings\n    else:\n        return [str(substring) for substring in strings]\n\nYou might want to consider using a dictionary instead of a list for this.\nIf you do, then you don't need to do any of the variable assignment inside the function.\n\nI disagree, I think it's much better to use a list.\n1) You can use a dictionary to store multiple things, but you can't use a list to store multiple things.\n2) You can iterate over a list, but you can't iterate over a dictionary.\n3) You can modify a list, but you can't modify a dictionary.\n4) You can sort a list, but you can't sort a dictionary.\n\nI can understand the first three, but what's the advantage of being able to sort a list?\n\nI can think of a few reasons:\n1) Sorting is O(n log n) so it's a good way to implement a binary search.\n2) Sorting is often a prerequisite for searching.\n3) Sorting can be used to pre", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return []", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return [str.find(substring) for str in strings if len(str) > 1]\n\nI think it would be better to call the function filter_by_substring_list.\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if substring in s:\n          return s\n\nIt's a very simple algorithm, but I've never seen it before.\nI wonder if there is a name for this kind of thing?\n\nI'm not sure I would call it an algorithm. It's a function.\n\nIt's a very simple algorithm, but I've never seen it before.\nI wonder if there is a name for this kind of thing?\n\nI'm not sure I would call it an algorithm. It's a function.\n\nIt's a very simple algorithm, but I've never seen it before.\nI wonder if there is a name for this kind of thing?\n\nI'm not sure I would call it an algorithm. It's a function.\n\nIt's a very simple algorithm, but I've never seen it before.\nI wonder if there is a name for this kind of thing?\n\nI'm not sure I would call it an algorithm. It's a function.\n\nIt's a very simple algorithm, but I've never seen it before.\nI wonder if there is a name for", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring)\n\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s => s.startswith(substring)).tolist()\n\nI think it's better to use the filter method from string module:\n>>> [a,b,c].filter(s => s.startswith('a'))\n[a, b, c]\n>>> [a,b,c].filter(s => s.startswith('a'))[0]\n'a'\n\nOr even better, the filter method from collections module:\n>>> [a,b,c].filter(s => s.starts_with('a'))\n[a, b, c]\n>>> [a,b,c].filter(s => s.starts_with('a'))[0]\n'a'\n\nOr even better, the filter method from itertools module:\n>>> [a,b,c].filter(s => s.starts_with('a'))\n[a, b, c]\n>>> [a,b,c].filter(s => s.starts_with('a'))[0]\n'a'\n\nThe filter() method is not", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.startswith(substring)).reverse()\n\nYou can also use string.find:\n>>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n['bacd', 'cde', 'array']\n>>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n['bacd', 'cde', 'array']\n\nThe difference is that find returns the index of the first occurrence, while reverse returns the last occurrence.\n\nThere's also string.findall:\n>>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n['bacd', 'cde', 'array']\n>>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n['bacd', 'cde', 'array']\n>>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n['", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s: strings.index(s, substring))\n\nThis is very similar to the list comprehension syntax.\n\nI'm not sure I'd call it \"very similar\".\nList comprehension:\n[x for x in list if x % 2 == 0]\nFilter by substring:\n[x for x in list if x[0] == 'a']\nThey are similar in that they both take a list as input, and return a list. But the syntax is very different.\n\nI'd say the difference between the two is that list comprehension is a _comprehension_ of the list, while filter by substring is a _filtering_ of the list.\n\nThe semantics of the two are different, but the syntax is very similar.\n\nI think the syntax is more similar to list comprehensions in Python.\n\nIt is, but I find Python's list comprehensions more readable.\n\nI think that's because Python's syntax is more consistent and Python doesn't have a long history of list comprehensions.\n\nI'm not sure that history makes a difference. I think the Python list comprehension syntax is more readable because it is more consistent.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if len(s) == substring:\n           return s\n\nThis is a good example of why it is important to know the difference between a function and a method. A function returns a value, while a method modifies a class instance.\n\nGood point, but the OP's code is a function.\n\nI agree. I was just pointing out that it is a common mistake.\n\n\"from typing import List\" is a bad idea. \"import typing\" is much better.\n\nI don't see why \"from typing import List\" is a bad idea. If you're using a module that requires a lot of typing, typing \"from typing import List\" is a lot easier than typing \"from typing import *\".\n\nBecause then you're using a module that requires a lot of typing. If you're using a module that requires a lot of typing, you should know what it does and what it imports.\n\nI don't see why you're being downvoted, but I think you're missing the point.\nYou can still know what it does and what it imports.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if substring in s:\n          return s\n\nI think the author should have used a regular expression for that.\n\nI think this is a very nice example of how Python's type system can help you write better code.\n\nNot really.\nIt's a nice example of how type annotations can help you write better code.\n\nType annotations are part of the type system.\n\nI'm not sure that's true. They're part of the type system _of Python_, but not the type system in general.\n\nI think that the python type system is a subset of the type system in general.\n\n_\"The type system of Python\"_ is the phrase that makes me think that.\n\nThe type system of Python is the type system of Python.\n\nI don't know if it's just me, but the title of this post just seems to be a bit of a troll.\n\nI don't think it's a troll. It's a pretty good example of how to use the type system in Python to write better code.\n\nThe title should have been \"A", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.startswith(substring))\n\nThat's the way to do it.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(lambda s: s.startswith(substring))\n\nI think it's much more readable and clear to use", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.lower().startswith('a'))\n\nfrom typing import List\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return [x for x in strings if x in substring]\n\nThe author of the article is apparently unaware of the fact that Python has a standard library, and the built-in string type is a list of bytes.\n\nYou can do this in C, too:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring).filter(None)\n\nI think this is more idiomatic:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, 0).reverse()\n\nIt's not clear from the article, but it looks like the author is using python 3.2.\nIn python 2.7, the equivalent would be:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for i in strings:\n       if strings[i].find(substring) is not None:\n          return strings[i]\n\nI don't understand the point of this article.\n\nI've never used Python, but I would guess that it's a language that does not have a standard library. So this is a way of writing a function to filter a list using a standard library function.\n\nPython has a standard library, but it doesn't have a standard list type. This is a way of writing a function to filter a list using a standard library function _on a list type that is not the built-in list type_.\n\nIt seems to me that this is a great example of the difference between a scripting language and a compiled language.\nIn a compiled language, you would write a function that would work on any list type.\nIn a scripting language, you have to write a function that will work on a specific list type.\n\nThis is a great example of the difference between Python and other languages that have a standard library.\n\nThat's exactly what I meant. I think that the article is a great example of the", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings.count(substring) > 0:\n        return strings\n    else:\n        return []\n\nThis is a very naive implementation, and it won't work for strings that contain spaces, tabs, line breaks, etc.\n\nIs there any way to do this in python?\n\nA more useful version would be", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.startswith(substring)).to_list\n\nI don't see the point of this code. Why not just:\nfor s in strings:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if s.startswith(substring) and s.endswith(substring):\n           return s\n    return []\n\nThis is a very common idiom in Python. It is used in a lot of places, from the built in string methods to the collections module.\n\nI was trying to think of a way to do this in C++. I think I would write it as\ntemplate<typename T>\nstruct filter_by_substring_impl\n{\ntemplate<typename T>\nT filter_by_substring(const T& s, const char* substring)\n{\nreturn s.find(substring, s.end());\n}\n};\n\nThis is a very common idiom in Python. It is used in a lot of places, from the built in string methods to the collections module.\n\nI was trying to think of a way to do this in C++. I think I would write it as\ntemplate<typename T>\nstruct filter_by_substring_impl\n{\ntemplate", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if (s == substring):\n           return s\n    return []\n\nI am a big fan of Python, but I really hate the fact that they have a built-in function called \"filter\" that is completely different from the one that everyone else calls \"filter\".\n\nI've heard the same complaint about \"map\" and \"filter\".\n\nI like the idea of a filter function that can be used to implement a map.\n\nI'm not sure what you mean.\n\nThe filter function in Python can be used to implement a map function.\n\nAh, yes, I see.\nI agree that this is a good feature, but I don't think it's a good idea to have the same name for two functions that are so similar.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(lambda s: s[substring], strings)\n\nI think the more interesting question is why you would use a list of strings as an input to a filter function.\n\nI was thinking the same thing. Is there an advantage to using a list of strings rather than a list of tuples?\n\nIt's probably just a matter of taste, but I find tuples more readable.\n\nI think tuples are more readable because they have a single-character syntax.\n\nI find the single-character syntax of tuples very confusing. I often find myself thinking that a tuple is a single object, when it is actually a list of objects.\n\nI have no idea why this is being downvoted. I find the single-character syntax of tuples confusing too. It's not a syntax that I'm used to, and I find it harder to read than a list comprehension.\n\nI find the single-character syntax of tuples very confusing. I often find myself thinking that a tuple is a single object, when it is actually a list of objects.\n\nI have no idea why this is being downvoted. I find the single-character syntax of tuples confusing too", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n       if s.startswith(substring):\n          return s\n\nWhat if the string starts with 'a' or 'abcd' or 'bacd'?\n\nThat's why you should always use 'a' instead of 'a' for the example.\n\nI've always been annoyed that Python doesn't have a ternary operator. I think it's one of the most elegant ways to express an if-then-else.\nIt's also a bit more concise than this:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str.startswith(substring)).to_list\n\nI'm not sure what you're trying to do. You're just creating a new list with the same elements as the original list.\n\nI think the point is that the code is trivial, and can be expressed in a couple of lines.\n\nI think that's the point of the blog.\n\nI think that's the point of the original blog.\n\nI think that's the point of the original blog.\n\nI think that's the point of the original blog.\n\nI think that's the point of the original blog.\n\nI think that's the point of the original blog.\n\nI think that's the point of the original blog.\n\nI think that's the point of the original blog.\n\nI think that's the point of the original blog.\n\nI think that's the point of the original blog.\n\nI think that's the point of the original blog.\n\nI think that's the point of the original blog.\n\nI think that's the point of the original blog.\n\nI think that's the point of the original blog.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for i in strings:\n        if strings[i] == substring:\n           return strings[i]\n\nThis is a lot like the filter() method of Python's list class.\n\nI'm glad I wasn't the only one who thought this.\n\nI'm not sure what to make of this.\n\nI am going to write a Python program to import it and then convert it to Java.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for x in strings:\n       if x.startswith(substring):\n         return x\n    return []\n\nSo basically,\nfrom typing import List", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for i in strings:\n        if strings[i] == substring:\n           return strings[i]\n\nThis is the single most important thing I've ever learned in Python. I've used it for everything from replacing an entire string (when you know the exact character you're looking for), to finding a substring in a string that's too long for a for loop.\n\nThere's a lot of things I've learned in Python, and I've been using it since version 1.5. But this is the single most useful thing I've learned.\n\nThis is not a Python specific feature. It's a generic programming feature.\n\nNot to mention that it's a good idea to avoid mutating lists in Python, and instead use a list comprehension.\n\nIf you're using Python 2.x, you're probably not using list comprehensions, because they're not part of the language.\n\nI've been using Python since 1.5. I've never had a good reason to use list comprehensions, and I've never missed them.\n\nI find them useful when I'm iterating over a dictionary and I", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for s in strings:\n        if not substring in s:\n           return s\n    return []\n\nThis is a very common pattern in Python. If you're writing a Python program that does something with a list of strings, you can often get rid of the loop by just calling filter_by_substring(s, substring).\n\nThis is a good example of the difference between Python and Perl. Perl has a built-in function called \"substr\" which takes a string and a start offset and returns the string starting at that offset. So in Perl you would do something like\n\nmy @list = qw(abc def);", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s for s in strings if s.startswith(substring))\n\nI like it. It's a nice solution to a problem that's not really a problem, but it's a good solution to a problem that's not really a problem.\n\nI think you just described the entire programming industry.\n\nI think you just described the entire ____ industry.\n\nI think you just described the entire ____ industry.\n\nI think you just described the entire ____ industry.\n\nI think you just described the entire ____ industry.\n\nI think you just described the entire ____ industry.\n\nI think you just described the entire ____ industry.\n\nI think you just described the entire ____ industry.\n\nI think you just described the entire ____ industry.\n\nI think you just described the entire ____ industry.\n\nI think you just described the entire ____ industry.\n\nI think you just described the entire ____ industry.\n\nI think you just described the entire ____ industry.\n\nI think you just described the entire ____ industry.\n\nI think you just described the entire ____ industry.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if strings:find(substring) == 0:\n        return strings\n    return []\n\nYou can probably get rid of the \"if\" statement and just return [] if the substring isn't found.\n\nIt's not a good idea to return an empty list if the condition is false.\n\nWhy not?\n\nBecause it's not a list if it's empty.\n\nIt is a list if it's empty. It's just an empty list.\n\nTrue, but if you return an empty list, you're telling the caller that the string is not found, even if it was.\n\nGood point. I don't know why I didn't think of that.\n\nI think this is the wrong way to think about it.\nYou are filtering a list of strings for a particular substring, not for a particular list of strings.\nIn the first case, you want to return a list of strings that contain the substring. In the second case, you want to return a list of strings that don't contain the substring.\n\nI think you're right.\n\nI think you're right about him being right.", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(str=substring).tolist()\n\nThis is not a criticism, but this is a good example of why I don't like the Python standard library.\nIn Java, this would be a method on the String class, and it would be called \"contains\".\nIn Python, you have to create a new class and write a function.\n\nI don't understand this criticism. Why do you need a new class and a new function? Why not just:\nfrom typing import List, String", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s.startswith(substring))\n\nI'm not sure how to feel about this.\n\nI'm guessing that the author is a Python programmer, and was trying to write Python in Ruby.\n\nI'm not sure why you think that. The author is a Ruby programmer, and was trying to write Ruby in Python.\n\nI'm not sure why you think that. The author is a Python programmer, and was trying to write Python in Ruby.\n\nI'm not sure why you think that. The author is a Ruby programmer, and was trying to write Python in Ruby.\n\nI'm not sure why you think that. The author is a Ruby programmer, and was trying to write Ruby in Python.\n\nI'm not sure why you think that. The author is a Ruby programmer, and was trying to write Ruby in Ruby.\n\nI'm not sure why you think that. The author is a Python programmer, and was trying to write Python in Ruby.\n\nI'm not sure why you think that. The author is a Ruby programmer, and was trying to write Ruby in Ruby.\n\nI'm not sure why you think that. The author is a", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return [str(substring) for string in strings if string in substring]\n\nWhat's the point?</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(lambda x: x in strings, substring)\n\nI'm sorry, but that's a terrible example.\nThe fact that filter() is a function is obvious from the context, so it's\nnot a good idea to write it out like that. It also doesn't show the\nbenefit of using the new syntax.\n\nThe example shows that the new syntax can be used to create a function\nwhich is passed as a parameter to another function.\n\nIt doesn't show that at all.\n\nI've been waiting for this.\nI wonder if it will be possible to use it to create a list of tuples\nwhere each tuple is a list of strings.\n\nIt is possible, but I'm not sure if it's idiomatic.\n\nIt's idiomatic in the sense that it's the most concise way to express the\ndesired functionality.\n\nI don't know, this seems like a nice language feature, but it's not really\nthe sort of thing that makes me go \"Wow!\" about Python.\n\nWell, it's a nice feature for a language to have. I don't know if it's\nenough to make anyone go \"Wow!\" about", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring).filter(substring)\n\nThat's actually a pretty cool function.\n\nIt's also a pretty cool trick to use `str` instead of `str.lower()`.\n\nWhat's the trick?\n\nStrings are immutable in Python.\n\nI don't understand.\n\nThe function returns a new list.\n\nI'm not sure why that makes a difference.\n\nYou can't change a string.\n\nI'm not sure why that's relevant.\n\nBecause you can't change the string to lowercase it.\n\nWhy can't you?\n\nBecause the string is immutable.\n\nI don't understand.\n\nYou can't change it.\n\nWhy not?\n\nBecause you can't.\n\nWhy not?\n\nBecause it's immutable.\n\nWhy can't you change it?\n\nBecause you can't.\n\nWhy can't you?\n\nBecause it's immutable.\n\nWhy can't you change it?\n\nBecause it's immutable.\n\nWhy can't you change it?\n\nBecause it's immutable.\n\nWhy can't you change it?\n\nBecause it", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n       return strings\n    else:\n       return filter_by_substring(strings, substring)\n\nI'm not sure I get it. What is this supposed to be?\n\nThe first example is a filter that returns the string \"a\" from the empty list.\nThe second example is a filter that returns the strings \"abc\" and \"bacd\" from the list that contains \"abc\", \"bacd\", and \"cde\".\n\nI don't think the first example is useful. It's very easy to write a filter that returns \"a\" from the empty list.\n\nThe first example is useful when you want to write a filter that returns the first element of a list.\nIt's the same as:\nfilter_by_substring([], 'a')\n\nI don't understand what you mean by \"write a filter\".\n\nWhen I write a filter, I have a list of strings and I want a list of the strings that contains a certain substring.\nfilter_by_substring([], 'a') returns a list of strings that", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n        return strings\n    else:\n        for substring in strings:\n            if strings[substring] == substring:\n                return strings[substring]\n    return []\n\nYou can also do:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(s for s in strings if s.startswith(substring))\n\nWhy not:", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings[substring]\n\nI don't know why, but I find it hard to read the code. I think it's the fact that it's in Python, which I am not familiar with.\n\nI think it's because it's a list comprehension.\n\nI don't know what a list comprehension is, but I'll take your word for it.\n\nI'm not a Python expert, but I think it's a way of writing a function that returns a list.\n\nIt's a way of writing a function that returns a list, by writing a list.\n\nAhh, so it's a list that's a function.\n\nI think the code is hard to read because it's not in a language you're familiar with.\n\nThat's probably the case, but I don't think that's the only reason. I've looked at code in languages I'm not familiar with before and had no trouble reading it.\n\nI think it's because it's a list comprehension.\n\nI don't know what a list comprehension is, but I'll take your word for it.\n\nI'm not a Python expert, but I think it's a way of writing a function", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return filter(lambdas: List[str], substring: substring, key: lambda x: x[0],", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, None)\n\nI think that the \"from typing import List\" is a bit of a red herring. The real problem is that the \"filter_by_substring\" function is not type-checked.\n\nI agree. I also think that the name is a bit misleading.\n\nI like it. It's a bit of a red herring, but it's a good example of a real-world use case for a type hint.\n\nI think the \"red herring\" is the name. I'd suggest \"filter_by_string\" or \"filter_by_substring\".\n\nI like it. It's a good example of a real-world use case for a type hint.\n\nI'm not sure if this is a red herring, but I think it's a good example of a real-world use case for a type hint.\n\nI like it. It's a bit of a red herring, but it's a good example of a real-world use case for a type hint.\n\nI think the \"red herring\" is the name. I'd suggest \"filter_by_string\" or \"", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    for x in strings:\n        if strings[x].find(substring)!= -1:\n            return strings[x]\n\nThis is a bit of a straw man. The author is using a list of lists as a string. The author could have used a list of strings and avoided the list of lists altogether.\nThe author could have also used a dict of lists (or dictionaries of strings, or any other data structure) and avoided the list of lists altogether.\nThe author could have also used a tuple of strings and avoided the list of lists altogether.\nI could keep going.\n\nI like the author's example because it's the most common case in Python.\n\nI like the author's example because it's the most common case in Python.\n\nI like the author's example because it's the most common case in Python.</s>", "from typing import List\n\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\" \"\"\"\n    return strings.filter(substring, lambda s: s in strings)\n\nI have to admit, that's pretty clever.\n\nIt's clever if you've never seen a functional language before.\n\nNo, it's clever if you haven't seen a functional language that doesn't have filter.\n\nHaskell doesn't have filter. Haskell is a functional language.\n\nIt does have filter, just not in the Prelude.\n\nNo, it has a filter function. It doesn't have a filter function in the Prelude.\n\nI have to admit, that's pretty clever.\n\nIt's clever if you've never seen a functional language before.\n\nNo, it's clever if you haven't seen a functional language that doesn't have filter.\n\nHaskell doesn't have filter. Haskell is a functional language.\n\nIt does have filter, just not in the Prelude.\n\nNo, it has a filter function. It doesn't have a filter function in the Prelude.\n\nI have to admit, that's pretty clever.\n\nIt's clever if you've never seen a functional language before.\n\nNo, it's clever if you haven't seen a functional language that"]]