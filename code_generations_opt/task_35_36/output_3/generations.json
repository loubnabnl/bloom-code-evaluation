[["def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    for elem in l:\n       if max_element(elem) > len(elem):\n         return elem\nI wish python had a way to write this sort of function like so:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l == list:\n       return l[-1]\n    return max(list)\n\n this one", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    max = 0\n    for e in l:\n        if e[0] > max:\n           max = e[0]\n    return max\nI would suggest:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    return max(l)", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) < 2:\n       return l[0]\n    return max(l)", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return (l[0].abs() > l[1].abs())\n    if __name__ == '__main__':\n    max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    # Returns 123", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return (l.max() for l in l)\n    def max_in_range(l: list):\n    \"\"\"Return maximum element in range.\n    >>> max_in_range([1, 2, 3, 4])\n    4\n    >>> max_in_range(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'])\n    'i'\n    \"\"\"\n    return (l.max() for l in range(l.length))\n    def max_not_in_range(l: list):\n    \"\"\"Return maximum element in range.\n    >>> max_not_in_range([1, 2, 3, 4])\n    4\n    >>> max_not_in_range(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'])\n    'e'\n    \"\"\"\n    return (l.", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n\nWhen you do this:\nmax_element([1, 2, 3])\nit is not printing a list of length 1.\nI think you meant:\nmax_element(['1', '2', '3'])\n\nGood catch, thanks.\n\n\"To write in C++, you have to be a bad programmer.\" \\- Bjarne Stroustrup\n\nA great way to ensure you'll never have a job in the future is to make generalizations like this.\n\nThe author:\n\"I'm not trying to troll here, I just felt the need to write this down.\"\n\nI'm a big fan of these series of articles. They are well written and informative.\n\nThe author's github repo: https://github.com/benbjohnson\n\nThe author's github repo: https://github.com/benbjohnson\n\nFirst time I've seen the words \"Ruby\" and \"lesson\" in the same sentence.\n\nI have no idea why this is downvoted. Ruby is famous for being very minimalistic and simple.\n\nI think because of the sarcastic way it was written? The author is being pretty sarcastic about the article", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l) == 1\nThis isn't the same as max(l), it's just `l[0]`.\n\nIn python 3, it's correct.\n\nWow, it is! I knew it'd be changed at some point, but I didn't expect it to be changed this soon.\n\nThis is really great! I am the author of gnutls-rs, which is a Rust implementation of the gnutls library.\nIt uses Tokio as its main abstraction for networking and asynchronous I/O, and it makes a lot of things much simpler.\nI can see that it is difficult to extend Tokio, but I am working to see if I can use it to write asynchronous Rust APIs.\nIf anyone is interested in a (work in progress) benchmark for a simple Rust API using Tokio and gnutls-rs, I wrote it here:\nhttps://github.com/kurtis/rust-async-benchmark\n\nI've been looking at your work lately and I'm very excited about what's coming with gnutls-rs! Would it be possible for you to share some thoughts on your approach to the memory safety of the gnutls", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l == []:\n       return 0\n    return max(l)", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)\nThere is no need for a class here.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l):\n       return max(l)\nI am sorry, but this solution is not correct. In python, max does not return the index of the maximum, but instead returns the value itself. Hence, this solution will give incorrect results when the list is empty or all elements are equal.", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    for _ in range(l.size()):\n        return max(l[i])\nIt took me a while to get the joke, and I'm still not sure I fully get it.\n\nNumpy is so much better than python, it just hurts. I mean, you could use a dict, but then you lose the indexing.\n(Also, that's not a for loop, it's a looping structure - not sure what to call it. Seems a bit confusing.)\n\nIt's a generator.\n\nThe \"for _ in range\" version is also a generator.\n\nSure, but the for loop version isn't intended as a generator - the for loop is using the yield statement to return a value.\n\nActually, the for loop version is intended as a generator. It's a generator that can't yield.\n\nI don't really see the problem with the for loop version. I think the point of the numpy version is to see what's going on in the inner loop, not the outer one. The outer loop is obviously a for loop.\n\nThe for loop version is fine, it's just that the outer loop is not for", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) > 1:\n        return l[0]\n    return len(l)\nNote that max_element() is linear in the list length.\n\nI would prefer to use the dictionary approach:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l.items(), key=lambda x: x[0])\nYou're missing the leading underscore on the return value, which makes it a local variable.\nI think it would be clearer to use len(l.items()) instead of len(l) for indexing.\nAlso, `l` should be `list`.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) == 1:\n        return l[0]\n    return None\nIt's nice that it returns None if the list is empty.\n\nThat's not an if statement, it's a for loop.\n\nSo, a single for loop can't be an if statement?\n\nNot in Python, no.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) > 1:\n       return max(l[0])\n    else:\n       return 0\n    def maximum_element(l: list):\n    \"\"\"Return the maximum element in the list.\n    >>> maximum_element([1, 2, 3])\n    3\n    >>> maximum_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if len(l) > 1:\n       return max(l)", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) > 1:\n       return l[0]\n    return None\nI think this is the real answer.\n\nAnd the answer to the first question is:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    max = list()\n    while True:\n        for i in l:\n            if i > max:\n               max = i\n             else:\n                max = max + 1\n    return max\n\nI prefer a simple, composable solution:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return l[-1]\n... or alternatively,\n      def max_element(l: list):\n        return l.index(0)\nIt's worth noting that the \"normal\" way of doing this in Python is to call \"itertools.max()\".</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return 0\n    else:\n        return max(l)\nTo me, this is more like a set than a list. A list would have:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l)", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l) - 1\nAm I missing something?\n\nIt's not the maximum element, but the index of the maximum element. The list is returned in reverse order, so it's the first element.\n\nOf course. That's a very simple and obvious way to do it.\nIn other words,\n(l - 1) * (l + 1) == l.last()\n\nSure, if you want the last element. The list is returned in reverse order, so it's the first element.\n\nThanks for the correction.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if list[0] > max:\n        list[0] = max\n    return max\nThis is a good example of how to write a bad python program.\nIf you want to iterate over a list and get the maximum element, write a function that does that. Don't modify the original list. If you want to get the maximum element in a sorted list, use the sorted function.\n\nI'm pretty sure this is why the language is so great. It's so incredibly easy to shoot yourself in the foot and write poor code in so many different ways.\n\nI've tried to do this many times, but haven't been able to get the performance I want. Is there a trick to it?\n\nIf you have Python 2.6 or higher, you can use the list comprehension syntax:\nmax_element = [list[0] for list in [1,2,3],", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    def max(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max([1, 2, 3])\n    3\n    >>> max([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    9\n    >>> max([1, 2, 3, 4])\n    3\n    \"\"\"\n    if len(l) == 1:\n       return l[0]\n    else:\n       if len(l) == 2:\n          return l[1]\n       else:\n          return l[0]\nThis is bad. If l is empty, it will return 1.\n\nOnly if you have an implementation that doesn't return the first element of an empty list. I'd say that's a pretty unlikely thing to happen, and so the behavior is not bad.\n\nI understand your point. But I think it's good to", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l)!= 1:\n       return None\n    for i in l:\n       if i == max(l):\n          return i\n    return None\nThis is a really bad solution. It's going to be slow since you have to walk the whole list on every call. You also have to add the return to the function call.  What you should do is to use a dictionary. Let's say l is a list of numbers.       max_element = {i: i for i in l if i == max(l)}\nFor Python 2 it might be:      max_element = {i: i for i in l if i == max(l) if i!=1}\nHow is it better than the OP's solution?\nIt's a dictionary of all the elements. You can iterate over it to find the max element without going through the list, or you can get the max element by key.\nSo you're going to walk through the list, checking if the element is in the dictionary.\nNo, you", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l[0] == max_element(l):\n       return max_element(l)\n    else:\n       return max_element(l[1:] + 1)\n\nThis is, what is known as, a \"dumb\" solution to the problem. It's dumb because it's slow.\n\nMore than that, it is not even _correct_. The max element of a list is not necessarily the first element.\n\nI can't believe I had to scroll down this far to find this comment.\n\nThe correct solution, as pointed out in this thread, is to sort the list. And then the resulting maximum element can be retrieved using an iterator.\nBut my comment was more a reaction to the fact that we have \"solved\" the problem of efficiently searching for the maximum element of a list in exactly the same way that we \"solved\" the problem of efficiently searching for an item in an unsorted list.\n\nThat's not the correct solution. The correct solution is to use a vector.\n\nIt's not a vector in that sense, it's a list that uses the same pointer to store its", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    max_element = lambda x: (x, x)\n    return max_element(l)\n\nHow is this different from this?", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return l[-1].max()\nIn my mind, this means that it returns the maximum element in the list, as if it were stored in an array.  So for the first example, it would return 3, and for the second example, it would return 123.\nI'm not really sure what you mean by \"it returns the maximum element in the list as if it were stored in an array\".  What's the difference between that and \"it returns the maximum element in the list\"?\nI'm sorry, I could have been more clear.  This is how I interpret what you wrote:            return l[-1].max()", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l:\n        return max(l)\nWhy is this so terrible?\nI would have written it like this:  def max_element(l: list):\n    if l:         return l[0]\n    else:         raise ValueError(str(l[0]))\n\nI'd just have it return None.\n\nI'd raise an exception in this case, because it's easy to modify the list\nin place (removing an element and then adding it back) to get a different\nresult.\n\nHow is this code helpful? It just looks to me like an obfuscated version of:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l: isinstance(l, str):\n        return l[0]\n    else:\n        return len(l)\n\nYou can also do this with \"max_element = max(l)\" if you're not using python 3.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return l.max\nYou can use the second return statement to return a tuple.  EDIT:  oh wait, you do that in your second example!  Sorry.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    max_element = 0\n    while l.has_key(None):\n        l.pop()\n        if max_element == l.pop()[0]:\n           max_element = max_element + 1\n    return max_element\nI really don't know if this is the right way, but I think that the key is the largest element in the list and the pop() method returns the element.\n\nI'm sorry I'm replying so late, but that was a great answer. Thanks.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    def max_index(l: list):\n    \"\"\"Return maximum index in the list.\n    >>> max_index([1, 2, 3])\n    2\n    >>> max_index([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    0\n    \"\"\"\n    return l.size() - 1", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0])\n\nmax_element is not a builtin function in python.\n\nThis is a common confusion. It is a builtin function, you just need to import it.\n\nHere is how to use it:\n>>> import max_element\n>>> max_element([1, 2, 3])\n3\n\nIf you don't want to import it, you can also just use sorted:\n>>> sorted(1, key=lambda x: x[0])\n3\n\nI'm glad you pointed this out. I often see that when people try to compare python to other languages they use examples like this, but they forget to import.\n\nI'll take a bit of a contrarian view and suggest that this is the biggest problem with python.\nWhy do I need to import this function?\nIt is impossible to know what the user is going to do with your code. If you write code that depends on the user importing a specific function from a specific module, you are doing it wrong.\nMy preferred approach is to not write code that depends on a specific combination of modules. If I need to do something that requires a specific module", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return sum(l)\nI see.\nBut I don't understand how the function is useful.\n\nYou can use it to find the longest element in a list, without worrying about how big the list is.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)\ni don't get it.\n\nreturn min(l)\n\nreturn max(l)\n\nreturn min(l)</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return None\n    else:\n        return l[-1]\nWell, that's a very short program.  I suspect the author made a typo.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) < 1:\n       return l[0]\n    else:\n       return l[1]\nDoesn't work for non-deterministic lists, though.\n\nI think the issue is that it depends on having a list of integers. A non-deterministic list could have any type, including other lists.\n\nRight. You can't call a function on a different type. You could maybe do something like type_of(l[0]) and use a type hint or something to make it work but it seems that there's not much point when you can just write the function again for a different type.\n\nOne could argue that the only reason that you'd use a list of numbers is for the maximum function, and that therefore, the max function should be in the language.\n\nI think the assumption is that the language can be used for more than just numerical computations.\n\nThe language also lacks a lot of things that are necessary for programming. For example, you can't get the length of a list without using external libraries.\n\nThis is very useful. I like the way you explained it", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    maximum = []\n    for i, item in enumerate(l):\n        if i == list.length:\n             maximum.append(item)\n    return maximum\nThe code here is very inefficient. It iterates through the entire list every time. I believe that there are better ways to do this, for example using a stack or a binary search.\nThis is one of those edge cases where the in-place list implementation sucks.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)\nShould be `max([l])` not `max(l)`\nThanks, fixed!\nJust FYI, \"max\" is a built-in function.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) <= 1:\n       return 0\n    for i, e in enumerate(l):\n       if e > max_element(l[i]):\n          return e\n    return max_element(l)\n\nI think the name \"max_element\" should be used for the function which maximises an array (ie. returns the maximum element), rather than the function which returns the maximum element from a list.\n\nI think this is a bad idea. If you look at the standard Python library, the name \"max\" is already used for something else (max() from the array module).\n\nI've always been frustrated with the name max(), which returns the _minimum_ element of the array it is called on, and similarly min() which returns the _largest_ element.\nAs the name implies, these are the functions you would use to find the max or min of an array.\nHowever, they do not do this.\nInstead, they return the smallest or largest _unordered_ element in an array.\n\nThere's a discussion here:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    max = 0\n    while l.has_key(max):\n       max = l[max]\n    max += 1\n    return max\nI don't understand why you would use a list if it doesn't have any elements in it, since you don't seem to be using the list data structure for anything else. Why not just call it as a function?\n\nIts the simplest solution, i am not saying this is the best solution. It should be just a \"toy\" to understand the concept.\n\nWhy not write it in assembly?\n\nThat's a good idea. I will try to do it.\n\nI think writing the solutions in different languages is a good way to learn. In the past I've done stuff in C, Java, Lisp, Python, Haskell and a bunch of others.\n\nI am not able to write in assembly, but I will try to convert this to c\n\nI would suggest looking at the assembly for an existing language. You don't have to know how to write it, just how to read it. A lot of languages have been written in assembly at one point or another, so there's", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    def max_element_by_key(l: list):\n    \"\"\"Return maximum element in the list for the given key.\n    >>> max_element_by_key(['1', '2', '3']\n    2\n    >>> max_element_by_key('1', ['1', '2', '3']\n    1\n    \"\"\"\n    return max(max_element_by_key(l))\nWhy is this python?\nBecause it's in r/python, dumbass.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) == 0:\n       return None\n    l.append(0)\n    return max(l)\nI wonder if this can be optimized, like maybe using a list of numbers instead of a list of strings?\n\nIt might be simpler to do a breadth-first search.\n\nI think this is still a bad solution:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l.count() > 1:\n        return l.max()\n\nI'm not sure what the point of this is.\n\nThis is an example of using a language feature to do something completely silly.\n\nI would normally have used the max builtin of the builtin container in Python. I just wanted to show the syntax of the new list comprehension. I admit, there isn't much value in this example. It's more of a silly example than a real example.\n\nWhat's the point of doing it this way? The code is not any shorter than:\nmax(l)\n\nThere is a lot of value in knowing how to use comprehensions. I'm not sure why people keep asking \"what's the point\" as if they're not incredibly useful.\n\nI'm asking because I don't understand. I would like to understand.\n\nPerhaps, then, you could phrase your questions in a more specific way, rather than asking why a useful, general-purpose feature exists.\n\nWhy is it useful?\n\nCan you read?\n_Perhaps, then, you could phrase your questions in a more specific way, rather\nthan asking why", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l) > 2\n    if len(l) == 1:\n         return l[0]\n    elif len(l) == 2:\n         return l[1]\n    elif len(l) == 3:\n         return l[2]\n    else:\n         return l[0]\n\nNot very good solution. All numbers are considered to be positive. What if you want to find the maximum negative integer?\n\nYou'll have to use a different heuristic. For example, you could use the sum of the squares of all the numbers in the list.\n\nAnd there are many other heuristics: the sum of the reciprocals, the number of divisors, and the sum of the divisors, to name a few.\n\nThe link is not a CS problem.\n\nIt is a CS problem, but it's more like a code golf problem. The language used is irrelevant.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l).max()\nbut don't think it is a good idea to promote this \"idiomatic\". I would find it more idiomatic to write:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l:is_empty():\n       return 0\n    return max(l)\nYou are using the wrong algorithm. You should use the `std::max` function.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l[0] == max:\n       return l[0]\n    for x in l:\n       if x == max:\n         return x\n    return 0\nI wonder how many variations of this question would end up here if you wrote that down somewhere.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda item: item[1] < item[0])[0]\nThat's not a correct solution. In particular, if the first two elements are equal, your solution will return -1.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    return len(l) > 1? max(l, key=lambda x: x[-1]) : None\n\n>>> max_element([1, 2, 3])\n3\n>>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n123\n\nThat's a lot of code to do the same thing that the for-loop does.\nYou could probably go even further and make a general max-function for any iterable.\n\nI don't see anything wrong with that code at all. It's a straight-forward implementation of what it says on the tin. It's good, it's simple, and it does what it says on the tin.\nAs a Python programmer, this is the type of code I like to see and write.\n\nThe code is totally fine, but it's just not needed for the problem at hand, because the for-loop is equally clear.\nIn other words, if you want to optimise the code for clarity and simplicity, you don't end", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l) > 0\nI feel like this is cheating. (Not that I know of any function I've written that does this - I tend to use generators for everything - but I've seen others.)\nBut of course, even generators are cheating, since you can just index from 0 and find the maximum number in the range.\n\nThe explicit return in the max_element example is an unnecessary flourish, but I think it's fairly clear that you're not guaranteed the 'first' element will be the largest (at least in the context of a list-like object).\n\nIt's not even a flourish. The explicit return is required, since the list may not be in order. If you return the length, then you don't know which element you actually got back.\n\nThis is exactly what I meant, but I couldn't think of the right word.\n\nI don't understand what the author is getting at. It's not as if we need to poll the dictionary to check if a word is valid, as that would be inefficient.\nThe dictionary is a key/value store. Why is the default value for a key not the empty set? Why would we ever need to use a key that", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l.size == 1:\n        return l[0]\n    else:\n        return max(l.size, key=lambda item: item[1])\nThis is a bit of a hack, it could be much faster.\nIf you only care about the element at the end of the list, there's no need to iterate over the whole thing.", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l == []:\n       return 0\n    return len(l), -1\n\nAs an alternative, I would use count(l).\n\nThat's true, but I'm not sure that's a reasonable alternative.\nI see no reason for `max_element` to use the list as a data structure at all, since it doesn't have to do anything with the list other than return a value that happens to be stored in a list.\n\nAs it happens, it does a lot more than that: it also needs to provide a way to get the maximum element from a list that's not in the list anymore.\n\nThis is an interesting read, but I'm not sure it qualifies as \"beautiful\".\n\nI second that.\n\nI was looking for a list of beautiful algorithms. This is not it.\n\nIt's not a list of algorithms. It's a post about how to make algorithms beautiful.\n\nExactly. It's a blog post about algorithms, but it's not a list of beautiful algorithms.\n\nIt is not a list of algorithms, it is a list of algorithms that are beautiful.\n\nAlgorithm: Beautiful or", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    \"\"\"\n    return l.pop(0)\nThis is incorrect. It takes the list as a tuple and returns the element. The actual behavior is undefined.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l) == 1\n    def max_sorted(l: list):\n    \"\"\"Return maximum element in the list in sorted order.\n    >>> max_sorted([1, 2, 3, 4, 5])\n    3\n    >>> max_sorted([-2, 0, 2, 2, -3, -4, 3])\n    -4\n    >>> max_sorted([1, 2, 3, 4, 5, -2, -3, -4])\n    5\n    \"\"\"\n    return max(l)\n\nHow about", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l)\nI've seen this used more often than not when a dictionary is available.  Though admittedly dictionary look-up is more performant than list look-up, list look-up is much simpler to understand.  (And that's why it's in the article, I'm sure.)</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return (l[0])\nI'm really glad that we don't need to write code like this in Python.\n\nRight, it's one of those things that is _really_ easy to write, and takes no time at all.\nAs an aside, I'm a little disappointed that python doesn't have the concept of a \"max\" function.\n\nPython's list comprehension notation is cleaner than Java's Java-like list comprehension notation, but you have to use a library to do list comprehensions in Python, so the result is a wash.\n\nI'm still very confused why this article seems to suggest that Java's list comprehension notation is somehow better than Python's.\n\nOne of the main criticisms of Java is that it doesn't have features that you can write in a few lines of code in Python. This is the case for both list comprehensions and closures. Java programmers complain about it all the time, and I'm not surprised it comes up in discussions of Java, even when the discussion is about something completely unrelated.\n\nI agree that closures are a weakness of Java. List comprehensions are not, however, as they've been added to Java in Java 7.\n\nThey're added to Java", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return l[0]", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) < 1:\n        return 0\n    else:\n        return l[0]\nYou probably wanted to have it return the length of the list instead of 0.\n\nThat's not guaranteed to work in all languages.\n\nIs it guaranteed to work in any?\n\nNone come to mind, but many allow recursion to work on lists, so the first step could return the length of the list if the list is empty.\nI'm just guessing here.\n\nIt's always hard to remember that you have to use different variable names for different languages. I thought the OP was referring to the Python datetime library.\n\nI thought so too until I read the comments.\n\nThe most confusing part for me was that I was expecting code in C# to be in PascalCase, but instead it is in camelCase.\n\nC# should be PascalCase, but it is in fact camelCase.\n\nAnd here's a non-C# example.\n\nIt's been said that one of the \"drawbacks\" of Python is that if you have to change code from an existing project that you", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    max = max(l)\n    if max == 0:\n        raise ValueError('No value is the maximum of a list.')\n    return max\n\n>>> max_element([1, 2, 3])\n3\n>>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n123\n>>>\n\nThe max function is not the same as the max_element function. The first\nis a method defined on lists, and the second is a function defined on the\ntype int. Since Python is dynamic, the type int can be coerced into a\nlist, but only if you tell Python to do so. You can do this by adding a\nbunch of parentheses, so instead of doing max(l), do max(l*l) where the\n* is the type conversion operator.\n\n>>> max_element(l*l)\n123\n>>>\n\nSo this code is actually a lot more confusing than it needs to be, and it\nis also a bit slower since you have to do the type conversion every time\nyou use it. I", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l) == 1\nThis code is just awful.\n\nIt's no worse than the usual way of doing this, which is to use a list comprehension:\nmax = [0] * [1] * [2]\nHere's another one that's far more readable:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)\nYou should probably add to the function description that max(x) returns the index at which x appears in a list.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    \"\"\"\n    def maximum_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> maximum_element([1, 2, 3])\n    3\n    >>> maximum_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    max = l.pop(0)\n    # All of the elements except the last are passed in as arguments\n    remaining_elements = [l[i:i+len(l)] for i in range(len(l)-1)]\n    # The last element is the remaining elements minus the first\n    # element\n    return max - remaining_elements[0]\n\nAhh, but this isn't doing any work for you. You _know_ that max_element is going to return a list, so you're just using Python's list structure as a shortcut. You should be able to make it work using a lambda.\n>>> max_element = lambda l: max(l", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    maximum = -1\n\n    for i in range(1, len(l)):\n        for j in range(0, len(l)):\n           if l[i][j] > maximum:\n               maximum = l[i][j]\n    return maximum\n\nThis is not O(n log n) in the general case.\n\nWhat makes you say that?\n\nAssuming the list contains n elements, the method is recursive and has to\niterate through all the elements in the list.\nIn the general case, each time it iterates through all the elements, it\nhas to test whether each element is greater than the current maximum.\nSince the list is of infinite length, this loop will never end and thus\nthe method does not terminate.\n\nYou may want to add a comment indicating the potential infinite recursion.\n\nYou may want to add a comment indicating the potential infinite recursion.\n\nBetter yet, the author should learn how to implement a basic recursive\nalgorithm.\n\nBetter yet, the", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return sum(l)\nWhat is the purpose of this? There are many ways to do the same.\n\nIt is just a little example. Of course, there are many ways to do the same.\nThe idea is to show that you can use Python's functions to build up a solution that is not always obvious. In this case the only way to do the same is to either\n1) Add the numbers and compare or\n2) Count the elements in the list and compare.\nI wrote it for no particular purpose other than to show that the solution can be done easily using Python's built-in functions. I'll add that to the blog post.\nThanks for the suggestion.\n\nI was asking because I didn't understand what the purpose was. I didn't know if there was a specific reason you chose that solution.\nI don't see the difference between your solution and adding the numbers and comparing, or counting the elements in the list and comparing. Both are simple solutions that do the same thing, so I don't understand why you chose to show how to use sum() to return the maximum value, instead of adding and comparing.\nI've seen solutions to problems that use very simple solutions that anyone would", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if not l.is_empty():\n       return l[0]\n\nThis might be a good example of the difference between Python and Ruby: the first one returns the first element, while the second one returns the max element. Ruby always returns the max value when comparing two objects.\n\nAs someone who learned Python first, this struck me as odd too.\n\n> def max_element(l):\n> return l.first\n>\n> max_element([1, 2, 3])\n> 1\nThis is the correct answer for Python.\n\nThe best way to make your code more readable is to use a language that is easier to read.\n\nIt sounds like you're just making a dig at Python. But the truth is that you can make your code more readable in any language. The most important thing is to be consistent and not make your code more readable in some places and less readable in others. If you do this, you're not making your code more readable, you're just making it more inconsistent.\n\nNot a dig at Python at all. My point is that it is easy to write bad code in any language, and the first step towards good code", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)\n>>>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l: isnum(list):\n        return l\n    elif len(list) > 1:\n        return max(x for x in l)\n    else:\n        return None\n\n    def max_contiguous(l: list):\n    \"\"\"Return maximum contiguous element in the list.\n    >>> max_contiguous([1, 2, 3])\n    3\n    >>> max_contiguous([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if len(l):\n        return max(l[0])\n    elif len(l) == 1:\n        return l[0]\n    else:\n        return None\n\nfails to pick up the the first solution, which is the correct one\n\nHere is a more extensive version of the same problem", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l) < l[0]\nthis is a possible implementation, but it is highly inefficient since it iterates over the entire list for every element. It would be better to use a set-like method which compares elements without iterating over them.\nThe same can be said about your implementation of min_element.\n\nYeah, that implementation is just for illustration. I think min_element could be implemented with a trie - if the dictionary is sorted, you just check the first entry. But max_element is harder, and probably you'd need to use a tree, although the data structure doesn't really matter if you're just interested in the basic algorithm.\n\nMy preference is for a balanced search tree. It is not too hard to implement and is pretty efficient.\n\nI've never used balanced search trees before. Do you have an example implementation?\n\nI have implemented a balanced binary search tree here: \n\nI think a set will be the most efficient. You just have to find the index of the maximum element. And you have the advantage of the syntax:\nlist_with_max_element = [1, 2, 3, 4, 5, 6, 7, 8", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l) - 1\nThis is the first time I've ever seen a negative indexing operator.\nTo be fair, the number of programmers who understand the difference between `n` and `i` is probably pretty small.   But why not `max_element(l) == l[0]`?\nYeah, that's not much better.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if not len(l) == 1:\n        return None\n    else:\n        return max(l)\n\nreturn max_element", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l)\nIt doesn't. You didn't check for outliers at all.\n\nCorrect. That was just an example. I guess I should have mentioned that.\n\nThis code is actually incorrect. It should instead be:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return (int)l.index(0)[0]\n\nHeh, I used to do this in C++ too.\n\n>>> def f():\n    \"\"\"Print out all the elements of the list in an iterable format.\"\"\"\n    for i in range(0, len(list)):\n        print list[i]\n    return\n>>> f()\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25]\n\nI like that this is the top voted comment, because it's the perfect example of something that is exactly what it looks like. There's no hidden magic or trickery, just straightforward, easy to understand code.\n\nWell, it's Python, so it's a little bit of magic, just not the kind we have to learn.\n\nI think it's a little more than a \"little bit\" of magic, but it's the kind of magic I'm OK with.\n\npython's magic doesn", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    l.max()\n    return l.max()\n\nI was surprised to see this in a recent project, I think a lot of people use `max()` to get the max element from a list.\n\nI remember when I was first getting into programming, I had some for-loop that used a temp variable, and my teacher told me to use list[0] instead. I was surprised to learn that you can do that, but it made sense.\n\nAnd also, list[0] and list[-1] in case your for loop uses that\n\nSome lists and array-like objects have special 0 and negative indices to make it easier to get the length of the list/array:\n\nIt's not a builtin, but the LazyList[1] library also provides a max() method.\n[1] https://github.com/pavg/lazylist\n\nI like this implementation (from Python) https://www.python.org/dev/peps/pep-0484/\n\nI have also used this implementation in my own code: https://github.com/srobertson/algo\n\nIn other", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l.__getitem__(0))\nmax_element([1, 2, 3])\n>>> 1\n\nAs explained here:\n\nD'oh!\nI guess I should have read the code first, as opposed to reading the\ncomments and thinking that the poster was asking a real question.\n\nThe title of the post has the words \"useful\" and \"optimization\" in it.\nWhy is this even on the front page of HN?\n\nI've always wondered if there was a way to do this.\n\nSo Python?\n\nYes. Because people who have only used Python will be confused why Python's solution to a problem is \"use a third-party package\".</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l[0] < l[1]:\n       return l[0]\n    return l[2]\nIt would be nice if this was at the top of the page and had a nice example, so I could see what it's doing without having to dive in.\n\nI put the line you posted at the top of the page, and replaced the line that was there before with a link to the documentation (which is in the same place as the example, but with a bit more explanation).\n\nThe documentation links at the top of the page do not have a \"What's this?\" section which is what the post author was requesting.\n\nAh, gotcha. I had forgotten about that section, so I didn't realize it wasn't there.\n\nA similar question was asked on SO about the same library:\n\nNote that this uses the same strategy to find the maximum element, but the implementation is different.\n\nThe author needs to read up on the addition and multiplication operators, which are defined differently in the context of lists. He is also misusing the assignment operator, and the list comprehension operator.\nThe max_element function is not well written.", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    element = l.pop(0)\n    if element is None:\n       return list(0)\n    else:\n       return max(element, l)\n    def iter_right(l: list):\n    \"\"\"Return a list of elements sorted in descending order by iterating\n    right on the list.\n    >>> iter_right([1, 2, 3], reverse=False)\n    [1, 2, 3]\n    >>> iter_right([1, 2, 3], reverse=True)\n    [3, 2, 1]\n    >>> iter_right([1, 2, 3], reverse=True, reverse_index=False)\n    [3, 2, 1]\n    >>> iter_right([1, 2, 3], reverse=True, reverse_index=True)\n    [1, 2, 3]\n    >>> iter_right([1, 2, 3], reverse=True, reverse_index=True, reverse_left=True)", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return list(1)\n\nThe example list is a trivial example, but I would be interested in a more general solution, if one exists.\n\nThis is the first solution I found to this problem:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return l[-1]\nI'm sorry, but this is useless... It's just a less readable version of `max(l)`.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l == list.end:\n        return l[0]\n    else:\n        return max(l)\nThe maximum element in this list is 2.\n\nI came up with that independently a few weeks ago, and wrote some tests to be sure it worked. I never wrote it up, but it's nice to know someone else came up with the same thing :)\n\nI think I did something similar:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return l[0]\nIt's no harder than finding the largest int in a list of integers, but this will be faster in Python than the naive version, because in Python a list is a tree, and trees are faster than linear searches on lists.\nThat being said, I like the pure Python solution. I'd never come up with that!\n\nOne can make it better still by combining the two versions, doing the linear search on the whole list for the first iteration, and then looping over the remainder of the list after the first element to find the next element to check.\n\n_One can make it better still by combining the two versions, doing the linear search on the whole list for the first iteration, and then looping over the remainder of the list after the first element to find the next element to check._\nWhy do you need to do that? The first iteration is the easiest, because you can just iterate over the list to find the largest element. After that, you don't need to search the whole list, because you know the largest element.\n\nYou want to do the linear search first, because that will use a tree data structure, which is more efficient than iterating over a list", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)\nThis is faster and more memory efficient.\n\nnope, python is python and js is js.\n`max` in python is implemented as a list comprehension, `max` in js is a function call.\n\nI was talking about the version in the original article, which is an equivalent list comprehension (e.g., the JS version above).\n\nThis is an incredibly bad idea.\nIt is essentially the same as an onClick=\"javascript:alert('pwned')\" in that it relies on an attacker's actions to produce an attack vector.\nI can't count the number of times I've had to explain to people that onClick is very dangerous. This is a lot like that, but more complicated.\nIf you want a count function, it should be implemented in a way that is impossible for an attacker to exploit. It is not reasonable to rely on the attacker to provide the exploit.\n\nIf you can't count the number of times you've explained the dangers of onClick, maybe you should be a bit more diligent about providing your audience with a solid argument in favor of using it.\n\nIt's a side-effect of people understanding their own projects.", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    max = l.max()\n    if max is None:\n       return None\n    return max", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)\nIt is not O(n). It depends on the order of the elements.\n\n(I think you mean O(n) in the worst case. It is O(n) in the average case).\nIt is O(n) in the worst case, but it depends on the order. I'm not sure if it is in the average case. The 'c' from the'max' does not imply constant time.\n\nYou are right, I did mean worst case. I changed the comment.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l == [] or l.count() == 0:\n        return 0\n    for e in l:\n        if e > l[0] and e < l[len(l)]:\n           return e\n\nIt's not a general solution, but for this particular problem, it works.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return l.index(0)", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return 0\n    else:\n        return max(l[::-1])\nI would prefer a different name for the method, as \"max\" is generally used for the maximum function that returns the largest of two or more values.\n\nThat's the conventional usage. But in Python's list datatype, the value of the first element of a list is 0, so it can't be the largest of two or more values. The semantics are different.\n\nIs the list datatype standard? I can't find a definition of the list datatype.\n\nThe Python list data type is the same as the Python dictionary (as long as you don't mutate the list or use it as a key). So you can see the dictionary docs for the list definition:\n\nI've been doing this for a while. At work I use it for finding the largest of a list of floating point values (e.g., a list of numbers representing the weights of particles in a simulation).\n\nUseful.\nI prefer this method:\nmax_element = 0\nfor i", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l) > 0 and not l[0]\nIt's not really the *fastest* way to do it.  You can't easily use it with iterators.  You don't have to worry about the list not containing any elements, or it containing more than one element.  It's just the most straightforward way to do it.\nYes, I was looking for the fastest way and you are right, this is not it.\nIt's not the fastest way, but it's the easiest way to implement.  You can always wrap it in something else if you need to.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    for element in l:\n       if element < max_element(l):\n         return element\n    return max_element(l)\nI'm going to feel bad if I'm wrong and you actually did get the answer from this, but it's bad form to post the answer to your own question on a forum.\n\nThis looks like a homework question.\nIf it's for homework, then I don't think posting the solution is the same as giving the answer.\n\nI think it would be much better to post the code you've tried so far and the errors that you've encountered and the expected behavior.\n\nmax_element doesn't support negative indices so you can't do what you want. You need a two-argument version of max_element:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return l[0]\nThis is the code I use for a minimum function, but I don't really like it. Is there a better way to do this?", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)\n\nmax_element is a little bit faster than max(l).\n\nSee also\n max (mathematics)\n\nReferences\n\nExternal links\n http://www.python.org/doc/current/lib/python/programming/sorted.html\n http://www.python.org/doc/current/lib/python/functions.html</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    l = [element for element in l if element > max_element(l) else None]\n    return l.head()\nThis is very inefficient, by the way.  If the element you're looking for is the last one, this will iterate the entire list and return None every time.  The way to do it efficiently would be to use something like the heapq module and return the first maximum element.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    def max_element(l):\n    if len(l) == 0:\n        return len(l)\n    return max(l)\nWhen I was a CS student, I'd always make sure that I would put \"return max(l)\" at the end of any functions that took a list as an argument.  But now that I've been working professionally, I've just given up.  The above code is so much clearer.\n\nWhat does that mean? If you say \"return max(l)\", you mean the same thing as \"return max_element(l)\". Why does the second one take three lines instead of one?\n\n_What does that mean?_\nThe first one assumes that the function's argument list is a list of numbers, and the function returns the maximum element in that list.\n_If you say \"return max(l)\", you mean the same thing as \"return max_\nelement(l)\"._\nNo. max(l) is ambiguous: it can either be a function that returns the maximum element in a list, or it can be a function that returns the length of the list. I suppose", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    return len(l) > 1 and l[-1] > l[-2]\nThis is completely unnecessary. I assume you have some reasoning for this that I'm not seeing?\nI think it's because you can't have a list of just one element:\n>>> l = [1]\n>>> l\n[1]\n>>> max_element(l)\nTraceback (most recent call last):\nFile \"\", line 1, in <module>\nFile \"/Users/ronnie/Documents/Programming/Python/functions/max_element.py\", line 8, in max_element", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)\n\nfor i in range(len(l)):\n    print(max_element(l, i))", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    l.remove(0).append(0)\n    return sum(l.values()[::-1])\n...", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l) - len(l[0])\nActually no. The max element of the list is the one that makes the list the longest. So the max element of the list you provided would be [3, 9, 0, 123, 1, -10]\nOr, the max element of the list is the one that makes the list the longest.\nNo, it's not. A list can be the same length without the max element being present. This depends on what you're using to compare the lengths of the lists.  (for example, a max element of a sorted list can be the last element).\nThat's fair enough. I was thinking of a list that is defined as having no gaps in the sequence.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return l[0].__max__()\nThat's a great way to loop over an entire list!</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    def max_index(l: list):\n    \"\"\"Return the index of maximum element in the list.\n    >>> max_index([1, 2, 3])\n    3\n    >>> max_index([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    return len(l) > 0 and max_element(l)\n\nHow do I make it so that if no max element exists it returns None?\n\nThere's a bunch of ways to do this. One way is to have a default value in your function and if the max index is greater than the default, then the function returns it.\nSo if you have a default of None, then you can just use the default value.\n\nmax_index(l, None)\n\nYou can also just return the minimum index in the list if there's no maximum element.\n\nmax_index(l, min(l))\n\nAnother way is to use an empty list as your default value.\n\nmax_element(l, [])", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) < 2:\n        return None\n    return l[0]\nThis is not a very good example. It'd be more correct to use something like this:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return sum(l)\nYou are the one using Python 3, why are you using 2?\nAlso, if you are looking for \"truth\", then you should use:\n>>> max_element(list(1,2,3))\n>>> max_element(list(5,3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n>>> max_element(list(1,2,3,5,3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n>>> max_element(list(1,2,3,5,3, -5, 2, -3, 3, 9, 0, 123, 1, -10))\n\nInteresting, I just tried it and it gives me different results. I'm using Python 3.4.0.\nI use 2 because I prefer it, I'm sure you can do it with 3, I've just not tried it yet.\n\nThe default behavior changed in 3.4:\n>>> max_element([1, 2, 3])\n3\n>>> max_element([1, 2, 3, 5", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)\nI also added a max method to the collections library.", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l: not isinstance(l, list):\n       raise Exception(\"arg must be a list\")\n    return len(l) - 1\nI thought that was the obvious way to do it, but there is a much more obvious and efficient way to do it using the functools library:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    def max_element_in_list(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element_in_list([1, 2, 3])\n    3\n    >>> max_element_in_list([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if l.is_list:\n        return max_element_in_list(l)\n    else:\n        return 0\n    return max_element_in_list\n\nPython", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)\nI guess it's a little nitpicky, but I wish they had used the function notation that Python uses, and not a lambda.  I'm probably just being pedantic though.\nIt's not just Python.  Ruby, OCaml, Java, etc. all use function notation.\nI know. I was just trying to limit my list to what I think are more popular languages.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)\nI'm pretty sure that l is a function there.\nBut I'm also pretty sure that l doesn't take in a list as a parameter.\nI'm going to go out on a limb here and guess that this is a joke.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n\nmax_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\nmax_element() is a function that accepts a list and returns the index of the list's maximum element. For lists with positive elements, the function returns the index of the largest element. For lists with negative elements, the function returns the index of the smallest element. For the following list, max_element() returns 2:\n\n[5, -3, -2, -1, 0, 1]\n\nThe following example demonstrates how to use max_element() to find the index of the maximum element in a list.", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l is not None:\n       for element in l:\n         if element is not None and l[element] > l[max_element]:\n            return max_element(l)\n    return l[0]\nAs the other poster said, this is slow as hell, and also the list has to be sorted to use it.    I would look at the following algorithm for inspiration:        def max_element_list(l):                 return l.sort()[0]\nYeah, I was going to suggest using an iterator instead of a list as well.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) > 0:\n        max_element = 0\n    for i in l:\n        if i < max_element:\n           max_element = i\n    return max_element\n        return 0\nThis is the correct answer.  Why do you want the function to return the minimum element in the list, though?</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    # Simple case\n    return l[0]\n    # Complex case\n    \"\"\"\n\n    def max_element_from_tuple(tuple):\n    \"\"\"Return maximum element in the tuple.\n    >>> max_element_from_tuple([1, 2, 3, 4])\n    4\n    >>> max_element_from_tuple([[1, 2], [3, 4]])\n    [1]\n    >>> max_element_from_tuple([[1, 2, 3], [4, 5, 6]])\n    6\n    >>> max_element_from_tuple([[1, 2, 3], [4, 5, 6, 7, 8]])\n    8\n    >>> max_element_from_tuple([[1, 2, 3, 4], [5, 6, 7, 8]])\n    8\n    \"\"\"\n    # Simple case\n    return tuple[0]\n    # Complex case", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)\nWhat if the list is empty?\nWhat if the list is [1, 2, 3]?\n\nYou're right. I haven't actually written the max_element function. My assumption was that the list would always be non-empty.\nThe empty list, of course, is a problem. But I would have thought that [1, 2, 3] is well defined. The list is empty, so max_element returns 3. Is that incorrect?\n\n[1, 2, 3] is an example of a list that will not have a maximum element.\n[1, 2, 3, 4, 5, 6, 7, 8, 9] on the other hand, will have one.\n\n\"If I have seen further than others, it is by standing upon the shoulders of giants.\" \\- Isaac Newton\nThe expression \"standing on the shoulders of giants\" is sometimes used to refer to the use of tools, techniques, and knowledge developed by others. In some cases, this concept has also been used metaphorically to refer to the achievements of other people, institutions, or nations.\n\nI don't think the author gets the point of the article. He's", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l == list() or l[0] == None:\n    return l[0]\n    return max(l.pop(0))\n\nNote that this is not the most efficient way to find the maximum element of a list.  An alternative way is to count the number of elements in the list, and find the maximum one.  The maximum element might not be the first or the last element, but there is a maximum, and it is the element that happens to be the most frequent.\n\nIn Python 3, the max function can be used to find the maximum element.", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)\n\nI think this is a very nice and simple way to express this, but I'm not sure if it's the best approach. I'm thinking of writing a general expression evaluator and I'm wondering what the best way is to write the max function.\nEg:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l == [] or len(l) == 1:\n       return l[0]\n    else:\n       return max(l)\n\nMax_element: __iter__(list) -> iterable\nMax_element: __contains__(self, x) -> bool\nMax_element: __len__() -> int\nMax_element: __reduce__(self, f, x) -> None\nMax_element: __reduce__(self, f, x, mapper) -> None\nMax_element: __reduce__(self, f, x, mapper, kwargs) -> None\nMax_element: __reduce__(self, f, x, mapper, kwargs, default_fn) -> None\nMax_element: __reduce__(self, f, x, mapper, kwargs, default_fn, op=None) -> None\nMax_element: __reduce__(self, f, x, mapper, kwargs, default_fn, op) -> None\nMax_element: __reduce__(self", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) == 0:\n       return None\n    else:\n       return max(l)\nAnother nice way to do this is with the \"lzip\" function from numpy.linalg:\n>>> import numpy as np\n>>> import numpy.linalg as linalg\n>>> np.linalg.lzip(l)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> l = np.linalg.lzip(l)\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> max(l)\n9\n\nFor a list of numbers, you can also use \"find\" from numpy.linalg:\n>>> import numpy as np\n>>> import numpy.linalg as linalg\n>>> l = np.arange(0, 4)\n>>> find(l, 1, -3)\n3\n>>> l = np.arange(0, 4)\n>>> find(l, 1)\n-3", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) < 2:\n       return list(1)\n    else:\n       return max(l[0], l[1])\nI don't get it. When len(l) < 2, the result should be 1. When it's 2, the result should be list(1). What does the return statement do?\n\nIn Python 2.x, the result of a generator expression (what's being passed to the function call here) is not a list, but rather a generator object. The \"return\" statement is merely a syntactic convenience to allow the use of an object as if it were a function; in this case, the function that is returned from the function call is a generator that always returns the first value from the generator.\n\nI'm using Python 3.\n\nYes. The \"return\" statement is used to define the \"return\" value of the generator function.\nIn Python 3, you can also return a normal function and have that function call the generator. This may be more convenient in some situations.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return l[0]\nWe need some sort of syntax for list comprehension.\n\nDon't you have something similar to it?\nPython has\nmax_element(list(1,2,3))\nand\nmax_element(list(5,3,4,1))\n\nBut it's always the last element, isn't it? It doesn't \"return\" the largest element.\n\nYes, it does.\n>>> max_element([5, 3, 4, 1])\n5\n>>> max_element([5, 3, 4, 1, 2, 3, 4])\n3\nIt does the same thing as the function in the article, just with a different syntax.\n\nI think this is a pretty good example of why functional programming is not so great:\n1\\. you get the wrong answer if you don't notice the type of your input\n2\\. even if you do notice the type, it is not at all clear how to handle the different cases\n\nTo be fair, I think it's a pretty good example of why _imperative_ programming is not so great.\n\nI'm not sure what's the difference, the solution is still imperative.", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)\nmax_element(x) would be much more readable. I mean, I know it's common to use the fact that the C++ max() is not thread-safe, but it should be used only for performance critical parts, not for the whole code.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l.index(element))\nWhy is this in python?\n\nBecause Python is fun.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return [x.get(0), x.get(1)]\nThe first time I saw this I thought \"how nice is that\". And the second time as well.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return min(l.pop())\nI like that.  I might use it in a utility function for my own use.\n\nI have a utility function like that which I use all the time. If the first item in a list is the max, it's easy enough to extract it. If not, then it's simply the max of the other items in the list.", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l: integer is None:\n        raise Exception(\"invalid input list\")\n    else:\n        return l: integer\n\nThis is pretty simple. The interesting part is the part where it checks if the list is empty.", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l) - 1\nI'd be more interested in the average element, the median element, and the lowest/highest element. I don't see how this is better than a for loop.\n\nBecause it's more readable and more concise?\n\nMore readable? Maybe. More concise? No.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l[0] < l[1] or l[1] < l[2] or l[2] < l[3] or l[3] < l[4]:\n        return l[1]\n\nCool, let's have a look at the code to see what it does:\n\nmax_element(['1', '2', '3'])\n\n>>> return '3'\n\nmax_element(['5', '3', '-5', '2', '-3', '3', '9', '0', '123', '1', '-10'])\n\n>>> return '123'\n\nI'm not sure about you, but I'm always amused by the terseness of Python and other \"scripting\" languages. I feel like I could spend my entire life just reading Python code, trying to figure out how people managed to write code that's so succinct.\n\nBy the way, I'm not sure if you noticed, but Python is just another programming language, and it's really not suitable for all programming tasks.\n\nThe difference between Python and other programming languages is that Python is a scripting language", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l)\nthe documentation doesn't even mention that it only works for lists and not any sequence.\nI get that it's just a little snippet for learning, but it's a bad way of teaching.  It's a bad way of teaching because if the documentation mentions that it only works for lists, there's no reason for the comments in the code to not mention it.  It's a bad way of teaching because it's not a good example of \"Pythonic\" code (i.e. the code is unreadable).</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) < 1:\n        raise ValueError(\"Must be a list of numbers.\")\n    else:\n        return max(l)\n\nAs far as I know, `max` is a built-in function. It's not clear to me why the author bothered reimplementing it.\n\nFor one thing, built-in functions can't be used in namespaces.\n\nWhy would you want to use this?\n\nPython 3:\n>>> x = [1,2,3] >>> max(x) 1 >>> x = [1,2,3,4] >>> max(x) 3 >>> x = [1,2,3,4,5] >>> max(x) 5\nIn Python 2:\n>>> x = [1,2,3,4,5] >>> x.max() 5 >>> x = [1,2,3,4,5] >>> x[:5].max() 5\n\nx is a list of lists, not a list.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    else:\n       return max(l.pop() for l in l)\nThis doesn't seem to work when the list is sorted.  For example, if you have:\n\n       [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18]\n       max_element([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18])\n       # Error: TypeError: list index out of range\n\nAnother approach is to use recursion, since the problem is more or less amenable to it.", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) > 1:\n         return max(l)\n\nPython is nice for its readability and its expressiveness. However, I think a lot of us who write Python take this expressiveness for granted. It's easy to write a horrible mess of a program and have it work, because Python's 'intuition' helps you get away with a lot of things.\n\nThe problem is that in a code base, it's hard to tell the difference between an accidental mess and a program that was written by someone who doesn't understand the language. I used to work with a person who wrote the most convoluted code in Python, and it was hard to tell if it was because he was a poor programmer or if he just had no idea what he was doing. He kept writing the same nasty, confusing, long-winded functions over and over again.\n\nSome Python code is very hard to understand and read. The easiest way to avoid this is to use the language's existing idioms to write code that is clear and concise.\n\nAlso, don't use 'def'.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l is None:\n        return None\n    return l[0]\nI have no idea how this is supposed to work.\n\nIt's supposed to return the maximum value of the list, and in this case it did. If the list is empty, it returns the same thing, which is why it worked in the example.\n\nSorry, I meant to say that I don't understand how it's supposed to work according to python conventions.\n\nIt's a very simple and popular algorithm, and a convenient way of accessing the list's length. If you want to access the nth element of a list, you don't have to do:\nlist[0] = list[1:]\nYou can just do:\nlist[0] = list[1:]\nWhich is why people use it.\n\nVery clever, but perhaps the \"best\" way to show this off would be in a shell, where it's more obvious what you're doing.\n\nIt's a decent example of using Python as a scripting language.\n\nThere's something about this code that doesn't quite seem right. Perhaps it's that I'm not a Python programmer and so", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l) > 0\n        def min_element(l: list):\n    \"\"\"Return minimum element in the list.\n    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    >>> min_element([3, 5, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -5\n    \"\"\"\n    return l[0] < l[1]\nI'm not sure if that's the most efficient way to do it, but it's the way I've been using.\n\nI like to use it like this:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) > 1:\n       return max(l)\n\nAh, so this is the article that was referenced in \"A thought for the day\". I'm not sure how to feel about this...</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    else:\n       return max(l, key= lambda element: element[0])\n\nBut:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l.length == 1:\n       return l[0]\n    else:\n       return max(l)\n    def max_index(l: list):\n    \"\"\"Return maximum index in the list.\n    >>> max_index([1, 2, 3])\n    1\n    >>> max_index([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    2\n    \"\"\"\n    if l.length == 1:\n       return 1\n    else:\n       return l[0]\n    def count(l: list):\n    \"\"\"Return number of elements in the list.\n    >>> count(['abc', 'def', 'ghi'])\n    3\n    >>> count(['abc', 'def', 'ghi', 'abc', 'def', 'ghi'])\n    7\n    >>> count(['", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    maximum = list(l)\n    while max is not None:\n        max.remove(1)\n        max = max.get(0)\n    return max\nThis is a better solution but still not very elegant or pythonic.\nThere are many other ways to do it with python but this is the cleanest I've found.\n>>> max_element(list(range(10)))\n0\n>>> max_element(list(range(10) + 1))\n11\n\nIndeed. The classic way to do it is to define a class for lists that implements __max__:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return l.index(0)", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    return (l[0] if len(l) == 1 else None)\n    def list(elements: list, n: int):\n    \"\"\"Return the list with all elements replaced with `n`.\n    >>> list([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5, n]\n    >>> list([1, 2, 3, 4, 5, n])\n    [1, 2, 3, 4, 5, n]\n    \"\"\"\n    if len(elements) == 1:\n       return elements[0]\n    return (elements[0] if len(elements) == 1 else [])\n    def length(l: list):\n    \"\"\"Return the length of the list.\n    >>> length(['A', 'B', 'C'])\n    3\n    >>> length([1, 2, 3,", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    for i in range(len(l)):\n        if l[i] < l[i+1] or l[i] > l[i+1]:\n           return l[i]\n    return None\nI think it's a fun thing to write a few of these.  What's the most efficient, etc.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l)\nThis is going to be a problem for lists of strings.\n...", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) > 0:\n       return max(l[0])\n    return l[0]\n\nI had a feeling that was the way to do it. Thanks for the confirmation.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l[::-1])\nWhat if you want to return the element with the greatest index?  Or the greatest index of the list that is greater than a number?  Also, how do you deal with the case where the list is empty?  I've never liked this solution.\nYou're right. The only case where it is correct is if the list is not empty. If it's empty, then the call to max(list) will throw an exception, which is not nice.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l[0] < l[1]:\n        return l[0]\n    return l[-1]\nI'm not sure how this is at all a useful function. It's far more likely that you'll have a sorted list.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l)\nI prefer:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    l = [1, 2, 3]\n    for i in range(len(l)):\n       if l[i] > max_element(l[i - 1]):\n          return l[i]\n       if i >= len(l):\n          return -1\n    return max_element(l)\n\nThis has some bad consequences if we are trying to do something like \"get the longest list element\" or \"get the shortest list element\":\n>>> max_element([1, 2, 3, 4, 5])\n-4\n>>> max_element([1, 2, 3, 4, 5, 6, 7, 8])\n6\n>>> max_element([1, 2, 3, 4, 5, 6, 7, 8, 9])\n9\n>>> min_element([1, 2, 3, 4, 5, 6, 7, 8, 9])\n3\n>>> min_element([1, 2, 3, 4, 5, 6, 7, 8, 9])\n-6", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l)\n(Edit: I changed the example to use a list instead of a tuple, because I think it's a little more illustrative.)\n\nHow does this help with the problem of (iterate all combinations of length n) being larger than (iterate all combinations of length n / 2)?\n\nBecause he didn't say that it did, but it does help with the problem of (iterate all combinations of length n) being larger than (iterate all combinations of length n / 2) _for a given value of n_, and that was the actual problem being addressed.\n\nI can think of one use-case for this: a while-loop without a counter. A while loop with a counter is more flexible, but requires the programmer to manage the counter.\n\nPython's range() function has the same effect:\n>>> range(1, 10)\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n>>> range(1, 10, 2)\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n>>> range(1, 10)\n1, 2, 3, 4", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)\nThere's also max_n_elements from numpy.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    if len(l) == 0:\n       return None\n    return max(l)\n\nThis is a wonderful example of how to write bad Python code.\n\nWhy? What's the correct way to do it?\n\n1. Use list comprehensions.\n2. If you are using the Python 2.x version, use list() instead of list[0] because it is more efficient.\n\nI'm not sure I understand what's bad about this code. It's a one-liner which works and does exactly what the author wanted. It's not like it's making use of any special built-in features of Python (e.g. list comprehensions).\n\nThat's exactly why it's bad. It uses two features of Python: list comprehensions and list()\n\nIt's not the job of a one-liner to demonstrate the performance characteristics of Python. If that was the case, we would be writing Python code like this:\nx = x + 1\ny = x\nx = x - 1", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l[0] > l[1]:\n       return l[0]\n    else:\n       return l[1]", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    # Create a temporary list to hold the maximum element\n    max_max = []\n    for i in l:\n       if i > max_element:\n          max_max.append(i)\n    return max_max", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l.__contents__)\nGood one. I also thought of:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l)\nIf l is empty then return 0.\nIf you are using python 3 then return type should be int not list.\nIf you want to return list then you need to convert it to list, list.append(i)\n\nit's python 2, but that's a good point\n\nthe point is that Python is not a static language.\nThe meaning of \"list\" depends on the context.\n\nOk, so how do I get it to return the integer?</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l)\nIt also works in Python3. \n\nI think there is an obvious flaw with this solution (it's actually a flaw with the Python example, too).\nSuppose the list has length zero. Then the return value is also zero, and your program reports no maximum element.\n\nNice solution. Although I still think that  is simpler.\n\nI'd just use the index of the maximum element, if one exists.\nBut this is cool because it doesn't have to scan the entire list.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    max = 0\n    for el in l:\n       max = max + el\n    return max\nI think you're looking for sorted() here, not max_element().\n\nI'll agree with you on this one. I don't think it should be max_element(), since it is a method that takes in an iterable and returns the maximum value in the iterable. However, I do think it is a good idea to be able to tell if an element in a list is greater than another. The question is how best to do that.\n\nIf you're doing this for programming quizzes (like I was just doing), I find\nsorted() to be a better fit.\nIf you're doing this for general utility, I think the most common way is to use min() and max() from the itertools module.\n\nI meant sorted(). I was also doing this for a quiz.\n\nWhy don't you use the built-in sorted() function? It's not a bad idea to know how it works, even if you never actually use it.\n\nI think the author meant sorted() instead of max_element().</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    for i in range(l.size()):\n       if i >= l.size() - 1:\n           return i\n    return None", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l.has_key(\"max_element\"):\n    return max(l[0], l.keys())\nThank you for helping me with my homework, but I am actually writing a function that generates the list, and I am trying to avoid loops.\nWhy do you have a loop for the list?\nI am asking my teacher about this, so I'm going to ask him that as well.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l) - 1\nI've always hated this idiom. The reason is that the max element may not be in the list. Also, I don't really get how it saves anything in terms of code.\n\nI think there is a misunderstanding: the method returns the index of the last element in the list, not the maximum.\n\nI think you're right. I had misread that as:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return [l[0] for l in l if max(l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7], l[8], l[9])]\nYou might want to use an `if` branch instead of a `for` loop.\nThe `if` branch will also support negative indices, but the `for` loop will not.\nYou could also use a `while True` loop, but that's a bit more verbose.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return 1\n    if len(l) == 1:\n        return l[0]\n    return max(l, key=lambda x: x[0], reverse=True)\n\nIf you like this one, you might like the following one, too:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l) - 1\nwhat the fuck is wrong with this subreddit?</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    def top_element(l: list):\n    \"\"\"Return top element in the list.\n    >>> top_element([1, 2, 3, 4, 5, 6, 7, 8])\n    5\n    >>> top_element([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    7\n    \"\"\"\n    return max(top_element, l)", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return sorted(l.pop(0))\nI'm no Python expert but I'm not sure about this: wouldn't it be better to sort the list and then look for the first element?\nIt's called a quicksort, it is a perfectly valid algorithm.  And this version is just a little bit faster than the original version.\nI'm a noob. Could you explain why?\nThe quicksort algorithm is optimized for the case where you already have an ordered list of values, and you want to find the maximum element in that list.  The OP's version works perfectly well if you have no information about the order of the elements, but it is slower than the quicksort version.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l.is_empty():\n        return 0\n    if len(l) == 1:\n        return l[0]\n    if len(l) == 0:\n        return 0\n    return max(l, key=lambda k: k.startswith('-') or k.endswith('-') or k == 'E' for key in reversed(l.keys()))</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l:length == 1:\n       return l[0]\n    elif l:length == 2:\n       return l[1]\n    elif l:length == 3:\n       return l[2]\n    elif l:length == 4:\n       return l[3]\n    elif l:length == 5:\n       return l[4]\n    elif l:length == 6:\n       return l[5]\n    elif l:length == 7:\n       return l[6]\n    elif l:length == 8:\n       return l[7]\n    elif l:length == 9:\n       return l[8]\n    elif l:length == 10:\n       return l[9]\n    elif l:length == 11:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    for i in range(len(l)):\n        if (l[i] > l[len(l)-1]):\n            return l[i]\n    return 0\nThis is probably more readable:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) < 1:\n       return -1\n    return max(l)\n\nI think you can just use max without the underscore.\nmax([1, 2, 3], 3)</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l == []:\n        raise ValueError('max_element() called on empty list')\n    return l[0]\nWhat if l is a tuple?\n\nNice catch. I actually never noticed this. Thanks!\n\n(If you are looking for an excuse to improve the readability of your code, you can also get rid of the \"l\" argument and make it a function taking any iterable)\n\nWhat if the iterable is not an object? Or a list?", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    l.sort()\n    for i, e in enumerate(l):\n       if i < e:\n          e = i\n       return e\nThis is the most logical solution in my opinion.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    maximum = 0\n    while l.count(i)!= 0:\n        i = l.pop(0)\n        if i > maximum:\n            maximum = i\n    return maximum\nI like it.  I like it a lot.  I want to marry it.  I want to have its children.\nI think I might have to steal this.\nI already did.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l is None:\n       return None\n    l.extend(0)\n    return max(l[:])\n> What's the point of this? Why not just call the built-in max function?\npython 2.7\n>>> max(1, 2, 3)\n3\n>>> max(1, 2, 3)\n3\n>>> from __future__ import print_function\n>>> max(1, 2, 3)\n3\nIt's not obvious that list.max is the same as calling max on the list.\n\nThis is silly. It's not clear that the behavior of the extension is as stated, and the behavior is _definitely_ not as described in the docs.\n\nThe whole concept of a'max' function on a list is strange. To me it seems like a perfect candidate for a builtin function.\n\nI actually like the idea of a max function. I think it's a good one, and would make sense as a built in.\n\nIt's not obvious that the behavior of the extension is as stated, and the behavior is definitely not as described in the docs.\n\nThe", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return len(l) - 1\nMakes the code slightly less readable, though.\nTrue, but I would have to agree with the other reply here. Sometimes it's nice to be able to come back later and remember what that function does without having to go back and read through a bunch of lines of code.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)\nThat's a solution, but it doesn't handle removing elements from the list.\nI was thinking this would work:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return l.pop()\n    return l[-1]\nI'm not a Python programmer, but I imagine it's possible to make this more efficient, no?\n\nI'm not a Python programmer, but I imagine that the first case is more efficient than the second case because there's no need to check whether the list is empty.\n\nYou're right. The first case has been optimized:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    l.extend([0],max(l.pop()))\n    return l.pop()\nI'm on mobile right now, but you can probably do it with np.max() instead of max_element().\n\nAnd if you need it to be O(1) on the input you can use min_element.\n\nI know that max_element is O(n). But what does O(n) mean?\n\nO(n) means \"order(n)\". Roughly speaking, it describes the amount of time or space that is required by a function to run through a list of n items.\n\nNot quite. Order(n) means the amount of time required to _find_ the maximum value if you don't already know the maximum value.\n\nYou are right. I was thinking about the amount of time it takes to test all the items in a list.\n\nI believe the correct answer is:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return list( sorted(l.items(), key=lambda x: x[1], reverse=True)\n    if len(l) else l[0])</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return min(l, key=lambda x: x[0]), key=(key(l) for l in l)\nThis is the same as `max(lambda l: l[0])`. Also, you might want to consider using a max() method that returns a tuple with the maximum element and its index.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return l[0]\n    else:\n        return max(l[1:])\nI feel this is a bit more idiomatic in Python, but I can't say I've ever actually written this.  Why is this more idiomatic than just using list.max?   I don't think I've ever had a situation where I wanted a max on a list and didn't already have it in a list.\nIn Python, you can't specify a sequence as a function argument, so this allows you to pass a list to a function which then returns the maximum element.\nYou can use a list comprehension instead:      max_element = max(list(x) for x in range(len(list)))\nThat's a good one, thanks!</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    def max_element_by_element(self, el):\n        return el\n    return max_element_by_element(self)\nWhat does this function do? The problem is that you've given no clue to the reader. The name \"max_element\" makes it sound like it'll return the maximum element in the list, but the function doesn't do that.\nThe function is really:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) > 0:\n        return max(l[0])\n    else:\n        return len(l)\nWhat if `l` is infinite?\n\nI was thinking about this too. What I would do is use the lambda trick.", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    list_to_int(l.pop(0))\n\nThis version is extremely inefficient. I'd advise you use `list_to_int(l.pop(0).index(0))`.\n\nThanks!\n\nI was hoping for this when I read the title.\n\nThis is what I was hoping for as well!</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    return max(l)\nI'm not saying it's bad that it uses list. I'm just saying it's not exactly rocket science.\nI think it's more of an example of how Python's standard library is really nice.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) < 1:\n       return None\n    if l[0] < l[1]:\n       return None\n    if l[0] == l[1]:\n       return l[0]\n    if l[0] == l[2]:\n       return l[1]\n    return max(l[1:])", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    for i in l:\n       max = None\n       for j in range(0, l.size):\n          if l[i][j] > max:\n             max = l[i][j]\n    return max\n\nThis is very clever.\n\nThat's the first time I've heard that. Thank you.\n\nI feel it's too clever. I know the author has put a lot of work in it, but for a novice programmer it's not obvious why max_element returns different results for a list of integers and a list of floating points.\nIt would be better if it always returned the maximum element, and then explained why it works.\n\nI disagree. If you want to know why max_element returns different results for a list of integers and a list of floating points, you're better off looking at the documentation.\nIn my opinion, the only way to learn how to program is to copy examples from the documentation and modify them to fit your needs. For example, here's a list of all the functions that return lists", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if len(l) > 1:\n        return max(l[0])\n    return min(l.__getitem__(0))\nI am not sure if this is the way you want to do it, but it works.\nI was also thinking about using min instead of max, but that would allow the user to actually have negative numbers.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l is not None:\n        return l[0]\n    else:\n        return max(l)\nThat's not how you use else in python.  Should be something like:       def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if not l:\n        return max(l)\n\nWhat is a list of lists?\n\nIt's a list, of course. It has a different meaning in Python, though. You can think of a list as an array, but instead of being fixed in size, it can grow or shrink at any point.\nYou can have a list of lists, and that's a list of arrays, and that's a list of lists of arrays, and so", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    def max(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max([1, 2, 3])\n    3\n    >>> max([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    if len(l) == 1:\n       return l[0]\n    if len(l) == 2:\n       return l[1]\n    if len(l) == 3:\n       return l[0] + l[1]\n    return max(l)\nmax_element(l: list, elem: float) = max(l, elem)\n\nThe order of max()'s invocation is undefined. This may or may not be of interest to you.\n\nYou could solve the problem you're trying to solve with \"in\" and \"not in\", which are in the standard library.\n\nSo is max.</s>", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l is None:\n       return 0\n    else:\n       return max(l)\nI'm not sure what the point of this was.  I know that it's fun to write, but it's not really anything more than just the standard `max()` implementation.  Maybe I'm missing something.\n\nI don't really like the way that you're reading it. I don't think this is meant as an example of a good, optimized algorithm, I think it's just meant as a fun toy.\n\nYou're probably right.  That said, I think it could have been written much more fun.  Maybe something like this:\nreturn list(l).index(l) + 1\n\n_maybe_ something like that\nreturn list(l).index(l) + 1\n\nI am not a Python expert, but I suspect that this will not work:", "def max_element(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> max_element([1, 2, 3])\n    3\n    >>> max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\" \"\"\"\n    if l: len(l) > 0:\n        return max(l)\n    return -1\n    if __name__ == \"__main__\":\n        print(max_element([1, 2, 3]))\n        print(max_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n        print(max_element([-1, -2, -3, -4, 4, 5, 6, 7, -7, -8, -9, -10]))\n\nIf you have not used Python list comprehensions before, they are quite useful in practice. The example above is equivalent to:\nmax_element = [max(l) for l in range(1,10) if l > 0]"]]