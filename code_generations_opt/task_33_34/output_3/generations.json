[["def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    for i in range(0,2,3):\n       l'[i] = l[i]\n    return l'\n>>>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    for i in range(1, len(l)):\n        if l[i] % 3 == 0:\n             swap(l[i], l[i + 1])\n              return l\n\nWhat about negative divisors of 3?\n\nFixed!\n\nAnother problem with this is that the integers mod 3 are exactly the first six numbers: 0, 1, 2, 3, 6, 10. So what's the point of sorting them?\n\nThat's not a problem, that's a benefit. The list would be sorted the same way even without this function.\n\nI like the point of the article. I'm not sure this solution is ideal, though:\n>>> sort_third([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18])\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    a = 0\n    for l in range(len(l)):\n        if a is not None:\n            a = a * 3 + l[a]\n            if a is not None and a is not 0:\n                return list(a)\n        else:\n                return l", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l.sort(), key=lambda x: x % 3)\nThere is no need to translate into C++ for the sake of the exercise.</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    # Only do this if the number of divisors is not equal to two\n    if l.count('divisors') == 2:\n       raise ValueError('cannot sort a list of length '+l.count('divisors')+' with divisors divisible by two')\n    # Grab the list of divisors of the list\n    l.iteritems().sort(function(item):\n       return item[0].divmod(l[0]) == l[0].divmod(item[0])\n    )\n    # Grab the list of divisors of the list, the first time around\n    l.iteritems().sort(function(item):\n       return item[0].divmod(l[0]) == l[0].divmod(item[0])\n    )\n    # Let's be clear about this\n    l.iteritems().sort(function(item):\n       return item[0].divmod(l[0", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    l = l.sort()\n    if l.count(1) == 0:\n       return list(l)\n    else:\n       return sorted(l[::-1], key=lambda l[-1]:l[-1])\n\nimport collections", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return [l[i] if i % 3 == 0 else l[i + 1] for i in xrange(len(l) - 1)]", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return l[l.indices[0] for l in l.values() if l.indices[0] not in [0, 1, 2, 3]", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return l.sort()\n\nSome might question the usefulness of this, but for me this is exactly what I've been looking for.\nIt's definitely useful if you're writing an interpreter for a language that doesn't have a built-in way to create lists.\n\nI'm having a really hard time seeing how this is useful.\n\nAs a concrete example: I was recently writing a dynamic programming language, and I needed a function that would create lists (well, dicts) of numbers. Of course, I could have used list(). But that doesn't exactly feel \"natural\" to me. Instead I wrote this function (and a number of others like it), and I feel like it's very natural to call things like\nnumbers = [int(3) for i in range(10)]\nor\nnumbers = [int(5) for i in range(5)]\nOr to use one of the other functions, like\nhead_list = numbers.head\ntail_list = numbers.tail\nI'm not sure if that's what the OP had in mind, but it's the first thing I thought of.\n\nThat's pretty much the use case I had in mind. I", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda a, b: a % 3 == 0)\n\nIf you want to sort by any other divisor, you can modify the code to accept that:</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    #'sort_third' is defined in the module 'practical_recursion'\n\n    def divide_first(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are divisible by one, while its values at the indicies that are not divisible by one are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> divide_first([1, 2, 3])\n    [1, 2, 3]\n    >>> divide_first([5, 6, 3, 4, 8, 9, 2])\n    [8, 9, 5, 6, 3, 4, 2]\n    \"\"\"\n    # 'divide_first' is defined in the module 'practical_recursion'\n\n    def divide_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x%3 == 0)\n\n_\n\n-", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if __name__ == '__main__':\n    def h(n):\n       if n % 3 == 0:\n          return 0\n       if n % 4 == 0:\n           return 0\n       if n % 7 == 0:\n           return 0\n       return (n % 3) * (n % 4) * (n % 7)\n    # We use the integer division\n    def divide(l, m):\n       return (l / m)\n    # We use the integer division\n    def sort(l: list, key: int):\n       for i in range(len(l)):\n           for j in range(len(l)):\n                 if l[i] < l[j] and key > 0", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if len(l) == 3:\n       return l\n    else:\n       return [l[3:] for l in l if l[0] % 3 == 0]\n\nI have seen this a few times in code and I have always found it extremely irritating. It is the most horrible form of code kluges that I have ever seen. The code above is one of the first examples that I have ever seen of code that sort of does what it says it does, but the problem is that it requires us to sort a list into a new list before we can sort it into the right order.\n\nThere is no reason why we should have to sort the list into a list. When we were building lists in python, we were taught that lists should be immutable. This means that it is impossible to modify a list after it has been constructed. This has come in handy many times. In fact it is what makes python great. When we have a list, it is guaranteed that we can go through the list and create a new list from it that is the same as the original list.\n\nThere is a much better way to do this.", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x % 3)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if len(l) > 2:\n        return [l[i] for i in range(0, len(l), 2)]\n    else:\n        return [l[i] for i in range(0, len(l), 3)]\n    return sorted(l[::2], key=lambda x: x, reverse=True)</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda l,k: (k-1)**(l%3))", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    l = sorted(l)\n    for i, j in enumerate(range(len(l))::int):\n        if l[i] % 3 == 0:\n             l[i] = l[i] + 1\n             j += 1\n    else:\n             l[i] = l[i] - 1\n             j -= 1\n    return l\nI believe the language is python, as the rest of the code is python.  This function is in a different language (Haskell).</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return l.filter(lambdax: x % 3 == 0).sort()", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n\nHere is some pseudo-python to translate it into pseudo-python.", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n          return list(l, sorted(l, lambda x, y: (x % 3 == 0)? 0 : 1))\nThis is far too naive. It doesn't handle strings (for which it gives the wrong answer), and it doesn't handle lists of objects (which you can't convert to integers).\n\nYou're right, this is far too naive. And it's fast because it's far too naive.\nI think the best way to handle strings is to use the string.find method. This method has the same performance profile as the internal list.find method, which is to say O(n) time for the first n characters.\nThe list.find method is there to be optimized if the programmer can tell that it doesn't need to be linear, which is the case when the list is empty or the string is a number.\n\nI am still not convinced. It is O(n) because it checks each element, but it could be made faster with a hash table.\n\nThe problem with using a hash table is that you have to create it, which takes time, and it has to be a power of 2, which is going to be a problem on", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n\n    return l[::-1].sort()\n   .sorted(key=lambda s: s % 3 == 0)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if l == []:\n       return []\n    if len(l) == 3:\n       return l\n    if len(l) % 3 == 0:\n       return l\n    if l[0] % 3 == 0:\n       return l[1]\n    if l[1] % 3 == 0:\n       return l[2]\n    if l[2] % 3 == 0:\n       return l[3]\n    return sorted(l)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    sort_third = lambda l: l + [1 for i in range(l) if i % 3 == 0]\n    return sort_third(l)\n\nThis is very different from how I would have done it, and for reasons I cannot fathom.\n(defun sort_third(l)\n    (list (sort l (- 3 (length l))))\n    (list (sort l (lambda (x) (- x 3))))\n    (list (sort l (lambda (x) (/ x 3))))\n    (list (sort l (lambda (x) (/ x 3))))\n)\nThe author's approach is a lot more verbose than mine (and by a lot, I mean four times more), and it isn't any more readable.\n\nI thought the same. I would write a recursive function, e.g.", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if l.count(1) > 1:\n        return l.sort()\n    return l.sort_values(key=lambda x,y: x % 3 == 0)\n\nThis is a non-trivial sort: it has O(n) runtime and O(nlog(n)) space, where n is the length of the list.</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    from collections import defaultdict\n    def _nth_third(l: list, n: int):\n    \"\"\"This function returns the item in the list l that comes after the item that is equal to nth_third(l, n-1) in the list l.\n    >>> sort_third(range(5), 3)\n    [5, 4, 3, 2, 1]\n    >>> _nth_third(sort_third(range(5), 3), 3)\n    [4]\n    \"\"\"\n    return defaultdict(int)\n    def _nth_third_reversed(l: list, n: int):\n    \"\"\"This function takes a list l and returns the item in l that comes before the item that is equal to nth_third(l, n-1) in the list l.\n    >>> sort_third(range(5), 3)\n    [5, 4, 3, 2, 1]\n    >>> _nth_third_reversed(sort_third(", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l.index(0), l.index(1),... l.index(3))\n\nI was expecting a list of the first four values.\n\nThat is what it returns.\n\nThat's what I get.\n1 2 3 5 6\n\nThe returned list is:\n5 6 3 4 8 9 2\n\nI know it's already been answered, but I thought I'd add a little visual explanation to go with it.\n\nIf you see a list as a set of key-value pairs, this function sorts the keys. Then it removes duplicates, making each key unique. Then it sorts the values.\n\nThis is the way I've always thought of it. The operation is clear when you think of it this way.\n\nThis is one of the reason that Python is so great.\nSimple and intuitive syntax.\n\nIt's also one of the reasons Python is so slow and inefficient. This function could be expressed so much more simply in a non- dynamic language.\n\nSo you would rather write something like:", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if not len(l) or len(l)==3:\n       return l\n    else:\n       return [l[1]+l[2]+l[3] for l in l]", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return (1 / 3) * list(range(list(l)))[::-1]", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l[::-1] if l[i] % 3 == 0 else l[i])\n\nWouldn't it be more robust to use a \"while True:\" loop instead of a \"if l[i] % 3 == 0:\" loop?\n\nIt would, yes. I just didn't think of it.\n\nI'm not sure I understand, why is this a bad idea?\n\nThere is a bug in the sorting code, specifically it doesn't handle the case where the first element is 3. In this case it will pass the first two elements to the inner function which will sort them, but the rest of the list will not be sorted.\nThis is because the definition of sorted says to use the function sorted() to sort the list, and in sorted() the second argument is the first element of the list.\n\nI think it's more of a bug in the function you use to sort the list. It should call sorted() on each of its arguments.\n\nIt's not a bug in that function, it's the one the OP posted that is wrong. The function should have been", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: not(x % 3))\nSo the core of the algorithm is to sort the list and then remove the duplicates, and then finally sort the resulting set.\nSo it's not a sorting algorithm at all, it's a split-and-combine algorithm.\n\nIf you use the Sorting Intros for Python book you can see that's about how much the standard library sort() function does as well.\n\nMost sorting algorithms are split and combine algorithms. They just use some kind of heuristic to do the splitting and combining.\n\nIt seems like this would be quite inefficient.\n\nThe wikipedia article suggests that it is pretty efficient:\n\nI'd be interested to see how it would perform on a real data set (not sorted).\n\nI've been using it on a few real data sets, and it performs very well. I've found that sorting the input data first, then using sort_third() to remove duplicates, and then sorting again to remove non-thirds, will usually give you a very fast sort.</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return [l[i] for i in xrange(3)]\n\nThere's probably something better, but here's my first shot:", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if len(l) == 3:\n        return l\n    else:\n        return sorted(l, key=lambda i: i%3 == 0, reverse=False)\n    def count_even(l):\n    \"\"\"This function takes a list l and returns the number of elements of l that are equal to zero.\n    >>> count_even([1, 2, 3])\n    4\n    >>> count_even([1, 0, 0, 0, 0, 0, 0])\n    1\n    \"\"\"\n    return len(l) == 0\n    def sort_odd(l):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by two, while its values at the indicies that are divisible by two are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_odd([1, 2, 3])", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return [l[indx] if (indx % 3 == 0) else l[indx] + 3 for indx in range(0, len(l))]", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if l.indices[0] == 0:\n       return [l[0], l[1], l[2]]\n    else:\n       return [l[0], l[1], l[2], l[3], l[4], l[5], l[6], l[7], l[8], l[9], l[10]]\n\nThis is a neat solution for the problem, but it's very O(n^2) in the worst case. I'm curious to see how you would implement it using itertools.\nIn general, the easiest solution for the problem is", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return l: sorted(l, key=lambda x: int(x%3))", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    i = 0\n    while l!= [] and (i%3 == 0) and (i mod 3 == 0):\n        l.extend([i+1])\n        l = l[:i]\n        i += 2\n    return l", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return l.sort()\n    if l.any(int(n) for n in range(len(l) - 2, 3)) == 1:\n       return [l[0], l[2], l[4] for l in l]\nI can't see how this will work...\n\nThe function just returns the result of sorting, then removes any element whose index is divisible by three. For example, for an input list of [1,2,3], it returns [2,3] then removes [1].\n\nThe author has a typo: it should be \"input list of size 3\"</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l) - sorted(l, key=lambda x: x % 3 == 0)\n\nThat's a really cool function!\n\nThanks. I found the C version here:</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n\n    print l\n    print l.sort()\n    print \"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return l.sort()\n\nThe article talks about how this function is the \"least worst\" of all the sorting algorithms on the list. However, in Python 2.x, there is a builtin function called _sort_. It is, by definition, a stable sort.\n\nA stable sort is a sort that preserves the order of elements that are equal.", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    sorted = [l[:i] for i in xrange(2)]\n    return sorted[3:]\n    \"\"\"\n    sort_third()", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    for item in range(2, l.indices[0]):\n        if item % 3 == 0:\n            item = sorted(l.indices[item], key=lambda l: l.indices[item % 3])\n    return l.indices[item]", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    l = [0]\n    l' = list(l.pop(), reversed(l.pop()))\n    for i in range(1, len(l)):\n        i = int(i/3)\n        if i mod 3 == 0:\n             l'[i] = l[i]\n            l'[i+1] = l[i+1]\n    return l'\n\nThe thing that gets me about these, is that I can't really tell what is being tested. It's a little different than a normal assert statement, because it doesn't necessarily get a value out. But I can't tell what it's doing.\n\nIt's meant as a design checker, not as a testing tool. It's for making sure that your code is doing what you want, and making sure your design is sound.\nIf you want to test that your code is doing what you think it is, you're better off using a debugger or unit tests (at least, in", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n\n    # Assuming that all the indices are positive\n    for i in range(len(l)):\n         l' = l[i]\n         if i == 0 or i == 3:\n               if ( i % 3 == 0 ):", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    from operator import itemgetter\n    from operator import itemsetter\n    from operator import itemset\n    from operator import itemget\n    from operator import iteminsert\n    import operator\n    def mnemonic(l: list):\n    \"\"\"This function creates a new function that operates on lists and that is easy to remember.\n    >>> mnemonic([1, 2, 3, 4, 5])\n    l = list(range(3))\n    >>> sort_third(l)\n    [1, 2, 3, 4, 5]\n    >>> l\n    [1, 2, 3, 4, 5]\n    >>> mnemonic(sort_third)\n    >>> l = [1, 2, 3, 4, 5]\n    >>> sort_third(l)\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    return lambda l: lambda x: lambda y: lambda z: lambda a, b: a * b + x *", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n        return l\n    else:\n        return sorted(l, key=lambdax: x % 3)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return [l[0:1] for l in l if l[1] mod 3 == 0]\n\nThis isn't a bad solution, but it seems like it would be a bit slow. I'm assuming that you want to check all the indices for divisibility by three. If so, this is O(n^2) and requires a linear amount of time for every element you sort.\nYou could make it O(n) and have it run in time proportional to the length of the list. This means that the time it takes to sort a list of length 2 is the same as the time it takes to sort a list of length 1000000. This also means that it will be significantly slower than the original solution.\n\nIt is O(n) if you just want to count the number of indices mod 3, and sort them last.\n\nIf you have some unevaluated dependencies, there is no need to do it in a loop. The most obvious example would be the case of a recursive call, like f(g(x)) = g(f(g(x))). The dependency graph should be traversed to find the minimum-cost path, i.e. an in-", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l[::-1], key=lambda l, i: i % 3 == 0)\nThis looks like it would have horrible performance on all but the most trivial of inputs. Why not use a trie, which would be much faster for large inputs?\n\nIt is not the most optimized code, but it works very well for small lists (lists with less than 200 elements). And it is faster than many of the Trie implementations I have seen in Python.\nBut yes, for large lists, Trie is much better.\n\nWhy doesn't it work for larger lists?\n\nSee my comment above.\n\nActually, I thought it would be much better for large lists, because it is faster than any other Trie implementation I have seen in Python.\nI am not saying it is the fastest, but it does work very well for small lists (lists with less than 200 elements).\nAnd it is faster than many of the Trie implementations I have seen in Python.\n\nIt's not that it doesn't work, it's that it's very slow compared to using a Trie (which are really, really, really fast).\n\nI think the code is fine for small lists", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    def __init__(self, l: list):\n    \"\"\"The value of the list l is the result of the call of this function.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([1, 2, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    >>> sort_third([1, 2, 3, 4, 8, 9, 2])\n    [2, 4, 6, 8, 9, 2, 3]\n    \"\"\"\n    l = []\n    for i in range(len(l)):\n        self.l[i] = l[i]\n    return l", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    ind_list = []\n    for i in range(len(l):):\n         if i % 3 == 0:\n              ind_list.append(i)\n    return [ind_list]\n    #defn sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    return [ind_list]\n\nExample 2", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    from collections import OrderedDict\n    results = OrderedDict([1, 2, 3, 5, 6, 3, 4, 8, 9])\n    l1 = []\n    for i in range(3):\n         l1.append(i)\n         for i in range(3):\n              if l1.has_key(i):\n                  results[i] = i\n                l1.remove(i)\n                l1.append(i)\n    return l1", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    values_in_order = [None, 1, None, None, 3, 4, 8, 9, 5]\n    values_in_order[2] = l[2]\n    values_in_order[3] = l[3]\n    values_in_order[4] = l[4]\n    values_in_order[8] = l[8]\n    values_in_order[9] = l[9]\n    sorted_values = sorted([None, None, None, 3, 4, 8, 9, 5])\n    values_in_order.append(sorted_values)\n    return values_in_order", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if len(l) == 2:\n        return [l[1:i-1], l[i-1:2]]\n    else:\n        return [l[0:i-1], sorted(l[i-1:])]\n    def sort_third_numerically(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted numerically.\n    >>> sort_third_numerically([1, 2, 3, 4, 5, 6, 7, 8, 9, 2, 3, 4, 5, 6, 7, 8, 9, 2, 3, 4, 5, 6, 7, 8, 9])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 2, 3, 4", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l.split() for l in l if l[0] <= 3 else l.drop(3), key=lambda x: x[0])\n\nThis is a beautiful example of Python being a nice, concise language.\nIn general, I think this is a good argument for Python, and not Perl.\n\nThis is actually quite straightforward in Perl, too. Here's one way to do it:\nsub sort_third {\nmy $list = shift;\nmy @r = split //, $list;\nreturn @r[1..$#r-2];\n}\n\nThe one advantage of Python here is that the implementation is pretty obvious to anyone who has written any Python. The one advantage of Perl is that you don't have to write any Python.\n\nIt's so weird to see Perl being used as a benchmark for readability.\n\nIt's not a benchmark for readability, it's a benchmark for expressiveness. The Perl is more expressive than the Python, but it's also more readable.\n\nI meant that the fact that Perl is being used at all is weird, since I've never heard of it being used in this way. It's also", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    values = [l[i]]\n    i = 0\n    while i <= len(l) - 3 and values[i] not in values:\n        i += 2\n    values = [values[i] - values[i-1], values[i-1]]\n    l' = [l[(i + 1) % 3] for i in range(len(l) - 3)]", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if len(l) > 2:\n        return sorted(l[0], key=lambda a, b: a[1] - b[1], reverse=True)\n    else:\n        return sorted(l[0], key=lambda a, b: a[0] - b[0], reverse=True)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    def sort_third_ex(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third_ex([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third_ex([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    def inner_sort(l: list):\n    \"\"\"This function takes a list l and sorts its elements. The result is a new list l' that is identical to l, but sorted.\n    >>> inner_sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n    [1, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13]\n    >>> inner_sort([7, 4, 3, 2, 1, 6, 5, 4, 3, 7, 8, 9, 6, 2])\n    [1, 6, 2, 7, 8, 9, 10, 11, 12, 13]\n    \"\"\"\n    def outer_sort(l: list):\n    \"\"\"This function takes a list l and returns a new list l' such that l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l,", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if l:is_sorted():\n        return list(l.index(list())-1:l.index(list()))\n    else:\n        return list(l.index(list()):[])\n    for ind in range(len(l)):\n        if l[ind] % 3 == 0:\n             l[ind] = l[ind] // 2\n             l[ind] = list(l[ind] % 3 + 1, l[ind] % 2, l[ind] % 1)\n             return l\n\nIf we had a concrete example of how to use this, it would be helpful.\nFor example, is this a standard algorithm? Is this algorithm better than BubbleSort?\n\nIt's the bubble sort algorithm, except it merges sorted sublists.\nIt's not faster than bubble sort, but it's more general.\n\nIt is more general than bubble", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    \"\"\"\n    # Generic sort algorithm\n    def sort_by_indices(indices, list):\n    \"\"\"This function takes a list l and an integer i and returns a list such that l' is equal to l for indices divisible by i, while its values at the indices that are not divisible by i are equal\n    to the values of the corresponding indices of l, but sorted.\n    >>> sort_by_indices([1, 1, 1], 3)\n    [1, 2, 3, 4, 5, 6]\n    >>> sort_by_indices([1, 3, 1, 5, 7], 3)\n    [1, 2, 3, 5, 7, 8]\n    \"\"\"\n    for i in range(len(indices)-2):\n        for a, b in enumerate(indices):\n            if indices[i, a]!= 0 or indices[i, b] == 0:", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambdax: int(x%3))\n\nThis is a nice example of how to use a slicing function. Slicing functions are very common in functional languages. They are basically a way of saying \"given this list, remove a part of it and return a new list which has that part\".\n(In Python, this is done with the slice() function, in Ruby with the range() function, and so on).\n\nA similar function that returns all numbers divisible by 3 and the rest as is:", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    def sort_third(l):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    if l[1] == 1:\n        return []\n    return [l[0] * 3 for l in l if l[2] mod 3 = 0]\n\nI'll say it again:\n\nIt's very bad to use a sort of any kind as a default.\nIf you want to sort something, use a sorted list.</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    index = 0\n    for i in range(len(l) - 2):\n       if i % 3 == 0:\n           index += 1\n    else:\n            index = index + 1\n    return l.copy()\n\nSort_third(list)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    index = 0\n    while index < len(l):\n        if n % 3 == 0:\n             index += 1\n    else:\n              index -= 1\n\n    return list(set(index, l[index]))\nMore importantly, if you're using Python 2, this:         return list(set(index, l[index]))  Will return the sorted list as a dictionary.\nIf you're using Python 3, it will return a list.  Also, the above is an optimized version.  The standard version will iterate through the list, sort it, and then iterate through the sorted list again.  The original version will return a list, but not the same list as the original, since the original version will add the element at index 0 to the list at every iteration, while the optimized version will not.\nI think the biggest difference is the time it takes to iterate through a list twice.  I would assume that on average, it would take about the same amount", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x % 3 == 0)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return [l[i] if i % 3 == 0 else l[i] for i in xrange(3)]", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    for n in range(0, 3):\n         l = [n]\n         l' = []\n         for j in range(0, n):\n            if j is divisible by 3:", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n\n    return sort_first(l)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if len(l) == 3:\n       return l\n    return [l[0] + l[1] + l[2], l[1] + l[2] + l[3] + l[0] for l in sorted(l)]\n    # http://stackoverflow.com/questions/1407741/sorting-a-list-by-multiplying-its-indices-by-three", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n\n    return l.sort()\n\nI'm not a python expert, but couldn't this be solved with a dictionary,\nwhich would be much more readable?\n\nI agree, but I'm not a Python expert, either.\n>>> d = {}\n>>> d['1']['2']['3'] = sort_third([1, 2, 3])\n>>> d['1']['2']['3']\n[1, 2, 3]\n>>> d['5']['6']['3']['4']['8']['9']['2']['5']['6']['3']['4']['8']['9']['2']\n[2, 6, 3, 4, 8, 9, 5, 6, 3, 4, 8, 9, 2]\n\nAh, great. It appears that the re-ordering is done before the dict is returned.\n\nIn my opinion, this is a prime example of why you shouldn't use a list when a dict would suffice.\n\nCan someone explain why this is interesting or useful?\n\nI think that the advantage is that", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    # Extract the divisors of three\n    divisors = [3, 6, 9]\n    # Extract the rest of the indices, and remove the divisors\n    l_non_div = [0, 4, 7, 10]\n    l_div = [5, 8, 11]\n    # Create a list l' with the first element equal to l, and the rest\n    # equal to l_non_div in the same order as l_non_div\n    l' = [l[0], l_non_div[0:4], l_non_div[4:7], l_non_div[7:10]]\n    # Sort the list l'\n    l' = [l'[0], l'[1], l'[2], l'[3]]\n    # Take the indices of the divisors of three (dividing by three)\n    for i in range(0, len(l'[2])) - 1:\n        divis", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return list(l[::-1])[::3]\n\nThis could be done in half the characters and more clear.\n\nI don't disagree, but you're not being constructive.</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    def           sort_third(l: list):\n                return [l[i] for i in range(0,3) if l[i] % 3 == 0 else l[i]]\n\nThis is a trivial solution, but one that is still useful.  For example, if you are given the list of integers {1, 2, 3, 5, 6, 8, 9}, the  solution will return the list {1, 5, 3, 8, 9} which is the sorted version of the original list, but with the numbers 1, 5, and 9 sorted as they should be, and 3, 6, and 8 swapped.\nThis solution relies on the fact that the indices that are not divisible by three are the only ones that matter, since the remainder is always zero, which will cause the values to be sorted correctly in all cases.  This solution is very simple and is not the fastest, but it is easily extensible to deal with larger lists of integers.", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return l.sort()", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    \"\"\"\n    def func(x: int):\n    \"\"\"This function takes an int x and returns a sorted list of x.\n    >>> sort_third(func(3))\n    [3, 5, 2, 6, 1, 4]\n    >>> sort_third(func(5))\n    [5, 2, 3, 1, 6, 3]\n    \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    def itertools.imap(f, x):\n        return [x[0] * f for x in f(x)]\n   \n    for _ in range(len(l)):\n        l = l[::-1]\n        for i in range(len(l[::-1]):):\n            if i % 3 == 0:", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    values = []\n    for i in xrange(1, length(l)):\n        values.append(l[i % 3] if i % 3 == 1 else l[i % 3])\n    return values</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return l.sort()\n    def __eq__(l1, l2):\n    \"\"\"This function takes two lists l1 and l2, and returns True if and only if they are equal, and False otherwise.\n    >>> [1, 2, 3] == [1, 2, 3]\n    True\n    >>> [1, 2, 3] == [1, 3, 2]\n    False\n    >>> [1, 2, 3] == [1, 2, 3]  #Should be True, but this is a bug in Python\n    TypeError: can't compare strings to integers\n    >>> sort_third([1, 2, 3], [1, 3, 2])\n    [1, 2, 3] == [1, 3, 2]\n    False\n    >>> sort_third([1, 2, 3], [1, 3, 2]) == [1, 2, 3]\n    True\n    >>> sort_third([1, 2, 3], [1, 3, 2])  #", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambdax:x%3, reverse=False)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    l2 = []\n    for i in range(len(l)):\n        if l[i] % 3 == 0:\n            l2.append(l[i])\n    return l2", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    sorted = sorted(l)\n    if sorted[0] < 1:\n        return [l[0] for l in sorted]\n    l = sorted[1:]\n    return sorted\n\nI would love to hear any comments/questions/suggestions!</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    result = []\n    for x in l:\n        result.append(x)\n    return result\nYes, this one is correct.</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return l.sort()\nSo this is a sorting function that only takes a list l and returns a list l' which is identical to l in the indices that are not divisible by three. I get that. But it seems like it doesn't do anything if the list is divisible by three.\nWhat am I missing?\n\nYes, this is the same as the naive solution in the article.\n\nI believe the link is broken...\n\nFixed. Sorry about that.</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l.values(), key=lambda k: k%3)\nNote that the type of the function is completely generic, as is the case in Haskell. This is a really good thing because it removes all the boilerplate.\n\nGood catch! I think this is a better example because it showcases a more typical situation: you have a list of numbers and you want to sort them.\n\nI wish Python had a proper type system, or at least a type hinting system. It would make this sort of thing a whole lot easier.\n\nThis is an example of why I think a type hinting system is a bad idea. It is too easy to get the wrong kind of help.\n\nIt could be done better than Python's current syntax, but I find it much easier to maintain code with type hints. Especially when you can do auto-completion against them.\n\nI'd like to know more about the details of the implementation. How does it handle overflow? I'd expect that it would use a stack, and I'd also expect that it would use recursive calls, but it doesn't seem to be the case from the code.\n\nHow could you implement something like this without recursion", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l = [l[:-3], l[3:-1], l[1:-1]]\n    if len(l) < 3:\n       return l\n    def sort_three(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    # first we loop over the first three indices\n    for i in range(2, 3):\n        if i % 3 == 0:\n            return [i, i + 1, i + 2]\n        else:\n            return [i, i - 1, i - 2]\n    # next we loop over the next three indices\n    for i in range(3, len(l) - 2):\n        if i % 3 == 0:\n             return [i, i + 1, i - 1]\n        else:\n             return [i, i - 1, i - 2]\n    # finally we loop over the last three indices\n    for i in range(len(l) - 3, -1):\n        if i % 3 == 0:", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return [l[x] for x in xrange(3)]\n\nI hope the OP meant to define his function as a Python function, and not a C function, in which case he would have to use Python's builtin sort() function (unless he doesn't like the result of sort() for some reason).\n\nThe OP meant to define a function that computes a permutation that sorts the elements of the list. I think you're right that he should have used Python's builtin sort function.\n\nAnother variant I use often is based on the idea that the list elements can be considered as a binary tree, and you wish to get a tree with the same leaves as the original one but sorted. This can be done with a well-known trick.", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n        return l\n    else:\n        return sort_third(l, key=lambda k: ((k % 3) & 1), reverse=True)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if len(l) > 1:\n       if l[0] < l[1] and l[0] < l[2]:\n           raise TypeError(\"sort_third() can be called only on a list of length 1\")\n    else:\n            return [l[0], l[1], l[2]]\n    if l[0] > l[1] and l[1] > l[2]:\n            raise TypeError(\"sort_third() can be called only on a list of length 1\")\n    else:\n            return [l[0], l[1], l[2], l[3]]\n    for i in range(len(l)):\n             return [l[i], l[i+1], l[i+2], l[i+3]]", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted([l[3:] for l in l if l[3] % 3 == 0] + [l[2:] for l in l if l[2] % 3 == 0] + [l[1:] for l in l if l[1] % 3 == 0])\n\nfor x in range(3, 10):\n    print sort_third(range(x))\n\n>>> print range(3, 10)\n[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39]\n>>> print sort_third(range(x))\n>>> print range(10)\n[1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31, 33, 35, 37, 39]</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    def replace(l: list):\n    \"\"\"This function takes a list l and a list r and returns a list\n    l' such that l' is identical to l except that each occurrence of an item r in r occurs only once in l',\n    and its value is equal to the value of the corresponding occurrence of r in l.\"\"\"\n    # the original list\n    r = [r]\n    for i in r:\n        r[i] = l[i]\n    return l'", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n        return l.sort()\nThis function is identical to sort(l, key=lambda i: i % 3)\nThe key function is equivalent to comparing the i'th item of the list to the key.  You would need to call the key function at least twice (one for each divisor) to ensure that the first and third items are in the correct positions.</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if l:\n        return l\n    else:\n        l = [l[2:] for l[2] in range(3)]\n        return sorted(l, key=lambda t:t[2]*3)</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    def _sort_indices(l, i):\n    \"\"\"This function takes a list l and an index i and returns an index j such that\n    l[i] < l[j] for all i < j and l[i] > l[j] for all i > j.\n    \"\"\"\n    for j in range(1, i+2):\n       l[j] = l[i]\n    return j", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n\n    return sorted(l, key=lambda x: x % 3 == 0)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n       if len(l) > 2:\n         return sort(l[:2], key=lambda x: x % 3, reverse=True)\n    else:\n          return sort(l, key=lambda x: x % 3, reverse=True)\n       return []\n\nthanks, I was not aware of these techniques\n\nThis is a bit off-topic, but what's the name of that site that creates a video of your code?</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return lambda l:", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(list(l))\n>>> print(sort_third([5, 6, 3, 4, 8, 9, 2], key=lambda x, y: x.index%3==y.index%3), reverse=False)\n['5', '6', '3', '4', '8', '9', '2']\nI know this is nothing new, but I've been looking for a way to do this\nin Python for a while and didn't find anything, so I thought I'd\nshare.\n--\nTollef Fog Heen\ntollef.fogheen@gmail.com</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l[0], key=lambda x: x % 3 == 0, reverse=False)\nSo this is the same function I posted on the forum. I thought it was in python, and it was not in ruby.  But I am asking about how to solve this problem in ruby not python.\nYou might also want to look at the posts of the original poster, they are much better.\nOops. Sorry.  I thought it was python, and didn't really read the question.  Have you tried asking on the python subreddit?\nno, I will try that. Thank you.</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return list(l, [indices[l % 3] for l in l if not indices[l % 3] in l ])", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    if len(l) == 2:\n       return [l[0], l[1]]\n    if numpy.isinf(numpy.ceil(numpy.pow(2, l.len()))) == 0:\n       return [l[0], l[1]]\n    # Checks for any indices that are divisible by 3", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    a = []\n    for i in range(3):\n       if a[i] % 3 == 0:\n           a.append(i)\n    return a\n\nA more straightforward solution:", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return [l[x for x in range(l.size)] for x in range(l.size)]\nI have no idea what this function is meant to do. It sounds like it should be sorting the input but it isn't.\nIt's making a list of the input, starting from the end, and creating a new list starting from the beginning, but swapping any index that is divisible by three.  It's not sorting, but it is sorting the values at the ends of the input.\nSo why does this function exist? It's pretty much useless\nI was trying to understand what the previous guy meant, and it makes sense to me that the function does what he thinks it does.  The problem is that he misunderstands what he's trying to do.  He needs to be sorting the indices, not the values.</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if l.is_list() and l.is_ sorted(True):\n        l = [l[0], l[1],..., l[l.length() - 1]]\n    return sorted(l, key=lambda x: x % 3 == 0)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n\n        if len(l) > 2:\n          return sorted(l[::-1], reverse=True)\n        if len(l) == 2:\n          return sorted(l[::-1], reverse=True)\n\n        if l[0] == 1:\n           return sorted(l[::-1], reverse=True)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n\n    n = len(l)\n    return sort(l, key=lambda a, b: a*b, reverse=True)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n\n    return l.sort()", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    result = []\n    for i in l:\n         if i % 3 == 0:\n              result.append(i)\n              i = i % 3\n    return result", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return list(l[0], l[0] + 3, l[2] + 4)\n    else:\n       return sorted(l[0:3], key=lambda x: x % 3, reverse=True)\n    >>> print(sort_third([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85,", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    def sort_third(l: list, key_type=int, key_value=None):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third(l.sort(), key_type=int, key_value=None)\n    [1, 2, 3]\n    >>> sort_third(l.sort(), key_type=int)\n    [1, 2, 3]\n    >>> sort_third(l.sort(), key_type=int, key_value=None)\n    [1, 2, 3]\n    \"\"\"\n    result = []\n    for ind in l:\n       if ind % 3 == 0:\n           if l[ind] is None:", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambdax: x % 3 == 0)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n\n    if n=len(l):\n        return l\n    if n>1:\n        return sorted(l, key=lambdax:x%3, reverse=True)\n\nI don't know how useful this is, but it's fun!\n\nIt's interesting that he's using a custom list type for this. It's easy to implement in Python using the `collections` module (http://docs.python.org/library/collections.html).\nI tried it with a list of Fibonacci numbers:\n>>> from collections import defaultdict\n>>> x = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233]\n>>> print defaultdict(lambda x: x[0], x)\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233]\n>>> print defaultdict(lambda x: x[0] - 1, x)\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n\n         if __name__ == '__main__':\n             print(sort_third([1, 2, 3])\n              )\n             print(sort_third([5, 6, 3, 4, 8, 9, 2])\n             )\n\nimport itertools", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l)\n\nYou should rename this to \"sorting by division\", or something along those lines. \"by thirds\" is ambiguous.</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    def __getitem__(self, x):\n    if x == 0:\n       return self[x]\n    return self[x] - 1\n    def __rjust__(self, x):\n    if x == 0:\n       return self[x]\n    return (self[x] + 1) % 3\n\nThis is a list-comprehension version of sort_third.", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted([l[0] * 2 for l in l] if l[1] % 3 == 0 else l)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l.sample(0, len(l) - 1), key=lambda x: x % 3)\n\nHere's another way to do this in Python, inspired by the fact that Python's `str.split()` doesn't split by _whitespace_ (but it does split by the other options):\n>>> import sys\n>>>\n>>> def sort_third(l):\n>>> \"\"\"This function takes a list l and returns a list l' such that\n>>> l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n>>> to the values of the corresponding indicies of l, but sorted.\n>>> >>> sort_third([1, 2, 3])\n>>> [1, 2, 3]\n>>> >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n>>> [2, 6, 3, 4, 8, 9, 5]\n>>> >>> sort_third(['1', '2', '3', '4', '5', '6', '7', '8', '9'])\n>>> [2,", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    def sort_third_by(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third_by([1, 2, 3, 4])\n    [2, 1, 3, 4]\n    >>> sort_third_by([3, 2, 4, 1])\n    [1, 2, 3]\n    \"\"\"\n    def sort_third_by_third(l: list, n: int):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    l2 = []\n    for i in l:\n       l2.append(i / 3)\n    return l2", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    s = l[::-1]\n    if s == 0:\n       return l\n    else:\n       for a in xrange(0, len(l)-1):\n           s = l[a]\n           if s == 0:\n               return s\n             else:\n                s = sort(l[s], key=lambda l: l[s])\n               if len(l[s]) < 1:\n                   return s\n                else:\n                  return s\n    return s</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    n = len(l)\n    for i in xrange(1, n):\n       for j in xrange(n, 1):\n           if j == 0 and l[i] > l[j]:", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if (l == []):\n        return l\n    if len(l)!= 3:\n        return []\n    for i in l:\n        for j in i*2:\n            if j % 3 == 0:\n                return i*3 + j\n          else:\n                return j*3 + i\n         l = [l[i*3:] + l[j*3:] for i in range(l.size) for j in range(l.size) if j % 3 == 0]", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return list(list(i for i in range(0,3)) for i in range(0,3))\n\nIsn't this just a different way of saying what's been said before? The list is being sorted by comparing the indices that are not divisible by three, while the values at the indices that are divisible by three are equal to the values of the corresponding indices of the list.\n\nI think it's not the same. The difference is that the original function is sorting by index, while the new one is sorting by value.\n\nI don't understand what you're saying. The two functions are the same with different variable names. The only difference I can see is that the new function is more verbose.\n\nThis is the same as the top post, except it uses __reduce__ instead of list.sort.\n\nIs there any reason you chose to name the function __reduce__ instead of __reduce_ex__?\n\nI think of it as \"drop the ex\".\n\nI'm pretty sure that means you're ignoring the ex.\n\nI was thinking of the fact that the \"x\" in \"__reduce__\" is really just a _", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return l.sort()\nBut you can't do this in a 'proper' language because it's slower.\nAnd you can't do this in a 'proper' language because it's harder.\nAnd you can't do this in a 'proper' language because it's actually not necessary.\nIf I want a function that does a similar thing, but doesn't involve sorting, I'd write it something like this:", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    k = 0\n    if len(l) < 3:\n       raise StopIteration\n    r = sorted(l)\n    if l[0] < l[1] and l[0] < l[2]:\n          k += 1\n    l = sorted(l[1:])\n    if l[0] < l[1] and l[0] < l[2]:\n          k += 1\n    r = sorted(l[1:])\n    if l[0] < l[1] and l[0] < l[2]:\n          k += 1\n    return r", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0] % 3 == 0]\nI'm not sure why this is sorting:\n>>> sort_third([1,2,3])\n[1, 2, 3]\n>>> sort_third([5, 6, 3, 4, 8, 9, 2])\n[2, 6, 3, 4, 8, 9, 5]\n\nYeah, I've been looking at it and I don't know what I'm doing wrong...", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return list(l).sort(function(a, b) a < b for a in l if a%3 == 0)\n\nAs a Python programmer, this does not appear to be a Pythonic solution.\nThat is, you're using language features that aren't part of the standard library.\nAs such, this is unportable code that will fail on any language other than Python.\nYou can just write it in Python:\nsorted_list = sorted(lambda x: x%3 == 0, list(x))\n\nIt's not necessarily the case that \"sorting\" is a built-in Pythonic feature. There are certainly a bunch of problems where it's easier to just write your own sorting function, even if it's not terribly efficient.\n\n_There are certainly a bunch of problems where it's easier to just write your own sorting function_\nYes, I've written a number of them.\nThey are not, however, Pythonic.\n\n_They are not, however, Pythonic._\nWell, neither are a lot of the language features that Python includes. The fact that you can define a __class__ method for a particular class, but not a __", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    for j in range(3, -1):\n        if l[j] % 3 == 0:\n            l[j] = l[j] * 3\n            else:\n              l[j] = l[j] / 3\n    return l'\n\nSee also\n\nLambda calculus\nFibonacci numbers\n\nReferences\n\nExternal links\nA C++ implementation of lambda calculus (clambda.c)\nA Python implementation of lambda calculus (lambda.py)</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if any([value(i) for i in l if value(i) % 3 == 0]) == 0:\n        return l[1:]\n    elif value(i) == 1 or value(i) == 2:\n        return l[2:]\n    else:\n        return l[3:]\n\nThe code can be found here: https://bitbucket.org/maxmtucker/python-benchmark-code/src/45d46e4626df8dfd7b98/sort_third.py\n\nI'm not a Python expert, so I'm not sure if this is what the author was trying to do (ie. sort a list by dividing the indices into 3 groups) but it seems to work.\n\nFor comparison, here's the Python solution that was posted to Reddit:", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return [l[x] for x in range(0,3)] + [l[x] for x in range(3)]\n\nI also just noticed that `sort_third` is the same as `reverse`.</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n         return list(l[0])\n    else:\n         # Merge all lists so far into one list\n         temp = []\n         for i in range(len(l)):\n             temp.append(l[i])\n             l = sort_third(l)\n          return list(merge(temp, l))", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    results = []\n    for i in range(3):\n        if i%3 == 0:\n            results.append(i)\n            results = sorted(results)\n    return results\n\nAs pointed out by others, this will not sort the list. It is equivalent to this (which does work):", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if l == [] or l[0] == 1:\n    return l\n    for i in range(len(l)-1):\n        if l[i] % 3 == 0:\n              return l[i]\n              else:\n                   return l[i+1]", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    for i in range(3):\n       l[i] = l[i] / 3\n       l[i+1] = l[i] / 3\n       l[i+2] = l[i] / 3\n    return l", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n\n    l = [3, 5, 7, 2]\n    return l.sort()\n\nI find it remarkable that this is (nearly) the same algorithm as is used to implement quicksort (though that is not the only sorting algorithm that uses it).\n\nIn quicksort, there is a guarantee that you won't be swapping the same element twice (i.e., you won't get the list back in the same order). Here, you might do that.\n\nThat's not what that means. It guarantees that the algorithm will terminate.\n\nIn the quicksort case, you don't get the list back in the same order, but it doesn't matter because the quicksort algorithm terminates. In the case of this algorithm, you might get the list back in the same order, so you might not be guaranteed that the algorithm terminates.\n\nRight, the algorithm is more complicated, but the algorithm guarantees termination.\n\nI'm not convinced the algorithm guarantees termination. I think it's pretty easy to get a counter-example that makes it not terminate.\n\nI'm not convinced the algorithm terminates. I think it's pretty easy to get an example that makes", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    result = []\n    for i, v in enumerate(l):\n        if v % 3 == 0:\n            if v > 3:\n                result.append(v)\n          else:\n                result.append(v)\n           else:\n                result.append(v)\n    return result\nYou can also do this with an integer division of the list's length.\n\nThere is a slightly more efficient algorithm for this. It's an algorithm that is typically used in Data Structures to sort.\n\\----\nIf l is a list of integers, and v is a list of integers, and v is sorted, and v[i] > v[i+1], then v[i] > v[i+1] is true.\n\\----\nSo you can just check if v", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    list_to_integer(l)\n    if list_length(l) > 2:\n        sorted(l, reverse=True)\n    else:\n        sorted(l, reverse=True)\n    list_to_integer(l)\n    return sorted(l, reverse=True)\n\nSo, my questions are:\n\n1) What is the purpose of the list_to_integer call? It seems to be unnecessary.\n\n2) Can this be done without using the list_to_integer call? If so, can anyone post a sample code?\n\nThanks in advance.\n\nZach\n\nOn Aug 8, 9:10 am, Zachary William <zwill...@gmail.com> wrote:\n> Hello All,\n>\n> I have a list of numbers and I want to sort them in order of\n> ascending values that are not divisible by three. So that means\n> that if I had a list that looked like this:\n>\n> [1, 3, 5, 7]\n>\n> I would want the", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    a = [0]\n    while a:\n        if a%3 == 0:\n            b = a\n             a = a[2:]\n          else:\n             a = a[1:]\n    return b", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    if l[0] == 1 and l[0] == 2 and l[1] == 1:\n        return [1, 2]\n    else:\n        return [5, 6, 3, 4, 8, 9, 2]", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return lambda x, y: [x[1], x[2], x[3] if x[1] <= x[3] and x[2] <= y[1]]\nWow, that's quite a nice solution.\n\nI am not sure why people are praising this solution so much. It does not even look like python. I would never write code like that.\nIt is quite clear that python already has a built-in function for this that does not look like a \"hack\". It is called \"sort\".\n>>> sorted([1, 2, 3], key=lambda x, y: x[1] < y[1])\n[1, 2, 3]\n\n_It is quite clear that python already has a built-in function for this that does not look like a \"hack\". It is called \"sort\"._\nIt's a hack in the sense that it's a one-liner, but it's not a hack in the sense that it's a bad solution. \"Sort\" is not a solution to this problem, because it's not guaranteed to be stable.\n\n\"Sort\" is not a solution to this problem, because it's not guaranteed to be stable", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n\n        return []\n       def sort_third_safe(l: list):\n         return sorted(l, key=lambda i: i % 3)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return l.sort(key=lambda x: x%3 == 0)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n\n    return l[::3]\n\nThe problem with this is that it is not clear that a for-loop should be used. This seems more like a list comprehension (or some other more functional style) to me.\n\nI agree that it's not immediately clear why a for-loop is used, but I suspect that the sort_third() function is part of a larger function, and the for-loop is simply a convenient way to keep the more important part of the function in a single place. I think that it's not a problem per se, since it's just a small piece of a bigger code.\n\nI'm curious what would happen if you made a list comprehension with the same exact logic and used that as the argument of sort_third()\n\nIt would also be nice to see a larger more complete example of what the for-loop is actually doing.\n\nI have a long list of numbers. Each number in the list is formatted as a string (e.g. \"2.23456789012345678\"). I want to find the number which is formatted as \"3.12\" and sort them alphabetically.\nI was thinking something like:\nfor e in numbers:", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return l.sort() if l.indices() == 0 else l.partition(lambda x: x % 3 == 0)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if l.count(1) == 3:\n        return l\n    else:\n        return l.sort()", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if len(l) == 2:\n       return l\n    else:\n       for i, value in enumerate(l):\n           if i % 3 == 0:", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    if l.count('*') == 0:\n        return l\n    else:\n        l = [x for x in l if x % 3 == 0]\n    if len(l) == 1:\n        return l\n    elif l.count('*') > 2:\n        return l\n    else:\n        l = l.sort()\n        return sorted(l.items(), key=lambda x: x % 3)\n\nThere are easier ways to do this, but I wrote this sort function for fun.</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n        if l[0] == 0:\n          return l\n       else:\n           return sort_third(l[1:], l[2:])\n\nThis is a good example of the useless code that often gets posted on HN.\nThe core concept here is that if you want to sort a list of numbers in ascending order, you can do so by sorting in ascending order those that are not divisible by three, and by sorting in descending order those that are divisible by three. In other words, the idea is to sort numbers such that they are unique.\nWhile it is a very basic concept, it is not clear what makes the following example particularly interesting:", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda a,b: (a%3==0 and b%3==0), reverse=True)", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n\n    def __init__(self):\n        self.head = []\n        self.tail = []\n        self.second = []\n        self.n = 3\n\n    def sort_third(l: list):\n        \"\"\"This function takes a list l and returns a list l' such that\n        l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n        to the values of the corresponding indicies of l, but sorted.\n        >>> sort_third([1, 2, 3])\n           [1, 2, 3]\n           >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n           [2, 6, 3, 4, 8, 9, 5]", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return list(zip(*[3:])(l), zip(*[3:])(l))\n\nI know this is really more suited to /r/learnpython, but I've always thought this was a strange feature of Python to have a language feature that is both more complex than the language allows, and not really that useful.\n\nI used to think that too, but in practice it's come in handy a few times.\nOne example: sorting a dictionary by one key (e.g., { 'color':'red' }) can result in the dictionary being sorted by another key (e.g., 'color').\nSorting a list by one key (e.g., [{'color':'red'}]) can result in the list being sorted by a different key.\nIt turns out that there's a case where the above two are equivalent, which is when the list/dictionary key is the same as the sort key. That's where the \"sort_third\" function comes in handy.\n\nYeah I guess it's a useful feature in some edge cases, but surely there must be better ways to solve the problem than trying to fake a new language feature.\nI", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return [x for x in sorted(l) if x % 3!= 0]\nIt's possible to use a list comprehension instead of a list comprehension:\n[x for x in sorted(l) if x % 3!= 0]\n\nAnd even in python3, where list comprehensions are not available:", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return [x*x for x in l if x % 3 == 0]\n\n>>> [sort_third([1, 2, 3], [5, 6, 3, 4, 8, 9, 2]) for i in xrange(len(l))]\n[1, 2, 3, 5, 6, 3, 4, 8, 9, 2]\n>>> [sort_third([1, 2, 3], [5, 6, 3, 4, 8, 9, 2]) for i in xrange(len(l))]\n[1, 2, 3, 5, 6, 3, 4, 8, 9, 5]\n>>>\n\nIt's a cute demonstration of the fact that recursion is the basis for all recursive functions.</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    for i in range(1, len(l)):\n        if l[i] % 3 == 0:\n            #this is the test that we want to do", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return [l[x] for x in l if l[x] % 3!= 0]\n\nThis returns a sorted list with the same values as the original list, but in a different order. The original list is unchanged, and is still unsorted.\n\nThis is not a general solution. There are two ways to define a function that returns a sorted list. The first one is the solution above, where the list is modified in-place and returned, and the second one is the solution below, where the list is returned unchanged and the sorting is done elsewhere.", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    l = []\n    for x in range(l.size()):\n       if l[x]%3!= 0:\n          l.append(l[x]-3)\n        l.append(l[x])\n    return l\n\nYou've got the concept of an edge case backwards. The example you gave is not an edge case because the code handles the case just fine. An edge case is a condition the code does not handle properly.\n\nOr perhaps a conditional that is not well thought out.\n\nI thought this was going to be about the performance of the Python sort function.\n\nMe too. I still haven't figured out why that is. For example, here's a version of sort that uses the whole list each time:", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda c: c % 3, reverse=True)\n\nI guess I'm failing to see the purpose of this.\nThe OP's solution doesn't even require a function. Simply swap the first two values of the list and the second two values of the list.\n\nThe function is intended as an illustration of the common way of implementing `sort`.\nIf you want to know how to implement a sorting algorithm, here's an excellent resource:</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    # Gives a sorted list.\n    return l.sort()\n    # Returns a sorted list.\n    return l.sort_values(lambda x: x%3 == 0)\nOoh, that's a good one.  On the one hand, you don't have to use a function at all.  On the other hand, it's very simple to add a function that you can use, for example, to re-order a list in place without re-sorting it.</s>", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return [l[i for i in range(1, len(l) - 1, 0) if i % 3 == 0] for i in range(len(l), 3)]", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"", "def sort_third(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_third([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\" \"\"\"\n    return sort_third(l.reverse().sort())"]]