[["def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in range(2,len(lst)):\n        for j in range(2,i+1):\n           if (i%2 == 1 and i%2 == j%2)\n               return sum(lst[i] + lst[j])\n    return 0\n\ni like the idea, but why not skip the i+1 part, and use:\n\nfor i in range(2,len(lst)):\nfor j in range(2,i):", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    if len(lst) == 2:\n        return lst[0] + lst[1]\n    return 0\n\nI'm curious how this is the first solution you've seen that returns a value.\n\nBut then, you just posted it - not the solution, but the solution's solution, to be more precise.\n\nNo, he posted the solution to the problem \"given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\" (well, if you ignore the fact that it doesn't return the answer - that's probably a bug).\n\nWhen you apply a solution to a problem, you are supposed to get a solution, not another problem!\n\nI think that's a bug in the program.\n\nWhoa.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    x = 0\n    for i in lst:\n        if i % 2 == 0:\n           x += i\n    return x\nI'm fairly sure you don't need the elseif in your for loop as you can just return x if all the elements in the list are odd and the loop will never execute if they are all even.\nYou may have already seen this and that's why it's in there but it caught my eye.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    # Python: only works with integer-returning functions\n    return sum(lst.pop(0, -1)) + sum(lst.pop(1, -1))\nThis is better pythonic:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sum(filter(lambda x: x%2==0, lst)\n        if lst else 0)\nHah! I was wondering how long it would take for someone to catch that!</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i, x in enumerate(lst):\n        if x%2==0:\n           return x\n    return 0\n\nThis is a more efficient way to implement the algorithm you were asking for:\nimport collections", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in range(len(lst) - 1, -1):\n        sum = 0\n        for j in range(len(lst) - 1, -1):\n           if lst[i][j] == 1:\n               sum += lst[i][j]\n              break\n         sum = sum / 2\n     return sum\n\nSolution to your homework\n\nI was hoping for something more interesting.\n\nI agree with the others, a solution to the assignment is a solution to the assignment, no matter how simple it might be. But I've done it and posted it anyway.\n\nOne might write a function which does exactly the same, except that it checks the number of elements in the list, and just returns the sum of the first n odd elements:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    for i in range(len(lst)):\n        if i % 2 == 1:\n           return solution(lst[i])\n        return solution(lst[i-1]) + solution(lst[i-2])\n    return 0\n\nIt's hard to believe that this is the best solution.  At least it's not the worst.\n\n\"All these solutions are terrible, and they are also quite fun to write.\"\n\nI'm looking forward to the other solutions, I'm sure they will be a hoot to read as well.\n\nThis is a good example of where the (pseudo)code is better than the code.\n\nThis is a good example of a good solution.\n\nI came to the comments to laugh at the awful pseudo-code, but I have to say, the python implementation is just as bad.\n\nI think the \"solution\" is:\n\nOn a vaguely related note, I saw the other day an interview with Ken Thompson where he says that the best way to tell a good coder from a", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    return lst.filter(odd)", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst) == 0:\n        return 0\n    for x in lst:\n        if x % 2 == 0:\n           x = x / 2\n          if len(x) > 1:\n             return sum(x)\n    return sum(lst[::-1])\n\nI like the Python solution. In fact, I would argue that for many problems like this the performance of a Python program is not the limiting factor.\n\n_In fact, I would argue that for many problems like this the performance of a Python program is not the limiting factor._\nFor some problems, performance is not the limiting factor. For many problems, performance is important.\n\nI think it depends on how long it would take to write the program and test it as well as the time spent running it.\n\nI see this as a great example of why Python is an easier language to write in than C.\n\nThe example is contrived, but you are right,", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    result = []\n    for i in lst:\n        if i % 2 == 0:\n           result.append(i)\n    return result\n\nwhile I like your solution, this is not a good way of writing a recursive algorithm, for several reasons:\n\\- It has two return statements, when it could use a single one.\n\\- It has a loop that iterates over all elements of the list, which is not necessary.\n\\- It uses a counter variable and an index variable to track the current element of the list.\nHere's an equivalent solution, using a simple recursive algorithm:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    return sum(lst[1:]) + lst[2:]) + lst[3:]\n\nI tried it, and it works!\n\nI had no idea it could be done so simply. Thanks!\n\nI'm pretty sure that the most efficient way to solve this problem in Python is to use a list comprehension:\nsolution = [i for i in list(range(1,len(lst))) if i % 2 == 0]\n\nI'd have done it with a dictionary.\nsolution = {1 : sum(lst[1:]) + lst[2:]) + lst[3:],\n2 : sum(lst[1:]) + lst[2:]) + lst[3:],\n3 : sum(lst[1:]) + lst[2:]) + lst[3:]}\n\nAt this point, I'd probably just use a recursive solution.\nsolution = sum(map(lambda x: x%2, lst))\n\nAt this point, I'd probably just use an array.\nsolution = sum([i for i in range(1, len(l", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return [i for i in lst if i % 2 == 0]\n\nIt's funny that the default python implementation of'solution' isn't a very good solution at all.\n\nIt's funny that the default python implementation of'solution' is a very good solution for 95% of the cases.\n\nI use Python regularly for work and I agree. It's a good language but there are a few things that annoy me about it, the main one is probably how weakly-typed it is.\n\nI'm surprised no one has complained about the \":\".\n\nAnd no-one has complained about \"solution(lst)\", which seems a better candidate for a rant.\n\nI was not aware of the word solution having a particular meaning in math. How is the python code wrong?\n\nIt's not. The author of the code has a different idea about what a'solution' is.\n\nI think it's funny that the author thinks the solution should be \"solution(lst)\".\n\nIt's also funny that the author thinks that\n(sum(lst[i % 2] for i in lst) == lst) ==", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in range(len(lst)):\n        if (i % 2 == 0) and lst[i] % 2 == 1:\n           return lst[i] + sum(lst[i:])\n\nIn Python this is a bit more complicated:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    def solve(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solve([5, 8, 7, 1]) ==> 12\n    solve([3, 3, 3, 3, 3]) ==> 9\n    solve([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return (sum(x for x in lst if x % 2 == 1) + sum(x for x in lst if x % 2 == 0))\n\nYep, that's good enough for me! If it's good enough for you, then read on.\n\nTwo people independently submitted the above solutions to the above problem. Both people deserve full credit, but only one person will get it. That's because the submitted solutions are different, and that matters for solving the problem.\n\nIt matters because different solutions demonstrate different ways to solve a problem. That's important. It's important because it's often difficult to find an efficient solution to a problem. The more ways we have to solve the", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return list(range(len(lst), 2), 1) + list(range(len(lst), 2), 2)\n    + list(range(len(lst), 2), 3)\n\nFor those who are curious, here's why it works:\nList[Int] has a method named _sum_ that calculates the sum of all the integers in the list. So if you call it with a list of integers, then you get back the sum.\nIf you take a look at the docs, you'll see that _sum_ is defined as a function, and so it can be used as a function. So you can call it as a function.\nSo the first line is just calling _sum_ with a list of integers as parameters. The _sum_ method is defined as taking a range as parameters, but the doc says that it will use 1 and 2 if you leave them out.\nThe next line is just calling _sum_ with a range, which it will use.\nThe next line is just calling _sum_ with a range.\n\nI was expecting to see something new, but this is just a \"cool\" (i.e. not \"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sum(lst[i] for i in range(2,len(lst)+1) if i % 2 == 1)\nLists don't have length, length is a function that returns the length of the list.\nI don't think it's a big deal, the problem is just a simple one.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i, x in enumerate(lst):\n         if x % 2 == 0:\n             return x\n\nHow would you do this in Python?\n\nfrom itertools import cycle, groupby\nfrom functools import partial", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst) == 0:\n        return 0\n    for i in xrange(1, len(lst) - 1):\n         if i%2 == 0:\n             return i\n        return 0", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    total = 0\n    for i in range(1, len(lst)):\n        if i % 2 == 0:\n            if lst[i % 2] == 1:\n                total += lst[i % 2]\n               elif lst[i % 2] == 0:\n                  total += 1\n\n    return total\n\nThe last line is an example.  It computes the sum of all the odd numbers from 1 to 321 that are in even positions.  It works because it's possible to sum even numbers (just use `sum([0, 2, 4, 6, 8, 10, 12,...])`), and the result is the sum of all the odd numbers from 1 to 321 that are in even positions.\n\n(The only tweak to the original is that the range of i in the for loop is 1, not 0.  Otherwise, you", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return len(lst) % 2 == 1\nI'm not really sure what this does.\nIt returns the sum of all of the odd numbers that are in even positions, and it returns 0 when the list is empty.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    for item in list:\n        if item % 2 == 1:\n            total += item\n        return total\n\nThis is one of the greatest things I have ever seen.\n\nThis is a great solution. It's using the [0, 1] range to do a binary search for the 2nd element in the list, and then adding it to the total. This will perform very well, assuming the array is already sorted.\n\nHeh, I was actually looking for a solution like this in the comments.\n\nHere's a solution with a bit less work:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    for o in lst:\n        if o % 2 == 0:\n            return o\n    return 0\n\n There's a better way.\n> solution([5, 8, 7, 1]) ==> 12\n> solution([3, 3, 3, 3, 3]) ==> 9\n> solution([30, 13, 24, 321]) ==>0\nWhy not use the sum method on each element of the list?\n\n_There's a better way._\nCan you please elaborate?\n\nIf you want to sum all the odd elements that are in even positions, you can do that very easily using a for loop, by assigning the value of the loop counter to a variable, and using that variable in the sum method.\n\nAh, I understand now. Thanks!\n\nThis is a great example of why code should be written in English.\n\nI just came here to say the exact same thing.\n\nI like that Python is becoming the new BASIC, the way BASIC was the new assembly language.\n\nPython is probably the best programming language for beginners. I started with it and", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for n in lst:\n        if n % 2 == 0:\n           return n\n    return 0\nThis is your function? It does not accept the correct input.\nIf it is, the first part is a little misleading.", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    return [solution(i) for i in lst if i % 2 == 0]\n\nThat's not a function, that's an expression. A function is supposed to take parameters and return a value.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return lst == [x[2] for x in lst if x[0] % 2 == 0]\nIt would be helpful to give it a more intuitive name.   Perhaps ``oddsum''?\n\nI don't think you should use such a name since it's not the original intent.\n\nAs a math PhD who can't program, I can say that this is awesome.\n\nI'm a programmer who can't do math, so I'll take your word for it. :-)\n\nAs a programmer who can't math, I'll take your word that you can't math\n\nAs a programmer who can't math, I'll take your word that you can't word.\n\nAs a mathematician who can't program, I'll take your word that you can't math.\n\nAs a programmer who can't word, I'll take your word that you can't math.\n\nAs a programmer who can't math, I'll take your word that you can't word.\n\nAs a programmer who can't math, I'll take your word that you can't math\n\nAs a programmer who can't math, I'll take your word that you can't math", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in range(len(lst) - 1):\n        if lst[i] < lst[i+1]:\n           return lst[i] + lst[i+1]\n    return 0\nI would also include the'return 0' part at the end.  Also, you could just write this as       return sum(lst) + 1\nThis is a good exercise, but I think that this should be given to someone who has had a couple of weeks of programming experience.  This has a number of fundamental errors that are more of a C/C++ style than Python.\n\nI agree. I would rewrite it as:\nsolution = sum(lst) + 1\n\nIndeed. Or better, use the built-in functions:\nsolution = lambda lst: sum(lst, 1)\n\nYou could also do it in one line with list comprehensions:\nsolution = [sum(lst) for i in range(len(lst) - 1) if lst[i] < lst[", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    a = 0\n    for i in range(len(lst)):\n        if i % 2 == 0:\n            a += lst[i]\n    else:\n             a += lst[i - 1]\n    return a\n\n>>> solution([5, 8, 7, 1])\n        12\n>>> solution([3, 3, 3, 3, 3])\n        9\n>>> solution([30, 13, 24, 321])\n        0\n\nUsing the % operator you can create \"composable\" functions like this.\n\nYou can also make functions that create functions, and so on.\n\nSee also:\n\nPython function creation\n\nPython lambda function\n\nPython generator\n\nPython generator comprehension\n\nReferences\n\nExternal links\n\n\"Solution\" in Python is the same word as the mathematical concept\n\nSolution in Python</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sum([i for i in lst if i % 2 == 0])\nI don't see the utility of this function.\n\nThis is a good example of what people mean when they say \"lines of code is not a good measure of software complexity.\"\nThe algorithm is relatively simple, but the code needs to be pretty complex in order to handle the edge cases correctly.\n\nThis is an interesting point. It seems like the code should be rather simple, though. Perhaps we are just using the wrong paradigm to solve the problem.\nMaybe, to solve this problem, we could use a parser/interpreter, where the user types in their solution and the parser/interpreter will convert it to the optimal solution.\n\nWhat is the point of it? It just sums the odd numbers in the even positions.\n\nI've seen plenty of stupid one-liners like this on HN. It's an exercise.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for x, y in zip(lst, 2):\n         sum += x % 2 == 0\n    return sum\n\nThis is the most direct solution I can think of. I'm not sure it's the most efficient.\n\nMost of the time, \"most efficient\" and \"shortest code\" go hand in hand.\n\nI wouldn't say that's necessarily true. I think the code is shorter, but the algorithm is more convoluted. The algorithm tries to find the maximum of x/2 for each element in the list, whereas the solution tries to find the maximum of x/2 for every pair in the list. For a list with only one element, the maximum of x/2 is 2.\n\nThat is the solution I would have thought up after 15 minutes. I was hoping for something more clever/elegant.\n\nYour code is much better than mine, but it's still not the most elegant solution possible. The algorithm can be simplified by breaking it down into two steps.\nIn the first step, you take the odd elements and see if they are in the even positions. If they are not, then move on to the second step", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst) == 1:\n        return 1\n    for x in range(0, lst.count()-1):\n        if lst[x] % 2 == 0:\n           return x\n\nHere's the Python solution:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if lst[0] % 2:\n        return len(lst)+2\n    elif lst[1] % 2:\n        return len(lst)+1\n    elif lst[2] % 2:\n        return len(lst)+0\n    elif lst[3] % 2:\n        return len(lst)+1\n    else:\n        return 0\n\nThis code is obviously wrong.\nLists don't have a. operator.\n\nI think this is supposed to be a joke :)\n\nI thought it was supposed to be a joke too, but then I realized that there are many programmers out there who don't know this kind of stuff, so maybe it is really a joke?\n\nI thought it was a joke, but then I remembered that I was writing code when I was about 13 and I've known some people who are not the brightest crayon in the box. So I'm not sure anymore.\n\nI would have thought", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sum(range(len(lst),2) for range in lst if range[0] % 2 == 1)</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in range(len(lst)):\n        if lst[i] % 2 == 1:\n            return lst[i] + lst[i+1]\n    return 0", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in range(len(lst)):\n        if lst[i] == 2:\n             return sum(lst[i:])\n    return sum(lst)\n\nThis is also a good exercise in looping, if you'd like to further develop your skills in Python.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return [i for i in lst if i%2==0]\n    print solution([2, 3, 4, 5, 6])</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if n % 2!= 0:\n         return sum(lst) / 2\n    else:\n         return sum(lst[::2])\n`;", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sum(filter(lambda x: x%2 == 0, lst))\n\nI want to point out that this is an absurdly slow implementation of the solution in terms of performance. I'm not familiar with Python, but I would expect some kind of set based operation to be able to do this much faster.\n\nThe main thing is, you want to do something like this:\nsum([x for x in lst if x % 2 == 0])\nor even better:\nsum(map( lambda x: x % 2 == 0, lst))\n\nAlso:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if lst == []:\n       return 0\n    else:\n       x = lst[0]\n       if x % 2!= 0:\n          return x\n    return x + sum(x % 2 for x in xrange(lst.size()))\n\nI like the def syntax better than the inline syntax for this. (I think the inline syntax is ugly because it tries to make a variable name stand for a function name.)\n\nAgreed - it's the kind of thing that I wouldn't have even considered for a function until I was asked about it in an interview.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    x = 0\n    for i in range(len(lst) - 1):\n        x = x + 2\n    return x", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    odd_positions = [lst[(i - 1) % 2] for i in range(len(lst))]\n    return sum(1 for i in odd_positions if lst[i] % 2 == 1)\n\nI think this would be more natural (and would use less lines of code) if written as:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\nreturn sum(list(evens(lst), 2) for evens in lst)", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst)==1:\n       return lst[0]\n    elif len(lst)==2:\n       return lst[0][0]\n    else:\n       return sum(lst[1:], 2)</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    for i in xrange(len(lst)-2):\n        sum = 0\n        for j in xrange(i+1, len(lst)-1):\n            if j % 2:\n                sum += lst[i+1]\n    return sum\n\nIn this Python example, the sum() function simply counts up all the odd numbers, starting at position i and going until position i+2. Then, in the last iteration, it counts up from i+2 to i+1, and so on.\n\nA major difference between Python and C++ is that C++ doesn't have operator overloading. So, instead, the sum() function is written like this:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in range(len(lst)):\n        if i % 2 == 0:\n             sum = sum + lst[i]\n    return sum", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    odd_int = []\n    for i in range(len(lst)):\n       if lst[i] < lst[i+1]:\n          odd_int.append((i - 1))\n       return sum(odd_int)\nIt's also worth noting that this is not what we're really looking for. It's not in-place or memoized.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    odd_count = len(lst) - 1\n    odd_items = list(lst)\n    odd_items.remove(0)\n    for odd_item in odd_items:\n        if odd_item!= 0:\n           if odd_item is in even_positions:\n                return odd_count + odd_item\n    return 0\n\nWhat is the point of the if odd_item is in even_positions?\nWhy not just return odd_item?\n\nThe problem with that is that if, for example, you are trying to add together a list of random numbers, the first value you get is always 1.\nYou're trying to find the sum of all the odd elements that are in even positions.\n\nAh, I see. I misread it. I thought it was trying to find the sum of the odd elements in the list.\n\nReminds me of Knuth's \"lemma\" on counting the number of ways to choose n objects from a", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sum(set([lst[1:]], [lst[2:]], [lst[3:]], [lst[4:]], [lst[5:]]]))\nWhat you want is", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sum(x for x in lst if x % 2 == 1)\nIf you're not going to use the list type, why not just write the solution as an expression?\nYea I know.  This was the first program I ever made when I got python.  I didn't really understand list comprehension at the time.  So i just made it like that.  But I like to keep my programs really organized so I thought it would be better to leave it as is.  I might rewrite it soon, though.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n        sum = []\n        for i in range(2,len(lst)):\n           if i % 2:\n               sum.append(lst[i])\n              if sum == len(lst):\n                 return sum\n            else:\n                return 0\n\n    return sum\n\nsolution() is still very inefficient. Given that it is a highly specific function, wouldn't it be better to write it in C and just link it into your Python program?\n\nThe solution is quite short, and the OP asked for a solution in python, not in C.\n\nYou could probably use a python function to do this:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst) == 1:\n        return 0\n    if len(lst) == 2:\n        return 1\n    else:\n        return sum(lst[x] for x in lst if x % 2 == 0)\n\nCan someone explain how this code works? I'm new to Python.\n\nIt's a function that takes a list of integers and returns the sum of all the even numbers that are odd.\nEssentially, it's a function that takes a list of (numbers, whether they're even or odd) and returns a (numbers, whether they're even or odd) list.\n\nAh, thank you. I was reading the function as the code in the post. The way you explained it makes a lot more sense.\n\nI would just use this for the second example.", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in range(len(lst)-1):\n        if i % 2 == 0:\n           return i\n    return 0\nIf you want to do it efficiently (i.e. not O(n^2)), you could use a dynamic programming solution, which would be much faster than any brute force method.  Of course, this is only true if the list isn't that big.  I'm assuming that the list is only as big as the number of odd integers that are in even positions, since the example list you gave has only 7 odd integers in even positions.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst) == 0:\n        return 0\n    # Take an item at a time. If it is even, add it to the list\n    for i in range(1, len(lst)):\n        if odd(lst[i-1]) == 0:\n            lst[i-1] += 1\n           # If it is even, add it to the list\n    return lst", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return []", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return lambda x: (x % 2 == 1 or x % 2 == 0) & (x % 2 == 0 or x % 2 == 1)\n    and sum(lst[:len(lst)-1])\nThis is a good example of how to read pseudocode and take it literally. :-)  That said, I do like the write-up in general.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    odd = [0]*lst\n    sum = 0\n    for i in range(0,len(lst)):\n        sum += odd[i%2]\n    return sum\nAnd you'd be surprised how often this comes up...</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i, x in enumerate(lst):\n        if x % 2 == 0:\n             return i + 1\n    return 0\n\nFor some reason, I initially thought this was a very fancy way of doing Fibonacci numbers.\n\nI thought the same thing. I thought it was a recursive solution to n! using integer arrays.\n\nI thought it was for finding the n-th Fibonacci number.\n\nMy solution took 40% less space and 25% less time:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sum([x for x in lst if x % 2 == 1])\n\nThis is a really neat hack.\nIt feels like it shouldn't be more than twice as fast as summing all the even elements of the list.\n(And I'm not convinced that it is.  I'm convinced that it's _at least_ as fast.)\n\nYou're right. The technique is described in Knuth, \"The Art of Computer Programming\" Vol 2, Chap 2, under the title _A very fast way to multiply two numbers_ [1].\n[1]\n\nAnother in Knuth's \"fast way to multiply two numbers\" series is summing all the divisors of a number. For example, summing the divisors of 6 would take O(n log n) time with a normal for loop (assuming you know how to write the loop) but only O(n) time with the Knuth technique.\n\nThat's not a great example of a real-world problem. It's a huge problem for things like factoring, but in general, you can't tell if a number is prime by checking its divisors.\n\nYou can easily do a breadth-", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in lst:\n        if i % 2 == 0:\n             return i\n\nThis is a trivial case of the solution to your stated problem. If you're asking for help, provide some context.\n\nOops, I should've mentioned that the solution has to use recursion, and that I can't use any built-in functions.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sum(range(0,len(lst)))\nBut you should consider the input as an integer. Your code reads like you are trying to figure out what the type of your input is. You should have a look at the   built in function.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    n = len(lst)\n    evens = []\n    for x in lst:\n        if x % 2 == 0:\n            evens.append(x)\n    return sum(evens)\nI am not the only one to see the problem here?</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    sum = 0\n    for k in range(len(lst)):\n        sum += lst[k] % 2 == 1\n    return sum\n\nimport itertools, sys", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    if len(lst) == 1:\n        return 0\n    else:\n        return sum(lst[:2]) + sum(lst[2:] - 2)\n\nThis isn't about Python, it's about programming in general.\n\nAt least it's a small and simple example.\n\nIt's simple, but not very small.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for x in lst:\n        if x % 2 == 0:\n           return x\n    return 0\n     I think you mean something like:\n         def solution(lst):\n           return (x%2 == 0)**2\n\nThere is nothing wrong with the original code. (He even used ** for exponentiation!) The problem with the original code is that it doesn't use the same notation for the function as the other examples.\n\"def solution(lst): return ((x % 2) ** 2) for x in lst\" is much easier to read, but the original code is perfectly valid.\n\nThe biggest problem with the original code is that it uses an infix operator in a case statement. That's illegal Python.\n\nIt's not illegal, just ill-advised.\n\nIt's not just ill-advised, it's flat-out wrong. In a _case_ statement, you have a _case_ expression, a _break_ or _continue_ statement, and", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return lst.pop()\n    if sum(lst[1:]) == 0:\n       return lst[2:]\n    else:\n       return sum(lst[1:]) + sum(lst[1:]) + sum(lst[1:])\n    return 0</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    # we want to take a slice of the list, and do a binary search to get the sum\n    odd_sums = []\n    # binary search on the left hand side of the equation\n    for i in range(len(lst)-1):\n        odd_sums.append(solution(lst[i:i+2]))\n    # do the same with the right hand side\n    # note: no need to change the range of the binary search as the list\n    # is sorted\n    for j in range(len(lst)-1):\n        odd_sums.append(solution(lst[i+j:i+2]))\n    return sum(odd_sums)\n\na = 0\nb = 0\nc = 0\ns = [0]\nfor n in range(len(s)):\n    s = s[1:] + s[-1:]\n    a = a + b\n    print s  # print [", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst) > 1 and len(lst[1:-1]) > 0:\n        for i in range(1,len(lst)-1):\n            sum = lst[i]*2\n            if i == 1:\n                break\n         else:\n               sum += lst[i]\n    return sum", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    # recurse until the list is exhausted\n    for i in lst:\n        if (i % 2 == 0):\n            return solution(i-1) + i\n        return 0\n    # return the result", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    numbers = [None]\n    for i in range(len(lst)):\n         if i % 2 == 1:\n             numbers.append(i)\n            lst = (lst[i], lst[i+1],..., lst[i+2])\n             if sum(lst) > len(lst):\n               return sum(lst)\n    return 0\n\nI think your algorithm is correct. It might be worth doing a real test though to be sure.\n\nThanks. I figured it out. Solution (in the context of solutions of equations) means the solution to the equation. So the answer is:\nsolution(list) = list[x for x in list if x % 2 == 1]\n\nThat's not true, the solution to the equation `x % 2 == 1` is `x`.\n\nYes, I meant:\nsolution(", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    print(\"\\n\\n\")\n       result = 0\n    for i, odd in enumerate(lst):\n        if odd % 2 == 1:\n           result += odd\n          print(\"\\n\\n\")\n    return result\n\nI've done more with Python than with Ruby, but my first thought is, \"Dude, that's really easy. What's the point?\"\nMy second thought is, \"Does Ruby not have built-in sum(), product(), and reduce() functions?\"\n\nWhile Ruby has sum(), product(), and reduce(), the code is a bit longer:\nsum = 0\nreturn sum.+(0 if odd % 2 == 1)", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst)!= 2:\n        return 1\n    for i in range(0,2):\n        sum = 0\n        for c in range(2,len(lst)-1):\n            sum += lst[i:i+2] - lst[i+2:]\n         return sum\n    return 0\nI'm not sure I understand this. It takes the first two elements of the list and then the last one. So it looks like it would do the same thing as the original code.\n\nTry it with a list of all zeroes. It should return 1.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\nThere is another solution that is much faster than this one:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    result = 0\n    for i, value in enumerate(lst):\n        if value % 2 == 0:\n            result += value\n         if i!= len(lst):\n             break\n    return result\nI guess I wasn't clear on the fact that this was a homework assignment.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return lst[(i % 2) for i in range(len(lst)+1)]\n\nThanks for the example. I see how this works but why are you using 'len(lst)' to get the sum?</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in range(len(lst)):\n        if i % 2 == 0:\n             return sum(lst[i - 1])\n        return 0\n\n    for i in range(1, n):\n         if lst[i] % 2 == 0:\n             return sum(lst[i])\n        return 0\n\nThis is exactly the algorithm from the article, but with the last line replaced by \"return 0\".\n\nI see, thanks for the clarification!\n\nWhy would you return a boolean when you could return an int?\n\nWhat I've seen a lot in the past is people write code like that as a convenience, but then it gets copy-pasted with the boolean return value and eventually the boolean is forgotten.\n\nA more obscure example of this is when the code was written by someone who'd written something in an interpreted language.\n\nI'm not sure I'd say it's obscure. Any example of", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst) == 1:\n        return 0\n    elif len(lst) % 2 == 0:\n        return len(lst)-1\n    elif len(lst) % 2 == 1:\n        return len(lst)\n    else:\n        return len(lst) + 1\n\n\t def evensum(lst):\n\t    \"\"\"Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n     Example:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sum(list(filter(lambda x: x % 2 == 1, lst)) + 1)\nWhat's the point of filter there?\nI would guess it's an attempt to generalise to non-integer lists, and an attempt to use the list comprehension syntax.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst) == 1:\n        return lst[0]\n    if lst[0] == 1:\n        return 0\n    return sum(lst[1:] * (lst[1] % 2 == 0))\n             # assuming odd number is 0\n    return -1\n\nThe answer to \"def solution(lst):\" is:\nreturn sum(lst[1:] * (lst[1] % 2 == 0))\n\nThe answer to \"def solution(lst):\" is:\nreturn sum(lst[1:] * (lst[1] % 2 == 0))\n\nThe answer to \"def solution(lst):\" is:\nreturn sum(lst[1:] * (lst[1] % 2 == 0))\n\nThe answer to \"def solution(lst):\" is:\nreturn sum(lst[1:] * (lst[1] % 2 == 0))\n\nThe answer to \"def solution(lst):", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    x = 0\n    while lst:\n        if (x%2 == 0):\n            x += lst[1:]\n        elif (x % 2 == 1):\n            x += lst[0:]\n        else:\n            return 0\n    return x\nThis was the solution I came up with, but I don't know how to convert it to python</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in range(len(lst)):\n        if lst[i] % 2 == 0:\n           return sum(lst[i]+lst[i+1])\n    return 0\n\nis that meant to be an example of recursion? it's an imperative algorithm.\n\nIt's not really an example of recursion. I didn't know how to use recursion to solve the problem, so I used the next best thing: a for loop.\n\nThere's a few different ways to do it:\n\nI think the best way to do this is to have a \"sum\" object that accumulates the sums of each element in the list, and then call the \"solution\" function recursively on each element of the list.", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for element in lst:\n       if element % 2 == 0:\n          return element + 1\n    return 0\n\nYeah, that's what I would expect, but the program does not return the correct answer.\n\nWhat happens when you run the program as is?\n\nIf you haven't seen this yet, you should check out the lint utility:\n\nThe other thing I did was to use a better programming language.\n\nI'm assuming that's not a real solution.\n\nIt's a real solution, but only for the problem in the original article. If you want to get this to work in Python, you need to add a few more lines to the solution. Here's what I have:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return (x*x+y*y for x,y in sorted(lst))\n\nIt's a pretty easy problem to write code for, but if you'd rather not write it, here is the above code as a function:\nimport operator", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    # Split list into odd and even elements\n    odd_count = 0\n    even_count = 0\n    while odd_count < len(lst):\n        odd_count = odd_count + 1\n        even_count = even_count + 1\n    return sum(odd_count) + sum(even_count)", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    \"\"\"Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n    Examples\n    solution([5, 8, 7, 1]) ==> 24\n    solution([3, 3, 3, 3, 3]) ==> 3\n    solution([30, 13, 24, 321]) ==> 0\n    \"\"\"\n    def oddSum(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in odd positions.\n     \"\"\"\n    \"\"\"Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n     \"\"\"\n    def evenSum(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the even elements that are in even positions.\n     \"\"\"\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n     \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for x in lst:\n        if x % 2 == 1:\n           return x\n    return 0\ni feel like I'm missing something obvious.\nI thought of the same thing.  But there are no solutions.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    i = 0\n    while i < len(lst):\n        i = i + 1\n        if i % 2 == 0:\n            lst[i] += 1\n    else:\n             return solution(lst[:-i])\nI think he means to do this in one line.   If not, the code could be improved.", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    x = 0\n    for lst in lst:\n        if x == 0:\n           break\n           x = x + lst[2:]\n    return x\nIf you're going to write a function, then do it right. You can either have a while or a for loop. Not both.\nThe for loop isn't necessary at all and can be removed. The while loop could be refactored so that you don't have to manually subtract the evens from x, but I'm guessing you're not to that stage yet.\n\"Do it right\" is overkill for someone who's just starting to learn programming.\nThis guy knows what he's talking about. I started to learn programming a month or two ago, and I still do stuff like this.\nThere's no reason to put extra effort into it if you don't need to. There are many things that are \"wrong\", but that's only if you're trying to be as efficient as possible. As long as the code is readable, it should be good enough.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sum(set(lst, n) for n in zip(set(lst, 2), set(lst, 2)) if n%2 == 1\n[I've fixed the formatting]\nPlease fix the formatting</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\nreturn [i for i in lst if i % 2 == 0]\n\n>>> solution(set([5, 8, 7, 1]))\n12\n>>> solution(set([3, 3, 3, 3, 3])).sum()\n9\n>>> solution(set([30, 13, 24, 321])).sum()\n0\n\nThere's a gotcha here -- if lst has two elements (e.g., 2, 3) the first solution will not work (as both 2 and 3 are in even positions), but the second solution will work fine.\nIt's easy to fix, though:\n>>> solution(set([2, 3], dtype='int')).sum()\n2\n>>> solution(set([2, 3], dtype='int', prop='odd_even')).sum()\n3\n\nWhat does that mean? If you say\n>>> solution([2, 3], dtype='int', prop='odd_even')\nyou are telling the function that you want to operate on the list (and only the list) as if it were a 2-element list of integers (no tuple).\nThe new function, with the prop argument, is the actual", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst) == 2:\n       return lst[0] + lst[1]\n    return 0\nI think you can simplify it a little further, by using len(lst) < 2 instead of len(lst) == 2.  (This is assuming that you don't have to handle lists of length 3 or more.)</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst) == 0:\n        return 0\n    for element in lst:\n        if element % 2 == 0:\n           return element\n    return -1\nThis is a bad solution. It fails when the list has length 2. It will also fail if the list is [2, 1].\nA better solution:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    n = len(lst)\n    for i in range(n):\n        if i % 2 == 0:\n            sum += lst[i]\n    return sum\n\nA slight modification gives the sum of the even elements that are in odd positions:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    lst.reverse()\n    for i in range(len(lst)):\n        if i % 2 == 0:\n            return lst[i]\n    return 0\nWhy do you need to reverse the list, and how do you deal with the case where it is empty?\nI am not familiar with Python.\n\nThe original code is in pseudocode, so those aren't really Python statements.\n\nYou have to reverse the list because you can't tell if the item is odd or even without knowing what order you're counting in.\nI'd call this something like \"solution(numbers)\" to make it more obvious it's operating on a list, because I spent a bit of time trying to work out how to make it work with a single number.\nAlso, in Python (and I imagine in Ruby, which I use regularly) you can drop the parentheses around the definition of the function and Python will infer the function name and put it in the right place for you.\n\nA better version of this code is:\nsolution = lambda lst:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    a = [0]\n    while len(a) > 0:\n        if a[0] % 2 == 0:\n            a[0] += 1\n        else:\n             return a\nOh, and the summation operation is also documented as \"solution\" in Python, in the \"s\" chapter of the language reference.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sum(odd(list(i for i in range(len(lst)))[:2]))", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for n in lst:\n        if n%2==0:\n           return sum(n)\n          else:\n            return 0\n    return sum(lst)</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in lst:\n        if i % 2 == 0:\n           odd = i\n    return odd", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for x in lst:\n        if x % 2:\n            return x\n    return 0\n\nMyself, I would do this a little differently:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return lst.pop(1)\n    for x in xrange(len(lst)):\n        sum += lst[x % 2]\n\nIs this code correct?  I can't seem to get it to work.  Is it because it is a list comprehension and not a for loop?  I tried a for loop and that didn't work either.   Thanks!\n\nI think the above example is wrong (or maybe just misleading), because it doesn't take into account the possibility of removing the last element (or first element, for that matter) from the list before doing the summation.\nI'd suggest:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    x = []\n    for i in lst:\n       if i%2 == 1:\n          x.append(i)\n    return x\nWhat would be the advantage over something like this?       def solution(lst):               return lst[(i % 2) & 1]\n(the & 1 is a bitwise and, not a logical AND).\n\nThe main difference would be that if the list was sorted, you would need to convert it to non-sorted before doing a bitwise and. The other way around is not the case.\nAlso, the way you wrote it, the result is always an int (or float if you used the 'e' instead of 'i' in the loop), which might or might not be what you want.\n\nI use this trick all the time, but the snippet posted doesn't include the error checking for the even positions. You need to check that the current element is odd and that the index is between 0 and length(lst) - 1.\nI", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in range(len(lst)):\n        lst[i] = (i & 1)\n    return sum(lst[1:])\n\nThis would be equivalent to:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in range(len(lst)):\n        sum = 0\n        for j in range(1,len(lst)-1):\n           sum += lst[i][j]\n    return sum", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    # Let f be the function that returns the sum of the odd numbers in\n    # an even position.\n    f = lambda lst: sum(lst[2:])\n    # Create the list of all odd elements in even positions\n    # to be summed.\n    oddEvens = sorted(lst, key=lambda a: a%2)\n    # Return the sum of the oddEvens list.\n    return f(oddEvens)\n\nimport operator", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in range(len(lst) - 1):\n        for j in range(i+1, len(lst)):\n            if lst[j] % 2 == 0:\n                return sum(lst[j])\n    else:\n               return 0\n    return 0", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    result = 0\n    for i in range(len(lst)):\n        if i % 2 == 1:\n           result = result + lst[i]\n    return result", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst) == 1:\n         return lst[1]\n    elif len(lst) == 2:\n         return lst[2]\n    else:\n          return 0\nThis is a terrible solution, since it requires you to know the length of the list ahead of time.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    return lst[::2] + lst[::2]\n\nI would have used a linked list of integers and just returned the sum of the even elements.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i, elem in enumerate(lst):\n       if elem % 2 == 1:\n          return elem\n    return 0\nI was going to do something similar, but I like this a lot better. I would replace the \"return elem\" with \"return sum(lst[i]) + 1\" and I think I'll use this.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst)!= 2:\n        return 0\n    for x in lst[1:]:\n        if (x % 2 == 1):\n            return x + 1\n         else:\n            return 0\n\n    def square(n):\n        return n ** 2\n\n    def sum(n):\n        return sum(square(n))\n\nThis is the naive solution and it is correct.\n\nReferences\n\nExternal links</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    import random\n    def list_with_solution(lst):\n        for i in range(len(lst) - 1):\n            lst[i % 2] = random.randrange(1, len(lst) - 1)\n         return list_with_solution(lst)\n\nsolution(['a','b','c'])\n\n>>> solution([3, 4, 5])\n7\n>>> solution([6, 6, 7])\n0\n>>> solution([3, 1, 0, 9])\n12\n\n>>> solution([3, 4, 5, 0, 9])\n0\n>>> solution([30, 13, 24, 321, 3, 3, 3, 3])\nTraceback (most recent call last):\nFile \"\", line 1, in\nsolution(['3', '4', '5', '0', '9'])\nFile \"\", line 1, in\nsolution([['3', '4', '5', '0', '9']])\nFile \"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return [int(x) for x in lst if (x % 2)!= 0]\nI don't see how to improve on that.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    odd_sum = [x.isdigit() for x in lst if x % 2 == 1]\n    return odd_sum.sum()\n\nOne thing to watch for is that the 1st, 2nd, 4th, and 6th elements in that list should actually be (0, 1, 2, 4, 6) respectively. In Python, even integer division gives the remainder 0.\n\nThanks, fixed.\n\nDoes anyone know of a library for doing similar things in C++ or Java? I would be interested in something that would work with C++ templates too, since C++ has the concept of operator overloading.\n\nThere is the boost.python library which allows to write C++ code that compiles to python. Not sure if that helps.\n\nI would recommend Boost.Python.\n\nI thought it was python the first time I read it</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    # The function returns True or False\n    return all(filter(lambda x: x%2 == 1, lst))", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if lst[0] == 0:\n        return 0\n    for i in range(len(lst)-1):\n        if lst[i]!= 0:\n            if i+1 % 2 == 0:\n                return lst[i]+lst[i+1]\n            else:\n               return 0\n    return sum(lst)\n\nSee also\n Python: How to check if an integer is even or odd?</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    if len(lst) == 1:\n        return sum(lst[1:])\n    else:\n        return sum(lst[2:])\n\nThis is one of those cases where the language isn't really clear about\nwhat is going on. (This is not uncommon in Python. You have to read\nthe \"How to Think Like a Computer Scientist\" book to get a\nreally good feel for how to work around it.)\n\nThe basic idea is that you can look at a list of integers as a binary\nnumber. You have the 0 and 1 values for the indices and the elements\nthemselves. So, if you have something like:\n\n1 1 1\n3 5 3\n8 9 5\n\nyou can look at it as the number 1011110111. The first element, the 1\nin the first position, is the rightmost digit.\n\nThe interesting question is: What happens if you have a list that\ndoes not have all zeroes and ones? For example, in the case of the\nexample above, what do you do with the number:\n\n1 1 2", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst) == 1:\n       return lst[0]\n    else:\n       if lst[0] % 2 == 0:\n           return sum(lst[1:])\n        else:\n           return lst[1:] + sum(lst[2:])\n\na more human readable version of this:\n\nsolution(lst) = sum(lst[1:] + sum(lst[2:])\n\nThere's also this:\n\nsolution(lst) = sum(lst[1:] + sum(lst[2:]) for i in range(2))</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst) == 0:\n        return 0\n    for j in range(len(lst)):\n        if lst[j] % 2 == 0:\n           return lst[j] + solution(lst[j+1:])", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return lst[0:lst.index(0) -1].reduce(0, sum)\nI think this would be better as a generator function and then you could easily change the type of sum.      def solution(lst):\n        yield sum(lst[0:lst.index(0) -1])\nI would also add a static assert so you can see where it's failing.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst) == 0:\n        return 0\n    for i in range(len(lst)-1):\n        sum += lst[i]\n    return sum</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst) == 1:\n        return 0\n    for i in range(1, len(lst)-1):\n        if i % 2 == 0:\n            return i\n    return 0</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    for i in range(len(lst)):\n        if i % 2 == 1:\n            return i\n    return 0\n\n    def to_s(num):\n        return int(num)\n\n    def l(n,m):\n        return int((int(n) + int(m)) / 2)\n\n    def s(lst,i):\n        return sum(solution(lst)) == i", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return len(lst) + len(lst[2:])\n\nThis is not a solution to the question posted.\n\nHow so? He asked for an implementation of a \"solution\" function, and this is one, a rather trivial one, but one nonetheless. It is also a classic example of using recursion for a simple problem.\n\nIt is not a solution because it does not solve the problem. It implements a solution.\n\nI think you're splitting hairs here. If we were talking about a definition of the problem, then I would agree with you. If we're talking about the act of implementing a solution, then this is indeed a solution.\n\nI think you're splitting hairs here. If we were talking about a definition of the problem, then I would agree with you. If we're talking about the act of implementing a solution, then this is indeed a solution.\n\nI think you're splitting hairs here. If we were talking about a definition of the problem, then I would agree with you. If we're talking about the act of implementing a solution, then this is indeed a solution.\n\nI think you're splitting hairs here. If we were talking about a definition", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\nIf the list is empty, the return value is 0.", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst) == 0:\n        return 0\n    else:\n        sum = 0\n        for k in lst:\n           if k % 2 == 0:\n              sum += k\n    return sum", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if lst == [] or lst.count(1) == 0:\n        return sum(lst[0:2])\n\nNote that in [5, 8, 7, 1], [3, 3, 3, 3, 3] and [30, 13, 24, 321], sum(lst[0:2]) returns 0.\n\nWe have to modify the code so that it returns the sum of all the odd elements in the list. We can do this by checking if the elements of the list are odd and then adding 1 to the sum if they are.", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst) == 1:\n        return 0\n    else:\n        # even positions\n           odd_sum = sum(lst[0:lst.index(lst.index(1))])\n            even_sum = sum(lst[lst.index(1):] - odd_sum)\n            return odd_sum + even_sum\n\nSomewhat clever, but it's still a case of \"put the 1st and last elements in a list and do arithmetic on that\" (it's certainly easier than the original puzzle, but it's still a case of \"just do arithmetic on the 1st and last elements\").\n\nHere's another solution to the same problem:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if lst == [] or lst[0] == 0:\n       return 0\n    for j in xrange(0, len(lst) - 1):\n        if lst[j] % 2 == 0:\n           return lst[j] + 1\n    return 0", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    return lst % 2 == 0\n\nThis is kind of neat. It's like an optimization of the \"reverse dictionary sort\" algorithm for single-element arrays.\n\nThis reminds me of my very favorite Python 3.0 feature, the \"reduce\" function.\n\nExcept that reduce is implemented using a list of tuples, not a list of functions. This is interesting, but it doesn't seem to offer much improvement.\n\nI'm not sure it's any better than a for loop. If you want to get fancy, you could probably use a generator expression to produce the functions in a more compact way.\n\nAlso, a for loop can be written using a generator expression.\n\nThis solution is the classic way to sort binary numbers.\n\nI'm having trouble believing this. I think you'd still need to build a stack, and you'd need to do something to keep track of which items have been \"added\" to the stack. It seems like that could be a lot more complicated than just doing it in C.\n\nI think the OP was being sarcastic.\n\noh.\n\nThis would have been more interesting if the challenge was \"given a list of numbers between 0 and 100", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sum(odds(lst), 2)\nThis is a really dumb question, but how do you do the \"odds(lst)\"?\nIt would be handy if you gave a sample solution too.\npython -c \"x = [5, 8, 7, 1] * x[2:end] + x[1:] # Sums the odd integers in even positions\"\nThe actual solution is in the article.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    # Note that this is the definition of solution in the docstring for sum().\n    solution_ = []\n    for i, x in enumerate(lst):\n       solution_.append(sum(i*2+x*2))\n    return solution_\n\n...this doesn't even work. If the given list is [3, 3, 3, 3], then the output will be [1, 5, 9] (and it will be out of range).</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    a = []\n    while lst:\n        a.append(lst[2:] + lst[-2:]*(1.0/2))\n        a.append(lst[1:] + lst[-1:]*(1.0/2))\n    return a\nNote: there is a subtle bug here.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst) == 0:\n        return 0\n    return sum(lst[odd()])", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    odd_even = [0]\n    for i in range(len(lst)):\n        if i % 2 == 0:\n           odd_even.append(i)\n        else:\n           odd_even.append(1)\n    return sum(odd_even)\n\nreturn sum(lst[0:])", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    n = len(lst)\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            sum = i\n              if i % 2 == 0:\n                   sum = sum + sum\n          return sum", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sum(lst[1:nfor(i in lst[2:]) if nfor(i in lst[2:])!= i] + lst[i])\n\nThis code is perfectly correct, but it is also incredibly slow. The complexity of this function is O(n2), which means that it takes a constant number of operations to add two numbers together. This is not good.\n\nThe solution is to use the built-in function sum(), which is already included in the Python interpreter.", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    for i, odd_number in enumerate(lst):\n        if odd_number < i:\n           return odd_number\n    return 0\n\n    return solution(lst)", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    i = 0\n    for i in range(len(lst)):\n        # If the current number is odd, then the number is in the\n        # wrong position, so we add it to the solution.\n        if i % 2!= 0:\n           solution.append(i)\n    return solution", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst)==2:\n        return lst[1][0]\n    else:\n        return 0\n\nI've written something similar to this before, but it was just a simple function. Is there any advantage to the code presented?\n\nI've been writing a lot of python and ruby lately and I'm not sure about the python but the ruby version is much more readable.\n\nI'm not sure I would call it \"readable\" per se, but the python version is certainly more verbose.\n\nI find the python version easier to read, but then I'm a python user.\n\nI thought the ruby version was pretty clear. I haven't written python in a while but I think this is roughly equivalent:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if lst[0]%2 == 0:\n        return lst[1:]+lst[2:]\n\nThis is a _less_ optimal solution than my own (and a lot more popular), but it is of course still optimal:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sum([i for i in list if i % 2 == 0])\nThis is cool because it's easy to understand and easy to modify to produce the sum of the even-indexed elements.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return (len(lst) % 2) + 1", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in range(len(lst)):\n       if i % 2 == 1:\n          sum = sum + i\n    return sum\n    return 0\nThis is a bad answer.  It's not clear from the question whether the \"odd\" and \"even\" labels are arbitrary or whether they have any meaning, e.g., whether you can actually have a list of odd elements.  The answer you gave will happily return zero when there are no odd elements, e.g., it will work for [\"a\", \"b\", \"c\", \"d\"] = [1, 2, 3].  The solution in the link is correct.\n\nSolution (in Python):", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    n = len(lst)\n    for i, odd, j in enumerate(lst):\n        if i % 2 == 0:\n            sum = sum + odd\n           n -= 1\n    return sum", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    if len(lst)==0:\n        return 0\n    elif len(lst)==1:\n        return lst[0]\n    else:\n        return 1\n\nYou might find the following more readable:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    number = len(lst)\n    for i in range(2, number+1):\n         sum = 0\n         for i in range(number):\n              sum += lst[i]\n             if sum == 0:\n                return sum\n    else:\n              return number\n\nWe can use this code to make the solution() function in the above example:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sum(lst[::2] for lst[::2] in lst if lst[::2] % 2 == 0)\n\nYou may want to add the definition of sum in the comments, so that people can run the program without having to look up what sum is, and what ::2 is for.\n\nThe list comprehension syntax makes it appear as though the solution function is operating on one integer at a time.\nWith a for loop you can see that it's summing up all the elements in an odd position.\n\nI use an even more compact solution. Note, the same solution also works for odd numbers.", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in lst:\n       if i % 2 == 0:\n          return i\n\nPython's default implementation of the sum() function is:\n    def sum(lst):\n        return lst.sum()\n\nand is implemented in the builtin Python library.\n\nAnother solution for the problem is:\n    def solution(lst):\n        if len(lst)!= 2:\n           return []\n        for i in range(len(lst) - 1):\n             if i%2==0:\n                 return i\n         return lst\n\nThis is the Python default implementation of the min() function, which is implemented in the builtin Python library.\n\nPython's default implementation of the min() function is:\n    def min(lst):", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sum(set(lst, i % 2 == 0))\n\nYou may want to use a more advanced technique instead, e.g. tree-shaking.\n\nI tried that, it wouldn't work with the default formatting.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in range(len(lst) - 1):\n        if i % 2 == 0:\n           return sum(lst[i:i+2], lst[i+1:i+3]) + sum(lst[i+1:i+2], lst[i+2:i+3])\n    else:\n         return 0", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for elem in list:\n        if elem % 2:\n            return elem+1\n    return 0\n\n    def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in odd positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 21\n    solution([3, 3, 3, 3, 3]) ==> 12\n    solution([30, 13, 24, 321]) ==>18\n    \"\"\"\n    for elem in list:\n        if elem % 2:\n            return elem-1\n    return 0\n\n    def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the even elements that are in odd positions.\n    \n\n    Examples\n    solution([", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    return sum(set(lst, 2) for set(lst, 2) in sorted(lst))\n\nThe arguments to sorted in your example aren't used in the body of the function and could be simplified:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    # A simple example\n    return sum(set(lst, x for x in odd(lst)))\nCan you provide a link for the list comprehension? Thanks!</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    i = 0\n    for j in lst:\n        if j % 2 == 0:\n            i += j\n            j = j % 2\n\nThere is a better way to do this:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in range(1, len(lst)):\n        sum = 0\n        for j in range(2, len(lst)):\n           if j % 2 == 0:\n              sum += lst[i]\n              break\n            return sum", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    if len(lst) == 0:\n        return 0\n    else:\n        total = sum(lst[::2] % 2)\n\n    if total == 0:\n        return 0\n    return total\n\nThis solution looks quite reasonable, but if you were to ask my\nroom-mate he might disagree.\n\nThat's because he thought of a more elegant solution. You can\nsee it here, but don't think he's not a good room-mate because of it.\n\nHope you enjoyed it!\n\nAdrian</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for element in lst:\n        if element not in [2,4,6]:\n           return 0\n        sum += element\n    return sum\n        import sys\n    sys.exit(0)\nI don't understand why they want to wrap a function that takes a list as a parameter.  The function above is so simple that you could easily do it in your head.\nthey've been using that code as an example of how to do a 'for' loop in Python.\nIt was never meant to be used in production code, it's a teaching example.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sum(map(lambda x:x%2,lst))\n\nAnd in java:\nint sumEven(int[] a) {\n    int sum = 0;\n    for (int i = 0; i < a.length; i++) {\n        sum += a[i] % 2;\n    }\n    return sum;\n}\n\nI'd be wary of using map(lambda x: x % 2, lst) as a function call in production code. It might work, but if you change the signature of your function (e.g. by adding a test for evenness, which would cause the behavior of your example to change), it won't compile.\nIn this particular case, it should compile without a problem.\n\nI guess you're right, but my solution is only a one-liner and compiles with a warning:\n\nI'm always amused by the terse comments one finds in code that's never been used by another human being.\n\nthis code is terrible. you should replace it with a for-loop that iterates over the list and adds the odd elements. it", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    return sum(odd(lst))", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    total = 0\n    for i in range(len(lst)-1):\n        if lst[i]%2 == 0:\n            total += lst[i]\n    return total", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return sorted(lst, key=lambda x: x[1] % 2 == 0)\n`for more programming humor `\nNo, for more programming humor you must first store the list of integers in a dictionary.\nDictionaries are usually used to store information about keys, so you can easily look up the corresponding value.  This way, you can look up the values of the odd elements in even positions in the dictionary, and return those values as the sum of the even positions of the odd elements.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    return sum(filter(not(isodd(n)) for n in lst))", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    a = [0] * len(lst)\n    for i in range(2, len(a) + 1):\n        a[i+1] = lst[i] + a[i]\n    return sum(a)\nIf the list is sorted, this will be O(n^2) time, since it'll have to visit every element twice. If the list is already in a certain order, then it'll be O(n), but it's still probably not that efficient.\nAlso, the speed of this function depends on the speed of the shift and sum operations, which can be quite slow.  So while this implementation might be okay for a personal project or toy program, if you are writing a library to be used by other people, you might want to use a faster method (like qsort's selection sort, for example).\nIt is O(n) if the list is already sorted.  And if the list is already sorted, then you don't need to count the number of even positions, since you can just move everything that is in an even position to the end.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    # Take the first element from the list\n\n    oddPos = lambda x: x % 2 == 1\n\n    # Take the difference between each two elements in the list\n\n    oddPos -= list(map(lambda x: x - oddPos, lst))\n    # Add the sum to the original list\n\n    oddPos += list(map(lambda x: x * oddPos, lst))\n    return list(map(lambda x: x + oddPos, lst))\n\nThis should be better:", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    results = []\n    for i, x in enumerate(lst):\n        if x % 2 == 0:\n            results.append(x)\n        results.append(i)\n    return results\nThat's quite a bad example for a solution. It's a classic case of \"what was I thinking\".\nFirst, use the method of induction.\nYou know that the first two numbers are odd. Thus, the third number must be odd.\nThe fourth number must be even. Thus, the sum of the first two is even, and the sum of the third and fourth is even, so the sum of the first three is even.\nTherefore, the last number must be odd, and the sum of the first four numbers is odd.\nNext, use a little more logic. Since the sum of the first four is odd, all of the remaining odd numbers must be in even positions, so just remove them from the list.\n\nYour solution was completely different than mine, but it's really the same thought process.\n\nOops. I misread it.", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i, a in enumerate(lst):\n        if a % 2 == 0:\n            sum += a\n    return sum", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in range(len(lst)):\n        if i % 2 == 1:\n            return solution(lst[i-2]) + solution(lst[i-1])\n    else:\n            return 0\nI was thinking the same thing! I was about to post it and then found your comment.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return solution(lst[::-1])", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return lambda x, y: x+y%2==0\nI think you mean x+y%2==1? Otherwise it only finds the odd numbers.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for i in range(len(lst)):\n       if i % 2 == 0:\n          return sum(lst[i - 1:], lst[i])\n\nSolution in python:\ns = []\nfor i in range(len(lst)):", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    a, b, c = [0, 1, 2],\n    i = len(lst) - 2,\n    j = 0,\n    i2 = i,\n    i3 = i2 + i,\n\n    while a!= 0:\n        i2, i3 = i, i2 + i, i2 + i3\n\n        if i2 == 0:\n            return sum(b[j], j = 0, i = 0, i3 = 0, j + 1)\n          else:\n            i3 = i2 + i\n            j = i3\n            return sum(b[j], j = 0, i = i3, i3 = 0)", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for x, y in lst:\n       if x % 2 == 0:\n          sum += x\n    return sum", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    return lst[(i*2)%2:i*2+2]\n\nI am aware that this is not an optimal solution, but I am curious why.\n\nIt should be clear that the above implementation is not optimal.\nThe best approach is to compute the sum modulo the length of the list.\nIf you are interested in why this is the best approach, I would suggest taking a look at the modulo operator.\n\nWell, it's not really clear why. Could you provide a little more detail?\n\nThe solution is optimal if the length of the input list is a power of 2.\nIn order to compute the sum modulo the length of the list, you can use the modulo operator ( % ).\n\nWell, the code provided is not optimal since it uses a for loop.\nA better approach would be to use the factorial function to compute the sum.\n\nThe better approach is not the factorial function. It's the modulo operator.\nIt's a bit more complicated than just using the factorial function, but the implementation is shorter, and it is much more efficient.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    var a = 0\n    for i in lst:\n        if i % 2 == 0:\n             a += 1\n    return a\nI like it!  I like it a lot.  You can apply this logic recursively (instead of the for loop) to get the sum of all odd numbers that are not in even positions.  I'd write it but I'm on my phone and it's a bit annoying to type it all out.\nI don't like the name.  I think there's something about it that is a bit misleading and I don't know why.\nHm... I just thought of it off the top of my head, so I don't really have any attachment to it.  If you think you can come up with a better name, feel free.  It does do what it says on the tin, though, so it works.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for x in lst:\n        sum = 0\n        if x % 2:\n            sum += x\n    return sum", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for odd, even in enumerate(lst):\n         sum = 0\n         odd = odd * 2\n         even = even % 2\n         sum += odd\n         if odd:\n             sum += even\n            return sum\nNote: I would have gone with `odd = odd % 2` and `even = even % 2`, as then you avoid the      if odd:  and        sum += even  code. You can see where the else branch is likely to get you in this situation.     Also note that a loop is unnecessary if you use `enumerate`, and also note that you don't need to use `while True:` either.\nI think you want `enumerate(lst)[0:2]` instead of `enumerate(lst)`\nYes, that will work too.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    n = len(lst)\n    for x in lst:\n       if x % 2 == 0:\n          return x + n\n    return n\nyou're missing the for loop around the return statement :)\nAlso, the example is using the *programming* subreddit, not the *coding* subreddit.  ;)\nThat's the joke. That's also how I learned Python.\nOK, you can never tell.  There are some people who really are that dumb.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    return sum(lst[1:], lst[2:], lst[3:])\n\nSolution to what, exactly?  I see no problem.\n\nsolution, like all the other challenges, is something to put on your resume.\ni'm guessing the original poster is looking for solutions to their problems.\n\nI am looking for solutions to my problems.\nI have been challenged by the \"Solution\" to do this\n\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\"\nAnd I have done it.\n\nAnd I have done it.\nAs has been mentioned, you haven't though. It doesn't work with all lists.\n\nok.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for s in lst:\n        if s%2==1:\n           return sum(s)\n         else:\n           return 0\n    return sum(solution([0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n\n    return [lst[n] for n in lst if n % 2!= 0]\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n\nI would be very surprised if this solution is _technically_ correct. Here's why:\nI can think of a couple of other solutions:\nsolution = sum(lst) % 2\nsolution = sum(lst) / 2\nIf I understand the problem correctly, the last is the shortest.\nIt is also worth noting that, while the post says the solution is the shortest, it is, in fact, the shortest _non-recursive_ solution, not the shortest solution overall.\n\nI wonder if there is a way to find the shortest recursive solution?\n\nThe solution is pretty complex, so I wouldn't be surprised. I don't really know much about Python, so I don't feel comfortable going into detail. But, based on the fact that the last solution is non-recursive, I think that a recursive solution", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    for num,j in enumerate(lst):\n        if num%2==1:\n           return num+j\n\nBut I need to find the sum of all of the odd elements that are in even positions in the list.</s>", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    # return the sum of the odd numbers that are in even positions\n    return sum(if odd(lst[i]) lst[i], lst)\n\nI feel like this is actually a good solution. If you want to sum the odd numbers in an array, you could just write:\nfor odd in even(myarray):", "def solution(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    solution([5, 8, 7, 1]) ==> 12\n    solution([3, 3, 3, 3, 3]) ==> 9\n    solution([30, 13, 24, 321]) ==>0\n    \"\"\" \"\"\"\n    # skip odd values to start\n    skip = []\n    # look for even values, find the even position, and skip odd values\n    for element in lst:\n        if even(element):\n            # even position, so skip odd values\n             skip.append(element)\n    return sum(skip)\n\nExample 2"]]