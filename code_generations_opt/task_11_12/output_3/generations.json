[["from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    for i in range(0,len(a)):\n        a = a[i] ^ b[i]\n    return a\n\nI prefer the pythonic (and shorter) solution:\n>>> string_xor('010', '110')\n'100'\n>>> b'010'*xor'110'\n'100'\n\nI like this better, too.\n\nI can't think of a reason for anyone to use this unless they were writing a tutorial on Python's built-in string methods.\nThe only possible reason I can think of is that you could use it as an example of how to use Python's built-in string methods.\n\nOr they're actually writing code that needs to do this and don't want to include Python's built-in string methods.\n\nYes, I did this for a fairly large Python project, as part of a fairly long method to convert a byte array to a string (part of a data conversion library, where I had to write to various formats).\nThe byte array was not ordered, and the string I wanted was.\nSo I used string_xor to \"de-base64", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a + b\n\nI like it, but I don't see how it's a good example of what you're saying.\nWhen you XOR strings, you get binary strings, which are usually represented as arrays of bytes. So, for this to be more of a \"pythonic\" version, you'd need to use list comprehensions:\nfrom typing import List", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return '010' ^ '010'\n\nThis would not parse in python.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    # use iterators, this will get you a list of 1s and 0s\n    l = List()\n\n    a1 = l.get(0)\n\n    b1 = l.get(1)\n\n    # binary xor\n    l.set(0, a1.xor(b1))\n\n    l.set(1, b1.xor(a1))\n\n    # output\n    l.set(0, None)\n\n    l.set(1, None)", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    s1 = a\n    s2 = b\n    x = s1 ^ s2\n\n    return x\n\nOk, so it seems like a basic example. I was hoping for a more in depth discussion of the types involved.\n\nI'm not sure what you mean. What's the problem you're having?\n\nThe problem is that I don't see how the types are defined. I can see what the operations are but I don't see how the types are created to match the operations.\n\ntype List[T] = [T]\ntype XorList = [List[T]]</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return ''.join((ord(a[0]) ^ ord(b[0]) for a, b in zip(a, b)))\nThis is more compact:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a = '1' * a + '0' * a\n    b = '1' * b + '0' * b\n    return a * b\n\nThis one is clever. I'm adding it to the list.\n\nIt's kind of fun that so many of these involve integers and string manipulation.\n\nI'm sure that's because those are the sort of things people normally do.\nI'm sure that if I ran a program which involved a lot of time spent calculating trigonometric functions or statistical models, I'd be using those idioms.\n\nMy favorite is the second example:\nimport random", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return (a & b) ^ b\n\n> from typing import List\n>\n>\nI thought that the best way to determine the best type for a function is to try it out. And the best way to try out a function is to call it. And the best way to call it is to use the language's builtin function for calling functions. And the best language for calling functions is Python.\n\nActually, I thought that the best way to determine the best type for a function is to write a program using that function and then look at it, see if you think it's doing the right thing. Then I thought the best way to write a program is to use a syntax that's easy to understand. Then I thought Python is one of the most expressive and powerful languages I know of. Then I thought that it's actually very easy to use the builtin function for calling functions in Python.\n\nI guess the problem is that Python's string type is very flexible, and most people don't have a good feel for when it's appropriate to use a string and when it's appropriate to use a list. The string_xor() function is a good example of that, and using it as a type argument for", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if len(a)!= len(b):\n       raise RuntimeError(\"Input strings must have same length\")\n    x = b.decode('utf-8')\n    y = a.decode('utf-8')\n    if x!= y:\n       return None\n    a_raw = a.encode('utf-8')\n    b_raw = b.encode('utf-8')\n    a_result = string_xor(a_raw, b_raw)\n    return a_result\n\n\"\"\"\n\nfrom typing import List, str", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return str(a) ^ str(b)", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\nA string xor function might have come in handy back in the day.\n\nI see two flaws with this code.\n\\- The line\nreturn a ^ b\ndoesn't compile.\n\\- The name of the function string_xor.\n\nI really hope that the author is using a ^ instead of.* and that their strings are all ASCII.\n\nThis is in Python, so it's very likely they are ASCII, and xor is a builtin operator.\n\nThat's still a dangerous assumption to make.\n\nI don't know about python, but in Java, xor is a built-in operator and is defined to work on bytes.\n\nYep, in Python, xor is also defined to work on bytes, and it's also used to compute the logical XOR of two integers, returning the one with the highest value.\n\nA subtle error in the comments of this code:\n>>> import string_xor\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: name 'list' is not defined\n\nThere are a few other functions in that file,", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if a!= b:\n       return a\n    return \"\"\n\nfrom typing import *", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n\n    for i in range(2, len(a)-1, 2):\n        x = 0\n        for j in range(2, len(b)-1, 2):\n            if a[i]!= b[j]:\n               x = x ^ a[i] ^ b[j]\n    return x\n\nList(string_xor('010', '110')).__class__ == str", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return b | a\n\n>>> import string_xor\n>>> b = string_xor('010', '110')\n>>> b\n'100'\n\nI think this is even better:\nfrom typing import List", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return (a ^ b) ^ b\nI had to check the code to see if it was Python.\n\nWhy is the main() function not returning a string? It's such a simple function that there's no reason not to.\nI have seen enough bad Python to believe it is possible that that is the case.\n\nIt's an example from the author's code.\nThe function is not returning a string because it's not implemented, since the code is an example of what could be implemented.\n\nOh, I misunderstood what was going on there. Thanks for clearing it up.\n\nIt's like Ruby's \"from __import__\"\n\nFor those who don't know, in Python the built-in function called'string' returns a list of characters.\n\nThe worst thing about Python is the lack of a solid string type.\n\nReally? That's the \"worst thing\" you could come up with?\n\nI think it's a valid point. The type of strings is... a string. And if you need to store an actual string in memory, you're supposed to store the bytes of the string. And the string's memory representation depends on the current locale, too.", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return (''.join(str(a ^ b) for a, b in zip(a, b)))\n\nI think you can get rid of the list comprehension and just write:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n\n    return string.binary_xor(a, b)\n\nWhat exactly is the use case for this? I've never seen a function that does this but is in python. The only case I can think of is some kind of a binary to ascii converter?\n\nI'm not the OP, but I have found myself writing this on occasion, and I'm guessing that is the case. In particular, if you're doing a lot of data parsing or web scraping, you often have to take a binary format and turn it into a usable data structure, which often means xor-ing it with a constant string and taking the resulting string.\n\nI don't know why there's a new XKCD every day.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a \\\n    | b\n\nand the way to call it:\n>>> string_xor(110,010)\n'100'\n>>> string_xor(\"010\", \"010\")\n'1000'\n>>> string_xor(\"010\", \"010\")\n'0110'</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return ''.join([str(a) ^ str(b) for a, b in enumerate(a.split())])\nThis is great! I've been looking for something like this for a long time.\n\nIt's also a builtin in Python 2.\n\nAnybody have a high-level writeup on the advantages of Python 3? I tried to look it up but most of what I find is either (a) partisan or (b) technical.\n\nA pretty good set of differences is here: \n\nI'd like to make a short comment about your comment:\nI've noticed that the python 3 advocates are also the most vocal advocates.\nI have a friend who is a python 3 advocate, and he always posts things like this on facebook (amongst many other things about python 3).\nI'm not sure if this is just a personal observation or if anyone else has noticed this.\nI personally like python 2.6, but that is because I like to keep my scripts as portable as possible. I think that most of the advantages of python 3 are pretty much useless, and they are things that should be handled at the library level.\nI think that the most important thing", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return str(a ^ b)\nWhat's the point of this?\n\nIt's part of a testing framework. In a nutshell, you write your tests in Python (using the typing module), and when the test suite is run you can use these functions to run them against a suite of test input files.\n\nIt's not clear how the author is using the \"testing framework\".\nThere is no explanation on how the tests are written, where they are stored, how the tests are run, etc.\n\nYeah, it's pretty light on details. I think the idea is that you have a file full of test cases and you have a command-line tool which takes a test case and an input file, runs the test, then returns the result of that test. You also have a way to get all the test results back in one go.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a.decode('hex').take(8).decode('hex')", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a XOR b\n\nWhy would you need this?\n\nXOR is frequently used as a cipher.\n\nWhere would you use this instead of a generator or a set of one-liners?\n\nCiphers aren't meant to be used in software, but if you do, you might want to use this kind of code.\n\nWhat about ciphers like RC4?\n\nI wouldn't use them, but if you do, you might want to use this kind of code.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if a[1] == b[1]:\n        return a\n    else:\n        return b</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a = b\n    return a[0] & b[0]\nfor n in range(5):", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return ''*a + b\n\n That's not xor. It's just \"concatenate\", with a fancy name.\nXOR is a function that takes two inputs a and b and returns true iff and only if a and b are different.\nYour function does not do that.\n\nIt does that if the two arguments are in ASCII.\n\nIt's still not xor because it doesn't return a boolean value.\n\nIt's an awful name for it.\n\nYou're missing the point. It's not an xor function because it doesn't return a boolean value.\n\nFrom the link:\n\"The name is not very good because it is not a very good xor function, but it's a good string-xor function.\"\n\nOne problem with this is that it will output some single-character strings.\nFor example, \"0101\" becomes \"1\", which is unexpected.\n\nYes, and \"1111\" becomes \"11\", and \"10101\" becomes \"1\", and so on.\nYou can fix this by making it explicitly convert the inputs to integers:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return \"\".join(chr(ord(a) ^ ord(b)))\n\nThis is one of the best Python examples I've seen for how useful the syntax is. This code is so easy to read and understand.\n\nI love Python's syntax but personally I'd use an actual function instead of string_xor. In the event I want to invoke the function on a string that is not an array of characters I can pass it a string[].\nIt would look like this:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return \"\"", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if a == b:\n       return a\n    else:\n       return b</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n\n    return a XOR b\n\nI found that while some of the comments were a bit harsh, they were all pretty accurate in describing this code as very slow, not so readable, and unoptimized.\n\nIt was very fast for me.\nAnd it was very readable.\nWhat's unoptimized about it? What should be optimized?\n\nIf you're only performing string XOR, then you should replace the `a XOR b` bit with a single `a OR b`.\n\n_edit_ : Oh, I see you did that, it was already in the source code.\n\nThis is a great example of a non-scalable algorithm.\n\nIt depends on the purpose of the code. If you're using it in a _one-off_ script, it is quite fast. If you're using it in a large program, it will probably still be pretty fast, and you can always do the optimizations you suggest. If you're using it in a very large program, it is probably better to use a different algorithm.\n\nYou don't do optimization before you need to.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return string.gsub(a, b, '0', '1').gsub(b, a, '0', '1')\n\nfrom typing import *", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\nthis is silly... the author should have defined the function as", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\n>>> print string_xor('010', '110')\n'100'\n\ni love languages that have the operators such as a ^ b as built-ins... but i can't figure out why they are?\nthey're simple, but also completely useless for any real-world application. what's the use case here?\ni suppose it's easy to implement but it's not something that would ever come up in the course of developing anything serious.\n\nAn example of a use case would be a generic string parsing function that accepts a string with only 0s and 1s.\n\nYes, but a ^ b is hardly the only way to do that.\n\nThere is a large difference between being the most efficient and being the easiest to understand and implement.\n\nOnly if you're a freshman.\n\nI'm a senior in a Computer Science program, and I consider myself a competent programmer. I know how to write a bubble sort, a quicksort, a radix sort, a heap sort, and a binary search. I can write a breadth-first search or a depth-first search from scratch. I know how to generate a sorted array using a merge sort.", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return string.hexdigits(a ^ b)\n\nThis is really a cool idea. I'm going to remember this for future use.\nI'm curious if there is some way to make this more efficient though? Like maybe an index of the 1's and 0's, in a way that would make the lookup faster.\n\nI'm thinking in terms of Python's built-in urllib.urlopen -\nI guess you could have two functions - one which implements the XOR function, and one which implements the string.hexdigits method. You would then pass a function which returns the index of the 1 or 0 into the latter function.\n\nI was thinking something along these lines as well. I was also thinking you might be able to do some statistical analysis of the string to determine where the 1's and 0's were more likely to be.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a, b = List(a), List(b)\n    if len(a)!= len(b):\n        raise ValueError(\"Inputs must be of equal length\")\n    return b[0] ^ a[1]</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a = a.replace(r'\\0', '0')\n\n    return a + b.replace(r'\\0', '0') + b.replace(r'0', '1')</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return string.ascii_lowercase(a ^ b).lower()\n\nxor is not a function, but the name of the operator used for the XOR operation.\n\nis that a bad thing? i thought that was how it was done.\n\nIt's not a bad thing, but it makes a little harder to understand the code.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a XOR b\n\n>>> string_xor('010', '100')\n'110'\n\n> string_xor('010', '100')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nAttributeError:'str' object has no attribute 'XOR'\n\nYou have a typo in your example; it should be \"010\" and \"110\"\n\nPython 2.7.2, jython 2.5.0.\n\nActually, it's not a typo; it's a missing <>.\n\nI had to look at the source to see where the problem was. I'm still not sure what the code is trying to do.\n\nI suppose it's a joke on the whole \"XOR is a very special bitwise operator\" meme.\n\nAhhh.. I feel so stupid right now!\n\nI'm not sure where the downvotes are coming from. This is just an example of how \"meta\" posts like this, which point out the humor of the original post, often get fewer votes than the original post itself.\n\nI think it's just the natural result of being", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\nI always find it strange that Python's `[]` is not a list type.\n\nPython is dynamically typed.\n\nWell, so are most languages that have a list type.\n\nThe lists are dynamically typed, not Python.\n\nC# has list and array types.\n\nDoes it? I thought it was all dynamic.\n\nThere are static typed lists and arrays.\n\nHow does one construct a static list in C#?\n\nYou declare it as an array of T, instantiate it, and then turn it into a List.\n\nI'm a little disappointed that the type system is so weak. It seems that the author couldn't think of anything to do with the type system that would be interesting, so he chose to make the type system _useless_.\nWhat's the use of having a type system if it can't detect the most basic of typos?\n\nThe use of having a type system is to not have to write as much boilerplate as you would otherwise.\n\nI'm still disappointed.\n\nI think it's more of a testament to the simplicity and expressive power of the Python syntax than anything else.\n\nI always", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a_1 = int(b) + 1\n    b_1 = int(a) + 1\n    return int(a_1 ^ b_1)\n\nand the equivalent python:\nfrom typing import List", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a, b = a, b\n\n    return List(str(a ^ b))\n\nI was gonna post this to reddit, but I guess there are people here too.\n\nIs there something I'm missing here?\n\nNot really. I've found this to be a really good way to get my mind going on how to solve a problem. I imagine it would be especially useful for people new to python who need to get their heads around iterators, the various data types and what not.\n\nI was just making a joke about the fact that the title says \"from typing import List\" while the example is actually \"from typing import String\" and has nothing to do with \"List\".\n\nI did that on purpose. I was trying to set it up as a joke that List() was the one that should be imported and \"list\" was just a typo.\n\nWow, I'm sorry, I'm stupid, I didn't even notice that. It's early in the morning here and I haven't had any coffee.\n\nI was hoping this would output \"01010\" and \"11011\" and be a simple explanation of Python's string type.\n\nNow this is one", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a.xor(b)\n\nI always wondered why people use words like \"array\", \"list\", \"tuple\" to refer to objects in Python. It's very confusing. It's not like there's a dearth of synonyms. \"Array\" is a fine word, but why do people like to invent new words for things that already have perfectly good names?\n\nSo you're saying that you're confused by the words \"list\", \"array\", and \"tuple\"?\n\nI'm confused by people inventing new words for things that already have names.\n\nI know what you mean, but this is a (really old) language quirk. Some people just prefer using the words \"list\", \"array\", and \"tuple\" (or sometimes \"sequence\") for the same thing, because it's more descriptive of what's going on.\n\nWhat's the point of inventing new words for things that already have perfectly good names? It's not like the words are ambiguous.\n\nBecause sometimes the things you're working with _aren't_ perfect. Sometimes the names are wrong.\n\nOf course they're perfect. It's the only thing in the Python language that _is", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\nIs this a joke?\n\nYou are not familiar with Python's List class?\n\nYes. I'm familiar with it. And this is a code sample on how to use it.\nHow is this news?\n\nBecause the \"import\" syntax is new to Python 3.\n\nand it's the first time I've ever seen it used.\n\n_\"Let's be honest here, we don't really care about how to use Python's standard library.\"_\nThat's fine. If you don't care, you won't use the article. You won't be affected by the article.\nBut you're in the minority. There are plenty of people who want to learn Python, who would be affected by this article. And who would be excited to see a \"real world\" use of a standard library function.\n\nI get that there's a lot of people who don't know how to use python's standard library. That doesn't mean it's news. It's like saying \"how to use the str() method\" is news.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    # First, convert both strings into binary form.\n    b = b.encode('ascii', 'ignore')\n    a = a.encode('ascii', 'ignore')\n    # Perform the binary XOR between two binary strings.\n    return b.xor(a, 'ascii')\n\nThis is not useful for much. If you want a function to do this, it should be of the form:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a.index('0') + b.index('0')\n\nbwahahahah!\n\nwtf, that's not even python\n\nI love the python community</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a = [0x0] * a\n    b = [0x1] * b\n    return b ^ a\n\nA more useful version might be:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n\n    return a.xor(b)</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if a: isinstance(a, str):\n       return b:\n    else:\n       return ''.join(a:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a = '010'\n    b = '110'\n\n    result = ''\n\n    while a!= b:\n        if a!= b:\n           result += a\n        a = b\n\n    return result\nI don't get it. This is a joke right?\n\nIt's a pretty simple example of binary XOR.\n\nThe problem is that it is a bad example.\nfor example if a=010 and b=110 then result=0101, not 100.\n\nI didn't understand it at first, either, but I think it's a good example of a more general principle: that you shouldn't write long functions to do simple things.\nInstead, a function for string_xor should do two things:\n1\\. Read the input strings.\n2\\. Perform the desired operation on the input strings.\nThis is a general principle that I've found applies to more than just string operations, too: it's a good idea to separate the functions you write into small pieces, so that you can better understand the program's flow, and", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return string(int(a & b))\n\nWhile this is interesting, it's also a bit of a straw man. Python's syntax for string handling is just way too complicated. It doesn't have a simple, readable syntax for concatenating strings that don't already have a delimiter.\n\nYes, this. That's why I prefer C++ string handling.\n\nWhy so?\n\nBecause of std::string.\n\nYes, because C++ is the one language that doesn't have a built in string class, so it's really important to shoehorn one in there with a large, complicated API.\n\nThere is also no built-in enum class, but they went and added one in C++11 anyway.\n\nThe thing about std::string is that it's an incredibly complicated API that's really hard to use correctly, but it's also the only one that's standardised and guaranteed to be available in every modern C++ compiler. The standard C++ string class is basically a joke.\n\nIf you don't like the syntax, you can always write your own class. As long as you follow the rules for allocating, copying, and manipulating strings, you're good to go.", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    # add 1 to both inputs\n    a += 1\n    b += 1\n    return a XOR b\n\nI see. Is there a site that has a list of \"cool\" python tricks, like this?\n\nThe list module is the default standard library module, so you don't really need to import it. That's like importing 'list' in C.\n\nWell, you can't import a module without importing the whole standard library, so...\n\nThe question was about cool tricks, not cool ways to do things.\n\nIt looks like this is something you'd want to use:\nfrom itertools import izip\nfrom typing import List", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return string.gsub(b, '0', '1')\n\nThat's a good example of how not to write a string xor function. It's not only too long, it's also a bit too clever (the 0-1 conversions and the gsub). Here's a better version:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return '1' if a == b else '0'\n\nI think it's interesting that python has a list type, but lacks string concatenation.\n\nI'd say it's an artifact of it being a dynamic language.\n\nThat's not why. The reason is that string concatenation is a non-trivial thing to get right, and it's not worth trying to get it right for most of the cases where it's needed.\nThe main problem with string concatenation is that it's generally recursive: you want to append a string to another, but in order to do that you need to know the length of the result and/or be able to accurately estimate it, otherwise you'll have a crash if you run out of memory, or a runtime error if you run out of stack.\nThe result is that it's pretty easy to write a string concatenation algorithm that works in most cases, but much more difficult to write one that's correct in all cases. Python does the reasonable thing, which is to only provide a useful algorithm in the common case, and to let you use Python's powerful string types and functions to write a specialized string concatenation algorithm for the less common cases", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    result = ''\n    while len(a)!= len(b):\n       a = b = a ^ b\n       result += a\n    return result\n\nI know its nitpicking but list is not a type, it is a data structure.\n\nin which case we could say \"from type import [list]\".\n\nThe Python documentation explains that 'type' is a keyword that refers to the type of an object (class, module, function, etc.), not the type of the code written in Python.\n\nIt's interesting that the Python documentation warns against using the 'type' keyword for functions, since one of the most useful features of the Python type system is the ability to catch errors at the type level.\n\nThis is useful, but it's more of a feature of the language than of the type system. Python has dynamic typing, which means that the compiler doesn't check the types of anything. In statically typed languages, such as Haskell, the compiler will catch type errors (and a lot of other errors).\n\nI used to do a lot of Python, but more recently I've switched to Haskell, where I've", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    # Interpretation depends on the platform and the compiler, use the platform's default\n    return a ^ b\n\nThat is a rather poor example. In Python, you would use 0b10 + 0b11 instead of xor. Or if you prefer the C-like solution, use a string of 0b11 instead.\n\n\"Input are two strings a and b consisting only of 1s and 0s.\"\nHow many programmers are going to assume that their strings are stored as 0b1101010, rather than 0b10011110?\n\nYou can't assume anything, you have to read the code to see how it was implemented.\n\nI like this better:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return list(a+b)\n\nThis is, of course, highly inefficient. It's using a list for a simple string operation.\nMy code actually looks like this:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return (a ^ b) ^ b\n\nNice. Forgot this was possible.\n\nPython 2.5 and 2.6 has some really nice stuff like this.\n\nIt looks like python 2.5 and 2.6 will be merged at the same time.\n\nThis is pretty cool, but is there any practical application?\n\nYou would be surprised how many applications this has. It might be less useful for the average programmer (how many times do you find yourself needing to do string XOR?), but for people who do a lot of data manipulation, this is very useful.\nExample: I was doing a lot of XML parsing in Python a while back and had to do a lot of string XOR. Also, doing a lot of string manipulation in general.\n\nThis is way too easy.\n\nIf you can do this without using \"to_string\", then you've got yourself an open-sourced \"a\" and \"b\" (whatever those are) and you can make the decision to use Python 3.\n\nI'm a Python 3.0 user and all, but this is not a very good argument.\n\nI thought it was pretty funny...</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\n I know the article is about object oriented programming, but that one is just egregious. How do you even do that in Python without copy/pasting the whole list?", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a | b\n\nPython doesn't have a C-style string type. Lists are immutable.\n\nYes, it's more like", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    # Binary XOR\n    return a ^ b", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a XOR b\nIt's a shame the built-in \"str\" object doesn't include a constructor.\n\nYes, that was a choice. str is pretty much a sugar-coated list of chars.\n\nIt's one of the things I don't like about Python. For example, the division operator has to be made of two pieces in order to be used correctly:\n>>> (a / b) * (c / d)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"/usr/lib/python2.7/divide.py\", line 83, in __call__\nreturn self.__divide__(self, *args, **kwargs)\nFile \"/usr/lib/python2.7/divide.py\", line 139, in __divide__", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return '\\x01\\x00' + a + '\\x01\\x00' + b\n\nxor of integers (2's complement) can be found in :\nhttp://www.ccs.neu.edu/home/matthias/pubs/book/book.pdf</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\nfrom typing import List", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\nIt's the first one I came up with, but it's not very good.\nThe problem is that it's wrong, and will fail for inputs like \"010\" + \"010\".\n\nI'm having a hard time understanding why it's wrong. Could you explain?\n\nI think the parent poster is saying that it is a bug, because if you consider the input \"010\" + \"010\", you should consider the input \"010\" + \"010\" + \"011\", and \"010\" + \"011\"!= \"110\".\nThe parent poster is likely wrong, because the code is not wrong. The code is only wrong if you consider \"010\" + \"010\" + \"011\" to be the same as \"010\" + \"010\" + \"011\".\nI think the author of the code wanted the code to work when \"010\" + \"010\" + \"011\" is the same as \"010\" + \"010\" + \"011\" + \"110\", so he wrote the code correctly.\n\nI think the parent is suggesting that the code is wrong because it fails to return \"010\" + \"110\" when passed in \"010\" +", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return '1' * (a & b)", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return (a ^ b) ^ b\n\n    def string_shift(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary shift on these inputs and return result also as a string.\n    >>> string_shift('010', '110')\n    '100'\n    \"\"\"\n    return (a >> b) & 0xFF\n\n    def string_substring(a: str, b: str, start: int, stop: int) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary substring on these inputs and return result also as a string.\n    >>> string_substring('010', '110', 2)\n    '010'\n    \"\"\"\n    return (a & b) ^ (start - start ^ stop)\n\nThis is just awesome. I love it.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a.encode('hex')\n    b.encode('hex')\n    for x in range(1,length(a)):\n       for y in range(1,length(b)):\n         if a[x] == b[y]:\n              return a[x] + b[y]\n    return a\n\nNice.\nIt might be more readable if you use a list comprehension instead of range.\n\nIs there a benefit to using list comprehension over range in this case?\n\nI think the benefit is that list comprehension has a readable syntax, whereas range is a little bit ugly.\n\nI think the point was more that Python lists are more naturally suited to implementing a for loop than a range.\n\nMy problem with list comprehension is that I don't find the syntax particularly readable (it is in this case, but in general I find it hard to figure out what the loop is doing just by reading it).\n\n\"Is there a benefit to using list comprehension over range in this case?\"\n\"I think the benefit", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a:List(str) = []\n    b:List(str) = []\n    for i in range(len(a)):\n        if a[i]!= 0:\n            a.append(String(b[i] & 0x80))\n           a.append(String(b[i] & 0x40))\n           b.append(String(a[i] & 0x80))\n           b.append(String(a[i] & 0x40))\n    return a\n\nI've been coding in Python for a few years now, but I had to look up the \"list concatenation\" operator you used in your example. I'd like to understand the reason for it.\nDo you mind explaining what it does? I thought Python's for loop syntax was already concise enough to avoid this sort of thing.\n\nPython's string syntax is very concise. I've never found it to be a problem.", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n\n    s1 = a\n    s2 = b\n    return (s1 ^ s2)\n\nthis should be a function:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return (a ^ b).decode('hex')\n\n>>> string_xor(\"010\", \"110\")\n\"100\"\n>>>\n\nThe actual code:\n\nfrom typing import List", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return (a ^ b) ^ b\n\nso, it's an XOR then, right?\n\nI've never had a course that taught this.\n\nMe neither, but it seems pretty obvious.\n\nI love how the author takes the time to describe the problem, explain the solution and then explain why this solution is a good one.\nThis is the best tutorial I've ever read.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return b ^ a\n\n\t\tdef string_xor_only(a: str, b: str) -> str:\n\t\t    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n\t\t Perform XOR on these inputs and return result also as a string.\n\t\t >>> string_xor_only('010', '010')\n\t\t '101'\n\t\t \"\"\"\n\t\treturn b ^ a\n\nI don't know what this is, but I know it's not Haskell.\n\nIt is Haskell, but it's not Haskell with the \"command-line\" package installed.\nIt's just a simple function that takes two strings and returns another.\nThat is a perfectly valid Haskell program (with a bit of syntactical sugar).\n\nNice.\nThe only thing I'm missing is the ability to print the value of a function. In Python this is done with `print(name)` which shows the name of the function and its argument.\n\nThanks, I was wondering how to do that.\n\nI like it!</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return'\\x00 '*(a ^ b)\n\nI know I am stupid but the code above does not work. I got \"\".\nI know this is trivial but I am trying to understand what is wrong. Thanks.\n\nTry \"0101\" and \"0110\".</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return b \\ | xor(a, b)\nNow that's beautiful!\n\nIt's also surprisingly simple to implement.\n\nThis is sort of similar to the PostScript Boolean operator ( | ), which takes two paths and outputs the left path if it exists, and the right path otherwise.\n\nI don't like Python's use of \" | \" as a boolean operator. It seems to me that it was added to the language just because it was convenient to have an operator for it.\n\nIt's been part of the language for a long time. What do you mean \"added\"?\n\nIt has been in the language from the beginning.\n\nThis is part of the philosophy behind Python: you can do a lot with few things. Also, you can use any (valid) Python expression as a function name.\n\nThe last bit is actually the more interesting bit. There are a few other languages that do that.\nIn Scheme, you can use any valid R5RS expression as a function. (including things like lambda).\nIn Factor you can do the same with the full Factor language.\nIn Clean, you can do the same with the full Clean language.\nIn CLU, you", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\nThis is one of the coolest things I've seen all day. I've never really thought of it in terms of functions.\n\nIs this useful? I always thought of functions as the smallest unit of programming.\n\nIt's an abstract concept in most languages, but it is very concrete in assembly, where it's pretty much the only way to express a sequence of instructions.\n\nIn assembly, functions are usually the smallest unit of programming, but you can also express statements as functions (albeit at a higher level than you can in higher-level languages), which is what the code above does.\n\nActually the binary XOR operator isn't written as a function, it is a binary operator.\n\nCan someone enlighten me as to what the purpose of this is?\n\nFor example, in C:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return xor(a, b)\n\nCode like this is great in one sense, but I think it's misleading to call it a \"pythonic\" solution. It's a solution to a problem that happens to use a pythonic API, but the problem is not \"implement string xor in Python.\" The problem is \"implement binary xor in Python.\"\n\nYou're right that the goal is not to write a Python program in Python. The question was how to write it in Pythonic way.\n\nI think a big reason people use python is that it's more pythonic to do it the hard way.\n\nIt's not Pythonic, it's just that some of us would rather use what's actually built in, than waste time writing things that are already written.\nAnd I'm not sure how you can say that it's the hard way.\n\nIt's definitely the hard way, and it's definitely pythonic. Not using builtins and writing a function that does the right thing is a lot more pythonic than using builtins. And why not, if it's easy to write the function?\n\n\"It's definitely the hard way\"\nPlease explain.\n\"and", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return b if a == b else None\n\n    def string_add(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform addition on these inputs and return result also as a string.\n    >>> string_add('010', '110')\n    '011'\n    \"\"\"\n    return '1' + (b.find(a).find(b))", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if a[0] == b[0] and a[1] == b[1]:\n        return b\n    return a\n\nPretty cool, but note it's case sensitive.\n\nJust use regular expressions and call it a day...\n\nThis is very cool!</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    x = 0\n    while a[x]!= b[x]:\n       x = x + 1\n\n    return x\n\nThis is a great example of the power of Python. (And it's also a great example of why you should use a module from python.org for string manipulation.)\n\nI agree. The only thing I would add is that in the case of this snippet, Python does it way better than any other language I know. It is concise, clear, and readable.\n\nIt is also very nearly optimal for this task. If you care about the maximum length of the result, you can use a few bytes more by (a) replacing the while loop with a while True (b) using a generator instead of a list (c) use a dictionary instead of a list (d) use a tuple instead of a list. If you don't care about the maximum length, you can replace the x variable with a function call that constructs the x and the x + 1 values, and you can replace the while loop with a map.\n\nI think the while True loop actually uses more memory. Generators are a lot more efficient than lists, though.", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if a: str.startswith('0') or b: str.startswith('0'):\n        return a\n    return b\n\nThis is much more readable than any of the idiomatic Python solutions.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    try:\n       a = 0\n       b = 0\n\n       while a!= b:\n          a, b = a ^ b\n          # Output is also in binary\n          return b\n       # These are two strings, not integers\n    except ZeroDivisionError:\n          raise ValueError", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return'\\x01\\x01\\x00\\x00\\x00 '\n\nI have to say, it's nice to see someone using Python in a real-world application.\nIt's too bad that Python's standard library isn't as rich as Ruby's, though. If it was, you could write something like", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if len(a) == len(b):\n        return a\n    else:\n        return a ^ b\n\nI'd use this if I could pass in a third argument indicating if the result is a char or a byte.\n\nYou can. It's called repr.\n\nAFAIK repr is a python3-only feature.\n\nWhich you can easily work around by using py3k.\n\nBut then you need to install a python3 environment (and/or some libraries) on all your machines.\n\nAre you implying that installing the Python 3 runtime is somehow more difficult than installing Python 2?\n\nI was thinking of a Linux server. That would mean installing the python3-dev package (or python3-xxx if you use a version with a different name).\n\nNo, you just need to install python3.\n\nNot if you use a different version of Python (e.g. 2.5), since Python 3 does not support Python 2's standard library.\n\nYou're completely missing the point. You said you need to install Python 3 and a bunch of libraries in order to run Python", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return b!= a\nI see a nice thing about that function, but I can't quite put my finger on it.\n\nNote that this is equivalent to:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\nI can't decide if this is the worst code in this thread, or the best.\n\nIt's the best! I love how it has a helpful comment. :)\n\nI love the implicit boolean type conversion.\n\nXOR is XOR, whether you do it with integers or floating point numbers. It's just a very simple boolean operation.\n\nThe python is wrong. It's \"string_xor\" not \"string_xor\".\n\nI think the OP just wanted to use the string form of the function as a way of commenting on how the implementation differs from the mathematical definition.\n\nEven then, the _ is used for _strings_, not _classes_, so the'string_' is redundant.\n\nThat is only true in Python.\n\nWell, the _string_ suffix is specifically used in Python to indicate a method, so it makes sense to use it for functions that return strings.\n\nI think the \"string_\" is redundant as well, but I think it is just the OP's style.\n\nThe author is assuming that 'a' and 'b' are ASCII strings. I've seen this assumption before in Python", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n        return '01'\n\nfrom typing import *", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a & b\n\nIt's not a trivial problem. It's one of those cases where it's easy to think you've solved the problem and be wrong, but I don't think you can ever say for sure that it can't be done, it's just that nobody has done it yet.\nOne interesting thing about this problem is that it has the same time complexity as the more mundane problem of factoring a number (assuming a = b = n and p is prime).\n\n_It's not a trivial problem. It's one of those cases where it's easy to think you've solved the problem and be wrong, but I don't think you can ever say for sure that it can't be done, it's just that nobody has done it yet._\nIt can't be done.\n(The proof is simple; you can find it in Knuth's Art of Computer Programming.)\n\nHere is the proof of the result that the problem is intractable.\n\nInteresting that Python has that. Even though I've used Python for years, I've never seen that one.\n\nSo if you feed the string_xor function the string \"010\" and the string \"110\", you'll", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a + b", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    result = \"\"\n    for i in range(len(a)):\n        if a[i] == 0:\n           result += \"01\"\n         else:\n           result += \"10\"\n        result += \"00\"\n    return result\n\nimport string_xor", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return list(a.encode('hex'), b.encode('hex'))", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return b.lower() + a.lower() +''\n\nI wonder how this compares to a \"good\" solution. It seems like the problem space is NP-complete, and in particular the problem of finding the shortest of a fixed number of strings of a fixed length. Is the naive solution actually close to the optimum?\n\nIt's not NP-complete; it's probably PSPACE-hard.\nYou can solve it in linear time with a quick binary search over the input list.\n\nThat is an interesting idea, I hadn't thought of that. But it doesn't really get at the question of whether the naive solution is a good one.\n\nWhy would it not be? If you have a fixed length list of strings (and you should, since the space of strings is at least exponential in the length), then you can determine the shortest using this method in linear time. If you have to add more than one element to the list to make it have the same length, you can add all of them at once with this method.\nIt's hard to get much faster than that without using some algorithm that's specialized to the problem.\n\nIsn't this a variation of the birthday paradox problem?", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return (a ^ b) ^ (a ^ b)\n\nSomeone please explain this to me! I'm really curious, because I can't figure out what it's doing.\n\nThe input is two strings a and b consisting only of 1s and 0s.\nThe function will perform binary XOR on these inputs and return result also as a string.\n>>> string_xor('010', '110')\n'100'\n\na ^ b ^ (a ^ b)\nIt's two nested loops, one for each a and b, starting from the first character. The condition is a ^ b, so that when you reach the loop for the second a or b, it will only do the first iteration of the inner loop.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if a in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z]:\n        return string_xor(a, b)\n    return \"\".join(string_xor(a, b))\n\nSo what is the purpose of this?\n\nTo post it here and receive lots of karma.\n\nI like to think of karma as something like the total points a user has\nreceived for all of their submissions/comments. It's nice to be able to\ncompare users to each other like this, but what's the point of the\nnumerical score?\n\nIt's not only about comparing users to each other. I know that when I hit\nthe \"+1\" button I am trying to send a signal to the community about how\nvaluable the submission is. (Hence the karma score.) I think that's a\nuseful signal to", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\nSince a and b are supposed to be 1s and 0s, this will always be equal to the length of a plus the length of b. It's the equivalent of \"a ^ b\".\n\nNot quite, because it's not really a function, rather it's a string that can be passed to a function that would otherwise accept two integers as parameters.\n\nAh, thanks for the correction.\n\nFrom the \"overloading\" section:\nThe more correct name would be overloading, not overloading.\n\nFixed! Thanks.\n\nIt also says \"However, overloading is a language feature, so you can do it in any language that has the feature.\"\nPython does not have overloading, which is a feature in C++. In Python, we call it \"generics\".\n\nIndeed, I read about that at some point but forgot. Thanks for the reminder.\n\nfrom typing import List\nnot from typing import List[Int]\nor is it\nfrom typing import List\nand not\nfrom typing import List[Int]\n\nThis is a very nice introduction for beginners, and I'm tempted to use it in my own Python education materials.", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\nOh how I hate this kind of thing, a bunch of people coding for themselves. The whole point of Python is that you write code for other people to use.\n\nJust because the \"whole point of Python\" is to write code for other people to use doesn't mean that all code has to be written with this goal in mind.\nI use Python mostly for personal projects, and I find that I can write code that is just as easy to read, and just as easy to maintain, as code that was written for others to use.\n\nAnd yet you're not writing it in Python:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return '\\x01' * (a ^ b)\nI've always written it as (a ^ b) ^ a, and when teaching I've always used the 'xor' symbol to be as clear as possible. I think this is the best way to do it, not sure how much clearer this could be.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    xor = False\n    while True:\n       xor = xor or a[0]!= b[0] or a[1]!= b[1] or a[2]!= b[2] or a[3]!= b[3]\n    return xor or b[0] == a[0] or a[1] == b[1] or a[2] == b[2] or a[3] == b[3]\n\nfrom string import lowercase, uppercase", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\n    print string_xor('010', '110')\n\nThanks for the tip, I've never thought of doing this. I've been using Python for about 4 years now and have probably written several thousand lines of code.\nBut why is the first example necessary? Can't you just do", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a2 = a.encode('ascii')\n    b2 = b.encode('ascii')\n    if a2 == b2:\n       return a2 + '0' + b2 + '0'\n    else:\n       return string_xor(a2, b2)\n\n\"a\" in that code is a string that \"consists only of 1s and 0s\".\nBut it's not the only one:\n\"010\" in that code is a string that \"consists only of 1s and 0s\".\nBut it's not the only one:\n\"0110\" in that code is a string that \"consists only of 1s and 0s\".\nBut it's not the only one:\n\"0101\" in that code is a string that \"consists only of 1s and 0s\".\nBut it's not the only one:\n\"01000\" in that code is a string that \"consists only of 1s and 0s\".\nBut it's not the only one:\n\"010001\" in that code", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return xor(a, b)\n\nThis is a common idiom in Python. I like the fact that you can write the string xor function with a single line and it is not like the classic C code where the xor function would take a few lines of code.\nIt is also a good way to introduce the language for people who are not familiar with it.\n\nYou can do the same thing in C.\n\nSo you would use strcpy instead of std::string? I don't know the C standard library very well, but it's possible that the standard library implementation of xor is more efficient than the Python implementation (though I doubt it).\n\nIt's a really bad example, but not one I would use to introduce someone to Python. It's very unlikely that someone would need to do this in production code, and it's somewhat difficult to grok the one-liner at first glance.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    x = a[:0]\n    y = b[:0]\n    if x[0] == 1:\n        return '0'\n    else:\n        return '1'\n\nNo comments on the code itself, but I noticed that the author used the 'x' operator for concatenation, as in \"x = x + x\". This makes the code more verbose than it could be. I find it easier to understand and maintain code that uses the '+' operator for concatenation, as in \"a += b\".\n\nI agree with you in general. But I think the motivation for using x for concatenation is the fact that in python an empty string is 0, which makes the first example shorter, e.g.:\nstring_xor('010', '110') #= '100'\nvs.\nstring_xor('010', '110') + '100'\nHowever, I'm not sure if that justifies the change.\n\nI'm not sure I understand the author's motivation at all. It seems like they are trying to illustrate that Python's", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n\n    return a & b", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if len(a) > len(b):\n       raise TypeError, \"a!= b\"\n    a[0] ^= b[0]\n    a[1] ^= b[1]\n    return str(a)\n\nThere's a typo in the code. Should be \"len(a) > len(b)\"\n\nI am guilty of this. I like using (map...) when I have a series of small steps that I want to apply to each item in the list.\n\nThe correct answer to this problem is to re-write the whole thing in one line of Python.\n\nAnd it's probably something like:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    try:\n       result = a.decode('ascii').encode('ascii')\n       except ValueError:\n       return b.decode('ascii').encode('ascii')\n\nHeh, I find this amusing, because I found myself coding that exact same thing the other day, except I wasn't even using Python at the time.\nIt's not just programmers that are pedantic, computer languages are also.\n\nHow can you even call yourself a programmer if you don't know binary?\n\nI think it's a joke.\n\nYeah, it was. It's an old one.\n\nThe old one went \"How can you call yourself a programmer if you don't know binary and assembly?\" I always thought it was a stupid thing to say, but at least it was consistent with the rest of the meme.\n\nIn Python 2.x:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if a.startswith('0'):\n        return '0'\n    else:\n        return b\n\nThis will not work:\n>>> string_xor('010', '010')\nTraceback (most recent call last):\nFile \"\", line 1, in\nFile \"\", line 2, in string_xor", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a = b = \"\"\n\n    if b == a:\n        return a\n    else:\n        return b\n\nWhat's wrong with ?\n\nThat's a good question!\nI guess it's a matter of taste. I'm not that much into Python, so maybe the above is just not idiomatic for that language.\n\nNot Pythonic?\n\nFrom the documentation:\n_Pythonic_ refers to code that is elegant, clean, and well-commented.\n_UnPythonic_ refers to code that violates those principles.\nIn the above example, I think both ``string_xor`` and ``xor_string`` are UnPythonic, but there's probably a good way to do the same thing.\n\nThe problem is that the documentation is about a programming language that doesn't exist. It's simply a matter of preference, and what the \"best\" way to do something is depends on what you're trying to do.\n\nI agree. I thought about that too. But then I thought that a general principle is that anything that's well-documented is probably a good thing.", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\n Edit: This is actually pretty cool. You can use it to build programs without the use of the Python interpreter. It's in the same spirit as  and\n.\nEdit2: Here's a post that explains how to use it:\n\nHere's one I just wrote:\n\nThis is very cool. You should add a comment at the top, though, explaining how this works, because it's non-obvious.\n\nYeah, thanks. I'll do that.\n\nfrom typing import List", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ** b\n\nfrom typing import List", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n\n    if a[0]!= b[0]:\n        return '0'\n    return a[0] | b[0]", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a = '0' if a else '1'\n    b = '1' if b else '0'\n    return a XOR b", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n\n    s = [0] * len(a) + [0] * len(b)\n\n    return ''.join(list(int(a[i] ^ b[i]), len(s) - 1))\n\nI've just posted a list of things I hate about Python. Please feel free to add to it.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if a == '0':\n        return b\n    return a * b", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a[i] ^ b[i]\n\nAnd yes, I'm aware this is pretty useless code, but I thought it was neat.\n\nYou're right it is! I'm going to use this in a follow-up post to the original\narticle:\n\"The 'pragmatic' programming\"\n\nNote that the code shown is not particularly useful, but it is clever. The\nstring XOR operator is defined as:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return string(a) ^ string(b)\n\nfrom typing import List\n\n    def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    return string(a) | string(b)\n\nWouldn't this get you in trouble for a few edge cases where the strings don't match in length, but do match in the other aspects?\n\nI think this example works because of the Python numeric operator precedence.\n>>> string_xor('010', '1110')\n'1100'\n>>> string_xor(0, '1110')\n'1110'\n\nIn python, you have to specify the order of operations and the order of precedence of operators.\n>>> string_xor(0, '1110')\n<interactive>:17: SyntaxError: invalid syntax\n\nNot necessarily.", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a.xor(b)\n\nOutput:\n\n>>> string_xor('010', '110')\n'100'\n>>> string_xor('010', '010')\n'110'\n>>> string_xor('010', '110')\n'101'\n>>> string_xor('010', '010')\n'111'\n>>> string_xor('010', '010')\n'101'</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    result = 0\n    while True:\n        result |= a\n        result |= b\n    return result\n\nIf you're ever unsure of whether to use \"|\" or \"^\" to do a bitwise operation, use \"|\" if you're a human, and \"^\" if you're a machine.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n\n    print(a)\n\n    a = xor(a, b)\n\n    print(a)\n\n    return a\n\nString_xor can be used directly in Python 3, there is no need for typing import.\n\nThe author:\n\nAh yes, I'm aware. I'm using Python 3.4, and I was being slightly snarky in the last sentence.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    input = ''\n\n    while input!= b:\n\n        input += a\n\n        if input == b:\n           return input\n\n    return input\n\nA subtlety with this code is that it doesn't take into account the effect of\nan empty input:\n>>> list(string_xor(\"0000\", \"0110\"))\n[0] \"1010\"\n>>> list(string_xor(\"0110\", \"0011\"))\n[0] \"1001\"\n>>> list(string_xor(\"1101\", \"0011\"))\n[0] \"1110\"\n>>> list(string_xor(\"1111\", \"0011\"))\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: list() object does not support item assignment\n>>> list(string_xor(\"1111\", \"0011\"))\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: list() object does not support item assignment", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return str(a XOR b)</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a = a & 0xFF\n    b = b & 0xFF\n    if a!= b:\n       return 'ERROR'\n    return a | b</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    for x in a:\n         for y in b:\n              if x & y == 0:\n                  return x & y\n    return ''.join(chr(int(xor(x,y))) for x in a for y in b)\n\nHow is that supposed to work? It does not work as intended.\n\nIt does work as intended if you use an ASCII (or even \"C\") representation of the binary values. Otherwise, it would be much more efficient to just use \"bool\".\n\nTo test this, I used Python 2.7 and python 3.3.3, and I got the following output:\n>>> string_xor('010', '110')\n'100'\n>>> bool(string_xor('010', '110') )\nFalse\n>>> bool(string_xor('010', '110') * 2 )\nTrue\nThis might be an implementation bug (only?), but it is _not_ in the spec.\n\nIt works on all Python", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return '1' if a in b else b\n\nIn Python 2.6, this would have the added benefit of being about 40x faster.\n\nPython 3.0 has a very nice xor operator:\n>>> a = '010' >>> b = '110' >>> xor(a, b) '100'\n\nxor is faster than a bitwise operation, but it's not going to be faster than a builtin. The following implementation also has the advantage that it doesn't use any extra memory, which is important on 32 bit systems.\n\nBoth of these are in Python 2.6 (in the string module):\n>>> import string >>> string.lowercase(a) 'a' >>> string.upper(a) 'A'\n\nI'm not sure why that would be faster. If you're using it as an operator, then you have to use the same data type, so it doesn't matter which is used. If you're using it as a function, then you don't have to.\n>>> type(xor('010', '010')) <type'str'> >>> type(string.upper('010')) <type'str'>\n\nAh", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return (a ^ b)\n\n>> string_xor('010', '110')\n'100'\n\nSurely you mean '100010'\n\nNope, because he does the addition in binary, so he actually gets '100'\n\nThe addition was in base 10, the return value is in base 2, which is binary.\n\nWhy is base 2 or binary so special? Why not base 3?\n\nBecause the very common computer architecture uses binary.\n\nBut, why?\n\nThe first computers used analog technology - switches and lights. They only had 2 states: on and off. We use base 2 because we were building on that technology. If we had built on base 3, we'd be using base 3.\n\nI would use base 8.\n\nMy only criticism is that there's not a trace of the \"Python\" in there.\nFor a Python programmer, this is easy to fix:\nfrom typing import List", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    result = \"\"\n\n    for a in a:\n        for b in b:\n           if a!= b:\n                 result += '1'\n                  a -= '0'\n                  b += '1'\n                  result -= '0'\n    result\n\nfrom typing import *", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\nfrom typing import Ord", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\nI guess that's actually not that bad. Assuming the input is binary data, you should use a specialized function anyway.\n\n`string_xor` is equivalent to `str.strip('0') ^ str.strip('1')`, which is not the same as `str.strip() ^ str.strip()`.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return '1' * a ^ b\n\nelse:\n    raise ValueError('Only strings are allowed')\n\nso, you're saying that a string is just a list of characters?\n\nThat is one way of looking at it.\n\"Strings are lists of characters\" is another.\n\nI think the first way is better because it does not assume that strings are immutable.\n\nCan't wait to start using this instead of passing strings by value:\nfrom typing import List", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a \\b \\b \\a\n\nIt's nice that it returns a string, but I would really have preferred\nthat this just be a function, and not use the `from typing import List`\nconstructor.\nThe same goes for most of the rest of this library, really.\n\nYou don't need to import the list module to use the list module.\nThat's the whole point of the 'from' statement in Python. You can use\n'from' to access objects in other modules or even files. It's very useful\nfor writing modules.\n\nI think the parent meant that he wanted to use the list type without\nimporting the list module. I'm not sure if there is a good reason\nfor that.\n\nOh, I see. Well, you could make a function that does the same thing.\nI haven't tried it, but it should work.\n\nIt's a matter of taste. I prefer to keep the number of module\nimports down, unless they add functionality that I really need.\n\nSame here. I find that the import statement is a good indicator of\nhow a module is structured and how it's intended to be used.", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a = a.encode('hex')\n    b = b.encode('hex')\n    return ''.join(map(str.encode('hex'))(a ^ b))\n\nWouldn't this be more readable as:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return b ^ a ^ b\n\nfrom typing import *\n\n    @b = string_xor(''x', 'x')", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a = a.encode(\"hex\")\n\n    b = b.encode(\"hex\")\n    return string_xor(a, b)\n\n>>> string_xor('010', '110')\n'100'\n\nBeautiful. I think I'll have to use this.\n\n\"print '10'\\nprint 'xor'\"\n\nHeh, this is brilliant.\n\nI wish it had a --hex argument.\n\npython-xor --hex\n\nThat's kind of clunky. I'd prefer to do it with just one statement.\n\nfrom typing import List", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\nTo me, this is more readable, and it's shorter too.\n\nThis is an example of what is wrong with Python.\n\nReally? Because I was thinking it was a good example of what is right with Python. It's concise, it's readable, and it's a really simple example of doing a simple thing.\n\nAgreed.\nIt's like the old joke about golfing, which I don't understand because I'm not a golfer, but is, in principle, a good one.\n\"There are two kinds of programmers: those that write code and those that can't read it.\"\n\nThis is an example of something that is not right with Python.\nThere are two types of people in the world: Those that can write code, and those that can read it.\n\nI don't see anything wrong with the snippet. I mean, there are certainly better ways to do this (more concise, more readable, more efficient), but it's not a crime.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a = b = ''\n\n    return a ^ b\n\n\tnot sure how that's \"pythonic\"?\n\nIf you look at the code itself, it's actually quite nicely written.\nIt's the lack of comments and especially the lack of comments that explain the intentions of the code that makes it not Pythonic.\n\nLet me explain why I think it's Pythonic.\nThe author used the standard library with a single, simple, non-abstract method. They're not creating a class with a lot of methods, they're not creating a class that needs to be instantiated. They're not even creating a class that can be instantiated.\nThe whole point of the article is to prove that the standard library can be used to solve a problem. This is a lot more Pythonic than writing your own module (although, yes, the documentation is lacking).\n\nI think the point is that the output of the code doesn't make much sense.\n\nFrom the article:\n\"\"\"\nInput are two strings a and b consisting only of 1s and 0s.\nPerform binary XOR on these inputs and return result also as a string.\n\"\"\"\nWhat's not to understand", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\nI think this is what you were going for.\n\nIt's really quite clever. I tried it with some more complicated data and it seems to work out.\n\nI'm not sure I understand why this is better than the standard string.replace function. Can someone explain?\n\nThe fact that it is in python3, the string.replace function is a python2 function.\n\nIt's in the standard library, though, and it's a builtin. So it's not unreasonable to expect people to be using it, even in Python3.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    list(map(chr, a)) + list(map(chr, b))</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if b == '0':\n        return b\n    else:\n        return '1' + a + '0' + b\n\n>>> List('010', '110') = string_xor('010', '110')\n>>> '010' + '110'\n'100'\n\n// Edit: The reason for the downvotes is that you are all missing the point. The import list was included to demonstrate how Python's meta programming ability allows you to quickly and easily generate code.\nI don't understand why it's being voted down. If you can do this in one line, you've got a _lot_ of time on your hands.\n\nI don't think that's the reason. The article is about Python's meta-programming capabilities, but the comment is about the standard library.\n\n\"The article is about Python's meta-programming capabilities\"\nNo it isn't. The article is about the \"import list\" statement, nothing more.\n\nThis is a very useful technique, and it can be used in a lot of different places. For example, I wrote a wrapper for the AWT Java", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return '010' + '010' + b + '010' + a\n\nSurely that's the other way around, right?\n\nIt's correct the way it is. You can think of it as a counter, where the output is updated each iteration. The output \"counter\" is then returned.\n\nI don't think that's correct at all.\nThe function takes two strings and returns a new string. If you put a 1 into the function, it'll get returned. If you put a 0 into the function, it'll get returned.\nIt's the same as if you were to take the binary representation of the numbers, XOR them, then convert back to ASCII.\n\nYes, that's what he said, except in the language of strings, not numbers.\n\nWell, I feel a bit stupid now. I looked at the code and interpreted it in the wrong way.\n\nIt's not immediately obvious. The reason this happens is that the XOR operator is commutative.\n\nNice trick!\n\nFunny, I was just thinking about this yesterday.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return '01' + a ^ b\nThis is absolutely brilliant. I can't decide if this is better or worse than the old 'boob' trick (you know, back when boobies were funny):", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a = a.replace('0', '0').replace('1', '1').lower()\n    b = b.replace('0', '0').replace('1', '1').lower()\n    return''.join(a XOR b)\n\nThat's interesting. I was just discussing this with someone last night: \n\nYou were discussing the inability to do string xor in Python and they linked you this?\n\nYes. They asked if I could do it in Python, and I said no. They asked why, and I said it was because of the lack of string_xor.\n\nI think you misunderstood something, or I'm misunderstanding you. Either way, you can absolutely do string_xor in Python:\n>>> a = '010' >>> b = '110' >>> a XOR b '100'\n\nHaha, you're right. I guess I'm not up on my Python.\n\nI'd actually recommend this method.", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return b ^ a", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n\n    print \"a = \", a\n\n    print \"b = \", b\n\n    if a!= b:\n        return \"Both strings are different.\"\n        return \"\"\n\n...And, if you happen to be writing a library for strings and you know that you are going to be doing a lot of string manipulation, you might define a subtype of string called a \"text\" which is immutable and always the same size, and which is optimized for manipulation:\n>>> text = List('a', 'b', 'c', 'd')\n>>> text[0] = 'e'\n>>> text[0]\n'a'\n>>> text[0] = 'e'\n>>> text[0]\n'b'\n>>> text[0] = 'e'\n>>> text[0]\n'c'\n>>> text[0] = 'e'\n>>> text[0]\n'd'\n>>> text[0] = 'e'\n>>> text[0]\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: object", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a & b == b\n\n    # a string with 1s and 0s\n    str = list('0101' if b == '1', '1110' if b == '0')\n    a = list(str)\n    b = list(str)\n    return str & b == b</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    x, y = a, b\n    while x!= y:\n        x, y = x ^ y\n\n    return x\n\nimport os, sys, time\nfrom string_xor import string_xor", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\nI don't get it, why would I use this?</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a + b\n\nBut the type of a string is str not int, so a string_xor should return a string.\n\nAnd: \n\nPython's typing is a mess, but it's getting better. I've been impressed with some of the new syntax in the 1.5 alpha releases.\n\n_Python's typing is a mess, but it's getting better. I've been impressed with some of the new syntax in the 1.5 alpha releases._\nI've been meaning to do some comparisons, but I'm not sure what to compare with and I'd rather not look at the old syntax for comparison, lest I start mistaking it for the new syntax.\n\nYou could compare it with the current syntax, if you're feeling masochistic.\n\n\"No matter how good the code is, if it's written in an obscure language, you're going to have problems.\"\n\nI am an avid Python programmer, but I have to agree with this statement.\n\nI read this as \"If you can't figure out a few basic things about a language, you're going to have problems\".\n\nI read this as \"don't pick a language for its features, pick", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return string(a ^ b)", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a xor b", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a_string = '0' * 256 + b_string\n\n    return string_xor(a_string, b_string)\n\nI actually use this for my command line tool for \"automagically\" encoding files in hex format:</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a.replace('0', '1')\n    b.replace('1', '0')\n    return a + b", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return '01' if a and b\n    else '10'\n\nI don't know if this is the best way to do it, but it's the simplest.\n\nWhy is that more readable than:\nxor_string = list(map(str, string_xor))\n\nI guess it's because the first one is written like a function while the other is a list comprehension. I like to think of list comprehensions as being more readable in some cases, and less readable in others.\n\nIt's a bad example because the lambda is more readable than the list comprehension, but the point is that you can do that.\n\nI'm not convinced that the lambda is more readable. I'm not sure why, but it seems more natural to me to read code in the order I expect it to be executed.\n\nI would agree with you that the lambda is more readable, but that's only because I have more experience with them. But I think it's hard to argue that list comprehensions are more readable in general, because they aren't.\n\nI'm not trying to argue that list comprehensions are more readable in general. But I believe that in some cases, for", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if len(a) == len(b):\n        return a\n    return b\n\nHow does that work?\n\nIt doesn't. It's a joke.\nIt's also a Python \"joke\" from 2004.\n\nOh... I thought it was a javascript joke.\n\nAh, classic. I like \"why\" jokes, because they're easy to understand even if you're not a programmer.\n\nIf you like _why_ jokes, you should also like this one:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return (a.xor(b).xor(a))\n\nThis may be an argument against over-abstraction.\n\nYea, I was confused for a second, but then I realized he was just using\nList as a container, not a class.\n\nI'm a bit of a fan of that. I use the term \"generic function\" for the type\nof function he is writing. Here is a similar function that uses\nnumeric types:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return '1' + (a ^ b)\n\nBeautiful.\n\nNice but I really don't get this type of examples. What are we supposed to learn from this?\n\nThat it is really easy to write a bad function if you don't know how types work.\n\nIt is much more useful to know that a programming language should be designed such that a function like this can't be written.\n\nSurely that's just an example of the language being Turing incomplete?\n\nRight. But there's a big difference between a Turing-incomplete language (like Python) and a non-Turing-complete language (like Haskell).\nI think the parent is suggesting that the latter is better, and I'm inclined to agree.\n\nI'm inclined to agree with you, but not as a blanket statement. There are times when a Turing-incomplete language is exactly what you need.\n\nIn what cases is that?\n\nFormal specification of systems with a limited number of states. See:\n\nThat is so bad it is not funny.\n\nThis would be my ideal way to teach introductory programming at the high school level. Make a language with basic types, add the power", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n\n    return a.find(b.find('1')).replace('1','0')\n\nXOR is commutative. I think you meant \"if a and b are equal\".\n\nThe \"find\" function is not commutative.\n\nI think you mean the \"replace\" function.\n\nYes. \"find\" is not commutative.\n\nNice, but if I were to do this, I would do it using a regular expression and look-ahead in the string.\na*(b|c) would be a regular expression that matches \"a\" or \"b\", and looks ahead two characters.\n(a|b)*c would be a regular expression that matches \"a\" or \"b\", and looks ahead two characters.\n(a*(b|c)) would be a regular expression that matches \"a\" or \"b\", and looks ahead two characters.\n\\a*(b|c) would be a regular expression that matches a space, a \"|\" or \"c\", and looks ahead two characters.\netc.\n\nI find it amusing that while you were writing this, you were probably thinking that you were writing some kind of smart algorithm", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n\n    return string.gsub(a, b, '0', '1')\n\nI'd be more impressed if they were demonstrating a concept using lists, rather than using lists as a substitute for string concatenation.\n\nAlso, if you know Python, you've probably seen this:\n\nA good example of why you shouldn't use `string.gsub` in real programs.\n\nFor the uninitiated, what's the problem with `string.gsub`?\n\nIt returns the original string if the match fails, as a tuple.\n\nAh, that makes sense. Thanks.\n\nYeah, but what if one of the strings is longer than the other? I see the\nother solutions to this problem have this limitation as well.\n\nThe solution I've seen elsewhere uses an XOR to produce the result.\n\nIf you're a fan of this sort of thing, I highly recommend the \"toy programming\" blog:\n\nFor a more approachable explanation of binary XOR, see:\n\nI think it should be added to the python standard library.\n\nthat is the worst name for a function ever.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n\n    return a XOR b\n\nfrom typing import List\n\n    \"\"\" Returns a string in hex representation of the number a. The\n    number a is converted to string and then converted to hex. The string\n    should be in Unicode. If no unicode conversion is possible, then the\n    string is returned in its current representation.\n    >>> hex(a)\n    '01'\n    >>> hex(b)\n    '01'\n    >>> hex(a, b)\n    '01010'\n    \"\"\"\n\n    if a is not None:\n        return str(a.encode('utf-8'))\n\nI just wish someone would take the effort to port the entirety of Python's standard library to Python 3.\n\nIt would be great to have that, but not everyone is going to want to switch over immediately, and I'm not sure I'd want to maintain the code in two versions.\n\nA lot of libraries are doing exactly that, and they all have a common approach:\n\\- Most of the code is in", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a.xor(b)\n\n(Disclaimer: I am not a Python expert, just a casual user)\nI like this a lot. It's well written, and the syntax is very clean.\nI'm not sure it's _less_ verbose than what you would do in Python, but it's still a good example of good use of Python.\n\nIn Python:\nfrom typing import List", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a = a + b\n\n    return a ^ b\n\n    print(string_xor('010', '110'))", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return '01' + a * (b & 0x80)\n\nPython was designed so that a beginner could use it after learning just one other language (it was originally based on ABC), so it is very easy to pick up.\n\nThe only downside of Python is that it's slow compared to other languages, and especially compared to compiled languages.\n\nNot true. Python is not slow, it's just not as fast as C/C++.\n\nI am going to go ahead and call this a feature.\n\nI love Python. I use it for everything from web development to making image processing scripts. It's great for learning programming concepts.\n\nNot just web development.\nI'm a long time Java programmer but for image processing, I can't find a better language than Python.\n\n\" _It's great for learning programming concepts._\"\nThat's the key thing about Python. It's very simple, so simple that it's hard to get wrong. It's also easy to read and understand, and that makes it great for teaching.\n\nI used Python to solve some engineering problems and for me it is more than sufficient.\n\nIt's a great language and it's my", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\nI have never seen anyone writing code like this.\n\nIt's so you can type in\nfrom typing import List\nfrom string_xor import string_xor\n\ninstead of\nfrom string_xor import string_xor as sxo\nfrom typing import List as t\nfrom string_xor import string_xor as sxo\n\nI guess. I don't see why you can't use type annotations to make your imports more readable.\n\nI guess you could, but there's also a performance cost to type checking in Python. It's a trade-off.\n\nThere's a very good reason that Python doesn't enforce static typing, but if you're using a language that does, the tradeoff between type checking and performance isn't an issue.\n\nBy the way, the great thing about Python is that you can use type annotations for every method if you want, and the type checker will silently ignore them. I use type annotations on all methods that return dictionaries or lists, and it makes it really easy to see at a glance whether a class is using the objects it returns properly.\n\nI don't know much about python.", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    result = \"\"\n\n    for i, char in enumerate(a):\n        result += a[i] ^ b[char]\n    if i % 2 == 0 and i % 4 == 0:\n        result += '1'\n    return result", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return ''.join(map(str, a[0] ^ b[0], a[1] ^ b[1]))\n\nI'm not sure I'm buying it.", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a[0] ^ b[0]\n\nfrom typing import List", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\n (not the best example but a fun one)</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a[x] ^ b[x]\n\nfrom typing import List", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n\n    return a XOR b\n\nIsn't that Python-2's `ord` function?\n\nThis is something I'm not too fond of in Python. Many times the solution to a problem is to import a module that does one thing and one thing only.\nI've seen the same modules over and over in many different projects.\nWhile it may be nicer to have everything in one file, I'm not sure the benefits outweigh the pains of dealing with duplicated code.\n\nI agree, but for different reasons. My reasoning is that if you need to import a module to do one thing, it is often better to actually write that one thing as a function instead.\n\nIf you import from a module that does one thing, you can guarantee that it is _only_ doing one thing. This is a big deal when you want to avoid the problem of \"goto\".\n\nTrue. But in my experience, that is not usually the case.\n\nWhat? Is this the right URL?\n\nYeah, it's a joke.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return str.xor_two(a, b)\n\nI'm not sure if it's just me, but the xor_two() function looks pretty suspicious, as well.\n\nI'm pretty sure it's just you.\n\nThe function is quite short, which I liked. It's not clear what xor_two() is doing though.\n\nI really liked this - it's pretty much the way I've always approached python.\nI'm not sure about this line though:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\n    from typing import Iterable, List, Generator\n    from itertools import chain, map, reduce, collect, find,\n    zip, izip\nI see the value of this, but is there a way to get the benefits of it in the more general case?</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a = int(a)\n    a = 0x00\n    b = int(b)\n    b = 0x01\n    return '0x' + xor(a, b) + 'x'\n\nNote that binary XOR is an operation that only has meaningful results when the inputs are a limited set of values. If the inputs are not a limited set of values, then the result will be a random string of bits. For example, the string '010' XOR'd with '110' results in '0111' but the string '1101' XOR'd with '0111' results in '0x5c6cb'.\n\nI think that's the point of the article.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a_str = list(a)\n\n    b_str = list(b)\n\n    xor_result = []\n\n    for i in range(1, len(a_str)):\n        a_str[i] ^= b_str[i]\n\n    for i in range(1, len(b_str)):\n        b_str[i] ^= a_str[i]\n\n    xor_result.append(xor(a_str, b_str))</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a.encode('ascii', 'ignore') ^ b.encode('ascii', 'ignore')", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if len(a) == len(b):\n       return ''.join(a) + '0' + '1' + b\n    else:\n       return ''.join(b) + '0' + '1' + a\n\nI'm not sure how I feel about this. It seems to me that the point of this exercise is to make a list comprehension more concise. This one is _a lot_ more concise, but is it also more understandable?\n\nThe Python equivalent (from the article)\nlist(map(lambda x: x%2 == 1,range(1,2,3,4,5,6,7,8,9,10))\n\nThat's not even close.\nThe equivalent would be\nlist(map(lambda x: x%2 == 1, xrange(1,2,3,4,5,6,7,8,9,10))\n\nOh, right. Good catch. I can't believe I wrote that.\n\nThis one is a bit too long, but I like this one:\na = [[1, 2, 3], [", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\nIt's a neat trick, but the \"from typing import *\" idiom is a bad idea.\nIt's poor programming style and makes your code difficult to read and impossible to maintain.\n\nAnd I would add that you might want to import something like \"fmt\" as well (from libc import * is also bad). I haven't used it, but it looks like Python already provides String.xor.\n\nYou can actually get away with importing only those standard modules that you actually use:\nfrom typing import List, Function, String\n\nYou can also use from typing import * to get everything in the Python standard library.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return b ^ a\n\nTIL: you can do string XOR in Python.\n\nXOR is implemented as a method of the string class, not as a built-in function.\n\nI think this is a bad way to start a tutorial.\nThe first thing you show your reader is a minor error that might make him/her think this is not a good tutorial.\n\nFor what it's worth, I didn't notice the typo.\n\nI didn't notice it until I read your comment.\n\nI notice it a lot.\n\nWho wouldn't?\n\nI don't think this is a very good way to teach people a programming language. Showing a bunch of code that doesn't work, and not explaining what you're doing.\n\nI find that when I'm starting to learn a new language, a couple of examples of things that _do_ work and _don't_ work can be immensely useful.\n\nI really liked the article, although I agree with you that it needs a few more lines explaining what's going on.\nThe first thing I noticed though was the very confusing example:\n>>> x = (0,0,0,0,0,0", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\nWhat is the point of this?\n\nWithout import, it will create a local variable \"string_xor\" from the module string_xor, so you don't have to type all the import.\nIt's just a convenience, but it's kind of cool.\n\nDoes this really change the way the code is compiled, or is it just an extra step to take advantage of a feature of the Python interpreter that doesn't really make any difference for the end result?\n\nGood question!\nI don't know if it makes any difference in the final result, but you'll never type \"import string_xor\" in your python program if you use this.\n\nIf you use the same module name as the class, you don't have to import it.\n\nI just thought it was interesting, not necessarily useful.</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if a == b:\n       return a\n    else:\n       return b\n\nList.from_string(string_xor('010', '110'))</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if a == b:\n       return b\n    else:\n       return'' * (a ^ b) + '0'\n\nis a more readable version. I never really understood why this is so common.\n\nThe OP's version doesn't use lambdas. It's not exactly the same, but it's pretty close.\n\nI don't think that's the intention. I think the intention is to show what you can do with just the built-in functions of Python.\n\nNah, it's to show how you can do everything using built-ins instead of having to import external functions. You can do most of that in a couple lines of code but with lambdas it's much shorter.\n\nI think it's a case of mixing two different styles of coding together.\nThe first is the non-OOP style:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a.encode('ascii').strip() ^ b.encode('ascii').strip()\n\nIt would be more intuitive if the function takes 2 xors as arguments instead of 2 strings.\n\nI don't see how it would be more intuitive.\n\nI feel it's more intuitive to give the function something to work with, rather than pass it two strings to work with.\n\n`string_xor` is basically `a & b | 0` so it is not hard to understand what it does.\nOn the other hand I think this is a nice example of how to make a small API that is easy to read, easy to test and covers a lot of use cases.\n\n>string_xor(string_xor('010', '110'), '010')\n'100'\n\nTIL: 0x10 = 100\n\n\"010\"!= \"0x10\"\n\nI'm not sure if I'm being trolled or not...</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if len(a) == len(b):\n       return b\n    else:\n       return a ^ b\nI am not sure if I like this code.\n\nWhy?\n\nI don't know if I've understood it correctly, but it seems to be calling b.lower() before doing the binary XOR.\n\na.lower() is not necessary, this code performs a (logical) XOR.\n\nYou'd have to write your own version of string_xor to do the inverse operation.\nfrom typing import List", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a1 = a.encode(\"utf-8\")\n    a2 = b.encode(\"utf-8\")\n\n    if a1!= b1:\n       return ''.join(a1) + '1' + b1\n\nfrom itertools import islice, islice_if, islice_apply, islice_partition\n\n    def string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\"\n    a1 = a.encode(\"utf-8\")\n    a2 = b.encode(\"utf-8\")\n\n    for i in range(0, len(a1)):\n       a1[i] = 0\n       a1[i", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n\n    return (a ^ b) ^ a\n\nfrom typing import List", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    result = ''\n\n    for i in range(1, len(a)):\n        result = result << a[i] ^ b[i]\n\n    return result", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    a = a.encode('utf-8')\n\n    for i in range(1, len(a)):\n        a.index(i) = a.index(i) ^ b.index(i)\n\n    return a.decode('utf-8')</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return '\\0' * (a & b)\n\nfrom typing import List", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a ^ b\n\nfrom typing import List, Char, Bytes\n\n    def string_xor(a: List(Char), b: List(Char)) -> List(Char):\n    \"\"\" Inputs are two lists of characters.\n    Perform binary XOR on these inputs and return result also as a list of\n    characters.\n    >>> string_xor([0,1,2,3], [0,1,2,3])\n    '000'\n    \"\"\"\n    return a | b\n\nWhy is the 2nd version more succinct?\n\nThere's a lot of overlap between those two versions, because the second one is almost identical to the first except for the type, so you're seeing the same code twice.\nI think the \"String XOR\" should be named \"Bit XOR\" or \"Binary XOR\".\n\nOk, so what is the difference between bit and binary?</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if len(a) == len(b)\n       return a\n    return b\n\nWhat a silly example. What would it return if one of the input strings had no 1s or 0s in it?\n\nNothing. You're supposed to think of it as\nString xor'ing the bits together, so if one of the inputs is empty, it's\nthe same as the other one.\n\nIt would be trivial to write a function that, given an empty string, produces an empty string. I don't see how this is useful at all.\n\nI think the point is to make a \"pythonic\" solution that is very easy to read. In addition, the function is defined in terms of the Python `str` type, so you can easily type-check your solution.\n\nPythonic? It's not even functional.\n\nIs this a joke?\nfrom typing import List\nfrom __future__ import braces", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return a.xor(b.encode('hex')).decode('hex')", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return \"\".join(map(str, a) + \"\".join(map(str, b)))", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if a:  and b:  and a < b:\n       return '0' + a\n    else:\n       return '0' + b\n\nThis is the python version of the code:</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    if a[0] == b[0] and b[1] == a[1]:\n        return a[2] + b[2] + b[0] + b[1]\n\nI've noticed a few of these snarky one-liners, but this one is the first time I've seen the one-liner writer actually attempt to justify their code's existence. I'm in stitches.\n\nI think a more reasonable version would be:", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    for i, l in enumerate(a) ** l:\n        if i > 0:\n                a[i] ^= b[i]\n                a[i] = 0\n    return a\n\nJust a nit, but it should be \"enumarate\" (sic).\n\nYes, thanks!</s>", "from typing import List\n\n\ndef string_xor(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> string_xor('010', '110')\n    '100'\n    \"\"\" \"\"\"\n    return '\\x00' * a ^ b\n\n    s = List(string_xor('010', '110'))\n    print s\n    print s.pop()\n\nThis has a hidden bug. str and s are initially equivalent. So\n>>> s = string_xor('010', '110')\n>>> s.pop()\n>>> print s\n'100'\n>>> print s\n'010'\nThe return value should be '010'\n\nIn python, an assignment inside an expression has the same effect as if it was written outside.\n\nYou can't print str, because you declared it as a list, not as a string.\nTry this:\n>>> print list(s)\n'100'\n\nIn python, you can print lists.\n\nOh, yeah, you're right. I was thinking of Python 2.\n\nI think you can do this:\n>>> string_xor('010', '110')\n'010'\n>>> s = list(string_xor('010', '110'))\n>>> s.pop()\n'010'\n\ns is a list, not a string."]]