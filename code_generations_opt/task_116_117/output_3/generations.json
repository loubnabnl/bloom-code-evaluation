[["def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    for i in arr[::-1]:\n        return sorted(i)\n    return sorted(arr)\n\nNot sure why you're getting downvoted. It's a little hard to read, but this is the proper way to do it.\n\nI agree, I believe that the author was trying to compare the result of the 'correct' solution to the others.\n\nYes, I should have mentioned that in the article. Thanks for pointing it out.\n\nI had a (still) harder one: sort a string of random numbers so that they are ordered by increasing number of digits.\n\n\"Hard\" is relative. What if we're talking about sorting a string of random _integers_?\n\nI'd say that's harder because you have to deal with the possibility of negative numbers.\n\nInteresting, I would say the opposite. The integer version is much harder than the one given here because of the possibility of negative numbers.\n\nIf you're sorting integers with negative numbers, there are only 3 possible outcomes:\n1. The negative number is in the \"middle\" of the sorted sequence.\n2. The negative number is the first", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\nI don't know much about this stuff, but I think this is broken:\n>>> import datetime\n>>> datetime.strptime([]).sort()\n[datetime.datetime(2003, 1, 1, 1), datetime.datetime(2003, 1, 1, 1, 0)]\n\nIt does not have to sort the date, it has to sort the ints in the array.\n\nAnd here's my solution:\n\n>>> def sort_array(arr):\n...        return sorted(array, key=lambda i: i)\n...        if __name__ == '__main__':\n...        arr = [0,1,2,3,4,5]\n...        sorted(arr, key=lambda i: i)\n...        print(sorted(arr))\n\nWhat's the difference between this and the one in the OP?\n\nSorting the array is the easy part of this. There's a trick to it, though. The\nsolution has to use the fact that there", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\n    return arr[::-1] if arr[::-1] > arr[::-2] else arr[::-2]\n\nfunctools.partial() can be used to partially apply a function to a single\nargument.", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return [i for i in ar if i % 2 == 0]\n\nI know that this is a toy problem, but if you're going to solve it, it is much better to use a comparison function that compares in binary representation.\nPython has `ord` for that.\n>>> from datetime import datetime as dt\n>>> dt.fromtimestamp('2019-04-01T16:38:52.928Z')\n>>> dt.fromtimestamp('2019-04-01T16:38:53.000Z')\n>>> arr = sorted(str(ord(i)) for i in range(1, 8))\n>>> arr\n[ 1, 2, 3, 4, 5, 6, 7, 8 ]\n>>> arr.sort()\n>>> arr\n[ 1, 2, 3, 4, 5, 6, 7, 8 ]\n\nThere's also the built-in sort() function that sorts an object or array in-place.\n>>> arr = [1, 2, 3, 4, 5, 6, 7, 8]\n>>> arr.sort()\n>>> arr\n[ 1, 2, 3, 4, 5, 6", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if len(arr) == 1:\n       return arr\n    elif len(arr) == 2:\n       return [arr[0]][0]\n    elif len(arr) == 3:\n       return [arr[0]][1]\n    elif len(arr) == 4:\n       return [arr[0]][2]\n    elif len(arr) == 5:\n       return [arr[0]][3]\n    else:\n       return [arr[0]]\n\nCorrect solution:", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return [int(x) for x in arr if x % 2 == 0 for x in range(len(arr) + 1)]\nI'm guessing that's an old kata? The provided solution would sort an array of integers in ASCII/binary, rather than a numeric array.\nIn the first case (int(x) for x in arr if x % 2 == 0 for x in range(len(arr) + 1)) the for loop would just iterate over the ASCII/binary string, ignoring the actual int value.\nIn the second case (int(x) for x in arr if x % 2 == 0 for x in range(len(arr) + 1)) the for loop would iterate over the int value, but it would also iterate over the ASCII/binary string, returning a sorted ASCII/binary string rather than an array of int values.\nI agree with the other comments: a simpler solution would be to just iterate over the array, and use array.sort() to perform the comparison.\n\n(2012)</s>", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    arr = [None, None, None, None, None, 1, 2, 3, 4, 5]\n    for i in range(2, len(arr)):\n       arr[i] = arr[i] & 1\n    print \"Array after two iterations:\", len(arr)\n    for i in range(0, len(arr)):\n       print \"Array before sorting:\", arr\n       print \"Current element and its binary representation:\", arr[i]", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if arr[0] == 0:\n        return [0]\n    else:\n        return [arr[0] for arr in arr]\n    return []", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    input_array = [1, 2, 3, 4]\n    print \"Input array: %s\" % input_array\n    for index in range(len(input_array)):\n        val = input_array[index]\n        if val == 1:\n            input_array[index] = 1\n         else:\n             input_array[index] = 2\n         if val == 2:\n             input_array[index] = 3\n         else:\n             input_array[index] = 4\n    return input_array\n\nSorting of binary numbers, in ascending order, with least significant bit first:\n1 - 2 - 3 - 4\n2 - 1 - 3 - 4\n4 - 3 - 2 - 1\n1 - 3 - 4 - 2", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    num = len(arr)\n    indices = {}\n    for i in range(0, num):\n        index = 0\n        while index < num:\n            index = (index + 1) % num\n            if (arr[i] % 1 == 0):\n                 indices[index] = arr[i]\n    return indices\n\nFor others who have trouble following the examples, here's the simple explanation:\n1 2 3 4\n-2 -3 -4 -5 -6\n0 1 2 3 4\n\n1 2 3 4\n0 0 1 2 3 4\n\nI think it's interesting that sort_array returns a dictionary. Does anybody know why?\n\nI like the first example, which basically uses some of the simplest data structures you can imagine to sort. I think it's interesting that for this data structure, the ordering is determined by the number of elements in the container, and not by the value of the", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    arr = [1, 5, 2, 3, 4]\n    sorted_arr = []\n    sorted_arr.append(0)\n    for x in arr:\n        if x < 0:\n            x = 0\n            if x == 0:\n                 sorted_arr.append(x)\n                break\n               if x > 0:\n                   x = int(x) * int(x)\n                 if x == 0:\n                       sorted_arr.append(x)", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\n    # Sort the array of integers\n    print \"[%d] %s\" % (arr.pop(1), sorted(arr))", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if len(arr) < 1:\n        print \"You didn't provide an array.\"\n    return\n    arr = (range(1, len(arr)-1))[::-1]\n    arr2 = []\n    for i in range(len(arr)):\n        if arr[i] == 0:\n            arr2.append(arr[i])\n         else:\n            arr2.append(0)\n    return arr", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if arr == [] or arr.count() == 0:\n        return arr\n    return arr.sort()\n\nWhat a useless kata.\n\nThis is a nice kata - it is simple and demonstrates the power of python's built-in sorting method.\n\nActually the OP's kata is much nicer. Yours is completely useless and doesn't demonstrate any power of python's built-in sorting method.\nIn fact, it's not sorting at all, it's just giving an order to the input.\n\nNow, this is a good kata. It teaches you to use the right tool for the job.\n\nI'm not sure what you mean by that. The OP's kata is also teaching you to use the right tool for the job. It's just that in this case, the job is a simple comparison of numbers.\n\nI don't think it's teaching anything. The code in the post doesn't do anything. It doesn't sort anything. It just sort of orders the elements of an array.\n\nThere's no question that it _is_ sorting the elements, it's just not using the \"right\" tool. The", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if arr.len() == 1:\n        return 1\n    else:\n        return [int(x) for x in arr]\n\nGood! Here's the one-liner:", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    # if the number of ones is odd, then, sort by the number of ones\n    if ord(arr[0])!= 1:\n        arr[0] = 0\n    # other than that, sort according to decimal value\n    else:\n        # if the number of ones is even, then, sort by the number of ones\n        if ord(arr[0]) == 1:\n           # sort by the number of ones\n          arr[0] = arr[0] - 1\n    else:\n           # sort by the number of ones\n           arr[0] = arr[0] + 1\n\nThis is not the correct way to do this. It is wrong and it will not work. Here is the code that works:", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    for c in arr:\n       if c[0] > c[1] and c[0] < c[2] and c[0] < c[3]:\n          c[0] = c[1]\n       else:\n           c[0] = c[2]\n           c[1] = c[3]\n    return sorted(arr)\n\nYou might want to consider using a hash table.\n>>> s = {}\n>>> h = {}\n>>> k = {}\n>>> s.insert(0, 5)", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if len(arr) == 1:\n        return arr[0]\n    else:\n        return sorted(arr, key=lambda x: x[1], reverse=True)\n\nSo the sort takes lambda expression as the key?\n\nYes.\n\nI think this could use a little more context. It seems to be a kata, but I'm not sure what it is a kata of. Is this a function in a programming language? If so, what is it's purpose?\n\nI am not sure either, but as far as I can see, this is to get you to understand the concept of recursion in a functional language.\n\nA little context:\n\nThis is a kata.\n\nI don't see anything wrong with the code, it's perfectly fine. Just because you don't understand it doesn't mean it's wrong.\n\nThe only issue I see is that there is no import statement, but I guess it doesn't really matter for a kata.\n\nA bit of context:\n\nI don't know why but it makes me uncomfortable. Is it because it's too", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    var arr = range(1, n)\n    for i in arr:\n       if arr[i] == 1:\n           arr[i] = i\n    return sorted(arr, key=lambda x: x[0])(*arr)\nThis is essentially what the Python standard library's `sorted` method does.\n\nthis doesn't work for the given code\n\nAh, you're right. The description is a bit misleading. A better implementation would be to iterate over the array, putting the ones first, then the zeroes:\nfor i in arr:", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if arr[0] == 0:\n        return [0]\n    else:\n        return [arr[0], arr[1:] + arr[1]]\n    else:\n        return sorted(arr)\n    # How to implement this in an imperative programming language such as C\n    def sort_array(arr):\n    if arr[0] == 0:\n        return [0]\n    else:\n        return arr.pop() + arr.pop()\n    else:\n        return sorted(arr)\n\nkata = [\n    [1, 2, 3, 4],\n    [-2, -3, -4, -5, -6]\n    ]", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    a = []\n    for i in range(10):\n       a.append(i)\n    return a", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    def initialize(arr):\n    \"\"\"Initialize array arr to hold integers in their binary representation,\n    sorted according to their number of ones.\"\"\"\n    arr = [0]*24 + [1]*16 + [2]*8 + [3]*4 + [4]*2", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return sorted(numpy.arange(len(arr)), key=ord)\nI'm not sure if this is a Kata, but more like an exercise.\n\nI think it's a kata. The whole \"create the sorting algorithm\" is the kata.\n\nIt's a kata. The purpose is to get you to think about sorting, and to practice using numpy.\n\nIf I understand it correctly, you're supposed to come up with a sorting algorithm on your own and then implement it, not to use numpy's built-in one.\n\nThis is a kata, yes, but the objective is to come up with a sort algorithm, not to use numpy.\n\nI agree. The objective is to come up with a sort algorithm, and the way I would approach it is to write it in python (no numpy or any other library), and then try to write the same algorithm in numpy.\n\nIt would be interesting to see if there are languages that are better for this sort of thing.\n\nI wrote mine in C#, actually.\n\nI was going to say that the challenge seemed too easy, but then I realized that I don", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    # kata definition\n    def kata(sorted):\n       return sorted\n   \n    # you can use any function you want for that\n   \n    # the function must be called sorted(). No other names\n    # are allowed.\n    return sorted\n\nThis is the sort_array() method of a module called sorted. The kata()\nmethod should always return an instance of the same class as the function\nit is calling. You can use any function you want, so long as it works on the\ngiven type.\n\nThe sorting function must use a standard comparison function that\naccepts two arguments, a first element and a second element. It must be\ncalled sorted(). No other names are allowed.\n\nFor example, the following code will pass the test:\n\n>>> sorted() == sorted()\nTrue\n>>> sorted() < sorted()\nFalse\n>>> sorted() < sorted()\nTrue\n\nYou can sort both ways: according to the number of ones and according to the\ndecimal value. You can sort an array of non-negative integers, or you can\nsort", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    from operator import itemgetter\n    from math import factorial\n    arr = [factorial(i) for i in range(1,10)]\n\n    for x in arr:\n       x, y = x, itemgetter(x)\n       if y!= -1:\n          if y == 1:\n               return y\n               else:\n                return factorial(x-1)\n                x = y\n                return x\n\nDid you use that in production?\n\nIt's a trick question.\n\nNot really. I'd be extremely surprised if it actually works.\n\nI did not mean to imply that it would work in production. The point is that the sort_array() function is in fact a bad solution.", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    arr = []\n    for i in range(1, 10):\n       if i % 2 == 0:\n          arr.append(0)\n    else:\n          arr.append(0)\n    arr.sort()\n    return arr", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    for i in range(len(arr)):\n        arr[i] = arr[i] & -1\n    return arr\n\nWhat does the last statement do?\n\nIt reverses the order in which the array is sorted.</s>", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return sorted(arr, key=lambda x: x[0], reverse=True)", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    for i in range(len(arr)):\n        return arr[i]", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    def b_ascii(x):\n    \"\"\"\n    Converts a string (starting with zero or more bytes that do not\n    represent a number) into a binary number.\n    >>> b_ascii(\"hello\") = 49\n    >>> b_ascii(\"5\") = -1\n    >>> b_ascii(\"3e1\") = 1\n    \"\"\"\n    return x % 10 + 0x100\n    def b_dec(x):\n    \"\"\"\n    Converts a binary number into a string in decimal representation.\n    >>> b_dec(\"1\") = \"1\"\n    >>> b_dec(\"1e10\") = \"1\"\n    >>> b_dec(\"10000000000000000000000000000000000000000000000\") = \"100000000000000000000000000000000000000000000001\"\n    \"\"\"\n    return x % 10 + \"0\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return sorted(arr, key=lambda i: int(i.ascii), reverse=True)\n\nNicely done.\nA few points:\n1\\. The kata has a strict definition of \"assignment\": the above solution is _not_ a valid assignment. (In the kata's solution, `sorted(...)` does not have a return value, so it's not a callable, and you don't have an explicit return statement.)\n2\\. It's \"Assignment 7\", not \"Assignment 7a\". I'm not sure how the numbering works in this kata, but in general, any time you're referring to an earlier problem in a series, you should spell out the number. It can be confusing to a reader if you just say \"Assignment 7\" without a number, because the reader doesn't know whether you mean \"Assignment 7\" in the previous kata, or \"Assignment 7\" in the current kata.\n3\\. The solution is missing the first part of the kata's description, which states:\n\"sort_array() must be implemented like this:\"\nI'm not sure if you meant to leave that part out, or if", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\nfrom collections import defaultdict", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if isinstance(arr, list):\n        arr = [0]\n    else:\n        arr = [1]\n    return sort(arr, key=int(str(n),2), reverse=True)\n\nThe Python approach is an efficient and straightforward one, but not very idiomatic for functional programming (even though it is a functional language).\nFor a more idiomatic solution, see .\n\nIt doesn't even work in Python 3.\n\nI didn't check. But the code is correct. In Python 3:\nsort(list(str(n, 2)), reverse=True)\n\nNo, it's not correct.\n\n\"The idea of this kata is to show that a problem can be solved in different ways, depending on the language, and that sometimes this can be much better than a brute-force approach.\"\nYes. The Python way is a brute-force solution.\n\"The first implementation just iterates over the numbers and compares them. For two equal numbers the kata requires the latter to be sorted after the former.\"\nNo. The kata requires the latter to", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return sorted(arr, key=lambda x: ord(x) for x in sorted(ord(x)))\n\nNeat!\n\nIt's rather interesting to see how the explanation is on the same level as the answer.\n\nHow is this a kata?\n\nI'm having trouble understanding this as well. What's the value of this?</s>", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return [i for i in arr if i**2 > 0]", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    for i in range(len(arr)):\n        arr[i] = int(i, 2) + 1\n    if arr[i] < 0:\n        arr[i] = 0\n    print(arr)\n\nThis is a nice, clean solution. Note that it uses the built-in int()\nfunction to extract the integer part of the number, and then 2-digit\nnumber to move to the next position in the array.\n\nMy first attempt was very similar to this. It was a bit faster, but\nreally wasn't much better. In some ways, it was worse. For example, the\ncompiler seems to have a problem with the fact that it's using\nfloat(int(x)) instead of just int(x), even though it's the same result.\nSo, the following was faster, but not much better.", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    results = []\n    while len(arr) > 0:\n        i = 0\n        j = len(arr) - 1\n        for i in range(j):\n            if arr[i] > arr[j]:\n                results.append(arr[i])\n          else:\n               results.append(arr[j])\n    return results", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    while arr:\n        if arr[0] < arr[1] or arr[0] > arr[2] or arr[0] < arr[3]:\n            arr = arr[1]\n            if arr[0] < arr[1] or arr[1] > arr[2] or arr[1] < arr[3]:\n               arr = arr[2]\n             else:\n                 arr = arr[3]\n\n    return arr\n\n    def sorted(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers in\n    ascending order.\n    It must be implemented like this:\n    >>> sorted([1, 2, 3, 4]) == [1, 2, 3]\n    >>> sorted([-1,", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\n    arr = [3, 0, 1, 5, 2, 4, -6]\n\n    def count_ones(arr):\n    return len(arr) == 1\n    >>> count_ones(sort_array(arr)) == 4\n    return -1\n    >>> count_ones(sort_array(arr)) == -5\n    return 0\n\n    def count_zeros(arr):\n    return len(arr) == 0\n    >>> count_zeros(sort_array(arr)) == 4\n    return -1\n    >>> count_zeros(sort_array(arr)) == -5\n    return 0\n\n    def sort_array_binary(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n    It must be implemented like this:\n    >>> sort_array_", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    n = len(arr)\n    result = []\n    while len(arr)!= n:\n        result.append(arr[n])\n        result[n] = 0\n    result.sort()\n\nI am not sure how you have your array of integers, but I would say you should be able to change this to sort the last n elements of your list in reverse.\n\nYou will have to do a few small changes.", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if len(arr) == 1:\n       arr = [1]\n    return arr\n\nI guess it should return [0, 1, 2, 3, 4]</s>", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return arr[:n] + n if n < len(arr) else arr[n:] + n\n\nIt's missing a key piece of information: that the numbers are all in a fixed base. If not, how would you sort the following list?\n0.1 1.0 10.0 100.0 101.0 111.0\nOr if the numbers are in base 2, how would you sort the following list?\n1.0 10.0 100.0 101.0 111.0 111.1\n\nPresumably if they're using Python they're using decimal.\n\nThey are.\n\nI thought that it was impossible to sort an array in this way. Perhaps not. The Kata is certainly interesting.\n\nHow would you sort an array of non-negative numbers in ascending order?\n\nIn Python, use \"abc\".sort().\n\nThat's a bit of a useless answer, isn't it? You know what he meant, but you're being deliberately obtuse.\n\nSorry, that wasn't my intention.\nThe OP's question is like \"How can I solve the equation x^2 + 2x + 5 = 0?\" The solution to that", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return lambda n:\n       if n == 0:\n          return lambda t: xs[1:]\n       else:\n          return lambda t: xs[0:]\n        if isinstance(n, int):\n           return lambda t: int(x) < t\n        else:\n           return lambda t: int(x) > t\n\nAs a CS grad student, I see the utility of this kata, but I also see how a lot of people in the real world would have a very difficult time with it. This is a great example of a programmer thinking in one way and a non-programmer thinking in another.\nFor the kata, I see two things wrong with it, though not necessarily the way it was implemented.\n1) The kata is for people who can think like a programmer (use a programming language to solve the problem). It's not a good kata for people who can't", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    # initialize an array of size 8\n    a = [0, 0, 0, 0, 0, 0, 0]\n    # initialize a list of 8 integers\n    b = [1, 2, 3, 4, 5, 6, 7, 8]\n    # loop over the array\n    while True:\n        # find the binary representation of the current element\n        # ie: the number of ones in the number\n        i = 0\n        for i in a:\n           # If it's positive, make it the smallest\n            if i % b == 0:\n                i = i + 1\n                b[i] = 1\n                continue\n             # If", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    arr = [0] * len(arr)\n    return sorted(arr, key=lambda value: value[0], reverse=True)\nI'm still very new to python, but I'm not seeing what the problem is here. Could someone enlighten me?\n\nThe problem is that they are teaching \"python\", not \"programming\".\nThey are teaching syntax. How to string together statements that do what you want.\nBut they are not teaching how to write _programs_. How to design a _system_.\nSorting an array of integers, doing something based on the value of the last element, isn't a program. It's a snippet of code.\nI don't care if you're programming in Haskell or Brainfuck or Python. If you're designing a system, you need to have a larger view of the problem and your solution to it. You need to think about how it's going to be used. You need to think about how it's going to be tested. You need to think about how it's going to be maintained.\nPython is a great tool. It has many of the features of a systems language (as in \"systems programming language\"). But if all you", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    def __init__(self, arr):\n       arr = []\n\n    def order(self, num):\n       return sort(num, key=lambda x: ((x[0] & 1) >>> 0) - 1)\n\n    def __eq__(self, other):\n       return not(self.order() == other.order())\n\n    return sorted(self, key=lambda x: self.order(x))\n    if __name__ == '__main__':\n       arr = [10, 11, 2, 4, 3]\n       print(sort_array(arr))", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    arr = [0]*10 for i in range(10):\n        arr[i] = arr[i] + 1 if arr[i] % 2 == 1 else arr[i]\n\nI know this is a very simple exercise, but what's the point? I have no idea what the algorithm is trying to achieve.\n\nThe point is to learn how to think about code and how to write code. If you can't understand the algorithm you can't write your own.\n\nI understand the algorithm. I can't understand the point of the exercise. If you're learning something by doing it, then there's a point. I can't see any learning point.\n\nOkay, that's fair.\nLet's try to abstract it a bit.\nWhat's the goal of the code? The goal is to get the \"1\"s and the \"0\"s in the correct order.\nWhat's the first step to take in order to achieve the goal? The first step is to get all the \"1\"s and \"0\"s in a list.\nWhat's the next step to take in order to achieve the goal? The next step is to", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if arr.size() == 1:\n        return arr\n    else:\n        for i in range(arr.size()):\n             if arr[i] == 1:\n                   return arr[i]\n          else:\n                   return arr[i]\n\nfrom __future__ import print_function\n\nfrom __future__ import division", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    for i, elem in enumerate(arr):\n        if elem[0] == 1:\n           elem[1] = 1\n         else:\n           elem[1] = elem[0]\n         if elem[0]!= 1:\n            elem[1] = 0\n         if elem[0] > 1:\n            elem[1] = -1\n         else:\n            elem[1] = 0\n    return arr</s>", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\n    var allones = [1] * len(arr)\n\n    while len(allones) > 0:\n        for a in allones:\n           if allones[a] == 1:\n                a, allones[a] = allones[a], allones[a] + 1\n                break\n           return allones\n\nWhat's the point of this kata?\n\nI think it's an exercise in recursive programming.\n\nIf that's the case, I'm curious why the author didn't just make it a recursive function, since they already had a recursive implementation of sort() anyway.\n\nI like that the Kata uses the built-in sort() function, rather than some contrived one.\n\nAgreed, and to that point, the standard library actually has a neat function for this as well.\n>>> from itertools import chain\n>>> sort_array = chain.from_iterable((", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    kata_display('sort_array', [\n         kata_title('sort array of integers'),", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if n == 0:\n       return arr[::-1]\n    else:\n       return sort_array(arr[::-1], key=0)", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\nThis is not Python.</s>", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return [x[i] for x in sorted(arr)]\n    def sorted(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sorted([1, 2, 3, 4]) == [1, 2, 3, 4]\n    >>> sorted([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sorted([1, 0, 2, 3, 4]) [1, 0, 2, 3, 4]\n    \"\"\"\n    x = int(arr)\n    arr = x[:x+1]\n    return [x[i] for i in range(len(arr))]\n\nThe author's output (except for the first example) is wrong.\n\nAgreed. But", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if len(arr) == 1:\n        arr = [0]\n    else:\n        arr = [[0]]\n    for i in range(len(arr)):\n        if i in arr:\n             arr[i] += 1\n              break\n    return arr\n\nThis is, in my opinion, a bit of a cheat. The original kata has been answered many times before, and in much the same way.\nI'd be interested to see a solution using explicit recursion.\n\nYep, this is the only correct way to do it.\n\nIt's the \"only\" correct way? So I guess any other solution is incorrect, even the one I provided?\n\nYou're being obtuse. It's the \"only\" correct way because it's the only way that correctly implements the kata. Your implementation, while correct, is not correct by virtue of the fact that it does not implement the kata.\n\nA kata", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    sorted_array = [1, 2, 3, 4, 5]\n    sorted_array.append([-1])\n    return sorted_array", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    def split_at(x):\n        return [x[0], x[1:], x[2:]\n              ]\n    return sort_array([[i for i in range(len(split_at(arr)))] for i in split_at(arr))]</s>", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if arr[0]==0:\n        return arr[0]\n    if arr[0]>0:\n        return arr[0]\n    if arr[0]<0:\n        return arr[0]\n    if arr[1]==0:\n        return arr[1]\n    if arr[1]>0:\n        return arr[1]\n    if arr[1]<0:\n        return arr[1]\n    if arr[2]==0:\n        return arr[2]\n    if arr[2]>0:\n        return arr[2]\n    if arr[2]<0:\n        return arr[2]\n    if arr[3]==0:\n        return arr[3]\n    if arr", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    total_array = [None]\n    for i in range(0, len(arr)):\n        total_array.append(arr[i])\n        if arr[i] == 0:\n               if i == len(arr) - 1:\n                     return total_array\n                      else:\n                            return -1\n    return total_array", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\nI like that this is a Kata, where you first have to implement it without recursion, and then you are asked to rewrite it with recursion. It's not asking you to use recursion in an interview, it's just asking you to prove that you know how.\n\nSort of like the algorithm design problems from the ACM interviews.\n\nI was given one of these a few years ago. It had to be done in a tight time constraint and my solution was super naive. I still got hired.\n\nI like this solution. It's the sort of thing that I would do in an interview without really thinking about it.\n\nI think a lot of problems that interviewers have are also solved in this way. I had a similar one with FizzBuzz but with only one version of the fizz buzz solution. I wrote it without recursion and my interviewer told me to use recursion. The fizz buzz I wrote in my previous interview was with recursion but he didn't seem to like it, so I used a linear search.\nThe interviewers I've had in the past that give me these sort of problems tend to ask \"how would you do it\" without actually asking \"how would you do", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return sorted(arr)\n\nNot sure if I like the way they define the \"sorted\" function. Maybe it is just the way I'm reading it but it seems to be setting itself up for potential bugs when used like this:\n>>> sorted([1, 2, 3, 4, 5])\n[1, 2, 3, 4, 5]\n>>> sorted([-3, -2, -1, 0, 1, 2])\n[-2, -1, 0, 1, 2]\n\nIt's an easy mistake to make. In fact, I can see how it's happened. In Python 2, it would be\n>>> sorted(sorted(sorted(sorted(sorted(...)))))\n>>> sorted(sorted(sorted(sorted(sorted(...))))))\n>>> sorted(sorted(sorted(sorted(sorted(...))))))\n>>> sorted(sorted(sorted(sorted(sorted(...))))))\n... and it's just as broken. I've made that mistake a few times.\n\nThe reason is that Python's sorting algorithm is recursive:\n>>> s = sorted([1, 2", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    # declare array and sort it with the default algorithm\n    arr = [1, 5, 2, 3, 4]\n    arr.sort()\n    print(arr)\n    # sort by binary representation, so the first element is 1\n    arr.sort_by_bits(b'0100')\n    print(arr)", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    def sort_array(arr):\n    \"\"\"\n    Start with a new list (arr) where the first element is a special value\n    that tells the rest of the list to be treated as integers.\n    Return a new list where the integers are sorted, and the special value is\n    returned as the last element.\n    >>> sort_array([1, 2, 3, 4]) [1, 2, 3, 4]\n    >>> sort_array([1, 2, 3, 4, 5]) [1, 2, 3, 4, 5]\n    >>> sort_array([1, 2, 3, 4, 5, -4]) [5, 4, 3, 2, 1, -4]\n    \"\"\"\n    results = []\n    for b in arr:\n       if b == 1:\n          results.append(b)\n      else:\n           results.append(arr[b])\n    return results", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    num = 0\n    for i in arr:\n        num += i\n        if num == len(arr):\n           return sort_integer(arr, key=num)\n    return sort_integer(arr, key=int(num))\n    def sort_integer(arr, key):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_integer([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_integer([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_integer([1, 0, 2, 3, 4]) [0,", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return [sorted(element) for element in arr if sorted(element) < sorted(element)]\nI don't understand why this should be used.  There are no negative values.\nThe returned array is not sorted and will be different every time.\n\nI think that your solution is the best, but I don't think it is that much better than the others.</s>", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    sorted = []\n    for i in range(len(arr)):\n       if i % 3 == 0:\n           sorted.append((i, i))\n    return sorted", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return sorted(\n         arr.astype(int)\n         if __name__ == \"__main__\":", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    for i, x in enumerate(arr):\n       if x > 0:\n          if x == 2**b:\n                return [i]\n                else:\n                  return [x]\n    if __name__ == '__main__':\n       print(sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5])\n       print(sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2])\n       print(sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4])\n\n1 2 3 4 5\n-2 -3 -4 -5 -6\n1 0 2 3 4", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return sorted(arr, key=lambda x: x.value)\n\nThat's all there is to it.\n\nNow I'd like to write a few words about why I chose this Kata for the first time.\n\nI've been thinking a lot about what makes a good Kata. I believe that the\nfollowing three criteria are important:\n\n- The problem should be specific (e.g. it should not be possible to solve\nit with some generic algorithm).\n- The problem should be easily understandable.\n- The solution should be elegant.\n\nI believe that this Kata satisfies all three. It is easy to understand. It\ndoesn't require you to invent a new sorting algorithm. The solution is\nelegant, since it is not only simple and efficient, but also beautiful.\n(The idea of using value-to-key mapping is so simple, yet so effective.)\n\nBefore we discuss the solution, let's see how it can be implemented using\nthe default sorting algorithm provided by Python.\n\n>>> def sort(a, key=None):\n    if key is None:\n        key = lambda x: x", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    arr = [1, 2, 3, 4, 5]\n    print \"Enter the array to be sorted.\"\n    input()\n    for i in range(len(arr)):\n        if arr[i] == 0:\n            arr[i] = -1\n        else:\n            arr[i] = i\n    print \"After sorting:\\n\"\n         for j in range(0, len(arr)):\n               print arr[j]", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\n    return [x]\n    for x in arr:\n        return sorted(ord(x) for x in xrange(len(arr)))\n   \n\nI thought it would be easy enough to be worth doing in C.\nI've changed the code to use ints rather than floats, and I'm getting good results, but it does involve a lot of conversion between binary and decimal.", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\nThis makes sense in the context of the sort kata.\nBut what is the actual reason for this code?\n\nIt's a simple problem to solve, but the question isn't really about solving the problem, but instead is about showing off the Python language's power.\nIn this case, the question could have been \"Sort the following string alphabetically: abcdefghijklmnopqrstuvwxyz\".\nIt's hard to come up with a better way to solve this problem with Python than the one provided, and it's also hard to come up with a more concise way to show off the language's power than the provided code.\n\nIf you're going to write a sorting algorithm, do it right:", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    for i in sorted(arr):\n        print i\n    print \"\n    [*] It is sorted!\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    kata_result = lambda i: sorted(kata_array(i))\n    while kata_result(0):\n        print '0'\n    else:\n        print '1'\n    if kata_result(0) == kata_result(1):\n        print '0'\n    if kata_result(1) == kata_result(0):\n        print '1'", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return arr.sort(lambda a, b: a[0] > b[0]? a[1] : b[1], key=lambda c: c)\n\nI had to use this for my last job. My first thought was to use a library like itertools, but I couldn't get it to work. It seems my gut feeling is not entirely wrong. This is the best solution I've come up with so far.\n\nI like your solution. It's simple and effective. I was curious what you were doing for the off-by-one case, since that would be the obvious next step (a[0] < b[1] would need the same treatment).\n\nThe off-by-one case is not really a problem. If you think about it, you don't care about the last element. If it happens to be out of order, it doesn't change the sort order of all other elements, so it doesn't matter.\n\nI think the correct answer is a cross join. The key is to determine the number of elements in the set where the first element is greater than the second element, then the second element is greater than the third, and so on.", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    @defer.filter(lambda x: x > 0, sort_array(arr))\n\nimport itertools", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    with numbers_list(len(arr), 0) as numbers:\n    for number in numbers:\n        print number\n        numbers[number] = 1\n    arr[number] = arr[number] + 1\n    return numbers\nI'm curious about the use of a for-loop here. Could someone enlighten me?\n\nI think it's because the \"decimal\" numbers have to be tested for equality with a regular for loop.\n\nThis could be done in a more concise way using lists as tuples:", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\nI guess that's a decent example of a Kata, but it's a bit too simple for a\nbeginner.\n\nI suppose for beginners, a good Kata would be implementing a bubble sort,\nand for more advanced users, implementing a quicksort.\n\nI'm not sure a bubble sort should be considered a good Kata. The typical\n\"implementing a bubble sort\" Kata involves comparing the inputs one at a\ntime. This is a bad idea.\n\nI think the input should be sorted in place and the output should be\ncompared. The problem with this is that the Kata doesn't have any \"right\"\nanswer.\n\nWhen I was learning C, I implemented the bubble sort algorithm, and in\norder to do it in place, I simply kept the entire array in an array called\n\"array\". I don't think that this is a good Kata.\n\nIt's not a good Kata because it's too simple. I think it's best to start\nwith an implementation of something like quicksort.\n\nI agree, but as a beginner, I don't think that a quicksort is a good Kata.\n\nThe problem", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    values = np.arange(10).reshape(arr.shape)\n    for v in values:\n        v = v / 255.0\n        for i in range(len(values)):\n            a = np.sum(values[i:i+1] - v[i])\n             sorted_arr = sorted(values[i:i+1], key=lambda x: x[i] - v[i])\n    return sorted_arr\n\nHere is one of the solutions I found:\nimport operator", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    # The test function sorts the input array.\n    def test(arr):\n    return sort_array(arr) == sorted_array(arr)\n\n>>> test(sorted_array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103,", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if arr.startswith(\"0\"):\n         return [x for x in arr if x>=0]\n    if arr.startswith(\"0x\"):\n         return [x for x in arr if x>=0 and x<=5]\n    if arr.startswith(\"0b\"):\n         return [x for x in arr if x>=0 and x<=5]\n    if arr.startswith(\"0b11\"):\n         return [x for x in arr if x>=0 and x<=3]\n    if arr.startswith(\"0b11100\"):\n         return [x for x in arr if x>=0 and x<=3]\n    if arr.startswith(\"0b1100\"):\n         return [x for x in arr if x>=0 and x<=3]\n    if arr", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if arr[-1] == 0:\n        return arr[1:]\n    return [arr[0] for i in range(len(arr))]\n\n(1, 3, 4, 5) == (1, 2, 3, 4, 5) is a lie:\n>>> import kata\n>>> print kata.sort_array([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: no conversion from 'int' to 'int'\n>>> print kata.sort_array([1, 2, 3, 4, 5], dtype=int)\n1 2 3 4 5\n\nThey are indeed not the same. This is because of the way Python interprets the string form of the array.\n>>> print arr(1, 2, 3, 4, 5)\n1\n>>> print arr(1, 2, 3, 4, 5) # empty tuple\nTraceback (most recent call last):\nFile \"<stdin>\",", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    for i in arr:\n         if i is None:\n            raise ValueError(\"Only numbers are allowed\")\n          else:\n              if i == 0:\n                  return i\n           else:\n                  return sum(i ** 32)\n                 i\n    return arr", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\nI like it. In many languages, the implementations of algorithms is a secondary consideration.\n\nThe problem with that code is that it is _incredibly_ inefficient.\n\nI don't see why. The idea is to start by sorting the 1s, then the 2s, etc.\nThe second loop has an O(n) complexity while the first and last loop have an O(n * log(n)) complexity, right?\n\nHe's talking about the fact that, for sorting the first number, the code creates and fills a whole new array just to hold the sorted value, rather than simply changing one of the values in the original array.\n\nOh, you're right. I think that it would be faster to build a whole new array because, in python, if you sort a list of n integers, it has to re-sort all the previous values and then update the new value. In this case, the array would be built with n-1 elements so that the first operation is only a sort of the first element.\n\nIn Java, it would be a hash map lookup.</s>", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\nOne more:", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if len(arr) == 1:\n        return arr\n    for i in range(len(arr)):\n        if ord(arr[i] % 2) == 1:\n            return sort_array(arr[i])\n    elif ord(arr[i] % 10) > ord(arr[i] % 100):\n            return sort_array(arr[i])\n    else:\n         return arr\n\n3.2.1\n- fixed a bug in the sort_array() function that caused it to be run on the\ncomplete list.\n- implemented the sort_array() function\n- increased the number of input arguments from 2 to 3\n- increased the number of output arguments from 2 to 3\n- increased the number of tests from 6 to 7\n\n3.2.2\n- fixed another bug in the sort_array() function that caused it to be run\non the complete list\n- implemented the sort_array() function", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return lambda x: x[1]*x[0]\n\nKata: Suppose a and b are two positive integers, where a is not equal to\nb.\nWrite a function that determines whether a is greater than b.\nThe function should use only arithmetic operations (+, -, *, /) and the\noperators || and &&.\n\nSee Also\n\nNotes\n\nThis problem is a bit tricky. It\u2019s actually pretty easy to write a quick-and-dirty solution to the problem (see below). However, in order to write a more maintainable and reusable solution, you\u2019ll need to understand recursion and iteration.\n\nHere\u2019s the quick-and-dirty solution:", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return [n for n in sorted(array) if n[0] == 1]", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return sorted(ord(arr[1]), int(arr[1]))", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\n    if arr[-1] == 0:\n        return arr[0]\n    elif arr[-1] == 1:\n        return arr[1]\n    elif arr[-1] == 2:\n        return arr[2]\n    elif arr[-1] == 3:\n        return arr[3]\n    else:\n        return arr\n        return sorted(arr)\n\nJust in case you don't understand this, it's written in Python, which has list and tuple datatypes, and lists can be sorted.\n\nOops, I should have made that clear.\n\nI think it's a pretty neat idea. I think it would be helpful to have a way to edit the code.\nAlso, it would be great to see a full Kata that has been solved by somebody.\n\nI'm in the same boat...I'm thinking of a way to let people edit the code, but I want to be able to verify", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return [int(arr[0], 2) for arr in arr.items()]\nI wouldn't be so quick to dismiss this.  You're solving a well defined problem using a simple data structure.  You're also avoiding any sort of OO paradigm, so you don't get bogged down in designing a class hierarchy.  A simpler solution may very well be to write an ordered dictionary class and use that.\n\nI'm not dismissing it, I'm saying it's not a kata.\n\n\"If I had more time, I would have written a shorter letter.\" \\- Blaise Pascal\n\nThe problem is that it is too simple.\n\nI don't think that's the problem.\n\nThe problem is that it doesn't test your understanding of the data structures/algorithms you are using.\nThis can be achieved in multiple ways.\na) Kata is a very bad idea (because the solution is trivial)\nb) Kata is a very good idea (because you can explain the solution to someone else and be asked questions about your solution)\nc) Kata is a very good idea (because the solution is trivial)\nd) Kata is a", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    arr = [False, False, False, False, False, False, False, False, True]\n    sort_array = lambda x: x < x[-1]\n    return sort_array(arr)\n\nThis is a pretty easy one! The only thing to note is that you have to define your sort function to be in terms of the array's members: you can't use the array name.\n\nThis is an example of what a general sort function might look like:", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if arr.endswith(''):\n        return arr\n    n = 0\n    while n < len(arr) and n!= len(arr):\n        i = n % len(arr)\n        if arr[i] == 1 and arr[i+1] > arr[i]:\n            break\n        else:\n             n -= i\n             i += 1\n    return sort(arr[::-1], key=lambda x: x[1] if x[0] == 1 else x[0] - 1)\n\nI'm not sure if the downvotes are for using Python or for using a kata?\n\nI'm not sure if the upvotes are for using Python or for using a kata?\n\nI'm not sure if the neutral votes are for using Python or for using a kata?\n\nI'm not sure if the comments are", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return np.array(arr).sort(key=lambda x: 1 if x > 0 else 0, reverse=True)", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\nfor i in arr:", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    kwargs = {'arr': arr}\n\n    return lambda v: sorted(sort(v, key=lambda n: n % 2==0, reverse=False), key=lambda n: n%2==0)\n        # sorted(x, key=lambda n: n % 2==0, reverse=False) returns a sorted list\n         # of the same type as x", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    def sort_array(arr):\n    \"\"\"\n    Arrays are passed as function arguments in Python.\n    >>> [1, 2, 3, 4] = [1, 5, 2, 3, 4]\n    >>> sort_array(arr) [1, 2, 3, 4]\n    >>> sort_array([1, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n    if arr is None:\n       print \"Enter array of integers:\"\n       print \"Enter value (sorted in descending order): \"\n       print \"Enter value (sorted in ascending order): \"\n       print \"Enter value (sorted in ascending order): \"\n    return\n    # Find the length of the array\n    # Number of elements / 2\n    # Number of elements\n    # Size of the smallest element\n    arr_size = len(arr) / 2\n    arr_size_return", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    # now let's define a helper function\n    def binary_sort(arr):\n    \"\"\"\n    Binary sort:\n    >>> binary_sort([1, 2, 3, 4]) == [1, 2, 3, 4]\n    >>> binary_sort([-1, -2, -3, -4]) == [1, 2, 3, 4]\n    \"\"\"\n    return arr.sort(key=lambda c: c.bits() & 1)\n    # try to use the helper function for the kata\n    sorted_array = binary_sort(arr)\n    print sorted_array", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return [i[0] for i in sorted(arr)]\n\nI feel like this sort of puzzle is a symptom of the \"It's the thought that counts\" mentality.\nIt's not that it's a bad question, it's just that it's a lot of effort to answer when I could do a lot better work in that time, so I'm not going to answer it.\n\nThey're not questions, they're practice exercises.\nIt's the same reason that you see programming exercises on Hacker News, or on the Google jobs page.\n\nKata's are great. As a problem solving exercise they force you to focus on the process of solving the problem. As an educational exercise, they demonstrate the importance of code elegance and clarity and have the added bonus of being fun!\n\nI like these Kata's as well, and agree that they are good for programming exercises. I am also very surprised to see so many comments questioning the utility of these Kata's.\n\n\"Kata\" is a Japanese word for the practice of a martial art.\nIt is also a Japanese word for the art of crafting a sword.\nIt is a Japanese word for the art of storytelling.\nIt is", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\n        if len(arr) > 1:\n          return sorted(arr[1:])\n    else:\n          return sorted(arr)\n\nI'm not sure what you mean by \"non-negative integers\", but the first time I\nread this code I interpreted it as only being able to sort negative numbers\nby number of ones.\n\nWhat is the difference between a \"non-negative integer\" and a \"negative\ninteger\"?\n\nThe distinction between positive and negative integers is that positive\nintegers are numbers that can be expressed as a non-negative finite\ndecimal fraction.  Non-negative integers are all positive integers, and\nnegative integers are all the integers except for positive integers.\nThe mathematical definition of \"non-negative integer\" can be found in\nthe wikipedia article \"Number theory\".</s>", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\n    def sort(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n    For the comparison, you can use the string comparison method (==).\n    >>> sort([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    >>> sort([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n\n    return sorted(arr, key=lambda x, y: (x, y), reverse=True)\n\n    def sorted(arr, key=lambda x, y: (x, y), reverse", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    arr = []\n    def one_to_one_conversion(num):\n        return num + 1\n    arr.append(one_to_one_conversion(arr[0]))\n    arr.append(one_to_one_conversion(arr[1]))\n    arr.append(one_to_one_conversion(arr[2]))\n    arr.append(one_to_one_conversion(arr[3]))\n    arr.append(one_to_one_conversion(arr[4]))\n    arr.append(one_to_one_conversion(arr[5]))\n    arr.append(one_to_one_conversion(arr[6]))\n    for i in range(len(arr)):\n        if arr[i] == 1:\n            return arr[i]\n        else:", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    for k in range(len(arr)):\n        arr[k] = arr[k] //! 1-based\n        arr[k] //! Decimal representation of arr[k]\n        if arr[k] == 1:\n             arr[k] = arr[k] //! Decimal representation of arr[k]\n             arr[k] = arr[k] //! 1-based\n        else:\n             arr[k] = arr[k] //! 1-based\n    return arr\n\nThis is a good kata because it brings together a variety of topics:\n\n\\- Binary Search\n\\- 1-based indexing\n\\- Decimal representation\n\\- Using a custom representation for your problem\n\\- Simple lookup tables\n\nIt's the sort of kata that I would do a few times on my own, then share with someone who I was working with. Then,", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\nThis is a good Kata, but I think there are some \"gotcha's\" about it.\n\nI was kind of surprised when it didn't work on the first attempt.\nI think the output is the opposite of what I would expect.\n\nI think this one was the most surprising:\n\n>>> [1, 3, 8, 5, 4, 6, 2, 1, 9, 7, 3, 10, 11, 8, 2, 6, 9, 4, 7, 12,\n3, 13, 5, 11, 2, 4]\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,\n19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return lambda x: x[1] - x[0] if x[0] > x[1] else x[0] - x[1]\n\nSo, if you think about it, this is really a sort_binary_array.\n\nAlso, you could probably reorder the code a bit to make it easier to understand, and more efficient.\n\nI'm not sure I understand what the comment has to do with my solution, but the code is a bit ugly.\n\nRight now, the sort method is doing two compares of every element of the array. A simple optimization is to make the comparison a bit smarter and only do one comparison per element if they compare equal:", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    arr = [1, 5, 2, 3, 4]\n\n    return arr.sort()\n\nKata: sort_array\n\n__author__ = 'David Mertz'\n__date__ = '2008-02-08'\n__date__ = '2008-02-08'\n__date__ = '2008-02-08'\n__date__ = '2008-02-08'\n__date__ = '2008-02-08'\n__date__ = '2008-02-08'\n__date__ = '2008-02-08'\n__date__ = '2008-02-08'\n__date__ = '2008-02-08'\n__date__ = '2008-02-08'\n__date__ = '2008-02-08'\n__date__ = '2008-02-08'\n__date__ = '2008-02-08'\n__date__ = '2008-02-08'\n__date__ = '2008-02-08'\n__date__ = '2008-02-08'\n__date__ = '2008-02-08'\n__author__ = '", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    #print(\"In this Kata, you have to sort an array of non-negative integers\")\n    #print(\"according to number of ones in their binary representation\")\n    #print(\"in ascending order.\")\n    #print(\"For similar number of ones, sort based on decimal value.\")\n    return sort([1, 2, 3, 4], key=lambda i: i.bit_length(), reverse=False)", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    from collections import defaultdict\n    import operator\n    arr = defaultdict(int)\n    for n in range(1, size(arr)):\n       if n == 0:\n           arr[n] = n * 10 + 0\n    else:\n           arr[n] = n\n    return arr\nIt's not that obvious if you're not already familiar with the \"pass in a list, return a dict\" idiom.\nI'd probably go with:", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    # count ones\n    for i in range(len(arr)):\n        if arr[i] == 1:\n           count_ones += 1\n        else:\n           count_ones = 1\n    # sort in ascending order\n    for j in range(len(arr)):\n        arr[j] = sorted(arr[j], key=lambda i: (count_ones * i))\n    return arr", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return sorted(arr, reverse=True)\n\nThe Kata is similar to sorting integers in ascending order, except that the numbers must be in binary format. The code is the same as in the original version, except that the sort function must support the reverse option and the binary format:", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\n          if isinstance(arr, array):\n             return arr.sort()\n\n          return sorted(arr)\n\nelse:\n    \"\"\"\n    In this kata, you have to sort an array of non-negative integers\n    according to number of ones in their binary representation in\n    ascending order. For similar number of ones, sort based on decimal\n    value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n          if isinstance(arr, array):", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return array(0, array(0, 0), array(0, 1), array(0, 2), array(0, 3),\n    array(0, 4), array(0, 5), array(1, 0), array(1, 1), array(1, 2), array(1,\n    3), array(1, 4), array(1, 5), array(2, 0), array(2, 1), array(2, 2),\n    array(2, 3), array(2, 4), array(2, 5), array(3, 0), array(3, 1), array(3,\n    2), array(3, 3), array(3, 4), array(3, 5), array(4, 0), array(4, 1),\n    array(4, 2), array(4, 3), array(4, 4), array(4, 5), array(5, 0), array(5,\n    1), array(5, 2), array(5, 3), array(5, 4), array(5, 5), array(6, 0),", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if len(arr) < 4:\n       return arr\n    else:\n       # Extra credit: sort based on decimal value\n       return sort(arr[::-1], key=int(arr[::-1]), reverse=True)\n   \n\nI hate to be that guy, but if len(arr) < 4 then it's not an array, it's a list.\n\nYes, you are correct. If len(arr) == 4, then we can assume arr has the four values 1, 2, 3, and 4. The if statement is correct, but the return value is not.\n\nI was a little confused by this, but looking at it, it's exactly the same thing.\n\nThe list [1, 2, 3, 4] is not an array.\n\nI was expecting an array and was confused by the list.\n\nsorry I missed this!\n\nNo problem. When I first saw this, I was expecting to be able to use len() to create a sorted array.</s>", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return sorted(arr, reverse=True)\n\nThis was one of the easiest katas for me. I had to fiddle a little bit with the sort function though.\n>>> from string import ascii\n>>> sorted([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n>>> sorted([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n>>> sorted([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n>>> sorted([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n>>> sorted([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n>>> sorted([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n>>> sorted([1, 2, 3, 4, 5]) == [1, 2, 3, 4, 5]\n\n>>> sorted([1, 2, 3, 4, 5]) == [1,", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    def sort_array(arr):\n    \"\"\"\n    This is an example of what to implement.\n\n    >>> from random import randint\n    >>> arr = [randint(1, 10), randint(10, 1), randint(1, 100),\n    randint(100, 1), randint(1, 1000), randint(1000, 1),\n    randint(1, 10000)]\n    >>> sort_array(arr)\n    [1, 10, 100, 1000, 10000]\n\n    The solution is based on the following logic:\n    * The first element in the array will be compared with the first\n    element in the sorted array. If they are equal, then the element will\n    be compared with the next one. The first difference will be selected.\n    * If there is more than one difference, the one with the greatest\n    magnitude will be selected.\n    * If there is no difference in magnitude, the one with the greatest\n    absolute value will be selected.", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    # Sorting an array with an unknown number of elements.\n    # Case 1: when size is known and is less than the number of elements\n    # Case 2: when size is not known and is equal to the number of elements\n    # Case 3: when size is not known and is greater than the number of elements\n    for i in range(len(arr)):\n       if arr[i] == 0:\n          return arr[i]\n      else:\n          return arr[i]\n\nHow does that work?\n\nIt doesn't. It's useless, and in fact it doesn't even work for small arrays.\n\nIt seems to work for small arrays.\n\nThis isn't a kata. I know this is a \"kata\" but this is a bad idea.\nIn the real world I don't think people who write sorting algorithms are going to be stopped dead in their tracks by a question about what's the name of the \"python built-in sort function\".\n\nI would think that", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return [int(arr[i] - 1) if i % 2 == 0 else i for i in range(len(arr) - 1)]\n\nWe can pass this function to the compare_function from kata1.py and the output\nwill be:\n\n>>> from kata1 import compare_function\n>>> compare_function(sort_array)\n[0, 1, 2, 3, 4]\n\nIn [16]: kata2 = compare_function(sort_array)\nIn [17]: kata2(1, 2, 3, 4)\nOut[17]: [1, 2, 3, 4]\n\nThe above code does not handle negative numbers, but we can easily extend it to\ndo so. The following function accepts negative integers too.</s>", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    for i in range(len(arr)):\n        if i < len(arr):\n           arr[i] = i - 1\n         else:\n           arr[i] += 1\n    return arr\n\nThe first interesting point is that this algorithm is not as fast as the naive one. The second interesting point is that this algorithm is very simple and easy to read.\n\nThis solution is exactly what you might expect from the description. The most interesting part is in the details.\n\nIt uses two nested loops to process the array, one for the lower bits and one for the upper bits.\n\nThe first step is to process the first loop. It has to process the first element, that is, the most significant bit, and then decrement the first element by one. The decrement is necessary because it has to be done in a way that, when the upper loop is done, the number of elements in the array will be the same as the number of elements in the original array.\n\nAfter this, the first loop has to", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\n    def __init__(self):\n    \"\"\"\n    This function is called by the __init__ method.\n    The number of items in the array, arr.\n    The number of items that must be returned at a time, n.\n\n    Return: an array, of the same length as the original array, that is\n    sorted. If the length of the array is odd, return an array of\n    length n-1.\n    \"\"\"\n    # A space-efficient array of the number of items in the original array.\n    self._items = self._size + 1\n    return sorted(self._items, key=lambda x: x[0], reverse=True)\n\n    # A space-efficient array of the number of items in the original array.\n    self._items = self._size + 1\n    return sorted(self._items, key=lambda x: x[0], reverse=True)\n\n    # A space-efficient array of the number of items in the original array.\n    self._", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    sorted_array = []\n    for i, element in enumerate(arr):\n       if i == 1:\n           sorted_array.append(element)\n    else:\n            sorted_array.append(reverse(element))\n    return sorted_array\n\nThis is brilliant.\n\nI must say that I really enjoyed working through this kata. The comments on each section are very helpful too.\n\nI've added a \"kata\" badge to the title. If you don't want that, please send us a modmail and we'll remove it.\n\nDone. Thanks.\n\nIs there any good resource for reviewing kata? I've been looking for something like this for a while.\n\nI've been working my way through them one at a time. I had to look up how to spell kata, though.\n\nI find it really interesting to see the variations in the solutions. I especially like the idea of doing a for loop in the middle of a for loop. It's one of those things that doesn't look", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    results = [0]\n    for i in range(len(arr)):\n       if arr[i] > 0:\n           results.append(arr[i])\n       else:\n            results.append(0)\n    return results\n\n>>> print sorted([1, 5, 2, 3, 4], key=lambda x: x[0])\n[0, 1, 2, 3, 4]\n>>> print sorted([-2, -3, -4, -5, -6], key=lambda x: x[0])\n[-6, -5, -4, -3, -2]\n>>>", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if arr.size == 1:\n       return arr\n    else:\n       if arr.size > 2:\n           # show the 2-element case\n            return sort_array(arr[0], arr[1])\n            return arr\n    for i in range(0, arr.size):\n        for j in range(0, arr.size):\n           if arr[i] == 1:\n               return arr[j]\n        else:\n              if arr[i] == 0:\n                 return arr[j]\n        else:\n               if arr[i] == 1", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\nI don't see the need to write a Kata. A decent class with an __init__, __len__, __cmp__ and __repr__ method will do the trick.\n\nIt's not a Kata. It's a puzzle. The point of the exercise is to understand the algorithm and to know how to implement it, not to copy-paste a solution from the internet.\n\nI'm not interested in writing a kata. The premise that I need to write a kata to understand sorting algorithms is ridiculous.\n\nI would just write a single function for that. No need to complicate things.\n\nThis is a good introduction to writing a Python quicksort.\n\nThank you for posting this. I'm currently learning Python and it's very helpful to see how someone implements it with a simple explanation of why they are doing each step.</s>", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\n    from collections import defaultdict\n\n    from functools import wraps\n\n    arr = defaultdict(int)()\n\n    k = 100\n\n    def compare_digits(a, b):\n    \"\"\"\n    Given two strings and a binary representation of number of ones in them,\n    returns -1, 0, 1 for these strings:\n    >>> from collections import defaultdict\n    >>> d = defaultdict(int)()\n    >>> d['1'] == d['1']['0'] == 1\n    >>> d['1'] == d['1']['1'] == 1\n    >>> d['1']['2'] == -1\n    >>> d['2'] == d['2']['0'] == 0\n    >>> d['2'] == d['2']['1'] == 1\n    >>> d['3'] == d['3']['0'] == 1\n    >>> d['3'] == d['3']['1'] == 1\n    \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if arr[0] == 0:\n        return arr\n    else:\n        return sorted(arr)\n\nIt's interesting that the author specifically calls out the non-negative values. I'm not sure if I agree with that - I think the sort order should depend on the type of integer (i.e., int vs long), not whether they're negative.\n\nI don't think the author was particularly interested in sorting by value, but rather in sorting by bit-ness.\n\nThis is a Kata. It has nothing to do with \"real life\" and you should ignore that part.\nYou should probably not be using `isinstance()` for \"determining\" the type of `numbers` (which is a bad name, by the way. `float`, `int` and `long` are integers). You should use the `isdigit()` function.\nThe correct answer for the kata is to write the function as a decorator:\nfrom functools import wraps", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    arr = [1, 0, 2, 3, 4]\n    while True:\n       if arr[i] == 1:\n          arr = sort_array(arr[i], key='binary_ones')\n          break\n       else:\n          arr = sort_array(arr, key='decimal_ones')\n    return arr", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if arr.startswith('0'):\n        return reverse(arr)\n    elif arr.startswith('1'):\n        return (int(arr[0]) + 1) / (2**(int(arr[0])))\n    elif arr.startswith('2'):\n        return (int(arr[1]) + 1) / (2**(int(arr[1])))\n    elif arr.startswith('3'):\n        return (int(arr[2]) + 1) / (2**(int(arr[2])))\n    elif arr.startswith('4'):\n        return (int(arr[3]) + 1) / (2**(int(arr[3])))\n    elif arr.startswith('5'):\n        return (int(arr[4]) + 1) / (2**(int(arr[4]", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    print \"Sort order is %d, %s, %s, %s, %s\" % (arr[0], arr[1], arr[2], arr[3], arr[4])\n    arr = [0]*64 + [1]*63 + [2]*62 + [3]*61 + [4]*60\n    return sort(arr, key=lambda n: int(n) % 64, reverse=True)\n    print \"Order is %s\" % arr\n\nHow much time did it take for you to solve this kata?</s>", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if arr[0] < arr[1]:\n         arr = sorted(arr)\n    else:\n         arr = sorted([1], key=lambda i: i)\n    return arr\nI would be suspicious of a test like this. It feels like a test that says \"we want to see you using a library\" and not a test of your ability to write clean, readable code.\n\nIt's a pretty reasonable test. Even if you don't use a library to do the sorting, you should still use one to ensure that it is performed correctly (especially for performance critical code).\n\nOne could argue that you should know how to use the standard library in order to be a good programmer.\n\nThe standard library, particularly in Python, isn't particularly good at performance sensitive code. Writing your own sorting algorithm that is both correct and fast is difficult.\n\nThe standard library is perfectly fine for performance sensitive code. How are you supposed to write your own sorting algorithm if you don't know how to use the standard library to do it? You're not going to do it correctly and you're not going to get it", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    i = 0\n    while i < len(arr):\n       if arr[i] == 1:\n          arr[i] = arr[i] + 1\n       else:\n          arr[i] = arr[i] * 2\n    i += 2\n    return arr", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\nWell, I thought I was going to have to bite my lip to get through this kata, but this is the first one where I'm like, \"eh.\" It's not even that I disagree with it, it's just I don't see what's so hard about this kata.\n\nIt's not even a kata. It's a single one-liner.\n\nI think this is an amazing kata. It is easy enough that you can do it in a couple minutes, but it is hard enough to make you really think about the algorithm. I love katas like this that get me to think and to question how I do things.\n\nIf you get a chance to look at the solution, you will see that it is a single one-liner. That is, it is a single line of code that uses a function that is built up from other functions and other lines of code.\nThe kata itself is great for getting you to think, but the actual solution is kind of irrelevant, especially if you think it's just a \"single one-liner\".\n\nIsn't this the first kata?\n\nI don't think so. I think the first kata is actually much harder.", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    def split_arr(arr, a, b):\n    \"\"\"\n    In this Kata, we are given an array arr of non-negative integers in binary\n    representation. It should be split into two arrays a and b with\n    a[0] = b[0] and a[1] = b[1]. Each of the arrays a and b will be\n    non-negative integers in decimal representation. For each element of the\n    original array arr, the corresponding element in the resulting arrays\n    a and b will be the same if the bit-wise equivalent of the element in\n    binary representation is non-zero and otherwise will be different.\n    There are no duplicates in the resulting arrays.\n    For example, arr = [0,1,2,3,4,5,6,7] gives a = [0, 1, 2, 3, 4] and b =\n    [5, 6, 7].\n    >>> split_arr([0, 1, 2, 3, 4, 5, 6, 7]) == [0", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return sorted(arr, key=lambda a, b: ord(a), reverse=True)\n\nThis is a bug.\n>>> sorted([1, 2, 3, 4]) == [1, 2, 3, 4]\n>>> sorted([-1, -2, -3, -4, -5]) == [-5, -4, -3, -2, -1]\n\nWow, you're right. That's not very Kata-like, is it?\n\nIn this case, I think you'd have to re-sort the elements if the original sort was equal.\n\nThis is a bug too.\n>>> sorted([1, 2, 3, 4], key=lambda a, b: ord(a), reverse=True) == [1, 2, 3, 4]\n\nIt looks like the bug isn't in this case but in the original case.\n\nI think it's more like the bug is in the Kata itself. The original case is fine as-is.\n\nI was thinking the same thing. If you have to keep re-sorting, then you're never\ngoing to be able to get it working correctly in", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if len(arr) == 1:\n    return arr\n    else:\n       arr = [arr[0], arr[1], arr[2], arr[3], arr[4]]\n       arr[0] = -1\n       arr[1] = 1\n       arr[2] = 2\n       arr[3] = 3\n       arr[4] = 4\n       arr = [arr[0], arr[1:3], arr[4:] + arr[0], arr[1:3]]\n    return sorted(arr)\n\nThe code for this solution is on GitHub.", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    a = sorted(arr)\n    return a\n\nYou can also use it as a function:\n>>> from itertools import chain\n>>> sorter = chain([sort_array(), sorted(arr)])\n>>> sorter([2, -1, -1, -1, -1, -1]) == [2, -1, -1, -1, -1, -1]\n>>> sorter([1, -1, -1, -1, -1, -1]) == [1, -1, -1, -1, -1, -1]\n\nsorter() is a bit more readable, too.</s>", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\n    for i in arr:\n         if i % 2 == 0:\n             # count number of ones\n              # and if same, sort based on decimal value\n               # and otherwise, sort based on binary value\n               # and if same, sort based on decimal value\n                # and otherwise, sort based on binary value\n                # and if same, sort based on decimal value\n                # and otherwise, sort based on binary value\n                 # and if same, sort based on decimal value", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\n    result = []\n    for i in arr:\n        result.append(0 if i!= 1 else 1)\n        result[0] = sort_int(result[:])\n    return result", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return [int(x) for x in sorted(arr) if x == 1 else 0 for x in sorted(arr) if x == -1 else 0 for x in sorted(arr) if x == -2 else -1 for x in sorted(arr) if x == -3 else -2 for x in sorted(arr) if x == -4 else -3 for x in sorted(arr) if x == -5 else -4 for x in sorted(arr) if x == -6 else -5]\n\nI'm a bit unclear on the rules regarding for loops. I don't think this is allowed, but:", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    sorted = [0]\n    while len(arr) > 1:\n        s = sorted.pop(0)\n        if s!= 0:\n            return s\n            if len(s) > 1 and len(s) % 2 == 0:\n                  sorted.append(s[1:-])\n                else:\n                  sorted.append(s[0:-])\n    return sorted", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if len(arr) < 2:\n       return arr\n    for i in range(1, len(arr) - 1):\n       s = arr[i]  # pick the first number in array\n       if s == 0:\n          if s == 1:\n              s = -s\n            else:\n              s = s + 1\n             # pick the next number in array\n            if s!= 0:\n                if s == 0:\n                   s = -s\n                  else:", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    print arr.sort()", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    def sort(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n    It must be implemented like this:\n    >>> sort([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n    if arr is None:\n       arr = []\n    else:\n       arr = sorted(arr)\n    return sort", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if arr[0] == 0:\n       return arr\n    else:\n       return [0] * len(arr)\n\n>>> from collections import defaultdict\n>>> def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n    if arr[0] == 0:\n       return default", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    print(\"\\n0: \" + str(len(arr)) + \"\\n\")\n    # Declare the function and assign it to the variable sort_array\n    def sort_array(arr):\n        if arr[0] < arr[1]:\n            return arr[0]\n        else:\n            return arr[1]\n        arr_len = len(arr)\n        return arr_len\n    arr = []\n    for i in range(arr_len):\n        arr.append(i)\n    print(\"\\n1: \", arr)\n    print(\"\\n2: \", arr[0])\n    print(\"\\n3: \", arr[1])\n    print(\"\\n4: \", arr[2])\n    print(\"\\n5: \", arr[3])\n    print(\"\\", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    print('Sorting an array of integers according to number of ones in their binary representation.')\n    for number in range(0, len(arr)):\n        print(number)\n        arr = sorted(arr, key=int(str(number)))\n        if arr is None:\n           print('No match')\n         else:\n            print('Sorted')\n   \n\nIf you want to sort an array of ints, then you can do:\n>>> from itertools import izip\n>>> sorted([[1, 2, 3], [5, 4, 3, 2], [4, 3, 2, 5]])\n['1', '2', '3', '5', '4', '3', '2', '5']\n>>> sorted([1, 2, 3, 4, 5])\n['4', '3', '2', '1', '5', '5']\n\nYou can also pass", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    if nb_ones == 0:\n        return []\n    if nb_ones == 1:\n        return arr\n    if nb_ones == 2:\n        return [num - 1 for num in arr]\n    else:\n        return arr\n\nHere is my solution:</s>", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return sorted([arr[i] for i in range(0, len(arr) - 1)])", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    for i in range(len(arr)):\n        if arr[i]!= 1:\n              arr[i] = 1\n       else:\n               arr[i] = -1\n    return arr", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    return lambda x: x.dec() == 0 if x:\n          return lambda x: x.int() > 0\n         else:\n          return lambda x: x.int() == 0\n\nOn 8/27/06, Michael Bayer <mbayer at gmail.com> wrote:\n> On Tue, 27 Aug 2007, Steve Holden wrote:\n> > I have to admit to being a little confused.\n> >\n> > I've been working through the kata, and I'm still not really sure what\n> > is expected. Is it supposed to sort the numbers in the array, or sort the\n> > string representation?\n> >\n> > Is this supposed to sort the numbers as strings?\n> >\n> > >>> sorted(sorted(range(3))) [1,2,3]\n> >\n> > Or is it supposed to sort the numbers as integers?\n> >\n> > >>> sorted(sorted(range(3))) [3,2,1]\n> >\n> > And is it supposed to do", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    for i in range(0, len(arr)):\n        if arr[i] == 0:\n            return arr[i]\n    else:\n             return arr[i] - int(arr[i] * 10)\n    return arr\n\nThe above is a simple solution. However, it is possible to further\noptimize this solution for efficiency. The following algorithm should\ngenerally be faster than the above.\n1) Start at the smallest number\n2) If its in-order binary representation has a 1 in the bit position\nthat will be the lowest bit in its decimal representation, move on to\nthe next smallest number.\n3) Otherwise, move on to the next smallest number\n4) Repeat step 2\n5) If we have exhausted the input, return the last number.", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n    results = []\n    for i in range(len(arr)):\n       for j in range(0, len(arr)):\n          result = arr[j]\n          if j == 0:\n              results.append(result)\n             result = int(result)\n             results.append(dec(result))\n    return results", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\nPython 3 (2.6)\n[1, 5, 2, 3, 4]\n[-2, -3, -4, -5, -6]\n[1, 0, 2, 3, 4]\n\nPython 2 (2.5)\n[1, 5, 2, 3, 4]\n[-2, -3, -4, -5, -6]\n[1, 0, 2, 3, 4]</s>", "def sort_array(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> sort_array([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\" \"\"\"\n\n    if not len(arr) or len(arr) == 1:\n        return\n    else:\n\n    return arr[::-1]\n\n>>> from itertools import islice\n>>> islice(sort_array([1, 5, 2, 3, 4]), [::-1])\n[1, 2, 3, 4]\n>>> islice(sort_array([-2, -3, -4, -5, -6]), [::-1])\n[-6, -5, -4, -3, -2]\n>>> islice(sort_array([1, 0, 2, 3, 4]), [::-1])\n[0, 1, 2, 3, 4]\n\nIf you were to use Python's built-in sort() function, it would probably have to use a slower comparison routine (e.g. byte-by-byte comparison) than just looking at the number of ones.</s>"]]