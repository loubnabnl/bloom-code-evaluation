[["from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i < n:\n           i += 1\n    return i\n\nI wish someone would do a study on how many people are like me: I read this and got a little lost. I read it again and again and still couldn't get it. I finally had to copy and paste it into another file and run it. Then I got it.\nThe reason I think I got it is because I've had to do this kind of thing a number of times. Is it possible that I've internalized the proper way to write this kind of code? And that this makes it easier for me to understand than it is for someone who hasn't done this kind of thing?\n\nYes, that's possible.\nI know that after many years of programming, I read code like this and say to myself, \"OK, I know what's going on here.\"\n\nHehe, I knew it! ;-)\n\nIt's all about seeing what you already know, you don't need to understand the code in order to write it. But the problem is, if you don't understand it, you", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for n in numbers:\n        if n > max:\n           max = n\n           new_list = [max]\n           new_list.append(n)\n\n    return new_list\n\nI have no idea what's going on here...\n\nI think it means that the list is sorted by increasing value, and then it removes the max element and starts the sequence over. But I have no idea why it returns a new list instead of just continuing the list.\n\nIt returns a list so that the elements don't get overwritten in the original list when the list is sorted again.\n\nNo, it returns a new list to prevent duplicates in the list when it has to re-insert the previous max. This is a very common technique in functional programming, at least.\n\nWhy not just return a tuple with two items, the current maximum and the current number?\n\nI'm glad I'm not the only one who thought this. Why a list? Why not a tuple?\n\nI can't tell if", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i > rolling_max(i-1):\n           numbers.append(i)\n    return numbers\n\nI was hoping for a little more of a \"wow\" factor when I opened the link. This is a neat technique, but it's not something I couldn't have come up with on my own if I'd had to.\nThat said, it's always a good idea to see how other people approach problems like this. For a little more of a \"wow\", try implementing a Huffman Encoder (it's a real problem, not just a contrived example).\n\nThat's a cool little algorithm, thanks for sharing it!\n\nI'm trying to understand what the problem is that this algorithm solves?\n\nIt produces the next highest number in the sequence, that will not cause the previous maximum to roll off the end.\nFor example, if the list were:\n[1, 2, 3, 4]\nThen rolling_max(4) would produce:\n[1, 2, 3, 5]\n[1, 2, 3, 5]\n[", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n       numbers.append(rolling_max(numbers[i]))\n\nEven more concise, albeit less readable:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if len(numbers) == 1:\n       return numbers\n    # if the list is empty, return the first element\n    for i in numbers:\n       if i > min(numbers[i+1], numbers[i+2]):\n          max = i\n    return max\n\nCan someone explain the difference between this and the Python version? I've never used Python, but I'm having trouble seeing how this code would work with a list that doesn't have a defined length.\n\nYou could declare the type of the list. E.g.", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return (numbers[0].max(), numbers[0].max(), numbers[0].max(), numbers[0].max(), numbers[0].max())\n\nfrom typing import List, Tuple, Type, TypeError\nfrom operator import abs", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    while numbers:\n        max = numbers[0]\n        numbers = sorted(numbers, key=lambda i: i[1])\n        rolling_max = rolling_max(numbers[0])\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    while len(numbers) > 0:\n        if numbers[0] < numbers[1]:\n           return numbers[0]\n        else:\n            return numbers[-1]\n\nIf you want to see the way it's actually done, Python has a built in function to show you the internal workings of a function:\n>>> f = lambda x: x + 1\n>>> f()\n1\n>>> f(0)\n1\n>>> f([]).__doc__\n<class '__main__.F'>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        yield i\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    if numbers:\n        max = 0\n        for x in numbers:\n            if x > max:\n                max = x\n                x = x - max\n          else:\n               max = x\n    return max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    def next_min(numbers: List[int]) -> int:\n    \"\"\" Generate the smallest of all numbers in the given list\n    >>> next_min([1, 2, 3, 2, 3, 4, 2])\n    1\n    >>> next_min([1, 2, 3, 2, 3, 4, 2, 5])\n    2\n    \"\"\"\n    if len(numbers) == 0:\n        next_min = 0\n        numbers = [0]\n    else:\n        next_min = numbers.get(0)\n        for i in numbers:\n           if i < next_min:\n              numbers.add(i)\n          next_min = i\n    return next_min\n\nI like it. It's the same thing as:\nnext_min = 0\nfor", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    start = 0\n    for i in range(len(numbers)):\n        number = numbers[start]\n        number = rolling_max(number) + 1\n    return number\n\nfrom typing import List, Tuple\n\n\tdef rolling_max(numbers: List[int]) -> List[int]:\n\t\t\tstart = 0\n\t\t\tfor i in range(len(numbers)):\n\t\t\t\tnumber = numbers[start]\n\t\t\t\tnumber = rolling_max(number) + 1\n\t\t\t\treturn number\n\nSome people may not like the named tuples, but I've been bitten by the `:` syntax more than once (and no, I don't know what the f __* : does).\n\nI don't get it. I'm not a fan of the : thing, but this particular case does not appear to be an issue.\n\nFor example, \n\nBut surely, the issue here is that the name of the function is very similar to the for loop keyword? I'd say that's a bad choice of name.", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return [numbers[0].rolling_max() for n in numbers if n < n + 1]</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    if len(numbers) == 0:\n       return [1]\n    for i in range(0, len(numbers) - 1):\n        yield i\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for index, element in enumerate(numbers):\n        if rolling_max(element):\n           numbers.append(element)\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\nreturn numbers.reduce(lambda a, b: a + b, 0)", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    min = numbers.get(0)\n    max = numbers.get(len(numbers))\n    for i in numbers:\n       if rolling_max(i):\n         min, max = i, rolling_max(i)\n    return [min, max]\n\nI like the idea, but why not just:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if n is not in numbers:\n       return numbers\n    for i in numbers:\n       rolling_max(i + 1)\n    return rolling_max(numbers)\n\nThat's great. But if you don't already know Python, it's not obvious that the function returns a tuple (there's no indication of it anywhere). Why not make it clearer?\n\nMy version of Tkinter uses a Tuple as a \"Tuple of Tuple\" (ie. a nested tuple).\nI use that to keep track of the window list, and other things. I did it because I didn't want to rely on global variables for these things. I also use a Tuple for the GUI itself.\nIt's like a chain, where the first element is the only one that has a name.\n\nIsn't that a list?\n\nThe Python Tuple is a list-like, mutable container. That is, it's a mutable list.\n\nYeah, and his code has a list in it.\n\nI have always liked the list comprehension syntax in Python.\nThe LISP guys could learn", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    while n in numbers:\n        min = min(numbers[n])\n        max = max(numbers[n])\n        rolling_max(numbers[n:]) =\n        min, max\n    return rolling_max\n\nI believe the recommended style is:\nfrom typing import List, Tuple, min, max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    rolling_max = lambda x: x if x in numbers else None\n    rolling_max.add((numbers.pop()))\n    return rolling_max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    n = 0\n    for i in numbers:\n        if n < i:\n           n += i\n    return List(n)\n\nThis is a very specific example of a more general concept, which is to \"implement\" a sequential algorithm in an FP language like Haskell.\nI've been doing this in school recently (on a project involving some kind of path-finding algorithm), and it's very interesting how different the code can be.\nIn the case of the rolling max algorithm, I have to admit that the python version looks much more readable to me, but the Haskell one is quite a bit more efficient.\n\nI disagree. The Haskell version is more _elegant_ and _intellectually satisfying_, but I wouldn't say it's more readable. There is a lot of information in the Python version that is lacking in the Haskell version.\n\nIn the case of the rolling max algorithm, I have to admit that the python version looks much more readable to me, but the Haskell one is quite a bit more efficient.\nFor a given list of integers, generate a list of rolling maximum element", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    l = 0\n\n    while n in numbers:\n        l = l + rolling_max(n)\n\n    return l\n\nThis is cute, but it's also pretty useless. It could be used to generate the sequence (0,1,2,3,4,5) or (0,1,2,3,4,5,6).\nBut, more importantly, the name of the function is misleading. I can only think of one reason for using the word \"rolling\" here, and it's not to refer to the process of finding a maximum.\n\nI agree. I'm pretty confused by the name.\n\nIt doesn't find the maximum as a rolling process - it takes the maximum of the list of numbers.\nI was expecting something like the classic computer science problem - rolling a die until you get a six.\n\nThe python code is \n\nI would have called it, \"taking the maximum of a sequence.\"\n\nBut that's not what it does. It only takes the maximum if one exists in the list. For example, if I pass [1, 2, 3, 4] to rolling_max(),", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        numbers[i] = max(numbers[i], numbers)\n    return numbers\n\nWhy not simply return the list of element indexes sorted by value?\n\nI prefer a dictionary because the indices are ordered lexicographically, which is easier to parse than the arbitrary ordering that would result from sorting by value.\n\nI'm sorry, but that's just a terrible choice. I've never seen a dictionary used as an associative array.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return [numbers[0] + numbers[1] for i in range(numbers.length) if i\n    > numbers[0]][0] + numbers[numbers.length-1] for i in range(numbers.length)]", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    return numbers[i] + numbers[i + 1] +...\nThis code actually returns a Tuple. This is a problem because of the way python handles tuple unpacking, which is the default behavior for tuple assignment. The code in the blog post should be:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    while numbers:\n        numbers.remove(0)\n\n    if numbers[0] == 0:\n        numbers = [0]\n    else:\n        rolling_max(numbers)\n\nI don't get this? He removes the first element but then removes the last element from the new list?\n\nIn the list of the first item, the 0th element is removed. Then he checks if the list is empty. If not, he recursively calls rolling_max on the remaining items.\n\nI am a bit confused. Does he mean to remove the first 0 element from the list or to remove the first item in the list? The first item seems like it would be more correct because it keeps the list sorted, but I'm not sure if that's what he meant.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    rolling_max = Tuple[int]()\n\n    for number in numbers:\n        rolling_max.append((rolling_max(numbers.index(number, 0))) + number)\n\nIn a language without tuples, the first example would have been better as:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    numbers.reverse()\n    numbers.extend([numbers[0], numbers[numbers.len()]])\n    numbers.sort()\n    numbers.reverse()\n    numbers.extend([numbers[0], numbers[numbers.len()])\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    while numbers:\n        # get the maximum element found so far\n        max = numbers.get(0)\n\n        # now, generate a new list with that element as first element\n        numbers.insert(max)\n\n        # increment the position in the original list\n        numbers.append(rolling_max(numbers.pop()))\n\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0, n):\n        max = numbers[i]\n        rolling_max = rolling_max(max) + max\n\nOh geez, it doesn't even have a __future__ section. I'm going to have to write an exception handler for this.\n\nI've already had to add an exception handler to make my code work with python 2.3.2. Why do we even need this feature?\n\nThe temptation to post a (Python) link to the \"Church of the SubGenius\" is overwhelming.\n\nWell, Python is a really good language for comedy. I myself have used \"import X as Y\" to make a joke in Python, and I've seen others do it as well.\n\nIn [1]: import humor as humor\n\nActually, one of the main reasons I don't use Python much is that it's so hard to get a straight answer about whether a feature is available in the version I'm using.\n\nWell, in this case it's not a feature, it's a bug.\n\nBut it's a bug that's being touted as a feature by the", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    i = len(numbers)\n    while i > 0:\n        i -= 1\n        rolling_max = []\n        for number in numbers:\n            if number in rolling_max:\n                rolling_max.append(number)\n             else:\n                rolling_max.append(rolling_max.pop())\n              i += 1\n    return rolling_max\n\nmy code is not very clear. there are two points:\n1\\. you can easily generate a rolling max using `max(...)`\n2\\. the implementation can be much better if you know that the rolling max is used in a context of a `for` loop:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return sorted(numbers.items(), key=lambda x: x[0], reverse=True)\n\nYou can use any of the following instead of the type-specific import:\nfrom typing import *\nfrom typing import object\nfrom typing import (isinstance, istype)\nfrom typing import isinstance\nfrom typing import ord\nfrom typing import collection\nfrom typing import (isarray, isinstance, is_sequence, is_sequence_like, is_mapping, is_set, isinstance, issubclass, issuper, isinstance, isin, ismember, isdeeply)\nfrom typing import operator\nfrom typing import operator\nfrom typing import set\nfrom typing import collections\nfrom typing import *\nfrom typing import (isinstance, isinstance, is_callable)\nfrom typing import (isinstance, is_callable, is_method, is_static, is_instance, is_class, is_object)\nfrom typing import (isinstance, is_callable, is_instance, is_class, is_class, is_class, is_class, is_callable, is_callable, is_callable)\nfrom", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if n in numbers:\n        return numbers.get(n).sum()\n    return n + 1", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i % 2 == 0:\n           return i\n        else:\n           return rolling_max(numbers[i + 1])\n\nI'm surprised that python doesn't already have this, in fact this is a pretty classic problem.\n\nIndeed, the built-in max() will not tell you when you've found the last maximum element in a sequence.\n\nI wrote a (perhaps naive) variation of this function in C# a while ago, just to see if I could.\nFor what it's worth, I can't seem to find it now.\n\nPython has a built-in rolling_max() function. It also has the built-in sum() function that I can't find anywhere in the article, but I'm assuming is being used to create the range.\n\nHere's a Python function that creates a running sum of a range:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for x in numbers:\n        max = numbers[0]\n        rolling_max(max+1)\n\nI'm a little confused. I don't see the utility of this function.\n\nThis is a good example of what people mean when they say \"functional programming\". It's a nice little exercise to help people get into the mindset.\n\nI like how Python is becoming a bit more expressive in the functional style.\n\nI'm not sure that this is a good example of functional programming.\n\nthis is exactly what I've always wanted in python!\n\nThis is nice. Can't wait to see more.\n\nfrom typing import List, Tuple\n\nI'm a little confused. I don't see the utility of this function.\n\nThis is a good example of what people mean when they say \"functional programming\". It's a nice little exercise to help people get into the mindset.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    # Extract the first number which is greater than 2.\n    if len(numbers) > 2:\n        first = numbers[0]\n    # Save the elements, which are greater than 2.\n    numbers[len(numbers) - 1] = first\n    # Increment the numbers by 1.\n    # Loop until no more numbers are found.\n    while numbers[-1] < 2:\n        # Extract the maximum number found so far.\n        max = rolling_max(numbers[-1])\n        numbers[-1] = numbers[-1] + 1", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers == []:\n       return numbers\n    for i in numbers:\n       if i >= n:\n          if i % 3 == 0:\n              if i % 5 == 0:\n                 return i\n                   if i % 7 == 0:\n                     return i\n                     return rolling_max(numbers[i:i+n])\n    return numbers\n\nOr just learn python:\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 3, 4, 4]\n\nWouldn't that require you to define a function rolling_max in the first place?\nIt's hard to tell if", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n         results = [0]\n        for number in numbers:\n            if number > rolling_max(numbers - 1):\n                results.append(number)\n                 number = numbers - 1\n    return results", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    nums = numbers.copy()\n\n    for i in range(1, len(nums)):\n        max = 0\n\n        if nums[i] > max:\n            max = nums[i]\n\n    return nums\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    nums = numbers.to_list()\n    rolling_max = []\n    while nums:\n       rolling_max.append(nums[0])\n       if rolling_max!= nums:\n          rolling_max.append(nums[0])\n        nums = nums.to_list()\n    return rolling_max\nI remember a time when Python developers were proud to use the language that was \"batteries included\".  Now they're proud to use it because they can write the same types of things in a dozen lines that would take other languages a page.\nI'm not saying that this is a bad thing, but it's certainly a change in how the language is being used, and an indication of how it's being marketed.\n\nI think you mean \"python developers in the 90's\". These days there's quite a few people who have been doing python for a decade or more who are mostly just tired of the cargo culting and cruft.\n\nThose people have a lot more experience than I do,", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\nNeat! I wrote a rolling median calculation function the other day [0] and I find rolling methods of statistics to be quite interesting.\n\nThis is really cool!\nOne suggestion: if you change the name of a variable, it doesn't update the function code in the current cell. I'm not sure how this could be solved, but it's pretty annoying.\n\nIt seems that there are a few bugs when using the keyboard. For example, you can't use the arrow keys to scroll through the help and documentation.\n\nYou can use the arrow keys to scroll the documentation, but not the help. I need to add the full text of the help pages as well.\n\nOops, I was just testing the wrong keys. Thanks!\n\nI'm getting a memory access violation on this one:\nimport math\nimport random", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if len(numbers) == 0:\n        return numbers\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        max = numbers[i]\n        rolling_max(numbers[:i], numbers[i+1:])\n\nThis is a really good example of the magic you can get from functional programming.\n\nYeah, but if you're going to write Python, you might as well write it in a Pythonic way, and that means not using tuples, lists, or any other collection data structure for that matter.\n\nI'm pretty sure the Python community is split on tuples. Some people love them, some hate them.\n\nI'm also pretty sure that none of the people who love them would use them here, or in the vast majority of code in the wild. This is just a sloppy, unmaintainable hack.\n\nI'm a person who loves tuples and I think this is a great idea. In fact, I'd like to do it in Ruby. But I'm not quite as lazy as the", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    max_seen = 0\n    for number in numbers:\n       max_seen += 1\n       if max_seen > n:\n          return n\n    return max_seen\n\nThat's pretty. I didn't know you could call methods on tuples.\n\nTIL</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if len(numbers) == 1:\n       return numbers\n    x = 0\n    while x < len(numbers):\n       y = 0\n       if n[x] > y:\n          x = x + 1\n          y = y + 1\n          rolling_max(numbers[x:])\n           x = x + 1\n           y = y + 1\n          return y\n\nIn Python 2.5, you can use it like this:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n\n    numbers = Tuple(numbers)\n    rolling_max = max(rolling_max(numbers))\n    numbers.to_list()\n\nTruly beautiful, especially the emphasis on 'rolling'.\n\nlol, actually it was a typo and supposed to be 'routing' but the typo was so appropriate that I kept it.\n\nI was just going to ask about that!\n\nI would have left it, but then I read the comments on the original posting.\n\nI think the use of Tuples is probably the most interesting thing here. I would really like to know the use cases for Tuples, particularly when they are used as opposed to lists or dicts or sets.\n\nI used to think that tuples were a bit silly, but I've found that they come in handy when you want to maintain a single immutable state.\nFor example, the dictionary class in Django has a list of tuples that make up the \"values\" dictionary. In that case, the list of tuples is the \"values\" dictionary and adding or removing a value is as simple as adding/removing a tuple from the list.", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    rolling_max = lambda n:\n        if n < 1:\n            return n\n        else:\n            return rolling_max(n+1)\n\nThere are so many other types that would have been a better choice than Tuple. The first one that springs to mind is a List[int, int, int, int] which would support both the ability to use 0-based indexing as well as 1-based indexing.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    n = 0\n    while True:\n       # current maximum is n.\n          n = numbers[0]\n        # we are not here\n          if n > n:\n              numbers[0] = n\n              n = n + 1\n             else:\n              numbers[0] = n\n               return numbers\nThis seems a little weird to me. You're going to pass in a list of integers, but you're going to generate a list of integers. I would think that the generated list would be the list of integers that have been output by the previous calls to the function.\n\nThis is a good point. I see this as an implementation detail that can be reworked in a real world application. It's interesting to see that you can do this with a", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        for j in numbers:\n           if rolling_max(j) > rolling_max(i):\n                 rolling_max(i) = j\n    return rolling_max(numbers)", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers.index(0).max() + rolling_max([numbers[numbers.index(n+1):] for n in range(numbers.length-1))\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    rolling_max = rolling_max_with_convergence(numbers)\n\nfrom typing import List, Tuple\n\n    def rolling_max_with_convergence(numbers: List[int],\n        max_found: int,\n        found_count: int,\n        step: int) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_with_convergence([1, 2, 3, 2, 3, 4, 2], 3,", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n         if i < rolling_max:\n             numbers.append(i)\n    return numbers\n\nThe story behind this: I had a small Python program I wanted to use to generate a sequence of rolling maximum elements for a given sequence of numbers. I couldn't find a function like this, so I wrote one.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    numbers.pop()\n    numbers.reverse()\n    numbers.sort()\n    numbers.pop()\n    numbers.reverse()\n    numbers.sort()\n    numbers.pop()\n    numbers.reverse()\n    while n < numbers.length:\n        if n > 0:\n           n = n + 1\n            max = numbers[0].max()\n            rolling_max = rolling_max(numbers.pop(1))\n            rolling_max.add(max)\n            max = numbers.pop(0).max()\n            rolling_max = rolling_max(numbers.pop(1))\n            rolling_max.add(max)", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    max = 0\n    for i in numbers:\n       if i % 2 == 0:\n          max += i\n          max = rolling_max(max)\n    return max\n\nThat's a cool trick. Also, I wonder how many people are doing this:\nfrom typing import List, Tuple, Function\nfrom random import randint", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(numbers.length):\n        max = numbers[i]\n        rolling_max(max)\n\nWhat's the use case for this? Just curious.\n\nPossibly an attempt to sort a list of values into \"sorted\" and \"not sorted\" sections. E.g.\nrolling_max([1, 2, 3, 4]) [3, 4]\nrolling_max([1, 2, 3, 4]) [1, 2, 4]\n[1, 3, 4]</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if len(numbers) == 1:\n       return [0]\n    for i in numbers:\n       if i >= n:\n          if i - n == 1:\n               return numbers[i - 1]\n          else:\n               return numbers[i]\n    return numbers\n\nThe documentation is a bit sparse.\n\nInteresting, but a good bit more verbose than:\nnumbers = sorted(range(1, n))\nmax = max(numbers)\nreturn numbers[max]\n\nShouldn't it return the nth element as the rolling maximum?\n\nIn fact, in case n is very large, this function should return the very last element.\n\nIt's possible to have a negative number of elements in a list, so that wouldn't work, and it would be a bad idea to rely on the length of a list being positive.\n\nIt's possible to have a", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if len(numbers) == 0:\n        return numbers\n        for i in range(0, len(numbers)):\n            numbers.remove(i)\n            max = 0\n            while numbers.has_key(i):\n               if numbers[i][0] < max:\n                    max = numbers[i][0]\n                    numbers.remove(i)\n                 return max\n\nWow, that's a nice way to learn python.\n\nNot really. It's a very small portion of python, and it's not even pythonic. I would argue that it is only a nice way to learn the list and dict datatypes.\n\nThis reminds me", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    def _rolling_max_next(numbers: List[int]) -> List[int]:\n    \"\"\" Find the next element of the sequence, given that the sequence has already been rolling-maxed,\n    and if the element is the smallest one, return it. If not, return None.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 4, 4]\n    >>> rolling_max_next(rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 4, 4]\n    >>> rolling_max_next(rolling_max([1, 2, 3, 2, 3, 4, 2]))\n    None\n    \"\"\"\n    return (numbers.head()\n    |> List.map(rolling_max_next)\n    |> List.reduce(rolling_max)\n    )\n\nWhat's the point of this? Why not just:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        max = max(numbers[i])\n        if max > numbers[i+1]:\n            rolling_max = numbers[i+1]\n            numbers.pop(0)\n    return rolling_max\n\nThat example doesn't make any sense, because it doesn't handle the case where the maximum is equal to the current element.\n\nIt doesn't handle the case where the maximum is equal to the current element, but that's the way I like my maximums.\n\nI'm not sure I get the joke (or if it's a joke at all), but you can still have a maximum equal to the current element. For example:\nrolling_max([1, 2, 3, 4, 5, 6]) = [1, 2, 3, 5, 6]\nrolling_max([1, 2, 3, 5, 6, 7, 8]) = [1, 2, 3, 5, 6, 7]\n\nThat's not the way I like my maximum", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    rolling_max = [:]\n\n    while True:\n        rolling_max.append(numbers.pop(0))\n        print rolling_max\nI haven't looked at the implementation but something seems to be wrong here.\n\nIt looks like a bug, yeah. The correct output should be\n[1, 2, 3, 3, 3, 4]\n[4, 4, 4, 4, 4]\n\nI believe that the author is aware of the bug and was going for a joke.\n\nThis is an obvious, but brilliant idea. I'll have to use it.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers:\n        return numbers\n    return numpy.linalg.norm(numbers)\n\nYour example doesn't show anything since it just returns the list.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    a = [1, 2, 3, 2, 3, 4]\n    for i in numbers:\n        i_rolling = rolling_max(i)\n        a.append(i_rolling)\n    return a\n\nInteresting. That's a great way to generate a compact data structure, and this one is nice and easy to understand.\nThe one thing I'd change is that I'd likely use an append-only list instead of a mutable one. This is a much simpler implementation:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    n = len(numbers)\n\n    for i in numbers:\n\n         if i >= n:\n             return numbers\n    else:\n         n = i + 1\n         rolling_max(numbers[i]) = n\n\np = rolling_max([1, 2, 3, 2, 3, 4, 2])</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    i = 0\n\n    while i < len(numbers):\n       if numbers[i] > numbers[i - 1]:\n           numbers[i] = numbers[i - 1]\n        i += 1\n\n    return numbers\n\nI'm not a Python expert, but why didn't you use list comprehensions?\n\nHere's a comprehensive explanation:\n\nIt seems to me that list comprehensions are a great example of why Python is a horrible language, and how a language can be beautiful and unreadable at the same time.\n\nI agree, although the comprehensions are a lot less nice in other languages. I think the Python implementation is the best of all worlds.\n\nThis is sort of a special case of the general 'rolling' problem: how do you find the kth largest element in a list. It has been the subject of a couple of papers:\nI've implemented one of the solutions to the problem in this\nlittle (less than 200 lines of code) C# library:\n(which uses the other solution to the\nproblem).\n\nThe first part", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    while nnumbers.count() > 1:\n         if nnumbers[0] < nnumbers[1]:\n              numbers.pop(0).append(max(nnumbers))\n         else:\n              numbers.pop(0).append(max(nnumbers[1]))\n    return numbers\n\nThat's actually quite clever.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    try:\n        numbers.reverse()\n    except:\n        raise RuntimeError(\"Unable to reverse the list\")\n        numbers = numbers.reverse()\n    return numbers.append(rolling_max(numbers.pop()))", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    max = []\n    numbers.sort()\n    for i in numbers:\n        max.append(i)\n    return max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    while numbers:\n        rolling_max = 0\n        for number in numbers:\n           rolling_max = rolling_max + number\n           if number is max(rolling_max):\n              break\n    return rolling_max\n\nThe code isn't very interesting, but I felt it was one of those \"Aha!\" moments when you see something you never knew existed or never thought of before.\n\nWhy wouldn't you just do\nrolling_max = numbers.max() + numbers.pop()\n\nEquality, you don't have to sort the list to get the max\n\nYou can use the same technique with tuples:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    n = len(numbers)\n    while True:\n       i, max_i = numbers[n]\n       max = max_i\n       if max!= numbers[n+1]:\n          max = max + rolling_max(numbers[n+1])\n\nUse Tuple[int] instead of Tuple[int, int].</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    current_max = 0\n    while current_max < len(numbers):\n       curr = numbers[current_max]\n       if curr < current_max:\n          current_max = curr\n          curr = numbers[current_max]\n    return [current_max, curr]\n\nI find the other solution nicer:\nfrom typing import List", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.map(lambda i: i + 1)\n    while n:\n       numbers.pop(0)\n       if n < rolling_max(numbers[-1]):\n          numbers.append(n)\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    while True:\n        if (numbers.head() < n):\n            numbers.append(numbers[n])\n        else:\n             rolling_max(numbers.pop(0))\n\nI've never been a fan of \"from x import y\". The only time I've ever used this in a large program was when I needed to import some functionality of one module, but not the rest, and I couldn't refactor my code so that it would fit.\n\nI don't like it much either, but I've found that it makes code easier to read if I'm working in a large program with a lot of imports. Having all the imports at the top of the file keeps all the imports in one place, and makes it easier to spot places where you don't have all the imports.\n\nI do the same, but I do a single import per line:\nfrom x import y, z, w, x, y, z, w, x, y, z, w", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    # number of elements in the list\n    max = 0\n    for n in numbers:\n       max += n\n    return max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    max = numbers.find(element=lambda x: x > max)\n    for i in range(numbers.len()):\n       max += numbers.pop(i)\n    return max\n\nThis is a bad example - it's a bad programming practice to use an iterator as a variable and then assign it. The list is iterated, so what's the point of having a variable (especially a global one) that references it? And if you have to have that variable, why not use a tuple?\n\nMostly because that's how I started using Python. I have a whole family of functions that use it like that, all starting with \"from\".\n\nI don't see how this is bad. Iterators are a great way to create something like a \"map\" function.\n\nI don't see how this is good either. It's not idiomatic, and there are better alternatives.\n\nI am glad there is this discussion on HN. I was about to come in and say, \"this is a bad example\". It is a great example of how you can write code in python but it is not pythonic.\nI am", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n       rolling_max = rolling_max(i)\n       numbers.add(rolling_max)", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if len(numbers) == 1:\n        return numbers\n    result = []\n    while len(numbers):\n        if numbers[i] < numbers[i + 1]:\n             result.append(numbers[i])\n         else:\n             result.append(numbers[i + 1])\n    return result\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        numbers[i] += 1\n    return numbers\n\nI think the point is that you could easily do this without typing import:\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        numbers.remove(i)\n        numbers = numbers.drop(i)\n        numbers = numbers.drop(rolling_max(numbers))\n    return numbers\n\nIt's worth noting that this is not a generic solution: it only works for lists of integers, since it's based on the notion of a binary tree (and there is no notion of equality between integers).\nFor a more generic solution, you need to use a list of tuples.\n\nThe interface to the python interpreter is so simple it's a bit of a pain to take advantage of it. The only way to do so is to add a decorator.\n\nI'm not sure what you mean by that. The python interpreter does not have an interface to the interpreter, it has an interface to the language. You can only use decorators on classes and methods.\n\nThere is a way to access the interpreter itself, which is only really used in the CPython interpreter, which is the one that can be used from external applications (e.g., CPython is the one that is used by Django", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n       if i == 0:\n          numbers.append(0)\n       else:\n          numbers.append(rolling_max(numbers[i - 1]))\n    return numbers\nThis is a rather contrived example. I would think that the easiest solution is to simply \"print\" the list in some manner that will allow you to extract the maximum value.\n\nI think it's not contrived, but it's a bad example.\nHow would you change it to make it more realistic?</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    a, b, c, d = numbers\n    if a > b:\n       return [a]\n    if b > c:\n       return [b]\n    if c > d:\n       return [c]\n    if a = b:\n       return [a]\n    return [a, b, c, d]\n\nIf you're going to use tuples, you should probably use the typeclass:\nimport tuples", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n       if i % 2 == 0:\n           numbers[i] = i\n       rolling_max(numbers)", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    rolling_max = lambda n: (n == 0) & (n <= n)\n\n    rolling_max(numbers)\n\nIn Python, that's\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    n = len(numbers)\n\n    if n <= 1:\n       return []\n    else:\n       # '''Rolling maximum of sequence length 1 '''\n       # Numerical distance between each pair of successive", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return list(numbers.values())\n\nThis is kind of interesting. The author is very much committed to the idea of explicit imports, which is very sensible, but instead of using the proper syntax from the standard library (from... import *), he decided to write his own that is more readable (in his opinion).\n\nThe syntax 'from... import *' is not correct as it means 'from the module \"...\" import all the symbols from that module'.\n\nNo, that's not what it means. It's in the documentation:\nfrom module import *\nWhen importing a module, the list of imported symbols is split in two parts. In the first part, the names of the module's local variables are imported. In the second part, the names of the module's global variables and functions are imported. If a symbol is both local and global, it is imported only once.\n\nBut it is _in_ the documentation (emphasis mine):\n\nYou are wrong. It does _not_ say that. It says \"Symbols that are _local_ to the module being imported are accessible _from_ the module being imported.\" It does not say \"Symbols that are local to the module", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort(key=lambda x: x[0])\n    for i in range(len(numbers)):\n        numbers.insert(numbers[i], rolling_max(numbers[i-1]))\n    return numbers\n\nIf you're using Python 2.6, you can replace Tuple with 2.6's named tuples, which are basically syntactic sugar for the same thing:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    s = List(numbers)\n    for i in xrange(len(s)):\n         if i >= s[-1] and i < s[0]:\n              s[i] = s[i - 1]\n    return s\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 4, 4]\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2, 3])\n[2, 3, 4, 4, 4, 4, 4]</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    rolling_max = lambda n: (n + 1) % n\n    while rolling_max(numbers):\n        numbers.append(rolling_max(numbers[-1]))\nI don't think this is correct. [1,2,3,3,4,4] is not a list of rolling max, since it's missing the first and last element. [1,2,3,3,4,4,5] would be.\n\nThis would be an example of why you need to be careful when using things like 'for' loops. The article is talking about generating a list of rolling max element (not necessarily the same as the first element or last element) but the example of [1,2,3,3,4,4] does not do that.\n\nI agree that the example doesn't do what the article is talking about, but there's nothing wrong with the for loop. The problem is in the code that calls the for loop. If you have a list of numbers, and you want to generate a list of rolling maxes, you need to iterate over the numbers in some way, and you need to", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.reverse()\n    numbers.sort()\n    for i in range(numbers.length):\n        numbers.append(rolling_max(numbers[i - 1]))\n    return numbers\n\nI was surprised by that one too. It seems to me that if you are going to require that, you might as well use a dict.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers.filter(x -> x <= n * rolling_max(n - 1) for n in numbers)\nThis is a nice exercise, but it's really just a trick. It doesn't show any real understanding of either Python or functional programming.\n\nTo be fair, it is a fairly interesting use of multiple return values, so it does demonstrate that.\n\nI think it's a good example of using generators too.\n\nI think you've pretty much nailed it.\n\nPython's a great language, but I'll have to agree that this is a terrible example of what Python can do. I like the idea of learning by doing, but I think it's important to look at the examples that the language authors have already provided in the documentation. The examples that come with Python are a bit old, but they still contain much more powerful techniques than this \"from typing import List, Tuple\" example.\n\nWhen I was learning I was always taught to write the simplest possible example to demonstrate a point. I don't think that's what this article is advocating. I don't see how this is any different than the articles that are posted here daily that demonstrate a feature in Rails or whatever other framework.", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(1, numbers.count()):\n        for j in range(1, numbers.count() + 1):\n             if numbers[j][i] == 0:\n                  numbers[j][i] = numbers[j][i + 1] + 1\n                   rolling_max = numbers[j][i]\n\nimport operator, types, unittest from timeit import Timer", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return sum(range(0, len(numbers)), range(numbers[0] - 1, numbers[numbers.length - 1]) + 1)\n    - sum(range(0, len(numbers)), range(numbers[0] - 1, numbers[numbers.length - 1]) + 1)\n\nI prefer (0, sum(range(0, len(numbers)), range(numbers[0] - 1, numbers[numbers.length - 1]) + 1) + 1)\nThat is, given your input,\n(1, 2, 3, 4, 2, 3, 3)\nThe result is (1, 2, 3, 3, 3, 4, 4)\nThe rolling_max(numbers) function does what I think you want, it finds the largest element (3) in the first iteration, then the second largest (2) in the second iteration, etc, until it reaches the end of the list.\n\nWell, the rolling_max(numbers) function doesn't find the largest element (it will find the first larger than the previous one, then the next, etc).\n\nI took", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    #rolling_max doesn't take a parameter\n    rolling_max([1, 2, 3, 2, 3, 4, 2])\n    return [1, 2, 3, 3, 3, 4]\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers.tuple()", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return sorted(numbers, key=lambda a: a[0], reverse=True)\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers:\n        numbers.sort()\n        return numbers[0]\n\nYou need to do something about those multiple equal items, though.\n\nindeed.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    # This is a complex method\n    def rolling_max_step(numbers: List[int]) -> List[int]:\n    \"\"\" Recursively step over all the numbers in the list and return a new list\n    of the maximum element found for each step.\n    >>> rolling_max_step([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 4]\n    \"\"\"\n    return numbers\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i > n:\n           numbers.remove(i)\n        if n == 0:\n            numbers.remove(0)\n        if i == 0:\n            numbers.add(i)\n    return numbers</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    def rolling_max_for(numbers: List[int]):\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_for([1, 2, 3, 2, 3, 4, 2])\n    [1, 3, 4, 4, 4, 4]\n    \"\"\"\n    while numbers:\n        numbers = numbers.pop(0)\n        rolling_max_for(numbers)\nThis is a classic example of a problem which requires an iterator instead of a generator.\nFor example, if your function needs to return the value of a variable, you'd want to use something like `yield variable;`.\nOn a related note, I don't see any indication that your variable numbers is ever used.\n\nIn what cases would an iterator be preferable? (I've seen that some other people are suggesting this as well.)\nThe reason I avoided that is because the function is meant to take a list of numbers as input and return the maximum value found at", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    max = Tuple(1)\n    for index in numbers:\n       max = rolling_max(index - 1) + 1\n       max.add(0)\n    return max\n\nWhat's the purpose of the 1 in the Tuple here?\n\nIt's a Tuple of the same length as the list (1 element) with the default value of 1.\n\nThe default value is the empty tuple.\n\nThe empty tuple is only a tuple of length 0.\n\nNo. It's the same tuple type.\n>>> (1, 2, 3)\n>>> (1, 2, 3)\n>>> (1, 2, 3)\n>>> (1, 2, 3)\n>>> (1, 2, 3)\n>>> (1, 2, 3)\n>>> (1, 2, 3)\n>>> (1, 2, 3)\n>>> (1, 2, 3)\n>>> (1, 2, 3)\n>>> (1, 2, 3)\n>>> (1, 2, 3)\n>>> (1, 2, 3)\n>>> (1, 2,", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\nHow can I even begin to describe how much I hate this?\n\nI don't hate it, but I do find it amusing.\n\nI hate it.\nIt's easy enough to write one's own version of rolling_max() which uses built-in function.\n>>> def rolling_max(numbers: List[int]):\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\nmax = max(numbers)\nreturn [x for x in numbers if x > max]\n>>> rolling_max(1, 2, 3, 2, 3, 4, 2)\n[1, 2, 3, 3, 3, 4, 4]\n\nAnd it will be inlined, which is also an advantage.\n\nI'm not sure it's an advantage in this case. The version of rolling_max() in the article is just one line. The version you", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    if len(numbers) < 2:\n       return [0]\n    if numbers[0] < numbers[1]:\n       return rolling_max([1])\n    else:\n       for i in range(0, len(numbers)):\n          if numbers[i] > numbers[i + 1]:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers.count() == 0:\n       return Tuple()\n    else:\n       rolling_max = []\n    for number in numbers:\n       rolling_max.append(number)\n    return rolling_max\n\nThe way I see this, it's just a simple algorithm that's easy to implement and maintain. The only new thing is the tuple class, which provides a shorthand for (I'm assuming) a list of lists. I don't see a big win here.\n\nI wonder how the performance of this compares to a simple implementation of heapsort...</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return (numbers.pop(0).roll_max(numbers.length - 1)).reverse()\n\nWhy not just use a set?\n\nIn Python 3, sets are dictionaries and dictionaries are implemented as sets, so\nI think the difference is just terminology.\n\nI think the point is that sets are already implemented in Python, and sets are easier to understand.\n\nI've never understood the point of implementing a set in terms of a dictionary.\nIf I want a set, I just want a set. If I want a dictionary I just want a dictionary.\nIf I wanted a set-like data structure that included an order element, then I'd want a set, not a dictionary, because I wouldn't want the extra overhead of having to maintain the dictionary itself.\n\nIt's used a lot in SQL, where you can have sets of rows that belong together.\n\nIf I recall correctly, one of the two main points of using a dictionary as a set is the fact that you can still get O(1) lookups. If that's the case, and you're comparing against the entire set, then why not just use a set in the first place?\n\nAny", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    result = []\n    while True:\n       # 1st iteration\n       numbers.append(rolling_max(numbers.pop()))\n       n = numbers.pop()\n       result.append(rolling_max(n))\n    return result\n\nIf you want to try it out in your shell:\n$ python -m rolling_max.py\n$ python -m rolling_max.py --help\nUsage: rolling_max.py [-h] [-n <integer>] [-n start] [-k]\n RollingMax function.\n-h, --help show this help message and exit\n-n <integer> Number of elements to start from\n-n start Number of elements to start from\n-k, --keep keep k most recent instead of just one\n\nIt's pretty slow on my machine (Ubuntu 10.04, 2.6.32-21-generic) - running it as a script from my shell gives me about a 10-second delay between each element:\n$ time python -m rolling_max.py --help\nUsage:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for n in numbers:\n        max = numbers[n]\n        for i in range(len(numbers)):\n            if max!= numbers[i]:\n                max = max + i\n    return max\nThis is not \"from typing import list and tuple\"\n\nfixed, I think</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i == max:\n           return [i]\n         if i % n == 0:\n            return [i]\n          i = max + 1\n    return [i]\n\nI guess I'm supposed to be impressed by this? I'm not.\n\nI'm trying to figure out how this is particularly different from rolling_min and rolling_max.\nThe only difference I see is that it's missing a tuple() or list() call (depending on whether the return type is int or list) at the end of the function to convert the list of integers into a list of integers.\n\nLet's see how your code deals with a list of strings.\n\nI'm confused, why does the question of how it works with strings matter?\n\nBecause there's no such thing as rolling_max for strings.\n\nThis is precisely why programming languages need a type-checker that can be made to work by the programmer.\n\nFor me,", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    start = 0\n    rolling = []\n    for i in range(numbers.size):\n       rolling.append(i)\n    while rolling:\n       rolling_max(rolling)\n    start += 1\n    return rolling", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    # Generate a random number between 0 and the size of the list.\n    random_number = random.randint(0, len(numbers))\n\n    # If the random number is greater than the one we found,\n    # then we found the maximum\n    if random_number > max(numbers):\n        return numbers\n    # If the random number is lower than the one we found,\n    # then we found a lower maximum\n    if random_number < min(numbers):\n        return [random_number, numbers[random_number]]\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(numbers.size):\n        i = numbers[i]\n        rolling_max = 1\n        if rolling_max == numbers.size:\n            rolling_max = 1\n            if i % 2 == 0:\n                rolling_max = i\n               if i % 2 == 1:\n                  rolling_max = i\n    return rolling_max\n\ni think the \"i\" is not necessary in range(numbers.size), cuz i think if i want to know the size of the list i can just call the length of the list (list(numbers)).\n\ngood point,\nI have updated the article to reflect your suggestion.\n\n\"Don't use general purpose operators like > and < unless you need the overhead and memory usage.\"\nThis", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    i = 0\n    while i < len(numbers) - 1:\n       # iterate over the list of numbers\n       i += 1\n       if i == len(numbers):\n          break\n       numbers[i] = max(numbers[i], numbers[i - 1])\n    i = i + 1\n    return numbers\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 3, 4, 4]\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2], 2)\n[1, 2, 3, 4, 4]\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2], 3)\n[1, 2, 3, 4, 4, 4]\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2], 4)\n[1, 2, 3, 4, 4, 4, 4", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if len(numbers) == 1:\n        return numbers[0]\n    else:\n        result = []\n        for i in numbers:\n           if i % 2 == 0:\n               result.append(i)\n              result = rolling_max(numbers)\n    return result\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 3, 4, 4]</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for number in numbers:\n       max = number.max()\n       rolling_max(max)\n\nThat seems to have a pretty high memory usage, and also be subject to the same slowdown that quicksort has when dealing with large lists.\n\nRolling for an infinite sequence of numbers might not be so bad, though, because you have the option of storing the results of the rolling in the list itself rather than constructing a new list.\n\nThat's a good point. This is a very simple example though. I don't think that the naive approach is the best way to do this though. I'd be surprised if this approach scaled well to large lists.\n\nWhy not?\n\nFrom the outside it's hard to tell what the structure of this list is without actually looking at it. It's difficult to tell whether there is any garbage in the list. Also, if you need to do anything with the list (for example, if you want to iterate it) you have to be able to reconstruct it.\n\nIn the actual implementation, it's a very simple list, just a list of ints.", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    numbers.reverse()\n    numbers.take(numbers.size() - 1)\n    numbers.reverse()\n    def found = 0\n    while numbers:\n        for i in numbers:\n           if i == found:\n              break\n              if i > max(numbers):\n                 found = i\n                 rolling_max(numbers[i:])\n                 else:\n                 found = i\n                 found = i + 1\n                 return found\n\nI'm curious about the reason", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    while True:\n        numbers.append((int(i) for i in numbers if i > n))\n        rolling_max(numbers)\n\nIs there any chance of giving a function name to the input of your function?\nAs it is it looks like you're using a \"List\" as your function argument and then you're giving a function to the \"List\".\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    for i in range(1, n):\n        numbers.append(i)\n        rolling_max(numbers)\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers[0]\n\nWTF?\n\nProbably imported because of:\n\nThanks, didn't realize this:</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    n = numbers.pop()\n    for i in range(n):\n        max = numbers.pop()\n        if max is not n:\n            max = rolling_max(n - max)\n            numbers.append(max)\n    return max\n\nHere is my question. Is there a reason to use this over the more straightforward:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n       if i > rolling_max(numbers):\n          numbers.append(i)\n    return numbers\n\nAnd my own, somewhat less practical, version:\nimport typing", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(numbers.size):\n        roll = numbers.get(i)\n        if roll > max:\n           numbers.set(i, roll)\n    return numbers\nThis is an extremely bad example, as it doesn't really do what it claims.\nThe correct way of doing this would be with a sorted list. You start at 0, and every time you get a number that is higher than the previous max (starting at 0), you change the value.\nNote that this is not in Python.\n\nTrue. But this example was done just to show the type of functions you can create with type declarations.\n\nIt's a bad example because it's a confusing example. It's hard to tell what it's doing until you've done it a few times, and it's easy to get the wrong answer. A good example would be the correct implementation of a rolling maximum, and something like a normal max, and then compare the two.\n\nIt's a bad example because it doesn't work.\n\nIsn't it better to do:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers.sort().filter(i > numbers[0].max()).max()", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers:\n       numbers = [x for x in numbers if x > x]\n       rolling_max = [numbers[x] for x in rolling_max.items()]\n    return rolling_max\n\nfrom typing import List, Tuple, Function\n\n    def rolling_min(numbers: List[int]) -> Tuple[int]:\n    \"\"\" From a given list of integers, generate a list of rolling minimum element found until given moment\n    in the sequence.\n    >>> rolling_min([1, 2, 3, 2, 3, 4, 2])\n    [(1, 4), (2, 3), (3, 2), (4, 1)]\n    \"\"\"\n    if numbers:\n       numbers = [x for x in numbers if x < x]\n       rolling_min = [numbers[x] for x in rolling_min.items()]\n    return rolling_min\n\nfrom typing import List, Tuple, Function, TypeError, Ind", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    rolling_max = 0\n\n    for i in numbers:\n        rolling_max = rolling_max + max(numbers[i], numbers)", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for n in numbers:\n        if n > rolling_max:\n           rolling_max = n\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if len(numbers) > 0:\n        return numbers\n    while numbers:\n        if numbers[0] == 0:\n            return numbers[0]\n            if numbers[0]!= numbers[-1]:\n              return rolling_max(numbers[0], numbers[-1])\n    return rolling_max(numbers[1:])\nI like this.\n\nThat's nice. It's a little hard to explain to someone who doesn't already know the problem, but that's to be expected from a good implementation.\n\nI'm not sure what the point of this is.\n\nIt's just a neat way to do something useful, and it's short and readable.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    numbers = sorted(numbers)\n    while numbers:\n        for num in numbers:\n            if num > rolling_max(numbers[0]:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if n in numbers:\n       return numbers\n    i = 0\n    while i < len(numbers):\n       if i == n:\n          return i\n       i += 1\n    numbers = [i]\n\nI don't like how in python \"list\" can be a type and \"tuple\" can be a type and \"set\" can be a type and \"array\" can be a type. I think python's type system is too flexible.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for number in numbers:\n       if number < n:\n          if number > m:\n               m = number\n               n = number + 1\n               number = number\n    return list(m) + list(n)", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    n = 0\n    for x in numbers:\n       if x < n:\n           n = x\n    return [n]\n\nThis is a really, really bad code snippet.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0, len(numbers) - 1):\n        numbers[i] = numbers[i] + 1\n\n    return numbers\n\n__repr__ = \"rolling_max({0}) -> list({1})\n    {2} -> {3}\n    {4} -> {4}\n    {5} -> {5}\n    {6} -> {6}\"\n\nThis is _not_ Python.\n\nThis is the old style of Python, before \"from __future__ import print_function\"\n(a.k.a. Python 2.5).\nIt is supported in Python 2.3 and 2.4.\n\nThis is why I always use \"from __future__ import print_function\" when I'm writing code that will be used in both Python 2.3 and 2.4.\n\nWhy do people keep saying this? It's not even an import, it's a module attribute!\n\nI think it's probably because it's the equivalent of\nimport __future__\nin Python 3.\n\nGood point. I've used that", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    \"\"\"\n    rolling_max = lambda x: x if x.value < x.value[-1] else []\n    \"\"\"\n    \"\"\"\n    for i, x in enumerate(numbers):\n        rolling_max([i, x])\n\nThe example is a bit contrived, but it makes sense.\n\nI don't quite get it. What does this do?\n\nIt generates a list of every number in the range [1, n], where n is the length of the list of numbers, and\ntakes the rolling maximum of each number (using the function rolling_max()).\n\nI'm confused about what the function rolling_max() does.\n\nI think it's not the best example, here's an example that makes more sense.", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n       # n1 is the current maximum element\n       n1 = 0\n       while n1 < len(numbers):\n          n1 += 1\n          if n1 > max(numbers):\n              n1 = n1 - 1\n              max(numbers) = n1\n              n1 = n1 + 1\n    return numbers.tuple(0)\nI believe there is a typo in the while loop.  I think the last assignment should be n1 = n1 - 1.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    t = 0\n    while len(numbers) > 0:\n        if numbers[t] > numbers[t - 1]:\n            t = t - 1\n            rolling_max(numbers[t:])\n\nI am not a python programmer, but I'm going to try and follow along here.\nCould you explain to me why:\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 3, 4, 4]\nis different from\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 4, 4, 4]\n\nI am sure there are many ways of doing this. I just did it this way since I wanted to be able to pass it a list as argument and get a list back.\n\nI see. Thanks for the response.\n\nI think the difference is that your version is really only useful if you know the sequence you want to produce, while the original", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for n in numbers:\n        if n < numbers[-1]:\n            numbers[n] = numbers[n+1]\n    return numbers\nHere's a minor nitpick:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i < n:\n           return i\n        if i == n:\n           return numbers[i + 1]\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    return numbers.sort()", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if n > 0:\n        return n\n    return numbers[::-1]\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    n = len(numbers)\n\n    max = numbers[0]\n\n    while n < len(numbers):\n        if numbers[n] < max:\n            numbers[n] = max\n         n += 1\n\n    return numbers\n\nI'm not sure if it's a bug or not, but it should be \"numbers[n] = max\" instead of \"numbers[n] = max\".\n\nFixed. Thanks!</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    n = 0\n    while True:\n       sum = 0\n       for i in numbers:\n           if i < n:\n              sum += i\n         n += 1\n         return sum", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.reverse()\n    for i in range(numbers.len()):\n        i = rolling_max(numbers[i])\n        numbers.append(i)\n    return numbers\nWhat is this doing?\n\nThank you for your reply. I think I have to clarify the problem statement.\nIn the python interpreter, you can use 'import' statement to import module. You can see the list of import module in the command prompt.\nIf you type 'import Tuple', then you can see the tuple() function as a result of import Tuple.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    if len(numbers) == 0:\n        return numbers\n\n    for i in numbers:\n         if i < n:\n            return i\n        else:\n             return rolling_max(numbers[i:i+n])\n\nThat's... kind of ridiculous. I mean, look at it. It's not even doing what I want it to do. It's producing a list of all the elements of the original list, but just as a list of tuples, not as a list of their values. It's not doing a single thing the way I want it to do it. It's doing something that sounds useful, but it's not doing that at all.\nFrom what I can tell, rolling_max is useful if you're dealing with an array or a list of tuples of integers, and you want to get a list of all the maximum elements of those tuples.\nIt's not useful at all in the case where you want to get a list of tuples, each", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers[0] + 1", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    rolling_max = []\n\n    rolling_max.append((numbers[i]))\n\n    for i in range(0, len(numbers)):\n\n       rolling_max.append(numbers[i])\n       if numbers[i] > numbers[i - 1]:\n\n          rolling_max.append(numbers[i - 1])\n\n    return rolling_max\n\nAlso, if you know Python, you should consider using Python's own built-in rolling_max() function:\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 4, 4]\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2], max=2)\n[1, 2, 3, 3, 4]\n\nThe Python built-in is a bit more complicated than rolling_max() in the blog post, because it uses range().\nHowever, the Python built-in is much more consistent (it will always do the same thing), and not dependent", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return list(zip(numbers.map(lambda x: x * x, numbers.reverse())))", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    i = 0\n\n    i += 1\n\n    while i < len(numbers):\n        i += 1\n        rolling_max(numbers[i - 1])\n\n    return numbers[:i]", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    n = len(numbers)\n    while numbers[n]:\n        if numbers[n][0] < numbers[n][1]:\n              numbers[n][0] = numbers[n][1]\n               numbers[n + 1] = numbers[n]\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    while True:\n        numbers.pop()\n        numbers.append(rolling_max(numbers.pop()))\n\nDefining named functions is the one thing that always makes me go \"oh, cool\" when I get to the point of using Python.\n\nA nice trick, but I've never needed a function like this for anything I've been working on, and I can't imagine a scenario where I would.\nI do like the syntax for defining a function in the current version of Python, though. Nice and clean.\n\nI would imagine it would be useful for applying dynamic programming to a sort algorithm.\n\nAn implementation of dynamic programming using a python list would be pretty bad. Using a vector and a recursive scheme would be much more efficient.\n\nI would think of this as a good way to demonstrate a dynamic programming approach to students, and how to use it on a sorted list.\n\nI would love to have the ability to use closures like that in Python.\n\nI know! Some day I'm gonna switch to Python full time and I'm gonna get all of my old code to", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers:\n       return numbers\n    return rolling_max(numbers: numbers.remove(0))\n\nRolling max is a very useful function (it is used in the Sieve of Eratosthenes for example). I would be very surprised if it were not already in the standard library.\n\nIt's not in the standard library because it is simple to implement, and can be easily factored out into a separate function.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\nCan you get that into your head? And can you explain what it does without looking at the code? What's the type of the result? Can you write the same code without the `def`?\n\nI know about explicit and implicit parameters. I was just asking what's the benefit of typing \"import\" instead of \"using\" in python.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    result = 0\n    while True:\n       result += numbers[-1]\n    if result < n:\n       result = rolling_max(numbers[-1:])\n    return result\n\nI would just use a generator.\n\nThe purpose of this is not to replace generators, it is to replace list comprehensions (or generators).\n\nNo, it's not. List comprehensions work on iterables. This doesn't.\n\nIt is an iterable, just not a list.\n\nHeh. It's not a sequence, so it's not an iterable. If you want to argue that all iterables are sequences, that's fine, but don't just assert things that are obviously false.\n\nWhy are you so aggressive? I simply said it is an iterable, not a list. Maybe he wants to have it work on sequences other than lists.\n\nNo, you didn't, you asserted that it's an iterable, which it isn't. And then you said that it's an iterable because all iterables are sequences, which is not true.\nI wasn't", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for number in numbers:\n         if number < n:\n             number = n\n         if n is max(numbers):\n             numbers.append(number)\n    return numbers</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    import itertools\n    rolling_max = itertools.product(rolling_max, [numbers])\n\nYes, that's the point. The author was trying to be funny.\nI guess humor doesn't translate well on the internet.\n\nI see nothing wrong with using `Tuple`; it makes the code a lot more readable than `List[Tuple[int]]`.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0, len(numbers) - 1):\n        if numbers[i] > numbers[i+1]:\n           numbers[i] = numbers[i+1]\n    return numbers\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers = (numbers.append(0))\n    while True:\n       if numbers.count() == n:\n          if numbers[0] > n:\n               numbers.append(numbers[0])\n                numbers.count() += 1\n        else:\n                numbers.append(numbers[-1])\n                 numbers.count() -= 1\n\nI didn't understand this example at all, but I did understand the one it was copied from.\n\nI didn't understand the example it was copied from either.\n\nI believe the point is that you're adding the first element to the list, then if the list is not yet full, you're finding the largest number and appending that to the list.\nThat's a different way of doing it, but it's not clear to me that it's", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    max = numbers.get(0).get()\n    rolling_max = Tuple[int]()\n    while max!= numbers.end() and rolling_max.get(max)!= 0:\n        rolling_max.set(max, max + 1)\n    return rolling_max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    min = numbers.get(0)\n    max = numbers.get(numbers.size())\n    for i in range(0, max - 1):\n        if i >= min:\n             numbers.remove(i)\n             numbers.append(rolling_max(numbers))\n\nYeah, but then you can't do:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if n is None:\n       return []\n    if len(numbers) > 1:\n       return [n for n in numbers if n < n + 1]\n    n = numbers[0]\n    for x in numbers[n]:\n       if n + 1 > x:\n          numbers[n+1] = x\n       else:\n          numbers[n] = x\n    return numbers\n\nYuck. For a good introduction to rolling window algorithms, I suggest this paper:\n\nI'd prefer\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(1, n + 1):\n        rolling_max(numbers[i])\nreturn numbers</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    values = list(numbers)\n    for i in xrange(0, len(values) - 1):\n        if i % 2 == 0:\n            values.append(i)\n            rolling_max([values[-1] for values[-1] in values])\n    return values\n\nAs a Python programmer, I find this unnecessarily verbose. The same code is\nmuch more readable:\n>>> max = rolling_max(range(1, 5))\n>>> max\n[1, 2, 3, 3, 4, 4]\n\nI don't find it verbose at all, but I would find it tedious to type that line of code.\nThe most annoying thing about it is that I have to get the range. I've noticed that some python programmers will get the range function from the math module and use it like that. I think that's the wrong thing to do, though, and I'd much rather do something like:\nfrom math import sqrt, sin, cos, log\n>>> max = rolling_max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    i = 0\n\n    if i < numbers.length:\n        i += 1\n\n    return List(i)\n\nThe code is incomplete. The author has not finished the algorithm. It does not ensure that the rolling maximum is unique.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    def rolling_max_numbers(numbers: List[int]) -> List[int]:\n    \"\"\" Given a list of integers, return a rolling maximum element\n    by applying rolling_max() to the list.\n    >>> rolling_max_numbers([1, 2, 3, 2, 3, 4, 2])\n    [1, 3, 4, 4, 4, 4]\n    \"\"\"\n\nThis seems like a mistake.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0,len(numbers)):\n        numbers[i] = numbers[i - 1] + 1\n\n    return numbers\n\nDoesn't the Python standard library have the same functionality?\nimport itertools", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    # Generate a list with the first element of the original list, the\n    # rolling maximum so far, and the current maximum found so far.\n    while numbers:\n       # Generate a list with the first element of the original list, the\n    # rolling maximum so far, and the current maximum found so far.\n       numbers = rolling_max(numbers[0], numbers[-1], current_max)\n       return numbers\n\nHere is the gist of the solution:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    while len(numbers) > 0:\n        numbers.remove(0)\n        numbers.append(rolling_max(numbers[0]) + numbers[1])\n    return numbers\n\nI don't know why people make such a big deal about lists and tuples and the like. Python has them, and people love it.\nRuby has them, and people love it.\nJavaScript has them, and people love it.\nBut when C++ has them, people hate it.\n\nI don't think its a question of hating lists and tuples, its a question of why would you need them.\n\nI've seen this a lot, and I think it's because people don't understand why lists and tuples are useful.\nThey're useful in C++, where you need to pass around large amounts of data. In C++, for example, you can take a list of people and their addresses and use them in a loop, or make a dictionary of car make and model information and use that.\n\nWhy can't you do this in C++ without lists and tuples?\n\nYou can, but", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i >= n:\n            yield i\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if n is None:\n        n = []\n        for i in range(0, n):\n            n.append(i)\n        return numbers\n\nThat's cool and all, but it looks like a bad example.\n\nYea, the right example should be:\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2, 3, 4, 2, 3, 4])\n[4, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10]\n\nAnd I would add that it is important to use a functional language for this, not just Python.\n\nI was thinking exactly the same thing. I just had to look for a way to make it work in Python first, in order to actually understand the concept.\n\nThis example may be taken as a proof that Python does not have the concepts of lists, tuples, or lists with the function property.\n\nI don't understand what you're saying.\n\nThe fundamental problem is that the OP has a function that", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if numbers[i] > numbers[rolling_max[i]]:\n           numbers[rolling_max[i]] = numbers[i]\n    return numbers\n\nThe reason I posted this was that I found the code very succinct and easy to read.\n\nThe code is indeed easy to read.\nIt's also easy to write.\n\nIt's actually harder to write than the equivalent in python:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers.count() == 2:\n        return [1]\n    while numbers:\n        if numbers[0] < numbers[1]:\n           return rolling_max(numbers[0], numbers[1])\n    return List()\n\nfrom typing import List, Tuple\n\n    def generate_random_permutations(numbers: List[int]) ->\n    List[int]:\n    \"\"\" Generate random permutations of numbers, for a given size.\n    >>> generate_random_permutations([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5, 2, 3, 4, 5, 3, 4, 5, 5, 1, 2, 3, 4, 5]\n    \"\"\"\n    if numbers.count() == 2:\n        return [1]\n    while numbers:\n        if numbers[0] < numbers[1]:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for n in numbers:\n        n = next(numbers)\n        n = max(n)\n        numbers.append(n)\n    return numbers\n\nInteresting. A pity it doesn't use Tuple though.\n\nPity it doesn't use a dict or list, and instead uses a tuple.\n\nIf you're wondering what's the purpose of the Tuple class, here's a hint: \n\nAlso, for anyone wondering why tuples are a useful language feature, this guy's post has a lot of good background info:\n\nWow, I've never seen this before. I'm not sure I'd ever have a use for this, but I like it.\n\nI think I'll be using this for a project I'm currently working on - I was writing a function to generate and then create a number of lists from a single list, but this is much cleaner.\n\nThis looks interesting. Now we can write a generator that returns a rolling tuple.\n\nI would have used a generator as well if I knew a way to make one with a :keyword parameter", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for number in numbers:\n       if number > current_max:\n          current_max = number\n          return numbers\nNote that Python's `List`s are not quite lists. They are more like linked dictionaries. In particular, if you were to modify the above code to use Python's `array` type instead of `List`, it would not work, because of the dict-like behavior.\nThe advantage of this is that if you use Python's built-in function `inspect`, you can see the current value of the `len` field in the `List` as the first item in the list.\nIn fact, if you're new to Python, you might want to just avoid using `Tuple` and `List` and learn the more explicit (but also more powerful) `dict` and `array` datatypes.\n\nI've tried this with tuples, and it doesn't work.\nIs this just a bug in Python 2.3?\n\nIf it's a bug, it's one in the standard library, not Python itself, because the standard library (the", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n       if i > rolling_max(i):\n          new_max = i\n       rolling_max = new_max\n    return rolling_max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0, len(numbers) - 1):\n        numbers.append(numbers[i - 1])\n    return numbers\n\nA more idiomatic Python way of doing this:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i > n:\n            numbers.remove(i)\n            numbers.append(rolling_max(numbers[-i:]) + 1)\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0, n):\n        max = i\n        rolling_max = rolling_max + 1\n        if max < n:\n           max = max + 1\n    return rolling_max\n\nList, Tuple, and Python. The three pillars of Pythonic programming.\n\nI'm not a Python programmer. Can you explain why Tuple is considered a pillar of Pythonic programming? I don't see anything bad or tricky about it, but nothing immediately Pythonic either.\n\nTuple is a great way to model a heterogeneous set of items. In C++, you'd have to roll your own struct, or use an existing one.\n\n\"In C++, you'd have to roll your own struct\"\nIn C++, you could also use std::vector, which I think is the preferred way.\n\nYes, and this is one of the biggest reasons why I'm not a C++ programmer.\n\nSo you'd rather roll your own struct?\n\nI don't understand why this is so heavily down-", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i < number_found:\n            continue\n            if i + 1 < number_found:\n                 continue\n                if i == number_found:\n                   break\n                  number = i\n    return numbers\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    a_max = [1]\n    a_max += numbers[0] + 1\n    while numbers:\n         current_max = a_max\n         if current_max == numbers[0]:\n             break\n           current_max = a_max + current_max\n          return [a_max]\n\nThat's a strange way to define a function. I haven't used Python, but the\nlist comprehension syntax makes it look like this should be more readable:\nrolling_max = lambda numbers:\n       return numbers[0] + 1\n\nIt is not a strange way to define a function, just an old-fashioned one.\nI prefer it to list comprehensions for some things, because you can easily\nsee what's happening and it's easy to keep track of what's happening.\n\nIt's not an old-fashioned way to define a function - it's an old-fashioned way to define a _method_,", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n         if i < n:\n              numbers[i] = n\n    return numbers\n\nI think you could have a lot of fun with list comprehensions.\n[1,2,3,2,3,4,2]\n-> [3,4,5,4,5,6,3]\n-> [5,6,7,6,7,8,5]\n-> [8,9,10,9,10,11,9]\n-> [11,12,13,12,13,14,11]\n-> [14,15,16,15,16,17,13]\n-> [17,18,19,18,19,20,16]\n-> [20,21,22,21,22,23,20]\n-> [23,24,25,24,25,26,21]\n-> [26,27,28,27,28,29,23]\n-> [29,30,31,30,31,32,28]\n-> [32,", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    for i in numbers:\n        return numbers[i]\n\nWe should put this in the Python library so that it can be imported as \"from rolling_max import rolling_max\".\n\nYes, but to be consistent, you should also be able to import it as \"from rolling_max import rolling_max\".\n\nActually, this is not valid because of the double colon.\n\nThis is too clever by half. I don't think it is worth the ambiguity in expression.\n\nI would have used a tuple instead.\nfrom typing import Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for n in numbers:\n       if n is not None:\n          if n > rolling_max(numbers[n - 1]:):\n                numbers[n] = numbers[n - 1]\n          else:\n               rolling_max(numbers[n - 1]) = numbers[n]\n    return numbers\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    n = 0\n    for i in range(n):\n         if numbers[i] < numbers[n]:\n             n = n + 1\n          else:\n             n = 0\n    return numbers\n\nWhat's the point of this? You could just use the built-in len() function:\n>>> rolling_max(range(10))\n[1, 3, 5, 7, 9, 11, 13, 15]\n\nIt's the same as the built-in function, except that it's a tuple instead of a list.\n\nThis is a nice example of a difference between Python 2 and 3. In 2.x, a for loop is required, and in 3.x, the for loop is optional. In 2.x, the first \"else:\" clause is a default case, so n = 0 is necessary. In 3.x, the \"else:\" clause is an exception handler, so n = 0 isn't necessary. The resulting code is much cleaner.\nAlso", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        max = numbers[i]\n        rolling_max = rolling_max(max)\n    return rolling_max\n\nimport random", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if len(numbers) == 1:\n        return numbers[0]\n    else:\n        return numbers[0] + rolling_max(numbers[1:] + 1)\n\nThis is the same thing as the built-in function sum.\n\nI didn't know about sum!\n\nmy first python program was an implementation of k-max</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    results = []\n    for i in numbers:\n        results.append((i, i + rolling_max(i - 1)))\n    return results\n\nThis is a bad example because it doesn't really demonstrate the problem.\nI recently tried to write a function to count how many 1's, 2's, etc. there were in a list. I did this by creating a list of these numbers and going through the list one by one and then calling a function to increment the counter.", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    rolling_max = lambda x:\n        x ** 2 + x\n    rolling_max(numbers)\n\n[1, 2, 3, 3, 3, 4, 4]\n\nI can see a use for this, but it can be done much more simply.\n>>> max(numbers)\n[1, 2, 3, 3, 4, 4]\n\nHow would this be more \"simply\" done?\n\nWell, you could make a function \"rolling_max\" which calls \"max\".\n\nHow would you make this \"much more simply\"?\n\n<stupid comment>\nlist.rolling_max = lambda x: x * 2 + x;\n<</stupid comment>\n\nYou forgot:\nlist.rolling_max(numbers)\n\nSo, instead of:\n>>> max(numbers)\n[1, 2, 3, 3, 4, 4]\nyou would type:\n>>> list.rolling_max(numbers)\n[1, 2, 3, 3, 4, 4]\nNot really simpler, but you save 2 keystrokes.\n\nI guess", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    results = []\n\n    i = 0\n\n    for i in numbers:\n        results.append((i, i+1))\n\n    return results</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    list = []\n    number = 0\n    while n in numbers:\n        if n < number:\n            number = n\n            list.append(number)\n    return list\n\nThis code is not correct. Rolling_max() should return the last element of the list.\n\nI'm not sure why this was modded down.  It's not the best example, but it certainly has the right idea. \n\nI think people are assuming that you need a for loop to do this. As you can see, the loop never ends.\n\nSo you need to pick your n in a smart way.\n\nYup.\n\nI don't understand the point of this. It is exactly the same as:\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    result = []\n    for number in numbers:\n       if number < rolling_max(number):\n          result.append(number)\n    rolling_max(number)\n    return result\n\n\"\"\"", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n\n    for x in numbers:\n       if x < rolling_max(x):\n          x += 1\n    return numbers\n\nOh god, what is this? It's a list comprehension but written in a really shitty way.\n\nI guess what's really important is that it works.\n\nNo, not really. The important thing is that it's easy to read and maintain. This is neither.\n\nI agree that the snippet isn't very clear, but a little bit of effort is all it takes to make it work for you.\nOnce you get used to it, it is quite easy to read and maintain.\n\nFrom the title, I expected the post to be about list comprehensions, not tuples.\n\nExactly! I was hoping for a list comprehension trick that was new to me. But nope, just an example of a common language feature.\n\nThis is like saying \"Here's a way to use the ternary operator\" or \"Here's how you use braces\". It's a non-story.\n\nIf you're used to python, maybe.\n\nIndeed. And that's my point", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers == [] then\n       return [1]\n    else:\n       if numbers[0] <= numbers[-1] then\n          return [numbers[1:], numbers[0], numbers[1:] + 1]\n    else:\n          if numbers[0] <= numbers[-1] then\n             return [numbers[1:], numbers[0], numbers[1:]]\n    else:\n             return [numbers[1:], numbers[0], numbers[1:]] + numbers[1:]\n\n[1] is not a valid rolling maximum, but the others are.\n\nIt's like rolling a die. You want the highest number that you can't get by rolling the die more than once. That's a rolling maximum.\nI suppose in this case, if it's a List of numbers, then a rolling maximum is a number that doesn't occur more than once in the list.", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    # if the first element of the list is 1, the first element of the result list will\n    # be 1\n    if len(numbers) == 1:\n        return numbers\n    # if the second element of the list is 1, the second element of the result list will\n    # be 2\n    #...\n    #...\n    return Tuple.fromlist(numbers, [len(numbers), n/2, n/4, n/8, n/16, n/32, n/64, n/128])", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i % 2 == 0:\n           numbers.remove(i)\n           rolling_max(numbers.pop())\n    return numbers\n\nIt's a fun exercise to try to write a similar function that works with ints only.\n\nVery interesting. I just wrote a quick Python script to see if I could do this. For fun, I did it in a single line with a for loop:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    max = numbers[0]\n    while max!= numbers.end():\n       max = max + numbers[0]\n       rolling_max(max)\nreturn max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    max = 1\n    for i in numbers:\n       max = max + max % n(i)\n    return max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    i = 0\n    while i < numbers.count():\n        i += 1\n        if i < n:\n             i = n\n    return list(i)\nI'm not really sure, but I think this is a terrible way to do this.\n\nThank you for your comment. It is just the implementation I used for the example, not a real algorithm. I'm not a python guru, I'm trying to learn the language and some example are more interesting than others. I'll try to replace this with a more useful example as soon as I have the time to do so.\n\nIt would be a better example if it worked :)\n\nYou're right. I will fix that asap.\n\nThe is not a very useful example, and the implementation is very ugly. There are much better implementations in the comments.\n\nThank you for your comment. I will fix this soon.\n\nIt's not a very useful algorithm, but it is a very good way to learn Python.\n\nThank you for your comment. What would be a good example of", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for number in numbers:\n       if number < n:\n          number = n\n       else:\n          rolling_max(numbers - number + 1)\n    return numbers\n\nA much faster version using two nested for loops:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if n:len(numbers)!= n:len(numbers[0]) and n:len(numbers[0]) == 0:\n        return numbers[0]\n    else:\n        rolling_max = 0\n    for i in numbers[0]:\n        rolling_max += numbers[i]\n    return rolling_max\nI don't get it. The code in the article is much clearer and shorter:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    current, next = numbers\n    numbers.remove(current)\n    while next:\n       next = next.max()\n       if next == current:\n          current = next\n        else:\n           next = numbers.pop(current)\n\nI was trying to solve this problem for a really long time and I finally came up with this solution. Hope it's clear enough.\n\n\"numbers\" is a list of integers, but it's never defined. Also, the \"else:\" clause is a bit odd.\n\nThanks for the comment, I'll update it</s>"]]