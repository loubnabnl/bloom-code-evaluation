[["from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i < n:\n            numbers[i] = i\n            n = i\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    while True:\n        if numbers[0] < numbers[1]:\n            numbers[0] = numbers[1]\n            numbers.append(rolling_max(numbers[0]))\n        else:\n            numbers.append(numbers[0])\n    return numbers\n\nI don't know much about python, but the first thing I thought was that this was a bad idea because of the way the language works. But then I looked at the example and it seems like it works.\n\nThe example is somewhat contrived. In the real world, you'd be better off using a dict with a counter.\n\nI don't see why. If you're generating a list of integers, you're going to have a lot of duplicates. Why waste memory?\n\nBecause you're not going to have a lot of duplicates if you're generating a list of integers.\nIf you're generating a list of integers, you'll likely", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers[numbers.index(i) + 1]\n\nI have no idea what's going on here.\n\nI think it's supposed to be:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers.map(lambda i: i * 2)\n\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 3, 4, 4]\n>>> rolling_max([1, 2, 3, 2, 3, 4, 4])\n[1, 2, 3, 4, 4, 4]\n>>> rolling_max([1, 2, 3, 2, 3, 4, 4, 4])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: list index out of range\n>>> rolling_max([1, 2, 3, 2, 3, 4, 4, 4])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: list index out of range\n\nI'm guessing that's a Python bug.\n\nIt's not a bug, it's the result of the fact that Python's list type is a\ndictionary, not a list.\n\nIs there a way to get a list of lists in python?\n\nYes", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if n > 0:\n        max = numbers[0]\n        n = 0\n        for i in range(n):\n           if i < max:\n                max = i\n                n += 1\n         return [n]\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers[:0] + numbers[:1] + numbers[:2] + numbers[:3] +\n    numbers[:4] + numbers[:5] + numbers[:6] + numbers[:7]\n\nimport rolling_max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    start = 0\n    for i in numbers:\n        if i < start:\n           start += i\n        return start", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for number in numbers:\n        max = max(number)\n        rolling_max = rolling_max(max)\n    return rolling_max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    def max(numbers: List[int]) -> int:\n        return numbers[0]\n        return 0\n    for n in numbers:\n        max(numbers[n]) + 1\n    return numbers\n\n>>> rolling_max(range(1, 10))\n[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\n>>> rolling_max(range(1, 10), 3)\n[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 3, 4, 4]\n\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2], 3)\n[1, 3, 5, 7, 9, 11, 13, 15, 17, 19]</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in range(numbers.size):\n        max = numbers[i]\n        rolling_max = [max]\n        numbers.remove(i)\n    return rolling_max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for number in numbers:\n         if number == n:\n              return number\n              else:\n                 return rolling_max(numbers[-1])\n\nThis is not very interesting, and it's not very idiomatic Python.\nThe Python community has been working on a replacement for this sort of thing for a while. The idea is that instead of having to write a function for every possible data type, you should be able to define a generic function that works with any type. This is called a type class.\nA type class is like a function, except that you don't call it with arguments of a specific type. Instead, you say what the type of the arguments is, and the function is then automatically adapted to work with those arguments. For example, here's the type class for lists:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i not in numbers:\n            return numbers[i]\n            numbers.append(i)\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    numbers.reverse()\n    numbers.sort()\n    for n in numbers:\n        if n < rolling_max(numbers):\n           numbers.append(n)\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        max = numbers[i]\n        if max > numbers[i+1]:\n            numbers[i] = max\n    return numbers\n\nI'm a little confused by this.\nnumbers = [1, 2, 3, 2, 3, 4, 2]\nrolling_max(numbers)\n[1, 2, 3, 3, 3, 4, 4]\nThe result is 4, but I would have expected the result to be [1, 2, 3, 3, 4, 4]\n\nI would have expected that too, but it is not so.\nI think that the problem is that the result is a list, and not a tuple.\nI think that this is the reason:\nnumbers = [1, 2, 3, 2, 3, 4, 2]\nrolling_max(numbers)\n[1, 2, 3, 3, 3, 4, 4]\nThe result is 4, but I would have expected the result to be [1, 2, 3, 3, 4", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    start = 0\n    while numbers:\n        max = numbers[start:end]\n        new_start = start + max\n        rolling_max = new_start\n    return rolling_max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    def rolling_max_counter(counter: int):\n    \"\"\" Given a counter, return a list of rolling maximum elements found until this moment.\n    >>> rolling_max_counter(3)\n    [1, 2, 3]\n    \"\"\"\n    rolling_max_counter(counter)\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for number in numbers:\n        if number <= rolling_max(previous_number):\n           return number\n    return List()\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i > n:\n            yield i\n    if i < 0:\n             yield i\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i in range(0,numbers.size() - 1):\n           numbers.remove(i)\n           if i < numbers.size():\n               numbers.append(i)\n    return numbers\n\nHow is that better than this:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers:\n        return numbers\n    m = 0\n    while numbers:\n        if numbers[m] > m:\n           m = numbers[m]\n           rolling_max(numbers[m:])\n           return rolling_max(numbers[0:])\n\nI think you missed the point of the article.\n\nI think you missed the point of my comment.\n\nI think you missed the point of my comment to your comment.\n\nI think you missed the point of my comment to your comment to my comment.\n\nI think you missed the point of my comment to your comment to my comment to your comment.\n\nI think you missed the point of my comment to your comment to my comment to your comment.\n\nI think you missed the point of my comment to your comment to my comment to your comment.\n\nI think you missed the point of my comment to your comment to my comment to your comment.\n\nI think you missed the point", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for n in numbers:\n        if n > max:\n           max = n\n           rolling_max(numbers.pop(0))\n\nThis is the kind of thing I'd expect to see in a tutorial or a blog post, not in a library.\n\nI have seen this in a library before, and I'm still not sure what it's for.\n\nI'm not sure what it's for, but I am sure it's not for the library.\n\nIt's a good example of how Python's OOP works.\n\nI've been thinking of a way to do this in Ruby.\nThe closest I've come is to use a method that returns a list of tuples:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0, len(numbers)):\n        numbers[i] = numbers[i] + rolling_max(numbers[i-1])\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        max = i\n        max_seen = 0\n\n        if max < n:\n            max_seen += 1\n\n    return max_seen\n\nThis code is going to be pretty slow. I think the best way to do it would be to use a list of tuples and then do binary search.\n\nI would have just used a list comprehension:\n[x for x in numbers if x >= max]\n\nI've seen this in a few places now and I'm curious as to why it's preferable.\n\nThe OP's version is an O(n) algorithm, whereas the list comprehension is O(n).\n\nI'm not sure that's true. O(n) means that the algorithm runs in time proportional to the size of the input. The list comprehension is O(n) in the sense that it will run in linear time, but the list comprehension algorithm may not be O(n) in the sense that it will run in constant time.\n\nThe O(n) in \"O(n", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers == []:\n       return []\n    i = 0\n    for j in numbers:\n       if j > i:\n          j = j - i\n          i = i + 1\n          return numbers\n\nI'm not sure I understand what this is doing. Is it just generating a list of the last n numbers?\n\nYes.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i % 2 == 0:\n             yield i\n    else:\n              yield i + 1", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers.get(0).get(0).get(0).get(0).get(0)\n\nThat's not how you get the first element of a tuple.\n\nIt's not a tuple. It's a list of numbers.\n\nIf you look at the code in the gist, it's a list of numbers with the first element being a tuple.\n\nI'm sorry, I should have been more specific. I was talking about the method that was being called.\n\nOk, but then what's the problem with the method? It's just a method that returns a tuple.\n\nThe method is not called on a tuple, it's called on a list.\n\nOk, so? The code in the gist is not the code in the comment.\n\nI was referring to the comment in the gist.\n\nI see, I didn't realize that. I thought you were referring to the code in the gist.\n\nThat's a neat trick, but I'm not sure how useful it is.\n\nIt's useful if you have a list of numbers and want the first maximum in the list.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers.max()", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in numbers:\n        if i < rolling_max(i):\n           numbers.append(i)\n    return numbers\n\nfrom typing import List, Tuple\n\n    def rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    numbers.sort()\n    for i in numbers:\n        if i < rolling_max(i):\n           numbers.append(i)\n    return numbers\n\nfrom typing import List, Tuple\n\n    def rolling_max(numbers: List[int]) -> List[int]:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    max = 0\n    while numbers:\n        max = rolling_max(numbers[0])\n        numbers = numbers.pop(0)\n        max = rolling_max(numbers[1])\n    return max\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return (numbers[0] + numbers[1] + numbers[2] + numbers[3]) %\n    (len(numbers) - 1)", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0, n):\n        max = numbers[i]\n        rolling_max = rolling_max(max)\n    return rolling_max\n\nThis is a great example of how to write a bad python program.\n\nI don't know about that, but I certainly don't like it.\nIt's a list comprehension, and I think that's the worst way to write them.\nI think it's much clearer to write:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for n in numbers:\n        max = n\n        for i in range(n):\n            if max == i:\n                max = i + 1\n                rolling_max(numbers, max)", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    n = len(numbers)\n\n    numbers = [numbers[i] for i in numbers if i % n == 0]\n    for i in numbers:\n        rolling_max = rolling_max(numbers[i])\n        numbers.append(rolling_max)\n    return numbers\n\nThe correct way to do this is to use a generator expression:\n>>> from typing import List, Tuple\n>>> def rolling_max(numbers: List[int]) -> List[int]:\n...", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for number in numbers:\n        if number > rolling_max:\n            rolling_max = number\n             number = number - 1\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in numbers:\n       if i < rolling_max(i - 1):\n          rolling_max(i)\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    rolling_max = lambda x: (x + 1) % len(numbers)\n    for number in numbers:\n       rolling_max(number)\n    return rolling_max(numbers)\n\nIf you have a list of numbers, it's easier to just use the built-in max() function:\n>>> rolling_max = lambda x: max(x)\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 3, 4, 4]\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2], n = 5)\n[1, 2, 3, 4, 4]\n\nThanks for the tip, I had not seen that one yet.\n\nWhy is the list of numbers not a tuple?\n\nBecause that's not the point. The point is to show how to use Python's type system to your advantage.\n\nI don't see how this is an example of using Python's type system to your advantage. I can do this in Ruby:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    start = 0\n    while numbers:\n        n = numbers.pop()\n        if n > start:\n           numbers.append(n)\n           start += 1\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i == 0:\n            return i", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    n = 0\n    while n < len(numbers):\n        n = rolling_max(numbers[n - 1]) + 1\n    return n\n\nWhy not just use the built-in \"max\" function?\n\nmax takes a function as its second argument.\n\nmax([1,2,3])\n\n[1, 2, 3]\n\nI think it's better to use the built-in function max, as it is more well known.\n\nI agree. I always use max for this sort of thing.\n\nI think this is a nice illustration of why the \"from <module>\" syntax is not a good idea.\n\nWhat do you mean by \"from <module>\"?\n\nPython uses a 'from <module> import *' syntax. It's used to import functions from modules.\nThe OP's function was not a module.\n\nWhy not? It is clearly a function that can be called by others.\n\nA function is not a module.\n\nWhat is the difference?\n\nA module has a __name__ attribute, and a __doc__ attribute, and it's", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in range(numbers.size()):\n        if numbers[i] < numbers[i+1]:\n            numbers[i] = numbers[i+1]\n    return numbers\n\nAnd I thought I was clever for using a dictionary.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    start = numbers.pop()\n    for i in range(numbers.size()):\n        if i < start:\n           numbers.append(rolling_max(i))\n    return numbers\n\nimport sys\nsys.stdout.write(\"\\n\")", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i > n:\n            numbers.remove(i)\n        else:\n             numbers.append(i)\n    return numbers\n\nA better example of the power of Python's type system is this:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i > rolling_max(numbers):\n           return numbers[i]\n    return numbers\n\nI've seen this before, but I don't really understand why you'd want to use it. What is the use case?\n\nThe usual use case is to generate a sequence of random numbers. For example:\n>>> def rand(n):\n...           return (1 if n < 1 else (n*(n-1)) if n > 1 else (rand(n+1)))\n...", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i > rolling_max(i-1):\n           rolling_max(i-1) = i\n    return List(rolling_max(i))", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        max = 1\n        if max < i:\n            max = i\n            i = max\n        return List(max)", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers:\n        return numbers\n    else:\n        return List(0)", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return (numbers.most_common(numbers.size()).max() for n in numbers)\n\nNot sure what the point of this is. It's just a slightly different way of writing a for loop.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for number in numbers:\n         if number < max:\n              max = number\n    return Tuple(max, number)", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        max = i\n        rolling_max = [max]\n    return rolling_max\n\nThere's a typo in the code sample.\n\nFixed. Thanks for the heads up.\n\nNot sure if I understand the point of this, but I like the name.\n\nI don't think this is a good example. The problem with the code is that it doesn't define the function.", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers = [0]\n    for i in range(numbers.size):\n        if i in numbers:\n            numbers.append(i)\n             rolling_max(numbers)\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    max_numbers = []\n    for i in numbers:\n        max_numbers.append(rolling_max(numbers[i]))\n    return max_numbers\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i > rolling_max(numbers[i-1]):\n           numbers[i] = numbers[i-1]\n    return numbers\n\nI know this is a joke, but it's actually a pretty nice example of how to write concise code in python.\n\nI find it amusing that he didn't bother to define a __init__() function.\n\nHe also didn't bother to define a __str__() function.\n\nI find it amusing that he didn't bother to define a __repr__() function.\n\nI find it amusing that he didn't bother to define a __repr__() function.\n\nI find it amusing that he didn't bother to define a __repr__() function.\n\nI find it amusing that he didn't bother to define a __repr__() function.\n\nI find it amusing that he didn't bother to define a __repr__() function.\n\nI find it amusing that he didn't bother to define a __repr__() function.\n\nI find it amusing that he", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    min = 0\n    while numbers:\n        if numbers[i] > min:\n           min = numbers[i]\n           numbers[i] = min\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        max = i\n        for j in numbers:\n           if rolling_max(max+j, max):\n               max = max + j\n    return max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if n < 0:\n        return []\n    for i in numbers:\n        if n % i == 0:\n           return i\n           n = n % i\n    return numbers\n\nI see this as a very simple way to implement a rolling hash table. It's not a very efficient implementation, but it is simple and easy to understand.\n\nI'm not sure I understand how this is a hash table.\n\nYou can think of it as a hash table that has a fixed-size bucket.\n\nYou can think of it as a hash table that only has a single bucket.\n\nNot sure why you're being downvoted. This is a perfectly valid way to think of it. It's certainly not the only way to think of it, but it's certainly a valid way.\n\nBecause it's not a valid way to think of it. A hash table is a data structure, not a program.\n\nThat's a bit of a useless distinction, isn't it? You can think of a hash table as", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(numbers.size):\n        if i < numbers[-1]:\n           numbers[i] = i\n    return numbers\n\nThis is really a matter of taste.\nI think this is ugly. I'd use a map (or a dict) and a for loop.\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for number in numbers:\n       if number > max:\n          max = number\n          new_max = max + 1\n          rolling_max(new_max)\n    return new_max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    while True:\n        numbers.append(rolling_max(numbers[-1]))\n        numbers.sort()", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        rolling_max(numbers[i])\n    return numbers\n\nSee also\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for n in numbers:\n       if n > max:\n          max = n\n       else:\n          max = rolling_max(numbers[n:])\n\nI'm not sure I get it. If I understand it correctly, it will always return the last element?\n\nYes, it will always return the last element. The idea is to generate the \"rolling maximum\" of the sequence.\n\nI think the word \"rolling\" is the confusing part. It suggests something that rolls over and over.\n\nIt rolls over the elements of the sequence, not the sequence itself.\n\nAh, so it's rolling over the elements of the sequence.\n\nYes, it rolls over the elements of the sequence.\n\nI don't think I would call that rolling, though. Rolling implies that it's rolling over the whole sequence, not just a subset.\n\nYes, it's rolling over the elements of the sequence.\n\nThat's not rolling, that's iterating.\n\nYes, it's rolling over the elements of the sequence.\n\nI think", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    numbers.reverse()\n    for i in numbers:\n       max = numbers[i]\n       if max < n:\n          max = max + 1\n          if max > n:\n           max = max - 1\n           return max\n\nI don't understand the point of this.\n\nThe point is that it's a really stupid way to implement a rolling max.\n\nI think it's a great way to implement a rolling max. The code is short, easy to read and understand, and it does the job.\n\nThe only problem I see is that it's not tail recursive.\n\nI don't know Python, but isn't this:\nnumbers.sort()\nnumbers.reverse()\na tail recursive algorithm?\n\nYes, it is.\n\nYou can't write a tail recursive function in Python, because you can't return a function.\n\nI think the OP's point was that the rolling", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers.size == 1:\n       return numbers\n    for i in numbers:\n       if i > rolling_max(i-1):\n          numbers.append(rolling_max(i))\n    return numbers\n\nI'd prefer:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in range(1, len(numbers)):\n        if numbers[i] > numbers[i+1]:\n            rolling_max(numbers[i])\n    return numbers\n\nI don't see any benefit over this:\nfor i in range(1, len(numbers)):", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(numbers.size()):\n        numbers.remove(i)\n        rolling_max(numbers.pop(i))", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers = numbers.copy()\n    for i in range(0, len(numbers)):\n        if numbers[i] > numbers[i-1]:\n            numbers[i] = numbers[i-1]\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers.count(0) > 1:\n        return numbers\n    else:\n        return numbers[0]\n\nThat's a really good idea, but I think the author should have used a different name for it.\n\nYeah, I was trying to be clever, but it's not really rolling, it's just the max. I was also thinking of something like \"maxrolling\" but that's a bit too long.\n\nIt's a good idea, but I think you should have used a different name for it.\n\nI don't know, I think it's a pretty good name.\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    return numbers.reverse()\n\nHow do you use this?\n\nI think it's a pretty clear example.\n\nI'm not sure I understand. If I were to use this, what would be the input?\n\nIt's a function that takes a list of integers and returns a list of rolling maximum elements found until a given moment in the sequence.\n\nI don't understand the purpose of the function. Can you explain it to me?\n\nIt's a way to generate a rolling maximum.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i > rolling_max:\n           rolling_max = i\n           rolling_max_count += 1\n    return rolling_max_count\n\nRolling maximum is an algorithm that finds the maximum value in a sequence, by repeatedly finding the maximum element in the sequence. It is based on the observation that the maximum element in the sequence is almost always the element that is the largest so far, but not necessarily the largest in the entire sequence.\n\nThis algorithm is used in several situations:\n\n1) When a sequence is sorted, the maximum element is the first element in the sorted sequence.\n\n2) When a sequence is not sorted, the maximum element is the largest element in the sequence.\n\n3) When a sequence is not sorted and contains duplicates, the maximum element is the largest element that is not a duplicate.\n\n4) When a sequence is not sorted and does not contain duplicates, the maximum element is the largest element that is not the first or last element in the sequence.\n\nThe algorithm is usually implemented as", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for number in numbers:\n        if number < rolling_max:\n           rolling_max = number\n    return rolling_max\n\nI can't get past the fact that the \"import\" statement is commented out.\n\nI'm going to go out on a limb here and assume that the import statement is commented out because it's a really terrible idea to import a bunch of stuff you're not using.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    i = 0\n    for i in range(1, n):\n        if numbers[i] > numbers[i+1]:\n            numbers[i] = numbers[i+1]\n        i += 1\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    rolling_max = lambda x: x + 1\n    for i in numbers:\n       rolling_max(i)\n\nI don't think that's very useful.\n\nIt's not very useful, but it's a good illustration of the fact that a list is a tuple of elements.\n\nI don't think it's a very good illustration of that. The code would be the same if you had a tuple of integers.\n\nYou are correct. The only difference is that you would have to write something like:\nnumbers = [1, 2, 3, 2, 3, 4, 2]\n\nor:\nnumbers = (1, 2, 3, 2, 3, 4, 2)\n\nThat's a good illustration of the fact that a tuple is a list of elements.\n\nI think the original comment was referring to the fact that you don't have to use a list if you have a tuple.\n\nI think that's the case.\n\nTuple is a list of items, not a list of elements.\n\nYou are correct. I have fixed the comment.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if n is None:\n       n = 1\n       for i in numbers:\n           if i!= n:\n                   n += i\n    return n\n\nThat's a cute example. But it's not what I think of when I think of a tuple.\n\nA tuple is a container that can hold any number of values.\nIn python, tuples are used as a list of values that can be indexed by any of the values in the tuple.\n\nI'm familiar with the concept of tuples. I just don't think of them as a programming construct.\n\nI don't think of lists as a programming construct, but I don't see how that's relevant.\n\nI'm not saying it's relevant.\nI'm saying that I don't think of tuples as a programming construct.\n\nI would be interested to know what you think of as a programming construct.\n\nI'm going to have to go with \"things that are used to solve programming problems\".\nI'm not saying that", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    numbers.reverse()\n    while len(numbers) > 0:\n        numbers.append(rolling_max(numbers[-1]))\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in range(0,len(numbers)):\n        if i < len(numbers):\n            numbers.append(rolling_max(numbers[i]))\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0,len(numbers)):\n       if numbers[i] < numbers[i - 1]:\n          numbers[i] = numbers[i - 1]\n    return numbers\n\nI think it's more idiomatic to use a generator function like this:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if n > 0:\n        n = n + 1\n    else:\n        return numbers\n\nThe above function is a prime example of how to write Python code that is both readable and maintainable.\n\nIt's also a prime example of how to write Python code that is hard to understand, because it is not idiomatic.\n\nI'd say it's a prime example of how to write Python code that is hard to understand because the author is trying to use a language feature that is not idiomatic.\n\n\"from typing import List, Tuple\" is idiomatic.\n\nA little bit of a tangent, but I think it's interesting how the Python community is very much in favor of using PEP8, yet the author of the article does not follow PEP8.\n\nThe author of the article is using Python 2.5, which is not PEP8 compliant.\n\nI think the author is using 2.6.\n\nYou're right, I thought I saw 2.5 in the first screenshot, but it was 2.6.\n\nI love Python, but I think this is a bit", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    while numbers:\n        for i in numbers:\n           if i < rolling_max(i):\n               numbers.append(i)\n    return numbers\n\nI'm not sure what this is supposed to demonstrate.\n\nIt's a bad joke on my part. It's a sort of self-referential joke.\n\nI'm not sure I get it.\n\nI think the point is that the code is so trivial that it can be written on a single line.\n\nI know that. But it's not a very good joke.\n\nI don't think it's meant to be a joke, but rather a demonstration of the fact that the Python list type is a tuple.\n\nYeah, that's what I thought it was supposed to be, but it's not.\n\nI'm not sure what this is supposed to demonstrate.\n\nIt's a bad joke on my part. It's a sort of self-referential joke.\n\nI'm not sure I get it.\n\nI", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    # generate a list of all possible values for the maximum element\n    for i in range(0,len(numbers)):\n        maximum = numbers[i]\n        maximum_index = 0\n        numbers.append(maximum)\n        if maximum_index == len(numbers):\n           maximum_index = len(numbers)-1\n           maximum = numbers[i]\n           numbers.append(maximum)\n           # remove the maximum element from the list\n           numbers.remove(maximum)\n           # and add it to the list of all possible maximum elements\n           numbers.append(maximum)\n    return numbers\n\nI'm not sure I understand what this does. Could you explain it to me?\n\nIt takes a list of integers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for number in numbers:\n        if number > rolling_max:\n           rolling_max = number\n    return rolling_max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0, len(numbers) - 1):\n        if numbers[i] > numbers[i + 1]:\n            numbers[i] = numbers[i + 1]\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    rolling_max = lambda n:\n        if n < numbers.size:\n             return numbers[n]\n        if n > numbers.size:\n              return numbers[n+1]\n    return rolling_max(numbers)\n\nI've been using this approach for a while now and it's nice.\nIt's similar to the \"fold\" function in Haskell, but with a small twist.\nThe \"fold\" function is defined as:\nfoldr f [] = []\nfoldr f (x:xs) = f x\nfoldr f (x:xs, y:ys) = f x y:foldr f ys\nAnd it's used to do things like:\nfoldr (+) 0 [1, 2, 3, 4] == [1, 2, 3, 4, 4, 5, 6]\nfoldr (*) 0 [1, 2, 3, 4, 5, 6] == [1, 2, 3, 4, 5, 6, 8,", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        max = i\n        if max > max_seen:\n           max_seen = max\n           max = rolling_max(numbers[i:i+1])\n    return max_seen\n\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 3, 4, 4]\n\nIf you want to use this as a library, I'd suggest that you put this in a module.\n\nI don't see the point of using tuples here.\n\nI'd like to see the implementation of rolling_max.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers = numbers.map(numbers.max())\n    numbers = numbers.map(rolling_max)\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i % 2 == 0:\n            numbers.append(rolling_max(i - 1))\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if n == 0:\n       return numbers\n    else:\n       return rolling_max(numbers[-1], numbers[-1]) + 1\n\nThat's a nice one. It's a bit like the \"reduce\" function from Python.\n\nI was just about to say that, and it seems like this is a list comprehension in python.\n\nThis is a list comprehension in Python:\nrolling_max([1, 2, 3, 2, 3, 4, 2])\n\nThis is a list comprehension in Python 2.5 (the list comprehension syntax is new in 2.5):\nrolling_max([1, 2, 3, 2, 3, 4, 2])\n\nOr, using Python 2.4 syntax,\nrolling_max([1, 2, 3, 2, 3, 4, 2])\n\nI'm not sure why you were downvoted, I use 2.4 syntax all the time.\n\nI don't know either, but I'm glad someone pointed out the 2.5 syntax.\n\nThis is pretty neat, but there is a built-in function to do", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(1, len(numbers)):\n        if i == numbers[0]:\n           return numbers[i]\n           else:\n              numbers[i] = numbers[i - 1]\n    return List(numbers)\n\nThis is very close to the way I'd have done it.\nThe only thing that would have bothered me is the assignment to numbers[i]\nin the second loop. I'd have used a dictionary instead.\n\nThe code is very simple, but what's wrong with it?\n\nIn Python, if you're using a list comprehension, you might as well use\nthe list comprehension syntax. It's less characters.\nIn this case, you can use\nnumbers = [i for i in range(1, len(numbers) if i == numbers[0] else numbers[i - 1]]\nand get the same result.\n\nI would have gone with the dictionary, but your solution is more concise.\n\nDictionaries are", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers.map(lambdax: x + 1)\n\nThis is a very useful function, but it's not a good example of why you would use a functional programming language. This could have been written in Python just as easily.\n\nYou can do this in Python, but it's not as pretty.\n\nIn Python, you can use the `itertools.chain` module to do this:\nimport itertools", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    start = 0\n    while numbers:\n        if numbers[start] > numbers[start + 1]:\n           numbers.append(numbers[start])\n         start += 1\n    return numbers\n\nSo, it's a list of the first n elements that are greater than the previous n elements.\n\nIf you are interested in some of the other fun things you can do with typing, check out this tutorial:\n\nI really like this. It's a nice way to implement a rolling hash table.\n\nYou can get a lot of mileage out of type-level programming.\n\nI'm curious as to why you don't use a Python list for this. It seems like this code is more complicated than necessary.\n\nI agree that it is more complicated than necessary. The main reason is that I wanted to see how to use typing. In Python I would have used a list or a set.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        rolling_max = max(rolling_max(i - 1), numbers)\n    return rolling_max\n\nIf you're going to have a \"from typing import\" statement, you might as well have the \"from functools import partial\" statement too.\n\nI think that's the point. It's a joke.\n\nOh, I see. I thought he was saying \"import this because it's useful\", but he was saying \"import this because it's useless\".\n\nIt's both.\n\nWhy is it both?\n\nBecause it's useful to have a useless module in your code, because then you can import it and then laugh at the import.\n\nI didn't get it, thanks.\n\nI think this is one of those cases where a code example is necessary.\n\nI'm not sure if it's a joke, but it's certainly useless.\n\nI didn't get it until I saw that it was from the python.org domain.\n\nIt's a joke. It's from the Python wiki.\n\nI don't get it. Why is it a joke?", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i > n:\n             rolling_max(numbers[i - 1], numbers[i])\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in numbers:\n       if i > numbers[-1]:\n          numbers[i] = numbers[-1] + 1\n       else:\n          numbers[i] = numbers[-1]", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i < n:\n             return i\n               n = i + 1\n                return n", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    a = numbers[0]\n    while len(a) > 0:\n        a = a[0] + a[1] + a[2] + a[3] + a[4]\n        numbers[a] = a\n    return List(a)", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i not in rolling_max:\n           rolling_max.append(i)\n    return rolling_max\n\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 3, 4, 4]\n>>> rolling_max([1, 2, 3, 4, 2, 3, 5, 4])\n[1, 2, 3, 3, 3, 4, 4, 4, 5]\n>>> rolling_max([1, 2, 3, 2, 3, 4, 5, 4])\n[1, 2, 3, 3, 3, 4, 4, 5, 5]\n\nI'm not sure why I find this so satisfying to look at.\n\nIt's like a fractal!\n\nAnd the code is fractal-ish too.\n\nI don't get it.\n\nThe code is recursive, and the recursive calls are nested in a recursive fashion.\n\nI know that, but I don't see the fractalness.\n\nThe nested", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(numbers.size()):\n        rolling_max(numbers[i])\n    return numbers\n\nNot sure why the downvote. This is a perfectly reasonable way to implement this function.\n\nI think it's because it's too easy to misunderstand. The function is not named rolling_max, it's named rolling_max_from_list.\n\nThat's a good point. I guess I just assumed it was a standard function.\n\nWell, it's not. It's a function he wrote.\n\nI know, I was just saying it's a good idea.\n\nSo, I'm not a python programmer, but this doesn't seem like a big deal to me. I think the article is a little over-dramatic.\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0, len(numbers)):\n       if numbers[i] < numbers[-1]:\n          return numbers[i]\n       else:\n          return numbers[-1]", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    # Start with the first element in the list, and see if it is a max\n    while n < numbers.count():\n        if n == numbers[0]:\n           return numbers[0]\n        # Otherwise, add it to the list of rolling max\n        numbers.append(n)\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n       if i >= max:\n           numbers.remove(i)\n           max = i\n    return numbers\n\nI prefer", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i < n:\n            rolling_max(numbers[i])\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers:\n       return numbers\n    else:\n       rolling_max = [0]\n       for i in numbers:\n          rolling_max.append(i)\n        rolling_max.append(rolling_max.max())\n    return rolling_max\n\nimport sys\nimport math", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    n = 0\n    while numbers:\n       if numbers[n] > n:\n          n += 1\n       numbers = numbers.pop()\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers[:i] if i < len(numbers):", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        max = max(numbers[i])\n        numbers[i] = rolling_max(max)\n    return numbers\n\nI don't know much about python, but I know enough to know that I don't like it.\nI'm not sure what I dislike about it, but something about it just rubs me the wrong way.\n\nThe best way to get to know Python is to write some code in it. It's easy to criticize languages from the outside.\n\nI've written a fair amount of code in python, and I've never been able to get over the fact that the language lacks an identity. It's just a mish-mash of features, many of which are borrowed from other languages, and very few of which are actually useful.\n\nIt's a language that was created by a bunch of people who really knew how to write good code. The result is a language that makes it easy to write good code. I think the lack of an identity is a feature, not a bug.\n\nI think the lack of identity is a result of the fact that it was created by", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n       if i < n:\n          rolling_max(numbers[i])\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in numbers:\n       if i < n:\n           numbers.append(rolling_max(numbers[i]))\n    return numbers\n\nThis is a great example of a function that is so simple to write that it's almost useless.\n\nI don't know, I think it's a great example of a function that is so simple to write that it's almost useful.\n\nI'm sure this is a great example of a function that is so simple to write that it's almost useless.\n\nThe only thing it's missing is a comment that says \"This is a great example of a function that is so simple to write that it's almost useful.\"\n\nWhy does this have a comment?\n\nBecause it's a great example of a function that is so simple to write that it's almost useful.\n\nI think it's a great example of a function that is so simple to write that it's almost useful.\n\nI'm sure this is a great example of a function that is so simple to write that it's almost useful.\n\nThe only thing", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in range(0, len(numbers) - 1):\n        if numbers[i] < numbers[i + 1]:\n            numbers[i] = numbers[i + 1]\n            numbers[i + 1] = rolling_max(numbers[i])\n\nYou can do better than that:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    rolling_max = lambda x: x if x < n else x + 1\n    for i in numbers:\n       rolling_max(i)\n    return rolling_max\n\nfor n in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    min = 0\n    max = len(numbers)\n    while numbers:\n       max = max + rolling_max(numbers[i])\n       min = min + 1\n    return max\n\nAs a python novice, I would have preferred if the author had put a comment at the top explaining what the function did.\n\nI have to say, as a non-python novice, the code was pretty easy to understand without any comments.\n\nI have to say, as a non-python novice, the code was pretty easy to understand with the comment.\n\nI have to say, as a non-python novice, I didn't understand the comment, but the code was pretty easy to understand without it.\n\nI have to say, as a non-python novice, I didn't understand the code, but the comment was pretty easy to understand.\n\nI have to say, as a non-python novice, I didn't understand the comment, the code, or the non-python novice.\n\nI have to say, as a non-python novice, I didn't understand the non-python novice", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if len(numbers) == 1:\n       return numbers\n    else:\n       for number in numbers:\n          if rolling_max(number):\n              return number\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for number in numbers:\n        if number > rolling_max(number):\n            numbers.append(number)\n    return numbers\n\nThe author of this post seems to think that list is the only data structure in Python.\n\nI was thinking the same thing. I'm not sure what he was trying to accomplish, but he could have done it with a dictionary, or even a list of lists.\n\nI'm not sure why you're being downvoted, you're completely right.\n\nBecause this is a very common mistake that beginners make. It's easier to understand when you've done it a few times and you have a better understanding of how Python works.\n\nI'm not a beginner, and I still make this mistake all the time.\n\nIt's not just Python. I've seen it in a lot of languages.\n\nYeah, I don't think it's a mistake, it's just a different way of thinking about the problem.\n\nThis is a great example of how to do it wrong.\nThe problem with this is that if you have", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers:\n        return [numbers[0] for _ in numbers if n[0] > n[1]]\n    else:\n        return [numbers[0] for _ in numbers if n[0] > 0]\n\nThis is one of those things that is much easier to read in Python than in English.\n\nIt's not even that much easier to read in Python. It's just more compact.\n\nI agree, I think it's just a matter of familiarity.\n\nIn the spirit of \"there's more than one way to do it\" I have a very similar function that I use a lot. I find that it's a bit more flexible than rolling_max.", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i < n:\n           numbers[i] = max(numbers[i], numbers[i - 1])\n           numbers.append(rolling_max(numbers))", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers.max()\n\nfrom typing import List, Tuple\n\n    def rolling_max_with_gap(numbers: List[int], gap: int) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_with_gap([1, 2, 3, 2, 3, 4, 2], 2)\n    [1, 2, 3, 3, 4]\n    \"\"\"\n    return numbers.max(gap)\n\nfrom typing import List, Tuple\n\n    def rolling_max_with_gap_with_sum(numbers: List[int], gap: int, sum: int) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_with_gap_with_sum([1, 2, 3, 2, 3, 4, 2], 2, 3)\n    [1", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in numbers:\n        rolling_max(i)\n    return numbers\n\nHere's a better version:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in numbers:\n        if i < numbers.pop(0):\n           numbers.append(rolling_max(i-1))\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    n = len(numbers)\n    for i in range(1, n):\n        numbers[i] = numbers[i] + 1\n    return numbers\n\nI don't get it, why is this so bad?\n\nThe last line of code is not necessary.\n\nIt is necessary to generate a list of the rolling max elements. The last line just happens to be the most convenient way to do it.\n\nIt's not. It's just an example of a common programming error: \"I can do this in a really convoluted way, so I will\".\n\nI don't think it's convoluted at all.\n\nIt's not convoluted, it's just not needed.\n\nI'm not sure what you mean.\n\nThe last line of the function is not necessary. It's just the most convenient way to do it.\n\nWhat is the most convenient way to do it?\n\nI'm not sure what you mean.\n\nThe last line of the function is not necessary. It's just the most convenient way to do it.\n\nWhat is the most convenient way to do it?\n\nI'm not", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0, len(numbers)):\n        max = numbers[i]\n        rolling_max = []\n        rolling_max.append(max)\n        rolling_max.append(max)\n    return rolling_max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n       if i > rolling_max[i-1]:\n          numbers.append(i)\n    return numbers\n\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 3, 4, 4]\n\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2, 3, 4])\n[1, 2, 3, 3, 3, 4, 4, 4]</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(numbers.length):\n        if i >= numbers[-1]:\n           numbers[i] = numbers[i - 1] + 1\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    max = 0\n    while True:\n       numbers = numbers.pop(0)\n       if numbers.has_key(max):\n          max = numbers[max]\n          numbers.pop(0)\n    return max\n\nThis is pretty neat. I think it would be useful to have a more general version that works on any iterable type.\nI don't know if this is a problem with my Python installation, but I'm getting this error:\nTypeError: 'list' object is not callable\n\nThanks. I think I'll implement it for any iterable. I'll post the code if it works.\n\nThis is really useful. I think it would be cool if it had a mode where you could specify the number of times to roll over the list, and the function would generate a list of tuples, each of which is the max of the last n elements in the list.\n\nThat's a really nice idea. I'll implement it.\n\nI've implemented a mode where", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0,len(numbers)):\n        max = numbers[i]\n        rolling_max = [max]\n    return rolling_max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i < n:\n           rolling_max(numbers[i:i+n])\n    return numbers\n\nAnd this is why I always use Python's typing module.\n\nWhy is that? I'm not familiar with python's typing module.\n\nIt enforces type checking. You have to declare the type of your variables and functions.\n\nI'm a bit confused by the author's use of the word \"list\". If you're using the Python list type, then you can't use a tuple.\n\nIt's a list of tuples.\n\nNo, it's a list of lists.\n\nSorry, I meant list of tuples.\n\nI think the author is using a different meaning of \"list\" than most people.\n\nI think he is using the dictionary definition of list, which is basically a collection of items with no order.\n\nI like the idea of rolling max, but it's not really a list. It's a list of tuples.\n\nIt's a list of lists, or as I like to call it, a", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n         if i % 2 == 0:\n              rolling_max(numbers[i])\n          else:\n              numbers[i]", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers.map(rolling_max)", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for number in numbers:\n        max = max(number)\n        rolling_max = [rolling_max(number+1), rolling_max(number+2)]\n\n    return rolling_max\n\nI love this. I love it because it's a perfect example of how to write Python code that's easy to read and easy to understand, and yet is also an example of some of the more advanced features of Python.\nIt's a very simple idea, but it's implemented in a way that makes it clear what it's doing, and how it's doing it. I like it.\n\nI love this. I love it because it's a perfect example of how to write Python code that's easy to read and easy to understand, and yet is also an example of some of the more advanced features of Python.\nIt's a very simple idea, but it's implemented in a way that makes it clear what it's doing, and how it's doing it. I like it.\n\nI don't understand the point of this. What is it supposed to do?\n\nIt's a simple example of how to use the list and", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i > n:\n           numbers.append(i)\n           rolling_max(numbers)\n\nfrom typing import List, Tuple\n\n    def rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    for i in numbers:\n        if i > n:\n           numbers.append(i)\n           rolling_max(numbers)\n\nThis is a good example of a class that should be a function.\n\nIn Python, that's a function:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for number in numbers:\n        if number > max:\n             max = number\n             rolling_max = rolling_max(numbers - 1)\n             rolling_max.append(number)\n    return rolling_max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for number in numbers:\n       if number > rolling_max(number):\n          rolling_max(number) = number\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for number in numbers:\n        if number == max_number:\n           return numbers\n        else:\n            max_number = number\n            return numbers\n\nI'm not sure that's much better than the built in max() function.\n\nIt's not.\n\nYou're right, it's not. It's better.\n\nI'd like to see this:\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(1, len(numbers)):\n         if numbers[i] > numbers[i + 1]:\n             numbers[i] = numbers[i + 1]\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0, len(numbers)):\n        if i in numbers:\n           return numbers[i]\n           if i % 2 == 0:\n                  numbers[i] = rolling_max(numbers[i - 1])\n                   numbers[i] = rolling_max(numbers[i - 2])\n    return numbers\n\nI don't understand why this is a blog post.\n\nI don't understand why this is a comment.\n\nI don't understand why this is a reply.\n\nI don't understand why this is a reply to a reply.\n\nI don't understand why this is a reply to a reply to a reply.\n\nI don't understand why this is a reply to a reply to a reply to a reply.\n\nI don't understand why this is a reply to a reply to a reply to a reply to a reply.", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0, len(numbers)):\n        if numbers[i] > numbers[-1]:\n            numbers[i] = numbers[-1]\n    return numbers\n\nThis is a really cool one.\nI wonder if it's possible to do this in a more general way.\n\nI think you could, but you'd have to use a different sorting algorithm.\n\nIt's not a sorting algorithm, it's a counting algorithm.\n\nI'm sure you're right. I was thinking of the ability to work with a list that is not sorted.\n\nI love this, and I think I'll start using it in place of the built-in max() function.\n\nI think you're missing the point of the article. The point is to show that Python's built-in functions can be written in terms of each other.\n\nI think you're missing the point of my comment. I was commenting on the rolling_max() function, which I thought was cool, and would use. I wasn't commenting on the article.\n\nI'm not sure you're", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers:\n        return numbers\n    else:\n        return [1, 2, 3, 3, 4]", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers = numbers.sort()\n    while True:\n        if numbers:\n             numbers = numbers[0]\n               numbers.append(rolling_max(numbers))\n\nThat's a nice little function.\n\nA bit slow though.\n\nNope, it's O(n)\n\nThe slowest part is the recursion, which is O(n^2). The rest is O(n).\n\nNice. But this isn't a list, it's a tuple.\n\nI thought about it as a tuple, but it is a list of elements, so I went with list.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in numbers:\n        if i > numbers[0]:\n             numbers[i] = numbers[0]\n    return numbers\n\nimport operator", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    def rmax(numbers: List[int]) -> int:\n    \"\"\" Return the maximum element in a given list of integers.\n    >>> rmax([1, 2, 3, 2, 3, 4, 2])\n    3\n    \"\"\"\n    max = 0\n    while len(numbers) > 0:\n       max = rmax(numbers[max-1])\n       numbers.append(max)\n    return max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for n in numbers:\n       if n > rolling_max(numbers):\n          numbers = numbers[n:]\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n       if i < n:\n          n = i\n       rolling_max = []\n       for j in range(n):\n          rolling_max.append(i)\n       return rolling_max\n\nI don't see why the first part is necessary.", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i > rolling_max(i - 1):\n            numbers.append(i)\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    rolling_max = Tuple([0])\n    rolling_max.append(numbers[0])\n    while len(numbers) > 0:\n       rolling_max.append(numbers[-1])\n       rolling_max.append(numbers[-2])\n       rolling_max.append(numbers[-3])\n    return rolling_max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return [numbers[i] for i in range(numbers.length)]\n\nI know this is an old post, but I'm not sure if this is the same as the rolling_max in the Python standard library.\n\nNo, it isn't. The one in the standard library returns a tuple.\n\nIn Python 3 it returns a list.\n\nThis is an interesting problem, and I think there is a better solution than the one in the article.\nThere are two problems:\n1) Find the maximum of a list of numbers.\n2) Find the maximum of a list of numbers that is generated in a rolling manner.\nFor 1) you can use a hash table. The problem is that you need to have the maximum value in the hash table. To do this, you can use a list of the maximum values that you found. If you have a list of the maximum values you found, you can use a binary search.\nFor 2) you can use a binary search. The problem is that you need to have the maximum value in the binary search. To do this, you can use a list of the maximum values that you found. If you have a list of the maximum values", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0, len(numbers)):\n        max = numbers[i]\n        rolling_max = numbers[i]\n        if rolling_max == max:\n            rolling_max = max\n    return rolling_max\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n       if i == max:\n          return i\n       else:\n          return rolling_max(numbers[i:i+1])\n\nThis is a great example of how the syntax of Python is so much more readable than that of C.\n\nIt is not just Python. You can do the same in C++ or Java.\n\nIt's a bit more verbose in Java, but still pretty straightforward.\n\nThe code is pretty verbose in Java, but the structure is similar.\n\nIt's not.\n\nWell, it is, but with the verbosity of Java it's a bit more verbose.\n\nAnd I think this is a good example of why Python is more readable than Java.\n\nThe code is much more readable in Java than in Python.\n\nIt's more verbose in Java.\n\nIt's not.\n\nWell, it is, but with the verbosity of Java it's a bit more verbose.\n\nI've been programming in Python for a few months now, and", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i >= 0:\n              return i", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in numbers:\n        if i < n:\n            rolling_max(i)\n    return numbers\n\nThe Python standard library has a function called max() that does this.\n\nYes, but this is a bit more general, and the code is more concise.\n\nI'm not sure I agree. It's a bit more general in the sense that it's not restricted to numbers, but I don't see how it's more concise.\n\nIt's not just more general, it's also more efficient. Max() works by iterating over the entire list and comparing every element to the one you're looking for. This is a linear time algorithm.\nRolling_max() works by iterating over the list once, keeping track of the largest element found, and then comparing every element to the one you're looking for. This is an O(n) algorithm.\n\nI know, but the difference is negligible. I don't think it's worth the extra code.\n\nI don't know about negligible.\n>>> rolling_max([1, 2,", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    n = numbers.pop()\n    numbers.append(n)\n    while n > 0:\n        if n == numbers.size():\n           return numbers\n           numbers.remove(n)\n           n = n + numbers.max()\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    min = numbers[0]\n    max = numbers[len(numbers)-1]\n    for number in numbers:\n       if number < min:\n          max = number\n          min = number\n    return max, min\n\nNice. I wonder if it's possible to do a similar thing with a list of tuples.\n\nI'm not sure I understand the use case for this.\n\nI think it's a great example of why you shouldn't use Python's list comprehension syntax for defining functions.\n\nI think it's a great example of why you should use Python's list comprehension syntax for defining functions.\n\nThis is why you shouldn't use Python's list comprehension syntax for defining functions.\n\nI think it's a great example of why you shouldn't use Python's list comprehension syntax for defining functions.\n\nI think it's a great example of why you should use Python's list comprehension syntax for defining functions.\n\nI think it's a great example of why you shouldn't use Python's list comprehension syntax for defining functions.\n\nI think", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        rolling_max = [max(i) for i in numbers if i < n]\n    return rolling_max\n\nI'm sorry, but what's the point?\n\nIt's a good example of how to write a Python function.\n\nI'm pretty sure that's a bad example of how to write a Python function.\n\nI'm pretty sure it's a great example of how to write a Python function.\n\nThis is a great example of how to write a bad Python function.\n\nThis is a great example of how to write a bad Python function.\n\nThis is a great example of how to write a bad Python function.\n\nI'm pretty sure that's a bad example of how to write a Python function.\n\nI'm pretty sure that's a great example of how to write a Python function.\n\nThis is a great example of how to write a bad Python function.\n\nThis is a great example of how to write a bad Python function.\n\nThis is a great example of how to write a bad Python function.\n\nI'm pretty sure that's a bad example of how to", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for number in numbers:\n        rolling_max = Tuple(number, next(rolling_max, -1))\n        rolling_max.append(number)\n    return rolling_max\n\nI prefer the use of a dictionary instead of a tuple, but I think the point is still valid.\n\nI've never seen anyone use a dictionary for this sort of thing. If you have a use case, I'd be interested to hear it.\n\nI'm not sure how I feel about this.\nI like the fact that the author of the code I'm reading is explicit about what they are doing.\nI dislike the fact that the code I'm reading is explicit about what they are doing.\n\nI don't think this is any worse than the \"from foo import *\" of Python.\n\nI think it's worse. At least with \"from foo import *\", I know I can ignore the next few lines, and the code will still work.\n\nI've seen this used in Python to avoid name clashes with other modules.\n\nI think this is great. I'm pretty sure it was in the book \"", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if n is None:\n       return []\n    for i in numbers:\n       if i > n:\n          n = i\n          rolling_max(numbers[i])\n    return [n]\n\nThat's not very useful, is it?\n\nIt is if you're trying to figure out the maximum value in a list of numbers.\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers.filter(n > rolling_max(numbers[-1]))\n\nI think the version with an explicit list comprehension is easier to understand:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for n in numbers:\n        if n > max_value:\n            max_value = n\n            numbers.append(n)\n    return numbers\n\nThe fact that he is using list and tuple interchangeably is kind of a pet peeve of mine.\n\nIt's a little bit of a pet peeve of mine, too, but I don't think it's a big deal.\nI think the real problem is that he's using a list comprehension instead of a for loop. I'm not sure I understand why he's doing that.\n\nI think the real problem is that he's using a list comprehension instead of a for loop. I'm not sure I understand why he's doing that.\nHe's using a list comprehension because it's a list comprehension. It's a perfectly valid way to express the problem.\n\nIt's a perfectly valid way to express the problem, but a for loop would be a better way to express the problem.\n\nWhy?\n\nBecause it's more concise and easier to understand.\n\nWhat about the comprehension is", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if n < 0:\n        return []\n    for i in numbers:\n        if i > n:\n            return i\n    return Tuple([n for n in numbers if i > n])\n\nI don't know why, but I like this. It's like a list comprehension that actually has a comprehensible syntax.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    start = 0\n    while True:\n        if numbers[0] > start:\n            numbers.append(numbers[0])\n            start = numbers[0]\n            numbers.append(rolling_max(numbers[1:]) + start)\n    return numbers\n\nI like it. You can also do the same with Python's built-in function max(), but this is much more elegant.\n\nIt's a good idea, but I don't like the fact that it's not obvious that the \"rolling_max\" function returns a tuple, and that it's not obvious that the \"numbers\" list is a list of tuples.\n\nIt's pretty clear that it's a tuple, though.\n\nBut it's not clear that it's a list of tuples, not a list of integers.\n\nI don't know, I think it's pretty clear that it's a list of tuples.\n\nIt's not clear to me. I had to read the", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers == [] or len(numbers) == 0:\n       return numbers\n    numbers.sort()\n    numbers.reverse()\n    rolling_max = []\n    for i in range(len(numbers)):\n       rolling_max.append(numbers[i])\n    return rolling_max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(1, len(numbers)):\n        if numbers[i] < numbers[i - 1]:\n            numbers[i] = numbers[i - 1]\n        else:\n            numbers[i] = numbers[i - 1]\n    return numbers\n\nNot as bad as it looks.\n\nI think it's pretty bad.\n\nYou can't call a function that takes a list of integers and returns a list of integers a \"typing error\". It's a perfectly valid function that does exactly what it's supposed to do.\n\nI think it's a joke, because the OP doesn't know what \"from typing import\" means.\n\nOh.\n\nThe OP's question was about the \"rolling_max\" function.\n\nI'm not sure what you mean.\n\nI mean that the OP's question was about the function rolling_max, not the \"from typing import\" statement.\n\nI know, but I wasn't sure what you were getting at.", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n          numbers.remove(i)\n          if i == 0:\n              numbers.append(rolling_max(numbers))\n    return numbers\n\nThis is a nice little utility function, but it is not a tuple.\n\nIt is not a tuple, but it is a list of tuples.\n\nI was going to say that it's a list of tuples with the same number of elements, but that's not right either. A tuple is a list of tuples with the same number of elements, and a list is a tuple with the same number of elements.\n\nThis is a list of tuples with the same number of elements.\n\nI'm not sure you can say that, because the result of the function is a list, not a tuple.\n\nI think you can. A tuple is a list of tuples with the same number of elements. This is a list of tuples with the same number of elements.\n\nA tuple is a tuple of tuples with the same number of elements.", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    while numbers:\n        if numbers[0] < numbers[1]:\n             numbers = numbers.pop()\n              numbers = numbers.pop(0)\n              numbers = numbers.pop(1)\n              numbers = numbers.pop(2)\n              numbers = numbers.pop(3)\n              numbers = numbers.pop(4)\n              numbers = numbers.pop(5)\n              numbers = numbers.pop(6)\n              numbers = numbers.pop(7)\n              numbers = numbers.pop(8)", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    \"\"\" The idea is to generate a list of rolling maximum elements found until a given moment.\n    For instance, in the case of the list [1, 2, 3, 2, 3, 4, 2],\n    the first element of the resulting list is the maximum of the first two elements of the list\n    and the second element of the resulting list is the maximum of the next two elements of the list.\n    \"\"\"\n    for i in range(1, len(numbers)):\n        if i % 2 == 0:\n            numbers[i] = numbers[i - 1]\n            numbers[i] += 1\n            rolling_max.append(numbers[i])\n    return rolling_max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers.max()\n\nThere are a few problems with this code.\nFirst, it is a bit confusing to define a function named \"rolling_max\" that doesn't return a list.\nSecond, the function is named \"rolling_max\" but it doesn't return a rolling maximum.\nThird, the code is not well-commented.\n\nYeah, it's a bit confusing. I think the author is trying to make it look like a \"rolling maximum\" function but the actual function is just a normal max.\n\nI agree. But that doesn't make it less confusing.\n\nI think it's a pretty good example of how not to write Python.\n\nI think it's a pretty good example of how not to write _anything_, really.\n\nI was referring to the fact that the function doesn't do what it's called, not that the code is bad in general.\n\nI know, but it's also an example of bad code.\n\nI don't think that's a good example of bad code. The code is fine, it's just not named properly.\n\nI think it's a good example of bad code, but not a good example of", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for number in numbers:\n       if number < rolling_max:\n          number = number + 1\n       rolling_max = number\n\nThis is a good example of a bad idea. The author could have used a list comprehension instead.\n\nI'd rather see a list comprehension than a list comprehension that uses a tuple.\n\nI'd rather see a list comprehension that uses a tuple than a list comprehension that uses a list.\n\nI'd rather see a list comprehension that uses a tuple that uses a list that uses a tuple that uses a list that uses a tuple that uses a list that uses a tuple that uses a list that uses a tuple that uses a list that uses a tuple that uses a list that uses a tuple that uses a list that uses a tuple that uses a list that uses a tuple that uses a list that uses a tuple that uses a list that uses a tuple that uses a list that uses a tuple that uses a list that uses a tuple that uses a list that uses a tuple that uses a list that uses a tuple that uses a list that uses a tuple that uses a list that uses a tuple that uses a", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0, len(numbers)):\n        numbers[i] = numbers[i] + 1\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(numbers.size):\n        if numbers[i] > numbers[i+1]:\n           numbers[i] = numbers[i+1]\n    return numbers\n\nA \"tuple\" is a 2-item collection.\nA \"list\" is a 1-item collection.\nSo, how can you make a 2-item collection out of a 1-item collection?\n\nYou can't.\n\nYes you can. A tuple is a special case of a list, it's just that the values\nare immutable.\n\nTuple is a type, List is a type.\nList is a 1-item collection.\nTuple is a 2-item collection.\n\nYou can have a 2-item collection of lists.\n\nIt's a list of lists.\n\nYes, and a list is a list of tuples.\n\nNo, a list is a list of values, which is a tuple.\n\nIn Python, a list is a list of tuples.\n\nNo, a list is a list of values, which is a tuple.", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n          if i > max:\n              max = i\n               max_num = max\n               max_num = rolling_max(max_num)\n    return max_num", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i == 0:\n            return numbers\n         if i < n:\n             return i\n          if i == n:\n              return rolling_max(numbers - i)\n    return rolling_max(numbers)\n\nI'm not sure I understand the point of this function. Is it to find the maximum element of a list? If so, the if i < n: clause is redundant, because if i is less than n, then i is already in the list.\n\nI think it's to find the _rolling_ maximum_, which is the maximum of the list that is not in the list.\n\nOh, I see. I didn't realize that was a thing.\n\nIt's not really a thing, it's just a clever way to find the maximum element of a list that is not in the list.\n\nIt's a thing, in the sense that", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    rolling_max = [],\n    while True:\n        rolling_max.append(numbers[i])\n        n = len(numbers)\n        if n > max:\n           rolling_max.append(max)\n          break\n\nPython's typing is a bit more flexible than Java's:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i > rolling_max:\n           rolling_max = i\n    return numbers\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0, len(numbers)):\n        max = numbers[i]\n        numbers.remove(i)\n        numbers.add(max)\n    return numbers\n\nI don't understand why the tuple is needed.\n\nI think it's because the range function returns a tuple.\n\nI was wondering about that. I would have written:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        rolling_max = numbers[i]\n        numbers.append(rolling_max)\n    return rolling_max\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    rolling_max = lambda x: x if x > a else b\n    for n in numbers:\n        rolling_max(n)\n\nIt's a shame that he doesn't have the Tuple class implemented in Python 2.5.\n\nThat's probably because it's a bad idea.\n\nI think you're missing the point of the article.\n\nI don't think I am.\n\nI think you are.\n\nNo, I'm not.\n\nI think you are.\n\nNo, I'm not.\n\nI think you are.\n\nNo, I'm not.\n\nI think you are.\n\nNo, I'm not.\n\nI think you are.\n\nNo, I'm not.\n\nI think you are.\n\nNo, I'm not.\n\nI think you are.\n\nNo, I'm not.\n\nI think you are.\n\nNo, I'm not.\n\nI think you are.\n\nNo, I'm not.\n\nI think you are.\n\nNo, I'm not.\n\nI think you are.", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in range(0, len(numbers)):\n       numbers.append(rolling_max(numbers[i]))\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return [numbers[i] for i in numbers if i > (numbers.size() - 1)]\n\nI like this.\n\nThanks!\n\nI prefer the one liner:\nimport itertools", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers == []:\n        return [1]\n    for i in numbers:\n        if numbers[i] > numbers[i+1]:\n                numbers[i] = numbers[i+1]\n        else:\n                numbers[i] = rolling_max(numbers[i])\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    while numbers:\n        if numbers[0] < numbers[1]:\n            numbers.append(numbers[1])\n        else:\n             numbers.append(numbers[0])\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i > n:\n            rolling_max(numbers[i-1], numbers[i+1])\n    return numbers\nI'd just do\nrolling_max = lambda x: max(x for x in numbers)\n\nThis is the Python way. This is why I love Python.\n\nThis is why I love Perl.\n\nI don't know why you're being downvoted. Perl has a very similar syntax for this.\n\nIt's because Perl is \"evil\" and Python is \"good\".\n\nNo, it's because Perl is a mess of a language, and Python is elegant and simple.\n\nWell, I don't know about you, but I find Python to be a mess of a language, and Perl to be elegant and simple.\n\nI would love to see a discussion of what you find to be a mess in python.\n\nI was being sarcastic. I actually like Python.\n\nAh, well that went over my head.\n\nIs it just me, or does this look a lot like the Lisp definition of a", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        max = numbers[i]\n        if max > rolling_max(max):\n            numbers[i] = max\n    return numbers\n\nThis is not a very good example, but I see it over and over again.\nThe problem is that the rolling_max function does not do what you think it does. It doesn't return the maximum element in the list, it returns the maximum element that has not yet been seen.\nSo the above example is equivalent to:\n>>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 4, 4]\n>>> rolling_max([1, 2, 3, 4, 4])\n[3, 4]\n\nThanks, I didn't know that.\n\nIt's a common mistake. It took me a while to understand it. I think it's because of the name.\n\nThe Python documentation for the max function says:\n_\"The returned value is the largest value in the sequence that has not yet been seen. If", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        numbers.append(rolling_max(i))\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for number in numbers:\n        if number < rolling_max(number - 1):\n            rolling_max(number - 1) = number\n    return numbers\n\nThis is probably the most common way to write this.\nAnother way to do it is to write a function that takes a function f as an argument and returns a function that returns a rolling maximum.\n\nHow does this compare to the \"rolling_max\" function in the post?\n\nIt doesn't.\n\nThis is a pretty neat trick, but in my experience it is better to use a library for this. The standard library has a function for this, and it's pretty easy to write your own.\n\nThe standard library function is nice, but it can only be used on lists. This is a function that can be used on any iterable.\n\nFor those who don't know, iterable is a Python 2.5+ keyword for anything that can be iterated over.\n\nThis is a nice trick. I've always used this:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    def rolling_max_from_end(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_from_end([1, 2, 3, 2, 3, 4, 2, 3, 3, 4])\n    [1, 4, 4, 3, 3, 4, 4, 3, 3, 4]\n    \"\"\"\n    def rolling_max_from_beginning(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_from_beginning([1, 2, 3, 2, 3, 4, 2, 3, 3, 4])\n    [1, 4, 4, 3, 3, 4, 4, 3, 3, 4]\n    \"\"\"\n    return rolling_max(numbers), rolling_max_", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(numbers.size):\n        if i > rolling_max[i-1]:\n           numbers.append(i)\n    return numbers\n\nThis is a nice little trick, but it seems like it should be a method on the list class rather than a new class.\n\nThat's what I thought, and I was hoping to see the code.\n\nI'll go a step further and say that this is a bad idea, and the way Python does it is better.\n\nI'm not sure I understand why you think it's a bad idea. It seems to me that it's a perfectly reasonable way to define a class with a method.\n\nI think that the author's goal was to show the use of the `from typing import List, Tuple` idiom, but the real takeaway is that you should use a list comprehension.\n\nNo, the real takeaway is that you can do this kind of thing in Python.\n\nThat's not a real takeaway, that's a trivia point.\n\nI've used this trick before, but for a slightly different purpose. I was", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i < n:\n             numbers.remove(i)\n              if i + 1 < n:\n                   numbers.add(i)\n                   if i > n:\n                       numbers.remove(i)\n                       if i - 1 < n:\n                         numbers.add(i)\n    return numbers\n\nI don't understand what this is doing. It seems to be removing any element less than the given number and adding any element greater than the given number. Is that right?\n\nYes. It's not quite as bad as it", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i > n:\n            numbers.append(i)\n             rolling_max(numbers)\n    return numbers\n\nThe code is very simple, and I'm sure there are better ways to do it, but it's a good example of the power of Python.\n\nThat's not very good. In python, you should write the code you want to write, and then try to make it as fast as possible.\n\nIt's a good example of the power of Python, not the best way to do it.\n\nI don't see how this is a good example of the power of Python. It's just a simple function.\n\nThat's because you're not a Python newbie.\n\nI'm not a Python newbie. I've been using Python for over 5 years.\n\nI'm sorry. I didn't mean to say that you were a newbie. I meant that the OP was a newbie.\n\nI'm not a Python newbie, either.\n\nI think he's", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    n = 0\n    while n < len(numbers):\n        if numbers[n] > n:\n            n += 1\n    return Tuple(n, numbers)\n\nThis is not a bad solution, but it doesn't handle the case where the sequence is empty. A better solution would be to use a generator expression.\n>>> rolling_max(lambda x: x + 1 for x in [1, 2, 3, 2, 3, 4, 2])\n[1, 2, 3, 3, 3, 4, 4]\n\nI don't know if it's a good idea to use a generator expression in a production program.\n\nI think it is. It's a very common idiom in Python.\n\nIt is a common idiom in Python, but I'm not sure if it's a good idea.\n\nI'm not sure what the problem with generators is. They're just functions.\n\nBut generators don't have a return type.\n\nThey do have a return type. It's just not always easy to determine.\n\nBut you can't", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in range(numbers.size()):\n        numbers.pop(0)\n        numbers[i] = numbers[i] + 1\n    return numbers\n\nThere is a Python function for this, it's called \"max\"\n\nI'm pretty sure this is the best answer.\n\nI would have to agree. The Python function max is very well documented.\n\nI'd have to disagree. The Python max function is very well documented.\n\nI would have to agree. The Python function max is very well documented.\n\nI'm pretty sure this is the best answer.\n\nI would have to disagree. The Python max function is very well documented.\n\nI would have to agree. The Python function max is very well documented.\n\nI'd have to disagree. The Python max function is very well documented.\n\nI would have to agree. The Python function max is very well documented.\n\nI'm pretty sure this is the best answer.\n\nI would have to disagree. The Python max function is very well documented.\n\nI would have to", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i < n:\n           rolling_max(numbers[i], numbers[i + 1])\n    return numbers\n\nI wonder if there is a way to use this to generate a rolling_max list for any given list of integers.\n\nThe rolling_max function would have to be modified to return a list of tuples instead of a list of lists.\n\nI don't think so. Rolling_max returns a list of tuples, but it has to be a list of lists. It's a function that takes a list of integers and returns a list of integers.\n\nYeah, that was my point. The list of tuples is a list of lists.\n\nThe example is a bit silly. Why would you ever want to generate a list of tuples?\n\nIt's a way of showing off the use of the Tuple class, which is new in Python 2.6.\n\nI find the use of the Tuple class in the example a bit contrived.\n\nThe example is contrived, but it's a contrived example of something that", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(1, len(numbers)):\n        numbers.append(i)\n        rolling_max(numbers[-1])\n    return numbers", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(0, len(numbers)):\n        numbers.append(numbers[i])\n        rolling_max = []\n        for i in range(len(numbers)):\n           rolling_max.append(numbers[i])\n           if numbers[i] > numbers[rolling_max[-1]]:\n               numbers[rolling_max[-1]] = numbers[i]\n    return rolling_max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return (numbers.max() for n in numbers if n > rolling_max(numbers[n]))\n\nFor a more readable version:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        max = i\n        if max == n:\n            return max\n            if max > n:\n                 max = max - n\n                 if max < 0:\n                     max = -max\n                   if max == 0:\n                       return max\n                    return numbers\n\nI would suggest \"rolling_max(numbers) -> Tuple[int]\". The only reason to use a list is if the number of elements is not known beforehand.\n\nI would suggest \"rolling_max(numbers: List", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if numbers:\n       return numbers\n    elif len(numbers):\n       return numbers[:len(numbers)]\n    elif len(numbers) > 1:\n       return numbers[0]\n\nI think the point was to demonstrate the use of the tuples, not the fact that he could write a better version of rolling_max in a few lines of python.\n\nI don't think that's the point. The point is that the python code is very verbose and hard to read.\n\nIt's not that bad.\n\nI'm not saying it's bad, I'm saying it's verbose. It's not a very good example of why you should use tuples.\n\nIt's an example of what you can do with tuples.\n\nIt's an example of what you can do with tuples, but not an example of why you should use tuples.\n\nIt is an example of why you should use tuples.\n\nNo, it's not.\n\nYes, it is.\n\nI can't tell if you're trolling or", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    return numbers.filter(number > n).max()\n\nIf you're trying to show off Python, why not show off a good library like itertools?\nfrom itertools import permutations\nnumbers = permutations(range(5))\nrolling_max = permutations.max(numbers)\n\nThat's a good one, too. I like to use the built-in functions as much as possible, though.\n\nIn that case, I'd go with a list comprehension:\nnumbers = [x for x in numbers if x > n]\nrolling_max = max(x for x in numbers)\n\n\"from typing import List, Tuple\"\n\nI like this. I'm not sure if it's the best way to do it, but it's pretty good.\n\nI'd do it this way:\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    while True:\n        numbers.append(rolling_max(numbers[-1]))\n    return numbers\n\nI'm not sure what's the point.\n\nThe point is that it's a very simple way to generate a sequence of rolling maxima.\n\nHow is this any simpler than just rolling the max on each element?\n\nIt's a way to generate a sequence of rolling maxima, not a single one.\n\nThe list comprehension is simpler.\n\nNot really. The comprehension is harder to read and doesn't explain what the function does.</s>", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    if len(numbers) == 0:\n       return [1]\n    else:\n       return [rolling_max(i) for i in numbers if i % 2 == 0]", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in numbers:\n        if i > numbers[-1]:\n            numbers[i] = i\n    return numbers\n\nI would have used a set.\n\nI would have used a dictionary.\n\nI would have used a hash table.\n\nI would have used a hash map.\n\nI would have used an array.\n\nI would have used a linked list.\n\nI would have used a binary tree.\n\nI would have used a b-tree.\n\nI would have used a red-black tree.\n\nI would have used a trie.\n\nI would have used a skip list.\n\nI would have used a binary search tree.\n\nI would have used a bloom filter.\n\nI would have used a self-balancing binary search tree.\n\nI would have used a red-black tree.\n\nI would have used a self-balancing binary search tree.\n\nI would have used a radix tree.\n\nI would have used a splay tree.\n\nI would", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n        max = numbers[i]\n        rolling_max = rolling_max(numbers[i])\n        numbers[i] = rolling_max\n    return rolling_max", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in numbers:\n       if i % 2 == 0:\n           numbers.append(i)\n           rolling_max(numbers)\n\nI'm not sure I understand what this is supposed to do.\n\nIt generates a list of all the elements in a list up to the given element, but only if it is not a multiple of 2.\n\nThanks. I was wondering if that was it, but it's a bit of a weird definition. I would have expected something like", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    for i in range(numbers.length):\n        if i < n:\n           numbers.remove(i)\n            numbers = numbers.pop(0)\n             i += 1\n    return numbers\n\nI don't understand why this is interesting.\n\nIt's interesting because it's so simple, and it's a good example of the fact that simple things can be beautiful and useful.\n\nI suppose that's true. I've just never been a big fan of the rolling-max algorithm.\n\nI didn't know that the Python standard library had a rolling-max. I've always just used this one:", "from typing import List, Tuple\n\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i in numbers:\n        if numbers[i] > numbers[rolling_max(i)]:\n            numbers[i] = numbers[rolling_max(i)]\n    return numbers\n\nI'm not sure what the point of this is. What is it meant to accomplish?\n\nI think the idea is to make a rolling-max algorithm that works in list context.\n\nRight, but it's still not clear what the purpose of the algorithm is.\n\nI'm not sure what the point of this is. What is it meant to accomplish?\n\nI think the idea is to make a rolling-max algorithm that works in list context.\n\nRight, but it's still not clear what the purpose of the algorithm is.\n\nIt's a fun little problem to solve.\n\nNo it isn't. It's a pointless problem to solve.\n\nI don't see how it's pointless.\n\nI don't see how it's fun.\n\nI don't see how it's pointless.\n\nI don't see how it's fun"]]