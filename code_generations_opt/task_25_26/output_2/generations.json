[["from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n           return []\n        if i % n == 0:\n           return []\n    return [i*i for i in range(n)]\n\nThis is a bad example, because it's a simple one-liner that doesn't illustrate any of the problems with the Python syntax.\n\nPython:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n+1):\n        if i % n == 0:\n           return [i]\n        else:\n           return [i*i for i in range(n)]\n\nThis is nice, but it could be improved.\nIt is not clear that this is the best algorithm to solve the problem.\nFor example, if you want to factorize the number 70, you might be tempted to try this:\nfor i in range(1, n+1):", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(n):\n       if n % i == 0:\n          return []\n       return [i] * (i + 1)\n\nI prefer the Haskell version:\n\nn `div` (p*q) == (p `mod` n) `div` q\n\nAs a bonus, it's not Python.\n\nI prefer the Ruby version:\n\nn.factors.sort.map{|i| i * i + 1}\n\nI prefer the Perl version:\n\nmy @factors = (1..n).comb;", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [0] * (n - 1)\n\nI've never seen that syntax before. Is that a Pythonism?\n\nI don't know if it's Pythonism, but I've seen it in at least one other Python program.\n\nIt's not a pythonism. It's a common mathematical notation.\n\nI'm not sure what you mean. That notation is not common in mathematics.\n\nIt's a standard notation for a list of prime factors.\n\nIn what field?\n\nIt's standard notation for a list of prime factors of a number in a ring.\n\nThat's not a field.\n\nIt's also standard notation for a list of prime factors of a number in a field.\n\nIt's not a standard notation.\n\nI don't know what you mean. That notation is not standard in mathematics.\n\nI'm not sure what you mean. That notation is not common in mathematics.\n\nI'm not sure what you mean. That notation is not common in mathematics.\n\nI'm not sure what you mean. That notation is not common in mathematics.\n\nI'm not sure what you mean. That notation is not common in mathematics.", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n - 2):\n        if n % i == 0:\n            return i\n       else:\n            return List(i)\n\nThis is what I was looking for. Thanks.\n\nI'm glad you found it useful.\n\nI'm glad you were glad he found it useful.\n\nI'm glad you were glad he was glad he found it useful.\n\nI'm glad you were glad he was glad he was glad he found it useful.\n\nI'm glad you were glad he was glad he was glad he was glad he found it useful.\n\nI'm glad you were glad he was glad he was glad he was glad he was glad he found it useful.\n\nI'm glad you were glad he was glad he was glad he was glad he was glad he found it useful.\n\nI'm glad you were glad he was glad he was glad he was glad he was glad he found it useful.\n\nI'm glad you were glad he was glad he was glad he was glad he was", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n        return [1]\n    else:\n        return [n] * [n - 1] * [n - 2] * [n - 3] *... * [n - (n - 1) / 2]\n    if n == 0:\n        return [1]\n    else:\n        return [n]\n\nI've been trying to get a grasp of functional programming and I've been reading \"The Little Schemer\" and \"The Seasoned Schemer\" (both by Daniel P. Friedman, which I recommend). I've also been looking at some of the other books in the series.\nI'm a little confused as to why this is a big deal. It seems like the code is doing exactly what it's supposed to do. Can someone explain?\n\nIt's just a nice way to get a list of primes in a certain range. You can also do it with a loop or a generator function or some other way, but it's not as elegant as this.\n\nThe elegance of the code", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n           return []\n        else:\n            return [i]\n\nI find it interesting that the author has chosen to import List, but not Function or FunctionCall.\n\nI think he wanted to be able to call it as factorize(n) and not factorize(n,...)\n\nI don't know about Python, but in Ruby you can write a method that takes a block as its first argument and returns a list of the results of the block.\n\nYou can do that in Python too, but it's not idiomatic.\n\nIt's idiomatic in Python to use functions for loops and if statements?\n\nNo, but it's idiomatic to use functions for building lists.\n\nThis is a very cool hack, but I'd rather use the built in prime_factors function.\n>>> from itertools import isprime, factorize\n>>> isprime(25)\nTrue\n>>> factorize(25)\n[5", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if n % i == 0:\n          return i\n    return List(i)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n for n in range(2, n+1)]\n\nThis is interesting.\nI think you could make it much more efficient by using a better algorithm, though.\n\nI think it is not that bad. It is not really optimized for efficiency, but for readability. I'm open to suggestions though.\n\nThe readability is indeed good, but I'd say the performance is poor.\n\nThere is an obvious inefficiency, but I'm not sure what it is.\n\nThe obvious inefficiency is that you are computing the list twice. If you iterate over the numbers and store the primes in a map, you can get the prime factors in O(n) time.\n\nI don't see how that would work. You can't iterate over the numbers, because they are not in any order.\n\nYou don't need to iterate over the numbers. Just iterate over the primes and map them to the numbers.\n\nI don't see how that would work either. You can't iterate over the primes, because they are not in any order.\n\nWhat do you mean they are not in any order? The numbers are in order.", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n / 2 for n in xrange(n)]\n\nfrom typing import *", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    for i in range(2, n+1):\n        if n % i == 0:\n           return [i]\n           n /= i\n    return [i*i for i in range(n)]\n\nfrom typing import List\n\n    def factorize(n: int):\n        \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n        Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n        Input number should be equal to the product of all factors\n        >>> factorize(8)\n           [2, 2, 2]\n           >>> factorize(25)\n           [5, 5]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n       return [1]\n    return [n] * [n]\n\n>>> factorize(8)\n[2, 2, 2]\n>>> factorize(25)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [2 if n % 2 == 0 else n for n in range(2, n+1) if n % 2 == 0 else n for n in range(n+1, n+2) if n % 2 == 0 else n for n in range(n+2, n+3)]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if n%i == 0:\n          return []\n          if i % n == 0:\n            return [i]\n           if i == 0:\n             return [i*i for i in range(n-1)]\n    return [i*i for i in range(n-1)]\n\nI'd like to know more about this. I'm not a programmer.\n\nIt's a python program that takes an integer n and returns a list of the prime factors of n. The first two lines of the program are:\nfrom typing import List\nThe \"from typing import List\" line is importing a function from the standard library that is used to define the type of the variables in the program. This is a common idiom in Python.\nThe next line, \"def factorize(n: int)\" is defining a function that takes an integer n and returns a list of the", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [x * x for x in range(n)]\n\nI'm not sure if you're being serious, but this is a bad idea.\n\nIt's a joke.\n\nIn that case, it's a very good one.\n\nI think I'll be using it anyway.\n\nI'm not sure if you're being serious, but this is a bad idea.\n\nI'm not sure if you're being serious, but this is a bad idea.\n\nIt's a joke.\n\nIn that case, it's a very good one.\n\nI think I'll be using it anyway.\n\nI'm not sure if you're being serious, but this is a bad idea.\n\nIt's a joke.\n\nIn that case, it's a very good one.\n\nI think I'll be using it anyway.\n\nI'm not sure if you're being serious, but this is a bad idea.\n\nIt's a joke.\n\nIn that case, it's a very good one.\n\nI think I'll be using it anyway.\n\nI'm not sure if you're being serious, but this is a bad idea.", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n if n % 2 == 0 else 0 for n in range(2, n) if n % 2 == 0 else 0 for n in range(n, n+1) if n % 2 == 0 else 0 for n in range(n+1, n+2) if n % 2 == 0 else 0 for n in range(n+2, n+3) if n % 2 == 0 else 0 for n in range(n+3, n+4) if n % 2 == 0 else 0 for n in range(n+4, n+5) if n % 2 == 0 else 0 for n in range(n+5, n+6) if n % 2 == 0 else 0 for n in range(n+6, n+7) if n % 2 == 0 else 0 for n in range(n+7, n+8) if n % 2 == 0 else 0 for n in range(n+8, n+9) if n % 2 == 0 else 0 for n in range(n+9, n+10) if n % 2 == 0 else 0 for n in range(n+10, n+11) if n %", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if n % i == 0:\n          return List(i)\n      else:\n          return List(factors(i, n))\n\nThis isn't the most efficient algorithm, but I think it's a good one to start with. The only trick is that you need to keep track of what factors you've already calculated.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    if n == 0:\n        return []\n    else:\n        for i in range(2, n):\n           if i%2 == 1:\n               return [i]\n          else:\n               return [i*i for i in range(n - i)]\n    return list(factorial(n))</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    for factor in List[int]:\n        if factor == n:\n           return factor\n        if factor == 1:\n            return List(1)\n        if factor == 2:\n            return List(2)\n        if factor == 3:\n            return List(3)\n        if factor == 5:\n            return List(5)\n        if factor == 7:\n            return List(7)\n        if factor == 11:\n            return List(11)\n        if factor == 13:\n            return List(13)\n        if", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(n):\n       if i % n == 0:\n          return List[i]\n       else:\n          return List[i * i for i in range(n)]\n\nThis is a perfect example of what is wrong with python.\n\nIf you have a problem with it, what's wrong with it?\n\nIt's a one-liner that does not do what it claims.\nIt's a one-liner that does not do what it claims.\nIt's a one-liner that does not do what it claims.\nIt's a one-liner that does not do what it claims.\n\nIt's a one-liner that does exactly what it claims.\n\nThat's a pretty stupid thing to say. You are essentially saying that the only thing that matters is the syntax, and that the semantics are irrelevant.\n\nThe semantics are irrelevant to the one-liner. If you want to factor a number, you don't need to know how it works, just that it does.\n\nThe point is that the one-liner is", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n        return [n]\n    else:\n        return [n * factor(n - 1)]\n\nThe only thing I don't like about this is that it doesn't do the full job.\n\nI don't understand why you're getting downvoted. You're right. This is a nice solution, but it's not a full solution.\n\nI don't understand either. If you have a list of numbers and want to find their prime factors, there's no need to only return the first two.\n\nI think the author of the post was only trying to show how to factorize integers in python. He was not trying to write a full-featured library.\n\nYes, that's what I was trying to say.\n\nI don't think that's the only way to factorize integers in python.\n\nYes, I know. I was just trying to show one way.\n\nThis is a nice solution, but it doesn't do the full job.\n\nI don't understand why you're getting downvoted. You're right. This is a nice solution", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    n = int(input(''))\n    return List(n, 1)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if i % n == 0:\n          return List[i]\n    return []\n\nThis is interesting. I'd like to see a python implementation of this. I wonder how you'd do it without a lot of string manipulation.\n\nIt's not that hard. In fact, I'd say it's the easiest way to do it.\n\nI wouldn't call it the easiest, but it is certainly one of the easiest.\n\nI guess I'm not sure what you mean by \"easiest\". It's certainly the most obvious way to do it.\n\nI don't know why you're being downvoted. It's a perfectly reasonable question.\n\nI'm not sure why I'm being downvoted either. I'm trying to have a conversation about this.\n\nHere's my implementation, it's not as pretty but it's pretty readable and it uses a list comprehension for the loop.", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    for i in range(2, n - 1):\n        if n % i == 0:\n             return [i]\n         else:\n             return [n % i] * i\n    return List(factors)\n\nI've been thinking of making a Python module for factorization of any given number.\nI was thinking of a recursive function that would call itself recursively with a smaller and smaller input until it finds a prime factor.\nThe function would return a tuple containing the prime factor and the number of times it appears.\nThis would be a very powerful tool for testing for prime numbers.\n\nThat's the standard way to do it, though it's not that useful to test for prime numbers.\n\nHow is it not useful to test for prime numbers?\n\nBecause you can just test if the number is divisible by any number less than n.\n\nI see.\nIt seems to me that testing", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for n in range(2, n+1):\n        if n % 2 == 0:\n           return List(n)\n    else:\n           return List(factorize(n-1))\n\nIf you're going to use it, I recommend at least writing the function so that it's more obvious what it does.\n\nI agree. I think it should be:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    if n == 0:\n        return []\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1, 2]\n    if n == 3:\n        return [2, 3]\n    if n == 4:\n        return [1, 2, 3]\n    if n == 5:\n        return [1, 2, 3, 5]\n    if n == 6:\n        return [1, 2, 3, 5, 7]\n    if n == 7:\n        return [1, 2, 3, 5, 7, 11]\n    if n == 8:\n        return [1, 2, 3, 5, 7, 11, 13]\n    if n == 9:\n        return [1, 2, 3,", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n+1):\n       if n % i == 0:\n          return i\n       else:\n          if i == n:\n              return List(i)\n       else:\n             return List(i+1)\n\nI always wonder why people do this, instead of just using a list comprehension.\n\nIt's not immediately clear to me why this is a bad practice.\n\nIt's not a bad practice. It's just that a list comprehension is clearer and more readable.\n\nI'm not sure I agree, but I'm not sure I disagree. I think it's the same readability as in the following:\nfor i in range(2, n+1):", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if n % i == 0:\n          return [i]\n          else:\n           return [i, i * i for i in range(n - 1)]\n    return [i]\n\nNice!\n\nThanks, I'm glad you liked it :)</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if i % n == 0:\n          return List(i)\n    return List(i for i in range(n - 1, i + 1))\n\nThe author of the article should have known that \"import\" is Pythonic and not C-like.\n\nI disagree, the fact that it is pythonic doesn't mean it's a good idea.\n\nI agree with you. I have no idea why the author of the article would do that.\n\nI think the author was making a point about Python not being a \"real\" language.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1, 2]\n    if n == 3:\n        return [1, 2, 3]\n    if n == 4:\n        return [1, 2, 3, 4]\n    if n == 5:\n        return [1, 2, 3, 4, 5]\n    if n == 6:\n        return [1, 2, 3, 4, 5, 6]\n    if n == 7:\n        return [1, 2, 3, 4, 5, 6, 7]\n    if n == 8:\n        return [1, 2, 3, 4, 5, 6, 7, 8]\n    if n == 9:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n - 1):\n        if n % i == 0:\n           return List[i]\n        else:\n           return [i]\n\nThis is the same code as in the article.\n\nI don't get it. What's the point of this?\n\nThe point is that Python is a language that can be used to write code that is easy to read, write, and maintain.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n+1):\n       if n % i == 0:\n          return i\n    return List(i)\n\nThanks for sharing. I'm always a bit disappointed when I see code that uses a non-standard library and doesn't have a license or copyright notice. I'm not saying it's bad to use non-standard libraries, just that it's good to have a notice saying so.\n\nI'm not the OP, but I'm pretty sure this is MIT licensed:\n\nYes, it is MIT.\n\nI'm still not convinced that this is the most efficient way to do this.\nI wrote a simple C program to do the same thing, and it only takes about 1.5 seconds to factorize 1,000,000.\n\nThe Python code is not particularly efficient, but it's also not particularly slow. The C version is much faster, but it's also much uglier.\n\nI don't think it's ugly at all. It's not the most efficient, but it's not ugly.\n\nThe C version is also not particularly ugly, but it", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for factor in range(1, n):\n        if n == factor:\n           return [factor]\n        else:\n           return List(factors[0], factors[1], factors[2])\n    return List(1, 2, 3)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n        if i % n == 0:\n           return [i]\n       else:\n           return [i, i % n]\n\nI like this one better:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n       return []\n    else:\n       for i in range(1, n - 1):\n          if n % i == 0:\n             return [i]\n             else:\n              return [i * n for i in range(i + 1, n)]\n    return [0]*List(n)\n\n>>> factorize(8)\n[2, 2, 2]\n>>> factorize(25)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n       return [1]\n    else:\n       return [factors(n - 1) for factors in range(2, n + 1)]\n    if n == 2:\n       return [1, 1]\n    else:\n       return [factors(n - 1) for factors in range(2, n + 1)]\n\nWhat does this do?\n\nI'm pretty sure it's a joke.\n\nWhy?\n\nBecause it's a one-liner that prints the list of prime factors of any number.\n\nThis is a classic case of a joke that's only funny to people who already know what it's about.\n\nI'm not a programmer, and I found it funny.\n\nI'm a programmer, and I found it funny.\n\nI'm not a programmer, and I found it funny.\n\nI'm a programmer, and I found it funny.\n\nI'm not a programmer, and I found it funny.\n\nI'm a programmer, and I found it funny.", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n] if n % p for p in range(2,n) else [n]\n\nI'm not sure I get what this is supposed to be. It's not a very good function, and it doesn't really do what it says it does.\n\nYou're right, it's not a good function, but it does exactly what it says it does:\n>>> factorize(8)\n[2, 2, 2]\n>>> factorize(25)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]\n\nThe function does what it says it does, but it's not very useful.\n\nWhat would be a useful function?\n\nThe one that returns the prime factors in the order of how many times they appear in the number, not the one that returns the prime factors in the order of how many times they appear in the factorization.\n\nI don't understand. You're saying you want the factors in the order of how many times they appear in the number, not the order of how many times they appear in the factorization?\n\nYes.\n\nI'm not sure I follow. Why would you want that", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return List(n * n for n in range(2, n + 1))\n\nI would not want to use that for the following reasons:\n1\\. The order is not guaranteed. It could be in ascending or descending order.\n2\\. The result of the for loop is not guaranteed to be a list.\n\n1\\. I agree.\n2\\. How could it not be a list?\n\nIt could be a tuple.\n\nThis is really neat, and it's really nice to see the implementation. It's not immediately obvious, though, that the first argument to the function is the number to be factored. It would be nice if the function signature was changed to:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    else:\n        return [n]\n\nYou're going to get a lot of these, so here's a response:\n\nI wrote a variation of this code for a problem in my combinatorics class. It works by repeatedly dividing the number by the prime factors until it's equal to 1, then returning the resulting list. It also doesn't take into account the case of 0.\n\nI'm a little surprised that the list isn't sorted.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if n % i == 0:\n          return []\n          return [i]\n\n>>> factorize(10)\n[2, 2]\n>>> factorize(25)\n[5, 5]\n>>> factorize(100)\n[2, 5, 7]\n\n>>> print(factorize(4))\n[2, 2, 2, 2]</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n + 1):\n        if n % i == 0:\n           return List(i)\n    return List(n)\n\nThis is not a good example of how to use list comprehensions. It would be much clearer if you replaced the for loop with a list comprehension:\n>>> from typing import List\n>>> factorize(8)\n[2, 2, 2]\n>>> factorize(25)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]\n\nI'm not sure I agree that this is a good example of how to use list comprehensions, either.\nThe original code is perfectly clear, and the comprehension obscures the fact that the numbers are being multiplied together.\n\nI agree. I think the comprehension is overkill here.\n\nThis is a good example of how to use list comprehensions.\n\nI think the comprehension is overkill here.\n\nI'm not sure I agree that this is a good example of how to use list comprehensions, either.\nThe original code is perfectly clear, and", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return [1]\n    else:\n        return [n for n in range(2, n + 1)]\n\nThis is a pretty good example of why you should always use the standard library, and not try to write your own code.\nThe standard library already has a function called factorize, that does exactly the same thing.\n\nThe author uses the same logic to show that they should use the standard library for everything else.\n\nI think the author is saying that if you're going to use a function that already exists, why not use the one that is in the standard library?\n\nI think he's saying that if you're going to use a function that already exists, why not use the one that is in the standard library?\n\nI think he's saying that if you're going to use a function that already exists, why not use the one that is in the standard library?\n\nI think he's saying that if you're going to use a function that already exists, why not use the one that is in the standard library?\n\nI think he's saying that if you're", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n] if n % 2 == 0 else List(n * (n - 1))\n\nI like it! It's a good example of a function that takes a lot of code to write and a lot of time to understand, but very little code to read and understand.\n\nI've been writing python for a few months now, but I still have no idea what this code is doing. Can someone explain?\n\nIt's a function that takes a number, and returns the list of prime factors of that number.\n\nI still don't get it. I know what a prime factor is, but how does it relate to the number 25?\n\nA prime factor is a number that can be multiplied by another number to get that number. For example, if I have a number, and I multiply it by 3, the result is the same number. If I multiply it by 5, the result is the same number. But if I multiply it by 7, the result is not the same number.\nIf I have a number, and I multiply it by itself, the result is the same number. But if I multiply it by itself again, the result is not the same number.\n\nThanks.", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n + 1):\n       if n % i == 0:\n          return [i]\n       else:\n          return [i, factor(n - i)]\n\nThis is an example of why you shouldn't use a list as a dictionary. If you have a list of lists of integers, and you want to get the smallest one, you have to iterate through the list, which is O(n), and you still have to test if it is the smallest one, which is O(n).\nIf you use a dictionary, you can get the smallest integer in O(1).\n\nI think the point of the example was to show that if you have a list of integers, you can get the prime factors in order with a single function call. You can do the same thing with a dictionary, but you have to know that the dictionary is a list of lists of integers, which is not always the case.\n\nI don't think the point of the example was to show that. The example was to show that you can get the factors", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if n%i == 0:\n          yield i\n    else:\n          if n % i == 1:\n              yield i\n    else:\n           if n % i == 2:\n               yield i\n    else:\n           if n % i == 3:\n               yield i\n    else:\n           if n % i == 4:\n               yield i\n    else:\n           if n % i == 5:\n               yield i\n    else:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n * (n - 1) for n in range(2, n) if n%2 == 0 else n for n in range(n+1, n+1)]\n\nfrom typing import List\n\n    def factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    return [n * (n - 1) for n in range(2, n) if n%2 == 0 else n for n in range(n+1, n+1)]\n\nThe first example is much more readable and is not prone to typos.", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(n):\n       if i % n == 0:\n          return [i]\n       else:\n          return [i * i for i in range(n)]\n    return [i]\n\nI like the idea of \"from typing import List\" but I think I would use a different name. Maybe from typing import ListLike.\n\nI think it is a good idea to have a way to implement something like List without having to use a list. It could be useful when you want to create a list-like object that is immutable, for example.\n\nI like it. It's a little bit like the \"from itertools import permutations\" idiom in Python.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [int(i) for i in range(2, n + 1)]\n\n>>> factorize(8)\n[2, 2, 2]\n>>> factorize(25)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]\n\nIf you're going to be using this a lot, you may want to consider using a type alias, like this:\n>>> from typing import List, int\n>>> factorize = int.List()\n>>> factorize(8)\n[2, 2, 2]\n>>> factorize(25)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]\n\nOr this:\n>>> from typing import List, int\n>>> factorize = List(int)\n>>> factorize(8)\n[2, 2, 2]\n>>> factorize(25)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]\n\nor this:\n>>> from typing import List, int\n>>> factorize = List(int)\n>>> factorize(8)\n[2, 2, 2]\n>>> factor", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    # If the number is even, then the list is empty\n    if n % 2 == 0:\n        return []\n    # If the number is odd, then the list is the product of all factors\n    if n % 2 == 1:\n        return List(n)\n\nThis is a good example of why I hate Python.\n\nThe author is clearly a beginner. I would be surprised if this code is used in production.\n\nYeah, that's the point. This code is the type of code you'd write when you're just starting out and not yet aware of all the best practices.\n\nI just wanted to add a little bit of background. I used python for a year and a half before I started programming in C# and I can tell you that I would have never written code like that.\n\nI'm not sure why you're being downvoted. I was a complete beginner when I started learning Python, and I never wrote code like this.\n\nI think it's because he's being downvoted for not liking Python.\n\nI think it's because he's being down", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n] if n % 2 == 0 else [n for n in range(n) if n % 2 == 0]\n\nThis is a pretty trivial implementation of a common problem, but it is nice to see that the language has a way to make this sort of thing easy.\n\nThis looks like an ideal use of the for loop.\n\nYes, but it's a very trivial use of the for loop.\n\nThe for loop is a pretty trivial construct, but it's nice to see that the language has a way to make this sort of thing easy.\n\nThe for loop is a pretty trivial construct, but it's nice to see that the language has a way to make this sort of thing easy.\n\nThe for loop is a pretty trivial construct, but it's nice to see that the language has a way to make this sort of thing easy.\n\nThe for loop is a pretty trivial construct, but it's nice to see that the language has a way to make this sort of thing easy.\n\nThe for loop is a pretty trivial construct, but it's nice to see that the language has a way to make this sort of thing easy.\n\nThe for loop is a pretty", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    else:\n        return [n ** 2 for n in range(2, n + 1)]\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n * 2 for n in range(2, n - 1)]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n           return []\n          return List(i)\n\nfrom typing import List\n\n    def factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n           return []", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if n % i == 0:\n          return [i]\n       else:\n          return [i for i in range(n - 1)]\n\nI'm not sure if this is the best way to do this. It doesn't seem to be a good way to learn the language, since it's not a typical problem that you encounter.\n\nThe point of the exercise is to show how to use the List class.\n\nI'm surprised this wasn't a submission of the \"Hello World\" program in Python.\n\nI'm not. It's a pretty stupid exercise. It's a little bit better than the \"make a program that prints 'Hello World'\", but it's still not a good way to learn a language.\n\nI'm not sure what you mean by \"a good way to learn a language.\" The goal of this exercise is to show how to use the List class.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    # loop through the list of numbers and find the ones that are factors\n    for factor in range(2, n + 1):\n        if n % factor == 0:\n           return [factor]\n           break\n    return [n]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if n % i == 0:\n          return [i]\n    return [i for i in range(2, n) if n % i == 0]\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n        if n % i == 0:\n            return []\n           if n % i == 1:\n               return [i]\n            if n % i == 2:\n               return [i, i]\n            if n % i == 3:\n                return [i, i, i]\n             if n % i == 4:\n                return [i, i, i, i]\n             if n % i == 5:\n                return [i, i, i, i, i]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n+1):\n        if n % i == 0:\n           return [i]\n       else:\n           return [i for i in range(i, n)]\n\nThis is what I would do:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(n):\n       for j in range(2):\n         if i % j == 0:\n              if i == j:\n                 return i\n                 return List()\n    return List(i)\n\nI think it would be easier to read if you changed the variable i to be the number itself (i = n)\n\nI don't get it, why does it return the number twice?\n\nBecause the first time through, you get the factors in the order of how many times they appear in the factorization, and the second time through, you get the factors in the order of how many times they appear in the original number.\n\nI think he's talking about the fact that if n=5, it returns [2,2,2,2,2]\n\nI think this is the most beautiful code I've ever seen.\n\nThis is a nice, simple example, but the", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    if n < 2:\n        return [1]\n    else:\n        return [n for n in range(2, n + 1)]\n\n>>> factorize(70)\n[2, 5, 7]\n>>> factorize(70)\n[2, 2, 2]\n>>> factorize(70)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]\n>>> factorize(70)\n[2, 2, 2]\n>>> factorize(70)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]\n>>> factorize(70)\n[2, 2, 2]\n>>> factorize(70)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]\n>>> factorize(70)\n[2, 2, 2]\n>>> factorize(70)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]\n>>> factorize(70)\n[2, 2, 2]\n>>> factorize", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n+1):\n       if n % i == 0:\n          return []\n          if i == 0:\n           return [n]\n          if n % i == 1:\n           return [i]\n          if i == 1:\n           return [n]\n    return [n]\n\nThe fact that this function is called \"factorize\" is pretty misleading, as it does not factorize integers.\n\nIt does factorize integers, it just doesn't do it in a way that you're expecting.\n\nThe definition of factorization is \"a process of dividing a polynomial by a nonzero constant, in which the resulting terms are the coefficients of the original polynomial\".\nThe definition of factoring is \"the process of finding the prime factors of a number\".\nThis function does not factorize integers, it factors", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n           return List(i)\n        else:\n           return List(n % i)\n\nI think I would prefer:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return List(n).filter(isprime).reverse()\n\nA few things:\n1\\. The title of the article is \"A simple approach to factorization\"\n2\\. The article is short and gives a simple solution.\n3\\. The title of the article is \"A simple approach to factorization\"\n4\\. The article is short and gives a simple solution.\n5\\. The title of the article is \"A simple approach to factorization\"\n6\\. The article is short and gives a simple solution.\n7\\. The title of the article is \"A simple approach to factorization\"\n8\\. The article is short and gives a simple solution.\n9\\. The title of the article is \"A simple approach to factorization\"\n10\\. The article is short and gives a simple solution.\n11\\. The title of the article is \"A simple approach to factorization\"\n12\\. The article is short and gives a simple solution.\n13\\. The title of the article is \"A simple approach to factorization\"\n14\\. The article is short and gives a simple solution.\n15\\. The title of the article is \"A simple approach to factorization\"\n16\\. The article is short", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(n):\n        if i%n == 0:\n           return [i]\n       else:\n           if i%n == 1:\n               return [i]\n       else:\n              return [i]\n\nWhat's the point?\n\nI am not sure. I am not the author.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n        if n % i == 0:\n           return List(i)\n    return List(i)\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n for n in range(2, n + 1)]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n for n in range(n, 2) if n % 2 == 0]\n\nimport itertools", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(n):\n        for j in range(1, i+1):\n           if j % i == 0:\n               return []\n               elif j == 0:\n                 return [i]\n                else:\n                 return [i, i+j]\n\nInteresting. I didn't know this was possible in python.\n\nThis is not the only way to do this, but it is the most readable.\n\nIt's also the only way to do this that's more than one line long.\n\nThe original post is two lines long.\n\nIt's one line long in Ruby:\nirb(main):002:0> (1..10).map(&:to_f).flat_map(&:to_i).each do", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    return [1 for i in range(n/2)] + [1 for i in range(n/2+1)] + [1 for i in range(n/2+2)] + [1 for i in range(n/2+3)] + [1 for i in range(n/2+4)] + [1 for i in range(n/2+5)] + [1 for i in range(n/2+6)]\n        [0]\n\nThis is the most beautiful thing I've seen all week.\n\nFrom the page:\n_\"I will not be responsible for any damage to your system or loss of data.\nYou use this code at your own risk.\"_\n\nI wonder if the author realizes that this code will only work on a 32-bit system.\n\nIt's written in Python, so it'll work on any system that has Python.\n\nI think he was referring to the fact that the author wrote the code to work with a 32-bit integer, not a 64-bit integer.\n\nI believe", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n           return [i]\n        if n % i == 1:\n           return [i]\n        if n % i == 2:\n           return [i]\n        if n % i == 3:\n           return [i]\n    return [i]\n\n>>> print(factorial(12))\n[1, 2, 3, 6, 10, 15, 20, 25, 36, 50, 120, 720, 1260, 2520]</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if n % i == 0:\n          return []\n          i = i / (n % i)\n          if i == 0:\n             return []\n            i = i * (n % i)\n           if i == 0:\n              return []\n    return List(i)\n\nThat's pretty cool. I'm not sure if I can think of any real-life applications for it, though.\n\nI've used it to verify that a number is prime.\n\nI'm curious: what would you use this for?\n\nI've used it to verify that a number is prime.\n\nI'm curious: what would you use this for?\n\nI've used it to verify that a number is prime.\n\nI'm curious: what would you use this for", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n < 1:\n        return []\n    if n == 1:\n        return [1]\n    else:\n        return [n % 2 for n in range(2, n)]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n       return []\n    else:\n       if n == 1:\n          return [1]\n       else:\n          return [n]\n       for factor in List(n):\n          if factor == 1:\n             return [factor]\n           else:\n              return factor\n\nI've seen this a few times, and I don't really understand why you'd use it. It's a trivial exercise to write the list comprehension:\nfactorize(n) = [n for n in range(2, n+1)]\nor the recursive function:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n * 2 for n in List(range(n, 2)) if n % 2 == 0]\n\nThis is the Python I want to see more of.\n\nNice. You should post it to the python reddit.\n\nIt's already been posted there.\n\nI think it's great, but it's not really Python. It's more like a dialect of Python.\n\nI think that's the point.\n\nIt's a nice piece of code, but I'm not sure if it belongs to the Python reddit.\n\nI think it's a great example of a clever piece of code that's short and simple. It's not really a \"pythonic\" way of doing things, but it's still a nice way of solving a problem.\n\nThe way I see it, there are two main reasons for having a subreddit.\n1) To have a place to discuss Python.\n2) To have a place to discuss things that are _about_ Python.\nI think it's a good example of the second.\n\nIt's not really about Python, it's about the implementation of a particular algorithm.\n\nIt's about a particular algorithm implemented in Python.", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n        if n % i == 0:\n           return List(i)\n        else:\n           return List(i) * List(i + 1)\n\nThis is a great example of why the import system is broken.\n\nI don't see what's broken about it. It's a simple and useful function, and it's not a very complex one either.\n\nI think the problem is that it is too simple and too useful.\n\nI think the problem is that it's a bad example. The problem with the import system is that it's hard to find the right imports.\n\nI have to agree. I think the problem is that the author didn't find the right imports.\n\nThat's a bit of a non-sequitur.\n\nI think the problem is that you didn't find the right import.\n\nI think the problem is that you didn't find the right import.\n\nI think the problem is that you didn't find the right import.\n\nI", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n       return []\n    else:\n       return [int(n) for n in range(n)]\n\nI don't understand why this is a problem.\n\nIt is not a problem, but it is a prime example of a code smell. The code is not readable.\n\nThat's debatable. It's readable enough to me.\n\nThe problem is that it's not just you that has to read the code.\n\nSo? I don't care if someone else has to read my code. I don't have to read theirs.\n\nYou may not care, but I do.\n\nThe code is still readable.\n\nI find the code extremely readable.\n\nIt's a subjective thing, I suppose.\n\nI'm sorry, but this is just stupid.\n\nI agree, the code is stupid.\n\nWhat is the problem?\n\nThe problem is that the code is not readable.\n\nI find the code readable.\n\nThat's debatable.\n\nI don't understand why this is a problem.\n\nIt is not a problem, but it is", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n[2, 2, 2]\n[5, 5]\n[2, 5, 7]\n\n[2, 5, 7]\n[2, 5, 7]\n[2, 5, 7]\n\n[5, 5]\n[2, 2, 2]\n[2, 2, 2]\n\n[5, 5]\n[5, 5]\n[5, 5]\n\n[5, 5]\n[5, 5]\n[5, 5]\n\n[2, 2, 2]\n[2, 2, 2]\n[2, 2, 2]\n\n[2, 2, 2]\n[2, 2, 2]\n[2, 2, 2]\n\n[2, 2, 2]\n[2, 2, 2]\n[2, 2, 2]\n\n[2, 2, 2]\n[2, 2, 2]\n[2, 2, 2]\n\n[2, 2, 2]\n[2, 2, 2]\n[2, 2, 2]\n\n[2, 2, 2]\n[2, 2, 2]\n[2, 2", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if n % i == 0:\n          return []\n       else:\n          return List(i)\n\nThat's the first time I've seen a def from typing.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n + 1):\n        if n % i == 0:\n           return List[i]\n    return List()\n\nThis is a great example of why you should use a library like \"numpy\" or \"pandas\" for numerical work.\n\nWhy?\n\nBecause it does all that for you and you don't have to write it.\n\nI am not sure why this is better than using a for loop.\n\nIt's not. It's just a toy example of using the \"list\" module.\n\nNo, it's not.\n\nThis is a bad example of why you should use typing.\n\nWhy?\n\nBecause it's not really type checking.\n\nWhy not?\n\nBecause it's checking that the list is a list, not that the elements are integers.\n\nWhy not?\n\nBecause it's checking that the list is a list, not that the elements are integers.\n\nWhy not?\n\nBecause it's checking that the list is a list, not that the elements are integers.\n\nWhy not?", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n+1):\n       if n % i == 0:\n          return [i]\n    return [i]\n\nfactorize(100)\n\n[2, 2, 2, 5, 5, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]\n\nfactorize(1000)\n\n[2, 2, 2, 5, 5, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]\n\nfactorize(10000)\n\n[2, 2, 2, 5, 5, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]\n\nfactorize(100000)\n\n[2, 2, 2, 5, 5, 7, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5]\n\nfactorize(1000000)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n < 2:\n       return List(2)\n    if n < 3:\n       return List(3)\n    if n < 5:\n       return List(5)\n    if n < 7:\n       return List(7)\n    if n < 11:\n       return List(11)\n    if n < 13:\n       return List(13)\n    if n < 17:\n       return List(17)\n    if n < 19:\n       return List(19)\n    if n < 23:\n       return List(23)\n    if n < 29:\n       return List(29)\n    if n < 31:\n       return List(31)\n    if n < 37:\n       return List(37)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n+1):\n       if n % i == 0:\n          return List(i)\n       i = i + 1\n    return List(i)\n\nI'm not sure if the name \"factorize\" is appropriate for this function. It's more like \"prime factors\" or \"prime factorization\" than \"factoring\".\n\nI agree, but I'm not sure what would be better.\n\nI'd go with 'prime_factors'\n\nI like this.\n\nIt's also called \"prime factorization\".\n\nThis is a nice little function, but it's not really doing what the name implies. It's returning a list of the factors of the input number, but it's not returning them in the order they occur in the input.\n\nThis is a very common problem in the real world.\n\nI don't see the problem here.\n\nThe name.\n\nThe name is a bit misleading, but I don't see a problem with it.\n\nI find this function to be really confusing.\n\nI", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [2]\n    if n == 3:\n        return [3]\n    if n == 4:\n        return [2, 2, 2]\n    if n == 5:\n        return [2, 5]\n    if n == 6:\n        return [2, 5, 7]\n    if n == 7:\n        return [2, 5, 7, 11]\n    return [n for n in range(1, n+1)]\n\nI like this. A lot.\n\nI don't. It's not even a one liner. It's a two liner.\n\nI would argue that it's a one-liner, because the entire function is one line.\n\nNot to mention it", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n] if n % 2 == 0 else [n, n * (n - 1)]\n\nThis is a great example of why you should use the Python standard library for things like this.\n\nThe author has a number of other examples of the same thing. I think he's trying to make a point.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    for i in range(1, n):\n        for j in range(i+1, n):\n           if i%j == 0:\n               return [i, j]\n    return [i]</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if n%i == 0:\n          return []\n       if n%i == 1:\n          return [i]\n       if n%i == 3:\n          return [i*i for i in range(n+1)]\n       if n%i == 5:\n          return [i for i in range(n+1)]\n    return List(range(n+1))</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    return [n * (n - 1) for n in range(2, n + 1)]\n\nThis is a good example of why you should always use a language that has native support for functional programming.\n\nPython does have native support for functional programming.\n\nReally? I thought it was imperative.\n\nPython supports functional programming as well as imperative programming, and this is not a bad thing.\n\nI can't believe this is on the front page.\n\nI can't believe it's not butter.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n           return List(i)\n    return List(i)\n\nList is a Python class. It's not a function.\n\nI know, it's a class. I just didn't want to make it too complicated.\n\nWhat's the point of this?\n\nI just wanted to have a list of prime factors of a given number.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    # loop over all numbers from 1 to n\n    for i in range(1, n):\n        if n % i == 0:\n            return []\n        # prime factorization\n        for j in range(1, n):\n             if n % j == 0:\n                 return [j]\n        return []\n\nI'm not sure what the point of this is. It's just a function that's a bit more verbose than the built-in one.\n\nIt's a good exercise in using generators and lambdas.\n\nI don't know about that. It's a good exercise in how to write a generator, sure, but there's no lambdas in there.\n\nThere's a lambda in the first for loop.\n\nLambda is a function. There is no function in that loop.\n\nI don't think we're talking about the same", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n        return [1]\n    else:\n        return [n for n in [2, 2, 2] if n % 2 == 0]\n\nOne of my favorite Python features.\n\nThis is a good example of why I think Python is a good language for teaching programming. It's simple, it's consistent, and it has a lot of features that make it easy to create small programs that are still very useful.\n\nI would say that this is a good example of why Python is a good language for teaching _a certain kind of programming_.\nI don't think it would be a good language for teaching a course on compiler construction, for instance.\n\nI'd say it's a great language for teaching how to write a compiler. It's just that the final result would be written in C.\n\nI would love to see a real compiler written in Python.\n\nI'm currently working on a Python to C compiler.\nIt's not a particularly big compiler, but it does support all the basic features.\nIt's written in Python (duh), and is _not_ a bootstra", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    result = []\n    for i in range(2, n):\n        result.append(i)\n    return result\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    for i in range(1, n):\n       if i % 2 == 0:\n          return [i]\n       else:\n          return [i, i*i, i*i*i]\n\nI don't think this is a good example.\nThe author of the code (in the blog post) is using a list comprehension instead of an explicit loop, which is a good thing.\nIt's better to use a list comprehension and get a better error message than to use an explicit loop and get a worse error message.\n\nA list comprehension is not the only way to write that code, and it is not the best way. It is the worst way to write that code, and it's a good example of how not to write Python.\n\nI'm not sure that's true. For example, the example given in the article is this:\n>>> a = 1\n>>> a\n1\n>>> a[0]\n1\n>>> a[1]\n1\n>>> a[2]\nTraceback (most recent call last):\nFile \"<", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    for i in range(n):\n        if i % n == 0:\n            return i\n        else:\n            return [i]\n\nThis is a really cool idea! I love it when people take a common problem and come up with a creative solution.\nI'm not sure it's better than the standard way of doing it (I'm not going to go into it here, but it's easy enough to find with Google), but it's certainly a lot easier to understand.\n\nIt's much better than the standard way of doing it, as it's more efficient and more accurate.\n\nIt's only more efficient if you're not using a computer.\n\nNot true. It's more efficient because it doesn't make a list of the numbers in the factorization. It makes a list of the factors. That's much more efficient.\n\nI'm not sure what you mean by \"efficient\" in this context. If you're saying that it's more efficient in terms of space usage, then you're wrong, because it's much easier", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    else:\n        return [int(n) for n in range(2, n+1)]\n\nI think this is an example of a case where the python code is easier to read. In fact, I think the python version is easier to read than the original C code.\n\nThe problem is not that it's hard to read, it's that it's hard to type. The Python version is a lot more typing.\n\nI don't know, I find it pretty easy to type\n>>> factorize(25) [5, 5]\n\nI think what the author is trying to say is that the Python version is more verbose than the C version, which is true.\n\nI don't think that's what he's saying. The C version is more verbose than the Python version. The Python version is just more typing.\n\nI agree with you, but I think you're missing the point. The C version is shorter than the Python version.\n\nI'm not missing the point. I'm saying that the Python version is more verbose than the C", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n         if n % i == 0:\n             return []\n         if n % i == 1:\n              return [i]\n        else:\n             return List(n % i)\n\nThis is an example of why I think Python is a terrible language for writing code.\nThis is a trivial algorithm that can be implemented in one line of C++:\nfor (int i = 2; i <= n; i++) {", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if n % i == 0:\n          return []\n       else:\n          return List(i)\n\nI think the point is that the author is using a library for doing something that could be done in one line of Python. The rest of the code is a demonstration of a way to do it.\n\nI can't help but think that the author is being a little facetious, with the implicit message being \"I can do this in one line of Python, and you should too\".\n\nI think he's being very facetious.\n\nI don't understand. I know this is a joke, but what is the joke?\n\nThe joke is that the author of the article is being facetious by demonstrating a simple task which could be accomplished in one line of Python, while the rest of the code is a demonstration of a way to do it.\n\nI don't get it.\n\nThe author is demonstrating that you can do this in one line of Python, and that you should do it that way.", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n        for j in range(1, n):\n           if n % i == 0:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if i % n == 0:\n          return []\n       return [i] * n\n\nThis is a great example of why you should use functions as much as possible, and only use classes when they are necessary.\n\nI disagree. The fact that this is a function is a code smell. This is a prime example of the lack of abstraction in Python.\n\nHow so? I think the problem is that the OP is trying to do something that is a lot more complicated than it needs to be.\n\nI agree. It's not a code smell, it's a symptom of a bigger problem.\n\nI'd argue that the code is a code smell, but the bigger problem is not the code.\n\nI think it's the other way around. The code is a symptom of a bigger problem.\n\nI would argue that the code is a symptom of a problem with the code.\n\nI would argue that the problem is not the code, but the problem with the code is the code.\n\nI would argue that the problem is the code,", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if n % i == 0:\n          return []\n          n = n / i\n    return [i for i in range(n)]\n\nThat's a good way to do it. I don't like how Python doesn't have the concept of a list of tuples, but I guess that's what dictionaries are for.\n\nYou could also use a list comprehension, like:\nl = [i for i in range(n) if n % i == 0]\n\nI'm not sure that the comprehension is any better than the original method, but it's certainly shorter.\n\nThis is a good example of the \"python is a language that doesn't really care about the order of operations\" thing.\n\nNo, it's not. Python does care about order of operations.\nPython just doesn't care about _side effects_, which is a very different thing.\n\nThe point is that there is no such thing as \"the order of operations\" in Python.\n\nThere is, it's just that the order", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n        if n % i == 0:\n           return []\n        else:\n           return [i] * n\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    result = []\n    for i in range(1, n):\n       for j in range(1, n):\n          if i % j == 0:\n              result.append(i)\n            else:\n              result.append(j)\n    return result\n\nThere are a couple of different ways to do this. I think the most obvious one is to make a list of the factors, and then use it to generate the list of the factors.\nThe other way is to use the list comprehension syntax, which I think is more readable.\n\nThe list comprehension is more readable, but it's not more readable _and_ more efficient.\n\nI don't understand why it's not more efficient.\n\nThe list comprehension is doing a lot of extra work. It's building a list of the factors, then iterating through it to generate the list of factors.\nThe other way is to just build a list of the factors, and then", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n * (n + 1) for n in range(2, n + 1)]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n+1):\n       if i % 2 == 0:\n          return [i]\n       else:\n          return [i, i+1]\n\n(This is very cute. I like it.)\n\nThat's a pretty cool trick. I'm wondering why you didn't use the built-in python range() function instead of the range() function defined in the standard library. I'm also wondering if this is more efficient than the built-in range().\n\nI didn't know about the built-in range() function. I just checked it out and it's pretty neat. It seems to be more efficient for small numbers, but I'm not sure about the performance of it for larger numbers.\n\nPython range() is a built-in function, not a standard library function.\n\nI know, but I thought it was part of the standard library.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if n % i == 0:\n          return List(i)\n    return List()\n\nDoesn't this just return a list of numbers?\n\nA list of prime numbers.\n\nAh, I see. I thought it was supposed to return a list of the prime factors of the number, but it returns a list of the primes themselves.\n\nThis is one of the most important lessons I have learned from Python. It's so easy to make a mistake, and so easy to introduce a bug, that I write unit tests for everything I do.\n\nI think you're right that it's a good idea to write unit tests, but I don't think this is a good example of that. It's not clear what the unit test should test.\nIt's also not clear that the code is buggy, or that the author made a mistake. Maybe the author intended to write a function that returns the prime factors of a number.\n\n>I think you're right that it's a good idea to write unit tests, but I don't think this is a good example", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(n):\n        if i == 0 or i == n:\n           return []\n           if i % n == 0:\n             return []\n            return List(i)\n\nYou may also want to use a generator for the list of factors.\n\nI think you mean list comprehension:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n           return []\n          else:\n           return [i]\n\nI'm not sure why you're using list here, you can just use a dict.\n\nI'm not sure why you're using an array there.\n\nI'm not sure why you're using a computer.\n\nI'm not sure why you're using Python.\n\nI'm not sure why you're using...\n\nI'm not sure why you're using...\n\nI'm not sure why you're using...\n\nI'm not sure why you're using...\n\nI'm not sure why you're using...\n\nI'm not sure why you're using...\n\nI'm not sure why you're using...\n\nI'm not sure why you're using...\n\nI'm not sure why you're using...\n\nI'm not sure why you're using...\n\nI'm not sure why you're using...\n\nI'm not sure why you", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n+1):\n        if n % i == 0:\n            return i\n           return List(n % i)\n\n>>> print(factorize(8))\n[2, 2, 2]\n>>> print(factorize(25))\n[5, 5]\n>>> print(factorize(70))\n[2, 5, 7]\n\n\"from typing import List\" is unnecessary.\n\nI don't know Python, but in other languages, the `from typing import List` would be necessary because Python would not know about the `List` type.\n\nPython has a built-in `list` type.\n\nI don't know Python, but in other languages, the `from typing import List` would be necessary because Python would not know about the `List` type.\n\nPython has a built-in `list` type.\n\nI don't know Python, but in other languages, the `from typing import List` would be necessary because Python would not know about the `List` type.", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for n in range(1, n+1):\n        if n % 2 == 0:\n           return [n % 2 for n in range(2, n+1)]\n        else:\n           return [n for n in range(2, n+1)]\n\nYou might want to try this instead:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if n % i == 0:\n          return List(i)\n    return List(i)\n\n>>> factorize(8)\n[2, 2, 2]\n>>> factorize(25)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    n = int(input(''))\n    return [n[0]*n[1] for n in range(n)]\n\n>>> print(factorize(8))\n[2, 2, 2]\n>>> print(factorize(25))\n[5, 5]\n>>> print(factorize(70))\n[2, 5, 7]\n\nYou could also use this to get the prime factors of a number:\n>>> print(factorize(25))[:2]\n[5, 5]\n>>> print(factorize(25))[2:]\n[2, 5, 7]\n\nand a small hack to get the primes:\n>>> print(factorize(25))[:2]\n[2, 5, 7]\n>>> print(factorize(25))[2:7]\n[2, 5, 7, 11]\n\nI like to use a variation of this to find the prime factors of a number, and then print the prime factors in the order of their size (so, the first prime factor is the smallest, and the last prime factor is the largest):", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n            return [i]\n    else:\n            return List(n / i for i in range(2, n))", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    result = []\n    for i in range(2, n):\n        if n % i == 0:\n            result.append(i)\n           break\n    return result\n\nI'm not sure if this is a joke or not, but I find it amusing.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [x for x in range(2, n + 1) if x % 2 == 0 for x in range(n)]\n\nfrom typing import List\n\n    def factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    return [x for x in range(2, n + 1) if x % 2 == 0 for x in range(n)]\n\nfrom typing import List\n\n    def factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        for j in range(2, i+1):\n           if n % i == 0:\n               return []\n                  if n % i == 1:\n                    return [j]\n    return List(factors(i), factors(j))</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n        if i % n == 0:\n           return [i]\n       else:\n           return [i * i for i in range(n - 1)]\n    return [i]\n\nThis is a bad example because the prime factors of 8 are 2, 2 and 2, so it should return [2, 2] and [2] (not [2, 2, 2]).\n\nI don't see why this is a bad example. The prime factors of 8 are 2, 2 and 2. That's what the program prints.\n\nThe author is pointing out that the program is wrong, because the prime factors of 8 are 2, 2, and 2.\n\nThe program is not wrong. The author is wrong.\n\nIt's not clear to me why the author is wrong. He's pointing out that the program should have returned [2, 2, 2] instead of [2, 2, 2, 2].\n\nThe program is not wrong. The author is wrong.", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        for j in range(2, n):\n           if (n % i == 0 and n % j == 0):\n               return List(i, j)\n    return List(i, n)\n\nThis is a very nice and simple solution.\n\nThanks for the comments. I was looking for a way to factorize an integer, and this solution came to my mind.\n\nThis is a great example of how to get a python solution to work with very little code. I wish there was a better way to share code snippets with the community.\n\nI like the way you refactored the code.\n\nThanks. I was looking for a way to factorize an integer, and this solution came to my mind.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n - 1):\n        if i % n == 0:\n           return [i]\n        else:\n           return [i * n for i in range(i * n + 1, n)]\n\n(Disclaimer: I am not a python expert, just a python enthusiast)\nI like this a lot. It's simple, elegant, and not obvious (at least to me).\n\nThanks!\n\nI always thought that was obvious.\n\nI think the code is a little verbose.", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    n = int(n)\n    for i in range(n):\n        if n % i == 0:\n           return List(i)\n        else:\n           return List(n % i)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if i % n == 0:\n           return List(i)\n        else:\n           return List(i * i)\n\nI was thinking that he would be using the python string type, but I guess he just doesn't like to use it.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n        if n % i == 0:\n           return []\n         else:\n            return [i, i * i for i in range(n + 1)]\n    return []\n\nfrom typing import List\n\n    def factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    for i in range(1, n):", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n < 2:\n       return []\n    else:\n       if n % 2 == 0:\n          return [n / 2 for n in range(2, n)]\n    else:\n          return [n % 2 for n in range(2, n)]\n\nThe function is not so good.\nIt breaks down when n is prime, which is not very surprising.\n\nI think it's a good example of why you shouldn't use functions with a lot of side effects in Python.\n\nSide effects? I don't see any.\n\nI think it's the \"return [n / 2 for n in range(2, n)]\". The range function has side effects.\n\nHow can a function have side effects?\n\nI guess I'm confused about what you mean by \"side effect\".\n\nI think he means that the function returns a list of items.\n\nI'm not sure what the \"problem\" is.\n\nI think he's saying that the function is broken because it breaks when given a prime number", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if i % n == 0:\n           return []\n        if i % n == 1:\n           return List(i)\n    return List(n)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n        if i == 0:\n            return [i]\n        else:\n            if i < n:\n                 return [i]\n        else:\n               if i == n - 1:\n                   return [i]\n        else:\n                 if i == n:\n                     return [i]\n    return [i]</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n + 1):\n        if n % i == 0:\n           return []\n           if i % n == 0:\n             return [i]\n            if n % i == 1:\n              return [i, i + 1]\n    return List(n % i for i in range(2, n + 1))", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [x for x in range(2, n)]\n\nI really like this. The way I see it, the problem is that the \"x\"s are just a list of integers, and the \"for x in range(2, n)\" is just a list comprehension.\n\nI think the point is that \"for x in range(2, n)\" is a generator, and \"x\" is an iterator.\n\nI'm still not sure I see the point.\n\nIt's a different way of thinking about the problem, and it's pretty cool.\n\nI think the point is that it is a list comprehension with a more verbose syntax.\n\nIt's a list comprehension with a more readable syntax. It's not more verbose, it's just that you're used to the shorter form.\n\nSo, how do you use this?\n\nIt's an exercise for the reader.\n\nThis is a good example of how Python's lack of syntax for iterators is a weakness.\n\nI don't think so. I'm not sure what you mean by \"syntax for iterators\".\n\nI think he means a way to say \"iterate over x in", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(n):\n        if i % n == 0:\n           return [i]\n        else:\n           return [i*i for i in range(n)]\n    return List(range(n))</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n for n in range(2, n) if n % 2 == 1]\n\nNow that's a pretty cool example. I'm not sure I'd have thought to use the fact that the number of times a factor appears in the factorization of n is equal to the number of times the factor appears in the list of factors.\n\nI think this is a very nice example.\nI think the author could have chosen a better name for the function, though. The \"factorize\" name is not very descriptive of what the function does, and it is not a word that is commonly used in mathematics.\n\nI thought the same thing, and the first thing I did was Google it.\n\nI don't understand why people are upvoting this. The code is not even correct.\n\nWhat is the correct way to implement it?\n\nYou have to be careful not to miss any primes, because they are what the algorithm is counting on to reduce the size of the list. So you have to check that the first number you are trying to factorize is not a multiple of 2.\nIf you miss a prime, you can get a list where every number is prime, so you have", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if i % n == 0:\n          return List(i)\n    else:\n          return List(i * i + 1 for i in range(n - i, 0, n - i))", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    result = []\n\n    for i in range(2, n + 1):\n        if n % i == 0:\n            result.append(i)\n            i = i + 1\n\n    return result", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    return [x for x in [2, 2, 2]]\n\nYou can do this in Python:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        for j in range(2, i):\n           if i % j == 0:\n                 factorize(j)\n                  return [i, j]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for factor in range(n):\n       for prime in range(2, n):\n         if prime not in factor:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if i % 2 == 1:\n            return [i]\n         else:\n            return [i for i in range(2, n - 1)]\n    return List()\n\nI think it's better to just use itertools.product\n\nThe code was not meant to be used in production. It was just an example of a \"trick\" I've used to get my head around Python. I wanted to show it to a colleague who knows nothing about Python and I wanted to show him how to factorize a number in Python.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n < 2:\n       return [1]\n    if n == 2:\n       return [1]\n    return [x*x for x in range(n) if x % n == 0]\n\nPython version:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n        if n % i == 0:\n            return [i]\n        else:\n            return [i, i+1]\n\nWhat are the advantages of this over the built-in prime factorization?\n\nI'm not sure if the built-in prime factorization is as fast as this one. The built-in one is O(n^2) which is definitely slower than O(n).\n\nThe built in one is O(n log n) which is much faster than O(n).\n\nWell, it's only a bit faster. The time complexity of the built in one is O(n log n) but the time complexity of this one is O(n) + O(n log n) since it does a bit more work than just factorizing the number.\n\nI agree. I think this is a good example of \"premature optimization\".\n\nI've been using this for a few days now. I like it better than the built in one because it", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n[0]*n[1]*...*n[n-1]]\n\n>>> import math\n>>> def factorial(n):\n    \"\"\" Return factorial of given number.\n    >>> factorial(10)\n    >>> factorial(100)\n    >>> factorial(1000)\n    >>> factorial(10,000)\n    >>> factorial(10,000,000)\n    >>> factorial(10^100)\n    >>> factorial(10^1000)\n    >>> factorial(10^10000)\n    >>> factorial(10^100000)\n    >>> factorial(10^100,000,000)\n    >>> factorial(10^100,000,000,000)\n    \"\"\"\n    return n**n\n\n>>> import math\n>>> def factorial(n):\n    \"\"\" Return factorial of given number.\n    >>> factorial(10)\n    >>> factorial(100)\n    >>> factorial(1000)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if n % i == 0:\n          return List(i)\n       return []\n\nThis is a great example of the power of functional programming. The code is more concise than its imperative counterpart, and it's also easier to understand.\n\nI don't think the imperative version is harder to understand. I think it's harder to write.\n\nI think it's easier to write.\n\nI think the imperative version is more concise.\n\nI think the imperative version is less concise.\n\nI think the imperative version is more concise.\n\nI think the imperative version is less concise.\n\nI think the imperative version is more concise.\n\nI think the imperative version is less concise.\n\nI think the imperative version is more concise.\n\nI think the imperative version is more concise.\n\nI think the imperative version is less concise.\n\nI think the imperative version is more concise.\n\nI think the imperative version is less concise.\n\nI think the imperative version is more concise.\n\nI think the imperative version is less", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    for factor in range(2, n+1):\n        if n % factor == 0:\n           return factor\n           return []\n    return List(factors(n))\n\nIt looks like the author is not familiar with the Python standard library.\nThe built-in function _factors_ is probably the best solution. It takes a number and returns a list of all prime factors.\n>>> import factorial\n>>> factorial(25)\n[5, 5, 25, 125, 625, 3125, 62500, 1, 4, 25, 125, 625, 3125, 62500, 1, 4, 25, 125, 625, 3125, 62500, 1, 4, 25, 125, 625, 3125, 62500, 1, 4, 25, 125, 625, 3125, 62500, 1, 4, 25, 125, 625, 3125, 62500, 1, 4, 25, 125, 625, 3125, 625", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n + 1):\n       if n % i == 0:\n         return [i]\n       if n % i == 1:\n         return [n]\n    return []\n\nI have been using this for a while and I really like it.\n\nI can't see why this is any more useful than simply doing:\nn = int(input( 'Enter an integer:'))\np = int(int(n))\nfor i in range(p):", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    else:\n        return [n for n in range(2, n+1)]\n\nYou can use a list comprehension to do this in a more readable way:\n>>> factorize(8)\n[2, 2, 2]\n>>> factorize(25)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]\n\nI've been seeing a lot of this lately. Is this the new way of writing Python? It seems like it's a lot more verbose and harder to read.\n\nNo, it's just a common idiom that's often easier to read than the equivalent list comprehension.\n\nIt's actually a list comprehension with a list comprehension inside of it.\n\nThat's one way to look at it, but it's also a list comprehension with a for loop inside of it.\n\nIt's a list comprehension with a list comprehension, a for loop, and a lambda.\n\nIt's a list comprehension with a list comprehension, a for loop, a lambda, a list comprehension, a lambda, and a", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n           return i\n          if n % i == 1:\n            return List(i)\n    return List(factors(n))\n\nThis is a pretty good implementation of the Euclidean algorithm for factoring numbers. I was expecting something like this to be at the top.\n\nI was expecting something more along the lines of", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n <= 2:\n        return [n]\n    else:\n        return [n] * [n - 1]\n\n>>> list(factorize(8))\n[2, 2, 2]\n>>> list(factorize(25))\n[5, 5]\n>>> list(factorize(70))\n[2, 5, 7]\n\nI like this:\n>>> list(factorial(10))\n[1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\n\nYou can also write it as:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n       return [1]\n    if n == 2:\n       return [1, 1]\n    if n == 3:\n       return [1, 2, 3]\n    if n == 4:\n       return [1, 2, 3, 4]\n    if n == 5:\n       return [1, 2, 3, 5]\n    if n == 6:\n       return [1, 2, 3, 5, 6]\n    if n == 7:\n       return [1, 2, 3, 5, 7, 8]\n    if n == 8:\n       return [1, 2, 3, 5, 7, 8, 9]\n    if n == 9:\n       return [1, 2, 3, 5, 7, 8, 9, 10]\n    return List()", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    factors = [None]\n    for i in range(1, n):\n        if n%i == 0:\n           factors.append(i)\n    return factors\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    n = int(n)\n\n    for i in range(2, n + 1):\n        if n % i == 0:\n           return []\n        elif n % i == 1:\n           return [i]\n        else:\n           return n % i\n\nThis is a good example of what is wrong with Python.\nPython is a very expressive language, but its expressiveness is abused by people who don't understand it.\nThe above code is a textbook example of a \"non-idiomatic\" Python program.\nIf you want to write code that reads like pseudocode, then Python is a great choice.\nBut if you want to write code that is fast, compact, and easy to maintain, then you should avoid things like the above code.\nThe correct way to write the above code is:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n + 1):\n        if n % i == 0:\n           return [i]\n        if n % i == 1:\n           return [i * i for i in range(n)]\n        if n % i == 2:\n           return [i * i * i for i in range(n)]\n        return []\n\nThis is a pretty terrible way to factorize a number. I don't know if it is the best way to do it, but I do know that it is not the best way to do it.\n\nIt's not terrible, it's just not the best way to do it.\n\nIf you want to see the best way to do it, you can look at:\n\nPython is a dynamic language, so it can't be compiled. But I think that the code in the article is the best that you can do with a dynamic language.\n\nI think the point of", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for n in range(1, n+1):\n        if n == 0:\n           return []\n        n *= 2\n        return List(n)\n\nThe article's example is a nice illustration of how to use a decorator.\n\nI was thinking of a different use case - I have a bunch of functions that are the same but have different parameters. I can factorize them and then write a decorator that does the same thing for all the functions.\n\nI had to look up \"decorator\" to see if that's what you meant. I was thinking of it more as a template.\n\nI think that's what he meant.\n\nI would use a function that returns a generator.\n\nYou mean like the generator functions in Python 2.7?\n\nYes.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n+1):\n        if n % i == 0:\n            return []\n        if n % i == 1:\n            return [i]\n        if n % i == 2:\n            return [i, i]\n    return [i*i for i in range(1, n+1)]\n\nI'm not sure why you wouldn't just use the built-in `factors` function.\n\nI think the OP is trying to say \"from typing import List; from math import factorial\"\n\nI'm not sure that's a good idea. It's a nice trick for quickly doing some calculations, but it doesn't teach you how to write a recursive function.\n\nI think the idea is to show how a list comprehension can be used to factorize an integer.\n\nThis is a cool trick. I'll have to try it out sometime.\n\nI think it's a cool trick", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [x**2 for x in range(n) if x % 2 == 0]\n\nI'm not sure what the point of this is.\n\nI'm not sure either, but I think it's a joke.\n\nI have no idea what the joke is.\n\nYou're not supposed to.\n\nI'm not sure if I'm supposed to laugh or not.\n\nYou are.\n\nI'm not sure if you're supposed to tell me I'm supposed to laugh or not.\n\nYou're not.\n\nI'm not sure if you're supposed to tell me I'm supposed to tell him he's supposed to laugh or not.\n\nYou're not.\n\nI'm not sure if you're supposed to tell me I'm not supposed to tell him he's supposed to laugh or not.\n\nYou're not.\n\nI'm not sure if you're supposed to tell me I'm not supposed to tell him he's not supposed to tell him he's supposed to laugh or not.\n\nYou're not.\n\nI'm not sure if you're supposed to tell me I'm not supposed to tell him he's not supposed to tell him he's supposed", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    result = []\n    for i in range(2, n):\n       result.append(i)\n    return result", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if i % 2 == 0:\n           return [i]\n        else:\n           return [i, i + 1]\n\nThe proper way to do this is to use a generator expression:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n for n in range(2, n)]\n\nI'm not sure if I'm missing something here but I don't think this is the most efficient way to factorize an integer.\n\nIt's not, but it's a nice way to do it.\n\nIt's not a nice way to do it. It's the only way to do it.\n\nI think the point of the exercise was to demonstrate a simple and straightforward way to do something that is often done in a less straightforward way.\n\nI'm sorry, but what was the point? I've done this in python before, so I'm not sure what I'm missing here.\n\nI think you're missing the point.\n\nI think he's missing the point.\n\nI think you're missing the point.\n\nI think he's missing the point.\n\nI think you're missing the point.\n\nI think you're missing the point.\n\nI think you're missing the point.\n\nI think you're missing the point.\n\nI think you're missing the point.\n\nI think you're missing the point.\n\nI think you're missing the point.\n\nI", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n+1):\n        if i % 2 == 0:\n           return [i]\n        else:\n           return [i * i for i in range(i+1, n)]\n\nI don't know much about python, but this seems like a much better way to do it.\n\nI would have written it this way:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    if n == 0:\n        return [0]\n    else:\n        return [x for x in range(2, n - 1)]\n\nWhy not just", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n * (n - 1)]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n           return [i]\n    return [i for i in range(2, n)]\n\nThat's a great example of why you should use a language with static types.\n\nIn python you would have to write:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    if n % 2 == 0:\n        return [n]\n    if n % 2 == 1:\n        return [n]\n    if n % 3 == 0:\n        return [n]\n    if n % 3 == 1:\n        return [n]\n    if n % 5 == 0:\n        return [n]\n    if n % 5 == 1:\n        return [n]\n    if n % 7 == 0:\n        return [n]\n    if n % 7 == 1:\n        return [n]\n    return List(n)\n\nfrom typing import List\n\n    def factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for factor in range(1, n):\n        if n == factor:\n           return [factor]\n           else:\n            return [factor] * n\n\nI am not sure I understand the motivation for this.\n\nI think it is an example of how to use the new typing module to create a class.\n\nThis is not an example of how to use the new typing module. The new typing module is a set of functions that allows you to add type annotations to your code.\nThe function factorize is not a class, it is a function. The author has used the new typing module to annotate the function.\n\nI think you're right. I was thinking that it was a class, but I guess it's just a function that has been annotated with the typing module.\n\nI'm trying to understand the value of this. Is it just for code review?\n\nI think the point is that it's a simple example of how to use the new typing module to annotate a function with types.", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    for i in range(1, n):\n       if i == n:\n          return []\n       i = i/n\n       if i == 1 or i == n:\n          return [i]\n    return [i for i in range(n/i)]\n\nYou could use a list comprehension to factorize a number into a list of factors.\n\n>>> factorize(8)\n[2, 2, 2]\n>>> factorize(25)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\nI like this example because it's simple, it's a good example of a simple algorithm that can be expressed in a few lines of code, and it's a good example of a simple algorithm that can be expressed in a few lines of code.\n\nThis is a bad example of a simple algorithm that can be expressed in a few lines of code. It's a good example of a simple algorithm that can be expressed in a few lines of code.\n\nThis is a bad example of a simple algorithm that can be expressed in a few lines of code. It's a good example of a simple algorithm that can be expressed in a few lines of code.\n\nThis is a bad example of a simple algorithm that can be expressed in a few lines of code. It's a good example of a simple algorithm that can be expressed in a few lines of code.\n\nThis is a bad example of a simple algorithm that can be expressed in a few lines of code. It's a good example of a simple algorithm that can be expressed in a few lines of code.\n\nThis is a bad example of a simple algorithm that can be expressed in a few lines of code. It's a good example of a simple algorithm that can be expressed in", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if n % i == 0:\n          return [i]\n       else:\n          return [i * n for i in range(2, n)]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n        return [0]\n    else:\n        return [n]\n\nThat's a cute trick, but it's not really necessary.\nIn Python, the builtin function \"factorial\" will do this for you:\n>>> from __future__ import division\n>>> factorial(5)\n[1, 2, 3, 6, 7, 8, 9, 10,...]\n>>> factorial(10)\n[2, 3, 6, 10, 15, 20, 25, 30,...]\n>>> factorial(70)\n[2, 5, 7, 11, 13, 17, 19, 23, 29, 31,...]\n>>> factorial(100)\n[3, 6, 10, 15, 20, 25, 30, 35, 40, 45,...]\n>>> factorial(1000)\n[3, 5, 11, 13, 17, 19, 23, 29, 31, 37, 41,...]\n>>> factorial(100000)\n[3, 5, 11, 13, 17, 19, 23, 29, 31", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n+1):\n        if n % i == 0:\n            return [i]\n            n = n/i\n    return [n]\n\nfrom typing import List\n\n    def factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    for i in range(2, n+1):\n        if n % i == 0:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    # We will generate a list of all possible factors of given number\n    for i in range(2, n+1):\n        if n % i == 0:\n           # This is a prime number\n           # And it's divisible by the number we are currently on\n           # So we will add it to the list of factors\n           factorize(i)\n        else:\n           # This is not a prime number\n           # So we will keep looking for the next factor\n           i = i + 1\n    return [i]</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    def factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    for i in range(2, n+1):\n       for j in range(n):\n         if n % i == 0:\n             return i\n             factorize(n-i)\n             return j\n    return List(factors(n))</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n + 1):\n        if n % i == 0:\n           return List(i)\n          return List(n)\n\nIt's missing a colon after `def` and `return` on line 3.\n\nFixed. Thanks.\n\nI don't know why this is so much fun.\n\nHaha, I know what you mean. I just spent the last hour or so playing with it. I ended up with:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n ** 2 for n in range(2, n) if n % 2 == 0]\n\nI'm not sure what the point of this post is.\n\nI'm not sure what the point of this comment is.\n\nI'm not sure what the point of this comment is.\n\nI'm not sure what the point of this comment is.\n\nI'm not sure what the point of this comment is.\n\nI'm not sure what the point of this comment is.\n\nI'm not sure what the point of this comment is.\n\nI'm not sure what the point of this comment is.\n\nI'm not sure what the point of this comment is.\n\nI'm not sure what the point of this comment is.\n\nI'm not sure what the point of this comment is.\n\nI'm not sure what the point of this comment is.\n\nI'm not sure what the point of this comment is.\n\nI'm not sure what the point of this comment is.\n\nI'm not sure what the point of this comment is.\n\nI'm not sure what the point of this comment is.\n\nI'm not sure what", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n        return [1]\n    return [n for n in range(2, n) if n % 2 == 0]\n\nI've always found the \"from typing import List\" to be a bit of a red flag. I know there are times when it is necessary, but it makes me wonder about the quality of the code.\n\nI've always wondered what the point of that is. I mean, it's not like the person who wrote that is going to be the only person who can modify the code.\n\nI find it useful when I'm using a library that was written by someone else, and I want to be sure that the imports are correct.\n\nI have to admit that I've never had that problem. I can't recall a time when I've had to modify someone else's code where the imports weren't correct.\n\nI have a hard time believing that you've never had to modify someone else's code.\n\nI meant modify as in change the imports. I have, of course, had to modify other people's code.\n\nI agree with the sentiment that \"from typing import list\" is a red", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n < 1:\n        return []\n    else:\n        return [n for n in range(n+1, 2*n+1)]\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(n):\n       if i % n == 0:\n          return []\n       else:\n          return [i]\n\nThis is not a good example.\n\nThe code is perfectly valid, but the example is a bit off.\n\nI think what he's saying is that it's a bad example because the code is doing too much. It's not a good example of good code.\n\nWhat is the best way to determine if a number is prime?\n\nThere's no \"best\" way. There are lots of ways, and some of them are more efficient than others.\n\nIt's also worth mentioning that for small numbers, it's much faster to try all numbers between 2 and the square root of n, and check if they're prime. For example, if n is 7, you can check if 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n[0], n[1], n[2], n[3], n[4], n[5], n[6], n[7], n[8]]\n\nI'm not sure I get it. I thought the \"n[0]\" thing was a joke about how python lists are indexed starting at 0, but then you never use that to refer to any of the elements.\n\nI'm a little lost too. Is this a joke about the fact that Python lists are indexed starting at 0?\n\nYes, and the fact that list indexing starts at 0 is the reason why Python's built-in functions for manipulating lists are named the way they are.\n\nOh, I see. Thanks.\n\nI wonder if this is a reference to the fact that Python lists are indexed starting at 0, and the fact that the built-in functions for manipulating lists are named the way they are.\n\nWhy would the fact that Python lists are indexed starting at 0 be a reason why the built-in functions for manipulating lists are named the way they are?\n\nI'm not sure I get it. I thought the \"n[0]\" thing was a joke about how python lists are", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if n % i == 0:\n          return [i]\n          if i == 1:\n             return [1]\n            if n % i == 1:\n               return [i]\n    return List(i)\n\nThis is a nice little hack, but the python version is a bit shorter:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    for i in range(2, n):\n        if i % n == 0:\n            return i\n        else:\n            return List(i)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    for i in range(2, n):\n        if i % n == 0:\n           return [i]\n        else:\n           return [i*i for i in range(i+1, n)]\n\nThis is a bug in the python interpreter. It is not a bug in the program.\nIn python, the range function is defined as:\nrange(i, n) = [i, i+n]\nThis means that if i is not in the range of i and n, then it will be added to the range. This is the reason that the code works.\n\nIt's not a bug, it's a feature. If you want to get a range of numbers, you can use range(0, n). If you want a range of numbers with a given upper bound, you can use range(n, 1).\n\nIt's a bug, because it's not what the user expects.\n\nIt's not a bug, it's a feature.\nIf you want to get a range of numbers, you can", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    for i in range(1, n):\n        if n % i == 0:\n           return List(i)\n    return []\n\n    def factorize_lazy(n: int):\n    \"\"\" Factorize given integer lazily.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize_lazy(8)\n    [2, 2, 2]\n    >>> factorize_lazy(25)\n    [5, 5]\n    >>> factorize_lazy(70)\n    [2, 5, 7]\n    \"\"\"\n\n    n = int(n)\n\n    for i in range(1, n):\n       if n % i == 0:\n           return List(i)\n    return []\n\nThis is", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n - 1):\n        if n % i == 0:\n           return [i]\n          else:\n           if i == 0:\n               return [1]\n             else:\n               return [i] * [i]\n    return List(range(n))\n\nThis is a very bad code. It is not Pythonic, it is not readable, and it is not maintainable.\n\nI'm not sure what you mean by \"Pythonic\" or \"readable\". This is a standard algorithm, and it is just as readable as the C or Java equivalent.\n\nPythonic:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n       return []\n    if n == 2:\n       return [1]\n    if n == 3:\n       return [2]\n    if n == 5:\n       return [5]\n    if n == 7:\n       return [2, 5]\n    if n == 11:\n       return [3, 7]\n    if n == 13:\n       return [3, 5, 7, 11]\n    if n == 17:\n       return [3, 7, 11, 13]\n    if n == 19:\n       return [3, 7, 11, 13, 17]\n    if n == 23:\n       return [3, 7, 11, 13, 17, 19]\n    if n == 29:\n       return [3, 7, 11,", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n        if n % i == 0:\n           return []\n        else:\n           return [i, i*n % i]\n\nThis is a good example of how to use a type system to enforce correctness. It's pretty easy to see that this function is correct, as it will always return the list of prime factors of any number.\n\nI'd be more interested in seeing a \"factorize\" function that returns the list of prime factors of a number in a different order than the usual one.\n\nAnd a \"reverse\" function that reverses the order of the factors.\n\n\"Reverse\" is a common method name in mathematics. For example, the inverse function of a matrix is called the \"reverse\" of the matrix.\n\nThe problem with \"Reverse\" is that it's ambiguous. There are many ways to reverse a list, and it's not obvious that the result should be the same as the original.\n\nThis is why I like the Python approach of having a reversed", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for n in range(1, n):\n        for factor in range(n):\n           if factor % n == 0:\n               return List(factor)\n    return []</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n] * List(int)\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if n % i == 0:\n          return []\n          i = i % n\n    return List(i)\n\nThis is an interesting example of how Python's type system can be abused to accomplish things that would be very difficult in other languages.\n\nI don't see how this is a good example of Python's type system. It's a good example of how Python's type system can be abused to accomplish things that would be very difficult in other languages.\n\nI agree, but I think the distinction is not very important. I was just trying to point out that this is not a flaw in the language or type system, but rather a weakness in the type system's expressiveness.\n\nThe distinction is important. It's a flaw in the language, because it's a flaw in the language's type system. The fact that it's a flaw in the language's type system makes it a flaw in the language.\n\nI think it's a flaw in the language's type system, but not a flaw in the language itself. I think", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n if n % 2 == 0 else [] for n in range(2, n - 1) if n % 2 == 0 else n * n for n in range(2, n - 1) if n % 2 == 0 else n * n for n in range(2, n - 1) if n % 2 == 0 else n * n for n in range(2, n - 1) if n % 2 == 0 else n * n for n in range(2, n - 1) if n % 2 == 0 else n * n for n in range(2, n - 1) if n % 2 == 0 else n * n for n in range(2, n - 1) if n % 2 == 0 else n * n for n in range(2, n - 1) if n % 2 == 0 else n * n for n in range(2, n - 1) if n % 2 == 0 else n * n for n in range(2, n - 1) if n % 2 == 0 else n * n for n in range(2, n - 1) if n % 2 == 0 else n * n for n in range(2, n - 1", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    n = n * n\n    while n > 0:\n       if n % 2 == 0:\n          return [n % 2 for n in range(2, n+1)]\n       else:\n          return [n % 2 for n in range(n+1, n+2)]\n\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    result = []\n    for i in range(2, n):\n        result.append(i)\n    return result", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n       return [1]\n    else:\n       return [n for n in range(2, n+1) if n % 2 == 1]\n   \n\nThe article doesn't mention it, but this code is from the standard library, and the code in the article is a thin wrapper around it.\n\nThis is a nice example of how to do something without using the standard library. I'm not saying it's always a good idea, but it's good to know.\n\nI disagree. It is a nice example of how to do something _using_ the standard library.\n\nI think the point is that you can use the standard library to solve a problem without knowing it.\n\nI think the point is that you can use the standard library to solve a problem without knowing _it is in_ the standard library.\n\nI think the point is that you can use the standard library to solve a problem without knowing _it exists_.\n\nI think the point is that you can use the standard library to solve a problem without knowing _it exists in_.\n\nI think the point is that you", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n        return []\n    else:\n        if n % 2 == 0:\n           return [n % 2 for n in range(2, n+1)]\n         else:\n           return [n % 2 for n in range(n, n+1)]\n\n>>> [2, 2, 2]\n>>> [5, 5]\n>>> [2, 5, 7]\n>>> [5, 5]\n>>> [2, 2, 2]\n>>> [5, 5]\n>>> [2, 2, 2]\n>>> [5, 5]\n>>> [2, 2, 2]\n>>> [5, 5]\n>>> [2, 2, 2]\n>>> [5, 5]\n>>> [2, 2, 2]\n>>> [5, 5]\n>>> [2, 2, 2]\n>>> [5, 5]\n>>> [2, 2, 2]\n>>> [5, 5]\n>>> [2, 2", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    result = []\n    for factor in n:\n        if not factor in result:\n           result.append(factor)\n    return result\n\nThis is a neat trick, but it's really not that much of a time saver.\n\nIt's not a time saver, it's an abstraction. You can factorize n by hand in O(n^2) time.\n\nI don't think it's an abstraction at all. The whole point of factorization is to take an integer and break it into smaller integers. The time taken to do this is not an abstraction, it's a fact.\n\nThe point is that it's not a time saver in the sense that it takes less time to factorize a large number than it does to compute its prime factors by brute force.\nIt's a time saver in the sense that it takes less time to factorize a large number than it does to write a function that will factorize a large number.\n\nIf you're writing a function to factorize a large number, you're probably doing something wrong.\n\nSo, I'm going", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if i % n == 0:\n          return List(i)\n    return List(i * i)\n\nI'm not sure how this is \"more pythonic\" than:\nimport itertools\nfact = lambda n: itertools.product(n)\nfor i in range(1, n):", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    return [n * n for n in range(2, n+1)]\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if i % n == 0:\n           return List(i)\n       else:\n           if i % n == 1:\n              return List(n)\n       else:\n            return List(i)\n\nIt's a good exercise to try and write a version that doesn't use recursion.\n\nTrue, but it's a good exercise to try and write a version that uses recursion but isn't a complete disaster.\n\nIn Python, you can use a generator for the recursive function, and yield the results you want, and it's a lot easier to read.\n\nI'm not sure if this is the right place to post this, but I found it amusing and I wanted to share.\n\nIt's a classic joke. It's also a good example of the importance of naming things.\n\nIt's also a good example of the importance of not naming things", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    for i in range(2, n):\n        if n % i == 0:\n           return [i]\n        else:\n           return [i * i for i in range(i, n)]\n\n    return [i for i in range(2, n)]\n\nI don't get it. Is this some sort of joke?</s>"]]