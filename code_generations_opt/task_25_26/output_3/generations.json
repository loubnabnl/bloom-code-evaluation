[["from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n           return List(i)\n    factorize(n - i)\n\nThe reason this is even a little bit interesting is that I first wanted to implement it using python 3's new itertools.repeat function. It's not even a really a new function, just a new way of writing for-loops in python, but I had never seen anyone use it before:\n>>> from itertools import repeat\n>>> def factorize(n):\n    return repeat(2, n + 1,\n         return List(i) if i % 2 == 0)\n>>> factorize(8)\n[2, 2, 2]\n>>> factorize(25)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]\n\nAnd then I figured I could write a function that would work the same way, but with less typing:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if n % i == 0:\n          return i\n       factorize(n - i)\n\nThe big-O is one.\n\nIt's one, but the code is bad and the reasoning is bad and the program does not even work as intended.\n\nTrue.\nI wrote it in 10 minutes. You have no idea how many times I had to go through this stupid thing to understand what's going on.\n\nI was wondering if anyone would see the humor in the original question. I'm happy you were able to decipher it as I was not.\n\nCan anyone explain why this is not the answer?</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    s = 0\n    while s < n:\n        for i in range(n - s):\n           if n % i == 0:\n               break\n        s += 1\n        if s == n:\n           return List(s)\n    else:\n        for i in range(n - 1):\n            if n % i == 0:\n               break\n        s -= 1\n        if s < n:\n            return List(s)\n\nThat's pretty much the algorithm (though you're not breaking in the middle of a loop). The algorithm is described in Knuth's \"Concrete Mathematics\" book.\n\nNow factorize the string \"The quick brown fox jumps over", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n for n in factorize(n - 1) for n in range(n)]\n\nJust a warning - this implementation is slow.\n\nHere's an O(n log n) one, with an example:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    return [n / n for n in range(n)]\n\nJust a couple of minor changes:\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    if n == 0:\n        return []\n    factorize_ = []\n    n = int(input(1))\n    for i in range(2, n - 1):\n        if i == 0:\n            return []\n        factorize_.append(i)\n        factorize_ = [i*n for i in range(2, n)]\n    return factorize_\n\nThis is not quite right, but I'm not sure how to fix it.\n\nTry it with 8, 25 and 70.\n\nOops, this is because I've never seen an integer with a factor of 0 before (I'm an applied mathematician, not a computer scientist).\n\nI'm not a computer scientist either, but I'm pretty sure it can't happen.\n\nThis will blow your mind. I've seen a float that had no value:\n>>> import numpy\n>>> a = numpy.zeros((4,3))\n>>> a\narray([])", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    if n == 0:\n       return [0]\n    return [x * x for x in range(n - 2)] * [x]\n\nThe \"if n == 0\" line is redundant.\nAlso, I think the factorial function should be renamed to something more appropriate. It's a totally different beast from the prime factorization function, which would be a better name for this function.\n\nThe \"if n == 0\" is not redundant. It's used to check if the number is a multiple of 2. If it is, then the function returns 0, which is the only factor that needs to be returned. If it is not, then the function returns the factors in order from smallest to largest. If the function did not include the line \"if n == 0:\", it would return a list of all the factors.\n\nI see.\n\nI wrote a similar function a while ago for ruby. The prime function in that was too slow for my purposes, but I would imagine that it can be optimized in python.\nI ended up using bitmasking instead and it has worked great for me: \n\nWhat is the use case for this?", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\nfor i in range(2, n+1):\n    if n % i == 0:\n        print(\"prime number\")\n    return List(i)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        for j in range(2, n):\n           if (i * j) == n:\n               return i\n    else:\n               return None\n    return List(factors(n))\n\n[Edited to fix formatting errors]\n\nAwesome! I've always wanted to do something like this.\n\nI used to do this all the time back in high school. Most of the time it was just for fun, but once I actually used it to do some cryptanalysis on a particularly nasty challenge.\n\nI remember doing this once for the fun of it. I thought it would be cool if I could factor numbers much larger than 32 bits, but that's not possible (yet). So I wrote a few different methods to factor numbers using only addition and multiplication.\nIt was very interesting to implement and even more interesting to see the math behind it all.\n\nHehe, I used to do this with my dad all the time", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n        if n % i == 0:\n           return []\n         else:\n             if i in range(2, n):\n                   return [i]\n         else:\n                   return []\n    return [i for i in factorize(n)]</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n / 2 for n in range(1, n) if n % 2 == 0]\n\nIf you want a hint that you might want to use a list comprehension instead of nested for-loops, you can try using this function:\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    l, p, q: List[int],\n    i: int,\n    if n%2 == 0:\n        p = []\n    else:\n        p = List()\n        q = []\n        for i in range(2, n):\n           if n % i == 0:\n                p.append(i)\n               q.append(i)\n              else:\n                q.append(n % i)\n    return l, p, q\n\nThis should be called \"factorization\" instead of \"factorize\".</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return []", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n for n in range(n-1,0,n+1)]\n\nI think you can get the same effect with a for loop. Also, why would you need to define a function for that?\n\nIt's for factorization of numbers larger than any practical use of an in-place loop.\n\nYou can always define a class in python. The difference is that a class is \"an object\", a function is not.\nSo in this case, you would define a class that has a method called \"factorize\". In this method, you would have a \"factorize(n)\" method. When you would call this method, you would call a function \"factorize(n)\" with a parameter n. And you would have the same result as the code in the blog post.\n\nThis is a bad example for a class because it is essentially a function without any arguments, and it's a bad example for a function because it is essentially a class with only one method.\nI would have named it `PrimeFactors`, and then defined it as a class with an appropriate number of methods.\n\nIt is not. The difference is that a function can't be an instance of a", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n+1):\n       if n % i == 0:\n          if i % n == 0:\n             return List[i]\n            else:\n             return List[i]*List[i-1]\n\nfrom typing import Ord", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n if n % n for n in range(2,n)] * List(n)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    while n > 1:\n          if n % 2 == 0:\n              return [n % 2]\n           elif n % 3 == 0:\n              return [n % 3]\n           else:\n              return [n % n for n in range(3)]\n\nI believe the recommended style is:\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n * (n+1) for n in range(2, n+1)]\n\nfrom typing import Type\n\n    def is_prime(n: int) -> Type:\n    \"\"\" Return true if n is prime.\n    >>> is_prime(16)\n    True\n    >>> is_prime(72)\n    False\n    \"\"\"\n    return not is_prime(n % n)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n - 1):\n       if i % n == 0:\n          return []\n      else:\n          return [ i, i*i for i in range(i + 1, n - 1)]\n\nHow does the for loop work with the range() function?\n\nrange(i+1, n-1) is equivalent to range(i, n).\n\nI would've thought the loop to be 1-indexed.\n\nIt looks to me like the loop is just a convenient way of building an infinite list of the smallest prime factors of an integer. The range() call in the loop lets you start from the smallest prime factor and go up to the desired number of factors.\n\nIf it's a numeric problem, python is a great choice.\nIf it's a string problem, python is a great choice.\nIf it's a problem that can be represented as an object in python, python is a great choice.\n\nDon't forget: If it's a problem that can be represented as a recursive function in python, python", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n        return [n - 1 for n in List(n)]\n    else:\n        return [n for n in List(n)]\n\nThis is very good, and we'll probably use it in our codebase, but it would be even better if it returned the factorization of the number as a string instead of a list.\n\nHow would one factorize a number as a string?\n\nI was being facetious, but it seems you've managed to extract the Python 2.x version from that code. I would imagine it would be even better to extract the Python 3.x version, which would probably look more like:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n] if n == 0 else\n    [n for n in [2, 3, 5, 7] if n % 2 == 0]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if n % i == 0:\n          return []\n    for j in range(i+1, n+1):\n         if n % j == 0:\n            return [j]\n    return [i] * [j]\n\nThis is good, but I like it better in Python:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n <= 2:\n       return [1, 1]\n    else:\n       return [n]\nThis is a good example of a classic gotcha in Python. For any number _n_, the result of the following function is _n_ :", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    result = []\n\n    for i in range(2, n + 1):\n        result.append(i)\n\n    return result\n\nfrom typing import *\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    from itertools import product\n    from math import sqrt\n\n    def list_of_factors(n: int) -> [int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> list_of_factors(8)\n    [2, 2, 2]\n    >>> list_of_factors(25)\n    [5, 5]\n    >>> list_of_factors(70)\n    [2, 5, 7]\n    \"\"\"\n    product = product.apply(n)\n    for i in range(1, n):\n       if n % i == 0:\n          fact = n\n          fact = product(i)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n <= 1:\n        return [1]\n    else:\n        return [2 ** n for n in range(n)]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n           return [i]\n       else:\n          return list(List(i, n % i))\n\nI'm always amazed when I see things like this, which make me feel like I'm missing something in Python. The whole point of using a functional language is to _avoid_ the whole nested for loop thing.\nThis is just a thought experiment. I'm sure there is a reason that this is done this way. But I still feel like I'm missing something.\n\nThis isn't really a functional language. It's OO with a few functional constructs. It's not really trying to be a functional language, though they're in the process of adding some real FP features.\n\nPython is a multi-paradigm language. You can write any kind of code in it.\n\nYes, that's what I said. And it's true for every language.\n\nYou said it was not a functional language. Which is not true. It has functional constructs, and", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2,n):\n       return (i % n) * n", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n+1):\n        if n % i == 0:\n           return [i]\n    return [i ** n for i in range(2, n) if n % i == 0]\n\nFactorials are a special case of this.\n\nThis was useful when I wrote a lisp interpreter in Python.\n\nI always use:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    factors = [False]\n    for x in range(n):\n        if x is not None and x%n!= 0:\n           factors.append(False)\n           if n%x!= 0:\n               factors.append(True)\n    return factors\n\nNot sure if it's the original intent, but you can also do this:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n       return [2, 2, 2]\n    else:\n       return [2, 2, n - 1] + [n - 2, n - 1, n - 2]\n    return []\n\nFactorize(8)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(n):\n        if n%i == 0:\n           return i\n       else:\n           return [i]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\nWhat is the meaning of \"in the order from smallest to largest.\"?\n\nIn this case the author is referring to the first definition of the function from the docs:\n>>> factorize(25)\n[5, 5]\nThe input number is 25, the \"factorize(25)\" returns 5, and the \"return [5, 5]\" line returns [5, 5], i.e. the list of prime factors with the largest ones first.\n\nThank you.\n\nAm I the only one who's annoyed by the fact that the author is using Python 2.6 while the only other mention of Python is in the title (Python 3.3.0)?\n\nI'd be more annoyed by the fact that the author is using Python 2.6.\n\nThis is a nice article and all, but I have to say that this line in particular made me chuckle:\n>>> from typing import List\nIt's \"from typing import List\", not \"from typing import Listing\". And while it's somewhat amusing, it's also un-pythonic, and the reason that the author is getting this error in the first place is because he's trying to call a function with a name that's too long", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    list = []\n    while True:\n       for i in range(1, n):\n          if n % i == 0:\n               list.append(i)\n             return list\n\nList(2, List(2, List(2, 2)))\n\nI don't really get it. This prints out a list containing a list with\n2 as the first element, followed by two lists with 2 as the first\nelement.\n\nYou're looking at the code as though it were imperative.\nWhat he means is that the list returned is the list of all the numbers\nwhich are prime factors of 8, arranged in the order in which they occur.\n\nYes, I was looking at the code as though it were imperative because that's the only way I know to code. Can you explain to me how to code without thinking about imperative actions?\n\nIt's not really a language issue, it's a way of thinking.\nA lot of the time, you're going to be thinking about the things", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    def is_even(n: int) -> bool:\n    \"\"\" Return true if n is even.\n    >>> is_even(5)\n    True\n    >>> is_even(23)\n    False\n    \"\"\"\n    if n % 2 == 0:\n       return False\n    return n % 2 == 1", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [2]\n    if n == 3:\n        return [3]\n    if n == 4:\n        return [4]\n    if n == 5:\n        return [5]\n    if n == 6:\n        return [2, 3, 5, 7]\n    if n == 7:\n        return [1, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    return [2, 2, 2, 5, 5, 7, 7, 11, 11, 13, 13, 17, 17, 19, 19, 23, 23, 29, 29]\n\nimport collections", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\nSome languages don't have an \"import\" keyword, but I suppose you could try this:\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    n = int(n)\n\n    for factor in range(n):\n        if n % factor == 0:\n             return List(factor)\n        elif n == factor:\n             return None\n       else:\n             return List(n)\n\nAnd here is a test program, with the number of lines shown in the abstract for each of the different solutions.\n\nimport string\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    for i in range(2, n+1):\n        if n % i == 0:\n           return\n        i = i/n\n        else:\n           n/i\n    return List(i)\n\nyikes!</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    num_factors = n\n    if num_factors == 0:\n       return [1, 0]\n    for i in range(1, num_factors):\n       for factor in range(1, n):\n         if i == n:\n             continue\n             num_factors = i\n              factor = i\n    return List(factors, num_factors)\n\nI would call it \"factorize\" to be more consistent with the main loop in the code.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    def list(lst):\n         return lst.values()\n         for f in lst:\n             if f == n:\n                  return [f]\n              else:\n                   return []\n    return list(factoring_numbers(n))\n\nimport math", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\nresult = []\n    for factor in factors(n):\n       if factor is not None:\n           result.append(factor)\n    return result", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n+1):\n        if n % i == 0:\n           return [i]\n       else:\n           return [i for i in range(1, n+1)]\n\nSo, I guess there are two major use cases. The first is to get the order of the factors as a list, and the second is to get a list of the factors themselves.\n\nSeems like a decent use case for a list comprehension.\n\nand just what is the difference?</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(n):\n       if n % i == 0:\n          return []\n          return [n]\n\nThe code is (unfortunately) non-idiomatic because it tries to abstract away the details of the problem at hand. Python is at its best when you try to express what you need in the clearest possible terms, and let the language take care of the rest. The clear solution here is:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    factors = []\n    for i in range(2, n):\n       if n % i == 0:\n          factors.append(i)\n       else:\n          for j in range(n / i, 1, n - 1):\n             if n % j == 0:\n               factors.append(j)\n    return factors\n\nFrom the article:\n\"\"\"\nThe intent of this exercise is not to teach you functional programming. Instead, the goal is to give you a glimpse of the kind of programming idioms we use in the course. This is just one exercise, but you will find that the same kind of thinking applies to other topics as well.\n\"\"\"\nI've done this exercise many times and even wrote about it in my own blog, but I never saw anyone talk about it. I wonder if it has any other applications?\n\nIt's the same as the classical recursive algorithm:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    var list = []\n    var n = int(input(1))\n    while n > 0:\n       list.append(n)\n    n = n/factors(n)\n\nThe author claims he doesn't know much about python, yet he declares a function called \"factors\". This leads me to believe that he is either a liar, or that this is not his first python program.\n\nWell, it's quite possible he's never written a class in python. That's where I started my python experience (coming from java) so it's not entirely out of the question.\n\nYes, that's exactly right. I know pretty much nothing about classes, although I've been playing with them for the last week or so.\n\nIt's not that hard.\nI assume you already know that \"list\" is the class and that \"n\" is the attribute.\nThe general pattern is this:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    n = int(n)\n    return List(n)\n\nBut that's cheating - you know how the algorithm works, so you can easily tell how to implement it.\n\nIt's not even cheating. It's doing the same thing, except with less typing. It's like saying this:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n>>> def divisor(n: int, x: int) -> bool:\n    \"\"\" Determine if given number is divisor of other number\n    This function returns true if given number is divisor of other number and false otherwise\n    >>> divisor(2, 4)\n    True\n    >>> divisor(4, 2)\n    False\n    \"\"\"\n\n>>> def prime(n: int) -> bool:\n    \"\"\" Return true if given number is prime number\n    This function returns false if given number is not prime number and true if it is\n    >>> prime(2)\n    True\n    >>> prime(3)\n    False\n    \"\"\"\n\n>>> def isPrime(n: int) -> bool:\n    \"\"\" Determine if given number is prime number\n    This function returns true if given number is prime number\n    >>> isPrime(2)\n    True\n    >>> isPrime(3)\n    False\n    \"\"\"\n\n>>>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       for j in range(i+1, n):\n         if n % i == 0:\n               j = j + 1\n       else:\n              j = j - 1\n               if j == 0:\n                  return []\n    return List()\n\nThis is not exactly the same code as the blog post, but very close. You can see that it's much more elegant than the original. The original, with only one loop, has to evaluate i and j for every value of i+1 and j+1. This has to evaluate only one loop (i+1 and j+1) for each value of i and j.\n\nThat is not how I would have done it. The naive way is:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n+1):\n        if (i % n == 0) or (i % n == 1) or (i % n == 3):\n           return [i]\n    return [list(i) for i in range(2, n+1)]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n if n%primes == 0 else x for x in primes if (x%n == 0) and (x%(n - 1)) == 0 else None for x in primes]\n\nOr you can just use the same function as the one in the article", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    # Store number in given variable\n    n = int(n)\n    while n > 2:\n       if n % 2 == 0:\n          n = n/2\n       else:\n          n = n % 2\n       for factor in range(2,n):\n          n = factor\n       # Store the prime factors in a list.\n    list = []\n    for factor in range(n):\n          list.append((int(factor) * n) % 2)\n    return list\n\n>>> print(factorial(8))\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100,...]\n\nThe code I wrote is obviously lacking a lot of information about how to deal with those edge cases. But in the interest of maintaining a simple interface I think it's good enough.\n\nI like this better:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    n = int(input(\"Enter number you wish to factorize: \"))\n    p = list()\n    for i in range(0, n):\n       p.append(i*p)\n    return p\n\n>>> from typing import List\n>>> factorize(70)\n[2, 5, 7]</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1 or n % 2 == 0:\n    return [1]\n    if n == 2 or n % 2 == 1:\n    return [1, 1]\n    factorize = [List[int]]()\n    for i in range(1, n):\n       factorize.append(i)\n    return factorize\n\nI guess the author is trying to be funny by trying to be obscure.\nI would just use this:\nimport itertools", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    var factors: List[int] = []\n    var found: int = 0\n    var last: List[int] = [0]\n    while (n > 1):\n       if n % 2 == 0:\n         factors.append(n)\n       n = n / 2\n       if n == 1:\n         found = n\n       else:\n         found = found / 2\n       if last == [0]:\n         last.append(n)\n       n = n / 2\n    return factors\n\nUnfortunately, while the algorithm is correct, it's not the most efficient one. For example, it cannot be used to factor the number 23.\n\nWhy? 23 = 3*5.\n\nSorry, I should have clarified. I was trying to say that 23 could not be factorized in linear time.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n for n in xrange(2, n) if (n%x == 0) else n]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    num_factors = len(n)\n\n    if n!= 0:\n       return List(num_factors)\n\nThis should be fun to play with</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n * (n * 2 for n in 2 to n * n)]\n\nWe're going to need a for loop for the testing.\nimport unittest", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n is None:\n       n = int(input(\"Enter an integer: \"))\n    return List(range(n))\n    for i in range(n):\n       if n % i == 0:\n          if i == 0:\n             return 0\n            if n % i == 1:\n              return 1\n            else:\n             return n\n    return list(range(n))\n\nAlthough I don't understand all of the details, I see that the code is very short, simple and clear.\n\nFor comparison, here is the same program, but implemented using \"from itertools import product\".\n>>> from itertools import product\n>>> def factorize(n: int) -> product.Product[int]:\n...    if n is None:\n...", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n > 2:\n        return [n]\n    else:\n        return [1] * [n - 1] * [n - 2] * [n - 3] *... * [n - (n - 1)]\n    return [1] * [n]</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    else:\n        return [1] * List(n / factorial(n - 1))\n\nI'm not sure why you would ever use this, given that the primitive is already built in. The built-in version is more useful and more concise.", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n       return [n]\n    n = floor(n * (1 << n))\n    return [n for n in range(n - 1) if n % (2 ** (n - 1)) == 0]\n\nI'm not sure this is what the OP was looking for (it's not the implementation of the algorithm), but it's a beautiful answer.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n <= 2:\n       return [1]\n    for i in range(1, n):\n       if n % i == 0:\n          return List(i)\n    else:\n          return List(i) / n\n\nOK, I'll admit to not having written any C in a few years. But I _still_ know that the author is using a List, not a dictionary, and for the life of me I can't figure out why that's wrong.\n\nI guess the reason is that it's a little bit verbose.\nThe way I would do it is:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n        return [1]\n    else:\n        factors = [n for n in range(2, n+1)]\n        return [n*factors for n in factors]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n - 1):\n        if n % i == 0:\n           return [i]\n    return [n / i for i in range(n - 1)]\n\nwhile 1:\n    if n % 1 == 0:\n        return [1]\n    else:\n        return [n * factorize(n - 1)]\n\nfor i in range(n):\n    print(fact(i))\n\nOne more, Python style.", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n < 0:\n         raise ValueError('divide by 0 is not a number')\n    else:\n         n = n.floor()\n    return [n for n in range(1, (1 << n/factors) - 1) if n % factors == 0]</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    l = []\n    if n == 0:\n        return l\n    for i in range(2, n):\n        if n % i == 0:\n           l.append(i)\n    return l", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n + 1):\n       if n % i == 0:\n          return []\n       else:\n          return [n % i for i in range(2, n)]\n\nThis code is a little broken, but the idea is good. If you change it to\nfactorize(n, 2**(n-1))\nyou'll get an empty list of primes.\n\nThe actual code: \n\nI don't see why this wouldn't work, since it computes the number of primes <= N and then subtracts one.\n\nIt's a little slow and not as efficient as other solutions.\n\nNot necessarily, if you allow the number of factors to be a variable. In that case, you can simply use a map() to do the work.\n\nBut that's cheating!\n\nI like the last line</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n is None:\n        raise TypeError(\"Input number must be an integer.\")\n\n    n = int(input(\"Enter integer: \"))\n    while n > 1:\n        if n % 2 == 0:\n           raise StopIteration()\n         n = n / 2\n        return [List[int(a) for a in factorize(n-1)] for a in factorize(n-1)]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return [1]\n    if n == 1:\n        return [1]\n    if n == 2:\n        return [1, 1]\n    if n == 3:\n        return [1, 1, 1]\n    if n == 4:\n        return [1, 1, 1, 1]\n    if n == 5:\n        return [1, 1, 1, 1, 1]\n    if n == 6:\n        return [2, 2, 2, 2, 2, 2]\n    if n == 7:\n        return [2, 2, 2, 2, 2, 2, 2]\n    return [n for n in [n * [n * [n * [n * [n * [n * [n * [n * [n * [n * [n * [n *", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n!= 0:\n        return []\n        x = n\n        for i in range(2,x+1):\n           if (n % i == 0) or (i == 1):\n              return i\n    return List(x)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if n % i == 0:\n          if n % i == 1:\n               return [i]\n               return []\n    return List(factors)\n\nWhy not just use the Mersenne twister algorithm?\nhttp://en.wikipedia.org/wiki/Mersenne_twister\n\nThat's a much better idea than iterating through all the factors.\n\nIs there a specific reason why it's in python?\n\nBecause it's a small exercise?\n\nbecause we can?\n\nAnd that, ladies and gentlemen, is why Python is such a beautiful language.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n + 1):\n        factorize(i)\n    return List(factors)\n\nto:\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if n % i == 0:\n          return i\n    return List(i+1)\n\nHaha, I like this one.\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n           return [i]\n        else:\n           return [i * factorize(i + 1)]\n\nTo my understanding, this is just a linked list. I would like to see a more efficient data structure than a linked list. I'd like to see the number of operations reduced, not increased.\n\nThis is a pretty great example of how to improve performance by using the right data structure.\n\nThis is the right data structure for the wrong problem.\nIt might be very useful in a case where you need to process a lot of numbers, and you need to make sure that the numbers are correct, but it doesn't help you if you are just trying to find the prime factors of a number.\n\nI think you're missing the point. The \"wrong\" problem is to find the prime factors of numbers.\nThe \"right\" problem is to find the prime factors of numbers with an efficient implementation.\n\nIn which case you don't need a linked list", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n % 2 == 1:\n       return [n]\n    elif n % 3 == 1:\n       return [n, n, n]\n    else:\n       return [n, n*n for n in range(n/2)]\n\nalso,", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n, List() if n % (n * (n + 1)) == 0]\n\nPretty cool, but note that the example given is incorrect.\nThe factorization of 25 should return [5, 5, 7] as the result.\n\nI'm confused by your comment. I tried it and it looks right to me. I also tried 70 and it returned [2, 5, 7] like in the example.\n\nIt's because they're not listing the factors in the same order. The first two factors in the list are 2 and 5, but they don't appear in the \"factorization\" list. The factorization list is in the order 2, 2, 2, 5, 5, and 7, instead of 2, 5, 7, 5, 2, 2.\n\nCorrect. The example is wrong.\n\nGood point.\n\nGood example, but I really don't understand the \"import typing\". I understand that \"import\" is used to load modules, but what does the typing have to do with it?\n\nThe original article was about Type Erasure.\n\nOk, I'm still not getting it. How does \"import typing\" get around type er", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(n):\n        if i % n == 0:\n           return list()\n        else:\n           if i * i > n:\n                return [i, i, i]\n        else:\n              return [i, i, i]\n    return list()\n\nThis is bad code.\n\nWhy?\n\nBecause if you're writing for an audience that might not know the Python language inside and out (or who may be learning Python), you should avoid gratuitous use of the impenetrable typing module (see, for instance, ).\nHere's a version that avoids the impenetrable typing module, and which is more readable:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if i%2!= 0:\n          return i*i\n    for i in range(n+1, 2):\n        if i%2 == 0:\n          return i*i\n    return [i for i in range(n, 1)]\n\nIs that a joke?</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if n % i == 0:\n           return\n        for j in range(n/i, i):\n           if i == j:\n             return\n        if n % i == 0 and i + j == n:\n            return\n        return []\n\n(Try it with the input \"8\"!)\n\nOh, and since the code was submitted earlier in the day, here are the top two comments from the previous submission:\n<\\--\n\nI came up with a similar function a while ago, and wrote an article about it:\nI also implemented it using explicit recursion.\n\nIt's not exactly the same algorithm, but it's similar.\n\nThis is almost identical to the code in the linux version of factor:\n\nIt's not exactly the same algorithm, but it's similar.\n\nWhat's the", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n for n in range(2, n+1) if n%2 == 0]\n\nWhat a beautiful program.\n\nNote that this is pure python.\n\nI'm sorry but I can't take this seriously. Yes it's pure python, and it's a good illustration of the fact that many people consider python to be a toy language. This is the kind of thing that would be a one-liner in a real language.\n\nPlease don't use gratuitous negativity in HN comments.\nhttps://news.ycombinator.com/newsguidelines.html\n\nI'm sorry but \"pure python\" is gratuitous positivity. It's a _bad_ thing.\nI suppose I should have phrased it differently. I believe that python is a useful tool, but I don't believe that it's a \"real language\". I didn't mean to make it seem like it was beneath me.\n\nI would be interested in knowing what languages you consider to be \"real languages\".\nI'm also interested in knowing why you feel Python is not a \"real language\" because as far as I can tell, it's Turing Complete, and can be used to write any", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n < 1:\n        raise ValueError(\"Incorrect input\")\n    else:\n        return [factors(n)]\n   \n\nfrom typing import List\n\n    def factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    if n < 1:\n        raise ValueError(\"Incorrect input\")\n    else:\n        return [factors(n)]\n   \n\nfrom typing import", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    return (n*x[1], n*x[2], n*x[3], n*x[4])\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n+1):\n       if n % i == 0:\n          if i % n == 0:\n             return [i]\n                  return []\n    return [n % i for i in range(n)]\n\n>>> factorize(8)\n[2, 2, 2]\n>>> factorize(25)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    factorize = lambda x: x % (x - 1)\n    for x in range(1, n + 1):\n       for y in range(1, n):\n         if x mod y == 0:\n             factorize(x, y)\n        else:\n            factorize(x - 1, y)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n        return [1]\n    for factor in 2..n:\n        if n == factor:\n           return [factor]\n        else:\n           return []\n\nWell done!\nIt's not obvious to the author, but apparently to the HN crowd, that this is a pure example of memoization.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for n in range(1, n+1):\n        if n % 2 == 0:\n           return [n*n for n in range(2, n+1)]\n    else:\n           return [n*n for n in range(n+1, n+1)]\n\nI thought this was a joke.\n\nIt is. You can't import types.\n\nAnd I _still_ thought it was a joke.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n        if i % 2 == 0:\n            return List(i)\n    else:\n            return [i]\n\nSlightly off-topic, but I'm a newbie, so forgive me if this is a dumb question.\nThe OP's solution is also a way of writing:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n+1):\n        if n % i == 0:\n           return []\n        else:\n           if n % i == 0:\n              return [n, i*n for i in range(n)]\n    return [1 for i in range(n)]\n\nI prefer to use the number_format function for format arguments. It is much more readable than in the OP.\n\nI was just sharing the one I came across. How do you like the formatting of the example I gave?\n\nIt's OK. I think this is a bit nicer:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    import random\n\n    def genList(n: int):\n    \"\"\"\n    Function that generates list of prime factors of given integer.\n    Returns list of tuples of form (p, q) where p is the prime factor of n and q is the number of times that p appears in factorization.\n    \"\"\"\n    q = (n * len(factors)) + 1\n    for i in range(len(factors)):\n       if n == i:\n          return (p, q)\n       else:\n          return (factors[i], q)\n\n    def main():\n    \"\"\"\n    Function that shows functionality of factorize() function.\n    >>> factorize(70)\n    [2, 5, 7]\n    >>> genList(70)\n    [2, 5, 7, 2, 5, 7]\n    >>> for n in genList(70):", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n * n for n in range(1, n)]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    return []\n\nYou missed an import.\n\nNope. Read the comment.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    n = int(n)\n    if n < 1:\n        raise ValueError(\"factorize() can only be called with positive integer\")\n\n    for factor in range(n):\n        if n % factor == 0:\n             raise StopIteration", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    for i in range(n):\n        if not i % n == 0:\n            continue\n            a, b, c = List.range(n, i)\n             for j in range(n):\n                 if a % j == 0:\n                         a = b % j\n                          b = c % j\n                           c = a\n                           a, b, c = List.append(a)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    def factorize_reverse(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from largest to smallest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize_reverse(70)\n    [2, 7, 5]\n    >>> factorize_reverse(2)\n    [2]\n    >>> factorize_reverse(25)\n    [7, 5]\n    >>> factorize_reverse(9)\n    [9]\n    \"\"\"\n    return List(reverse(factorize_reverse(n)))\n\nI prefer the Pythonic approach:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    p = int(n) * p\n    p_1 = p % p\n    p_2 = p / p % p\n    p_3 = p / p % p\n    for i in range(p_1 + 1, p_2 + 1, p_3 + 1):\n        if (p % p == 0):\n           p = i\n        else:\n           p = p + 1\n         return [p]\n\nIsn't there some more concise way of doing this? Maybe I'm missing something but this is really long.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n        if (n % i == 0):\n           return []\n        for j in range(1, i+1):\n            if j % i == 0:\n                    return [i, i*j]\n\nI don't see how this is any better than the standard recursive solution.\n\nIt isn't.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n-1):\n        if i % 2 == 0:\n           return i\n    return [i]*[i]\n\n\"The syntax of Python's list comprehension notation is very flexible. The most important syntax rules are as follows:\n* A list comprehension is delimited by the pair of parentheses with a colon in between:\n((condition))\n* Nested list comprehensions (called \"comprehensions within comprehensions\") can be written in a single line, with the outermost pair of parentheses having the innermost pair nested within it:\n((a [b [c]])\n(condition))\n* The body of a list comprehension is a Python expression that evaluates to a Python value.\n* The name of the expression can be an arbitrary expression, but it is usually a function name.\n* The body of a list comprehension is executed as a single Python statement.\n* All the elements of the list comprehension are accessed by index, using the colon syntax.\n* The syntax for accessing elements of a list comprehension is as follows:\n(0) is the first element of", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    list = [0]\n    for i in range(2, n+1):\n        if n % i == 0:\n           list.append(i)\n    return list</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n] * [n for n in [1, 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 109, 113, 127, 131, 137, 139, 149, 157, 163, 167, 173, 179, 181, 193, 197, 211, 223, 227, 233, 239, 251, 257, 263, 269, 271, 277, 281, 293, 307, 311, 317, 331, 337, 347, 359, 367, 373, 379, 397, 421, 431, 437, 439, 443, 449, 457, 461, 463, 469, 471, 473, 479, 487, 489, 491, 499, 503, 509, 517, 523, 541, 547, 553, 559, 563, 569, 573, 579, 583, 591, 593, 595, 597, 601, 607, 613, 6", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    a, b, c, d, e, f = List(1, 2, 3, 5, 7)\n\n    if n % 2 == 0:\n        a, b, c = factorize(n / 2)\n        d, e, f = factorize(n % 2)\n\n    for i in xrange(1, n):\n        if (a[i] * b[i] == c[i] * d[i] + e[i] * f[i]) and (a[i] * b[i] + c[i] * d[i] == e[i] * f[i]):\n             a[i] *= b[i]\n             c[i] *= d[i]\n             d[i] *= e[i]\n             f[i] *= e[", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if n % i == 0:\n          i = n // i\n          return [i]\n\n>>> from typing import List\n>>> from typing import List\n>>> factorize(25)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]\n\n>>> fact = lambda n: List[int]\n>>> fact(1)\n[2, 1]\n>>> fact(10)\n[2, 2, 2]\n>>> fact(14)\n[2, 5, 7]\n>>> fact(15)\n[2, 3, 3]\n>>> fact(25)\n[5, 5]\n>>> fact(35)\n[2, 5, 7, 1]\n>>> fact(45)\n[2, 3, 3, 2, 5, 7, 1]\n>>> fact(55)\n[2, 3, 3, 2, 5, 7, 1, 9]\n>>> fact(70)\n[2, 5, 7, 1, 11, 13", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    for factor in range(1, n):\n        if n % factor == 0:\n            factor = n\n             List.add(factor, 1)\n        else:\n             factor = List.get(n, factor)\n    return factorize(n - 1)\n\nPython 3.1.2 (default, Oct 11 2009, 07:19:29)\n[GCC 4.2.1 Compatible Apple LLVM 7.0.0 (clang-700.0.46)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> factorize(2)\n[2, 2]\n>>> factorize(3)\n[3, 1]\n>>> factorize(6)\n[6, 2, 2]\n>>> factorize(15)\n[15, 5", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    for i in range(1,n):\n       for j in range(2,i+1):\n          if i*j!= n:\n              continue\n              j = j*j\n              i = i*i\n    return [i for i in range(j) if i*j!= n]\n\n    print(factorial(1))\n    print(factorial(2))\n    print(factorial(3))\n    print(factorial(4))\n    print(factorial(5))\n    print(factorial(6))\n    print(factorial(7))\n    print(factorial(8))\n    print(factorial(9))\n    print(factorial(10))\n    print(factorial(11))\n    print(factorial(12))", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    for i in range(n - 2):\n         if i % 2 == 0:\n             if i % 3 == 0:\n                 return i\n                 return List(i)\n\nNow, explain why this is so wrong.\n\nIt's not so wrong. I would have written this as", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    def factorial(n: int):\n    \"\"\" Return result of factorial operation on the given number.\n    \"\"\"\n    return n! / factorial(n - 1)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(n):\n       if i < n:\n          return List(i)\n       if i == n:\n          return List(n)\n    return List(factorial(i))\n\nfor i in range(8):", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\nfor n in range(2, n):\n    if n % 2 == 0:\n        return n\n    return []\n\nI don't know Python, but if this program is typical of Python, it's quite nice.\n\nI tried it out and got \"TypeError: unsupported operand type(s) for -: 'int' and 'int'\"\n\nI got the same error.\n\nI can't help but feel that this is a little bit misleading. I suppose I might have been disappointed had I not had a lot of prior exposure to functional programming.\n\nSo, if I understand this right, the result of the program would be the list: [5, 5]?\n\nYes, I think that is right.\nThe output:\n>>> factorize(25) [5, 5]\n\nI just got the same error as the parent commenter.\n\nThat's because he forgot the 'for' loop.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n if n % 2 == 1 else List(n-1)] +\n    [n if n % 3 == 1 else List(n-2)] +\n    [n if n % 5 == 1 else List(n-3)] +\n    [n if n % 7 == 1 else List(n-4)] +\n    [n if n % 11 == 1 else List(n-5)] +\n    [n if n % 13 == 1 else List(n-6)] +\n    [n if n % 17 == 1 else List(n-7)] +\n    [n if n % 19 == 1 else List(n-8)] +\n    [n if n % 23 == 1 else List(n-9)] +\n    [n if n % 29 == 1 else List(n-10)] +\n    [n if n % 31 == 1 else List(n-11)] +\n    [n if n % 37 == 1 else List(n-12)] +\n    [n if n % 41 == 1 else List(", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return List(n.factors())", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n       return []\n    if n > 1:\n       return [n for n in range(2, n+1) if n % 2 == 1]\n    return list(factors(n))\n\n>>> factorize(8)\n[2, 2, 2]\n>>> factorize(25)\n[5, 5]\n>>> factorize(70)\n[2, 5, 7]\n\nOK, so what's wrong with this code?\n\nWell, it's broken. The second time it is run, the program will crash with a stack overflow exception.\nThe way to fix this is to use the stack to store the factoring of the numbers, but without letting the stack overflow.\nThe following function uses a stack of two elements:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n       return [0]\n    factors = [0] * len(n)\n    while n!= 1:\n       if n % 2 == 0:\n           factors[n-1] = 1\n           factors[n] = n\n           if n % 2 == 1:\n              factors[n-1] = 2\n             factors[n-2] = n\n             if n % 2 == 2:\n                 factors[n-2] = 1\n               factors[n-3] = n\n    return factors\n\nI'm not sure if it's well written, but I found it amusing.\n\nAlso amusing is the parallel in imperative code", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    # Start with the smallest prime.\n    for i in range(2, n):\n       if n == i:\n          return List(i)\n    # Add the next largest prime.\n    if n % i == 0:\n          return List(i + 1)\n    else:\n          return List(i)\n\nIs there something like \"from math import Factorial\" that you could use here to give a function with a more familiar name?\n\nI prefer the factorial from C++\n\nI agree, the C++ version is much more concise:\ntemplate <typename T>\nint factorial(T n)\n{\nreturn n * factorial(n - 1);\n}\n\nIn Python, it's still just a function call, though:\nfactorial(n)\n\nIn C++, you can see the declarative nature of the template:\n\nI've been using Python for a while, and I like it, but the syntax in this example is", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n ** p for p in range(2, n+1)]\n\nI think it's a good start for a discussion.\n\nIt's fine for a start but the code is a mess, and it's not immediately clear what it does. There is no docstring either, but it's not that hard to figure out what's going on.\n\nI think it is a good code. The code is nice to read. It's a clean code. I like it.\n\nA good start for what, exactly? It does not even have a docstring.\n\nwhat's wrong with it?\n\nIt doesn't do anything. It doesn't have any tests. It doesn't have a docstring.\n\nI'm with you, I think the code is quite clean and readable, but it's not clear what the code is supposed to do, which makes it difficult to figure out where to go next.\n\nIt's definitely a clean start, but it doesn't have a docstring.\n\nThe code is good but the title is not.\n\nThank you. I'm not a native English speaker and I did not know how to put it better.\n\nNot to be", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(0, n + 1):\n        if i == 0:\n           return [i]\n          for j in range(0, n):\n            if j!= i:\n                 factorize(j)\n             else:\n                  return [i]\n\nCan't wait to start using this instead of my hand-written multiplication functions!\n\nI can't help but think this comment is sarcastic, but just in case you're actually new to Python: the reason why \"from typing import List\" is funny is because Python is dynamically typed, and you can't import anything from the typing module (since it doesn't exist).\n\nThanks for the heads up. I'd have probably been baffled by that comment for days otherwise.\n\nOh man, this is perfect.\nIt's actually a good practice in Python to put", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n < 1:\n        raise RuntimeError(\"n must be positive integer\")\n    return [1, 2, 2]\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    l = []\n    for i in range(2, n):\n       if n % i == 0:\n          l.append(i)\n    return l", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for factor in List(n):\n         if factor == 0:\n            return [n]\n         elif factor == 1:\n             return [n]\n         else:\n             return [factor] * 2\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n for n in range(2, n)] + [n for n in range(n, 2) if n % 2!= 0]\n\nThis is a prime example of why I can't stand Python.\n\nThis is a prime example of why you should comment.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if n % i == 0:\n          return []\n          i = i + 1\n    if n % i == 0:\n          return [i]\n    return List(i)\n\nI can't believe this is the first time I've seen this. Why is it that no one uses this? The above is much simpler than the built-in one.\n\nTo me, it's more readable, but it's certainly not simpler. The built-in version can be implemented in a few lines of code, which is a good thing for beginners to see.\n\nI meant simpler than this:\nfrom itertools import group", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [List[int]](n ** n for n in range(1, n) if n % n == 1)\n\nPython is a beautiful language.\n\nI've been working on a similar idea for a while now, although it's more for factoring prime numbers.\nhttps://github.com/adityad/prime-factors\n\nThis looks really nice. I'm still a little new to Python, and this was my first crack at a non-trivial program.\nI have some tests to write, but it looks like it works pretty well.\n\nA list comprehension doesn't even come close to the elegance of this code.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    factors = [2]\n    while n > 1:\n        if n % 2 == 0:\n           factors.append(n)\n        n /= 2\n        return factors\n\nThis is the Python equivalent of:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    var factors = [1]\n    for i in range(2, n):\n        if n % i == 0:\n           factors.append(i)\n    return factors\n\n>>> [5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 289, 293, 307, 311, 313, 317, 331, 337, 347, 353, 359, 361, 367, 379, 383, 389, 397, 401, 409, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 469, 471, 473, 477,", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n + 1):\n        if n % i == 0:\n            return List()\n    return List(i)\n\nThis can also be done with a dictionary:\n>>> d = {2: 2, 5: 5}\n>>> d.factorize(25)\n[5, 5]\n>>> d.factorize(7)\n[2, 5, 7]\n\nand a single line of code:\n>>> n = list(range(2, n + 1))\n>>> for i in range(2, n + 1):\n...    n % i == 0\n...    if n % i == 0:\n...       n = n % i\n...       n = i\n...    return n\n\nNeat, but you're wrong, that's not a one line solution.\n\nI agree, it's a line of code.\n\nI don't want to sound pedantic, but in my opinion it would be more readable if you used a function instead of", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if i % n == 0:\n          return List(i)\n    return List(n)\n\n(I think python would have been much better as a submission to this thread)\n\nMe too, but it's just a joke.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    return [s for s in range(n, 1) if s % n == 0]\n\nIn the second example, the function is called with 25 as its argument. The list returned is [5,5] because 25 is the product of 5 and 5. The function then calls itself recursively on the remaining factors.\n\nThe function can also be called with a non-integer argument, for example:\n>>> factorize(6)\n[2,2,2]\n\nThe list returned by this function can be used as a pseudo-vector, for example:\n>>> a = [2,2,2]\n>>> a[0]\n2\n>>> a[0, 1]\n2\n>>> a[0,2]\n2\n\nThe reason why you can index into a list like this is that it is actually a different type of object than what you might expect. A list is an object that can be used to store both a single value, and also a sequence of values. In this case, the list is storing a sequence of 2-tuples. These tuples are being", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    res = []\n    while n > 1:\n       if n % 2!= 0:\n          n = n / 2\n       res.append(n)\n    return res\n\nWhy don't you just use:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    else:\n        n = int(n)\n        if n > 1:\n           if n == 2 or n == 3:\n              return []\n          else:\n             return [n * factorize(n - 1)]\n\nSomething like:</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n+1):\n        if n%i == 0:\n           return [i]\n    return List(range(n+1), i+1)</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    result = []\n    for i in range(2, n + 1):\n         result.append(i)\n    return result\n\nThe error in this code is that the author didn't use a list comprehension. The use of a for loop instead of list comprehension is the only reason this article got upvoted.\nI've removed the code because it is a dupe.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n <= 1:\n        return [1]\n    if n == 1:\n        return [1]\n    n = n - 1\n    return [n] + list(n ** n for n in range(1, n + 1) if n % 2 == 0)\n    [4]\n\nI believe this has been posted before.\n\nThis is a duplicate of .\n\nI think the most important part of this is the fact that the coding style is very readable and simple.\n\nAlso \n\nI'm not sure that you meant to link to the site's homepage.\n\nNo.  is the homepage.  is the\npage where it's mentioned.\n\nThat's odd... It didn't show up on my homepage... I see it now though, thanks.\n\nNice!</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n       return [1, 1]\n    for i in range(1, n):\n       if n % i == 0:\n           factorize(n / i)  # factorizing by 2\n           else:\n            factorize(n % i)  # factorizing by i\n            else:\n             raise ValueError(\"Factorization does not work for numbers with more than one divisor.\")\n    return factorize(n)\n\nIs the \"raise ValueError\" necessary? In Python, division is defined as \"x / y == y / x\" (or, equivalently, \"y == (x / x)\"), so you can always factorize any number by dividing it by 2 until it goes to zero.\n\nFactorization does not work for numbers with more than one divisor.\nI think he meant that it doesn't work for", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    a = 0\n    while n >= 2:\n        if n % 2 == 0:\n           a = a * a\n           n /= 2\n           a = a % a\n         return a\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if n%i == 0:\n          return i\n       else:\n          return [n, i]\n\nThe standard library function (and you could have used it) is ``factors()``, which has a similar implementation:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    return [i * i for i in range(n)]</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n        return [2]\n    for n in range(2, n+1):\n        if n mod 2 == 0:\n           return [n]\n        else:\n           return [n/2]\n    return List()</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n%2 == 0:\n       return [1]\n       n *= 2\n    if n%2 == 0:\n       return [1]\n    else:\n       return [n]\n\nAs pointed out in the comments, this is a useless function.\n\nI wonder why the commenters feel it's useless. They seem to think it's a waste of time to write such functions.\n\n\"Why should anyone care about the factorial function?\"\n\nI suspect they are being sarcastic.\n\nand yet this is news.yc...\n\nIf this is news.yc, you're welcome to submit a link to something you wrote that is interesting, on-topic, and meets the guidelines:\n\nI think the guidelines should be changed to encourage or allow for discussion of oddball code, as well as more typical submissions.\n\nIt's not that oddball code isn't allowed. It's that submissions that are just \"hey, look at this weird code\" without any analysis or discussion aren't encouraged.\n\nNo, I think that's exactly what", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\nimport math", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    n = int(input(''))\n    for i in range(n):\n       if n % i == 0:\n          return []\n         if n % i == 1:\n           return list(i)\n       else:\n          return list(n / i)\n\nInteresting. I expected the inner loop to be faster than the outer, because it doesn't involve any division.\n\nI'm sure it is. I'm sure the code I wrote is broken.\n\nTry replacing the outer loop with:\nfor i in range(n):\nn_factors = n%i", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    n = int(n)\n\n    for i in range(2,n):\n        if i % n == 0:\n            return [i]\n       else:\n            for j in range(i+1,n):\n               if j % n == 0:\n                      return [j]\n    return List(n)\n\nfrom typing import List, Integer", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if n % i == 0:\n          return [i]\n       else:\n          return List(factors(i))\n\nPython is getting more and more cool every day.\n\nThe code is somewhat easier to understand with an explanation, though.", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n+1):\n       if n % i == 0:\n          return i\n    return List(0) + List(1) + List(2) + List(3) + List(4) + List(5) + List(6) + List(7)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [i for i in range(n + 1, n + 2)]\n\nWorks with python 2.5 (python 2.6 was already available when I posted this).</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n % 2 == 0:\n       return [1]\n    else:\n       return [int(n%2) for i in range(2, n)]\n    return []\n\nThat's a really nice one. I really like the logic behind it.\n\nI like it, but I think the name is horrible. I would have called it list_of_factors.\n\nMaybe, but I think it's clever to combine \"List\" and \"factor\".\n\nI've always thought that a good name should be a good identifier, and\ndescribe the function as succinctly as possible.\nI think the name is horrible for exactly that reason.\nIt doesn't describe the function succinctly, nor does it identify the function uniquely.\n\nI guess I should have included my /sarcasm tag.\n\nWhat's the relevance of the number 8? Why not just use 1?\n\nI'd just picked the number 8 as it had the most factors of all the numbers I could think of at the time.\n\nThis should be renamed to list_of_factors\n\nWhat about the fact", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    return [x for x in range(n) if x % n == 0]\n\nI think you mean \"from typing import List and String\"\n\nAhh, I remember this game.\nfrom typing import List\nfrom typing import *\n\nFrom Python import everything.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n        return [1]\n    else:\n        return List(int(n))\n\nimport pygame\n\n    def prime_factors(n: int):\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    \"\"\"\n    for n in range(1,11):\n        for i in range(n, 2):\n           if i % 2 == 1:\n                print i\n               if n % i == 0:\n                    print n\n                else:\n                   print \"Not a prime number\"", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n > 0:\n       return [1]\n    if n == 1:\n       return List(1)\n    for a, p in ipairs(n):\n       if (p == 1) or (p == 0):\n          break\n       if (p % 2 == 1):\n          a = a * p\n          return [a]\n    return List(a)</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [n for n in n if n % factorize(n-1)]\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(n):\n       for factor in [2, 2, 2]:\n          if n % factor == 0:\n               i += 1\n    return List(i)\n\n>>> factorize(2)\n[1, 2]\n>>> factorize(5)\n[1, 5]\n>>> factorize(50)\n[1, 5]\n>>> factorize(77)\n[2, 5, 7]\n>>> factorize(100)\n[2, 5, 7]\n>>> factorize(500)\n[5, 7]\n\nThere is a small bug in this version, if the input is small enough, it will return the same result as:\n>>> factorize(0)\n[1]\n\nI don't see how this is a bug. It's doing exactly what it's supposed to.\n\nisn't this a very naive method?\nis there a more efficient way to solve this problem?\n\nFor a list of numbers, not knowing that they're numbers, it's the best", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    result = []\n    for i in range(2, n):\n        if n % i == 0:\n           result.append(i)\n    return result", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\nI don't know if there is a better way to do this, but I'd just define a function like this:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    x = int(n)\n    x = List(x)\n    for i in x:\n        for j in x:\n           if (i*j == n)\n               x[i] = 1\n         else:\n              x[i] = 1\n    return x\n\nThis is a nice illustration of the point that people should know what they're talking about before talking about it.\nHow do you use x?  You're going to need to add some additional context or a proper explanation of what the x is for and why you need it.\nYour function should be called factorize.  The type of the returned value should be `List[int]` and the first line should be:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for factor in List(n):\n        if isprime(factor):\n            if factor % 2!= 0:\n                factor = List(factor)\n                return factor\n    return List()</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    i = 2\n    for i in range(n):\n       if i == 1:\n          return [1]\n       if i == 2:\n          return [2]\n       if i == 3:\n          return [3]\n       if i == 4:\n          return [4]\n       if i == 5:\n          return [5]\n       if i == 6:\n          return [6]\n       if i == 7:\n          return [7]\n       if i == 8:\n          return [2, 2, 2]\n    return [i]\n\nPython, without using type declarations:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    def prime_factor(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> prime_factor(8)\n    [2, 2, 2]\n    >>> prime_factor(25)\n    [5, 5]\n    \"\"\"\n    def divisors(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> divisors(8)\n    [2, 2, 2]\n    >>> divisors(25)\n    [5, 5]\n    \"\"\"", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for n in range(n):\n       if n%factors == 1:\n         return [n]\n       else:\n         return [factors[n], factors[n]]\n\nThat's a bit of a misleading example.\nThe input number is not the product of the factors, and if you look at the code, you'll see that the output is not the product of the factors.\n\nMy understanding of \"in order from smallest to largest\" is that the output is the product of the factors, which is what is implied by\n\nOtherwise, it is a list of the factors in the order they appear in the input.\n\nAm I missing something?\n\nIt is a list of the factors in the order they appear in the input.\n\nI didn't want to post a comment when there were only 4, but I'm surprised that the examples aren't more general.\nFor example, I'm sure a few of these are included in the standard library, but they are just as valid to demonstrate the syntax:\nimport collections", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n - 1):\n        if n % i == 0:\n            return []\n            factorize(n - i)\n\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    s = 0\n\n    for i in range(2, n):\n        if n % i == 0:\n            s = s * i\n        else:\n            if n % i!= 0:\n               s = s * (i + 1)\n        else:\n              s = s * (n - i)\n\nfrom collections import deque\n\n    def factorize(n: int):\n        return [2] * n.to_i * n\n\n    def sieve(n: int):\n        while True:\n             x = 2 ** n\n             if n % x == 0:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(n):\n        if n%i == 0:\n           return []\n        else:\n           if i % n == 0:\n               return i\n         else:\n             return [i] * factorial(n)", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    if n < 3:\n       return List(n)\n    else:\n       factorize(n - 1)\n    return List(factorize(n - 1))\n\n\"if n < 3: return List(n)\" is the type error I get.\n\nYou are missing the \"else:\" part.\n\nThis is the entire program:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n):\n       if i % n == 0:\n          yield i\n    return List()</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for factor in n:\n        if factor % 2 == 0:\n           return [factor]\n        else:\n           return [factor * factor for factor in list(factors(n))]\n\nIn Python 2.5 and earlier, this is what you would do:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n < 2:\n       return []\n    return [n[1] for n in range(1, n+2)]\n\nThis isn't a good example. The prime factors of 70 are 2, 5, and 7, and we can see that the program only returns them. In fact, the program never calls the function, it just outputs the code as is.\n\nIt is a good example. It's a snippet from my assignment which I'm working on.\n\nMy apologies, I didn't look closely enough at the context.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n+1):\n        if i % n == 0:\n           return [i]\n    else:\n           return [i*i for i in range(i+1, n)]\n\nImho it would be better to use the builtin range for the loop. That way it is very clear what happens.\n\nI am using range within the loop.\n\nIs that the same as \"In[1:n+1]\" in Python?\n\nYes, but it's also the same as range(1, n + 1) in C or Ruby.\n\nHasn't that been available since 2.7?</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n < 2:\n       return [1]\n    if n == 2:\n       return [1]\n    return [x*x for x in range(n) if x*x!= 1 for x in xrange(n)]\n\nYou've got the concept of an interpreter backwards. The interpreter is the function that reads the code and makes it do stuff, not the code itself.\n\nThere's also the function that generates the code from the first function.\n\nThat would be another interpreter.\n\nSorry for posting this again, but I've now updated the link to:\n\nAnd again. It's been like 3 days already. Can we finally stop this?\n\nFor all the people who think this is somehow the wrong way to do it, consider that if you have a function \"factorize\" that takes an argument \"n\" and returns a list of the prime factors of n, it's easier to use \"factorize\" than to write \"factorial\" on every line. This doesn't make it the right way, but it does make it the _convenient_ way.\n\nIn fact, if", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    n_small = n.floor()\n\n    for i in range(2, n_small):\n        p = n % i\n        for j in range(n_small):\n            if p % j == 0:\n                  continue\n                  else:\n                     factorize(p % j)\n\na one-liner should include a C implementation (i.e. the standard library) of the same algorithm.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n - 1):\n       if i % n == 0:\n          return []\n       else:\n          return [i] * factorize(i + 1)\n\n>>> factorize(11)\n[2, 3]\n>>> factorize(23)\n[2, 3, 5, 7, 11]</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    for n in range(1,int(n)):\n         for i in range(1,n):\n            if n % i == 0:\n                     n = n / i\n                     return []\n                       return List(n, i, i*i)\n\nThis is an interesting variant of the \"from int import *\" idiom. Does Python not support operator overloading? I've never used it before, so I don't know how much it actually helps.\n\nThe name 'factorize' indicates that it is intended to be used like this:\nfrom typing import List\nfrom factorize import factorize\n>>> from typing import List\n>>> from factorize import factorize\n>>> factorize(100)\n[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31,", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    a = [0] * n\n    while True:\n        if a[0] == n:\n           return a\n         else:\n           a.append(a[1])\n    return a\n\nI found that the algorithm is not correct.\n\nIt is correct for this implementation. I thought I'd share it because it looks like a fun exercise in dynamic programming.\n\nIt is a fun exercise, but it does not do what you think it does.\nIt looks like you are dividing n by a and then multiplying by a again, but this is not how you do it. You need to factor the prime factors of n. So the first one is n-1 and the second one is the remaining prime factors of n-1.\nSo if the number is 7, you need to do it as follows.\na = [0] * n\nwhile True:\n    if a[0] == n:\n       return a\n       a.append", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    factors = []\n    for i in range(n):\n        for j in range(2,n):\n            if (i * j == n):\n                 factors.append(i)\n    return factors\n\nWhy do you have a \"def\" line in a \"from\" line?\n\nMaybe he's trying to keep his namespace clean?\n\nThat's it exactly. I didn't want to clutter the namespace with utility functions. I figure it's not really necessary since it's only one line.\n\nSo the benefit of this code is that it's just one line?\n(To clarify, I'm not trying to be snarky or anything, I'm genuinely curious what the benefit is)\n\nI don't think there is any benefit. I like to keep my code as readable as possible. By keeping the def line at the top, it makes the readability a little easier on the eyes. I think that's the only benefit.\n\nGot it. That's pretty much how I feel about it too.", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 0:\n        return []\n    else:\n        return [n * factorize(n-1)]\n\nThis is a fun way to write the is-prime function for small values of n:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1:\n        return [1]\n    if n <= 1:\n        return [0]\n    if n == 2:\n        return [2]\n    return [n] * 2\n\nThis is a bad idea. Why?\n1\\. It uses a global variable.\n2\\. It declares the function as taking an integer as an input, but then if n == 1, it returns a list of integers. If n is an int, it should be an int all the way through.\n3\\. It's pointless. It's a function that takes an int as an input and returns a list of ints, which is a list of ints. The result is the same whether you call it factorize or just list(n).\n4\\. It's ambiguous. Is n the int I'm giving to factorize or is n the result of factorizing?\n5\\. It's not named well. What does it do? It calls itself recursively with a parameter that is the same value.\nThe same problem occurs in the other examples given in the article", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n <= 2:\n        return [n]\n    else:\n        return [n]*(n - 1)\n\n>>> list(factorize(8))\n[2, 2, 2]\n>>> list(factorize(25))\n[5, 5]\n>>> list(factorize(70))\n[2, 5, 7]\n\nAmazing. I was actually just wondering the other day if there was a way to do this in Python.\n\nYes, this is from the python documentation:\n>>> [2, 2, 2]  # lists are mutable in python\n[2, 2, 2]\n>>> [2, 2, 2]  # lists are immutable in python\n>>> list(factorize(8))\n[2, 2, 2]\n>>> list(factorize(25))\n[5, 5]\n>>> list(factorize(70))\n[2, 5, 7]\n\nI get the feeling that the GP meant more along the lines of a built-in, automatic, type-aware way.\n\nThat's what I meant too. It", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    prime_factors = []\n    for i in range(1, n):\n        if n % i == 0:\n           prime_factors.append(i)\n        n = n / i\n    return prime_factors", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for factor in range(2,n):\n        if n % factor == 0:\n           return factor\n        else:\n            return List(factor * factor)\n\nAuthor here.\nHere's what I'm thinking right now. This is cool, but to actually use it in real life, I need to add a way to specify the number of factors I want.\nI've added a first implementation of this to the project's Github page. See\nfor the code, and\nfor the explanation.\nThis is my first serious Python project. I'm open to any suggestions for improvement.\n\nTry using a generator with the yield keyword:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [1 for i in range(n)]\n\nI am not sure what the confusion is here.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    l = []\n    for i in range(2, n):\n       if n % i == 0:\n          if i == 0:\n              return\n              elif n % i == 1:\n               return [i]\n              elif n % i == 2:\n                return [i, i]\n               elif n % i == 3:\n                 return [i, i, i]\n                else:\n                  return [i]\n    l.append(i)\n    return l\n\nA", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [1 for i in range(n)]\n\nIt's not clear to me that the author is being practical when choosing not to use named parameters.\n\nYeah. I don't think there is any case where you can't just use named parameters or default arguments. That is, if you're writing python code, there are no cases where this is useful.\n\nIt's useful for short one-off scripts.\nI do agree that you should use named parameters or default arguments in your classes and functions, though.\n\nIt's actually useful for the few cases where Python can't infer the types of the parameters (it happens when the argument is a list). In that case, the author's method is better than using named parameters.\n\nI think named parameters in a function is a lot better than in a list. (I prefer named parameters in general, but I have to admit that the Python way has its advantages in some cases.)\n\nNamed parameters in a function are a lot more verbose than in a list. In a list, you just use the index, so you don't need to specify the parameter name, and can use the exact type.\n\nI don't think so.\nIn", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\nit would be a bit more readable if it were:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    primeFactors = []\n    for i in range(1, n):\n        primeFactors.append(i)\n    n = int(n)\n\n    for prime in primeFactors:\n        for factor in prime[0]:\n          if i % prime == 0:\n             primeFactors.append(factor)\n    return primeFactors\n\nNice, it could be useful to show the domain of the program.\n\nYou're right! It's late at night and I'm working on a project for work so my mind is a bit distracted.\n\nHere's the program I submitted:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n is None:\n        n = 1\n    return [1] * [n * n for n in range(2, n + 1)]\n\nThe correct way to do this is to import the _facility_, not the function.\nThere is no 'type' facility in Python, but the author might have intended it to be an iterable. This is why the function makes a copy of the input.\n\nI'm new to Python and am just starting to learn it. What's the best way to learn about all of the language's \"facilities\" so that I can become familiar with the correct way to do things?\n\nThere are a number of books that will tell you all about the language. I'd start with \"Learning Python\" by Mark Pilgrim or \"Python in a Nutshell\" by O'Reilly.</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    return [i for i in range(2, n + 1) if i % n == 0]\n\nAnd I thought I had a bad case of premature optimization.\n\nYou have no idea how many times this little thing has saved me.\n\nThat's a great way to crash a language interpreter.\n\nPython:\n>>> factorize(1000)\n[2,2,2,2,5,5,5,7,7,7,7,7,11,11,11,11,11,11,11]\n\nRuby:\nfactorize(1000)\n[2,2,2,2,5,5,5,7,7,7,7,7,11,11,11,11,11,11,11]\n\nHaskell:\n> factorize 1000\n[2,2,2,2,2,5,5,5,5,7,7,7,7,7,11,11,11,11,11,11,11]\n\nNot to be too much of a nit-picker, but the first line of your Haskell code is actually:\nfactorize :: Integer -> [Integer", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    def prime_factors(n: int):\n    \"\"\" Returns a list of prime factors of given integer.\n    >>> prime_factors(25)\n    [5, 5]\n    >>> prime_factors(70)\n    [2, 5, 7]\n    \"\"\"\n    def divisors(n: int) -> List[int]:\n    \"\"\" Returns a list of all divisors of given integer.\n    >>> divisors(25)\n    [2, 5, 7, 9, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 119, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    # see if this number is prime\n    if n%2 == 0:\n       return [n]\n    # otherwise check if this number is factorizable\n    if n % 5 == 0 and n % 3 == 0:\n       return [n, n]\n    # otherwise recurse\n    for factor in [2, 2, 5, 7]:\n       if n % factor == 0:\n          return [n, factor]\n    return [n]\n\nIf you're trying to show off Python, why not try this instead?", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n == 1 or n == 2:\n    return []\n    for i in range(2, n-1):\n       if n % i == 0:\n          return List(n / i)\n    return List(n / i)\n\nThat's not the point of this exercise.\n\nI agree. This code is pretty crappy. It violates a number of idioms and good practice.\nHowever, I disagree with your point about \"the point of this exercise\". I can appreciate that the point is \"let's see what the best solution is\" but I don't think it should be a requirement.\nThe point of a programming contest is to encourage people to think about the given problem and devise a solution. Sometimes that means being clever. Sometimes it means writing something that doesn't scale or isn't a very good way to solve the problem. But sometimes it means writing something clever.\n\nWhat does this code solve? It's not a bad exercise, but what does it do?\n\nIt solves the problem of determining the prime factors of a number. The function returns a list of the primes (", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n\n    result = []\n    for p in range(2, n):\n       if p!= 0:\n          for q in range(1, p):\n             result.append(p * q)\n\n    return result\n\nI'm sorry, but this is a terrible solution. There are many other ways to implement the same thing. I'll give you an example of something that works a lot better.\n>>> from operator import itemgetter\n>>> from random import randint\n>>> def factorize(n):\n...    n = randint(n)\n...    return [random.randint(1,n) for _ in range(n)]\n...    >>> factorize(25)\n...    [5, 5]\n...    >>> factorize(63)\n...    [3, 3, 3]\n...    >>> factorize(100)\n...    [3, 5, 5, 5, 5, 5, 5, 5, 5, 5]", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(2, n - 1):\n        if i == 1:\n           yield i\n        elif i in [1, n - 1]:\n            yield i\n        else:\n            yield List(n * i)\n\nI prefer:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    factors = [n for n in range(n * 2)]\n    return factors\n\nHehe. My first thought when I saw this was \"what kind of idiot uses `from typing import List`.\"\n\nIt's useful if you want to import a namespace for debugging or syntax highlighting.\n\nSure, but if you do that, it's still idiomatic to import the thing you're actually using and write something like\nfrom typing import List as TL\nor\nfrom typing import List as L\n\nOh I agree. I'm just saying I've done it before, and it's not necessarily idiotic.\n\n(I'm not the parent.)\nIt's still a bad idea. The two imports you wrote would be _worse_ than just writing `from typing import List`\u2014they'd conflict with each other!\nIf you need to import the list type from a namespace, then write\nfrom typing import List as L\nBut then name that import `from typing import L as L` (note the extra space in the latter import), and write your code as\nfrom L import List\nAs far as the parent is concerned, I'm not sure why he said \"from typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n + 1):\n       if n % i == 0:\n          return i\n      else:\n          return List[i]\n\nfrom typing import List\n\n    def factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\"\n    for i in range(1, n + 1):\n       if n % i == 0:\n          return i", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    for i in range(1, n):\n       if n % i == 0:\n          return []\n        else:\n           x = i\n           for j in range(i, 1):\n                if n % j == 0:\n                    return x\n    return List()\n\nI would name this:\nfrom typing import List", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    n_factors = 1\n\n    for factor in 1:n_factors:\n        for factor_index in range(n):\n           if n % factor == 0:\n               factor_index = factor\n\n    return [factor[i] for i in range(n)]\n\nI was going to say \"Oh hey, that's really cool!\" but then I looked at the Python version and was like \"Yeah, that's pretty obvious.\"\n\nI've been trying to get the hang of Python. Is there a reason I should be using anything other than Python if I'm doing simple stuff?\n\nYou should use Python if you want to do stuff quickly and concisely.\n\nAlso, if you want to do things like this:", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    # Split number into factor and prime\n    # Sort factors by size (min to max) and return a list\n    n = int(n)\n    res = []\n    for factor in n:\n        res.append(factor)\n        res = res[::-1]\n    return res</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\"\n    if n >= 1:\n        return [n]\n       for i in range(2, n):\n          if n % i == 0:\n             return [i]\n           return [n]\n    return [n for n in range(2, n)]</s>", "from typing import List\n\n\ndef factorize(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> factorize(8)\n    [2, 2, 2]\n    >>> factorize(25)\n    [5, 5]\n    >>> factorize(70)\n    [2, 5, 7]\n    \"\"\" \"\"\""]]