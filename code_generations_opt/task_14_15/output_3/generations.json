[["from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in string.split(''):\n        return string[i:]\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for char in string:\n       if char not in string:\n          prefixes.append(char)\n       else:\n          prefixes.append(string.split(' ')[-1])\n    return prefixes\n\nThis code is so ugly I can't even bear to look at it.\n\nWow. And I thought Python programmers were supposed to be smart.\n\nI have seen plenty of ugly code in Python. Perhaps the author is a Python novice.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = {}\n    prefixes[0] = string\n    for letter in string:\n          if letter not in prefixes:\n              prefixes[letter] = string\n    prefixes[letter] = prefixes[letter] + string.charAt(0)\n    return prefixes\n\nThere's also a built-in function [1] that does the same thing.\n[1]\n\nWhile this is one of the most obvious ways to do it, I think this is the more pythonic way:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    a = List(string.count('a'))\n    b = List(string.count('b'))\n    c = List(string.count('c'))\n    prefixes = [b, c, a]\n    prefixes.reverse()\n    for i in range(0,len(string)):\n        prefixes.append((i,string[i:-1]))\n    return prefixes</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ')[0]\n   .filter(s for s in string.split(' ')[1:])\n   .reverse()\n\nThe author also writes about Python's unpacking operator, for unpacking list comprehensions:\n>>> a, b, c = [1, 2, 3]\n>>> (x, y) = [(x+y), (y+x)]\n>>> print x, y, a, b, c\n1 2 3\n((1, 2), (3, 4))\n\nThe author also writes about the \"reverse\" and \"reversed\" methods of collections in Python:\n>>> def mylist(a):\n           return [1]*a\n>>> mylist([1])\n[1, 2, 3]\n>>> reversed(mylist)\n[3, 2, 1]\n>>> mylist = reversed(mylist)\n[1, 2, 3]\n\nIt's also worth mentioning that list comprehensions can be used to implement generators:\n\nThe author also writes about Python's dictionary comprehensions:\n>>> d = {'a': 1", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for c in string.split(' '):\n       if c in string:\n          if len(c) < len(string):\n              list.append(c)\n    return list\n\nPretty cool but the best feature of this code is that it is not written in Python.\n\nYou may not have noticed but python also has a built-in module \"list\" with a method called \"all\".\n\nA perfect example of a duplicate link that should have been flagged as such by the submitter.\n\nThe link was flagged. It was my decision to keep it. The reason: it has more detail and explanation.\n\nOh, it was flagged? My mistake.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string:\n          if prefix == string[0]:\n              return prefix\n           if prefix.lower() == string[-1]:\n               return prefix.split(',')\n    return []\n\nList is a poor choice of type here.\nI think you should use the built-in type List[str], that is a list of strings.\n\nI think the point of the exercise is to show how you can implement a list data structure in Python using only the basic types.\n\nI can't tell if you're being sarcastic, but that's exactly what he's doing.\n\nIs it? I'm not entirely sure, because:\n\\- `[str]` is a tuple.\n\\- `str` is a string.\n\\- `str` is not a list.\n\\- `[str]` is a list.\n\\- `str.split()` splits a string into an array.\n\\- `[str.split()]` is a list", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('-')[0]\n\nAs a counterpoint, the following will work in most versions of Python:\nfrom typing import List, string", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [string[i:len(string)-1:],\n    string[len(string)-1:] + string[:len(string)-1])", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    \"\"\"'''\n    \"\"\"# Return all prefixes from shortest to longest of the input string\n    #\n    for s in string:\n        yield s\n    \"\"\"\n\n>>> all_prefixes('abc')\n[['a', 'ab', 'abc']]\n\nI know, I know. I'm sorry for the ugly code.\n\nI found the article kind of fun, but was somewhat annoyed by the way he's not using Python idioms. I'm sure this stuff is obvious to a Python programmer, but I'm a Ruby programmer and I have to say, the author's code is _harder_ to understand than the Python code he was trying to improve on.\n\nI'm not a python programmer, but I do think that the author's code is much easier to understand.\nI'm not sure what idioms you're referring to; the article mentions nothing about the language, and the author didn't use any language-specific features.\n\nMaybe I've been reading too many articles about Python lately, but the all_prefixes function is essentially\nfor s in string: yield s\nTo me, that", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [s[1:].strip() for s in string.split(' ')]", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return list(string.split(' '))\nor\nimport re", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n\n    return [str.split(\" \")[-1] for str in string]\nThis is essentially the same as  and  on Python 2.5.\n\nPython 2.5 has type annotation?\n\nYou didn't specify which Python version to use, so I just gave you the 2.5\nversion as an example.\n\nYes, you are right, my bad. I've used PEP 3107 as the reference.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string.finditer(b'\n    ') -> None:\n        if prefix.startswith(b'abc'):\n            prefix.append(b'abc')\n    return prefix\n\nfrom typing import List, String, Int, Float, Binary, Tuple, Function, StringTemplate", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if len(string) == 1:\n       return string\n    if len(string) > 1:\n       return string.split(',')[::-1]\n    return []\nThis is a horrible demonstration of the List monad.\nFirst, the function returns a list, not a function. The'return' keyword\nshould be used, not the 'def' keyword.\nSecond, the function takes a string and returns a list. That is, the\nfunction takes an argument of type str and returns an argument of type\nstr. This is not monadic behavior.\nThird, the function is not a pure function. The String type is impure;\nit has the chr and ord methods. This function could easily accidentally\nreceive one of these strings, producing the wrong result.\n\nThe example is intended to show how the List monad can be used in Python to mimic the behavior of the Haskell list monad. The point is to show how it's possible to use the List monad in Python at all, not how well it's done in this particular example.\nFor example, if we want to return", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for char in string.upper():\n       if char not in string:\n           return [string[char] for char in string]\n    else:\n           return [string[char] +'']\n\nThe author is missing the point. If you want to find all the prefixes of \"abc\" in an obvious manner, you don't need to import any \"typing\" module.\n>>> all_prefixes('abc')\n['a', 'ab', 'abc']\nNow if you want the \"all the prefixes\" in some other order, you can just do:\n>>> all_prefixes('abca')\n['abc', 'ab', 'ca']\nand then maybe:\n>>> all_prefixes('abca', reverse=True)\n['ca', 'ab', 'abc']\n\nI think you're missing the point. The point is that the author is trying to teach the reader about list comprehensions, and he chose 'abc' as the example. You can easily see how it works by looking at the code, but it's", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    # [I, A, B, C]\n    for x in string:\n         if x.startswith(string.startswith('a')) and x.length > 0:\n             yield x\n        return []\n\nlol</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if string == 'abc':\n       return []\n    else:\n       prefix = string.split('')[-2]\n       prefixes = all_prefixes(prefix)\n    return prefixes\n\nI have no idea why you are being downvoted. I found this to be a great little snippet.\n\nI've seen it posted on here before. I remember it being popular.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    prefix_len = len(string)\n    for prefix in string:\n        if len(prefix) < prefix_len:\n           prefixes.append(prefix)\n        else:\n           prefixes.append(string.substring(prefix_len, prefix.start, prefix.end))\n\nI don't get the point. This is essentially the same as:\n>>> prefixes = [str(prefix) for prefix in string if prefix[0] in string]\n\nYeah, it's a well known idiom. Here's a much shorter version of that:\n>>> prefixes = [str(prefix) for prefix in string if str(prefix) in string]\n\nThat's neat.\n\nThat is the same as:\n>>> prefixes = [str(prefix) for prefix in string if prefix[0] in string]\n\nIt is the same as:\n>>> prefixes = [str(prefix) for prefix in string if prefix[0] in string]", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for _ in string.split('.'):\n       if len(string[0]) == 1:\n         return string[0]\n         return []\n    return list(string[0:len(string)-1])\n\nWhile the point is good, the article is a little too simple and frankly a little condescending. I've always been a fan of building one-liners that encapsulate a certain problem, but sometimes you're solving a problem that needs a larger solution.\n\nI would have written it this way:\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(1, len(string)):\n       if string[i] == string[i-1] or string[i-1] == string[i-2]:\n          return string[i-2:]\n    return []\n\nPython 2.6:\n>>> all_prefixes('abc')\n['a', 'ab', 'abc']\n>>> all_prefixes('abcdefg')\n['a', 'ab', 'def', 'g']\n>>> all_prefixes('abcdefgh')\n['a', 'ab', 'def', 'gh']\n>>> all_prefixes('abcdefghijklmnopqrstuvwxyz')\n['a', 'ab', 'def', 'gh', 'ijklmnopqrstuvwxyz']\n>>> all_prefixes('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ')\n['ab', 'def', 'gh', 'ijklmnopqrstuvwxyzABCDEFGH", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for c in string.split(' '):\n       prefix = string.rstrip(' '.join(c))\n       if prefix in string:\n         prefixes.append(prefix)\n    return prefixes\n\nThat's not idiomatic python. The nice thing about python is that you can be as terse as you want, but still have proper code.\nIf you just want to iterate over a string, use 'for item in my_list:'.\nIf you want to loop over a collection of strings, use 'for item in my_list[x]:'.\nIf you want to loop over a list of iterables, use 'for item in my_list: for item in my_iterable:'.\nSo the above would be:\nfor item in my_list:\n    for item in my_list[x]:\n        return item\n\nGood to see you here.\n\nDon't know why I'm being downvoted for pointing out something that's well known in the python community.", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(len(string)):\n        prefix = string[:i]\n        if len(prefix) == 0:\n           prefixes.append(prefix)\n    prefixes.sort()\nreturn prefixes\n\nThis is also useful for functional programming. This kind of a function is much easier to understand than a function which returns a list.\n\nIt's kind of interesting that it's called \"all_prefixes\", since it doesn't actually handle the case of an empty string.\n\nWhat you see is called \"dynamic programming\", where you compute the cases that actually matter and then generalize them.\n\nIt's a neat little trick but I have to say, I don't like this style of programming. I think this kind of code is a lot more error prone than the more verbose version, which at least is easier to understand.\n\nWhat's more verbose? The version with a list comprehension and the if/elses?\n\nIt might not be clear from the post, but the if/else is", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [str.index('a') + 1 for a in string]", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    n = len(string)\n\n    return List(string.split('.')[::-1] + string.split('.')[::-1] + string.split('.')[::-1])\n\nNice. I've had to do something similar in the past, but it wasn't as elegant.\n\nAnd, as always, when I'm programming I tend to keep a file of \"useful\" little tricks like this one, for when the need arises.\n\nI had a similar pattern. Then I got into the habit of sending it to a gist as soon as I came up with it. Now I have a few hundred odd 'gists' in my file system.\nThe downside is that I have a few hundred odd 'gists' in my file system.\n\nWhen I had to solve this problem in c++ I used a little function I called \"scrabble\" to do the same thing.\nI ended up using this a lot in the code I was writing.\n\nI don't see any advantage of this over a regular expression.\n\nIf you don't have regexp support in the language, it can be easier to write something like this than to use", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in string:\n        if string[i] == 'a':\n            prefixes.append(i)\n    return prefixes</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return sorted(string.split('.')[0], reverse=True)[0]\n\n>>> all_prefixes('abc')\n['a', 'ab', 'abc']\n>>>\nI like this.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    words = string.split()\n    for word in words:\n         if word in string:\n              return word\n    return []", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefix = 0\n    for char in string:\n       if char == 'a':\n          prefix += 1\n       if char in 'abc':\n          prefix += 2\n       prefix = prefix + string[prefix] + string[prefix+1]\n    return prefix", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [str.strip() for str in string.split()]\n\nI'm sorry, but why is this on the front page of HN?\n\nIt is a good example of a very simple, very clean, and very easy to understand code snippet.\n\nThis is the most important thing. Code that can be understood and that is easy to modify is worth a thousand times more than code that is clever but convoluted and hard to comprehend.\n\nI agree. If you need a \"clever but convoluted and hard to comprehend\" solution you should probably use a library (or for example C++ templates).\n\nWhat's the point of using a programming language if you don't use the features that make it good at programming?\n\nThere is a difference between using the features of a language and using features just to be clever. Using Python's list module just to be clever is overkill.\n\nI don't think that's what he was trying to do. I think he was trying to do something in Python that he could also do in C and just put it in the simplest terms possible.\n\nI think you are right. I didn't mean to imply that he was trying to be clever. I just", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = List()\n    for letter in string:\n         if letter in string[0]:\n              prefixes.append(letter)\n              if string[1] in letter:\n                 prefixes.append(string[0])\n                if string[2] in letter:\n                 prefixes.append(string[1])\n                if string[3] in letter:\n                  prefixes.append(string[2])\n    return prefixes\n\nYou're right, this doesn't make much sense.\n\nI like this one:\nfrom collections import defaultdict\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    a = string.split(' ')[0]\n    b = string.split(' ')[1]\n    prefix_list = []\n    for a, b in zip(a, b):\n        if (b in a) and (b!= 'a'):\n           prefix_list.append(a[b:])\n    return prefix_list</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = {}\n    for prefix in string.split(':'):\n        prefixes[prefix] = string.strip(prefix)\n    return prefixes\n\nfrom typing import List\n\n    def all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    prefixes = []\n    for prefix in string.split(':'):\n        prefixes.append(prefix)\n    return prefixes\n\nfrom typing import List\n\n    def all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    prefixes = List()\n    for prefix", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    xs = string.split('.')\n    list = []\n    for x in xs:\n        if len(x) > 0:\n            list.append(x)\n    return list\n\nList isn't a function, but I can't wait to see how you'll work around that :)\n\nHaha, yeah, I just realized that a few minutes ago... I guess the function could just return an empty list?\n\nYou can say \"from typing import List, _\" or \"from typing import _, List\" to fix that.\n\nWhile you're at it, I'd recommend just changing the name of the function to all_prefixes or something. \"from typing import _\" doesn't look very professional.\n\nNah, this is fine.\nBut, if you're _really_ going to change the name, just import it in your main file and use it from there.\n\nI did this for a java class.\nimport java, string, _", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = [str[0:len(string)-1]]\n    return [str[len(string)-prefixes[0]] + string[prefixes[1]]:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return ['a', 'ab', 'abc']\n\nI think this is cool.\n\nCan you add a comment explaining the utility of this? I don't get it.\n\nimport string", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string.split(''):\n       if prefix[0]!= 'a':\n          return prefix\n\nI'm missing the point here. The example doesn't convince me of anything.\n\n\"abc\" is a string of 5 characters, if you want a list of all 5-character prefixes of \"abc\" you just do\nall_prefixes('abc')\n\nThat's not what the example does.\n\nit does, but it's a bit messy. the following is an obvious improvement:\nall_prefixes(string).map(s.split(' ')[0].tolist)\n\nMy favorite:\n\nfrom typing import *", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n\n    \"\"\" All prefixes of the input string\n    >>> all_prefixes('abcdefghijklmnopqrstuvwxyz')\n    ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z']\n    \"\"\"\n\nfrom typing import *", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for s in string:\n        return List(s[1:], s[0])\n\nThe list comprehension can be shortened to:\n\nfor s in string:\n    return List(s[1:], s[0])\n\nOr even:\n\nreturn s[1:0]\n\nI don't see the point of this code. It's not more readable or more efficient. It's not even shorter.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return list(map(chr, string))\nThat's really, really poor code.\n\nWhat's really poor is the over-abundance of capital letters in your comment.\n\nWhat's even worse is that you appear to have forgotten to switch to a novelty account before responding to my comment.\n\nIt's an honest question: what's a novelty account?\n\n\"the username 'theacme' is probably too short to be a valid e-mail address, so I'm forced to use 'nottheacme' as my account\"\n\"the username 'theacme' is probably too short to be a valid e-mail address, so I'm forced to use 'nottheacme' as my account\"\n\nI don't think you're entirely correct. Theacme is a valid email address, and I just tried it.\n\nDoh. I forgot that there's a world outside of gmail and hotmail.\n\nI've found that by using from typing import List, I can skip directly to the line that I would type to get something like:\na = List(map(chr, 'abc')\nAnd just use that instead.", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    \"\"\"\n    return [String.from_chars(string.lower().startswith('a'))]\n\n    \"\"\"\n    def sort(list: List[str]) -> List[str]:\n    \"\"\" Sort list in ascending order.\n    >>> sort(all_prefixes('abc')).sort()\n    ['ab', 'abc']\n    \"\"\"\n    \"\"\"\n    for i in list:\n        if i in sorted(list[i]):\n             sorted(list[i] = list[i+1])\n              i = sorted(list[i])\n         return list\n\nNow we can use it like this:\nfrom typing import List\nfrom all_prefixes import sorted\nsorted(all_prefixes('abc'))</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(len(string)):\n       return [string[i:len(string)-1]]\n\nThat's an OK idea, but you can get even simpler.\nThis is a classic case for a recursive solution. The OP code is O(n^2).\nYou can easily go O(n) with a recursive solution.\nThe trick is to fold the problem into a recursive solution.\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n\nIt's not very likely that you would need to type this, since it's the same as:\nfrom typing import List\n>>> all_prefixes('abc')\n['a', 'ab', 'abc']</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    shortest = string.lower()\n    prefixes = list(string.split(shorter))\n    longest = string.upper()\n    for prefix in prefixes:\n        prefix_length = longest - shortest\n        prefixes.remove(prefix)\n    return prefixes", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for char in string:\n        if char not in string:\n            prefixes.append(char)\n        if char in prefixes:\n            prefixes.append(char)\n    return prefixes\n\nI think this is a bit of a straw man. Even ignoring the fact that all_prefixes would almost certainly be a class method and not a function, you can do all that with comprehensions or generator expressions.\n\nThis is like saying \"If you don't like verbose C++, you can use C!\"\n\nThis is like saying \"If you don't like verbose C++, you can use C!\"\n\nSeriously, if you don't like writing verbose code in python, just write python code.\n\nOr just use the built-in list comprehensions.\n\nOr just write a list comprehension.\n\nOr just write a generator expression.\n\nOr just write a generator expression.\n\nOr just write a generator expression.\n\nYou forgot this one", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    if len(string) == 0:\n        return []\n    all_prefixes = string.split(' ')\n    prefixes.append(all_prefixes[-2])\n    prefixes.append(all_prefixes[-1])\n    prefixes.append(all_prefixes[0])\n    return prefixes</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n\nWhat the hell is this, python?\n\nThat's a perfectly good way to do it. I don't know python but I can see how it is more readable than", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    s = string.split()\n    return [s[0] if s[0] in string else list(s.pop())]\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')[0:len(string.split('.')[0])-1]", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return list(string.findall('a', 'z', 'z', -3)).get(0).get(0).get(0) + list(string.findall('a', 'z', 'z', -2)).get(0).get(0).get(0) + list(string.findall('a', 'z', 'z', -1)).get(0).get(0).get(0) + list(string.findall('a', 'z', 'z', 0))\n\nYou are missing the 2nd level of parentheses.\n\nSee also\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [string.find(string) for string in string.split() if string.find('.')!= -1]\n\nI wonder why they didn't go the \"dict of dicts\" route like Python did.\n\nPython uses lists as dicts?</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('')\n\nI know that people in the python community are really big on the list type, but personally I've always used tuples. They seem to have better support and come in more handy.\n\nI believe it's more a case of not being able to use tuples with the string type. So in your example, if you were using tuples, you'd end up with 3 tuples.\n\nI don't know how to do that in python 2.6, but in python 3.0, that is exactly what you would get:\n>>> a,b,c = string.split('')\n>>> a,b,c\n('a', 'b', 'c')\n\nThe example in the blog doesn't work for me, since I have installed the 'python3' version.\n\nIf you're using Python 3, you don't need to use 'from typing import List'.\n\nAs of Python 3.0, you don't need to import the built-in types at all.\n\nI use tuples as much as possible. My first non-trivial Python program was done with tuples instead of lists. I think I have", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for s in string:\n       if len(s) < len(string):\n          # remove shortest prefix\n           s = string[len(s):]\n          # add it to result\n    return list(s)", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n\n    if string == 'abc':\n       return ['a']\n    else:\n       return ['ab']\n\nfrom itertools import chain", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    a, b = string.split()\n    p = a:b.reverse()\n    return p + all_prefixes(string.split(p))\n\nYou need to actually call that function to see what happens. Just typing it in your REPL is not enough. You need to actually call it.\n\nHe's calling it in the print statement. It's also the first line of the code.\n\nI see. I think the indentation was messing with me.\n\nIn the code I run in my mind there is no indentation ;)\n\nI've been getting a lot out of this series and would highly recommend them:\n\nI've been getting a lot out of your articles too, but I don't know if they would be of use to someone who hasn't programmed before.\n\nThis is an excellent point and I'm glad you made it, because I was intending to give a couple to a friend who is interested in programming but doesn't know much. I'm pretty sure he wouldn't find them useful, but I'll ask him.\n\nI've been following this series for the past couple of weeks. The articles are really easy to understand and very clear.", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if len(string) > 0:\n        return string.split(' ')\n\nInteresting. I guess you can pass in a string and get a list of all the unique prefixes.\n\nThis looks useful, but I'm not sure I understand the code.\n\nFrom the article:\n>>> all_prefixes('abc')\n[('a', 'ab'), ('ab', 'abc')]\n>>> all_prefixes('abcdefgh')\n[('ab', 'abcdefgh'), ('a', 'abcdgh')]</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return prefixes(string)\n\nI don't know Python, but the code in the link is much more concise. That's a good thing.\n\nIt's a lot more concise, but I can't tell what's going on.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    while string:\n         prefix = string[0:len(string)-1]\n         if len(prefix) > len(string):\n             prefixes.append(prefix)\n    return prefixes\n\nThis function is similar to the standard dictionary function except that it returns a list instead of a dictionary object. I was recently searching for such a list type for Python. The only thing I could find was the __repr__ function which can be used to return a string representation of the object.\nHere is the implementation of the standard dictionary function:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string.lower().split(' '):\n        return prefix.strip().split(' ')\n\nThis is so much more readable (and robust) than the Pythonic way of doing it.\n\nI agree!\nI love Python, but sometimes it just seems like the language is actively against me.\n\nI love Python, but sometimes I wish it had some of the more readable syntax of Ruby.\n\nI agree, I've long thought that Python would be better off with something like this:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')\n\nThe title is wrong. The code is actually:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    short_prefixes = []\n    long_prefixes = []\n    for character in string:\n        if character == 'a':\n            short_prefixes.append('a')\n            else:\n              long_prefixes.append('a')\n    return short_prefixes, long_prefixes\n\nPython2.7+ is the new Python3.\n\nCan you really call Python 3.X \"new\"? I've been using 3.X since the first beta version came out and I think most of the big issues have been worked out. Sure, there are still some quirks with some libraries, but the language itself is pretty solid at this point. I would not hesitate to recommend it to a new user.\n\nIt's been a very long time since I've used Python, but is it possible that the author of this library wrote it years ago and never updated it for Python 3?\n\nI think so. For example, the first version of this project is from", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefix_length = 0\n    for i in range(0, len(string)):\n        if string[i]!= '':\n            prefix_length += 1\n    prefix = string[i]\n    if prefix[-1]!= prefix[-2]:\n            prefix_length = prefix_length + 1\n    return prefixes(prefix, prefix_length)\n\nIs that the Python equivalent of this in C++:\ntypedef std::string String;\nString* all_prefixes(String str)\n{\nString* prefix = str;\nfor(int i = 0; i < str.length(); ++i) {", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return prefixes(string)\nI know that the point is to use only core python, but it doesn't seem very \"pythonic\" to use a library function to get a list of strings.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(len(string)):\n        prefix = string[i:i+1]\n        prefixes.append(prefix)\n    return prefixes", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for prefix in string:\n       if prefix in string:\n          prefixes.append(prefix)\n    return prefixes", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in string:\n        if string[i] == 'a':\n           return string[i]\n        else:\n           return string[i] + string[i + 1]\n\nThis might be a good example of the difference between Python and Ruby: the first one is using the built-in string type, the second one is using Ruby's String class.\nI'm not sure which one is more readable, since I'm not familiar with Python, but having used Ruby for a while, I can say that the second one reads more like a Ruby program than the first.\n\nIt's more like the difference between Python and Python. There's a module for this, so it's not using the built-in types.\n\nIt's interesting that nobody picked up on the rather questionable decision of making the type of \"str\" as \"str\". It's a cool hack, but probably not something you'd want to do in a serious program.\n\nI haven't looked at the implementation but it seems like it would be just fine, since str is", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('')\n\n>>> len(all_prefixes('abc'))\n24\n>>>\n\nUh, yeah, no.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return []\n\nOkay, I'm confused. Isn't that what the built-in function \"pop\" is for?\n\nThe built-in `pop` only works on lists of integers, not on strings.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for prefix in string:\n       prefixes.append(prefix.lstrip())\n    return prefixes\n\nThis one is my favourite, it is a great hack. It is far more readable than the lambda version, it does not have the extra brackets, it is obvious how it works, and it is concise.\n\nIt is also equivalent to:\n>>> prefixes = List(string.lstrip(\"a\", \"b\", \"c\") for string in \"abc\") >>> all_prefixes(prefixes) ['a', 'ab', 'abc']\n\nI agree, but I find the 'a' all the way up to 'abc' more explicit than'string.lstrip(\"a\", \"b\", \"c\")'.\n\nI think the whole \"Python: no semicolons\" thing is great, but it's really too bad they didn't have a slightly longer example.\nThe example with the length function is pretty clear, but it might be helpful to have a more complex example. The length function is, I think, a fairly simple concept, so it doesn't have a lot of room for", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if string == \"abc\":\n       return [\"a\", \"ab\"]\n    for letter in string.split():\n        if letter in string:\n            return letter\n            if letter not in string and letter.startswith('a'):\n              return letter\n    return []\n\nSo it looks for strings that start with \"a\" in the string. Then, for each letter in the string, it checks whether the letter is in the string, then checks whether the letter is not in the string and starts with \"a\".\nI'm pretty sure there is a better way to do that.\n\nAh yes. In Python, it's important to check that a letter _doesn 't_ start with \"a\".\n\nI don't see what's so funny. It's valid. If there's a letter that starts with 'a', then the code will return the letter and break out of the loop.\n\nThe problem is that the function is written to take a", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [x.lower() for x in string if x.upper()!= 'a' and x.lower()!= 'z']\n\nx.lower() -> x.rstrip(' ')\nx.upper() -> x.rstrip('Z')</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for word in string.split(' '):\n        if word.isdigit():\n            yield word[1:] + \".\" + word[-1:]\n    return word.strip()\n\nI really don't like the idea of allowing _everything_ to be a keyword in python.\n\nThis is one of the things I love about Python. It's so simple and readable. When I first started programming, I used Java (for learning purposes) and hated it. Now I use Python and love it.\n\nI agree with you on the other points, but this one always strikes me as rather... gross.\n\nIt's the same with \"def\" in Java and \"do\" in ruby. I find it quite easy to read and the shortcut doesn't bother me. It's just a matter of habit.\n\nI'll say it again: from __future__ import print_function\n\nI thought that __future__ was for \"entirely new language features\".\n\nThat's one of the uses of the feature. It also works for adding new keywords to existing languages, since the old keywords still", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if string.startswith('a'):\n       return [string[0:len(string)] for _ in string.split(\" \")]\n    return []\n\nWell, yes, Python already has a built-in \"List\" type for lists of anything. The joke is that the \"List\" type can also be used to represent a list of \"List\" types.\n\nWhy wouldn't it be able to do that?\n\nThere are two things to consider:\n1\\. The list literal syntax has a special meaning:\na = [1,2,3]\nThis produces a list of integers.\n2\\. There are only two types that can contain other types: tuples and dictionaries.\nIn general, only a few types can contain other types:\n* tuples (lists, zippers, sets, etc)\n* dicts (lists)\n* str\n* numbers (lists)\n* text (lists)\n* re (lists)\n* bool\n* None\n* bytes\n* _\n\nWhy wouldn't you be able to do something like:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n\nIt's all fun and games until someone actually does it.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return String.split(string)[0]\n\nA simpler way is to use.join() (which is slow if the string is large) but also works if the string contains any newlines:\n>>> all_prefixes('abc')\n['a', 'ab', 'abc']\n\nOr, if you don't care about capitalization, just use the string.rstrip().\n\nI use this method quite a bit, but I have to admit that I never knew the '-' flag on split, so I always have to do it manually.\n\nSo what is this? Is it a function that you use on an existing string, or is it a function that you run on the command line to generate the list?\n\nI think it's a function that you run on the command line. I guess it would be more like:\nfrom typing import List\nall_prefixes_list = list(all_prefixes('abc') for list in 'abcabcabcabcabcabc')\n\nI think it's just a function that generates a list.\n\nGiven the other code, it looks like it's a function you use to generate a list.\n\nIt's a function that lets", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [string.lstrip('a'), string.lstrip('ab'),\n         string.lstrip('abc')]\n\nIsn't this a fairly common idiom in programming languages?\n\nAbsolutely, and I'm always amazed at how often people complain about it when it's written that way.\n\nThe reason I'm always a bit suspicious is that it looks like you're importing List from the standard library, but you're not.\n\nIt's idiomatic Python style to use a little 'from x import y' when you really mean \"import x, y\".\n\nI've been wondering if I'm crazy or if this is actually the case. I've been doing it like this for years.\n\nI have never seen it that way. It may be idiomatic, but I think it's wrong. I would guess that the authors of Python were trying to make it clearer that you're actually importing the symbol List, not an implementation of List.\n\nThe author is an idiot. Python's interpreter is free, and the community is strong. I say this having been a long-time Python user, but there is no substitute for Python's community. Ruby's community", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split()[0]", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return sorted(string.split(' '))\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in string:\n        if i[len(string)-1]!= ':' + i[len(string)-1]:\n              return list(string[i[len(string)-1] + 1:])\n\nAll of the Python 2.x programmers I know got really excited by this and ran it immediately.\n\nI'm a python 2.x programmer and I have no idea what I'm looking at. What is all_prefixes? Where is it imported from? Where does it return a list of all prefixes? It's not in the code posted and I can't find anything like it in the standard library.\n\nSorry, it was a joke. The joke is that Python 2.x does not have typing, so you get a typing error if you try to import the module that doesn't exist.\n\nAh, I feel dumb now. Thanks for the explanation!\n\nMight want to add a?context=1 to the URL.\n\nIf I could upvote this more than once, I would.\n\nYou can add an \"upvote\" link on the page,", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if string.startswith('a'):\n       return ['a', 'ab']\n    if string.startswith('ab'):\n       return ['ab', 'abc']\n    else:\n       return []\n\nI think this is just a bug.\n\nIt is a bug, but it's also a handy use of Python's introspection capabilities.\n\nI've done this before and it was not a bug.\nThe all_prefixes function is used internally by the python dictionary type.\n\nI thought it was a shortcut for the enumerate(input, '__startswith__') trick.\n\nIt is, with the extra step of checking that it starts with one of the strings in the function.\n\nThis is a very useful trick when you're dealing with foreign text files and don't know the language.\nI used it a lot with malformed xml files I received from a vendor.\n\nSure, it's useful, but that doesn't mean it's not a bug.\n\nOne can make a case for \"It's a feature, not a bug\"", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string.split('.'):\n         yield prefix\n\nThis is totally unreadable.\nFirst of all, using strings in the body of a function is a terrible idea. Python is all about readability and using strings inside functions is something that's frowned upon.\nSecondly, I have no idea what the actual function does. It's hard to tell what 'prefix' is, what the actual string is, and what the purpose of the function is.\nThirdly, the function does not return anything. You never return the result of a function. It should be", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in string:\n        for p in string.lower().split(' '):\n           prefixes.append(p.split(' ')[-1])\n    return prefixes\n\nI'm sure it's cute, but it's not Pythonic. Python is a very context-sensitive language. In this case, the context is a string. It's clear that string.lower() is used. It's clear that this is a function, and the input is a string.\nThe \"lint\" approach would be to take the code that reads like English, and turn it into a Pythonic way to do the same thing.", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    list = []\n    longest = string.find(\"abc\").length\n    for i in range(longest):\n        if string.find(\"ab\") == i:\n             list.append(i)\n    return list\n\nI think the author might have had the idea to name the function \"all_prefixes\" before they realized what the function was actually supposed to do.\nIt's a utility function that, given a string and a prefix, finds all the prefixes of the string.\nInstead, it simply finds all the prefixes of the input string, in order of length.\nIf you're searching for all the prefixes of a string, it's only useful if you don't know the length of the string. For example, you want to search for all the prefixes of a string in a dictionary. You search for the first prefix, and if it's not in the dictionary, you search for the second, and so on.\n\nI'm pretty sure the author didn't have the idea to name the function \"all_prefixes\" before they realized what the function was", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    while len(string) < len(string.startswith(string.endswith(string))) and string in string.split():\n        prefixes.append(string.substr(1, len(string.startswith(string))) + string.substr(1, len(string.endswith(string))) + string)\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if string[0] == 'a':\n       return ['a', 'ab']\n    return string.split('.')", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n\n    for prefix in string.split(','):\n        return prefix + string[prefix:]\n\nNow we can create a function to print all the strings in the list that match a regular expression:\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('-')\n\nHere's another way to do it:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    def prefix(string: str, len: int, stop: int, pos: int, ending: int) -> int:\n    \"\"\" Return the suffix of a string starting with position len characters,\n    including the last character pos, and ending with character ending.\n    >>> prefix('abc', 3, 5, 9, 3, 8)\n    6\n    \"\"\"\n    prefix_len = len\n    pos = pos\n    pos_string = string[pos:len]\n    ending = string[len:]\n    suffix = prefix(pos, len + pos_string + 1, stop + 1, pos, ending)\n    return suffix\n\nIs this supposed to be funny? I don't get it.\n\nIt's the opposite of a metasyntactic variable.\n\nHasn't it been obvious for a while that this kind of thing is idiomatic in Python?\n\nI'm a bit surprised the author is surprised to see this sort of thing. As much as I'd like Python to get its act together, it has been like this for a very long time", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return set(string).filter(prefix == string[0:len(string)-1])</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for letter in string:\n       if letter in string.lowercase:\n          return string.lower()\n       else:\n          return string.upper()\n\nThis is probably an over-simplification, but I think you might find it easier to understand:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string.split(\".\")[-1]:\n         yield prefix\n\n>>> print(all_prefixes('abc'))\n['a', 'ab', 'abc']\n\nJust for comparison:\n>>> list(split(\".\")[-1])\n['a', 'ab', 'abc']\n\nOr as a for-loop:\n>>> for prefix in string.split(\".\")[-1]:\n...    yield prefix\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...    pass\n...", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for char in string.chars:\n        if char not in string:\n           return []\n        if len(string) > len(char) * 2 + 1:\n           return [char]\n    return list(string)\n\nIs the benefit of the library that it doesn't require you to know the binary representation of strings? If so, I don't see why this is helpful. I don't write a lot of Python, but I can't imagine someone would have a hard time remembering the binary representation of strings.\n\nNo, it's for working with Unicode strings.\n\nI don't understand the utility of this. Can someone explain how it improves on the standard `encode` method in Python?\n\nI believe it's designed to allow you to use the standard `encode` method with byte arrays.\nThe standard `encode` method doesn't take byte arrays, so it's not possible to use the `encode` method directly on files that are loaded from disk.\n\nAh, gotcha. I use Python", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string:\n        yield prefix\n\nI'm not sure I get the point of this.\n\nIt's a toy. It doesn't have a point. It's not supposed to be useful.\n\nIt's a toy that is useful for understanding the process of removing prefixes from a string.\n\nTrue, but I don't think you needed the list at all. You could just return an iterator over prefixes.\n\nTrue, but then the point of the exercise would be completely lost. I think it's important to keep the code simple.\n\nI don't think the point of the exercise is to remove prefixes from a string. It's to use list comprehensions, dictionaries and generators in Python.\n\nThat's a good point. I'm not sure I agree, but at least it's a valid point of view.\n\nI agree. I don't think the exercise is to remove prefixes from a string either. I think the exercise is to learn about list comprehensions, dictionaries, and generators in Python.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    def prefix_find(str: str):\n    \"\"\" Finds all prefixes of the input string.\n    >>> prefix_find('abc')\n    ['a', 'b', 'c']\n    \"\"\"\n    for s in string.lower():\n        prefix_find(s)\n\n>>> all_prefixes('abc')\n['a', 'ab', 'abc']\n>>> prefix_find('abc')\n['a', 'b', 'c']\n>>> all_prefixes('abcdefg')\n['ab', 'abc', 'def', 'g']\n>>> prefix_find('abcdefg')\n['a', 'b', 'c', 'def', 'g']\n\nI think this is more readable than the Python version, but I'd still prefer Python for this sort of thing.", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return all_prefixes(string.lower().split())\nThis is so bad.\n\nFrom the parent:\n\nOh sorry, didn't see that.\n\nThe title here is the title of the blog post, but it's a little misleading. This is a blog post about how to implement the \"all_prefixes\" function, not about how Python should implement it.\n\nThank you.\nI guess the title is a bit misleading. I will change it.\n\nActually I did not read that. But I guess you will have to change your title.\n\nYes. I guess I will change the title.\n\nIt seems like everyone is getting really hung up on the trivial thing of the name of the function. If you read the blog post, it is obvious that the blog post is about the implementation of the all_prefixes function, not about the name of the function itself.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    short = string.lower().split(' ')\n    prefixes = []\n    for i, short in enumerate(short):\n        prefix = short[1:]\n        prefixes.append(prefix)\n    return prefixes", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    start = list(string.rfind('a'))\n          for prefix in string.rfind('a'):\n              if prefix in start:\n                  start = start.append(prefix)\n    return start\n\n>>> all_prefixes('abcd')\n    ['ab', 'abcd']\n\nOne of the things I hate about Python is how easy it is to write code that is difficult to read.\n\nI would argue that it's not easy to write code that is difficult to read.\n\nIt's easy to write code that is easy to write.\n\nIsn't it easy to write code that is difficult to read in any language?\n\nWhat is the purpose of the list that is returned?\nIs it for iterating over the prefixes?\n\nIs it for iterating over the prefixes, but also for printing out the results?\n\nThat is a good point. I guess in my mind I was thinking of printing out the results, but there is no way", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string:\n        yield prefix\nreturn list(all_prefixes(string))\n\nNot to be nitpicky, but a method should probably have a return type.\n\nIn Python, you can omit the return type as long as it is one of the following:\n\\- Any of the numeric types (int, long, float, None)\n\\- Any of the string types (str, str2, None)\n\\- Any of the list types (list, list2, None)\n\\- Any of the dictionary types (dict, dict2, None)\n\\- Any of the function types (function, function2, None)\n\nInteresting. You can also omit the return type in C++.\n\nI don't get it. Could someone please explain?\n\nPython is a scripting language, C++ is a compiled language. C++ will fail to compile and the error will be reported if the return type isn't specified. Python will just accept the function without complaining.\n\nI've seen compilers complain about missing return types in Python.\n\nI'm not aware of any Python compiler.\n\nI don't know if there is an official", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return []\n\nfrom typing import List\n\n    \"\"\" Find all substring from start position to length-1\n    >>> count_substrings('abcde')\n    [('a', 1), ('a', 2), ('a', 3), ('a', 4), ('a', 5)]\n    \"\"\"\n    return count_substrings(string, -1)</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for s in string:\n       if s in string:\n          return s\n    return []", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(len(string)):\n        if string[i] not in string[i+1]:\n            yield i", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split()\nI don't understand this example. What does this do, exactly?\n\nThe string is split on spaces.\n\nNo, it's split on all non-whitespace characters.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string.split('-', 2):\n       if prefix.length < string.length:\n          return prefix\n    if prefix.length == string.length:\n         return list()\n    return list(prefixes(string))\nI don't know Ruby, but this sounds like an easy way to make a mistake (typo) and get a bunch of unexpected behavior.\n\nRuby has so many more awesome features than Python (or Java, for that matter). For instance, if you accidentally call all_prefixes without passing in a string, it would return a List[String] rather than a List[str]. If you meant to return a List[str], you could do this:\nList.all_prefixes('abc')\n\nI've been looking at Ruby as a language to try and learn. I'm wondering though, is there any reason to learn it if Python is available?\n\nIf you don't want to learn it for the sake of learning it, then you don't have to.\nIf you _do_ want to learn it, there's", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefix_map = {\n         'ab': ['a', 'ab'],\n         'abc': ['a', 'b', 'c']\n    }\n\n    return prefix_map.apply(string).sort()", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split()\n\nClasses?\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefix = list(string.lower())\n    for i in range(len(prefix) + 1, len(string)-1):\n        prefix.append(string[i:])\n    return prefix</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    # Shortest matches\n    prefixes = []\n    for i in range(1, len(string) - 1):\n        prefix = string[i:i+1]\n\n    if prefix in prefixes:\n        prefixes.append(prefix)\n    return prefixes\n\nNow I'm confused. I don't know if the author intended to use dict(string) (the built-in dict), or dict() (a function that calls built-in dict).\n\nI think the author intended for the first one.\n\nOr the author was simply too lazy to do a dict() that would look at the object for a __contains__() method, and then do a built-in dict with that object.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n\n    \"\"\"Shortest = 0L\n    Longest = L\n    for i in range(0, len(string)):\n        return string[i] + Shortest\n    if string[i] == Shortest:\n        return string[i]\n    elif string[i] == Longest:\n        return string[i]\n    elif string[i] > Shortest:\n        return string[i] + Longest\n    elif string[i] < Longest:\n        return string[i] + Shortest\n\n    \"\"\"\n    \"\"\"When a function's name contains one or more periods, like \"all_prefixes\",\n    the Python interpreter processes the name as a series of individual\n    arguments. In this example, \"all_prefixes\" is a function with a single\n    argument, \"string\".\n\nThis can be confusing when using the function in a string literal, because\nthen it", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [string.find('a')[::-1], string.find('ab')[::-1],\n    string.find('abc')[::-1]]\n\nHow does this get upvoted? It's just a snippet of the Python documentation, right?\n\nno, it's not the python documentation, it's actually an example of a simple generator in python. There are a lot of things that can be done with a generator.\n\nThe article I linked is about generators. It's a very interesting topic.\n\nDoes anyone know if there's a way to have multiple generators in Python?\n\nI think it is not possible.\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if len(string) == 1:\n        return []\n    else:\n        return string.split('.')[0]\n\nIt doesn't work:\n>>> all_prefixes('abc')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: list() takes exactly two arguments (2 given)\n\nwell, it's only a proof of concept, but it's interesting to see the different ways of achieving the same result.\nhere is my version:\nfrom string import String", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(0, len(string) - 1):\n        if string[i] == string[i+1]:\n           return [string[i] if i in string else None]\n    return [None]\n\nThe range function is probably unnecessary and if you're familiar with the slice syntax in Python, it will be easier to understand.", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    def find_prefix(prefix: str) -> str:\n    \"\"\" Return the prefix that is closest to the input string, if it exists.\n    >>> find_prefix('abc')\n    'ab'\n    >>> find_prefix('abcd')\n    'ab'\n    >>> find_prefix('ac')\n    'c'\n    \"\"\"\n    def remove_prefix(prefix: str):\n    \"\"\" Remove the prefix from the input string, if it exists.\n    >>> remove_prefix('abc')\n    'ab'\n    \"\"\"\n    def apply(input_string: str):\n    \"\"\" Apply the transformation to the input string.\n    >>> apply('abc')\n    'ab'\n    \"\"\"\n\nThis is a perfect example of why OOP is so great. I just used Python as an OOP language to write a working, functional language.\n\n>This is a perfect example of why OOP is so great.\nThis is a perfect example of why OOP is so", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n\n    for s in string:\n        prefix = s.lower().rfind(' ')\n\n        if prefix in prefixes:\n             prefixes.append(prefix)\n             s.reverse()\n\nI'm not a python programmer, but I'm curious. How does the implementation of this code compare to the one using the built-in dictionary?\n\nFor one thing, it's a few lines longer, so I guess that's one way in which it's worse.\n\nDon't forget the extra import.\n\nThat's true, but the fact that it's a list of tuples is a feature of the built-in dictionary; you can do this sort of thing with a dictionary as well. I guess what I'm asking is: how would you implement this using just the built-in dictionary?\n\nDictionaries don't have an istructural way to iterate over the keys, which is why the built-in itertools module (which is used here) is useful.", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')\n\nthat's really neat!\n\nIt's a pretty common technique for large data sets.\n\nYes, but many python programmers don't know it, and I think it's worth pointing out.\n\nSee also:\n\nI love this trick, and use it all the time. I just wish that I could do the same with \"obsolete\" parameters.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for char in string:\n        prefixes.append(chr(chr(string[chr])))\n    return prefixes\n\nI think this is a very nice answer.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    # calculate the length of each string from shortest to longest\n    start = string.find('a')\n    end = string.find('z')\n    for i in range(0, end - 1):\n        if start[i]!= end[i]:\n            start[i] = end[i]\n        end = end - 1\n    return List(start) + List(end)\n\nThis is a great hack and all, but it's not really a better solution than `all_from_least_to_most` or `all_from_most_to_least`.\nThe former of the two can be even shorter and doesn't require you to specify the length. It also handles cases where the input string is empty (because it just skips all the checks).", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n\n    return string.split(0, string.length-1)\n\nfrom typing import *\n\n       def increment_prefix(prefix, c):\n         if c is None:\n            c = 1\n\n         if prefix in c:\n              c = c + 1\n\n        return c", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    result = []\n    for char in string:\n        if char not in 'abc':\n           result.append(string[char])\n    return result\nYou should probably name it `all_prefixes_length` instead of `all_prefixes`, for consistency.\n\nI thought about that, but I didn't want to get into OO (I didn't want to use a class). So I opted for the functional/generic route.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ').map(prefix).sort()", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n\nWow, that is some serious \"why not\".</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n\n    for i in range(0, len(string) - 1):\n        if string[i] == 'abc':\n           return string[i] + string[i+1]\n    return []\n\nI'm not sure what the point of this code snippet is. It's just a for loop that generates a list of all valid prefixes of `string`.\n\nIndeed. Even if there was a need to compute the set of prefixes from the set of non-prefixes, the list comprehension would be far more elegant.\n\nFrom the title I was expecting some super-optimized coreutils version that actually used type inference.\n\nUsing type inference would be great. The current type system of Python (and thus, Ruby, Perl, etc.) seems a little ad hoc to me.\n\nThis is a fun use of the readability of a Haskell-style type system to do something really useful. But the underlying problem is just a _slightly_ more general version of the Sieve of Eratosthenes.\n\nWe have this in the standard library:\n\nI think it's a very common", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return sorted(list(string.rfind('abc', 'a', -1), string.rfind('abc', 'b', -1), string.rfind('abc', 'c', -1))\n\nYou don't need to import List to get the string class.\n\nimport string", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [str[i:i+1], str[i+1:] for i in range(len(string) - 1)]</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return sorted(string.lstrip(), key=lambda s: len(s.rstrip()))\n\nand\nfrom typing import List\nfrom typing import OrderedDict", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for prefix in string:\n        prefixes.append(prefix)\n    return prefixes\n\nThis is a good one. I like it.\n\nit's really cute :)</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for letter in string:\n        return list(chr(letter), len(letter))\n\nfrom typing import List\n\n        def all_prefixes(string: str) -> List[str]:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    def _prefix(len: int, start: int):\n        return string[len:]\n    return _prefix(0, len(string), len(string))\n\nHere is my question. Is there a way to use this same syntax to define the above function as a function object? It seems like it could be done since it is essentially a function. Is it necessary to make it a class in order to do this? I'm asking because I'm not sure how to go about doing this without making it a class.\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string:\n         if prefix in string:\n               return prefix\n    return List()\n\nfrom typing import List\n\n    def all_prefixes(string: str):\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    for prefix in string:\n         if prefix in string:\n               return prefix\n    return List()\n\nfrom typing import List\n\n    def all_prefixes(string: str):\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    for prefix in string:\n         if prefix in string:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')\n\nThis is basically my approach.\n\nI don't really see the point of this.\n\nRight now I'm working on a large data set of English text that is sort of like a large database dump. I'm writing a program to extract meaningful information from it, and I'm using a modified version of this technique to generate a dictionary of the words found in the data set.\nI'll have to be able to do lots of lookups, so generating a dictionary in advance makes the program more efficient.\n\nI wrote a similar tool a while back for a project that I was doing. The tool would search a list of strings to find the longest common subsequence. It used your approach (string.split('.')) to break down the input string into prefixes and then combined the prefixes and looked for the longest common subsequence of the results.\nThe code is here: \n\nThat's a cool idea. I'd be interested to see a blog post or something that describes your project.\n\nSome problems with this approach:\n\\- For strings that don't have an obvious repetition, a single split will miss all the prefixes.\n\\- A split might make", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string:\n          if string[prefix] in string:\n                list.append(prefix)\n    return list\n\nfor f in all_prefixes('abcdefghijklmnopqrstuvwxyz'):", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(',')\n\nThis is a fine example of Python's magic. The problem with this, and many other, Python programs is that they rely on magic. What's the type of List? It's something that Python knows. What's the type of any function returning a list? It's something that Python knows.\nThe point of a statically typed language is that it _doesn't_ need to know this stuff. There are a lot of things that Python programs do that are impossible to express in a statically typed language, but it's not impossible to express them in a statically typed language that supports higher-order functions.\n\nWhat do you think the type of List is? How do you think Python would have behaved if the user had specified `2`, say?\nThe `list` module is one of the most important pieces of the Python standard library. I don't think it's a good example of \"magic\" at all.\n\nIt's a list. The type of List is 'object'. But the compiler doesn't know that. It's possible to write a program that makes use of List and returns a List, but the compiler will not know that List is the return type.\nThis is", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for s in string.split(' '):\n       if s[0] == 'a':\n         return s\n       if s[0] == 'b':\n         return [s[1], s[2], s[3]]\n       if s[0] == 'c':\n         return [s[1], s[2], s[3], s[4]]\n       if s[0] == 'd':\n         return [s[1], s[2], s[3], s[4], s[5]]\n       return []\n\nThis is great, and I've written similar one-liners for this purpose many times before.\nWhat I find is that you need to make a conscious effort not to overuse it. There's a fine line between using an expression that's brief and terse, and one that is too terse. It's an art form, and you have to learn to appreciate a", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('-', 1)[:len(string) - 1]\n\nFrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for prefix in string.split():\n        if prefix in string:\n           prefixes.append(prefix)\n    return prefixes\n\nIt's more like", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return sorted(string.split(' ')[::-1], reverse=True)\n\nnot sure what you're trying to demonstrate here, but the answer is:\n>>> all_prefixes('abc')\n[('a', 'abc'), ('ab', 'abc'), ('abc', 'abc')]\n\nNot sure if that was the point, but his list comprehension is recursive, so if it takes any amount of time to run, it's non-deterministic.\n\nAs far as I can tell it's not doing anything with the input, just sorting it, so it's not non-deterministic. (Though I guess you could argue that any computation could take some amount of time.)\n\nI'd argue that any computation that depends on the input is non-deterministic.\n\nIt does not depend on the input in any way. It depends on the length of the input, but that's a constant.\n\nI'd argue that any computation that depends on anything is non-deterministic.\n\nAh, the old halting problem. I was not expecting to see it here.\n\nMost certainly it is. I know this because the page is at\n.\nAnd", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [\n         ['abc']", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ').map(str).tolist()\n\nI always get confused when I see things like this...", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return set(string.index(string, 'a'), string.index(string, 'b'),\n    string.index(string, 'c')).unique()\n\nfrom typing import List\n\n        def all_prefixes(string: str) -> List[str]:\n          \"\"\" Return list of all prefixes from shortest to longest of the input string\n          >>> all_prefixes('abc')\n           ['a', 'ab', 'abc']\n          \"\"\"\n          return set(string.index(string, 'a'), string.index(string, 'b'),\n            string.index(string, 'c')).unique()\n\nfrom typing import List\n\n        def all_prefixes(string: str) -> List[str]:\n          \"\"\" Return list of all prefixes from shortest to longest of the input string", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if len(string) < 2:\n       return []\n    for char in string[0:2]:\n       if char == 'a':\n           return ['a']\n       if char == 'b':\n           return ['ab']\n       if char == 'c':\n           return ['abc']\n    return []\n\nIt's a bit more readable with the string unpacking syntax:\n>>> all_prefixes(\"abc\")\n['a', 'b', 'c']\n>>> all_prefixes('abc')\n['a', 'ab', 'abc']\n\nInteresting. This is really neat.\n\nI'd like to see it compared to the usual technique for finding all prefixes of a string. I usually find that involves finding all substrings of the string with a length of 1, then recursively finding all substrings of length 2.\n\nI'm not sure what you mean by \"the usual technique\". If you", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    min = None\n    max = None\n    for i in range(1, len(string) - 1):\n       min = min + string[i]\n       max = max + string[i]\n    return [min, max]\n\nreturn all_prefixes('abc')\n\nWorks on Python 2.5.1\n\nThis is a bit silly. The OP's point was that there should be a built in function for this.\n\"Why doesn't Python have a built in function that does x\" \"Here's a function that does x\"\n\nSometimes \"here's a function that does x\" is a nicer way of saying \"why doesn't python have a built in function that does x?\"\n\nIt is good to use the built in function where it is available. I think the point of the post was that the built in function does not exist, and thus it is a feature request.\n\nThis is so trivial to write that I don't understand how a native function is worth the time to implement.\n\nThe native function doesn't have to be longer than:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ')\n\nI like to use a variation of this that returns a list of all combinations of the same number of characters:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return (string.find('-') for _ in string.rfind('-') if _ == -1 else string)\nThat's ugly code, not least because it is a one-liner that could have been written as one line:\nfrom typing import List\nall_prefixes = [String(find('-', string) if find(string, -) else string)]\nThe type system is supposed to be a tool to help you write more readable, less buggy code. If you find yourself being tempted to write bad Python to avoid type errors, I'm pretty sure you're doing something wrong.\n\nI don't know how you'd write this in a single line. I think it's very readable.\nI think the real problem here is that \"find\" is a function in the string module, not in the python module. Is it a programming flaw? I'm not sure. I do know that I don't like it.\n\nI know that many people like Python, but this is one of the reasons that I _don't_. I think it's a poor design to have two different things in the same language with the same name.\n\nIt's actually a very smart design. It lets", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    \"\"\"\n    prefix = []\n    for character in string:\n        prefix.append(char)\n    return prefix", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    result = []\n    for s in string.lower():\n       result.append(s)\n    return result\n\nThat's one heck of a long namespace. It's like the worst of Python's package system, the worst of Java's import system, and the worst of Ruby's module system all rolled into one.\nThat looks pretty useful, though. I'd definitely like to see the equivalent of Python's \"os\" built-in for every language I use, and I'm pretty sure that I've seen something like this for Ruby.\n\nIt's a bit long, but it's not like you'll have to type it very often.\n\nIt doesn't look too bad, though it does look to require a lot of typing. This seems to be a very good example of \"Pythonic\" programming (useful, but not \"pretty\").\nWhat if you want to get all of the prefixes of _every_ character in the string? That's probably a pretty common use case (in my mind, at least).\n\nHere's a way to get all of the prefixes of every character in the string:\n>>> prefixes = all_prefix", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return (string.lower() for i, char in enumerate(string.split(' ')[0]) if i < string.length[0])\n\n>>> all_prefixes('abc')\n['a', 'ab', 'abc']\n\n>>> all_prefixes('fghijklmnopqrstuvwxyz')\n['f', 'gh', 'ij', 'kl','mn', 'op', 'qr','st', 'uv', 'wxy', 'zy']\n\n>>> all_prefixes('fghijklmnopqrstuvwxyzab')\n['f', 'gh', 'ij', 'kl','mn', 'op', 'qr','st', 'uv', 'wxy', 'zy', 'ab']\n\n>>> all_prefixes('fghijklmnopqrstuvwxyzabcabc')\n['f', 'gh', 'ij', 'kl','mn', 'op', 'qr','st', 'uv', 'wxy', 'zy', 'ab', 'abc']\n\n>>> all_prefixes('fghijklmnopq", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return list(string.split(',').reverse())\n\nI've seen a lot of code like that - and it's just broken. If you're going to use that kind of list, then you should always use it with the append() method. Otherwise you're just begging for bugs.\n\nNot sure what you mean by \"begging for bugs\". I've done quite a bit of programming in Python, and I've never encountered a bug caused by the use of `list(string.split(',').reverse()).append()` instead of `list(string.split(',').reverse())`. If I did, I'd probably try to understand why the code was breaking before I fix it.\n\nYou're missing the point. I'm not saying you _will_ encounter a bug. I'm saying that you _can_ encounter a bug. In fact, the potential for bugs is extremely high if you don't use `append()`.\nWhat happens if you want to add a new prefix? You now have to worry about the fact that your list is immutable. What happens if you want to delete one of the prefixes? You now have to worry about whether or not your list is actually immutable. What", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    n = len(string)\n    return list(string[::-1], string[::-2]) + List(string[::-3], string[::-4]) + List(string[::-5], string[::-6]) + List(string[::-7], string[::-8]) + List(string[::-9], string[::-10]) + List(string[::-11], string[::-12]) + List(string[::-13], string[::-14]) + List(string[::-15], string[::-16])\n\nCan't this be simplified by just having a 1 element list?\n\nMaybe but it's not as pretty :)\n\nI would argue that the general case of a list of prefixes in the list of prefixes is not pretty. :)\n\nWell, yeah, but it was intended as a joke.\n\nIt's a joke, but it's also a useful real-world example for an interesting programming concept: the inversion of control pattern.\n\n\"It's a joke, but it's also a useful real-world example for an interesting programming concept: the inversion", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for x in string:\n       if x not in list:\n            add(x, string)\n\n    return list\n\nI don't understand this, can someone explain?\n\nIt's the same thing as", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefix = 0\n    while len(string) > 1 and string[len(string)-1] in prefixes:\n         prefix += string[len(string)-1]\n    return prefixes\n\nWhy not just      import operator  and call it directly?\n\nI don't see how that's any different.\n\nDoesn't Python have some support for the 'is' operator built in?\n\nI think I would have to compare the string to a list of the known prefixes. I'm not sure what that would look like in Python.\n\nIt would look like \nis a list of strings that the string _does not_ match.\nis a list of strings that the string _does_ match.", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for char in string:\n        if char in prefix:\n            return prefix[char]\n        else:\n            return string\nYou should write:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split()\n\nI love Python.\n\nThat's actually a pretty bad example of why you love python.\n\nI think it's a pretty good example. He imported a module for a single function, and was able to get a list of all prefixes in one line.\n\nI meant in the sense that it's not even really a \"pythonic\" way of doing things. Python encourages small functions, so making a function with a single statement is very unpythonic.\n\nOkay, so you mean it's not the most pythonic way of doing things. I read it as you saying that the idea of splitting a string is not pythonic.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n\n    prefixes = []\n    for character in string:\n       if character in ['a', 'ab']:\n          prefixes.append(character)\n    return prefixes</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string[int(len(string) - len('a') + len('ab') + len('abc') + 1)]\n\nThis is a little odd. He's taking advantage of Python's int(). I guess it's a shortcut for __len__(string), but it's a little confusing to me.\nIt's a good thing they picked the name \"all_prefixes\" for this function. I wouldn't want to use a function called \"string_prefixes\".\n\nI'm a Python novice, so maybe this is a dumb question, but why not?\n\nBecause \"string_prefixes\" is ambiguous. Does it return the string before the first 'a' or 'b' or does it return the string before the first character that's a 'b' or an 'a'? The name \"all_prefixes\" avoids this ambiguity.\n\nPython has a few of these \"defying convention\" shortcuts, which are quite handy.\n\nNope, a list is a list is a list.\n\nBravo, you've now made the Python-in-JavaScript compiler even more complicated.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(0, len(string) - 1):\n       if i in string[0:-1] and string[i]:\n          return string[i]\n    return []\n\nFrom:\n\nThis version isn't as elegant, but it's more efficient.\n\nWhat's less efficient about it?\n\nIt's a copy of the string, rather than a list.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for a in string.lower():\n       if a[0] == 'a':\n         return List(a)\n    return List(string.lower()[0:len(string)-1])\n\nI don't know python, but doesn't this mean that the all_prefixes() function returns the string in reverse?\n\nNo. `all_prefixes` returns a list of strings, not a reversed string.\n\nRight, I didn't think that through enough.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n       for string in string.lower():\n          return all_prefixes(string[1:])\n\nThere is a 'from typing import List' at the top of the file. It's a standard Python idiom.\n\nI don't understand the joke.\n\nOP wrote a seemingly inconsequential comment, but since he was using Python, he was able to do so in a single line of code.\n\nThanks.\n\nThis is better:\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string:\n        if prefix.startswith('a'):\n           return [prefix]\n        else:\n            return [string[1:] + string[prefix]]\n   \n>>> list = all_prefixes('abc')\n>>> list\n['a', 'ab', 'abc']\n>>> list[:]\n['a', 'ab', 'abc']\n>>> list[:]\n[('a', 'ab'), ('a', 'abc'), ('ab', 'abc')]\n\nHow much time did you spend writing that?\n\nIn the same amount of time I could have written\nfrom typing import List\nlist = [('a', 'ab'), ('a', 'abc'), ('ab', 'abc')]\n\nWhat makes this Pythonic?\n\n\"Pythonic\" is a word with no clear definition. I would argue that there is a difference between (a) a minimal program that accomplishes the desired task and (b) a minimal program that is also compact, elegant, and easy to read", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for p in string:\n        if p.startswith(string[0]):\n           return p\n    return []", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [str.substring(0,len(string)-2).replace('.', '_') for _ in string]</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return sorted(string.split(' '), reverse=True)[::-1]\n\nClickable:</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if len(string) == 1:\n       return string\n\n    return string.split(' ')\n\nI think that's the whole point of it being a \"toy\" program.\n\nI agree. I think the point of the program was to write a toy program that would compile and run, but not work correctly.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n\n    if len(string) == 1:\n       return []\n    for i in range(len(string) - 1, -1, 0):\n        return [i if i in string else '']\n\nThe original implementation had a bug.\n\nI don't think the downvotes are fair. The most recent implementation did not have a bug. The original version did. It was updated.\n\nYou need to have a way to say \"I have nothing interesting to say\" without cluttering up the discussion.\nYou can't downvote the OP, so you downvote the reply. It's not fair, but I'm not sure there's any other way to do it.\n\nI am surprised that there are no comments on the use of Python's \"from typing import...\". I like the idea of using it in small utility programs like this, but it is still lacking in a number of areas:\n1) No support for multiple inheritance.\n2) No support for multiple interfaces.\n3) No support for abstract classes.\n4) No support for virtual inheritance.\n\nFor what it's worth, this is really not too", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n\n    if string[0]!= 'a':\n        return []\n\n    if string[0] == 'ab':\n        return ['a', 'ab']\n\n    if string[1]!= 'a':\n        return []\n\n    if string[1] == 'ab':\n        return ['a', 'ab']\n\n    if string[2]!= 'a':\n        return []\n\n    if string[2] == 'ab':\n        return ['a', 'ab']\n\nI don't really get it - \"if string[0]!= 'a'\" and \"if string[0] == 'ab'\"\nwill both return [] because the string does not start with a, but you don't\nreturn it anyway.\n\nThe string is \"abc\", so the \"if string[0]!= 'a'\" check will always return\n[] because there is no 'a' in the string. The \"if string[0] == 'ab'\"\nwill", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string.lower().split()[:3]:\n        return string.lower().split()[3:] + prefix\nI like that! I've been reading through the source to the Python library for a while. I wonder if I could get it to return a list of lists...</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for _ in range(1, len(string)-1):\n       return string[0:_]\nAh, that's not so bad. The \"range\" function is an evil construct, though, it would be much better to write it like this:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.upper().split('-')\n\nThis is a bit misleading, it's not the shortest to longest, it's the longest to shortest.\n\nProbably not, and if I had to guess, I'd say it's a bug in the function (which should have split at the first whitespace).\n\nThis is a bug in the function (which should have split at the first whitespace)\n\nI'd be interested in knowing how the author came to the conclusion that all_prefixes should be the longest prefix.\n\nBecause it's going from \"one prefix\" (string) to \"many prefixes\" (list of strings). The prefixes will be in increasing length. The result is a list of prefixes. The prefixes will be the longest prefixes (from a certain point of view).\n\nI feel like an idiot, but I don't understand this. Can someone explain what the all_prefixes function is supposed to do?\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [prefix[0] for prefix in string.split(\".\") if prefix[0] not in string.lower().split(\".\")]\n\nAll of the examples here seem to be doing a lot of work to make a short, simple, self-contained one-liner.\nList comprehensions are just fine, and only a small amount more verbose.\nBut one thing that is nice about the Python 3 syntax is that it is a lot easier to read.\n>>> all_prefixes('abc')\n['a', 'ab', 'abc']\n>>> all_prefixes(string.split('.'))\n['a', 'ab', 'abc']\n\nThe Python 2.7 equivalent is nicer.\n>>> all_prefixes('abc')\n['a', 'ab', 'abc']\n>>> all_prefixes(string.split('.'))\n['a', 'ab', 'abc']\n\nI was looking for a way to do this (and couldn't think of it in the moment):\n>>> all_prefixes('abcdefghijklmnopqrstuvwxyz')\n['a', 'ab', 'abc', 'def', 'ghij", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string[:len(string)]\n\nIs there really a difference between:\nabc\nand:\n>>> import string >>> string.strip('abc') ['a', 'b', 'c']\n??\n\nYes, for a non-trivial program, this difference can be non-trivial.\n\nPlease elaborate.\n\nTake the input 'abc', strip the leading 'a', then consider the function 'all_prefixes' where the second argument is 'abc'.\nA bug could be introduced if 'abc' is re-parsed to 'abc' if the call is made at the 'abc' level, rather than the 'a' level, and then applied to 'a', 'b', and 'c' rather than 'a', 'ab', and 'abc'.\nThis bug would never occur with your second example, because you know 'abc' is actually 'abc'.\n\nSo, 'all_prefixes' without the parameter is the same as 'all_prefixes('abc')'.\n\nI see. Is there a way to explicitly specify that the parameter is a string rather than an iterator?\n\nIs it just me, or does this", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [string[len(string)-1:] for _ in range(len(string) - 1)]\nWhat's the advantage of doing it this way, instead of just using string.split()?\n\nThere's no real advantage. But it looks cool.\n\nI would expect it to be more performant. This uses iterators and those are very fast compared to, say, a list comprehension (and in this case a list comprehension would be more readable).\n\nI'd be very surprised if this were faster.\nThe split function is very fast and has a very low memory footprint.\n\nI haven't benchmarked it but I just assumed that the iterator code would be faster than the list comprehension. I wouldn't be surprised if it was the other way around, though.\n\nI don't think it is, the split function is a very thin wrapper around the C library. It's probably a few calls into the OS or C library.\nI don't think a list comprehension is a very expensive call either.\n\nI'd be surprised if that's the case, though. The underlying Python list data structure (and lists are one of the fastest data structures in Python) is much faster than the list", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if string.find('a').count('a'):\n        return ['a'].reverse().get()\n    if string.find('b').count('b'):\n        return ['b'].reverse().get()\n    if string.find('c').count('c'):\n        return ['c'].reverse().get()\n    return ['a', 'ab', 'abc']\n\nI'm not a python programmer (I know the basics), but this seems like bad style.\nIs this a common idiom? What's the proper way to do this?\n\nIf it's a variable-length list (one where you don't know the length in advance), you'd use a generator expression:\nlist(string.find('a'))\nIf it's a fixed-length list (one where you do know the length in advance), you can use a list comprehension (where you don't need a for loop):\nlist(string.find('a') for 'a' in string.find('a'))\n\nCan you explain how you would use", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    suffixes = string.lstrip().split()\n    for s in suffixes:\n       if len(s) > len(string):\n          return s\n       return []\n\nThat's a really cool trick!\nA few questions:\n1\\. How do I figure out how many elements I want to get?\n2\\. How do I figure out the order in which I want to get them?\n3\\. How do I get the names of the elements? (I'm using Python 2.5.2).\nThanks!\n\n1\\. You can't. But you can use all_prefixes(string.lstrip().split()) to get\nthe prefixes of a string (no matter how long).\n2\\. You can't. You'll get the prefixes in random order.\n3\\. You can't. But you can use all_prefixes(string.lstrip().split()) to get\nthe longest prefix of a string (no matter how long).\n\nOk, I think I understand.\nBut let's say I have a string that I want to split up into", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    while string[len(string) - 1]!= '':\n        if len(string[len(string) - 1]) > string[len(string) - 1]:\n           prefixes.append(string[len(string) - 1])\n    return prefixes\n>>>\nAnd that is why Python needs Unicode string support.\n\nNot sure I understand your point. This works fine in Python 2.7 as well:\n>>> \"abc\" in all_prefixes(\"abc\") True\n>>> \"abc\" not in all_prefixes(\"abc\") False\n>>> \"abc\" in all_prefixes(\"abc\")\n[('a', 'ab', 'abc'), ('a', 'bc', 'abc'), ('a', 'ba', 'abc')]\n>>> \"abc\" not in all_prefixes(\"abc\")\n[False]\nIt's even better in Python 3, since there's a built-in string type that does Unicode (utf-8) conversion:\n>>> \"abc\" in all_prefixes(\"abc\")\n[u'a", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for x in string:\n        return [x, x.lstrip().rstrip() for x in string[x.start:x.end - 1]]\n\nNice :)\n\nFrom the title I expected the post to be a rant against list comprehensions.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(len(string))+1:\n        prefix = string[i:i+1]\n        if string[i:i+1] in string:\n             prefixes.append(prefix)\n    return prefixes\n\nYou've just created a new class to do what could be done with a list comprehension, except that you've made it slower, and you've made the syntax more complicated.\n\nNot to mention that `list(a for a in abc)` is more readable than `all_prefixes(ab)`.\n\nNot to mention that you've made a copy of the string for every element in your list, making your code slower and less efficient.\n\nNot to mention that he could have just used the Python standard library:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ').filter(prefix => prefix.length() <= str)\n\nThat's neat. Python 3.2's `list(string)` also does that:\n>>> list('abc')\n['a', 'b', 'c']\n\nI see a lot of examples where a list comprehension is used instead of just\nthe list function. Is this just a matter of taste or is there an\nadvantage?\n\nI've always been taught to avoid list functions, especially \"list\" and \"dict\".\n\nWhy is that?\n\nI have no idea. I was taught in a class when I was first learning python and it stuck.\n\nMaybe this is a dumb question, but when did \"from\" come into play? I thought the standard practice was to import modules to use them.\n\nThey added from to python 3.0 (AFAIK, they just added it as a convenience, because using from foo import bar is like saying:\nfrom foo import *\n)\n\nIf you want to get super-minimalistic, `os` is a module.\n\nThey've also imported os.path, but not os.walk, which makes it", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for char in string.characters():\n       if char in string.characters()[0:]:\n           return []\n        else:\n           return list(string.substring(1, char.index(string.characters())) + string.characters())\n    return list\n\nThis is a very neat idiom, but it's a bit slow.\nimport itertools\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ')\n\nimport operator", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for char in string:\n        prefixes.append(char)\n    prefixes.reverse()\n    return prefixes\n\nAnd this is why you should use the duck typing approach to OOP:\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    def find_prefix(string: str) -> int:\n    \"\"\" Finds prefix of the input string with a given score (inclusive)\n    >>> find_prefix('abc')\n    1\n    >>> find_prefix('abc')\n    -1\n    \"\"\"\n    return int(string.find(\"^\", 1) + string.find(\"*\", 2) + string.find(\"$\", 3))\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in string.finditer(chr(i) for i in range(len(string) - 1)):\n         prefix = i\n         return prefixes(string[prefix:])\n\nOne could just as well have the function in the Python standard library and then no one would have to remember any magic function names.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    lst = []\n\n    for i in range(len(string)):\n        lst.append(string[i % len(string) + 1])\n\n    return lst\n\ni.e. \"abc\" -> [\"a\", \"ab\", \"abc\"]\n\nI've seen this example a couple of times, and I was wondering if this is a common idiom in python?\n\nI've seen this a couple of times, and I was wondering if this is a common idiom in Python?\n\nI've seen this a couple of times, and I was wondering if this is a common idiom in Python?\n\nI've seen this a couple of times, and I was wondering if this is a common idiom in Python?\n\nI've seen this a couple of times, and I was wondering if this is a common idiom in Python?\n\nI've seen this a couple of times, and I was wondering if this is a common idiom in Python?\n\nI've seen this a couple of times, and I was wondering if this is a common idiom in Python?\n\nI've seen this a couple", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    d1 = len(string)\n    d2 = string.find('a')\n    d3 = string.find('ab')\n    d4 = string.find('abc')\n    d5 = string.find('x')\n    # They are in reverse order!\n    return [d1, d2, d3, d4, d5]</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(0, len(string) - 2):\n       if string[i:i+1]!= 'a':\n          return string[i:i+1]\n          else:\n           return string[i:i+1] + string[i+1:i]\n\nNice! Now lets make a regular expression engine.", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return list(string)\n\nthe all_prefixes function in python3 is much better:\nfrom typing import List\nfrom itertools import product", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for item in string.split():\n        if item == string.upper():\n           return item\n         else:\n            return string.lower() + string.upper()\n\nThis is beautiful.\n\nI will get this printed on a T-shirt.\n\nI was thinking of getting this tattooed on my back, actually.\n\nFor a more concise (and easier to read) version of this:\nfrom typing import isupper\nfrom itertools import islice", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(len(string)):\n        return string.split('-')\n    return [str[i:i+1] for i in range(len(string)-1)]\n\nI don't understand the need for this. Isn't the \"shortest\" a prefix, and the \"longest\" a suffix?\n\nNo, it's in alphabetical order.\n\nDoesn't he mean \"preceding\" and \"succeeding\" instead of \"shortest\" and \"longest\"?\n\nIf he did, it would be a very different program.\n\nI should have said \"preceding\" and \"succeeding\" and \"following\" instead of \"shortest\" and \"longest\".</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    l = len(string)\n    prefixes = []\n    for i in range(0, l):\n        if string[i] in string:\n            prefixes.append(string[i])\n    return prefixes</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for char in string:\n        if not char in string:\n            return []\n        if char in string[1:]:\n            return string[1:]\n        if char in string[0] * string[1:] + string[2:] + string[3:] +\n            string[4:] + string[5:] + string[6:] + string[7:] + string[8]:\n            return string[1:] + string[2:] + string[3:] + string[4:] +\n            string[5:] + string[6:] + string[7:] + string[8]\n\nAll I can say is _wow_.\n\nThis is very useful, I also had a similar list of functions like this for Python:\n\nExcellent! I've been trying to write a list of useful python tricks that I've found. Any chance you could", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [str[0] for str in string if len(str) < len(string)]\n\nand to make it somewhat more clear:\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for letter in string:\n        if letter in string[0]:\n            prefixes.append(string[1:-1])\n         if letter in string[1:]:\n            prefixes.append(string[0:-1])\n    return prefixes\n\nThis is a great example of the fact that list comprehensions can be _much_ more efficient than a for loop when the number of items is known ahead of time. In particular, the time complexity is O(N), instead of O(N^2).\n\nI'm afraid it is not correct. The time complexity is still O(N).\nThe list comprehension is slightly faster, but not much. The reason is that the list comprehension is implemented using a for loop.\n\nHow is it implemented with a for loop?\n\nHe probably means: the list comprehension is implemented using a for loop under the hood.\n\nA great example of what's wrong with Python's standard library. It's bloated and has some pretty bad code", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for p in string.split(r'^%s*'):\n        prefixes.append(p)\n    return prefixes\n\nThanks. I was looking for that after I submitted this article.\n\nI had a similar feeling when I saw this:\nfrom typing import List\n\nI am confused about this. Are you saying that Python's lists are not 'types'? If so, then why is the following valid?\n>>> [0] 'hello'\n\nSince they're built-in objects, they are not considered types. Just like how \"abc\" is not a type, \"List(abc)\" is not a type, but \"str\" is a type.\n\nA list is a type.\n\nGood point! I think the following might be a better way of saying it:\nSince they're built-in objects, they are not considered types _by Python_.\n\n\"A list is a type\" is definitely true in python. It's a built-in type that can be built by a non-type object.\n\nIs there a way to use a type for something like this in"]]