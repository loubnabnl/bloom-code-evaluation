[["from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in string.split(''):\n        return string[i:i+len(string)]\n\nWell, I think that is a terrible idea. There's no reason to assume that the string is ASCII or Unicode, and it's not even clear from the implementation what the string is. If you're using Python, you can just use the built-in split.\n\nThis is a really simple implementation. It does exactly what it says on the tin. There's nothing wrong with that.\n\nThere's nothing wrong with it, but it's also not very good. It's just a very basic implementation that doesn't even do what it claims to do.\n\nThat's true, but I think the author just wanted to show a simple example of the concept.\n\nThis is a good idea. But it's also quite easy to implement it in Python:\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ').filter(not='.').reverse()\n\nThis is why I love Python.\n\nThe other day, I was looking at the source of a little library that someone wrote for a project I was working on. I noticed that it used a function called \"list_of_lists\". I thought \"that's a bit long winded, why not just do it this way?\"\nSo I tried:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for char in string:\n         if char in string[0:len(string)-1]:\n               prefixes.append(char)\n    return prefixes\n\nfrom typing import List\n\n    def all_prefixes(string: str):\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    prefixes = []\n    for char in string:\n         if char in string[0:len(string)-1]:\n               prefixes.append(char)\n    return prefixes\n\nfrom typing import List\n\n    def all_prefixes(string: str):\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = [None]\n\n    for i in range(len(string) - 1, -1, 1):\n        if string[i] == string[i+1]:\n           prefixes.append(string[i+1])\n    prefixes.sort()\n\n    return prefixes\n\nThe article is about the problems with this solution.\n\nIt's not a bad solution for the problem, but it's not the most efficient solution.\nI've written a library that addresses this problem: \nThe idea is that it's a single function that takes a string and returns a list of all the substrings. The implementation is efficient (using a trie) and fast.\nI've also written a simple benchmark for it: \nThe benchmark is for a list of 100,000 strings. The fastest version of all_prefixes() takes 0.41 seconds, while the fastest version of my function takes 0.01 seconds.\n\nThe code that you have linked to is not in the same category as the all_prefixes() code. The all_prefixes() code is", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ')\n\n>>> import itertools\n>>> all_prefixes = itertools.groupby(itertools.islice(all_prefixes('abc')))\n>>> all_prefixes\n['a', 'ab', 'abc']\n>>> all_prefixes.sort()\n['a', 'ab', 'abc']\n>>> all_prefixes.reverse()\n['ab', 'a', 'abc']\n\n>>> import itertools\n>>> all_prefixes = itertools.groupby(itertools.islice(all_prefixes('abc')))\n>>> all_prefixes.sort()\n['a', 'ab', 'abc']\n>>> all_prefixes.reverse()\n['ab', 'a', 'abc']\n\n>>> from typing import List\n>>> all_prefixes = List()\n>>> all_prefixes.sort()\n['a', 'ab', 'abc']\n>>> all_prefixes.reverse()\n['ab', 'a', 'abc']\n\n>>> import itertools\n>>> all_prefixes = itertools.groupby(itertools.islice", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    all_prefixes = []\n\n    for i in range(len(string)):\n        for j in range(len(string[i])) - 1:\n             if string[i] == string[j]:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(len(string) - 1, len(string) + 1):\n        prefix = string[i]\n        prefixes.append(prefix)\n    return prefixes\n\nIt's hard to tell from the article, but I assume that this is supposed to be a joke.\n\nNot a joke. It's a real thing.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for letter in string:\n       if letter in string:\n          prefixes.append(letter)\n    return prefixes", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ')", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return sorted(string.split('.'), reverse=True)\n\nI think you meant:\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for s in string:\n        prefixes.append(s)\n    return prefixes\n\nI think this is a poor way of explaining the all_prefixes method.\nIt's not really explaining what it does. It's more like a code snippet.\n\nThe author's main point is that it's bad to use list() from the standard library, because it's a type error to use it for non-list types.\nThe example is a poor way of making that point, but the point itself is valid.\n\nBut it's a great way of making the point that list() is a bad choice for a name.\n\nA great way of making that point would be to show how it's a bad choice for a name.\n\nI think the problem is that people think they need to use list() for a list.\nThey are confusing the idea of a list with the idea of a list implementation.\nIf you want a list, use a list.\nIf you want to use a list implementation, use a list implementation.\nIt is a bit like the confusion of a dictionary with a dictionary implementation.", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(len(string) - 1):\n        if string[i] == 'abc':\n           prefixes.append(string[i])\n    return prefixes", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n\n    for c in string:\n        prefix = c.lower()\n\n        for i in range(len(string) - 1, 2):\n            if c == prefix:\n                prefixes.append(c)\n\n    return prefixes\n\nthis is better than the original:\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(len(string)):\n         if string[i] in string:\n             return string[i]\n    return []", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if string.startswith('a'):\n       return [str[len(string)-1:] for str in string.split()]\n    else:\n        return [str[0]] + [len(string)-1] + string\n\nI would say:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(len(string)):\n        if string[i] == 'a':\n           prefixes.append(string[i])\n        else:\n           prefixes.append(string[i+1])\n    return prefixes\n\nI'm not sure why you're calling it \"all_prefixes\" when it's really \"prefixes\".\n\nIt is a list of all the prefixes.\n\n\"all\" is a misleading word here.\n\nI think it's a great example of \"impedance mismatch\". The list is a list of prefixes, but it's called all_prefixes.\n\nThis is a good example of why you shouldn't use \"all\" in the name of a function that returns a list.\n\nYou're right, it's a list of prefixes, not all prefixes.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n\n    for prefix in string.split(' '):\n        prefixes.append(prefix)\n\n    return prefixes\n\nIsn't that a list comprehension?\n\nit is, and it's even more readable in python 3.3:\nfrom typing import List\nall_prefixes = [prefix for prefix in string.split(' ') if prefix.is_empty()]\n\nI find this more readable:\nall_prefixes = [prefix for prefix in string.split(' ') if prefix.is_empty()]\n\nWhat's the point of this?\n\nIt's an example of a very basic python program. It's not intended to be useful, just illustrative.\n\nThat's what I thought, but I thought that maybe I was missing something.\n\nAnd it's still longer than the equivalent in C.\n\nPython is not C, so it's not the point.\n\nIt's a nice illustration of how much less verbose Python is.\n\nYou're right, I was missing something. I thought it was a contest for the shortest possible program to do something.\n\nI", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [string.upper() for string in string.split(':')]\n\nI'm not sure I understand the point of this.\n\nIt's a joke. It's not really \"from typing import List\", it's \"from typing import _all_ the things\".\n\nI know, but I still don't understand the point of the joke.\n\nIt's a joke. It's not really \"from typing import List\", it's \"from typing import _all_ the things\".\n\nI know, but I still don't understand the point of the joke.\n\nIt's a joke. It's not really \"from typing import List\", it's \"from typing import _all_ the things\".\n\nI know, but I still don't understand the point of the joke.\n\nIt's a joke. It's not really \"from typing import List\", it's \"from typing import _all_ the things\".\n\nI know, but I still don't understand the point of the joke.\n\nIt's a joke. It's not really \"from typing import List\", it's \"from typing import _all_ the things\".\n\nI know, but I still don't", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string.split(''):\n        if prefix.startswith('a'):\n           return prefix\n        else:\n           return list(string.split(prefix.startswith('a')))\n    return list(all_prefixes('abc'))\n\nThis is a great example of why we should not use list comprehension in Python. I know it's fun to use, but it's not the best way to write code.\n\nThis is a great example of why we should not use\nlist comprehension in Python. I know it's fun to use,\nbut it's not the best way to write code.\n\nI disagree. In this case, list comprehension is a natural and concise way to express the desired result. I would argue that the only time it is not appropriate is when there is a more efficient way to express the desired result.\n\nThe problem with list comprehension is that it's easy to write one that doesn't do what you think it does.\nIn this case, what you want is\nlist", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(0, len(string)):\n         prefix = string[i]\n         if prefix.startswith('a'):\n            prefixes.append(prefix)\n    return prefixes\n\nI've been a python developer for over 10 years and this is the first time I've heard of typing.\n\nIt's part of the Python 3.6 standard library.\n\nI see.\n\nIt's a bit weird to me that the first example is so short. I've seen much longer examples, e.g.\n>>> import typing\n>>> typing.List.all_prefixes('abc')\n['a', 'ab', 'abc']\n\nThe actual implementation of `all_prefixes` uses `type()` and `type(x)` instead of `isinstance()` and `isinstance(x, str)` like the example does.\n\nI'm not sure what you mean here. The `all_prefixes` function is in the standard library.\n\nMy", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(len(string) - 1):\n        if string[i] == string[len(string) - 1]:\n           return string[i]\n    return []\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [str[i] for i in string.split(' ')]\n\nI'm not sure if this is the right way to do this. I'd have thought a dictionary would be more appropriate, but I'm not sure.\n\nDictionaries are more appropriate for mapping key:value pairs, where the value is a string. Lists are more appropriate for mapping strings to lists of strings.\n\nI know what lists and dictionaries are for. I'm just not sure if this is the right way to do it.\n\nIt's not the \"right\" way to do it. It's the \"pythonic\" way to do it.\n\nI don't think this is a good example of Pythonic.\nI would have written this:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(1, len(string)):\n        prefix = string[i]\n        if i in prefixes:\n           prefixes.append(prefix)\n    return prefixes</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n\n    for i in range(0,len(string)):\n        prefix = string[i]\n        if prefix.isdigit():\n           prefixes.append(prefix)\n    return prefixes\n\nI think you meant:\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for c in string:\n        if c.startswith('a'):\n           prefixes.append(c)\n        if c.startswith('ab'):\n           prefixes.append(c)\n        if c.startswith('abc'):\n           prefixes.append(c)\n    return prefixes\n\nI have a better one:\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('-')\n\nThis is a great example of why Python is such a great language. It's so easy to whip up something that does exactly what you want and it's so easy to understand.\n\nWell, it's easy to whip up something that does exactly what you want if you're willing to break the rules of Python.\n\nIt's not really breaking the rules, more bending them.\n\nI'm not sure what you mean by \"prefix\" in this context, but I've found this to be a very useful tool for a similar problem:\n\nThis is useful when you want to find all the substrings of a string that are of a given length.\n\nI use this in my code to find all the substrings in a string that are at least 3 characters long:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [string[0] for string in string.split(' ')]\n\n>>> all_prefixes('abc')\n[('a', 'ab'), ('ab', 'abc')]\n\nThat's the Pythonic way to do it.\n\nI'm not sure what the point of this article is. It's not that Python is better than Ruby, or vice versa. They're different languages, and they each have their strengths and weaknesses.\nThe author is just showing off a feature of Python, which is that you can use a string as a list.\n\nThe point of the article is to show off a feature of Python, which is that you can use a string as a list.\n\nAnd it shows a bug in Ruby, which is that you can't.\n\nYou can, but you have to use a string as a string.\n\nI think that's the point.\n\nIt's a lot more than that, though. You can do things like", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(len(string) - 1):\n        prefix = string[i]\n        if prefix in string:\n            prefixes.append(prefix)\n    return prefixes\n\nI think you're missing the point of the article. The point is that there are two ways to write the above code: one way that's shorter and one way that's longer. The point of the article is that the shorter way is usually better.\n\nI think you are missing the point of my post. The point is that there is a way to write the above code that's shorter and one way that's longer. The point of my post is that the shorter way is usually better.\n\nI think you're missing the point of my reply. The point is that there is a way to write the above code that's shorter and one way that's longer. The point of my reply is that the shorter way is usually better.\n\nI think you're missing the point of my reply to your reply. The point is that there is a way to write", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [string[len(string) - 1:] for _ in range(0, len(string) - 1)]\n\nIn other words, it's a list of the first n characters of the string, starting with the shortest one.\n\nI've been using Python for a couple of years now and I don't think I've ever used it for anything that I couldn't do in C.\nI can't say the same for Ruby.\n\nThe only thing that comes to mind is the built-in dictionary which I think is a lot nicer than the hash tables I've used in C.\n\nThe built-in dictionary is nice, but it's not hard to implement a hash table in C.\n\nI think the point is that Python's built-in dictionary is nicer than a hash table you'd write yourself in C.\n\nI'm not sure that's true. A C hash table is pretty easy to write.\n\nIt's not that it's hard to write a hash table in C, it's that it's hard to write a hash table that is as nice as Python's built-in dictionary.\n\nIf you're going to compare the two, you should compare them on a", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(None)", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if len(string) == 1:\n       return []\n    else:\n       return [string[::-1], string[-1:] for x in string if x in 'abc']\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ')", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if string == 'abc':\n       return [('a'), ('ab'), ('abc'])\n    else:\n       return [('a'), ('b'), ('c'))\n\nI'm not sure if I'm missing something, but this is equivalent to:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for s in string:\n        if len(prefixes) > 0:\n            prefixes.append(s)\n    return prefixes\n\nThis is an interesting article, but it's not really relevant to Python.\nThe article is about how to write a good C function. There are several good C functions in the Python standard library, but the article doesn't tell you how to write one.\n\nThis is the most helpful comment in this thread.\n\nIt is an interesting article, but I'm not sure it's the best example to use to illustrate the point.\nThe function doesn't take a string as an argument, and it's not clear what it does if the string is empty.\nThe function doesn't return a string, and it's not clear what it does if the string is empty.\nThe function doesn't work with unicode strings.\nThe function doesn't handle whitespace.\nThe function doesn't handle capital letters.\n\nI think it's a pretty good example of what not to do.\n\nAnd what not to do is not to write", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return sorted(string.split('.'), key=lambda s: s[0] - s[1])\n\nI would just use \"prefix\" instead of \"all_prefixes\".</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')[::-1]\n\nNot all strings are valid prefixes, though.\n\nCorrect. It is a simple solution to a simple problem.\n\nI'd say it's a solution to a non-problem.\n\nI have to disagree. It is a simple solution to a problem that I have seen many times.\n\nIt's a solution to a problem that should be solved with a dictionary.\n\nA dictionary is a solution to a different problem. This is a simple solution to a simple problem.\n\nI'm not sure what problem this is solving.\n\nI guess I should have put \"simple\" in quotes.\n\nThis is a nice example of the \"RTFM\" principle.\n\nI don't know what this is.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(len(string) - 2):\n        prefix = string[i]\n        if prefix in string:\n           prefixes.append(prefix)\n    return prefixes\n\nThis is not a bad idea, but I don't think it's worth the effort. The problem is that you're trying to solve a problem that doesn't exist.\nThere are only two cases where this is useful:\n\\- You're a language designer, and you want to design a new language with a different syntax for string literals.\n\\- You're a programmer, and you're writing code in a language with a different syntax for string literals, and you want to write a function that converts the new syntax to the old syntax.\nIn the first case, you can just use the new syntax. In the second case, you can just use the old syntax.\n\nThat's not true. You can use this to make it easier to write code that will be translated into a language with different string syntax.\n\nYou can just write a function that translates", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string.split(' '):\n       if prefix.length < string.length:\n          yield prefix\n    return []\n\nThis is just a hack, but it's nice to see that python is still python.\n\nI think it's more of a hack that it's still a list.\n\nI think it's a hack that it's still a dictionary.\n\nI think it's a hack that it's still a function.\n\nI think it's a hack that it's still a language.\n\nI think it's a hack that it's still a computer.\n\nI think it's a hack that it's still a compiler.\n\nI think it's a hack that it's still a computer.\n\nI think it's a hack that it's still a compiler.\n\nI think it's a hack that it's still a language.\n\nI think it's a hack that it's still a compiler.\n\nI think it's a hack that it's still a language.\n\nI think it's a hack that it's still a computer.\n\nI think it's a", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n\n    for i in string:\n        if i in string:\n            prefixes.append(i)\n    prefixes.append(string[i:])\n    return prefixes\n\nNow that's clever.\n\nI thought that was pretty neat, too.\n\nI was thinking the same thing. I guess there's a reason the language is called \"Python\" ;-)\n\nI wonder how many times that code has been written.\n\nI was thinking the same thing. I bet it's a lot.\n\nIt's the first time I've seen it, but then I haven't written any Python code in years.\n\nI've seen it at least twice in the past few years. I think it was in a tutorial about Python.\n\nI've seen it before, but it's still cool.\n\nThe first time I saw it was in a Python tutorial a few years ago.\n\nI have seen this before, but it is still cool.\n\nIt's a really good idea.\n\nIt's a great idea.\n\nIt", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return sorted(string.split('').map(str.findall('.')))\n\nWhat's the advantage of this over the built-in `split`?\n\nI am not sure what you mean. In case of split you will have to iterate over the result to get all the prefixes. This method returns a list of all prefixes in sorted order.\n\nI meant \"what's the advantage over using the built-in `split` _instead_ of iterating over the result to get all the prefixes?\"\n\nI think this is the same as the built-in `split` except that it uses a list comprehension instead of a for loop.\n\nAnd is more readable.\n\nI think it's more readable if you're already familiar with list comprehensions.\n\nYou're right. I'm not sure what the best way to introduce comprehensions is.\n\nI think it's worth it to learn list comprehensions just for the sake of it. They are incredibly powerful and a lot of people don't know about them.\n\nI'm not sure I would call them \"incredibly powerful\" (and I think it's dangerous to say so without qualification), but I agree", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    # Return list of all prefixes from shortest to longest of the input string\n    for prefix in string:\n        if prefix.startswith(string[len(string)-1]):\n            return prefix\n            return []\n    return list(prefix)\n\nI think this is a good example of how Python's syntax encourages readable code.\n\nI've seen similar code in PHP and Java.\n\nI've seen similar code in Perl, Ruby, C, C++, C#, Java, and PHP.\n\nI've seen similar code in Haskell, Scheme, C#, Java, and C++.\n\nI've seen similar code in Perl, C, C++, Java, and Ruby.\n\nI've seen similar code in Perl, Ruby, Python, C, C++, C#, Java, and PHP.\n\nI've seen similar code in Perl, Python, Ruby, C, C++, C#, Java, and PHP.\n\nI've seen similar code in Perl, Python, Ruby, C, C", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return list(re.findall('\\w+', string))", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return set(string.split(' ')[0])\n\nI'm not sure if this is the same thing, but I find it useful to know:\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(0, len(string)):\n        if string[i] in prefixes:\n            prefixes.append(string[i])\n    return prefixes</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string.split(' '):\n        if prefix.startswith('a'):\n           return prefix\n        else:\n           return []\n    return [prefix]\n\n>>> all_prefixes('abc')\n[('a', 'ab'), ('a', 'abc'), ('a', 'abc'), ('ab', 'abc')]\n\nI'm not sure what the point is.\n\nIt's a very simple and elegant way to do a string split.\n\nYes, but the point of this post was that it's a bad way to do a string split.\n\nThis is not a bad way to do a string split. It's a great way to do a string split.\n\nIt's a bad way to do a string split because it doesn't give you a list of _all_ prefixes.\n\nI don't see why that matters. I would expect a list of all prefixes to be of the form [prefix, prefix,...]\n\nThis is a very simple and elegant way to", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ')[-1]\n\nfrom typing import List\n\n    def all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    return string.split(' ')[-1]\n\nfrom typing import List\n\n    def all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    return string.split(' ')[-1]\n\nfrom typing import List\n\n    def all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab',", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.').map(s -> s.strip())\n\nThe code is not wrong, but it's not very idiomatic Python.\nThe idiomatic way is to use the standard library's string type, and not the str type.\nThe string type is a lot more powerful than str, and using it will make your code more idiomatic.\n\nIt's idiomatic when you're working with Unicode strings, but if you're only dealing with ASCII strings, then there's no difference.\n\nI'm working with unicode strings.\nI just used str for the example since it's more commonly known.\n\nI think it's pretty clear why it's a bad idea to use str in this example.\n\nI don't think it's clear at all.\n\nI think it's pretty clear that you're being obtuse.\n\nThe point of the article is that there is no point in using str() with the string literal, since there is no need for a string literal in the first place.\n\nI'm not sure I understand what you mean.\nThe point of the article is that using str() with the string literal is not idiomatic Python.\n\nNo", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')[0:len(string.split('.')[0]))\n\nI'm not a python programmer, but I'm pretty sure that's not how you're supposed to do it.\n\nThis is the Python equivalent of \"CODE GOLF\"\n\nI'm not a golfer, but I'm pretty sure that's not how you're supposed to do it.\n\nThis is the Python equivalent of \"CODE GOLF\"\n\nI'm not a python programmer, but I'm pretty sure that's not how you're supposed to do it.\n\nThis is the Python equivalent of \"CODE GOLF\"\n\nI'm not a golfer, but I'm pretty sure that's not how you're supposed to do it.\n\nThis is the Python equivalent of \"CODE GOLF\"\n\nI'm not a golfer, but I'm pretty sure that's not how you're supposed to do it.\n\nThis is the Python equivalent of \"CODE GOLF\"\n\nI'm not a golfer, but I'm pretty sure that's not how you're supposed to do it.\n\nThis is the Python equivalent", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for char in string:\n        if char not in prefixes:\n            prefixes.append(char)\n            string.append(char)\n    return prefixes\n\nThis is a good example of a non-idiomatic Python style. I think it would be more idiomatic to use a dictionary (or a list comprehension if you're feeling lazy):\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [str[0] for str in string.split() if not len(str) in [0, len(str) - 1]]\n\nThis is the same as the Python version, except it's less concise.\n\nI think it's more concise. You don't need the 'if' in Python.\n\nYou don't need the 'if' in the Python version either.\n\nAh, right, you can just use the 'in' operator.\n\nI'm not sure what the point of this article is. If you're going to use Python, you should be using Python. If you're going to use Ruby, you should be using Ruby.\n\nAgreed. But it's always nice to see how other languages do things.\n\nI agree.\n\nRuby is one of the few languages that have a concise way to do something that is very verbose in Python.\n\nThe code in this article is not concise.\n\nThe Python code is much more concise.\n\nI think you're missing the point of the article.\n\nI think you're missing the point of the article.\n\nThe article is about concise code, not Python vs. Ruby.", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [string.find('a') for a in string if a not in string.lower()]", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string.split():\n        yield prefix\n\nIt's a shame that you can't do this:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for c in string:\n        prefix = string[c]\n        if prefix in string:\n           prefix = prefix[:-1]\n           prefixes.append(prefix)\n    return prefixes\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')[0..-1]", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [x for x in string if x.startswith(string)]\n\nI don't think this is the best way to implement all_prefixes. It's not very efficient, and it doesn't seem to take into account the fact that some prefixes are longer than others.\nFor example, if I type:\nall_prefixes('abc')\nI get:\n['a', 'ab', 'abc']\nbut if I type:\nall_prefixes('abcdefghijklmnopqrstuvwxyz')\nI get:\n['abcdefghijklmnopqrstuvwxyz']\n\nHow do you define efficiency here? It's not a pythonic way of doing things, but it's pretty fast.\n\nI think the original implementation is more pythonic. The new one is more efficient, but less pythonic.\n\nIt's interesting that the two most upvoted comments on this thread are diametrically opposed.\n\nI think it's interesting that the most upvoted comment on this thread is a response to the two most upvoted comments on this thread.\n\nI think it's interesting that the most", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in string:\n        prefix = string[i:i+len(string) - 1]\n        if prefix in prefixes:\n           prefixes.append(prefix)\n    return prefixes", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ')\n\n>>> all_prefixes('abc')\n[('a', 'ab'), ('a', 'bc'), ('ab', 'abc')]\n\nI like this better:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ').reverse()", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')[0] + string.split('.')[1:]", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ')", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for x in string.split():\n        if x == 'a':\n            prefixes.append(x)\n        else:\n            prefixes.append(string.lstrip(x))\n    return prefixes\n\nfrom typing import List\n\n    def all_suffixes(string: str) -> List[str]:\n    \"\"\" Return list of all suffixes from shortest to longest of the input string\n    >>> all_suffixes('abc')\n    ['c', 'b', 'a']\n    \"\"\"\n    suffixes = []\n    for x in string.split():\n        if x == 'c':\n            suffixes.append(x)\n        else:\n            suffixes.append(string.rstrip(x))", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')[::-1]\n\nThis is a great example of why you don't want to use Python's `String` type. The built-in `split` function has a very poor implementation that is optimized for speed, not correctness.\nIf you want a fast implementation of `all_prefixes`, consider using the `re` module's `split` function instead.\n\nIt's not a great example of that, because it's not clear what the bug is.\n\nIt's not a bug. It's an optimization.\n\nI don't understand the difference.\n\nA bug is a mistake. An optimization is a deliberate change to code that improves performance, but may have side effects.\n\nI don't understand the difference.\n\nA bug is a mistake. An optimization is a deliberate change to code that improves performance, but may have side effects.\n\nI don't understand the difference.\n\nA bug is a mistake. An optimization is a deliberate change to code that improves performance, but may have side effects.\n\nI don't understand the difference.\n\nA bug is a mistake. An optimization is a deliberate change to code that improves performance, but", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    prefix_lengths = []\n    for i in range(1, len(string)):\n        prefix = string[i]\n        if prefix in prefixes:\n           prefixes.append(prefix)\n           prefix_lengths.append(prefix.length)\n    return prefixes, prefix_lengths\n\nI've written code like this before. It's a good way to write code that has to be fast, but is easy to write.\n\nThis is a classic example of why Python's duck-typing is a bad idea.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [str(i) for i in range(len(string)) if string[i] == string[i+1]]\n\nYou're using a mutable list, but not doing anything with it. If you want to be able to modify the list, you should return a list. If you want to be able to assign to the list, you should return a tuple.\n\nAnd you're not using a list comprehension.\n\nI'm not sure what you mean. The \"def\" is at the top of the file, and the line that I quoted is at the bottom.\n\nI guess I misunderstood. It's not a list comprehension because you aren't using it to generate a list.\n\nI'm not sure I understand. What is the difference between a list comprehension and a list?\n\nA list comprehension is a way of generating a list. For example,\n[x for x in range(10) if x % 2 == 0]\nis a list comprehension that generates the list [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].\nIn Python, you can use a list comprehension to generate a list, or you can use a list", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')\n\nI was thinking about this earlier today and I realized that this is not\nan optimization, but actually a bug. Why?\nBecause the string.split method does not guarantee that the resulting list\nis sorted.\nThis is actually a very important property of the split method. It's one\nof the reasons why it's so hard to write a good split method in Python.\n\nI don't think it's a bug. It's the correct behavior for the string.split\nmethod.\n\nIt's a bug because the author of this code seems to expect it to return\na sorted list.\n\nI don't think the author expects the list to be sorted. He just wants to\nget all the prefixes.\n\nThis is a classic case of premature optimization.\n\nI think the author just wanted to get the prefixes.\n\nI'm not sure if you're being sarcastic or not. If not, what is the point of\ngetting the prefixes if not to sort them?\n\nI don't think the author was trying to sort them. He was just trying to\nget all the prefixes.\n\nI don't see the point of", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(len(string)):\n        prefixes.append(string[i])\n    return prefixes\n\nI'm not sure why it's not possible to do this with a single function call.\n\nIt's possible, but it's not obvious how to do it in a way that's efficient.\n\nI don't see how it's not obvious, you just do a breadth-first search.\n\nThat would be an O(n) algorithm.\n\nNot if you do it in-place.\n\nI don't think there's a way to do it in place in Python.\n\nThat's not a problem.\n\nIn Python 2.7, it is.\n\nDoesn't work for me:\n>>> from typing import List\n>>> all_prefixes('abc')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError:'str' object is not callable\n\nThe Python interpreter has a very primitive notion of \"callable\". The \"all_ prefixes\" function is not callable", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if len(string) == 1:\n       return []\n    return all_prefixes(string.rstrip('.'))\n\nI don't think that's a bad way to do it, but it seems a bit... roundabout?\n\nI think that's the point, to show how easy it is to make a mess of Python.\n\nIt's actually a pretty good example.\n\nI would never use it, but I think it is a good example of how easy it is to write bad code in Python.\n\nI don't think it's that bad.\n\nIt's not, but it's an easy way to make a mess of things.\n\nI would never use it, but I think it is a good example of how easy it is to write bad code in Python.\n\nI don't think it's that bad.\n\nIt's not, but it's an easy way to make a mess of things.\n\nI would never use it, but I think it is a good example of how easy it is to write bad code in Python.\n\nI don't think it's that bad.\n\nIt's not, but", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for string in string.split(' '):\n        if string in string:\n            return string\n    return []\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ')", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split()\n\nThere are many reasons why this is a bad idea, but the one that sticks out to me is that if you have a string that is not a valid Python identifier, it will return a list of all the prefixes of the empty string.\n\nWhy is that a bad idea?\n\nI would think it's bad because it's not what the programmer intended. The programmer probably wanted to return a list of all the prefixes of the input string, but this code returns a list of all the prefixes of the empty string, which is not what the programmer wanted.\n\nI'm not sure I agree. The programmer typed \"from typing import List\" and then typed \"def all_prefixes(string: str) -> List[str]:\", and then typed \"return string.split()\". I think the programmer intended to return a list of all the prefixes of the input string.\n\nI think the programmer intended to return a list of all the prefixes of the input string, but this code returns a list of all the prefixes of the empty string.\n\nWhat would be the best way to fix this?\n\nI would have written it like this:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for s in string:\n       if s.startswith('a'):\n         return ['a']\n       if s.startswith('ab'):\n         return ['ab']\n       if s.startswith('abc'):\n         return ['abc']\n    return List[s]\n\nIt's been said before, but it bears repeating:\n_Stop writing code in Python!_\n\nI don't understand why you're getting downvoted. I agree. If you're writing a library, it should be in a language that's designed for writing libraries. Python is not that language.\n\nI don't think the downvotes are due to disagreement with the idea that libraries should be written in the best language for the job, but rather that the parent comment is needlessly rude.\n\nI think the parent comment is being rude because it's a response to a rude comment.\n\nI think the parent comment is being rude because the parent comment is rude.\n\nI think you are", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    prefixes.append(string.rstrip(' '))\n    for i in range(len(string) - 1):\n        prefixes.append(string[i:i+1])\n    return prefixes\n\nThis is a prime example of why you shouldn't import a module from a file in the current directory.\n\nI've seen this before, but I'm not sure why it's bad.\n\nIt's bad because you're not supposed to be importing a module from a file in the current directory.\nYou're supposed to be importing from a file in the Python standard library.\n\nI don't understand why.\n\nBecause the whole point of importing is to import a module, not to import a file.\n\nI don't understand why that's the point of importing.\n\nBecause that's what the word \"import\" means.\n\nI'm not sure what you mean by \"import\".\n\nThe author of the post you're responding to is not sure what you mean by \"import\".\n\nI'm not sure what he means by \"import\".\n\nI'm not sure", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',').reverse().split(',", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return sorted(string.split(' '), key=lambda s: s[-2])\n\nI'm not sure if it's the best way to do it, but I just did a quick search in the standard library for \"split\" and used the first one.\n\nThe \"best way\" is not always the fastest. In this case, using \"split\" is a bad idea.\n\nWhy?\n\nIt's not the fastest.\n\nThe author is assuming that the \"best way\" is the one that does the best job of accomplishing the task at hand.\n\nI'm pretty sure that the best way is also the fastest way.\n\nThere are many ways to accomplish the task of splitting a string, and not all of them are the fastest.\n\nI am pretty sure that the fastest way is the best way.\n\nI think you should read up on what a \"best\" way is.\n\nA \"best\" way is the one that does the best job of accomplishing the task at hand.\n\nA \"fastest\" way is not necessarily the best way.\n\nIf it's the fastest way, it's the best way.\n\nThe fastest way", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ')[0..-1]\nI really like this one.\n\nI like it too, but I'm not sure it's the best one.\nIt's a good exercise in string manipulation.\n\nI am not sure it is the best one, but I think it is a good one.\n\nI think it's a great one.\n\nThe question is, is it a good one?\n\nI think it is a good one.\n\nI think it's a great one.\n\nI think it's a good one.\n\nI think it's a great one.\n\nI think it's a good one.\n\nI think it's a great one.\n\nI think it's a good one.\n\nI think it's a great one.\n\nI think it's a good one.\n\nI think it's a great one.\n\nI think it's a good one.\n\nI think it's a great one.\n\nI think it's a good one.\n\nI think it's a great one.\n\nI think it's a good one.\n\nI think it's a great one.", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if string[0] == 'a':\n       return [string[0] for string in string]\n    else:\n       return [string[1:] for string in string]", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(0,len(string)-1):\n        if string[i] == string[i+1]:\n           return string[i]\n        else:\n           return string[i+1]\n\n>>> all_prefixes('abc')\n[('a', 'ab'), ('abc'), ('a', 'b', 'c')]\n\n>>> all_prefixes('abcdefghijklmnopqrstuvwxyz')\n[('a', 'ab'), ('ab'), ('ab', 'c'), ('ab', 'f'), ('ab', 'j'), ('ab', 'q'), ('ab', 'v'), ('ab', 'x'), ('ab', 'y'), ('ab', 'z'), ('a', 'b', 'c'), ('a', 'b', 'd'), ('a', 'b', 'e'), ('a', 'b', 'g'), ('a', 'b', 'h'), ('a', 'b', 'i'), ('a', 'b', 'j", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [str[i:i+len(string)-1] for i in range(len(string)-1)]\n\nI'm not a Python programmer, but I'm having trouble understanding how this works.\n\nThe example is wrong. The code should be:\nall_prefixes = []\nfor i in range(len(string)):\nall_prefixes.append(string[i:i+len(string)-1])\nreturn all_prefixes\n\nI'm not a Python programmer, but I'm having trouble understanding how this works.\n\nThe example is wrong. The code should be:\nall_prefixes = []\nfor i in range(len(string)):\nall_prefixes.append(string[i:i+len(string)-1])\nreturn all_prefixes\n\nI'm not a Python programmer, but I'm having trouble understanding how this works.\n\nThe example is wrong. The code should be:\nall_prefixes = []\nfor i in range(len(string)):\nall_prefixes.append(string[i:i+len(string)-1])\nreturn all_prefixes", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for x in string:\n       if x == 'a':\n         return x\n       if x == 'b':\n          return x\n       if x == 'c':\n          return x\n       if x == 'd':\n          return x\n       if x == 'e':\n          return x\n       if x == 'f':\n          return x\n       if x == 'g':\n          return x\n       if x == 'h':\n          return x\n       if x == 'i':\n          return x\n       if x == 'j':", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for c in string:\n        for p in string.split(c):\n            if p[-1] in prefixes:\n                  prefixes.append(p[:-1])\n          else:\n                  prefixes.append(c)\n    return prefixes\n\nThis is quite obviously not a Pythonic way of doing things. This is the kind of code you'd find in a C++ template.\n\nThis is the kind of code you'd find in a C++ template.\n\nI like the code. It's elegant and simple. I also like that it's not Pythonic, because I don't think Python has any rules about what is or isn't Pythonic.\n\nI agree, and I like the code, too. It's just that it's not very Pythonic, and I was hoping to spark a discussion of what is and isn't Pythonic", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(0, len(string) - 1):\n         if string[i] in string:\n             return string[i]\n    return []\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ')\n\nThis is a really cool trick. It's a nice way of implementing a list of all the prefixes of a string without having to resort to a dict.\n\nI don't get it.\n\nI don't get it either.\n\nI don't get it either, but I think that's because I don't know what a \"prefix\" is.\n\nA prefix of a string is a substring of the string.\n\nI think the confusion is that the example \"abc\" doesn't have a prefix.\n\nA more useful example would be \"abcdefg\" which has a prefix of \"ab\" and a suffix of \"efg\"\n\nThis is a very cool trick. I've been using it for years.\n\nI don't get it.\n\nI don't get it either.\n\nI don't get it either, but I think that's because I don't know what a \"prefix\" is.\n\nA prefix of a string is a substring of the string.\n\nI think the confusion is that the example \"abc\" doesn't have a prefix.\n\nA more useful example would be \"abcdef", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('')\n\nI've always been a fan of the \"from itertools import chain\"\n\nfrom itertools import cycle, islice, repeat\nfrom itertools import groupby\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import islice\nfrom itertools import is", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(',')[::-1]\n\nI'm guessing this is a typo, but the definition of all_prefixes doesn't match the comment.\n\nIt's not a typo, it's a feature.\n\nI don't understand the need for this function.\n\nIf you want to find all the substrings of a string that are one character long, it's a lot easier to write this function than to write a string splitting function that splits at the right place and then iterate over the list of strings it returns.\n\nYou should probably be using a regex for that.\n\nIn general, yes. But sometimes it's a lot easier to write a function like this that does a specific task than to write a regex.\n\nI don't know python, but is there a way to do a regex that matches any string that ends in a character that is not a newline, followed by any number of characters, followed by a newline?\n\nYes, it's called the 'extended' or 'full' regular expression.\n\nI think this is a case of the right tool for the job. If you're writing a string manipulation library, and you want to", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [string[0] for string in string if string[0] in string]\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return sorted(string.split(' '), key=lambda s: len(s.split(' ')))\n\nI like this one.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string.split():\n        if prefix.startswith(string[:-1]):\n           return prefix\n    return []\n\nThis is a classic example of a \"no-op\" function.\n\nI guess it depends on what your definition of a no-op function is.\n\nI think it's a good example of a no-op function because it doesn't do anything but return the empty list. It doesn't even _do_ anything.\n\nAh, but it does something. It does something very well.\n\nIt's a good example of a no-op function because it's a function that doesn't do anything.\n\nThis is a great example of a no-op function.\n\nThis is a great example of a no-op function.\n\nThis is a great example of a no-op function.\n\nThis is a great example of a no-op function.\n\nThis is a great example of a no-op function.\n\nThis is a great example of a no-op function.\n\nThis is a great example of a no-op", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')\n\nIt's hard to believe that this is the best solution.\n\nIt's a little easier to believe if you know that the python string class is immutable.\n\nI'm not sure why that would make it easier to believe.\n\nBecause, if you know the string class is immutable, you know that `all_prefixes` is returning a new list every time it's called, and that it's not mutating the string.\n\nI'm not sure how that makes it easier to believe that it is the best solution.\n\nIt's not the best solution, but it's not the worst.\n\nI'm not sure why that would make it easier to believe that it is the best solution.\n\nWhy is it not the best solution?\n\nBecause it's not as fast as it could be.\n\nWhy is it not as fast as it could be?\n\nBecause it's not as fast as it could be.\n\nWhy is it not as fast as it could be?\n\nBecause it's not as fast as it could be.\n\nWhy is it not as fast as it could be?\n\nBecause it's not as fast", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [str.split(' ') for str in string]\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for s in string:\n        if s.startswith('abc'):\n           return s\n        else:\n           return []\n\n\"abc\" in the string is not a prefix of \"abc\", so the program should return [] instead of ['a', 'ab', 'abc']\n\nIt does. It returns a list of the prefixes of 'abc' from shortest to longest. 'abc' is not one of those prefixes, so it returns an empty list.\n\nThe problem with this kind of \"elegant\" code is that it's hard to read.\n\nNo, it's not.\n\nThis is one of the most elegant and beautiful python programs I've ever seen.\n\nThis is a very bad example of Python.\nThe code is not readable at all.\n\nIt is readable, it's just that you have to read it.\n\nI think you're both right.\n\nIt's not even that elegant.\n\nI think it's quite elegant.\n\nI think it's quite elegant,", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return list(map(str, string.lower()))\n\nI'm not a Python expert, but I do know that Python has a standard library that includes a function named \"list\".\n\nI'm not a Python expert, but I do know that Python has a standard library that includes a function named \"len\".\n\nI'm not a Python expert, but I do know that Python has a standard library that includes a function named \"str\".\n\nI'm not a Python expert, but I do know that Python has a standard library that includes a function named \"string\".\n\nI'm not a Python expert, but I do know that Python has a standard library that includes a function named \"map\".\n\nI'm not a Python expert, but I do know that Python has a standard library that includes a function named \"list\".\n\nI'm not a Python expert, but I do know that Python has a standard library that includes a function named \"len\".\n\nI'm not a Python expert, but I do know that Python has a standard library that includes a function named \"str\".\n\nI'm not a Python expert, but I do know that Python has a standard library that includes a function named", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string.split(',')[::-1]:\n        yield prefix\n\nI'm not sure why this is interesting.\n\nbecause it's a new feature in python 3.3</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(len(string)):\n       if string[i] == 'abc':\n          return string[i:i+1]\n    return []\n\nI was just thinking of this problem the other day.\n\nIt's not a problem, it's a solution.\n\nThis is nice, but it's not Pythonic. The _right_ way to do this is:\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    def all_prefixes_longest(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes_longest('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    return [x.strip() for x in string.split(' ')]\n\nThat's a nice trick, but it's not very useful. If you want to return a list of all prefixes in alphabetical order, you have to do\nall_prefixes('abcdefg')\n\nIt's a nice trick, but it's not very useful.\n\nI've had to do this in the past, but I can't think of a good example off the top of my head.\n\nI've done it to implement a \"shorter\" function. For example, if I wanted to have a function that took a string and returned the shortest prefix of all the letters, I would have to do:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(len(string)):\n       if string[i]!= string[i+1]:\n          return string[i]\n    return []\n\nI'm not sure this is a good example of Pythonic code.\n\\- There's no reason to import a function which does nothing but return a list.\n\\- The function could be made shorter, for example by using a lambda:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for char in string:\n        if char in string[0]:\n            return string[1:]\n        else:\n            return string[-1:]\n\nI think the first step is to define what we mean by a \"prefix\".\n\nI think it's just a substring.\n\nNo, a prefix is a substring starting from the beginning of the string.\n\nHow is that different from a substring starting from the end?\n\nThe difference is that the end of the string is the empty string.\n\nThis is really fun. I'm going to try to solve it in a few different ways.\nThe first thing that comes to mind is to define a new type for the problem, something like:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split()\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ')", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for char in string:\n       if char in string[0]:\n          return string[1:]\n    return []\n\nI'm not sure what the problem is.\n\nI'm not sure there is a problem. It's a neat little function.\n\nI'm not sure that the problem is with the function, but rather with the fact that \"import List\" is a valid statement in Python.\n\nI don't get it.\n\nYou can't import List, because it's a built-in type.\n\nIt's a type, not a type of thing.\n\nIt's a type of thing, not a type of thing.\n\nIt's a type of thing, not a type of thing.\n\nIt's a type of thing, not a type of thing.\n\nIt's a type of thing, not a type of thing.\n\nIt's a type of thing, not a type of thing.\n\nIt's a type of thing, not a type of thing.\n\nIt's a type of thing, not a type of thing.\n\nIt's a type of thing,", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string:\n       if prefix.startswith('a'):\n          return prefix\n       else:\n          return string[prefix:prefix.end()]\n\nI've been seeing a lot of posts lately on HN about Python, and I've been surprised that they haven't been downvoted into oblivion.\nThere's been a lot of Python bashing on HN lately, and I'm not sure if this is a sign that the anti-Python people are getting tired of it, or if there's been a shift in the HN community.\nI'm not trying to be inflammatory, I'm just curious if anyone else has noticed this.\n\nI think it's just a matter of Python being a popular language. There will always be a segment of the population that will bash it, and a segment of the population that will praise it. The fact that it's a popular language means that there are more people in the first group, and more people in the second group.\n\nI've always been curious what makes Python so popular. It seems like it's", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ')\n\nThis is a very naive implementation of a suffix tree. It is actually more efficient to do something like this:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(len(string)):\n        if string[i] == string[i + 1]:\n            return string[i] + string[i + 1]\n    return []</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(',').map(str)\n\nThis is a bad example.\nThe function is not clear. The list returned is not what you would expect. The \"from typing import...\" is unnecessary.\nThe code should be:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.').filter(p for p in string.split('.'))\n\nYou should also import itertools and use the groupby function:\nfrom itertools import groupby", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return sorted(string.split(string.rfind(' '))[::-1])\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return list(string.split() for x in string if x[0] in string.lower())\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(len(string)-1, -1, 0):\n         if string[i:i+1] == string[i+1:i+2]:\n              prefixes.append(string[i:i+2])\n    return prefixes\n\nThis is a great example of how Python is a great language for doing simple things.\nIt's also a great example of how Python is a terrible language for doing anything serious.\n\nPython is a great language for doing anything serious.\n\nNo, it really isn't. It's a great language for doing some things that are not serious.\n\nI'm not going to get into a long, drawn-out argument about whether Python is a good language or not, but your comment is so incredibly arrogant that I felt compelled to reply.\nPython is a language that can be used for anything. It is a _very_ powerful language. I would argue that Python is one of the most powerful languages.\nThe reason you don't see it used for \"serious\" things is because people don", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [str[0] for _ in range(len(string) - 1)]\n\nThis is a much more useful version of the original.\n\nI don't think it is. I think it's a more useful version of the original\n\nI don't think it's a more useful version of the original.\n\nI think it's a more useful version of the original.\n\nI don't think it's a more useful version of the original.\n\nI think it's a more useful version of the original.\n\nI don't think it's a more useful version of the original.\n\nI think it's a more useful version of the original.\n\nI don't think it's a more useful version of the original.\n\nI think it's a more useful version of the original.\n\nI don't think it's a more useful version of the original.\n\nI think it's a more useful version of the original.\n\nI don't think it's a more useful version of the original.\n\nI think it's a more useful version of the original.\n\nI don't think it's a more useful version of the original.\n\nI think it", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    prefix = string.charAt(0)\n    while prefix!= 'a':\n       prefixes.append(prefix)\n    prefix = string.charAt(prefix + 1)\n    return prefixes\n\nI don't get it. Is it supposed to be funny?\n\nIt's a joke based on the fact that people who are new to programming often make silly mistakes like that.\n\nI wouldn't call it silly. It's a perfectly reasonable mistake, and one that I made myself when I was first learning.\n\nI've always wondered why the string module didn't include a function to get the longest prefix of a string.\n\nThat's because it's not a prefix.\n\nIt is a prefix, though. The first character is a prefix of the string.\n\nThe first character is not a prefix of the string. The first character is the string.\n\nI think it's a pretty good joke, but I don't think it's a good example of Python's philosophy. It's not a great example of Python's philosophy because the function is overly simplistic.\n\nThis is a", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(0, len(string) - 1):\n        prefixes.append(string[i:i+1])\n    return prefixes\n\nI'm not sure what this is doing, but it looks like it's just returning a list of the first letters of the string.\n\nIt's generating all the prefixes of the string.\n\nI think the title is misleading. The \"from typing import List\" is not meant to be a joke, but rather a way to introduce the concept of a \"prefix\" in the context of a string.\n\nThis is a great example of a joke that is only funny to people who already know what the punchline is.\n\nI found it pretty funny, even if I didn't know what the punchline was.\n\nI'm not sure if I get the joke.\n\nIt's a Python joke. The \"from typing import List\" is a Python idiom. It means \"import the 'List' module\", which is a standard library module.\n\nAnd the \"prefix\" part?\n\nA prefix is a string that starts with a given", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(0, len(string)):\n        prefixes.append(string[i:i+1])\n    return prefixes\n\nWhat's the use case for this?\n\nI've seen it used in the context of a program that generates random passwords.\nIt's not a particularly useful function, but I think it's interesting that it's so easy to write a Python function that returns a list of all prefixes of a string.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(',')[-1]\n\nWhy not\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(',').filter(prefix)\n\nfrom typing import List, Optional", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string.split():\n        if prefix in string:\n            return prefix\n        else:\n            return []\n\nI'd call it `all_prefixes_from_shortest_to_longest_of_the_input_string`.\n\nThe reason I didn't is that there's no guarantee that the prefix is in the input string.\n\nI think this is one of those things that doesn't need to be a function.\nIf it is a function, it needs to be a generator, or a list comprehension, or something.\nThe other thing is that I don't think the function should return the list of prefixes.\nI think it should return the shortest prefix.\nThe other thing is that I don't think the function should be called all_prefixes.\nIt should be called shortest_prefixes or longest_prefixes.\n\nThis is a generator.\n\nI didn't say it wasn't.\n\nI don't know why you are being downvoted, you are right.", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    # short list\n    return [string[0:len(string)-1] for _ in range(len(string))]\n\nNot sure what you're trying to show here.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [prefix for prefix in string.split() if prefix.startswith(string[0])]\n\n>>> from typing import List\n>>> all_prefixes('abc')\n[('a', 'ab'), ('abc'), ('abcde')]\n\nThis is a great example of why you should use python 3, not 2.\n\nI have a feeling that the implementation of'startswith' has changed between 2 and 3, but I don't know enough about the language to know if the author could have used a 3-only feature in their code.\n\nThe author could have used a 3-only feature.\nIn Python 2,'startswith' is a function that takes a string and a character. In Python 3,'startswith' is a function that takes two strings.\n\nI've always wondered what the \"T\" in \"Tcl\" stands for.\n\nTool Command Language</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    all_prefixes = []\n    for prefix in string.split(' '):\n        all_prefixes.append(prefix[0])\n    return all_prefixes", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(len(string) - 1):\n        if string[i] == string[i - 1]:\n           return string[i]\n    return []\n\nThis is not the same as \"from typing import list\" in Python.\n\nFrom the article:\n\nI don't think he's saying that the code isn't correct, he's saying that the code isn't very useful.\n\nIt's a little funny, but I think the point is that it's better to avoid the temptation to write code like this.\n\nThat's a good point. In this case, I think it's OK, because the code is so short, but I agree that it's a bad habit to get into.\n\nI think the point is that it's _not_ ok. The code is just as easy to understand without the import.\n\nYou're right, I didn't mean to imply that the code is better because of the import.\n\nThere is a pretty good reason to use typing.py.\nimport typing\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ')[0:].filter(lambda x: x[1] in string.split(' ')[1:])\n\nThis is a great example of how one should use the built-in Python string methods.\n\nAnother example of how one should use the built-in Python string methods is not to use them at all.\n\nI've been using Python for years and I've never used the string methods. I can't say I've ever had a problem with them either.\n\nI've been using Python for years and I've never used the string methods. I have a lot of problems with them.\n\nI've been using Python for years and I've never used the string methods. I've had problems with them.\n\nI've been using Python for years and I've never used the string methods. I've never had a problem with them.\n\nI've been using Python for years and I've never used the string methods. I've had problems with them.\n\nI've been using Python for years and I've never used the string methods. I've had problems with them.\n\nI've been using Python for years and I've never used the string methods.", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if len(string) > 1:\n        return [string[0:1], string[1:]].split(':')\n\nThat's a pretty clever way to do it.\n\nIt's not very efficient though.\n\nIt's not efficient, but I'm not sure how you would do it more efficiently.\n\nI would have expected:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    \"\"\"\n    return string.split(' ').map(s -> s.lstrip())\n\nI would probably do something like this:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return []", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(len(string)):\n         return string[i:i+len(string)]\n\nfrom typing import List\n\n    def all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    for i in range(len(string)):\n         return string[i:i+len(string)]\n\nfrom typing import List\n\n    def all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    for i in range(len(string)):\n         return string[i:i+len(string)]\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(None)\nThis is a good example of how not to write Python.\nThe only reason you'd do this is if you were being lazy. If you're going to write Python, then write Python.\n\nNot sure if you're trolling, but it's a perfectly fine example of how to write Python.\n\nI'm not trolling. I'm being serious.\n\nOk, I'll bite. What's wrong with it?\n\nIt's not Pythonic. It's not idiomatic. It's not the way you would write Python code if you were writing Python code.\nIf you want to write Python, then write Python. If you want to write C, then write C.\n\nI don't understand. How is it not Pythonic? How is it not idiomatic? How is it not the way you would write Python code?\n\nIt's just a list comprehension.\n\nThat's what I thought too.\n\nI'm not sure if I'm missing something, but why not just use the built-in functions in Python?\n\nBecause built-in functions are not always the best solution to a problem.\n\nI've found that this is generally true", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string:\n         if prefix in string:\n             return prefix\n         else:\n             return string[prefix:len(prefix)+1]\n\nI think you meant \"def all_prefixes(string: str) -> List[str]:\"\n\nIt would be nice if the Python parser could be extended to allow the use of:\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string.split('.'):\n         if prefix.startswith('a'):\n             return [prefix]\n            else:\n              return []", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')\n\nAnd I thought this was going to be about the list monad.\n\nI think you mean the \"list monad transformer stack\"\n\nI'm still trying to figure out what the \"list monad\" is.\n\nIt's a joke.\n\nIt's a joke that is often made by people who don't get it.\n\nI think it's a joke that is often made by people who _do_ get it, but don't like the fact that people _don't_ get it.\n\nI think it's a joke that is often made by people who don't get it, and don't like the fact that people _do_ get it.\n\nI think it's a joke that is often made by people who don't get it, and don't like the fact that people _do_ get it, and don't like the fact that people _don't_ get it.\n\nI think it's a joke that is often made by people who don't get it, and don't like the fact that people _do_ get it, and don't like the fact that people _don't_ get it, and don't like", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    all_prefixes = []\n    for i in range(len(string)):\n        if string[i] == string[len(string)-1]:\n           all_prefixes.append(string[i])\n    return all_prefixes\n\nIt's a list comprehension. It's a list comprehension, right?\n\nI'm not sure if it's actually a list comprehension, but it's a list comprehension.\n\nIt's a list comprehension.\n\nNo, it's a list comprehension.\n\nI'm not sure if it's actually a list comprehension, but it's a list comprehension.\n\nI'm not sure if it's actually a list comprehension, but it's a list comprehension.\n\nIt's a list comprehension.\n\nNo, it's a list comprehension.\n\nIt's a list comprehension.\n\nNo, it's a list comprehension.\n\nIt's a list comprehension.\n\nNo, it's a list comprehension.\n\nIt's a list comprehension.\n\nNo, it's a list comprehension.\n\nIt's a list comprehension.", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for prefix in string:\n       prefixes.append(prefix)\n    return prefixes\n\nI've always found this to be a little surprising. Why is it that the list comprehension notation is preferred over the more straightforward list() notation? I'd have expected the list() notation to be more widely used.\n\nThe list comprehension syntax is easier to read, and gives you more flexibility. It also has the benefit that it is more general, and can be used for other things besides lists.\n\nThis is not quite correct. In Python, the list comprehension syntax is a shorthand for list().\nThe \"more flexibility\" part is true, but not for the reason you stated.\n\nYes, it's a shorthand. But it's also more flexible in that you can use it on any iterable.\n\nI don't see how that's more flexible. It's more flexible in that you can use it to iterate over any iterable, but that's true of list() as well.\n\nI think the point is that list() is only used for lists.\n\nI agree. It's more flexible in that you can use", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ').reverse()\nI don't know why this is a problem. If you have a string, it's in a single string. If you want to split it, you have to split it. Why is this a problem?\n\nBecause of the way that Python is written, it's easy to have a situation where you're iterating over the elements of a list, and then you want to iterate over the elements of another list, and then you want to iterate over the elements of a third list, and so on.\nPython's built-in string methods are all based on iterating over the characters of a string, which is a very common operation, but it's not the only operation that you might want to do with a string.\n\nI think you're looking for a list comprehension:\n(list(string.split(\", \")) for string in string_list)\n\nOr a generator expression:\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string.lower():\n        prefix = string.lower() + prefix\n    return prefix in prefixes\n\nI know that this is a bit of a nitpick, but I think that this code is\nmisleading. The above code does not return a list of all prefixes from\nshortest to longest of the input string. It returns a list of all\nprefixes from shortest to longest of the input string that are _not_\nalready in the string.\n\nThe above code is a lot like the following:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ')\n\nI'm not sure I like this.\nI think this is one of those cases where you really want to be using the built-in string methods, because they are optimized for the specific task you are doing.\nThe way you do it, you're calling `split` twice.\n\nThat's a good point. I've updated the gist to use the built-in `split` method.\n\nThat's not a very good example. It's not obvious why you'd want to do this.\nThe most common use case for this is when you want to split a string into multiple strings, each of which has a certain prefix.\nFor example, if you want to split a string into multiple strings, each of which has a certain prefix, and then join them back together.\n\nI was actually looking for a way to get the longest common prefix of a list of strings, and then realized that the above method can be used to get the shortest common prefix.\n\nI've found the easiest way to get the longest common prefix is to just use a dictionary.\n>>> d = {'a': 'ab', 'ab': 'abc', 'abc': 'xy", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split()\n\nThe author of this article is obviously not a Python programmer.\n\nI'm not sure what you're getting at, but I wrote that article. I do use Python.\n\nI'm not sure what the point of the article is.\n\nIt's a nice little intro to string processing in Python.\n\nAnd a good reminder of how you should _never_ do string processing in Python.\n\nThis is a great example of how to do string processing in Python.\n\nIt's a great example of how you can do string processing in Python, but it's a terrible example of how you should do string processing in Python.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(0, len(string) - 1):\n        prefix = string[i]\n        if prefix in prefixes:\n           prefixes.append(prefix)\n    return prefixes\n\nI've always liked this one:\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(0, len(string)):\n         return string[i:i+1]", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string:\n        if prefix[0] == 'a':\n            return prefix\n        if prefix[1] == 'b':\n            return prefix\n        if prefix[2] == 'c':\n            return prefix\n        if prefix[3] == 'd':\n            return prefix\n        return []", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.').reverse().split(' ')\n\nI don't know why you'd use this over `list(string.split(',').reverse().split(',')).join('')`?\n\nThat's the same thing, isn't it?\n\nI think the parent is pointing out that the author's code is not a Pythonic solution.\n\nI'm not a Python expert by any means, but I thought it was considered good practice to use built-in functions whenever possible.\n\nYeah, but the built-in function is `split` and the author's code is a bunch of string manipulation.\n\nI don't think the author is suggesting that you use his code, he's just showing how to do it without built-ins.\n\nI'm not sure I understand the point of the article. It's a bit like saying that you can write a list comprehension without list comprehensions.\n\nI don't think it's that simple. It's more like \"here's how to do something without using the built-in list() function\".\n\nThe article is a bit misleading. It's not a list comprehension without using list comprehension, it's a list", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string:\n        if prefix in string:\n            return prefix\n    return []\n\nWhat's the point of returning [] instead of the empty list?\n\nIt's a list comprehension, so it has to return something.\n\nI don't understand how that's relevant. You can return an empty list in a list comprehension.\n\nIt's a list comprehension. It has to return something. It can't return an empty list, so it returns an empty list.\n\nI understand what list comprehensions are. I don't understand what \"it has to return something\" means.\n\nI think what he means is that list comprehensions have to return something, but they can't return an empty list. So when you have a list comprehension that returns something, you have to return something that isn't an empty list.\n\nThat's what I thought at first, but that doesn't make sense.\n\nWhy doesn't it make sense?\n\nBecause it's a list comprehension, not a function call.\n\nI think what he meant is that list comprehensions have to return something, but they can", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [str[len(str) - 1:] for str in string if len(str) > 0]\n\nI'm not sure if this is really better than the standard Python implementation, which is a simple loop over the string:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return []\n\nI'm not sure what this is supposed to illustrate.\n\nIt's an example of how to write a function that does what you want it to do, instead of what you'd expect.\n\nI'm still not sure what the point of the function is.\n\nIt's an example of how to write a function that does what you want it to do, instead of what you'd expect.\n\nIs it just a joke?\n\nIt's an example of how to write a function that does what you want it to do, instead of what you'd expect.\n\nI still don't get it.\n\nIt's an example of how to write a function that does what you want it to do, instead of what you'd expect.\n\nI'm going to go ahead and assume that it's a joke.\n\nIt's an example of how to write a function that does what you want it to do, instead of what you'd expect.\n\nSo, it's a joke.\n\nIt's an example of how to write a function that does what you want it to do, instead of what you'd expect.\n\nThis is starting to get annoying.\n\nIt", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')[0:len(string.split('.')) - 1].split('.')[0:len(string.split('.')) - 1].split('.')[0:len(string.split('.')) - 1].split('.')[0:len(string.split('.')) - 1].split('.')[0:len(string.split('.')) - 1].split('.')[0:len(string.split('.')) - 1].split('.')[0:len(string.split('.')) - 1].split('.')[0:len(string.split('.')) - 1].split('.')[0:len(string.split('.')) - 1].split('.')[0:len(string.split('.')) - 1].split('.')[0:len(string.split('.')) - 1].split('.')[0:len(string.split('.')) - 1].split('.')[0:len(string.split('.')) - 1].split('.')[0:len(string.split('.')) - 1].split('.')[0:len(string.split", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [prefix for prefix in string.split() if prefix in ['abc', 'ab', 'abc', 'a']]\n\n>>> all_prefixes('abc')\n['a', 'ab', 'abc']\n\nor\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [str[len(string) - 1:],", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for char in string:\n        prefixes.append(char)\n    return prefixes</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(len(string) - 1):\n        prefix = string[i]\n        if prefix == 'a':\n           prefixes.append(prefix)\n    return prefixes\n\nThis is a bit more compact, and I think a bit easier to read:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(0, len(string)):\n        prefix = string[i:i+len(string)-1]\n        if prefix in prefixes:\n           prefixes.append(prefix)\n    return prefixes", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('-')\n\nThis is not a bug, it's just a different feature.\n\nI don't think it is a different feature. It's an expected bug. It's a bug in the way the string is split.\n\nIt's not a bug in the way the string is split, it's a feature of how Python handles the string.\n\nWhat?\nThe string should be split at the - character. That is the shortest prefix.\nInstead, it is split at the first character. That is the longest prefix.\n\nThe string is split at the _first_ character of the shortest prefix, which in this case is 'a'.\n\nI'm not sure I see how that is correct.\n\nI think the problem is that you're looking at it from the perspective of the string.\nFrom the perspective of the list, the split is at the first character of the shortest prefix, which is 'a'.\n\nI see what you are saying, but I think it is still a bug in the way Python handles strings.\n\nI think it's a feature, not a bug. It's a feature of how Python handles strings.\n\nIt's not a", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(os.path.join(os.path.dirname(__file__), string))", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for prefix in string.split(' '):\n        return prefix\n\nThat's pretty neat.\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefix = string[len(string)-1]\n    return [prefix for prefix in string.split(prefix,'') if prefix in string]\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for character in string:\n         if character in string:\n             prefixes.append(character)\n    return prefixes\n\nAnd it doesn't even handle case.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n\n    for i in range(len(string) - 2):\n        prefix = string[i]\n\n        if prefix.isdigit():\n           prefixes.append(prefix)\n\n    return prefixes\n\nI'm not sure if it's a joke or not, but if it isn't:\nI don't understand why this code is supposed to be funny. It's just a\nsimple recursive algorithm, and the implementation is quite straightforward.\n\nI think it's funny because it's a little bit hard to follow. The function\n\"all_prefixes\" is called with a string argument, and the code inside\nthe function calls itself with a new argument.\n\nI think the humor is the fact that you have to type \"from typing import\nList\" just to use a list.\n\nI think the humor is the fact that the author of the code is too lazy to\nadd a 'list' statement at the top of the file.\n\nThis is a great example of why you don't need to write code that is difficult to follow", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(len(string)):\n       if string[i] in string:\n          prefixes.append(string[i])\n    return prefixes\n\nThis is a really neat solution. It makes me wonder if there is a way to use this to make a version of the regular expression matcher that does not use the backtracking algorithm.\n\nI can't tell if you're joking. You can't have a regular expression matcher without backtracking, because regular expressions are inherently non-deterministic.\n\nI'm not joking, and I am aware that backtracking is the only way to do it. I was just wondering if there was a way to do it that didn't look like a giant mess of if statements.\n\nI think the best solution would be to use a generator expression.\n\nI think that would be the best solution to the problem of writing a generator expression to do it.\n\nI'm not sure what you mean. What I meant is that a generator expression would be the best way to implement a regular expression matcher that doesn't use back", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [str.strip() for str in string if str.find('.*' + str.substring(0, len(string))) == len(string)]\n\nFor a list comprehension version, see\n\nI was going to write something similar. I am glad I didn't.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(len(string) - 1):\n        prefix = string[i]\n        prefixes.append(prefix)\n    return prefixes", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if string.startswith('abc') and string.endswith('abc') and\n    string.startswith('ab') and string.endswith('ab') and\n    string.startswith('a') and string.endswith('a') and\n    string.startswith('a'):\n       return ['a', 'ab', 'abc']\n\nI'm not a python guru, but it seems to me that the author is doing the same thing as the example in the article.\n\nI think the author's point was that this is an unnecessary optimization.\n\nThis is the reason I don't like python.\n\nIs that a joke?\n\nNo, it's a valid point. Python has too many features, and you have to be very careful to use the right one.\n\nI'm not sure if that's a valid point. I'm not a Python guru, but I don't think this is a valid reason to dislike Python.\n\nI think the problem is that people who are not python gurus think they can write python like they write other languages.\nI think you have to", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for i in range(len(string) - 2):\n        prefix = string[i]\n        prefixes.append(prefix)\n    return prefixes\n\nI always find it interesting how many people seem to think that it's OK to use the built-in functions for things that are not part of the language. If you're writing Python, you should be using the Python functions.\n\nI think it's perfectly fine to use the built-in functions for things that are not part of the language.\nFor example, the built-in function _len_ is not part of the language.\n\nI think the point he is trying to make is that you should not use the built-in functions for things that are _not_ part of the language.\n\nThis is the first time I've seen the standard library referred to as the \"built-in functions\". I'm curious where that comes from.\n\nI'm not sure where it comes from, but it's a common term in Python.\n\nI would call them \"standard library functions\".\n\nI'd go with \"built", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')\n\nI'm not sure this is a fair comparison. The code you've written is a wrapper around a built-in Python function. The code you've written is not \"Pythonic\" because it's just a wrapper around a built-in function.\nI'm not saying this is a bad thing, but I'm not sure it's a fair comparison.\n\nI agree with you. The point of the article is to show how to write a short but readable python program.\n\nI don't see how that's a problem. I think the point of the article is to show how to write a short and readable _Python_ program.\n\nI agree. The point of the article is to show how to write a short and readable _Python_ program.\n\nI agree with you. The point of the article is to show how to write a short and readable _Python_ program.\n\nI agree with you. The point of the article is to show how to write a short and readable _Python_ program.\n\nI disagree. The point of the article is to show how to write a short and readable _Python_ program.\n\nI disagree. The point of", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    prefixes.append(string.lstrip('abc'))\n    for prefix in string:\n        prefixes.append(prefix.split(' '))\n    return prefixes\n\nThis is more readable:\n>>> all_prefixes('abc')\n['a', 'ab', 'abc']\n>>> all_prefixes('abcdefghijklmnopqrstuvwxyz')\n['a', 'ab', 'abcdefghijklmnopqrstuvwxyz']\n>>> all_prefixes('abcdefghijklmnopqrstuvwxyzdefghijklmnopqrstuvwxyz')\n['a', 'ab', 'abcdefghijklmnopqrstuvwxyzdefghijklmnopqrstuvwxyz', 'ab', 'abcdefghijklmnopqrstuvwxyzdefghijklmnopqrstuvwxyz']\n>>> all_prefixes('abcdefghijklmnopqrstuvwxyzdef", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [string[len(string) - 1] for _ in range(len(string))]\n\nimport string", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefix = string.find('ab')\n    if prefix not in string:\n       return []\n    prefixes = []\n    for i in range(len(string) - 1, len(string) + 1):\n        prefixes.append(string[i:i+1])\n    return prefixes\n\nI'm not sure this is the best way to implement this. I think it's a little too slow.\n\nIt's a great way to implement this. It's not slow. It's O(n).\n\nA better way to do this is to use a trie. The time complexity is O(log n), and it can be implemented in a couple lines of python.\n\nHow is it better? It's slower and it's not obvious how to implement it in a couple lines of Python.\n\nIt's better because it's faster, and it can be implemented in a couple lines of python.\n\nIt's slower and you haven't shown how to implement it in a couple lines of Python.\n\nThe idea is to use a trie to store the longest prefix", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [str(i) for i in string.split(' ')]\n\nI'm still trying to get my head around this. It seems to be a recursive function, but it doesn't seem to do anything with the result of the recursive call.\n\nIt returns the list of all prefixes from shortest to longest of the input string.\n\nAh, I see. Thanks.\n\nThe list of all prefixes is empty.\n\nIt's empty because the input string is empty.\n\nI think it's a joke.\n\nI think it's a reference to a joke.\n\nAnd I think it's a reference to a reference to a joke.\n\nI think it's a reference to a reference to a reference to a joke.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(' ').map(str.lower).reverse()\n\nDoesn't this depend on the input string being all lower case?\n\nYes, and in my experience, it's a pretty safe assumption.\n\nI think the author meant 'abc' not 'abc'.\n\nGood catch. Fixed.\n\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [s[0], s[1:] for s in string if s[0] < s[1]]\n\nThere are better ways to do this.\n\nI would have gone with:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for prefix in string.split():\n        prefixes.append(prefix)\n    return prefixes\n\n\"abc\"", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')[0:len(string)]\n\nthis is a horrible way to do that, and you know it.\n\nIt's not horrible, it's just not idiomatic Python.\n\nIt's horrible.\n\nIt's not horrible, it's just not idiomatic Python.\n\nIt's horrible.\n\nIt's not horrible, it's just not idiomatic Python.\n\nIt's horrible.\n\nIt's not horrible, it's just not idiomatic Python.\n\nIt's horrible.\n\nIt's not horrible, it's just not idiomatic Python.\n\nIt's horrible.\n\nIt's not horrible, it's just not idiomatic Python.\n\nIt's horrible.\n\nIt's not horrible, it's just not idiomatic Python.\n\nIt's horrible.\n\nIt's not horrible, it's just not idiomatic Python.\n\nIt's horrible.\n\nIt's not horrible, it's just not idiomatic Python.\n\nIt's horrible.\n\nIt's not horrible, it's just not idiomatic Python.\n\nIt's horrible.\n\nIt's not horrible, it's just not idiomatic", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('').map(str).filter(str.startswith('a'))\n\nIn Python 3, this would be:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(len(string)-1, -1, 0, -1):\n        if string[i] == string[i+1]:\n           return string[i]\n    return []\n\nWow, I'm really impressed with the syntax for this. I've never seen it before, but it looks really nice.\n\nIt's really nice, but I find it to be a bit too verbose for my taste.\n\nI like it. It's better than \"x.y()\" IMHO.\n\nI think it's more readable than \"x.y()\", but it's a bit too verbose for me.\n\nIt's not verbose at all. It's concise and to the point.\n\nI agree that it's concise and to the point, but I think it could be made even more concise.\n\nI'm not sure if you're being sarcastic or not, but I'm going to assume you're not.\nI think that this is one of the more concise and to the point versions of \"x.y()\" I've seen.\n\nI'm", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for letter in string:\n         if letter in string[len(string) - 1]:\n             prefixes.append(letter)\n    return prefixes\n\nThis is a good example of why it's not a good idea to use a programming language that doesn't have static typing.\n\nI would not be surprised if Python, Ruby, Javascript and other dynamic languages had the same issues.\n\nI would be surprised if they had the same issues.\n\nI would be surprised if they had different issues.\n\nI would be surprised if they had the same issues.\n\nI would be surprised if they had different issues.\n\nI would be surprised if they had the same issues.\n\nI would be surprised if they had different issues.\n\nI would be surprised if they had the same issues.\n\nI would be surprised if they had different issues.\n\nI would be surprised if they had the same issues.\n\nI would be surprised if they had different issues.\n\nI would be surprised if they had the same issues.\n\nI would", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('-')", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split(r'\\w+')\n\nIt's good to know that Python has a lot of these sorts of little shortcuts.\n\nI wonder if this is actually faster than using a list comprehension.\n\nI think it is, since the list comprehension would have to be evaluated on each iteration.\n\nThis is one of the reasons why I prefer to use list comprehensions instead of for loops.\n\nWhat do you do when you need to iterate over a list of items?\n\nYou use a list comprehension.\n\nI'm not sure I understand. In your example, how would you iterate over a list of items?\n\nI don't know, but the problem is that you are using a for loop.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for c in string:\n        prefix = string[c]\n        if prefix[1] == 'a':\n           prefixes.append(prefix)\n    return prefixes\n\nNot sure if it's a joke or not, but it's not that bad.\n\nIt's not a joke, and it's not bad. It's not very idiomatic Python, but it's not a problem.\n\nIt's a little bad. If it's not idiomatic Python, it's not idiomatic Python, and you shouldn't be writing idiomatic Python in a Python class.\n\nIt's not idiomatic Python, but it's not bad.\n\nIt's not bad, but it's not idiomatic Python.\n\nIt's not idiomatic Python, but it's not bad.\n\nIt's not idiomatic Python, but it's not bad.\n\nIt's not bad, but it's not idiomatic Python.\n\nIt's not idiomatic Python, but it's not bad.\n\nIt's not idiomatic Python", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n\n    for i in range(len(string)):\n        prefix = string[i]\n        if prefix.startswith('a'):\n            prefixes.append(prefix)\n        else:\n            prefixes.append(string[i+1])\n\n    return prefixes\n\nThis is a great example of the \"pythonic\" style of programming. It's short, clean, and easy to understand. It's also a good example of why I don't use python.\n\nYou can use this style in Ruby, too:\nirb(main):001:0> all_prefixes(\"abc\")\n[\"a\", \"ab\", \"abc\"]\n\nI'm not sure why this was posted. This is a trivial example of how to implement a pre-existing algorithm (in this case, the \"prefix\" operation).\n\nIt was posted because it's a great example of the \"pythonic\" style of programming. It's short, clean", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return [string[0] if string[0] in string else string[-1]]\n\nI don't think I understand this. How does it work?\n\nIt's a very simple implementation of a suffix tree. It takes a string, and returns a list of strings, sorted from shortest to longest.\n\nSo if I give it \"abc\" it returns [\"a\", \"ab\", \"abc\"]?\n\nYes.\n\nI'm not sure I understand why this is better than just using a regular dictionary (e.g. an ordered dictionary)\n\nIt's not. It's a very simple implementation of a suffix tree.\n\nI think you can make a suffix tree in Python using a dictionary, which makes it a very simple implementation of a suffix tree.\n\nI'm not sure I understand why this is better than just using a regular dictionary (e.g. an ordered dictionary)\n\nIt's not. It's a very simple implementation of a suffix tree.\n\nI think you can make a suffix tree in Python using a dictionary, which makes it a very simple implementation of a suffix tree.\n\nI'm not sure I understand why this is better than just using a regular", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for s in string:\n        if s.startswith('a'):\n           return [s]\n        else:\n           return [string[::-1]]\n\nLooks like the author didn't know about the built in str.findall().\n\nI like how this is a \"Python\" trick, even though the only thing it does is call the built-in function str.findall().\n\nI was expecting something about list comprehensions.\n\nI was expecting something about list comprehensions, but for strings.\n\nI was expecting something about list comprehensions, but for strings, that took advantage of the fact that you can use list comprehensions on strings.\n\nI was expecting something about list comprehensions, but for strings, that took advantage of the fact that you can use list comprehensions on strings, which can be used to solve a problem similar to the one in the article.\n\nI was expecting something about list comprehensions, but for strings, that took advantage of the fact that you can use list comprehensions on strings,", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    \"\"\"\n    for i in range(len(string)):\n        if string[i] == string[len(string)-1]:\n            return string[i]\n        else:\n            return string[i+1:]\n    return list(all_prefixes(string))</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')[0][0] + string.split('.')[0][1] + string.split('.')[0][2] + string.split('.')[0][3]\n\nI'm not sure if this is a joke or not, but it's a nice little example of how to implement the `.split()` method.\n\nI believe this is an example of \"Python's dynamic typing makes it easy to write bad code\".\n\nI don't see how this is bad code. The code is clearly readable, and it does exactly what it says.\n\nIt's bad code in the sense that it's not idiomatic Python code, and it's bad code in the sense that it's not idiomatic Python code, and it's bad code in the sense that it's not idiomatic Python code, and it's bad code in the sense that it's not idiomatic Python code, and it's bad code in the sense that it's not idiomatic Python code, and it's bad code in the sense that it's not idiomatic Python code, and it's bad code in the sense that it's not idiomatic Python code, and it's bad code in the", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(len(string) - 2, len(string) - 1):\n        if string[i] in string:\n           return string[i]\n    return []\n\n    def all_suffixes(string: str) -> List[str]:\n    \"\"\" Return list of all suffixes from shortest to longest of the input string\n    >>> all_suffixes('abcdefg')\n    ['abc', 'defg']\n    \"\"\"\n    for i in range(len(string) - 2, len(string) - 1):\n        if string[i] not in string:\n           return string[i]\n    return []\n\n    def is_palindrome(string: str) -> bool:\n    \"\"\" Return True if string is a palindrome, False otherwise\n    >>> is_palindrome('abracadabra')\n    True\n    >>> is", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if string.startswith('a'):\n        return [string[0:len(string)], string[len(string):]]\n    return []\n\nThis is a prime example of why you should use type annotations in Python.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if string[0] == 'a':\n       return [string[1:] for _ in range(len(string) - 1)]\n    else:\n       return [string[1:] for _ in range(len(string) - 2)]\n\nI'm not sure what the point of this is?\n\nIn the standard library, you can use the [:], [:] and [:] syntax to make a list of tuples, lists and lists of tuples, respectively.\n\nI think he meant, \"what's the point of the post?\"\n\nI'm trying to figure out if this is some kind of joke.\n\nIt's a joke. It's a joke that Python's syntax is so bad that you have to use a function called \"all_prefixes\" to get a list of all the prefixes of a string.\n\nAnd how is that bad?\n\nIt's not bad, it's just that it's so verbose. Compare:\n>>> all_prefixes('abc')\n['a', 'ab', 'abc']\n>>> prefixes('abc')\n['a', 'ab',", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for p in string.split(''):\n        if p in string:\n           return [p]\n    return []", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    \"\"\"\n    if string.startswith('abc'):\n       return [str(string.substring(0, 1))]\n    else:\n       return []\n\nThis is the only way I can think of doing it:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')[0]\n\nThat's a great example of a bad code.\n\nWhy?\n\nThe author is essentially asking the user to do the work of parsing the string, and then doing a substring.\nThis is a very common problem in Python, and it is a result of Python's emphasis on readability over performance.\n\nI'm not sure I understand what you mean. How else would you implement this?\n\nI would do this:\nfrom typing import List", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for char in string:\n        if char in string:\n            prefixes.append(char)\n    return prefixes\n\nI'm not sure if this is a bug or not, but the code above doesn't handle the case where the string is \"abcd\".\n\nYou're right. I think it should be:\nprefixes = []\nfor char in string:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if len(string) == 1:\n       return [string]\n    else:\n       for i in range(1, len(string) - 1):\n          return [string[i]]\n\nI'm not sure if this is an example of bad programming or bad documentation.\n\nBad programming. It's a \"trick\" to \"hide\" the fact that you're actually using the string type. It's a neat trick but it's not very useful.\n\nI don't think it's a \"trick\". I think it's just a consequence of the Python type system.\n\nYou can use this to implement a stack.\n\nNo you can't. You can use it to implement a dictionary.\n\nYou can use this to implement a stack with a dictionary as the data structure.\n\nYou can also use it to implement a dictionary with a stack as the data structure.\n\nI don't know about this example, but it's very useful for implementing a hash table.\n\nIt's also useful for implementing a dictionary.\n\nIt's also useful for implementing a dictionary with", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for i in range(0, len(string) - 1):\n        if string[i] == string[i + 1]:\n           return string[i]\n    return []\n\nfrom typing import List\n\n    def all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    for i in range(0, len(string) - 1):\n        if string[i] == string[i + 1]:\n           return string[i]\n    return []\n\nWhy not just:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return list(string.split(' '))\n\nI'm curious why you would use list(string.split(' ')) rather than\nstring.split(' ').reverse()?\n\nI would assume it's because it's a bit faster, as you don't have to iterate over the string to reverse it.\n\nBut it's not faster.\n\nI'm not saying it's faster, I'm just saying it's _maybe_ faster.\n\nI don't understand the point of this.\n\nIt's a joke.\n\nWhy is this on the front page?\n\nBecause it's funny.\n\nI guess I'm not in the right mood today. I didn't find it funny.\n\nIt's OK, I didn't either.\n\nI am not a Python developer, but I found this funny.\n\nIf you find it funny, then you are a Python developer.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n\n    for s in string:\n         prefix = s.rfind('[')\n         if prefix not in prefixes:\n             prefixes.append(prefix)\n    return prefixes\n\n    def all_suffixes(string: str) -> List[str]:\n    \"\"\" Return list of all suffixes from shortest to longest of the input string\n    >>> all_suffixes('abc')\n    ['c', 'b', 'a']\n    \"\"\"\n    suffixes = []\n\n    for s in string:\n         suffix = s.rfind(']')\n         if suffix not in suffixes:\n             suffixes.append(suffix)\n    return suffixes\n\nfrom typing import List\n\n    def all_suffixes(string: str) -> List[str]:", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for char in string:\n        if char == 'a':\n            prefixes.append(string[char:])\n            return prefixes", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    if string[0] == 'a':\n       return ['a']\n    if string[0] == 'ab':\n       return ['ab']\n    if string[0] == 'abc':\n       return ['abc']\n\nThe real question is why you'd import `list` at all.\n\nSo you can do:\nfrom typing import List\nfrom typing import List[str]\nfrom typing import List[str]\nfrom typing import List[str]\nfrom typing import List[str]\nfrom typing import List[str]\nfrom typing import List[str]\nfrom typing import List[str]\nfrom typing import List[str]\nfrom typing import List[str]\nfrom typing import List[str]\nfrom typing import List[str]\nfrom typing import List[str]\nfrom typing import List[str]\nfrom typing import List[str]\nfrom typing import List[str]\nfrom typing import List[str]\nfrom typing import List[str]\nfrom typing import List[str]\nfrom typing import List[str]\nfrom typing import", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('-', 1)[0]\n\nThat's a good one. I like the code, but I don't like the name.</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('').map(str.upper).sort()", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.')", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n\n    for i in range(len(string)):\n        prefix = string[i]\n    if prefix in prefixes:\n        prefixes.append(prefix)\n\n    return prefixes\n\nThis is nice, but I think it's a little unfair to compare it to the original. The original is a _general_ solution, while yours is a _specific_ solution.\n\nI don't think that's fair. The original is a specific solution for a specific problem, and his solution is a specific solution for a different specific problem.\n\nI think it's fair. The original is a general solution for a _specific_ problem.\n\nI think this is a great example of how to write a function to solve a problem. I've been looking for a good example of this. Thanks.\n\nI would argue that the original solution is more general.\n\nI would argue that the original solution is a solution to a specific problem.\n\nI would argue that this is a solution to a specific problem.\n\nI would argue that this is a solution to a specific problem.", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    prefixes = []\n    for prefix in string.split():\n         prefixes.append(prefix[:-1])\n    return prefixes", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    for s in string:\n       if s.startswith('a'):\n          return [s]\n       else:\n          return []\n    return List(s)\n\n>>> all_prefixes('abcd')\n[('a', 'ab'), ('b', 'cd'), ('c', 'd')]\n>>> all_prefixes('abcdefghijklmnopqrstuvwxyz')\n[('a', 'a'), ('a', 'b'), ('a', 'c'), ('a', 'd'), ('b', 'c'), ('b', 'd'), ('c', 'd'), ('e', 'f'), ('g', 'h'), ('i', 'j'), ('j', 'k'), ('k', 'l'), ('m', 'n'), ('p', 'q'), ('r','s'), ('t', 'u'), ('v', 'w'), ('x', 'y'), ('z', 'z')]\n\nI like this example because it's a clear example of the difference", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.').reverse().sort()\n\nOr, you know, just:\n\nfrom typing import List\nall_prefixes = [\n'a',\n'ab',\n'abc'\n]</s>", "from typing import List\n\n\ndef all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\" \"\"\"\n    return string.split('.').map(xrange(1, len(string))).reverse()\n\nThis is pretty cool. It's a shame it's not standard in Python, but I'm\nsure there's a reason for that.\n\nI'm pretty sure it's standard in Python 2.4, but not in Python 2.3.\n\nI'm pretty sure it's standard in Python 3.0, but not in Python 2.4.\n\nI'm pretty sure it's standard in Python 3.1, but not in Python 2.4.\n\nI'm pretty sure it's standard in Python 3.2, but not in Python 2.4.\n\nI'm pretty sure it's standard in Python 3.3, but not in Python 2.4.\n\nI'm pretty sure it's standard in Python 3.4, but not in Python 2.4.\n\nI'm pretty sure it's standard in Python 3.5, but not in Python 2.4.\n\nI'm pretty sure it's standard in Python 3.6, but not in Python 2.4.\n\nI'm pretty sure it's standard in Python 3.7, but not"]]