[["def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    for c in s:\n        chr(((ord(c) + 5 - ord(\"a\")) % 26) + ord(\"a\"))\n        s.remove(c)\n    return s.join(\"\")\n\nThis is a lot nicer than the golang example since it avoids having to do any'scanning' to get the first character (e.g. to get 'c' you have to scan to 5 in the alphabet and then scan to find 'c').\n\nWhat about decoding it back from byte code?\n(defn encode-shift [s]\n(.concat (repeat 5 (make-hash-table)) s)\n(.toList s))\n(defn decode-shift [s]\n(.map (fn [c]\n(.concat (repeat 5 (make-hash-table)) (make-hash-table) c)))\n(.toList s)))\n(encode-shift \"I like cheese\") ;; \"UaLaChEf\"\n(encode-shift \"I like cheese\") ;; \"IaLaChEf\"\n(", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s[::-1]", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(\"a\") + ord(\"a\") - ord(\"a\") / 26) + ord(\"a\") for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(ord(ord(ch) - ord(\"a\")) for ch in s.split() if ch >= 26 else \"\")\n\nSee also\n\n Charset\n International Components for Unicode\n UTF-8, UTF-16, UTF-32\n\nReferences\n\nFurther reading\n  See section 5.2 for a description of shift-JIS.\n\nExternal links\n Shift-JIS: A multibyte encoding for Japanese language text processing (Japanese page)\n Shift-JIS at IBM developerWorks</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.encode(\"ascii\").decode(\"ascii\")\n\nI find it easier to use the.ascii() method than the.encode() method, and it's almost always faster.\n\n`decode_shift` doesn't use `.encode()`.\n\nit's an example for the \"it's almost always faster\" part.\n\nI don't understand this, can anyone explain? Is it about the way that the 5th letter is encoded?\n\nYes.", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join([chr(ord(ch) + 5) for ch in s])</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) + 5) - ord(\"a\")) % 26) for ch in s])\n\nThis code snippet works perfectly for the ASCII alphabet, but when I try to encode characters from other alphabets, the results are strange. For example, I want to encode characters from the Greek alphabet (ISO 8859-7), but the results are not the ones expected:\n\n>>> import random\n>>>\n>>> encoding = \"greek\"\n>>>\n>>> encoded = encoding.encode_shift()\n>>>\n>>> decoded = encoding.decode_shift()\n>>>\n>>> print decoded.join(\"\")\n>>>\n>>> ['.', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '',", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) + 5 - ord(\"a\")) for ch in s])\n\nNote that chr and ord are not part of the python standard library, so if you don't already have them, you'll need to import them first.\n\nPython 3 has a built-in `ord` function, but `chr` is still not part of the standard library.\n\nAnd that's why I use Python 2.\n\nObligatory \"just use the language you like, don't be a zealot\" comment.</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(\"a\") - ord(\"A\")) % 26) + ord(\"A\")) for ch in s])</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.encode(\"ascii\")", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(s.replace(\"\\x5\", \"\") for ch in s.split())</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr((ord(ch) - ord(\"a\")) % 26) for ch in s])\n\n>>> encoded_string = \"\".join([chr(ord(ch) + 5 - ord(\"a\")) for ch in s])\n>>> decode_shift(encoded_string)\n\"\".join([chr(ord(ch) - ord(\"a\")) for ch in s])\n>>>\n\nThis looks like a pretty clear, well-thought-out approach to the problem. I'm not sure how I missed this when I was originally learning Python.\nThanks for sharing.\n\nWouldn't a more idiomatic way of doing this be\ns = \"\".join([chr(ord(ch) + 5 - ord(\"a\")) for ch in s])\nencoded_string = s.encode('ascii')\ndecoded_string = s.decode('ascii')\n\nProbably. I came to Python from Perl, where arrays are normally passed by reference, so I tend to write the most idiomatic Perl I can. (And then get a little confused when Python does something different.)\nI should probably have said that that", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(ord(ch) for ch in s if ord(ch) <= ord(\"a\") else \"\").join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s]</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    for ch in s.split(\"\\n\"):\n        return ch.decode()[5:]", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) - ord(\"a\")) % 26) - ord(\"a\")) for ch in s])\n\nThe part of this code that interests me is where it says \"ord('a')\". Does anyone know what the deal is with this?\n\nIt's a python library, but it's also a little bit of math:\n>>> 'a' - ord('a')\n<class 'int'>\n>>> 'a' - ord('A')\n<class'str'>\n>>> 'a' - ord('A' * 0x3FF)\n<class'str'>\n>>> 'a' - ord('A' * 0x7FF)\n<class'str'>\n>>> 'a' - ord('A' * 0xFFFE)\n<class'str'>\n>>> 'a' - ord('A' * 0x1FFE0)\n<class'str'>\n>>> 'a' - ord('A' * 0x1FFFE)\n<class'str'>\n>>> 'a' - ord('A' * 0x2FFFE)\n<class'str'>\n>>> 'a'", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    for ch in s:\n       chr = ord(ch)\n       if chr > 0x3F:\n          return chr\n       else:\n          return chr - ord(\"a\")\n    return s", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join(ord(ch) for ch in s.split(\"\")).decode('utf-8')\n\nHere is another one from the list of encryption algorithms in the same file:", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join([chr(ord(ch) - 5) for ch in s if ord(ch) > 26])\n\nThis is the same as what is done by urllib2\n\nI guess this is a fun programming exercise, but I don't see what it solves.\n\nit solves the problem of having a fun programming exercise.</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(chr(ord(ch) * 5))[:-1]\n\nThe problem with this is that the \"problem\" string \"abcdefg\" becomes the \"correct\" string \"cdagbf\". The shift operator is not commutative.\n\nThe one true solution to this problem is to not attempt to encode/decode anything that contains characters that could be used as control characters, and to not use any characters that could be used as control characters in a string intended to be used as a password.\n\nI don't understand what the problem is. How is a password in a language like this encoded?\n\nSee the second sentence in my post: \"and to not use any characters that could be used as control characters in a string intended to be used as a password.\"\nIf your language's character set includes control characters, you can't use a password in that language.\nIf your language's character set doesn't include control characters, you should be fine.\n\nThe problem is that some languages use the same character sets for both.\nIn this case, you can't use any characters that can be used as control characters, not just those in the set used for passwords.", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(map(ord, str.encode_shift(ch)))", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join([chr(ord(\"a\")) for ch in s if ch >= ord(\"a\")])</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(chr(((ord(ch) + 5) % 26) + ord(\"a\")) for ch in s)</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr((ord(ch) - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    for ch in s:\n        if ord(ch) > ord(\"a\"):\n           return ch - ord(\"a\")\n        else:\n           return ch", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join(chr(ord(ch) + 5 - ord(\"a\")) for ch in encode_shift(s))", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(s.decode())", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 + ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\nIn Python 2.x, we can avoid explicit type declarations by using the str type which is a Python reference type. This avoids the need for the cast.", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) - ord(\"a\")) for ch in s] + s[:ord(\"a\")] + s[ord(\"a\") + 1:])</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) - 5) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join(chr(((ord(ch) - 5 + ord(\"a\")) % 26) + ord(\"a\")) for ch in s)\n\nThe \"encoded string\" is \"AAABBAABBAAABBAAABBAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAAABBAA", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join([ord(ch) for ch in \"\".join(s)])\n\ncode = \"\"\"\n    1.1 + 1.2\n    is\n    2.3\n    \"\"\"\n\nencoded = encode_shift(code)\n\ndecoded = decode_shift(encoded)", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.split(\"\").join([chr(ord(ch) + ord(\"a\")) for ch in s.split(\"\"))])\n\nThis is very similar to the base64 example, except that instead of splitting up the string into characters, we take it apart into characters and then reassemble it using join().\n\nTo ensure you understand what is going on, try changing the encode_shift and decode_shift functions so that they decode and encode the same string.  See if you can get the output to match the output above.\n\nReferences\n\nExternal links\nA Python implementation of the Caesar cipher.\nPython tutorial.</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join([chr(ord(ch) + 5) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(ord(ch) for ch in \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s]))", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) - 5) for ch in s])\n\n>>> s = encode_shift(\"test\")\n>>> s.decode()\n\"tes\"\n\n>>> s = \"abcd\".encode_shift()\n>>> s.decode()\n\"cde\"\n\n>>> s = \"abcd\".encode_shift(\"z\")\n>>> s.decode()\n\"abcd\"</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) + 5) for ch in s if ord(\"a\") in ord(ch)] + chr(ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(\"a\" + ord(\"a\") + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\" + ord(\"a\"", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.shift(5) + \" \".join([chr(((ord(ch) + ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\nAnd here's my take on an implementation of zip:", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\nso it's a one-to-one function, right? it's a bit hard to follow...\n\nYes, it's a one-to-one function.\n\nI always wonder why people insist on using binary encodings for this kind of stuff. What's wrong with something more human-readable, such as octal, or maybe even decimal?\n\nI've always wondered why people insist on using their eyes to read when they can use an audio-to-text reader instead.\n\nBecause that is impractical? You could have chosen a more appropriate analogy.\n\nSo is reading text in binary.</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) % 26) for ch in s])</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\nThe code in the article is a rewrite of this:", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) - ord(\"a\")) for ch in s])\n\nAn alternative way to define the encoding for the function encode_shift:", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.decode(\"latin-1\")", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.encode(\"utf-8\").decode('utf-8')</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return chr(ord(s[0]) ^ ord(\"a\")) for ch in s", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr((ord(ch) + 5 - ord(\"a\")) % 26) - ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(chr(((ord(\"A\") - ord(\"a\")) % 26) + ord(\"a\") for ch in s.split(\".\") if ch!= \"A\"))\n\nI agree with your approach. The fact that the author of the article missed the trick is a symptom of the author's lack of knowledge, not of Python's.\n\nAuthor here. I understand the encoding and decoding process, but I did not think of the fact that the \"A\" would be counted as \"A\" not \"0\" when reading the text file.\nI actually wrote the article after encountering the problem in a real world problem and the article was supposed to be a short and simple solution to the problem. Hence the title \"Python: A simple solution\".\n\nOne way to avoid this is to use split instead of join, so that chr() can't be overloaded.\n\nCan you explain how you can overload chr? I didn't think it could be overloaded.\n\nPython provides several variants of chr(), all of which return a different integer depending on the context.\n\nAh, I see what you're saying. I thought you were talking about how chr can be overloaded in terms", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    if len(s) == 2:\n       return decode_simple_shift(s)\n    return decode_simple_shift(s, 2)", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.split()[0]", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr((ord(ch) + ord(\"a\")) % 26) for ch in s])\n\na = \"abcdefghijklmnopqrstuvwxyz\"\nb = encode_shift(a)", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([ord(ch) for ch in s if ord(ch) < ord(\"a\") and ord(\"a\") + ord(ch) <= ord(\"z\"))])\n\n>>> encode_shift(\"hello\")\n\t'%c%h%e%l%l'\n>>> decode_shift(\"hello\")\n\t'hello'\n\nor alternatively, with 2 fewer lines:", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s] + chr((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\"))\n\nThis is a good way to handle it (assuming that the \"alphabet\" is fixed):\n>>> 'abc' << encode_shift( 'abc' )", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(map(ord, chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s.split(\".\")))\n\nI didn't get it.\n\nIt's a joke. It's a very naive way to do a \"shift\" function.\n\nI really don't see how the code is naive. It is simply the simplest way of implementing this function. You have a string s you want to shift. The code splits it into an array of characters and a count of the \"a\" characters. You can then transform each character into a number by counting the number of \"a\" characters that precede it and then adding 5 to that number. You can then transform that number into a new character by multiplying it by the character's code point.\n\nThis is an interesting implementation of a concept I've been looking for a good solution to.\nI have a program that takes a list of characters and runs them through a function that makes a word cloud with them. It was originally just a list of words, but I figured that it would be more interesting if it could be a list of characters with a shift and/or rotation.", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(s.map(ord, \"a\"))\n\ndecode_shift(encode_shift('hello world')) == 'hello world'", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) + ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([ord(ord(\"a\") - ord(\"a\")) for ord in s if ord in \"a\" else 0])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join([chr(ord(ch) + 5 - ord(\"a\")) % 26 for ch in s])\n\nIt's not clear to me that this does what you want. If the encoded string is, for example, \"abc\", then this returns \"abcd\", whereas you want \"abcde\". It should be \"abcdee\".\n\nAh, of course! I have been doing this in Ruby for a while, where chr() always returns a character, so it's easy to forget that in some languages it returns an int. Thanks.\n\nThe use of a \"chr\" function is a good idea, though.\n\nYes, it's nice to be able to use a string. In the Ruby version it's even nicer, since it's a syntax sugar that returns the same string that you're passing to it. So chr(0) gives you a '0'.\n\nIf you're on Python 2, the standard library \"ord\" function will give you the Unicode codepoint of a string, and \"ord(\"a\")\" will return \"U+0061\". (The first two arguments of \"ord\" are the string you want to decode, and", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) + 5) for ch in s])</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(s.split(\",\")[0] for s in encode_shift(s))", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.split(\"\").reverse().join('')\n\nfor i in range(5):\n    result = encode_shift('')\n    print \"%s -> %s\" % (result, decode_shift(result))", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    if s.startswith(\"\".join(chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s)):\n        return s\n    else:\n        return chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\"))</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s[chr(ord(ch) + 5 - ord(\"a\")) % 26]", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([ord(ch) for ch in s if ch in (ord(\"a\"), ord(\"b\"), ord(\"c\"), ord(\"d\"), ord(\"e\"), ord(\"f\"), ord(\"g\"), ord(\"h\"), ord(\"i\"), ord(\"j\"), ord(\"k\"), ord(\"l\"), ord(\"m\"), ord(\"n\"), ord(\"o\"), ord(\"p\"), ord(\"q\"), ord(\"r\"), ord(\"s\"), ord(\"t\"), ord(\"u\"), ord(\"v\"), ord(\"w\"), ord(\"x\"), ord(\"y\"), ord(\"z\")]))</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(s.split(\":\")[0])[0]\n\na = \"CAT\".encode_shift()\nb = \"ATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATATAT", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) + 5 - ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([ord(ch) for ch in s.split(\",\") if ch > ord(\"a\")])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join(ord(ch) for ch in ord(\"a\"..\"z\"))</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(chr(((ord(ch) - ord(\"a\")) % 26) + ord(\"a\")) for ch in s)\n\ns = \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\ns = \"\".join([chr(((ord(ch) - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.split(\"\").map(ord).join(\"\")", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join([chr(ord(ch) + 5 - ord(\"a\")) for ch in s] + \"\")</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(ord(ch) for ch in s)</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(chr(((ord(ch) - 5 + ord(\"a\")) % 26) - ord(\"a\")) for ch in s)</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    s = s.decode('ascii')\n    return s.join(\"\")\n\nSomewhat off topic, but how do you do the ascii decode? The str.decode() method seems to be blocked by the.join call, I can't figure out how to do it.\n\nI think they're using a library.\n\nYes, I didn't want to post a link.\n\nThe problem with this is that you can get the same result by shifting the characters in the alphabet 5 places to the right, without any encoding at all.\nFor example, if you enter \"secret\", you get \"spetsct\" and \"snecsct\". This is really just a different encoding of the same thing.\n\nThat's the point.\n\nJust shift the alphabet 5 places right.\n\nI know, I can't understand why people are so impressed by this.\n\nI'm not so much impressed by this than by the fact that it was posted by someone with a PhD.\n\nHey, I've got a PhD, and I'm a moron.</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.replace(ord(\"a\"), ord(\"a\" + 5)) + s.replace(ord(\"b\"), ord(\"b\" + 5)) +... + s.replace(ord(\"z\"), ord(\"z\" + 5)) + s.replace(ord(\"a\" + 5), ord(\"a\" + 5))\n\nIt's not that clear what the purpose of this is, because the definition of decode_shift doesn't use it anywhere.\n\nI think this could be a nice way to teach the concept of \"backshift\" in shifting alphabets.\n\nI was thinking the same thing.\nI'm going to rewrite this a bit, but the idea is to have a program that takes a string of characters and gives you an output string where each character is shifted left 5 places from the original position.\nIt's a good way to think about how the characters shift positions in a string.\n\nThis is also a good way to introduce the concept of a shift register in electronics:\n\nI think this is a pretty good example. I'll probably steal this for my kids when they're old enough to grasp it.\n\nI'd also like to hear from any \"young hackers", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(ord(ch) for ch in s.split()[:4] if ch > 26 else ch)</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([ord(ch) for ch in s if ch == ord(\"a\")] + s)\n\nSo, why is it that the solution posted by Coder9 gets upvoted but the solution posted by makkuro gets downvoted?\n\nBecause the solution posted by Coder9 doesn't work. If you look at the actual code, it does not match what is shown in the post. The first paragraph of the post is a more clear and correct description.\n\nHey, I didn't downvote the other post. But I looked at the code and it looks pretty much like the code in the post.\nI think the point of the post is to generate a string which contains only a, b, c, d, e, f, g, h and i.\nThe code in the post shows how to do that.\n\nThe code in the post does not match the text of the post. Look again.\nThe code in the post does not create a string which contains only a, b, c, d, e, f, g, h and i. It creates a string containing a, b, c, d, e, f, g, h", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr((ord(ch) + ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join(chr((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\"))</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([ord(ch) for ch in s.encode_shift()])\n\nIs there any reason you're not using a counter to figure out which character to shift?\n\nI wanted to use a regular expression but couldn't find a way to achieve it.\n\nThere's a regexp library for Python.\n\nYes, I'm aware of it but for some reason it doesn't work the way I want it to. Maybe I'm doing something wrong.</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) - ord(\"a\")) % 26 for ch in s])\n\n>>> encode_shift('h3h3h3')\n    ''.join([h3h3h3h3h3h3])\n>>> decode_shift('h3h3h3')\n    'h3h3h3'\n>>> encode_shift('h3h3h3')\n    ''.join([h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h3h", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) - ord(\"a\")) for ch in s])\n\nBy the way, this is also the solution to a previous question:\n\nI love HN.</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    if s == \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s]) :\n        return s\n    return \"\".join([ord(ch) for ch in s if ord(ch) < ord(\"a\")])\n\nSee also\n Shift cipher\n\nReferences</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return chr(ord(\"a\" + ord(ch)) % 26 for ch in s) + s</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join(\"\").decode(ord(ch) - ord(\"a\"))", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return str.join(chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s)\n\nThe code is also included in the article.</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.encode('ascii')</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) + 5) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    for x in s.split(\" \"):\n        return \" \".join(chr((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\"))\n\nIf you're curious,  will do the same thing, but also use an alphabet of 26 letters, as is done by many Asian languages.\n\nYou can do the same thing with just 4 characters:\n\nwhile s:\n    if s[0] == 'a' and s[1] == 'n':\n        return \"\".join(s[0:2]) + s[3:4]\n\nThis one is easier to remember for me.\n\nI tried to do it in one line, but then I have to make another function that just return a list of the characters.\n\nOne problem I ran into when using this (at least with Python 2.6) was that the space character will get shifted as well.\n\nTrue, I was wondering how I could do it without using a space character as a delimiter, but I have not found a way yet. Any suggestions?\n\ntry:\n\tfor x", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) - ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.replace(\"a\", \"Z\").replace(\"a\", \"A\").replace(\"a\", \"Z\").replace(\"a\", \"A\").replace(\"a\", \"Z\").replace(\"a\", \"A\").replace(\"a\", \"Z\").replace(\"a\", \"A\").replace(\"a\", \"Z\").replace(\"a\", \"A\").replace(\"a\", \"Z\").replace(\"a\", \"A\").replace(\"a\", \"Z\").replace(\"a\", \"A\").replace(\"a\", \"Z\").replace(\"a\", \"A\").replace(\"a\", \"Z\").replace(\"a\", \"A\").replace(\"a\", \"Z\").replace(\"a\", \"A\").replace(\"a\", \"Z\").replace(\"a\", \"A\").replace(\"a\", \"Z\").replace(\"a\", \"A\").replace(\"a\", \"Z\").replace(\"a\", \"A\").replace(\"a\", \"Z\").replace(\"a\", \"A\").replace(\"a\", \"Z\").replace(\"a\", \"A\").replace(\"a\", \"Z\").replace(\"a\", \"A\").replace(\"a\", \"Z\").replace(\"a\", \"A\").replace(\"a\", \"Z\").replace(\"a\",", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\"))\n\nNow do you see why, without knowing the algorithm used, it is impossible to give a useful answer to this question?\n\nGood answer!\nFor those who don't understand it, the shift function is similar to the subtraction operator in programming.\nInstead of subtraction, it shifts one digit to the right.\nThe return value of the shift function is the same as the result of the \"shift\" operator.\nIt seems that the shift operator is used in the post, but I can't figure out why it was used.\n\nThe point is, shift has no order, and you can't take the output of the function and figure out what order the numbers were in.\n\nI can't read this code.\nI read it as:", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([ord(ch) for ch in s.split() if ord(ch) < ord(\"a\") for ch in s.split()])\n\nI wonder how you would be able to get the output you want, without having to convert the original string to lower case first.\n\nI like the way that the HN frontpage now is not cluttered by all these stupid programming questions (not that I don't like programming questions, I do, but I have to read through the questions to get to the good ones).\n\nThe URL had?p=1 appended to it. I guess that got passed along to the URL as well.\n\nIf only the Python reddit was more active...\n\nAh, so it is. I was using the Google Groups feed for python-reddit (which I think has been\ndead for months).\n\nNow with a paltry 9 upvotes, I think it's safe to say that people don't care.\n\nTo be fair, this question is somewhat meta for HN. The guy was looking for a simple solution that didn't involve any extra modules. He may not have been aware of the standard string module's methods.", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.split(\"\").join(chr(ord(ch)) for ch in s.split(\",\"))\n\nIn both functions the function  has been used to extract letters from the input string. This function is defined in python's standard library.</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([ord(\"a\") for ord(\"a\") in s])\n\nencoded = encode_shift('abcd')\ndecoded = decode_shift(encoded)", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.encode('utf-8')\n\n>>> enc = \"abcdefg\"\n>>> dec = \"efghijkl\"\n>>> enc = encode_shift(enc)\n>>> dec = decode_shift(dec)\n>>> print(dec)\n\"abcdefg\"", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join([chr(((ord(\"a\" + 5) % 26) + ord(\"a\")) for ch in s])\n\nThis is probably not the most efficient implementation, but it is the most readable one for me.\n\nYou're getting downvoted because you're not really giving the most efficient implementation. To fully decode the string, you need to go through every single character in the string, and compare it to \"a\" until you find one that matches. You can do it in O(n) time, where n is the length of the string.\nTo do it in O(1) time, you need to compare the first character to the first character in the alphabet, the second to the second, and so on. For that, you can use the array-based solution above.\n\nThat's not the most efficient, as you can do it in O(1) time by skipping all comparisons if the first character is 'a'.\n\nI would argue that the parent comment's solution is in fact the most efficient, since it's very easy to do in a single pass of the string, whereas your solution requires two passes to check the first character. In my opinion,", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(ord(ord(chr(ord(\"a\"))) + ord(\"a\")))\n\nSee also\n Python String Methods\n\nExternal links\n\nHow to decode shift 5 encoding\n\nHow to decode shift 6 encoding\n\nHow to decode shift 7 encoding\n\nHow to decode shift 8 encoding\n\nHow to decode shift 9 encoding\n\nHow to decode shift 10 encoding\n\nHow to decode shift 11 encoding\n\nHow to decode shift 12 encoding\n\nHow to decode shift 13 encoding\n\nHow to decode shift 14 encoding\n\nHow to decode shift 15 encoding\n\nHow to decode shift 16 encoding\n\nHow to decode shift 17 encoding\n\nHow to decode shift 18 encoding\n\nHow to decode shift 19 encoding\n\nHow to decode shift 20 encoding\n\nHow to decode shift 21 encoding</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr((ord(ch) + 5 + ord(\"a\")) % 26) for ch in s])</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([ord(ch) for ch in s.split()])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(\"a\" - ord(\"a\" + ord(\"a\"))) / 5 - ord(\"a\")) for ch in s] + s[::-1])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 + ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\nI think that this article is misleading.\nThe original article was about how to use'shift' as a primitive to build a substring of a string in a certain language (which I don't remember, but it is not English).\nThe trick is to use the 'decode_shift' function to get the substring, and to replace the 'encode_shift' function in the 'encoding' function.\n\nI agree. I didn't understand the purpose of this until I saw the original article. I think it's a little misleading as written.\n\nThe original article (\n) was about how to use\n'shift' as a primitive to build a substring of a string in a certain language.\n\nYeah, that's the article I meant. I think the way this article is written is a bit misleading because it doesn't make it clear that it's a translation to Python.\n\nThe other article is also misleading, since it doesn't mention any sort of conversion of the shift function.\n\nI don't think", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(\"a\")) for ch in s.split()])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) - 5) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    if not s.startswith(\"\"):\n       return \"\".join([chr(ord(ch) + 5) for ch in s])\n    return s.strip()\n\nI'm not sure if I'm being stupid, but I don't see how this is supposed to work.\n\nYou're not stupid.\n\nThis seems to be about the same as this, which also works (in python):\n>>> import urllib\n>>> s = urllib.urlencode(\"This is a test.\")\n>>> d = urllib.unquote(s)\n>>> print d\nThis is a test.\n>>>\n\nIt's important to understand that this only works if you don't mind screwing up your data in the process.\nIt's not the same as urllib.unquote(). The unquote() function returns the bytes that make up the _string_, encoded in the encoding specified by the Content-Type header.\nThe function from the original post actually shifts every character in the string 5 bits to the left, and then returns the result. The data returned is not valid UTF-8.\n\nIt's not", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    s = s.decode('ascii', 'ignore')\n    s = s.decode('utf-8', 'ignore')\n    s = s.decode('utf-16le', 'ignore')\n    return s\n\nI'm afraid it's not that simple. There are three different shifts depending on the alphabet: UTF-8/16/32 (base 10/16/32). And the result is not always ASCII.\n\nSee also: \n\nFascinating. I had no idea such a simple algorithm could be used to store data compactly.\n\nNote that this is not \"encoding\" the data, it's simply a way to compress a string with a very small loss of fidelity.\n\nThat's why it's called \"compressing\".</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) - 5) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.shift(ord(\"a\") + ord(\"a\")) + s.join(chr(ord(\"a\") + ord(\"a\")))\n\nThe code is elegant and simple. It is a very naive way to do it. I wrote it to test my new browser.\n\nI don't understand it. How can a string be encoded with a single function? I'm not familiar with python so maybe it has some weird quirks, but I'd expect you'd need an encoding for every string. How do you encode strings of variable length?\n\nIt doesn't encode the string. It returns a new string encoded with some scheme. The scheme is \"shift characters by five\".\n\nI got that. But if you try to put it in a file and run it, how do you encode the string?\n\nYou would encode it using a \"data encoder\" (eg, Base64), which you would import into your script. You can encode the same string many times, and encode the different encodings using different data encoders.\n\nSo if your string is \"abcdefghijklmnopqrstuvwxyz\", and you wanted to encode it using Base64", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return str(s.encode_shift())</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) - ord(\"a\")) for ch in s if ord(\"a\") in ch])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(ord(ch) for ch in s if ch >= ord(\"a\") else ch)\n\nAs explained here, you can use python's built in \"ord\" to convert the character to the corresponding letter.\nSo for example, decode_shift('abcdefg') = 'def'.\nThe title of the article has the correct answer of 'defg'.</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(\"a\")) for ch in s if ord(ch) > ord(\"a\"))])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) + ord(\"a\")) for ch in s])</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    for ch in s:\n        return ord(ch)\n\nDoes anyone understand how this works? I can't figure it out.\n\nIt shifts everything by 5 characters, and then adds the letter a on to the end.\n\nYou can see that he is getting the encoded string by using the ord function.\n\nThe encoding used is called a \"Universal Code\"\n\nIt's easy to break with \n\nThe author is the creator of universal code!\n\nSo, it's basically a URI encoded with base-5 (thus, why you can decode it with base-5)?\n\nExactly.\n\nThat's a pretty cool trick. Although I think you should always make sure your users know how to decode your binary data.\n\nI agree. It's a little bit strange to use this encoding to transmit passwords.\n\nI am sorry but I don't get it.\n\nBase 5 is just a number system, each character is a number, just like in base 10 (decimal).\nIn base 5, the number 5 would represent the letter \"A\" and 0 would represent the letter \"0\".\nThis encoding is used to transmit data in a", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(chr(((ord(\"a\") + ord(\"a\") % 26) - ord(\"a\") + ord(\"a\")) for ch in s))</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    for _, v in enumerate(encode_shift(s)) -> iterable:\n        v = v[0]\n        if chr(ord(v)) == ord(\"a\"):\n           return \"\".join(v)\n        else:\n           return s\n\nI read that, and didn't immediately recognize it as being the equivalent of encoding with base 26, so I took a closer look and was surprised to see that the encoding method was a dictionary lookup. The way it was written, it looks like it is the equivalent of the \"chr\" function, which would produce the same value as the original string. It took a few seconds to realize that it's actually encoding the string with a new alphabet, and that the \"chr\" function is not part of the new alphabet.\nAs an alternative, you could use the \"codecs\" module to produce a more readable encoding and decoding function. You can define your own codecs, which is actually pretty fun.\n>>> from codecs import Codec", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.encode('ascii', 'ignore')", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n>>> print encode_shift(u'Hello world')\n'HeLlO wOrLd'\n>>> print decode_shift(u'Hello world')\n'Hello world'\n\nI would add the algorithm's definition and not the bare factorial.</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(chr(ord(ch) + 5 - ord(\"a\")) for ch in s)", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\nAnother way to encode it is to convert it to base64. The reason for this is that base64 encodes it in ASCII characters, and the decoding can be done by counting the number of characters in the string.", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.split('.').map(str.get_base_value + ord(ord(ch)) % 26)\n\ns = \"abcdefghijklmnopqrstuvwxyz\".encode_shift()\ns = s.decode_shift()</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.encode('ascii','shift=5')", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    s = \"\".join([ord(ch) for ch in s if ord(ch) % 26!= 0])\n\nI can't believe they used Python for this. The explanation of this program is much easier in English than Python.\n\nI like this example because it shows how easy it is to translate math into Python. The two operations, \"shifting\" and \"concatenation\" are both built into the language.</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.replace(\"\".join([chr(ord(ch) + 5 - ord(\"a\")) % 26]) for ch in s])</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([ord(ch) for ch in s.shift()])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([ord(ch) for ch in \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s] if ch!= ord(\"a\"))))\n\nThe main difference is that encode_shift is a 'linear function' (addition modulo 26) while decode_shift is a 'non-linear function' (loop). In any case, I doubt that Python implements'shift' in that way.\n\nIt is indeed implemented with a loop.\n\nWhy would you want a non-linear function for this?\n\nYou want it to be non-linear because it makes it easier to reorder the encoded characters to the desired order.\n\nNo, it doesn't. It makes it easier to change the alphabet, but if you want to reorder the original alphabet, you do the same thing as linear code, just iterating backwards.\n\nThis was a good read. I recently put together a fun little language that has byte-oriented Unicode handling. It uses a similar trick to make a byte-oriented sort routine. I wrote a blog post about it:\n\nIt's interesting that there is", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    chr((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\") + ord(\"a\") + ord(\"a\")", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join(ord(\"a\"), ord(\"z\"))</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(s.split(\"\").decode(\"ascii\"))", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.replace(\"\".join(chr(((ord(ch) - ord(\"a\")) % 26) + ord(\"a\")) for ch in s))\n\nThe \"def decode_shift(s: str):\" part of the code is the function that is executed.\nThe \"return s.replace(\"\".join(chr(((ord(ch) - ord(\"a\")) % 26) + ord(\"a\")) for ch in s))\" line is not part of the function. It's just part of the code that is executed.\n\nThat's the same with the \"def encode_shift(s: str):\" part.</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) - ord(\"a\")) for ch in s if ord(ch) in range(26 - ord(\"a\"))])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) - ord(\"a\")) for ch in s])\n\nLOL, I'm soo tired of those stupid \"LOL\" comments...\n\nI'll be glad when that trend goes away. It's like someone is laughing at me, and I don't like it.</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s[0] + chr(((ord(ch) - 5) % 26) + ord(\"a\")) + ord(\"a\")", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([ord(ch) for ch in s])</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) + 5 - ord(\"a\")) for ch in s.encode_shift()])</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) - ord(\"a\")) for ch in s])\n\nNow, if you want to find the answer, you have to make the same transformation in the decoded string.", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(ord(ch) for ch in s[:5])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.replace(''.join(ord('a' if ch >= 26 else 'a') for ch in s), 'a')\n\nNote that there are only 5 letters in the alphabet. :)\n\nThis is an interesting idea.\nI would call this a \"Cobol Encoding\" as it is based on the fact that C0 is\nequal to A, C1 is equal to B, C2 is equal to C, and so on.\nIt is really interesting that this encoding is actually shorter than the\nunencoded strings.\n\nI implemented this for C++ to test it and it turns out that this function is\nnot constant time. It's a relatively small slowdown, but it still does not\nperform as well as a conventional function which would be constant time.\nFor the curious, the slowdown is due to the fact that the function\nencoder_shift() is using a relatively expensive O(n) operation, while the\ndecoder is using a relatively cheap O(1).", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(ord(ch) for ch in s.split())", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join(ord(\"a\")) + s.join(ord(\"b\")) + s.join(ord(\"c\")) + s.join(ord(\"d\")) + s.join(ord(\"e\")) + s.join(ord(\"f\")) + s.join(ord(\"g\")) + s.join(ord(\"h\")) + s.join(ord(\"i\")) + s.join(ord(\"j\")) + s.join(ord(\"k\")) + s.join(ord(\"l\")) + s.join(ord(\"m\")) + s.join(ord(\"n\")) + s.join(ord(\"o\")) + s.join(ord(\"p\")) + s.join(ord(\"q\")) + s.join(ord(\"r\")) + s.join(ord(\"s\")) + s.join(ord(\"t\")) + s.join(ord(\"u\")) + s.join(ord(\"v\")) + s.join(ord(\"w\")) + s.join(ord(\"x\")) + s.join(ord(\"y\")) + s.join(ord(\"z\")) + s.join(ord(\"a\")) + s.join(ord(\"b\"))", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) + ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    for ch in s:\n         return chr((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(ord(ord(ch) + ord(\"a\")) for ch in s)\n\nI'm not sure if this is the intended behavior, but the resulting decoded string doesn't contain any characters from the \"a\" alphabet.\n\nIndeed, I think the order is wrong.\n\nIt is not wrong, it is just a different encoding.\n\nI'm not sure what you mean by that. I assume you mean that the ordering of the alphabet is arbitrary.\nIf that's what you mean, then I have to say that's incorrect. For the simple reason that if you have a string of the same length and you're just replacing some characters with others, you have to keep the alphabet in the same order. If you don't, then you can't tell what the original string was.\nSo if you replace a 'a' with an 'a' that's one thing. If you replace a 'a' with an 'r' then the alphabet is in a different order, so you don't know what the original string was.\n\nA slight modification gives you this:", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.split(\"\").join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\nPythonic.\n\nHow is this pythonic?\n\nIt's more readable than the original.\n\nActually, it isn't. At least not without reading it several times to be sure of what it does.\n\nI like it. I'm going to steal it and use it. Thanks.</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.encode_shift(str.lower().decode('ascii'))</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    s = \"\"\n    for ch in s:\n       if ord(\"a\" + ord(\"a\")):\n          s += ch\n       if ord(\"a\" + ord(\"a\"))!= ord(\"a\" + ord(\"a\")) + ord(\"a\"):\n          return \"\".join([chr(((ord(\"a\" + ord(\"a\") - ord(\"a\" + ord(\"a\"))) % 26) + ord(\"a\")) for ch in s])\n    return s\n\nThat's great, but doesn't that mean that it doesn't work on non-ascii characters?\n\nI guess not, because it's using ord().\nBut I don't understand the purpose of this. What are the use cases?</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.join(b\"\\0\")", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(ord(ch) for ch in s.split(\"\").reverse().split(\" \")[::-1])</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s[chr(((ord(ch) - ord(\"a\")) % 26) + ord(\"a\")) for ch in s]", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) + 5 - ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return decode(chr(ord(\"a\")) + ord(\"a\"), s)\n\nHere is the Python version of encode_shift. I am not sure if it is in Python3, but I haven't seen it.", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) + ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return decode_str(s, \"base64\")\n\nHow does it work?\n\nThe encode_shift function is a simple and straightforward function. It just shifts the characters in the string by the given amount. The %26 is a modulo operator that returns the remainder of the division of the number by 26.\n\nThe decode_shift function is also very simple, it just returns the decoded string after base64 encoding.\n\nThe main function is the one that uses these two functions. The first argument to main is the input string, and the second argument is the number of bytes to encode the string with.\n\nSee also\n Base64\n Encode\n Decode\n\nReferences\n\nExternal links</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    for c in s:\n        print(c)\n    return \"\".join([chr(ord(c) + 5 - ord(\"a\")) % 26 for c in s]\n\nAs the article points out, this is _much_ more efficient than a number of other approaches.\n\nIt's not, it's just different. The _only_ thing that's different is that the method is using a static encoding, instead of a dynamic encoding.\n\nHow are you getting this? The article explicitly states that:\n\nNo, it says that this is a different approach to the problem. What you've done is taken an encoding that's inefficient for the task at hand (high-entropy string encoding) and found a clever way to use it.\nThe _only_ thing that makes this interesting is the static encoding. It's something that's good for other tasks, but not this one.\n\nThat's a pretty impressive result, given that the example given is not even vaguely real-world.\n\nWouldn't this be much more efficient if it used a lookup table instead of all that string manipulation?\n\nThen you have the overhead of a lookup", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    if s.startswith(\"^\") and len(s) == 1:\n       return s\n    if len(s) > 1:\n       return s[0:5]\n    return \"\".join(ord(ch) for ch in ord(s[0:5]))\n\nmy shift function:", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch)) for ch in s if ord(ch) > ord(\"a\")])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return chr(ord(ord(\"a\")) + ord(\"a\")) for ch in s", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s] + \"\")</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([ord(ch) for ch in s if ch!= ord(\"a\") for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.split(\"\").map(chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\"))).join('')\n\nAnd then, to use it:", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.replace(ord(\"a\" + 5) for ord(\"a\" + 5) in s)</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(ord(ch) for ch in s.split())</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(\"a\" + ord(ch)) % 26) for ch in s])\n\nI am not sure I understand this. How do you get the original string back?\n\nYou can always use the length() method to figure out the length of the result.\n\nOr just have the function return a tuple that has both the decoded value and the index into the source string.\n\nOr use the sorted() method.\n\nOr return the index as the character at the end of the string.</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.replace(\"a\", \"z\").join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\nWhen you want to count the number of a specific character in a string you can use this:", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr((ord(ch) + 5 - ord(\"a\")) % 26) for ch in s if ord(ch) % 26])</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr((ord(ch) + 5 - ord(\"a\")) % 26) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.split()[1] + s.join(chr(ord(ch) + ord(\"a\")) for ch in s)", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    for c in s:\n        if ord(c) > 26 and ord(c) < ord(\"a\"):\n            return ord(\"a\")\n        else:\n            return ord(c)\n    return s\n\nThe _char function is extremely useful when working with unicode strings, especially if you have to support multiple encodings.</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 + ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s.replace(\" \", chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s)</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(chr((ord(\"a\") - ord(ch)) % 26) for ch in s.encode_shift())\n\nEncode_shift and Decode_shift are simple functions which take a string and shift each character by 5 in the alphabet.\n\nSee also\nCRC encoding\n\nReferences\n\nExternal links\nReducing the search space for efficient encoding/decoding with LSH</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(s[:5]) + chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\"))\n\n    \"\"\"\n    def ascii_to_str(str: str):\n    \"\"\"\n    converts string to a sequence of ASCII characters\n    \"\"\"\n    return str.split(\"\\r\").get(0).split(\"\\n\")[::-1]\n\n>>> ascii_to_str(\"fghi\")\n[('f', 'f'), ('h', 'h'), ('i', 'i'), ('j', 'j'), ('k', 'k'), ('l', 'l'), ('m','m'), ('n', 'n'), ('o', 'o'), ('p', 'p'), ('q', 'q'), ('r', 'r'), ('s','s'), ('t', 't'), ('u', 'u'), ('v', 'v'), ('x', 'x'), ('y', 'y'), ('z', 'z')]\n\n>>> ascii_to_str(\"xn--p1", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return decode(s).replace(\"_\", \"\").replace(\"_\", \"\")", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s[0] + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord(\"a\") + ord", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(chr(ord(ch) - ord(\"a\")) for ch in s)\n\nThis is not a good idea. Suppose you are decrypting a message that has been encoded with your encryption algorithm, and suppose it's a message like: \"This is an example of a message that was encoded with our encryption algorithm\".\nThen you get a stream of bytes like this:\n% and if this is encoded with the same method as the decoder\n% then decoded:\n%", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch) - ord(\"a\")) for ch in s])\n\n>>> encode_shift(\"hello\")\n\"55e00\"\n>>> decode_shift(\"55e00\")\n\"hello\"\n\nSo this just shifts the alphabet right? I'm not sure why I would need to do this, what's the advantage?\n\nYou might not want to do this (unless you are sending over an encoded stream), but the advantage is that you can easily see what the encoded string contains.\nI wrote a little bit about this a while back:\n\nI usually use encode() for this.</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    s = \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n    s = chr(ord(ch)) + ord(\"a\") * 26\n\n    return s", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    if s.startswith(\"encode_\") or s.startswith(\"decode_\") or s.startswith(\"encode_shift_\") or s.startswith(\"decode_shift_\"):\n        return s\n\n    s = list(s.split(\"\n    \"))\n    for i in range(0, len(s)):\n        s[i] = decode_shift(s[i] / 26)\n\n    return s\n\nThe author didn't do any math. A shift of 5 places will translate to a substitution of two places.\n\nFor an efficient implementation, consider \"substituting\" by multiplying the characters together mod 26 instead of directly shifting the characters.\n\nI think that's a bit too clever, especially given that it's python.\nI think it would be more efficient to just do the simple lookup table:\n>>> 'encode_a_b_c'[26] = ['a', 'b', 'c'] >>> 'encode_a_b_c'[27] = ['a',", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([chr(ord(ch)) for ch in s if ch not in \"a\"])</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([ord(\"a\") for ch in s if ch!= ord(\"a\")))\n\nThis seems to have the same effect as:", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(ord(\"a\"), ord(\"a\") + ord(\"a\")) for ch in s)</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s[(ord(ch) + 5 - ord(\"a\")) % 26] + \"a\"</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\"))", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join([ord(ch) for ch in s])", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(chr(ord(ch) - ord(\"a\")) for ch in s)\n\nSlightly cleaner version:", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    if s:match(\"^[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{1,2}[a-z]{", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return s[:5] + ord(\"a\")</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return \"\".join(s.encode(\"utf-8\"))</s>", "def encode_shift(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\" \"\"\"\n    return chr(ord(ch) * 5 - ord(\"a\")) for ch in s\n\ns = \"abc\".encode_shift()\ns = s.decode_shift()\ns = \"abcdefg\".encode_shift()\ns = s.decode_shift()\n\n[Edit] The original post was incorrect; my solution and a much better one were posted later.\n\nI'd like to emphasize that the argument to the encode_shift function should be a character string, not a character sequence. This is a very important detail.\n\n[Edit] Even if the comment is not correct, the point is still valid: the function is not correctly specified.\n\nI don't understand how you get that behavior from the provided examples. I can't even get the first example to behave as you describe.\n\nPlease use Python 2.x syntax (and wrap the expressions in parentheses) to make it clear that the argument to encode_shift is a string, not a sequence of characters.\n>>> \"abc\".encode_shift(\"abcdefg\")\n\"abcdefg\"\n>>> \"abc\".encode_shift(\"abcdefg\")\n\"abcdef"]]