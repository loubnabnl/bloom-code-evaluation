[["def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def __init__(self, n: int):\n    self.n = n\n    def fib(self):\n    return self.n\n    def __str__(self):\n    return '{}%s' % (self.n, repr(self.fib(1)))\n    def fib(self, n = 1):\n    return self.fib(n-1) + self.fib(n-2)\n    def fib(self, n = 2):\n    return self.fib(n-1) + self.fib(n-3)\n    def fib(self, n = 3):\n    return self.fib(n-1) + self.fib(n-4)\n    def fib(self, n = 4):\n    return self.fib(n-1) + self.fib(n-5)\n    def fib(self, n = 5):\n    return self.fib(n-1) + self.", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\nThis is a nice example. You can do:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def __init__(self, n: int):\n    self.n = n\n    def next(self):\n    \"\"\"Return next element of fibonacci sequence.\n    >>> next(fib(10))\n    55\n    >>> next(fib(1))\n    1\n    >>> next(fib(8))\n    21\"\"\"\n    return self.n\n\n>>> def fib(n):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    def __init__(self, n: int):\n    self.n = n\n    def next(self):\n    \"\"\"Return next element of fibonacci sequence.\n    >>> next(fib(10))\n    55\n    >>> next(fib(1))", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def f(n: int):\n    \"\"\"Return fibonacci number n-th.\n    >>> f(8)\n    21\n    >>> f(11)\n    34\n    >>> f(22)\n    55\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return fibonacci number n-th.\n    >>> fib(11)\n    34\n    >>> fib(22)\n    55\n    \"\"\"\n    return f(n-2) + f(n-1)\n\nGiven that the Fibonacci sequence does not converge, the function is only defined for natural numbers and cannot be used for arbitrary precision numbers.\n\nThis is a fine example of why you don't use functions to define other functions.\n\nIt's also worth noting that the recursion-based implementation of the fibonacci sequence is more efficient than the iterative-based approach.\n\nMy version of fib() as a python dictionary and its fibs() as a function that works with tuples, lists and diction", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(1)\n    1\n    >>> fib(2)\n    2\n    >>> fib(5)\n    8\n    >>> fib(3)\n    8\n    >>> fib(7)\n    21\n    >>> fib(4)\n    13\n    >>> fib(6)\n    34\n    >>> fib(2)\n    3\n    >>> fib(4)\n    11\n    >>> fib(1)\n    1\n    >>> fib(2)\n    5\n    >>> fib(3)\n    8\n    >>> fib(5)\n    21\n    >>> fib(7)\n    34\n    >>> fib(4)\n    13\n    >>> fib(1)\n    1\n    >>> fib(", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(3)\n    1\n    >>> fib(5)\n    1\n    >>> fib(5)\n    1\n    >>> fib(6)\n    1\n    \"\"\"\n    if n == 0:\n       return 0\n    n = n - 1\n    if n == 1:\n       return 1\n    return fib(n - 2) + fib(n - 1)\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(8)\n    21\n    >>> fib(0)\n    0\n    >>> fib(1)\n    1\n    >>> fib(2)\n    1\n    >>> fib(0)\n    0\n    \"\"\"\n    if n ==", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    n = 0\n    while n < 10:\n        n = fib(n-1) + fib(n-2)\n    return n\nI understand that fib(1) is the first Fibonacci number, and that this is just a matter of testing for numbers smaller than 10 and returning the first one.\nBut why is there a loop? Why don't you just return the first value and break out of the loop?\nIt looks like it's just to make it easier to understand, but I have no idea why.\n\nThe loop is to show that fib(x) is the same thing as (fib(x-1) + fib(x-2)) where fib(x-1) is also known as \"fibonacci(x-1)\".\n\nThank you. That's a good explanation.\nBut what does that have to do with n?\n\nIt's used to make the return of fib(n) be different from fib(x) if n!= x.</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return [0] if n <= 2 else\n    return fib(n - 2) + fib(n - 1)\nI think there's a bug in this code.\n\nWhat does this mean?</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    n = n - 1\n    return fib(n - 2) + fib(n - 1)\n\nThis is a perfect example of _why_ Python 2 has str2num.\n\nI see no problem with this. This is an example of a correct and a incorrect use of the str2num conversion. The code could have been written to have the desired behavior of the conversion by simply adding an isinstance check to the function that is trying to convert to a number:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(1)\n    1\n    >>> fib(2)\n    1\n    >>> fib(3)\n    2\n    >>> fib(5)\n    8\n    \"\"\"\n    return 0\n\nYou missed the point. The assignment was to write a function that returns a value equal to its input, or raises an exception.\nFor fib(10), fib(1) would return 10. You can't return 10 from a function that takes one argument.\n\n>The assignment was to write a function that returns a value equal to its input, or raises an exception.\nYou could just return 10.\n\nI think it's more important to get the message of the assignment. If you are writing code that makes some kind of sense, but doesn't work, it's easy to miss that the assignment is to make it work.\n\nYou missed the point of the assignment.\n\nI love this site.</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    n := 1\n    while n < 2:\n        if n == 1:\n           return n\n          else:\n            n := n + fib(n - 1)\n           return n", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n):\n    \"\"\"Return fibonacci number for n-th iteration.\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 0:\n       return n\n    return fib(n - 1) + fib(n - 2)", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(1)\n    1\n    >>> fib(2)\n    3\n    >>> fib(3)\n    5\n    \"\"\"\n    return n*fib(n-1)+fib(n-2)\nThis is like the perfect definition of \"functional programming\". No variables, no side effects, no names. Just \"do it this way, always\".\n\nIt's also a great definition of \"blindly following a bad algorithm\".\n\nCan you expand on that?\n\nThe Fibonacci sequence is _known_ to be not-so-efficient. It's not only that the algorithm is simple; it's also that it's _guaranteed_ to use O(n^2) space in the worst case, and that's a bad tradeoff for a sequence that can be described as \"really big\".\nIn fact, there are better algorithms that can be described in just as few characters as this one. Here's one:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    n = int(input(\"Enter the number to calculate: \"))\n    f1 = fib(n - 2)\n    f2 = fib(n - 1)\n    return f1 + f2\n\n[EDIT]\n\nA little bit better.", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    return 0\n\nLooks like an interesting language, but is it really necessary to post your own language in each \"I made a programming language\" thread?\n\nSo, what's wrong with Python?\n\nThis is far too \"ruby like\". I feel like there's a lot of boilerplate and too many abbreviations, it's a bit of a pain to read.\n\nThis is like ruby with curly braces, OO, and weird indentation.\nI don't understand the downvotes, he's right.\n\n\"This is like ruby with curly braces, OO, and weird indentation.\"\nI have not heard a more succinct explanation of what I hate about Ruby, and now I have a way to say it. Thank you.\n\nIt's like Python if Python had all the features of Perl, except for the syntax of Python.", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib_dec(n: int):\n    \"\"\"Return (n-1)*(n-2).\n    >>> fib_dec(10)\n    55\n    >>> fib_dec(1)\n    1\n    >>> fib_dec(8)\n    21\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    def fib_dec(n: int):\n    \"\"\"Return (n-1)*(n-2).\n    >>> fib_dec(10)\n    55\n    >>> fib_dec(1)\n    1\n    >>> fib_dec(8)\n    21\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return fib(n-1) + fib(n-2)\n>>> fib(5)\n<type 'int'>\n>>> fib(6)\n<type 'int'>\n>>> fib(7)\n<type 'int'>\n>>> fib(8)\n<type 'int'>\n>>> fib(9)\n<type 'int'>\n>>> fib(10)\n<type 'int'>\n>>> fib(11)\n<type 'int'>\n>>> fib(12)\n<type 'int'>\n>>> fib(13)\n<type 'int'>\n>>> fib(14)\n<type 'int'>\n>>> fib(15)\n<type 'int'>\n>>> fib(16)\n<type 'int'>\n>>> fib(17)\n<type 'int'>\n>>> fib(18)\n<type 'int'>\n>>> fib(19)\n<type 'int'>\n>>> fib(20)\n<type 'int'>\n>>> fib(21)\n<type 'int'>\n>>> fib(22)\n<type 'int'>\n>>> fib(23)\n<type 'int'>\n>>> fib(24)\n<type '", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib_recursive(n: int):\n    \"\"\"Return n-th Fibonacci number recursively.\n    >>> fib_recursive(8)\n    21\n    >>> fib_recursive(5)\n    23\n    \"\"\"\n    return fib(n - 1) + fib(n - 2)\n\nYou can save on the implicit recursion by using the Python \"pass\" function:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib2(n: int):\n    \"\"\"Return n-th Fibonacci number, only if the difference is < 2.\n    >>> fib2(2)\n    1\n    >>> fib2(1)\n    1\n    >>> fib2(6)\n    6\n    >>> fib2(3)\n    3\n    \"\"\"\n    def fib3(n: int):\n    \"\"\"Return n-th Fibonacci number, only if the difference is < 3.\n    >>> fib3(2)\n    1\n    >>> fib3(2)\n    1\n    >>> fib3(2)\n    1\n    \"\"\"\n    def fib4(n: int):\n    \"\"\"Return n-th Fibonacci number, only if the difference is < 4.\n    >>> fib4(2)\n    1\n    >>> fib4(2)\n    1\n    >>> fib4(2", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\n_\n\nI hope that this is the correct forum to ask this question. I am currently in an intermediate Python programming course.\n\nI am having trouble with a very simple program that is supposed to be a simple fibonacci calculator. I have read the documentation over and over again and still can't figure it out. Please help, I need to pass this assignment.", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n        def get_next_fib(n: int):\n    \"\"\"Return first fibonacci number which is greater than n.\n    >>> get_next_fib(2)\n    12\n    >>> get_next_fib(3)\n    21\n    \"\"\"\n        def get_next_fib_for_n(n: int):\n    \"\"\"Return first fibonacci number which is greater than or equal to n.\n    >>> get_next_fib_for_n(5)\n    25\n    >>> get_next_fib_for_n(4)\n    16\n    \"\"\"\n        def fib_sum(n: int):\n    \"\"\"Return sum of all fibonacci numbers from 1 to n.\n    >>> fib_sum(5)\n    120\n    >>> fib_sum(1)\n    3\n    \"\"\"\n        def", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\n    def fib2(n: int):\n    \"\"\"Return n-th Fibonacci number squared.\n    >>> fib2(10)\n    55\n    >>> fib2(1)\n    11\n    >>> fib2(8)\n    121\n    \"\"\"\n    def fib_one(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib_one(10)\n    55\n    >>> fib_one(1)\n    1\n    >>> fib_one(8)\n    21\n    \"\"\"\n    def fib_two(n: int):\n    \"\"\"Return n-th Fibonacci number cubed.\n    >>> fib_two(10)\n    55\n    >>> fib_two(1)\n    11\n    >>> fib_two(8)\n    121\n    \"\"\"\n    def fib_three(n: int):", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return (n < 2? 1 : n + fib(n-1))\nThis is a very simple implementation of fibonacci (it uses recursion to compute the next n/2 numbers). The purpose of the post is to show that the Python version does not just \"work\", but is very efficient (and probably faster than other implementations).\n\nThe C version is more efficient (if you don't count the overhead of the function call):\nfib(n)\n{\nreturn n / 2\n}\nIt can be rewritten without the function call as a simple expression:\nfib(n) = n / 2\nBut the Python version is a good example of recursion and functional programming.\n\nYou're not counting function calls in the Python version, either. You are calling the same function for every number.\nI'm not sure how to count that, but I would say that it is not as efficient as the C version.\n\nThe Python version has no overhead for function calls. There's a small overhead for the function call in the C version.\n\nFunny that the author doesn't mention how much overhead there is for function calls in Python.\n\nWhen I started the article,", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return fib(n-1) + fib(n-2)\nAnd now try this:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def nfib(n):\n    \"\"\"Return n-th Fibonacci number.\"\"\"\n    return fib(n-2) + fib(n-1)", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib():\n    \"\"\"Return Fibonacci number.\n    >>> fib()\n    21\n    >>> fib(5)\n    56\n    \"\"\"\n    if n == 1:\n       return 1\n    return fib(n-1) + fib(n-2)\n    # Addition is commutative\n\nWhen n == 1, this is the same as simply calling the method fib.  The author could have used \"if __name__ == '__main__':\", but chose not to.\n\nSo, it's a class that only has a single method, that just does a lookup of a static variable?\n\nThe static variable can be changed at runtime, so I wouldn't call it a lookup.\n\nThis is the best explanation I've found of it: \n\nSo, the article is a bit misleading. The only thing that makes it \"immutable\" is the local scope. When you import the module it's no longer immutable.\n\nI would say it is, just not in the sense the author is talking about.\n\n\"The", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return n if n <= 0 else 1\nOh man, there is no way you should be on the internet.\nIf you didn't get it: \n\nI don't see the point of this.\n\nIt's a joke.</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\n    def fib(n: int) -> int:\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(8)\n    21\n    \"\"\"\n\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(7)\n    35\n    \"\"\"\n\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(7)\n    35\n    \"\"\"\n\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(7)\n    35\n    \"\"\"\n\n    def fib(n: int):\n    \"\"\"Return n-th Fib", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return 1\nThat one is a bit better than the original.\n\nNah, this is what makes it even better:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib():\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib()\n    55\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    return fib(n)\nI am sorry but this is not acceptable.\nI expect the use of a language to be consistent and concise. I don't like having to look up the docs to figure out the function signature.\n\nI'm more sympathetic to the view of pajamajam.\nI think the _convention_ of", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def __add__(self, r: int, s: int):\n    \"\"\"Return sum of two numbers.\n    >>> __add__(5, 2)\n    7\n    >>> __add__(2, 5)\n    7\n    >>> __add__(3, 5)\n    11\n    >>> __add__(4, 5)\n    16\n    >>> __add__(6, 5)\n    21\n    >>> __add__(2, 4)\n    8\n    >>> __add__(4, 4)\n    8\n    \"\"\"\n    def __mul__(self, r: int, s: int):\n    \"\"\"Return product of two numbers.\n    >>> __mul__(5, 2)\n    25\n    >>> __mul__(3, 4)\n    15\n    >>> __mul__(6, 5)\n    30\n    >>> __m", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def f1(n: int):\n    \"\"\"Return first Fibonacci number\n    >>> f1(5)\n    10\n    >>> f1(2)\n    5\n    >>> f1(1)\n    1\n    >>> f1(0)\n    1\n    \"\"\"\n    def f2(n: int):\n    \"\"\"Return second Fibonacci number\n    >>> f2(5)\n    15\n    >>> f2(2)\n    8\n    >>> f2(1)\n    4\n    >>> f2(0)\n    1\n    \"\"\"\n    def nf(n: int):\n    \"\"\"Return Fibonacci number n.\n    >>> nf(5)\n    55\n    >>> nf(5)\n    1\n    \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(5)\n    28\n    \"\"\"\n    return (n - 1) + fib(n-1)\nI don't see the point of this code. It's not more readable or\nunderstandable than the example in the article.\n\nI think the original poster was referring to the following:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return (1 if n == 0 else fib(n-1)+fib(n-2))\nAwesome, thanks.</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    if __name__ == \"__main__\":\n    fib = 0\n    for i in range(2,100):\n       fib += fib(i-1)\n    print(fib)\n\nNow you might be tempted to use Python's built-in for loop instead.\n\nfor i in range(2,100):\n    print(fib(i))\n\nAnd you might be tempted to use Python's built-in range function instead.\n\nfor i in range(2,100):\n    print(fib(i))\n\nBut this is not recommended.  The reason is that range is implemented as a generator, and generators are not implemented in a way that allows them to be used inside a for loop.  The error message you will get is \"TypeError: generator expressions cannot be used in for expressions.\"\n\nfor i in range(2,100):\n    print(fib(i))\n\nInstead, you should use the range function as a generator and use the yield expression instead.\n\nfor i in range(2,100):\n    print", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n       return n-2\nWhat is the purpose of this? I don't really understand the point.\n\nIt's a function that takes a natural number, and returns the N-th Fibonacci number.\n\nWhat is the purpose of this?</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return [0, 1, 1, 2, 3, 5, 8, 13, 21]\nI use this all the time.\n\nEvery time I see code like this I think \"Haskell would be so much better if it had support for implicit typing.\"\n\nIt does:\n[0, 1, 1, 2, 3, 5, 8, 13, 21]\n\nI don't see how this is supposed to be a rebuttal. If Haskell had support for implicit typing, we wouldn't have to write the type signature of fib(10) explicitly.\n\nI don't see how this is supposed to be a rebuttal. If English had support for implicit typing, we wouldn't have to write the type signature of \"fib(10)\" explicitly.\n\nIf you have to have an explicit type signature to use a function, it isn't implicit.\n\nRight, but the point is that implicit typing is a language feature, not a function.\n\nI once used a recursive solution to something that most of us consider to be a very simple problem. I found that this recursive solution had a much lower runtime than the naive solution.\nI am still not sure how it happened, but", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib():\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(5)\n    25\n    >>> fib(4)\n    16\n    >>> fib(2)\n    8\n    \"\"\"\n    if n <= 0:\n        return 0\n    return fib(n-1) + fib(n-2)\n    def fibs(n: int):\n    \"\"\"Return all Fibonacci numbers.\n    >>> fibs(5)\n    [1, 1, 2, 3, 5]\n    >>> fibs(5, 10)\n    [1, 1, 2, 3, 5, 8]\n    \"\"\"\n    def fibs():\n    \"\"\"Return all Fibonacci numbers.\n    >>> fibs(5)\n    [1, 1, 2, 3, 5]\n    >>> fibs(5, 10)\n    [1, 1, 2,", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n        def fib2(n: int):\n          \"\"\"Return n-th Fibonacci number, after step 2.\n         >>> fib2(8)\n           14\n    \"\"\"\n        def fib3(n: int):\n          \"\"\"Return n-th Fibonacci number, after step 3.\n         >>> fib3(5)\n              14\n    \"\"\"\n        def fib4(n: int):\n          \"\"\"Return n-th Fibonacci number, after step 4.\n         >>> fib4(7)\n             21\n    \"\"\"\n        def fib5(n: int):\n          \"\"\"Return n-th Fibonacci number", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib_eval(n: int):\n    \"\"\"Return a function object that takes a single parameter, n, and\n    returns the n-th Fibonacci number.\n    >>> fib_eval(10)\n    >>> fib_eval(1)\n    >>> fib_eval(8)\n    >>> fib_eval(1)\n    55\n    \"\"\"\n    def fib_eval(n: int, f: Function):\n    \"\"\"Return a function object that takes a single parameter, n, and\n    returns the n-th Fibonacci number.\n    >>> fib_eval(10, lambda x: x**2)\n    >>> fib_eval(1, lambda x: x)\n    \"\"\"\n    return Function(lambda x: f(x, n - 1), n - 1)\n\nActually, I'm not sure that this is the best way to do it... I just couldn't find an easy way to express it.\n\nI like this. I've been wanting to see more examples of things like", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    if n < 2:\n        return 0\n    else:\n        if n % 2 == 0:\n           return 1\n    else:\n           return fib(n-1) + fib(n-2)\n    else:\n           return fib(n-1)\nThe above function is not a function.</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(2)\n    1\n    >>> fib(3)\n    3\n    >>> fib(2, 4)\n    8\n    \"\"\"\n    return n == 1? 1 : fib(n - 2) + fib(n - 1)\n\nI don't get it. Is this supposed to be like the Knuth-Plass line noise example [0], which just looks like noise?\n[0] https://en.wikipedia.org/wiki/Knuth-Plass_line_noise\n\nThe result is a very long series of 1s and 0s. In binary, those are equivalent to a long sequence of 1s.\nIn other words, the Fibonacci series is just a sequence of 1s.\n\nThank you. I can't believe I missed that.\n\nThis is the first programming thing I've ever submitted, so I'm nervous!\n\nI've only been here for a few days, but I'm glad to see it. I'm trying", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return fib(n - 1) + fib(n - 2)\nThe story of the Fibonacci sequence (and its cousins) is a good one, and it's good to see it in code.\n\nFunny how the Fibonacci numbers actually pop up everywhere in nature.\n\nEven funnier is that the sequence (1,1,2,3,5,8,...) shows up in the recursion of the code!\n\nReally cool code. I especially like the part where it uses recursion.\n\nI like the part where it uses recursion too!\n\nWhen it loops, the fib() function is exactly the same as f() in this function, which is to say that it calls itself to calculate the next value.\n\nI know this is old but I have to be a pedant: This isn't recursion!\nIt's an example of a tail-recursive function, the two are not the same.\n\nHow does this differ from the definition of recursion in terms of tail-recursion?\n\nI would like to know the answer to this question, too.\n\nTail-recursion has a stack.\nRecursion only requires an", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return [0]*(n - 1) + [1]*(n - 2)\n    if n == 0:\n    return [0]*(n - 1)\n    if n == 1:\n    return [1]*(n - 1)\n\nInteresting that the last step of the fibonacci sequence (n = 2) is a loop.\n\n`fib(n)` calls `fib(n - 1)` and `fib(n - 2)` to calculate the previous n numbers in the sequence.\nSo if n == 2, it calls itself.\n\nIt could have been done with a recursive function too, like this:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    return n if n % 2 == 0 else n\n\nfib(10) would be fine if it was replaced with\nfib(10, 2)\n\nThat's not Pythonic. You want a context manager there to keep you from accidentally calling it with the wrong argument.\n\nIs there an article on the HN front page that is not a response to something that was discussed on the front page a couple days ago?\n\nMaybe that's a sign of a mature, self-moderating community?\n\nThe conversation on that submission was already extensive and thoughtful.\n\nIt is. And in the spirit of this site, it's also appropriate for another submission to be made.\n\nI'm a new programmer, and it's very interesting to see what people consider to be the \"bad\" code.\nI've been reading python tutorials for the last two", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def nthfib(n: int):\n    \"\"\"Return the n-th Fibonacci number.\n    >>> nthfib(3)\n    7\n    >>> nthfib(1)\n    1\n    >>> nthfib(5)\n    25\n    \"\"\"\n    def __iter__(self):\n    \"\"\"Return the iterable version of the object.\n    >>> mylist = [fib(1), fib(2), fib(3)]\n    >>> iter(mylist)\n    [fib(1), fib(2), fib(3)]\n    >>> iter(self.__iter__())\n    [fib(1), fib(2), fib(3)]\n    \"\"\"\n    return self\n\nPython", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return fib(n-1) + fib(n-2)\nPython2.7 will also get the memoization right for this.\n\nWhat's the memoization supposed to do in this case? It's not like you can be doing anything in the loop other than calling fib and returning a value.\n\nThe point is that if you compute fib(1), then the next time you call fib, Python will remember it, and compute fib(n-1) and fib(n-2) only if n == 1. This speeds up the calculation of fib(10) considerably.\n\nOops, I read it as \"memoization is right for this\", as in \"The above example is a good use of memoization\".\n\nI think this is a bit like the \"sort() is slow\" meme; it's not really slow, it's just that its interface is not very flexible. You have to say how to sort, which means you have to say what to compare things by, which means you have to define a type system. The solution is to use a library that abstracts the comparison function.\n\nSort() is actually not a great example in this regard, because the interface for", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    if n <= 1:\n       return 1\n    n = 0\n    while n < 2:\n       n = fib(n - 1) + fib(n - 2)\n       return n\n\n> def fib(n: int):\n>    \"\"\"Return n-th Fibonacci number.\n>    >>> fib(10)\n>    55\n>    >>> fib(1)\n>    1\n>    >>> fib(8)\n>    21\n>    \"\"\"\n>    if n <= 1:\n>       return 1\n>    n = 0\n>    while n < 2:\n>       n = fib(n - 1) + fib(n - 2)\n>       return n\n>\nSo you are going to give this thing the 10 in this case?\n\nThis is the first time I've seen the language name written as \"Python\".\n\nIt's a style", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(100)\n    >>> fib(1000000000)\n    1.399999999999999624\n    1.9999999999999999896\n    \"\"\"\n    result = 0\n    while n > 1:\n       result = result + fib(n-1)\n    print result\nPython's standard library has this one covered\nfor n in range(1, 101):", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def __init__(self, n):\n        self.n = n\n        def fib(self):\n        return self.n\n        self.fib = fib\n\n    def fibonacci(n):\n         return n if n<2\n         return fib(n-1) + fib(n-2)\n\n>>> fibonacci(11)\n    55\n\n>>> fibonacci(1)\n    1\n\n>>> fibonacci(2)\n    3\n\n>>> fibonacci(3)\n    8\n\n>>> fibonacci(4)\n    21\n\n>>> fibonacci(5)\n    55\n\n>>> fibonacci(6)\n    89\n\n>>> fibonacci(7)\n    144\n\n>>> fibonacci(8)\n    233\n\n>>> fibonacci(9)\n    809", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    n = n+1\n    while n < 2:\n       n = n-1\n       return n\n\nI hate to be the nag, but I think you should change it to the form:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\n    def fib2(n: int, seed: int):\n    \"\"\"Return n-th Fibonacci number, starting from seed.\n    >>> fib2(0, 3)\n    5\n    >>> fib2(1, 3)\n    13\n    >>> fib2(6, 3)\n    89\n    \"\"\"\n\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n\n    def fib2(n: int, seed: int, step: int):\n    \"\"\"Return n-th Fibonacci number, starting from seed, stepping by step.\n    >>> fib2(0, 3, 3)\n    55\n    >>> fib2(1, 3, 3, 4)\n    55\n    >>> fib2(6, 3,", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\n    return fib(n-1) + fib(n-2)\n\nThis is a function that returns the n-th Fibonacci number.  It's very simple.\n\nThis is another function that returns the n-th Fibonacci number.  It's very simple.", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\n    return [0, 1]\nIn python,\n    def fib(n):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(5)\n    [0, 1, 1, 2, 3, 5]\n    >>> fib(3)\n    [0, 1, 2, 3, 5]\n    >>> fib(2)\n    [1, 1, 2, 3, 5]\n    \"\"\"\n    return n*fib(n-1) + fib(n-2)\n\nI like how the Python version uses n-1 and n-2 as loop counters. This is the correct way to implement this algorithm.\n\nCan someone explain why the OP's version is considered incorrect?\n\nIt's not. It's the right way to do it.\n\nOkay, I just wanted to make sure I wasn't overlooking something.\n\nFibonacci uses an iterative algorithm. So, you iterate through the range [0, 1). At each step, you add the last two values of the sequence (because we're dealing with", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    print(fib(10))\n        print(fib(1))\n        print(fib(8))\n        print(fib(11))\n\nfib is an example of a recursive function that needs stack space.  The recursive part is the \"if\" statement.  Consider what would happen if the following were changed:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return 0 if n <= 1\n    else:\n    return fib(n - 1) + fib(n - 2)\n\nIt might not be obvious but this Fibonacci function is wrong.\n\nWhy? The article doesn't explain why it's wrong.\n\nThe first test case is that fib(1) should return 1, not 0.\n\nI was hoping that it was something deeper than a mere function definition error.\n\nI was going to post about this also. This is interesting from a programming language perspective:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib2(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib2(8)\n    21\n    >>> fib2(1)\n    1\n    >>> fib2(2)\n    1\n    >>> fib2(3)\n    0\n    \"\"\"\n    def fib3(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib3(10)\n    89\n    >>> fib3(1)\n    1\n    >>> fib3(8)\n    55\n    \"\"\"\n    def fib4(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib4(8)\n    55\n    >>> fib4(1)\n    1\n    >>> fib4(2)\n    1\n    >>> fib4(3)\n    0", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return fib(n-1)+fib(n-2)\nThe title of the article has the correct answer, it's just that the example has the wrong answer.\n\nThe article author forgot to add that in Java you can achieve the same effect as in C by using the instance method 'int fib(int n)' instead of 'int fib(int)' or 'int fib(int n)'.\n\nIt's a very good point that I missed.\n\nThe other major difference is that the C version doesn't use function calls to compute the result. The C version computes the result directly. The Java version uses the method invocation syntax to look up the correct method.\n\nFunction calls are very rarely free of overhead. They may look more or less the same as local variables and functions that are called using the same register set are likely to be pretty similar.\nThe difference is that with the compiler trickery, Java can decide at run time whether to inline the call or not.\n\nAnd with the right compiler settings you can do the same thing in C. The only difference is that if you write it with no optimization in mind (i.e. you don't have to target a specific CPU)", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return n if n == 0 else n if n <= 1 else fib(n-1) + fib(n-2)\nThis is great! The only thing I would change is to use n == 0, n < 1 instead of n == 0, n < 1.\n\nWhy? This is the most efficient way of doing it.\n\nCould you explain why?\n\nThe most efficient way of doing it is to do a bit of math. What's the probability that n is the first element in the sequence? If it's 1/3, and you take the number, you are almost guaranteed to have done the right thing.\nIf n is not the first element, you want to add 1 to it and check again. What's the probability that it's the second element? If it's 2/3, and you take the number, you are almost guaranteed to have done the right thing.\nIf n is not the second element, you want to add 1 to it and check again. What's the probability that it's the third element? If it's 1/3, and you take the number, you are almost guaranteed to have done the right thing.\nIf n is not the third element,", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def next(n: int):\n    \"\"\"Return the next Fibonacci number.\n    >>> next(1)\n    1\n    >>> next(8)\n    21\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return the Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n\nThis seems to show two things:\n\n1. Python has no way of making code look like a data structure (i.e. with brackets, braces, semicolons, etc.).\n2. Python doesn't have a way of expressing a return value.\n3. Python doesn't have a way of doing anything that requires more than one statement.\n\nDo you agree with me that this example is not valid Python? If so, then please explain what is valid Python.\n\nI can't speak for the original poster, but I'd say that you are right and that example is not valid Python.", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return the n-th Fibonacci number.\n    >>> fib(1)\n    1\n    >>> fib(2)\n    1\n    >>> fib(1)\n    0\n    >>> fib(1)\n    1\n    \"\"\"\n    if n < 1:\n       return 1\n    else:\n       return fib(n-1) + fib(n-2)\n    >>> fib(100)\n    55\n\nGreat that it's so short, but there is something very wrong with this. I don't know why.\n\nFibonacci sequences have very simple recurrence relations. That's what the code you pasted is computing.\n\nIt's the \"n < 1\" part that confuses me.\n\nIf n is 0 or negative, then the function will return 1.\n\nGotcha. Thanks.\n\nThe Lisp version of the same algorithm (which also uses recursion) is a lot more compact.", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def nfib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> nfib(10)\n    55\n    >>> nfib(1)\n    1\n    >>> nfib(8)\n    21\n    \"\"\"\n    def f(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> f(10)\n    55\n    >>> f(1)\n    1\n    >>> f(8)\n    21\n    \"\"\"\n    def fib2(n: int, f: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib2(10, 1)\n    55\n    >>> fib2(1, 8)\n    21\n    \"\"\"\n    def fib3(n: int, f: int, g: int):\n    \"\"\"Return n-th Fibonacci number.", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return (n - 1) * (n - 2)\nAm I missing something or is this a terrible implementation of the fibonacci sequence?\nYou're missing something. The recursive implementation is:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    return n if n < 2\n    else:\n    return fib(n-1) + fib(n-2)\nHere is how to rewrite this using 'camelCase':", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\n    def fib_n: int = fib(n - 1) + fib(n - 2)\n\n    def fib_acc(n: int):\n    \"\"\"Return the n-th Fibonacci number in the range [0,1].\n    >>> fib_acc(10)\n    55\n    >>> fib_acc(1)\n    1\n    >>> fib_acc(8)\n    21\n    \"\"\"\n\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n\n    def fib_n: int = fib(n - 1) + fib(n - 2)\n\n    def fib_acc(n: int):\n    \"\"\"Return the n-th Fibonacci number in the range [0,1].\n    >>> fib_acc(10)", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\nfibonacci.py, line 1", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    return n\nThis is a perfectly good function, but if you call it like this, it will always fail:\n>>> fib(10)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"/Users/tom/Dropbox/GitHub/01-CompSci-2012/programming/nopython/fib.py\", line 5, in main\nreturn fib(1)\nNameError: global name 'fib' is not defined\nThis is because the return statement is _in the wrong place_. You want to do something like this:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def _get_first_numbers(n):\n    \"\"\"Return [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> first_numbers(10)\n    [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> first_numbers(1)\n    [1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n    >>> first_numbers(2)\n    [1, 2, 3, 5, 8, 13, 21, 34, 55]\n    \"\"\"\n    def _get_last_numbers(n):\n    \"\"\"Return [55, 21, 5, 8, 3, 2]\n    >>> last_numbers(10)\n    [55, 21, 5, 8, 3, 2]\n    >>> last_numbers(1)\n    [55, 21, 5, 8, 3, 2]\n    >>> last_n", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n       def fib(n):\n        if n == 0:\n           return 0\n        else:\n           return fib(n - 1) + fib(n - 2)\n         n\n       return fib(n)\nI've never understood this style of implementation. It's not really idiomatic.\n\nCould you explain why?\n\nFibonacci sequence is a common example used in algorithms classes to demonstrate recursion. It's easy to implement in a recursive way, and it's very clear what it does.\nFor example, this implementation (from the first few results I got when googling for 'Fibonacci recursion') is very clear:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    if n >= 2:\n        return fib(n-1) + fib(n-2)\n    else:\n        return fib(n-2) + fib(n-1)\nIs this the standard way of implementing fibonacci numbers in python?  I thought there was a way to calculate the n^2+1 terms as well.</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    n = 0\n    while n <= 1:\n        n = n+1\n    return n\n\nMore interesting:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\n    def fib2(n: int):\n    \"\"\"Return n-th Fibonacci number, with a 2-argument version of the function.\n    >>> fib2(10)\n    55\n    >>> fib2(1)\n    1\n    >>> fib2(8)\n    21\n    \"\"\"\n\n    def fib3(n: int):\n    \"\"\"Return n-th Fibonacci number, with a 3-argument version of the function.\n    >>> fib3(10)\n    55\n    >>> fib3(1)\n    1\n    >>> fib3(8)\n    21\n    \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n       return fib(n-1) + fib(n-2)", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def f1(x: int):\n    \"\"\"Return first Fibonacci number.\n    >>> f1(10)\n    5\n    >>> f1(1)\n    1\n    >>> f1(5)\n    8\n    \"\"\"\n    def f2(x: int):\n    \"\"\"Return second Fibonacci number.\n    >>> f2(10)\n    13\n    >>> f2(1)\n    5\n    \"\"\"\n    def f3(x: int):\n    \"\"\"Return third Fibonacci number.\n    >>> f3(10)\n    21\n    >>> f3(1)\n    8\n    \"\"\"\n    def f4(x: int):\n    \"\"\"Return fourth Fibonacci number.\n    >>> f4(10)\n    55\n    >>> f4(1)\n    13\n    \"\"\"\n    def", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib():\n    \"\"\"Return Fibonacci numbers.\n    >>> fib()\n    >>> fib()\n    >>> fib()\n    >>> fib()\n    1\n    1\n    3\n    8\n    21\n    \"\"\"\n    x = 0\n    while x < n:\n        y = 1\n        a, b = x, y\n        if a > b:\n           b = a\n           a = b\n           y = b\n           x = a\n           x = b\n    return a, b\nThe code to calculate fib(10) is the same as the Fibonacci function.\n\nMight be worth mentioning that the 'x' variable in fib(n) will be an iterator over the Fibonacci numbers", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return [1, 1]\nLooks like they are writing the code in a language other than Python.\n\nI was wondering why their list comprehension wasn't working...</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\n    def fib_with_digits(n: int):\n    \"\"\"Return n-th Fibonacci number with digits.\n    >>> fib_with_digits(10)\n    55\n    >>> fib_with_digits(1)\n    1\n    >>> fib_with_digits(8)\n    21\n    \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return 1 if n < 2 else fib(n-1) + fib(n-2)\nThere's a little extra code for handling 0 and negative numbers.  It's not too bad, and should be easy to refactor to handle negative and 0 separately.\n\nI love the xkcd comic where the guy writes an algorithm to compute the fibonacci numbers.\n\nIt took me a while to understand what he was doing. I had to read the comments to figure it out.\n\nI could've sworn I saw this same algorithm in the comments for that comic.\n\nI actually used this on a phone app for learning to count in Java. This is a nice implementation and it's very fast (as far as recursive calls go).\n\nQuick hint: Use a stack instead of a heap to store the previous values and you'll save a whole lot of memory.\n\nI'm a bit confused. What is the difference between a stack and a heap in the context of this algorithm?\n\nThe stack is the container in which the current value is stored while the heap is a container in which a number of values are stored.\nIf you store the next value on the stack, and you can store", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return fib(n-1) + fib(n-2)\nIn this case it's not as efficient to just return a function, since a function call is slightly slower than an arithmetic operation. The compiler can optimize the function call into a jump table, but it can't optimize the arithmetic.\n\nPython is a scripting language, performance in this case isn't exactly a priority.\nAlso, I don't think the compiler can optimise away arithmetic code without something more than just an if statement.\n\nRight, I was mostly just trying to point out that while Python's language structure isn't C-like, the structure of the code is fairly similar to that of other procedural languages, and so code optimizers can do some interesting things with it.\n\nIf you do a good job of using decorators you can make your python code look like this:\nimport math", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n):\n       return n-1 if n < 2\n       return fib(n-1) + fib(n-2)\n    return fib\nis this correct?\n\n\"fib(n: int)\" is wrong: it should be \"fib(n: int, denom=2)\".\n\"fib(1)\" is also wrong, because it always returns the same thing, but that's easy to fix.\n\nI think the first one is only wrong if your goal is to actually compute fib(n). If you're just trying to demonstrate that you've got the syntax right, then this is a fine way to do it.\n\nThere is no universal way to demonstrate that you've got the syntax right. You could write a program that tests the user-defined syntax, but that would probably be slower than just using the built-in syntax. You could require that users provide some test case, but that would be a waste of everyone's time if there's a better way to test it.\nSo, you could start with the user-defined syntax, but make it clear that it's not correct.", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    n = 0\n    n += 1\n    if n == 2:\n       return n\n    return fib(n-1) + fib(n-2)", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return 1 + fib(n-1)\n\nDoes this really count as a \"hack\"? It's one line of code that does what it's supposed to. If I saw a Fibonacci implementation like this in production code, I would be horrified.</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    if n < 2:\n       return 0\n    else:\n       return fib(n - 1) + fib(n - 2)\n    I think I've seen this exact code in at least 4 different places. It's the first thing I've seen here that I recognize.\n\nI know it by heart, my first python script was a fibonacci generator.\nIt was really a pain to write something like that, I was learning the language and it took me some time to get it working, and I was very happy when it was finished :)\n\nThe _first_ thing I ever wrote in python was a fibonacci generator.\nNow I'm working on a fibonacci generator.\n\nI can't believe it took me this long to find it:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return fib(n-2) + fib(n-1)\n    + fib(n-2) + fib(n-1)\nThis is exactly how I would write it. It's simple and efficient.\nI would write a generic version of this that used a function call instead of an assignment. Then you could use it for any n, not just integers.\nMaybe it's because I'm a computer scientist, but I like to think of the program as a math function.\n\nI would probably write it like this:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(1)\n    1\n    >>> fib(2)\n    3\n    >>> fib(3)\n    5\n    >>> fib(5)\n    12\n    >>> fib(6)\n    21\n    \"\"\"\n    if n == 0:\n        return 1\n    return n * fib(n-1) + fib(n-2)\n  I was taught to do it like this:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    \"\"\"\n    return 0 if n > 0 else 1\nYou are *not* required to post code that breaks the rules of the subreddit.</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return fib(n)", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return fib(n - 1) + fib(n - 2)\nI'm not sure if you're looking for feedback, but this is quite wrong. The first problem with this is that the return value is not what the code is supposed to return, but rather it's the type of the return value. This function doesn't return any value of type int, it returns an object of type fib that is an instance of the fibonacci class. This is important because in python, unlike other languages, the return value of the function is not the same as the return value of a function. This is because the return value of a function is the result of evaluating the function, and it is common for the result of the evaluation of the function to not be of the same type as the return value.\nIf you want to use this function as-is, you need to make the function return the object of type fib, or you can make it return something else, but you will have to make sure that it returns something that you want to be the result of the function. The point of the previous paragraph is that you cannot just say return fib(n - 1) + fib(n - 2) and then call the function and expect", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    def fib_n(n: int,\n    start: int,\n    cnt: int,\n    prev_cnt: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib_n(10,1,1)\n    55\n    >>> fib_n(1,8,1)\n    21\n    \"\"\"\n    def fib_n(n: int,\n    start: int,\n    cnt: int,\n    prev_cnt: int,\n    is_prime: bool):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib_n(10,1,1,true)", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def a(i: int):\n    \"\"\"Return next Fibonacci number in the sequence.\n    >>> a(1)\n    1\n    >>> a(8)\n    21\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(1)\n    1\n    >>> fib(n)\n    n-1\n    \"\"\"\n    return a(n-1) + a(n-2)\n    def fib2(n: int):\n    \"\"\"Return n-th Fibonacci number to the 2nd power.\n    >>> fib2(8)\n    64\n    >>> fib2(3)\n    27\n    \"\"\"\n    return fib(n-2) + fib(n-1)\n\nNote that a(1) is 1, and a(8) is 21.\n\nPython 2.7+", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def __init__(self):\n    self.n = 0\n    self.i = 1\n    self.j = 1\n    self.result = []\n\n    def nthFib(self, n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    self.i = self.n % 2\n\n    self.j = self.n % 2\n\n    if self.j == 1:\n        self.result.append(self.n)\n        return self.result\n\n    return self.result[-1]\n\nThis Python solution is a bit more complicated, but can actually be simplified further with the following trick:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\n    return fib(n - 1) + fib(n - 2)\n\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(11)\n    89\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n\n    return fib(n - 2) + fib(n - 1)\nThanks, I didn't know that.</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\n    def fib(n: int) -> int:\n    \"\"\"Return the n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n\n    def fib(n: int) -> int:\n    \"\"\"Return the n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n\n    def fib(n: int) -> int:\n    \"\"\"Return the n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n\n    def fib(n: int) -> int:\n    \"\"\"Return the n-th Fibonacci number", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(5)\n    25\n    >>> fib(2)\n    1\n    >>> fib(8)\n    13\n    \"\"\"\n    return n + fib(n - 1) + fib(n - 2)\nI can't tell if you're joking or not.</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def f1():\n    \"\"\"Fibonacci sequence of length 1.\n    >>> f1()\n    1\n    \"\"\"\n    def nthfib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> nthfib(9)\n    44\n    >>> nthfib(1)\n    1\n    >>> nthfib(2)\n    2\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Fibonacci sequence of length n.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(2)\n    3\n    >>> fib(3)\n    8\n    \"\"\"\n    def nthfib(n: int):\n    \"\"\"Fibonacci sequence of length n.\n    >>> nthfib(10)\n    55", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def nthFib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> nthFib(10)\n    55\n    >>> nthFib(1)\n    1\n    >>> nthFib(8)\n    21\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    def nthFib(n: int):\n    \"\"\"Return n-th Fibonacci number.", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    if n == 0:\n       return 0\n    return 1 + fib(n-1) + fib(n-2)\nThis isn't correct. It always returns the first Fibonacci number when n == 0.\n\nYou are right, I updated the code and added this exception.\n\nThe title should be \"A Python function to generate Fibonacci numbers using recursion\".\n\nThanks, I have changed the title.\n\nIn an article about Python recursion and the fibonacci sequence, the following code is presented:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return fib(n - 1) + fib(n - 2)\nI'm not sure I understand your question.  What is the problem with this?  It looks like it is the same algorithm as your recursive one.</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    if n == 0 or n == 1:\n        return 1\n    else:\n        return fib(n-1)+fib(n-2)\nAh, I see. I did not realize there is an implicit \"return\" at the end. Thanks!</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fibonacci_sequence(n):\n    \"\"\"Return fibonacci sequence of n.\n    >>> fibonacci_sequence(10)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21]\n    >>> fibonacci_sequence(1)\n    [0, 1]\n    >>> fibonacci_sequence(8)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21]\n    \"\"\"\n    def fib_n(n):\n    \"\"\"Return fibonacci of n.\n    >>> fib_n(10)\n    55\n    >>> fib_n(1)\n    1\n    >>> fib_n(8)\n    21\n    \"\"\"\n    return fibonacci_sequence(n)\n\nSee also\n nth_fibonacci()\n\nReferences\n\nExternal links\n Dive into Python: Fibonacci Numbers</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return 1+fib(n-1)\nIt's such a short code that it would be nice to just copy and paste the output instead of wasting time doing it yourself.\nIt doesn't look like the author did that though, instead they used mypy to type check the code.\n\nThe type checker is just a tool for making it easier to see a problem in your program. You're right that it's simple enough to copy and paste the output, but the tool gives you that output with a single keystroke.\n\nI've written a few articles on static typing for Python which show how you can use mypy to enforce more advanced type rules and catch more problems in your program, in much the same way as other static type checkers:\n* A More Advanced Example of Type Checking in Python:\n* Type Checking Helpers for Python:\n* Type Checking Python Functions Using MyPy:\n* The Types of Python:\n* Pythonic Types:\n* Type Checking Python in the Browser:\n\nI have always found the type checking in Python to be helpful, but never something that I felt needed to be forced.\nThe one type checking feature that I do miss is better support for Generics", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    return fib(n - 1) + fib(n - 2)\n    >>> fib(2)\n    7\n\nI'm not sure why this is news. I remember reading about this kind of thing in high school - and it's nothing particularly new, either - the Fibonacci sequence has been studied for a very long time.\n\nI thought that the problem was well known and well studied. What is interesting about this solution is that it's built on top of the sum of the reciprocals of the digits of pi. It's not just a brute force solution.\n\nI think the better way of stating this would be that the solution is based on the sum of the reciprocals of the digits of pi. It's not really that surprising to find a sequence of numbers that are a sum of the reciprocals of the digits of pi (after", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def __getitem__(self, n):\n       return self[n]\n    def __len__(self):\n       return len(self)\n    def __call__(self, *args):\n       return self.__getitem__(0) + self.__getitem__(1)\n    def fib(n):\n       return fib(n-1) + fib(n-2)", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(2)\n    1\n    >>> fib(3)\n    3\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(4)\n    8\n    >>> fib(3)\n    5\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(5)\n    13\n    >>> fib(2)\n    1\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(6)\n    21\n    >>> fib(4)\n    8\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    if n<1 or n>=100:\n       return n\n    else:\n       return fib(n-1)+fib(n-2)\nI've always wondered how other people got around this.\n\nI've seen a number of different answers to this. I like the list based approach:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    print(n)\n    return 0\nI think this code snippet is so nice I'll just copy it into my clipboard.\n\nThat's not nice, that's cheating.\n\nIt's nice because it's short and readable.\n\nActually, the code is so short and simple that it's almost pointless to call it code. What you have there is an expression.\n\nNice is not a synonym of \"useful\".\n\nThis is not a complete solution, but it demonstrates the technique:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def nth_fib(n):\n    \"\"\"Return Fibonacci number which is n-th power of 2.\n    >>> nth_fib(2)\n    13\n    >>> nth_fib(10)\n    55\n    \"\"\"\n\nIn the spirit of the original article, I think there is a better way to write this, using multiple inheritance:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    if n < 2:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)\nThat's the most terrible definition of fib I have ever seen.\nYou're missing the base case.\n\nThat's because I didn't define it.\n\nThe parent comment did, which is what he was referring to.\n\nHe was pointing out that the fib function I copied into this comment didn't actually work.\n\nAh, I misunderstood.\n\nThis is a duplicate of .\n\nI think the most important part of this is the fact that both the Fibonacci sequence and the golden ratio follow the rule of reciprocity.\n\nI hate to be that guy, but there is nothing special about this. It is a simple product of two sequences.\n\nYou mean \"fibonacci sequence\" and \"golden ratio\".\n\nIt's interesting to me that the sequences don't start from zero and one. That they both start at 1 and 1 makes them in some sense more interesting.\n\n_fibonacci sequence_\nThe Fibonacci sequence doesn't", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def recurse(n: int):\n    \"\"\"Return first n-th Fibonacci number.\n    >>> recurse(2)\n    5\n    >>> recurse(4)\n    13\n    >>> recurse(5)\n    21\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(4)\n    55\n    >>> fib(3)\n    8\n    >>> fib(2)\n    5\n    >>> fib(0)\n    1\n    \"\"\"\n    if n == 0:\n       return 0\n    else:\n       return fib(n - 2) + fib(n - 1)\n    >>> fib(5)\n    55\n    >>> fib(3)\n    8\n    >>> fib(2)\n    5\n    >>> fib", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    return 1 if n < 2 else fib(n - 2) + fib(n - 1)\nThat's not pythonic! You're just importing a function and calling it.\nSee?", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib_def(f: float):\n    \"\"\"Print a concise description of Fibonacci numbers for a given precision.\"\"\"\n    \"\"\"For n=1 to n:\n        f(n-1)+f(n-2)\n        + f(n-1) + f(n-2)\n                = 0", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return 1\nNote that in Python, you can take advantage of multiple return values.\n\nThe fib function in the article does return multiple values; it returns a tuple containing the two n-th numbers in the sequence, and the number of steps to get to the n-th number.\n\nThat's what I thought too, but it only returns a tuple if n == 2. It should probably return 2, 3, 5, 8, 13, 21.\n\nOh, you're right, I didn't realize. I guess it's because fib(1) is in fact 1. It would be a pretty easy fix though.\n\nNot sure why the author is using the iterable keyword instead of the builtin iter() function.\n\nI believe iterable is part of the standard library, whereas iter() is part of the language and therefore in many places, not imported. I prefer using iter() as well.\n\nIterable is just a special case of iter().\n\nAnd both are in the standard library, but not all libraries follow the Python standard library.</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 0:\n        return 1\n    return fib(n-1)+fib(n-2)\nWTF?\n\nAnd it's python. Not even a real programming language.\n\nReal programming languages are general purpose languages that allow you to develop applications. Python is one of the top 5 programming languages in the world, and I don't think it will lose its popularity any time soon.\n\n_Real programming languages are general purpose languages that allow you to develop applications_\nI agree with the first sentence, and disagree with the second. Real languages are those that can be used to express new ideas. That does not mean that they must be general purpose or have applications in mind.\n\nThis is pretty cool. However, is it really necessary to call the function fib? Or is it more a proof of", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def __init__(self, n: int):\n    self.n = n\n    def fib(self):\n    if n < 2:\n        return self.n\n    return self.n - self.n-1\n    def sum(self):\n    if n < 2:\n        return self.n\n    return self.n + self.n-1\n    def fib(self):\n    if n < 2:\n        return sum(self)\n    return sum(self) - sum(self)\n    def sum(self):\n    if n < 2:\n        return fib(self)\n    return fib(self) - fib(self)\nThe problem is that this is only O(log n), whereas the \"standard\" fibonacci implementation (in Python) is O(n). That is, this is much slower than the naive approach.\n\nIt's an illustration of the difference between recursive", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(12)\n    66\n    >>> fib(13)\n    89\n    >>> fib(14)\n    144\n    \"\"\"\n    if n < 2:\n        return 1\n    return fib(n-1) + fib(n-2)\n    if __name__ == '__main__':\n        print fib(50)\n        print fib(49)\n        print fib(48)\n        print fib(47)\n        print fib(46)\n        print fib(45)\n        print fib(44)\n        print fib(43)\n        print fib(42)\n        print fib(41)", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    n = 1\n    if n < 2:\n        return n\n    else:\n        return fib(n - 1) + fib(n - 2)", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    a = 0\n    while n <= 2:\n        a, b = a, a+b\n        return a\nThis is fine. But I can't help but feel it's only so complicated to appear to be a better programmer.\nIf you're writing this sort of utility function to be used in some larger project, why not just make it one line?", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(1)\n    1\n    >>> fib(2)\n    1\n    >>> fib(3)\n    2\n    >>> fib(4)\n    3\n    >>> fib(5)\n    5\n    >>> fib(6)\n    8\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return fib(n - 1) + fib(n - 2)\n        if n == 1:\n           return 1\n          else:\n            return fib(n - 2) + fib(n - 1)\n         if n == 0:\n            return 1\n\nThis", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib2(n: int):\n    \"\"\"Return fib(n)+fib(n-2)+fib(n-1)\n    >>> fib2(3)\n    18\n    >>> fib2(1)\n    2\n    >>> fib2(9)\n    80\n    \"\"\"\n    def fib3(n: int):\n    \"\"\"Return fib(n)+fib(n-3)+fib(n-2)\n    >>> fib3(2)\n    16\n    >>> fib3(3)\n    20\n    >>> fib3(10)\n    100\n    \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    return 1\n    return fib(n-1) + fib(n-2)", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\n    return fibonacci(n-1) + fibonacci(n-2)\n\nWhy is this considered \"the right way\"?\n\nIt's a recursive function, and thus, doesn't need to make a function call for each iteration. I'm not sure why, but this makes it faster for some reason.\nI think it's because the calls are further down the call stack.\n\nI don't understand your last sentence. What does being further down the call stack have to do with it?\n\nIn Python, functions are first looked up by name. If the function isn't found, Python will look for it in the module (if you're importing it) and if that doesn't work, it will look for it in the import module's namespace, and so on, until it finds the function.\nWhen you have two functions in your own module, function A calls function B and function B calls function A, they're both on the same call stack.\nHowever, in this case, function A is being called by the module, which means it's further down the call stack than function B, which is being called by function A.\n\nAhh, I see what you mean now. Thanks", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib_add(cur_n: int, n: int):\n    \"\"\"Return sum of fibonacci numbers.\n    >>> fib_add(10, 1)\n    12\n    >>> fib_add(8, 2)\n    16\n    \"\"\"\n    def fib_sub(cur_n: int, n: int):\n    \"\"\"Return difference of fibonacci numbers.\n    >>> fib_sub(8, 1)\n    3\n    >>> fib_sub(8, 2)\n    11\n    \"\"\"\n    def fib_mod(cur_n: int, n: int):\n    \"\"\"Return remainder of fibonacci numbers.\n    >>> fib_mod(8, 1)\n    3\n    >>> fib_mod(8, 2)\n    11\n    \"\"\"\n    def fib_div(cur_n: int, n: int):\n    \"\"\"Return divisor of fibonacci numbers.", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n        return fib(n - 1) + fib(n - 2)\nWhy is this the n-th Fibonacci number?\nThe naive way to think about this is to say that it is the\nn-th Fibonacci number, in the sense that it is the nth\nFibonacci number to which you've added 1.\nThe more mathematical answer is that the Fibonacci sequence", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib2(n: int):\n    \"\"\"Return n-th Fibonacci number, where n is the sum of the previous two numbers\n    >>> fib2(10)\n    55\n    >>> fib2(1)\n    8\n    >>> fib2(8)\n    21\n    \"\"\"\n\nHow is that a hack?\n\nIt's just a way of showing that the Python interpreter uses an interpreter written in Python, and that all sorts of nifty things are possible. It's a joke.</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    #include <stdio.h>\n    #include <stdlib.h>\n    #include <string.h>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    a, b = 0, 1\n    while a < n:\n        b = a + b\n        a = b\n    return b\nIf you are looking for an excuse to understand and use generators, this is it. If you get stuck, there are some good resources on stackoverflow that discuss how to use generators with python.\n\nI think that's an important part of learning how to program: being able to translate things you read/hear to simple code.\n\nYeah, but then again it's also important to understand when to use other people's code.\n\nI've got a lot of Python experience, but I'm still not sure exactly how to read a Fibonacci function.\n\nPython 2:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    return [1,1]\nI laughed, thanks.</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib_to_n(n: int):\n    \"\"\"Return n-th Fibonacci number.\"\"\"\n    if n == 0:\n        return 1\n    else:\n        return fib(n - 1) + fib(n - 2)\n    n", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def main(args: Array[String])( implicit ev: IOException):\n    \"\"\"Main entry point.\n    >>> main()\n         <interactive>:10: UnboundLocalError: local variable 'fib' referenced before assignment\n          at fib.main(fib.__module__.__name__)", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(n+1)\n    >>> fib(n+3)\n    >>> fib(n+7)\n    >>> fib(n+11)\n    >>> fib(n+13)\n    >>> fib(n+15)\n    >>> fib(n+17)\n    >>> fib(n+19)\n    >>> fib(n+23)\n    >>> fib(n+25)\n    >>> fib(n+29)\n    >>> fib(n+31)\n    >>> fib(n+33)\n    >>> fib(n+35)\n    >>> fib(n+37)\n    >>> fib(n+39)\n    >>> fib(n+41)\n    >>> fib(n+43)\n    >>> fib(n+45)\n    >>> fib(n+47)\n    >>> fib(n+49)", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def __init__(self):\n         self.fibs = [0]*2\n    self.fib = 1\n    self.n = 0\n\n    def __call__(self, n):\n         if n == self.fib:\n             return n\n             return self.fibs[n]\n             return -Inf\n             self.n = n\n             self.fib = self.fib + 1\n\n    def fib(n):\n         return fib(n - 1) + fib(n - 2)\n         if n == 1:\n             return 1\n\nSome interesting observations:\n\n1) The function is O(1) in the number", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def __init__(self, n):\n         self.n = n\n         self.sum = 0\n         self.index = 0\n    def recurse(self):\n         self.n += 1\n         if self.n == 1:\n             self.index = 1\n             self.sum = sum + self.index\n            return self.index\n    return recurse\nLooks good, but it's missing a few extra features.  First, when you run it, it doesn't terminate.  Second, you don't have any input checking at all.  Third, you're not doing anything to check the validity of the input (for example, you don't have a check to see if the user passes in a negative number).\n\nFibonacci is a big problem. I'm not sure it's a good one to start with", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n> def fib(n: int):\n>    \"\"\"Return n-th Fibonacci number.\n>    >>> fib(1)\n>    1\n>    >>> fib(8)\n>    21\n>    \"\"\"\n>>> def fib(n: int):\n>>>    \"\"\"Return n-th Fibonacci number.\n>>>    >>> fib(1)\n>>>    1\n>>>    >>> fib(8)\n>>>    21\n>>>    \"\"\"\n>>>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\nIn Haskell, I believe that would be:\n\nfib :: Int -> Int\nfib n = n `fib` 1\n\n(I'm sure someone will correct me if I'm wrong.)\n\nA more idiomatic way to do it in Haskell would be:\n\nfibs = map (fib 1) [1..]\n\nYou can also use \"invert\" to avoid using \"fib\" as a function name, which is a monad:\n\nfibs = map invert [1..]\n\n(Note that \"invert\" is a function from (Int -> Int) -> [Int], not the other way around. The \"invert\" function is used as a monad here, but it's just a normal function, not a monad in itself.)\n\nIt's funny that he mentions the Fibonacci sequence, because the sequence is a great example of a recursive algorithm that you shouldn't optimize. The Fibonacci sequence is a classic example of a problem where an \"obvious\" recursive solution is extremely inefficient.\n\nI don't know much about Haskell, but I'm under the impression that the Fibonacci sequence is one of the very", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 1:\n       return 1\n    else:\n       return fib(n - 1) + fib(n - 2)\n    n - 1\n\nI like the use of comments for print statements.\n\nI like the use of the list comprehension for fibonacci.\n\nI actually didn't notice that until I read the comment, but that is pretty clever.\n\nYeah, you could even call it \"brilliant\" or \"genius\" or \"fantastic\" without much hyperbole.\n\nMy favorite: \n\nThis is the most concise and readable version I've seen.\n\nI use this version:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return n-1\n\nSimple, short and to the point.\n\na = 1\nwhile True:\n    a = a + 1\n    a = fib(a)\n\n(if you want to be really terse:\nwhile True:\n    a = 1\n    a = a + 1\n    a = fib(a)\n)\n\nI think this is a good candidate for the \"shorter is better\" argument.\n\nThe original version of this function (and it's pretty obvious what it's meant to do) in Perl:\nsub fib {\n\treturn 1 if $#_ > 1;\n\t$_[0] = 1;\n\twhile (1) {\n\t\t$_[0] = $_[1] if $#_ > 1;\n\t\t$_[0] = $_[1] + fib($_[1], $_[2]);\n\t\t}\n\treturn $_[0];\n}\nsay fib(10);\n\nI would add a few more linebreaks, so it's a bit more readable:\nsub fib {", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    n = 0\n    while n < n + 2:\n        n = fib(n - 1) + fib(n - 2)\n    return n\n\nThis is a bad example. It's not nearly the most idiomatic way to do the problem.\nThe function is recursive, but the recursion is hidden in the function body. The function body is one line (not counting the blank line after the statement). You can't call it a \"one-liner\".\nThe actual Fibonacci recursion:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\nThis is called an infinite recursive function.\n\nAs you can see, it is called the fib function but it returns a function\n(fib(n: int) -> int).\n\nCalling fib(n: int) with the value 10, it returns a function that calls fib(n-1) with n-1 and returns the result.\n\nCalling fib(n: int) with the value 1, it returns a function that calls fib(n-1) with n-1 and returns the result.\n\nCalling fib(n: int) with the value 8, it returns a function that calls fib(n-1) with n-1 and returns the result.\n\nSo far, the function has always returned a function, so it is an infinite recursive function.\n\nThe problem is that the function calls itself, and as you can see the function has no return value. This means it is stuck in an infinite loop, and it will run forever.\n\nSo, an infinite recursive function is a type of function that calls itself recursively.\n\nHere is another example:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int) -> int:\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    return fib(n - 1) + fib(n - 2)\nFibonacci sequence is a sequence of numbers where the following two formulas hold:\n0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...\n\nYou are not the only one who wrote a fib function in python:\n\nI'd rather use the array method:\n[i-1,i-2]\nThis assumes the last number is 1 and returns the fibonacci number i.e. 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 25", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(8)\n    21\n    >>> fib(8,1)\n    8\n    >>> fib(10,2)\n    55\n    \"\"\"\n    return (fib(n-1) + fib(n-2)) % 2\nFor some reason this makes me cringe. I'm not sure if it's the fact that fib(8) returns 21, or that fib(8,1) returns 8. The second one is the worst.\n\nIt's possible that I'm too old to understand the new way of doing things. I prefer my way because it is a direct translation from the mathematical definition, but the new way is shorter and more flexible.\n\n_This is what the __init__.py file looks like._", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    if n == 1:\n        return 1\n    return fib(n-1) + fib(n-2)\nI do that all the time when I want to test a function with numbers between 1 and 10.\n\nHah, this was the first thing I thought when I saw the post. Though I do it with a fixed n and only test a few values.\n\nI've always been partial to this one:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(0)\n    1\n    >>> fib(1)\n    1\n    >>> fib(n-1)\n    n\n    \"\"\"\n    if n > 1:\n       return n\n    else:\n       return fib(n-1) + fib(n-2)\n\nTo be honest I haven't worked with Python in several years, and I wasn't really familiar with Python 3 when it first came out, but I find the new syntax easier to read and understand. Am I alone in this, or am I missing something?\n\nI'm with you. I think the python 2.x syntax is kind of verbose, and I've always hated the = operator. I think python 3.x's syntax is pretty nice.\n\nWhy did they remove the tuple from the list? \n\nI don't know, but in Python 2, you can do the same thing using a list comprehension:\n>>> lst = [", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    >>> fib(3)\n    8\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(4)\n    13\n    >>> fib(6)\n    34\n    >>> fib(2)\n    1\n    >>> fib(5)\n    22\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(1)\n    1\n    >>> fib(5)\n    22\n    >>> fib(1)\n    1\n    >>> fib(2)\n    1\n    >>> fib(3)\n    8", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    n = int(input(\"Enter the Fibonacci number: \"))\n    while n > 1:\n       if n == 1:\n          return 1\n       else:\n          return n - 1\n    return 0\nThis function is really long. You can use a normal loop instead.\nfor n in fib(1,10):", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    n = 0\n    a = 1\n    while n <= 1:\n        a = fib(n-1) + fib(n-2)\n        n = n-1\n    return a\nEven though I'm a big Python fan, I will never understand why some people think this is good code. I've had to maintain some code written by very talented developers, that used this style. It's really hard to maintain and understand, even though they were very good at it.\n\nFully agree. I would use a function like this:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n        def fib_seq(n):\n          return n if n <= 2\n          return fib(n-2) + fib(n-1)\n          else:\n           return fib_seq(n-1) + fib_seq(n-2)\n           if __name__ == '__main__':\n             print(fib_seq(10))\n            print(fib_seq(1))\n            print(fib_seq(8))\n\nThe fibonacci sequence is defined to be [0,1,1,2,3,5,8,13,21,...]\nSo the program above is technically correct, and is just returning [2,3,5,8,13,21].\n\nIn fact, this is the most efficient way to compute this sequence.", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib2(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib2(10)\n    21\n    >>> fib2(2)\n    1\n    >>> fib2(5)\n    11\n    >>> fib2(10)\n    55\n    \"\"\"\n\nIf you're looking for a way to return multiple values, you could use a list comprehension.\n>>> fib2(1:10).items()\n[1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n\nFor a more concise (and easier to read) version of fib2(), try this:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n\nThere's no explanation why that is better than an explicit loop, but I guess it can be used for teaching purposes.\n\nI guess I'd prefer the original version with explicit loops. It's not like you'll ever come across an algorithm that you need to use _exactly_ the way it's in the official documentation.\n\nThere is also this Python version:", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n > 1:\n       return n-1\n    else:\n       return n\n    print \"The fibonacci sequence is %s\" % fib(n)\n\nThis is the F# version of the code. The anonymous function is syntactic sugar for an anonymous delegate. Notice how the lambda looks like an anonymous method but it has a body.\n\nAlso notice that this is a common language feature in the ML family of languages.\n\nlet fib n =\n    match n with\n                    | 0 -> 1\n                    | n - 1 -> fib(n - 1)\n\nThis is", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(1)\n    1\n    >>> fib(2)\n    2\n    >>> fib(3)\n    5\n    >>> fib(4)\n    8\n    \"\"\"\n    return fib(n-2) + fib(n-1)\n\nYou should use", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    if n is None:\n        return None\n    else:\n        return fib(n-1)+fib(n-2)", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    fib(10)\n      55\n      >>> fib(1)\n      1\n      >>> fib(8)\n      21\n\nC-style function definition syntax?\n\nPlease don't do this.\n\nIsn't this using the C-style function definition syntax?\n\nYes it is, and I would hate it if Python adopted it.\nI still can't believe Python's syntax for function definition is so different from C.\n\nPython's function definition syntax is so different from C because it's not C.\nIt's an easy mistake to make if you're new to the language, but it's easy to notice that the function is indented only once. The single-indentation rule is one of the defining characteristics of Python.\n\nI'm surprised they didn't use a little 'f' for function to make the point even more obvious.\n\nI would like to see the code of this in a language like ocaml, python, or ruby.\nThe C style function definition syntax is just wrong.\n\nI would like to see the code of this in a language like o", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    return 1\n> return 0  FTFY</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib2(n: int):\n    \"\"\"Return the n-th Fibonacci number.\n    >>> fib2(5)\n    25\n    >>> fib2(3)\n    8\n    \"\"\"\n    def fib3(n: int):\n    \"\"\"Return the n-th Fibonacci number.\n    >>> fib3(2)\n    22\n    \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fibs(n: int):\n    \"\"\"Return a list of the first n Fibonacci numbers.\"\"\"\n    return [n]*[n]\n    def fibonacci(x: int):\n    \"\"\"Return the first n Fibonacci numbers.\"\"\"\n    for i in fibs(0):\n        print i\n        if x == 0:\n            break\n    return\n    def fibonacci_inv(x: int):\n    \"\"\"Return the first n Fibonacci numbers.\"\"\"\n    for i in fibs(1):\n        print i\n        if x == 0:\n            break\n    return", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib():\n    \"\"\"Return the n-th Fibonacci number.\n    >>> fib(11)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    return 2\nWhen you read this code, you don't get the impression that the programmer is going to make a useful library.  I don't think that's a valid criticism.  Most of my code is not useful.  I have written very little code that I could imagine including in a library.  It's not the point.\n\nSo? It's not like you are an authority on whether the code is useful or not. It's really hard to write a good fibonacci function, and it's not like he's trying to write a public API for some language or framework.\nI think it's pretty cool.\n\nI think you missed the point.\n\nI'm sure there are some things we both missed.\n\nI am not sure what his point was to be honest. He just seemed to be complaining about something that was already well understood by the community.", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(5)\n    25\n    >>> fib(2)\n    1\n    >>> fib(3)\n    8\n    \"\"\"\n    if n == 0:\n       return n\n    else:\n       return fib(n - 1) + fib(n - 2)\n    def f(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> f(5)\n    25\n    >>> f(2)\n    1\n    >>> f(3)\n    8\n    \"\"\"\n    if n == 0:\n       return n\n    else:\n       return fib(n - 1) + fib(n - 2)\n    def fibs(n: int):\n    \"\"\"Return n-th Fib", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(1)\n    1\n    >>> fib(1)\n    1\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n == 0:\n       return 0\n    if n == 1:\n       return 1\n    if n == 2:\n       return fib(n - 1) + fib(n - 2)\n    if n == 3:\n       return fib(n - 1) + fib(n - 2) + fib(n - 3)\n    return fib(n - 2)", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib_right(n: int):\n    \"\"\"Return right-most Fibonacci number.\n    >>> fib_right(10)\n    22\n    >>> fib_right(1)\n    1\n    >>> fib_right(8)\n    13\n    \"\"\"\n    return n+1\nYou can pretty much think of the fibonacci sequence as an infinite sum where each term is just the sum of the previous two numbers.\n\nSo there are some obvious holes, e.g. n=3 and n=6 both return the same answer. Also I have no idea if fib(6) is even defined.\nIt might be a good idea to work this out by hand and then use it as a lookup table.\n\nI'm not sure if it's obvious, but you're right, I don't think the code will work. I guess this is what I get for not doing something simple like test cases.\nI'm not sure how to work this out by hand, though, I'll have to figure it out.\n\nIf you're trying to learn this stuff, I highly", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return (n%2)\nFor the record, it's n-th.\nCame here to say that, but it's fixed now :)</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    return if n <= 2: 1\n    return fib(n-1) + fib(n-2)\nI've never actually used it in practice, but for any of you who think this is \"too long\" or \"too verbose\", just remember that sometimes you're going to want to write short and concise functions that work. I would much rather write something that works, even if it takes longer to write, than something that is shorter but does not work the way I want it to.</s>", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def __init__(self):\n    self.n = 1\n    def add_numbers(self):\n    \"\"\"Add two consecutive Fibonacci numbers.\n    >>> a = fib(10)\n    >>> a + fib(11)\n    >>> a\n    21\n    >>>\n    >>> a = fib(11)\n    >>> a + fib(12)\n    >>> a\n    55\n    >>>\n    >>> fib(10) + fib(11)\n    >>> fib(20)\n    >>>\n    >>> fib(11) + fib(12)\n    >>> fib(34)\n    >>>\n    >>> fib(11) + fib(12) + fib(13)\n    >>> fib(55)\n    \"\"\"\n    return a + self.n", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n        return fib(n - 1) + fib(n - 2)\nThe return value of fib(n) is (n-1) + (n-2), so the return value of\nfib(n-1) is (n-2) and the return value of fib(n-2) is (n-1).  That's\nnot what is shown in the code.\n\nHi,\nI had a look at this (I've not worked on Ruby or Lisp before).\nIt looks like Ruby doesn't have a modulus operator, so the\nC-like line can't be written in Ruby.\n\nInteresting, I didn't think about Ruby's modulus operator.\n\nMinor nitpick, but it should be \"fibonacci\", not \"fibonacci number\". The latter sounds like it should be a variable.\n\nIt should be _either_, not _or_.\n\"A set of all fibonacci numbers\" is not a well-defined concept.\n\nThe code should also return the number of terms.\n\nWhy not just call it fibonacci_n?\n\nGood idea, but what if you", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib(n):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n < 2:\n       return 0\n    return fib(n-1) + fib(n-2)\n    def fib2(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib2(10)\n    55\n    >>> fib2(1)\n    1\n    >>> fib2(8)\n    21\n    \"\"\"\n    def fib2(n):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib2(10)\n    55\n    >>> fib2(1)\n    1\n    >>> fib2(8)\n    21\n    \"\"\"", "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\" \"\"\"\n    def fib_as_list(i: int):\n    \"\"\"Return list of i-th Fibonacci number.\n    >>> fib_as_list(1)\n    [1]\n    >>> fib_as_list(9)\n    [1, 1, 2, 3, 5, 8, 13, 21]\n    \"\"\"\n    def fib_as_set(i: int):\n    \"\"\"Return set of i-th Fibonacci number.\n    >>> fib_as_set(1)\n    Set(Set(1, 1, 1, 1, 2, 3, 5, 8, 13, 21))\n    \"\"\"\n    def fib_as_dict(i: int):\n    \"\"\"Return dictionary of i-th Fibonacci number.\n    >>> fib_as_dict(1)\n    {'1': 1, '1': 1}\n    \"\"\"\n    def fib_as_set_with_index(i: int, n: int):"]]