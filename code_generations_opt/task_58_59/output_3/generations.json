[["def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    for elem in l1:\n       if elem in l2:\n          return l1[elem]\n    return l2\n\nHere's a shorter version (some might not like it because it has a hardcoded list size):", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1 == l2:\n        return l1\n    else:\n        return []", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1[0]!= l2[0]:\n         raise ValueError(\"first list element must be equal\")\n    return sorted(set(l1), set(l2))\n         def set(l1, l2):\n          return l1 + set(l2, l1)\n          def sorted(l1, l2):\n          \"\"\"Return sorted list of unique common elements for two lists.\n    >>> sorted([1, 5, 3, 2, 8], [5, 3, 8])\n    [5, 3, 8]\n    >>> sorted([5, 3, 2, 8], [5, 3, 2, 8])\n    [5, 3, 8]\n    >>> sorted([5, 7, 1, 5, 9, 653, 121], [3, 2])\n    [2, 3]\n    \"\"\"\n    return [set(l1,", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def __getitem__(self, key: int):\n        if key in l1:\n           return l1[key]\n        else:\n           return l2[key]\n        return None\n\n    def __len__(self):\n        return len(self.__dict__)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def less(l1: list, l2: list):\n    \"\"\"Return the lesser of two lists.\n    >>> less(['a', 'b', 'c'], ['a', 'b', 'c', 'd'])\n    [c]\n    >>> less(['a', 'b', 'c'], ['a', 'b', 'c', 'd'])\n    [c]\n    >>> less(['a', 'b', 'c'], ['a', 'd', 'b', 'd'])\n    [d]\n    >>> less(['a', 'b', 'c'], ['a', 'd', 'b', 'd'])\n    [b]\n    \"\"\"\n    def intersect(l1: list, l2: list):\n    \"\"\"Return a list containing all common elements in l1 and l2.\n    >>> intersect([1, 3, 4, 8], [1, 3, 4, 5, 7, 8])\n    [(1, 3, 5", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return l2.sort()\n    if l2 is None:\n        l1.sort()\n    return l1\nThis is missing the case where one of the lists is empty.\n\nAgreed, I like the case where one of the lists is empty so it returns a sorted list of singleton elements. It's a little clearer.\n\nYou might want to do a quick test to see if the list being sorted is empty. That way you can avoid the overhead of sorting if it's empty.\n\nYou may also want to make the function name a bit more clear. If you search \"common\", most of the common ones that come up are for the common comparison operator.\n\nIf you were to use this, the sort function is usually cached, so you don't end up with a lot of overhead. I wouldn't worry about it.\n\nExcept that it's not a sort, it's a partition, and it's probably a bad idea to cache partition algorithms.\n\nI'm pretty sure that in the overwhelming majority of cases, the sort function is cached. The only thing that's a little tricky is if the underlying library is a queue", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    def __eq__(self, other):\n    \"\"\"Return True if x is a common element of y, False otherwise.\n    >>> common([1, 2, 3, 4, 5], [3, 3, 2, 6])\n    False\n    >>> common([1, 2, 3, 4, 5], [6])\n    True\n    >>> common([1, 2, 3, 4, 5], [7])\n    True\n    \"\"\"\n    return (other.l1 == self.l1) and (other.l2 == self.l2)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1 == l2:\n        return l1.pop()\n    return []\nYou should use a hashing function.\n(Also, that's not guaranteed to be the correct solution.)\n\nHashing doesn't solve the problem.  If you hash the first list and the\nsecond list has a different order of elements, the result will be a list\nwith the second list's order of elements.  If you hash both lists and\nyou get the same result, you will only have one element in the result,\nbut you can't know if that is the first element of the first list or\nthe first element of the second list.  In both cases, the result won't\ncontain the second list's elements in the correct order.\n\nYou're right.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if length(l1) == length(l2):\n        return sorted(common(l1, l2))\n    else:\n        return sorted(l1.copy(), l2)\n\nThe problem with the Common function is that you need to know what the\nother input is when you're writing your sorted function. You need to\nassume that the other input is a list, not an arbitrary object.\n\nPython's Common function works on any arbitrary object. So if you had\nan object with a list of integers, and a list of objects with a list\nof integers, you could sort them, like so:\n\n>>> sorted([[1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3], [1, 2, 3]],\n\n[[1, 2, 3], [2, 3, 1, 4], [2, 3, 1, 4], [2, 3, 1, 4], [2, 3, 1,\n4]])\n\n[1, 2, 3, 4, 1, 2,", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"Check that the two lists are not equal.\n    \"\"\"\n    if l1 == l2:\n       return []\n    else:\n       return l1\n    for x in l1:\n       if x not in l2:\n          x = l2[x]\n          if l2[x] in l1:\n               l2[x] = l1[x]\n              return x\n    if x not in l1:\n       return []\n\nThis algorithm is slow because it calls sort twice.", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return [x for x in l1 if x not in l2]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.union(l2), key=lambda x,y: x[0]==y[0])\n\nThis isn't that \"common\", as you could come up with it in a few minutes.\nIt's a great example of a functional solution to a problem with a clear imperative one (do an ordered merge).\n\nSo, it's a common library problem?\n\nNo. It's a common problem that has been implemented many times in many languages.\n\nI've always found this to be a nice solution: \n\nI don't like it. I have to write a function for every data type I want to merge and it doesn't work with lists and dictionaries.\n\nIt is called common for a reason.\n\nand \"common\" is a context-sensitive language feature. It's a common function that doesn't work on lists and dictionaries.\n\nIs it really \"context sensitive\"?\nI can see how it might be (if you were using the builtin __common__ or __eq__ method in Python, for example), but if you were to write your own \"common\" function, would it be \"context sensitive\"?\nI could understand if", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    x = [l1[0] for l1 in l1]\n    y = [l2[0] for l2 in l2]\n    return [x[0] if x[0] in l1 else x[0] for x in common(l1, l2)]\n   \n    def groupby(l: list):\n    \"\"\"Return a sorted list of groups of elements in l. The list is sorted in the groups. The groups are defined by a unique set of common elements.\"\"\"\n    sorted_l = [l[0] for l in l]\n    groups = sorted_l.groupby(lambda x: x in l)\n\n_\\--", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return list(set(l1, set(l2)))\n    @property\n    def same(l1: list, l2: list):\n    \"\"\"Return true if list1 contains same elements as list2.\n    >>> same([1, 3, 2, 6], [1, 2, 3])\n    True\n    >>> same([1, 3, 2, 6], [1, 2, 3, 5])\n    False\n\n    \"\"\"\n    return set(l1, set(l2))\n    @property\n    def equal(l1: list, l2: list):\n    \"\"\"Return true if list1 contains same elements as list2.\n    >>> equal([1, 3, 2, 6], [1, 2, 3])\n    True\n    >>> equal([1, 3, 2, 6], [1, 2, 3, 5])\n    False\n    \"\"\"\n    return list(set(l1, l2)) == set(l1, set", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1 == l2:\n        return []\n    return [l1[:], l2[:]]\nThis is a very naive implementation. For example, it will not work correctly for the following:\n>>> a = [1, 2, 3]\n>>> b = [3, 5, 7]\n>>> common([a, b])\n[1, 2, 3]\n>>> common([1, 2, 3], [3, 5, 7])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in?\nTypeError: cannot compare types 'list' and 'tuple'\nIt would also be more efficient to use something like Python's sorted() or sorting module.\n\nFor a given list of length N and another of length M, the union of the two is the list of length N+M with the unique elements from the first and rest of the elements from the second.\nThis means that the union of [1,2,3] and [3,5,7] is [1, 2, 3, 3, 5, 7, 7, 7, 7].", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    if len(l1) == len(l2):\n        return [[x for x in l1 if x not in l2]]\n    else:\n        return l1[:].sort()\n\nThat's what I was doing.\nThe question is how do I use that in a function like:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def sort(l1: list, l2: list):\n    \"\"\"Sort lists by given key and return a list of tuples that contains\n    elements from both lists that have the same key.\n    >>> sorted([1, 2, 3], [1, 2, 3])\n    [1, 2]\n    >>> sorted([1, 3, 5], [1, 3, 5])\n    [1, 3]\n    >>> sorted([1, 2, 3], [3, 2, 1])\n    [1, 3]\n    >>> sorted([1, 2, 3], [2, 1])\n    [2, 1]\n    >>> sorted([1, 2, 3], [3, 2])\n    [3, 2]\n    >>> sorted([1, 2, 3], [5, 1])\n    [2, 3]\n    >>> sorted([1, 2, 3], [5, 7])\n    [1, 2, 3]\n    >>> sorted([1,", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def __init__(self):\n        self.l1 = l1\n        self.l2 = l2\n        self.sorted = False\n\n        if self.l1.count(self.l2) > 0:\n           sorted = True\n          self.sorted = sorted.sort(key=lambda x,y: x[0] < y[0])\n          sorted\n          self.l1.remove(self.l2)\n          return sorted\n\nOh, I read that one before.\n\nAny other suggestions?\n\n_Which book is the best one to read_?\nI think that's the wrong question. You probably want to know which are the best books _to read_. The \"best\" will vary with the author, the book, and the circumstances.\nYou should read them all. Then read them again.", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1.count() == 0:\n       return l2.items()\n    else:\n       return [l1[0] for l1 in l1 if l1[0] in l2]\nI don't know much about Python, but the above doesn't make much sense to me. How is [1, 5, 653] the same as [1, 5, 653]?\n\nIf you were to sort the original lists, you would get this answer. But sorting lists in Python is a slow operation.\n\nAh, right, that makes sense. Sort the lists, then compare them, then throw out the elements of the original list that are already in the second list.\n\nI always wonder why people insist on using binary trees. If you're using a BST (balanced search tree), you'll get the same O(log(n)) performance, and the time to insert and delete elements will be O(1). The only time when you'd want a binary tree is if you have a pathological case (e.g. when searching for a very large value among very many very small values) in which case", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def compare(l1, l2):\n    \"\"\"Compare two lists for common elements. If they have none, return\n    False.\n    >>> compare([1, 2, 3], [], False)\n    False\n    >>> compare([1, 2, 3], [1, 2, 3], False)\n    True\n    >>> compare([1, 2, 3], [1, 2, 3], True)\n    True\n    >>> compare([1, 2, 3], [1, 2, 3], False)\n    False\n    >>> compare([], [], False)\n    False\n    >>> compare([], [], True)\n    True\n    >>> compare([], [], False)\n    True\n    >>> compare([], [], True)\n    False\n    >>> compare([], [], True)\n    False\n    >>> compare([], [], False)\n    False\n    >>> compare([], [], True)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return [x for x in common(l1, l2) if len(l1) == len(l2) else l1[x]]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if not l1 or not l2:\n        return []\n    l1.sort()\n    l2.sort()\n    return [l1[1] for l1 in l1 if l1[1]!= l2[1]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def common_reverse(l1, l2):\n    \"\"\"Return sorted common elements for two lists, with the first\n    elements reversed.\n    >>> common_reverse([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [2, 5, 7, 9, 5, 653, 121]\n    >>> common_reverse([5, 3, 2, 8], [3, 2])\n    [8, 2, 5, 3, 653]\n    >>> common_reverse([3, 2, 5, 7, 8], [5, 7, 1, 5, 9, 653, 121])\n    [5, 7, 1, 653, 121]\n    \"\"\"\n    for x in l1:\n       for y in l2:\n         if not x.endswith(y):\n              x, y = [x[-", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1 == l2:\n       return []\n    else:\n       for a in l1:\n          for b in l2:\n             if a in b:\n                    return [a, b]\n         else:\n                    return []\n\nMy take on it:\n\"\"\"Return sorted unique common elements for two lists.\n\"\"\"", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return list(set(l1), set(l2))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def is_sorted(l1: list, l2: list):\n    \"\"\"Return True if the two lists are already sorted.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> is_sorted(common(l1, l2), [5, 7, 1, 5, 9, 653, 121])\n    True\n    >>> is_sorted(common(l1, l2), [5, 7, 1, 5, 9, 653, 121])\n    False\n    \"\"\"\n\n    def common_unique(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements of two lists.\n    >>> common_unique([1, 4, 3, 34, 653, 2, 5], [5", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sort_and_union(l1, l2):\n    \"\"\"Sort elements in list l1, unioning the sorted elements of l2 and\n    returning a new list.\n    >>> sort_and_union([1, 2, 3], [4, 5, 6])\n    [1, 3, 4, 2, 5, 6]\n    >>> sort_and_union([1, 2, 3, 4], [4, 5, 6])\n    [1, 3, 4]\n    \"\"\"\n    if l1.count() < l2.count():\n        return sorted(l1.items(), key=lambda l: l[0], reverse=True)\n    else:\n        l2.items()\n        return sort_and_union(l1.items(), l2.items(), key=lambda l: l[0])\n    def add_common_elements(l1: list, l2: list):\n    \"\"\"Return", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    l1.sort()\n    l2.sort()\n    common([l1.head(), l2.tail()])\n\nI don't understand what this is supposed to do. The tests show that the sorting happens after the common() call, so the example is correct. However, if I swap the sort order, it fails. Am I missing something?\n\nYes, you're missing the fact that l1 is not sorted. In fact, if you swap the sort order, the result of common() would be equivalent to calling l1.sort(), and l2.sort() would call the function twice.\n\nThanks, I had it backwards. I guess it would be good to make this clear in the tests.\n\nIt doesn't seem to be clear to me either. I don't get why the tests are necessary.\n\nWhen I get this kind of comment, it usually means I should have written the doc better.\n\nThanks for fixing this. I've updated the docs with a more detailed example.\n\nYou should probably add a comment or note about why the tests are there in the first place.\nI didn't read the tests because I thought it was for", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"Return sorted unique common elements for two lists.\"\"\"\n    def __lt__(a: A, b: A) -> Bool:\n    \"\"\"Return True if a is less than b\"\"\"\n    def __gt__(a: A, b: A) -> Bool:\n    \"\"\"Return True if a is greater than b\"\"\"\n    def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    if len(l1) > len(l2):\n       l1.sort()\n    else:\n       l2.sort()\n    return [a for a in", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted_common(a: list, b: list):\n    \"\"\"Return a sorted list of unique common elements for two lists.\n    >>> sorted_common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sorted_common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    sorted_common(l1, l2):\n    \"\"\"Sort two lists and return a sorted list of their unique common\n    elements.\n    >>> sorted_common(l1, l2)\n    [1, 5, 653]\n    \"\"\"\n\nI like this one, it makes it a bit clearer what it is doing.\n\nI'm not sure if this is a function that should be in the standard library or not.\n\nIt's basically a combination of list.sort() and list.unique(). I think it's probably ok to add.", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"Returns sorted list of common elements from two lists.\n    >>> l1 = [[1, 4, 3], [34, 653], [2, 5]], l2 = [[5, 7, 1],\n    [5, 9, 653], [121]]\n    >>> common(l1, l2)\n    [1, 5, 653]\n    >>> common(l1, l2, reverse=True)\n    [1, 5, 653]\n    >>> common(l1, l2, reverse=True, sort_key=lambda item: item[0])\n    [1, 5, 653]\n    \"\"\"\n    if l1.count() < l2.count():\n        return [common(l1, l2) for common, l1 in l1.keys() if\n         l1[common] in l2]\n    else:\n        return [common(l1, l2) for common", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.union(l2, key=lambdax: x.last), key=lambdax: x.first)\n         # remove duplicates\n          if key not in common(l1, l2):\n            return common(l1, l2, key=lambdax: x.first)\n          # ignore elements with equal keys\n          return common(l1, l2, key=lambdax: x.key==l1.key)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1: len(l1) == l2: len(l2):\n        return []\n    for item in l1: if item not in l2:\n        item = item[1:]\n        item.append(item[2:] if item[2] in l2 else None)\n        item.append(item[3:] if item[3] in l2 else None)\n        return [item]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n    def __init__(self):\n        self.l1 = l1\n        self.l2 = l2\n        self.count = 0\n    \"\"\"\n    def common_count(self, item):\n        if item not in self.l1:\n            self.count += 1\n        return self.count\n    def common_add(self, item):\n        if item not in self.l2:\n            self.l2.append(item)\n        return item\n    def common_remove(self, item):\n        if item not in self.l1:\n            self.l1.remove(item)\n        return item\n    def common_sort(self):", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.indexed(l2))\nThat's really more like it. I'd probably make it in a dictionary, though, rather than using a list.\n\nIt's an interesting exercise in how to do the same task, but in my opinion it is not quite as elegant as the original.\nA few reasons for this are that it doesn't preserve the order of the result, you have to keep track of the indices of each element when you call the function, and the return type of the function is a list.\nIt's all a matter of taste, though.\n\nNot only is it not as elegant as the original, it's not even as elegant as my first idea:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    import collections\n    import itertools\n    import math\n   \n    def unique(l1, l2):\n    \"\"\"Return unique elements for two lists.\n    >>> unique([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [1, 8, 2, 3, 4, 5, 7, 9, 10]\n    >>> unique([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [1, 8, 2, 3, 4, 5, 7, 9, 10]\n    \"\"\"\n    if len(l1) > len(l2):\n       return []\n    return itertools.product([l1.sort(), l2.sort()]), l2", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n    if len(l1) > 1 and len(l2) > 1:\n        return [l1[0] for l1 in l1, l2[0] for l2 in l2]\n    else:\n        return []\n    \"\"\"\n    def common_unsorted(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common_unsorted([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_unsorted([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    if len(l1) > 1 and len(l2) > 1:\n        return [l1[0] for l1 in l1, l2[0] for l2", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def remove_duplicates(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists without duplicates.\n    >>> remove_duplicates([5, 7, 1, 5, 9, 653, 121], [5, 7, 1, 5, 9, 653])\n    [1, 5, 653]\n    >>> remove_duplicates([5, 7, 1, 5, 9, 653, 121], [5, 1, 5, 9, 653])\n    [1, 5, 653]\n    >>> remove_duplicates([5, 7, 1, 5, 9, 653, 121], [1, 5, 653])\n    [1, 5, 653]\n    >>> remove_duplicates([5, 7, 1, 5, 9, 653, 121], [5, 1, 5, 9, 653])\n    [1, 5, 653]\n    >>> remove_duplicates([5, 7, 1, 5, 9", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def s1(x: List[Any]): List[Any] = List(x)\n    def s2(x: List[Any]): List[Any] = List(x)\n    def s3(x: List[Any]): List[Any] = List(x)\n    def s4(x: List[Any]): List[Any] = List(x)\n    def s5(x: List[Any]): List[Any] = List(x)\n    def s6(x: List[Any]): List[Any] = List(x)\n    def s7(x: List[Any]): List[Any] = List(x)\n    def s8(x: List[Any]): List[Any] = List(x)\n\n    def g(x: List[Any]): List[Any] = List(x)\n    def gs(x: List[Any]): List[Any] = List(x)\n    def gt(x: List[Any]): List[", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(set(l1), set(l2))\n\nThis won't work with duplicate elements. For example, the following:\n>>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\nTraceback (most recent call last):\nFile \"<pyshell#24>\", line 1, in <module>\nFile \"<pyshell#24>\", line 5, in common\nreturn sorted(set(l1), set(l2))\nFile \"<pyshell#25>\", line 6, in sorted\nFile \"<pyshell#25>\", line 16, in set\nset([5, 3, 2, 8])\nFile \"<pyshell#25>\", line 18, in set\nset([3, 2])\nFile \"<pyshell#25>\", line 20, in set\nset([2, 3])\nFile \"<pyshell#25>\", line 23, in set\nset([], {})\nFile \"<pyshell#25>\", line 25, in set\nAttributeError: 'dict' object has no attribute", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def uniq_common(l1, l2):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> uniq_common([1, 2, 3, 4], [4, 1, 1, 1])\n    [4, 1]\n    >>> uniq_common([5, 6, 7, 1], [1, 2, 3])\n    [5, 2]\n    >>> uniq_common([5, 7, 8, 1], [1, 2, 3])\n    [7, 1]\n    \"\"\"\n    return sorted(l1.items()).unique()\n\nThe reason this is common is that it needs to be implemented in the standard library because there is no reason for this to not be in there.", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(zip(l1, l2))\n\nHere's a more efficient way to sort an array of doubles:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return l1\n    for i, el in enumerate(l1):\n        if el == l2[i]:\n           return el\n    return l1", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1, l2, key=lambda s: l1[s], reverse=True)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def new_min_comp(l1, l2):\n    \"\"\"Return the smallest common element of two sorted lists.\n    >>> min_comp([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    5\n    >>> min_comp([5, 3, 2, 8], [3, 2])\n    7\n    >>> min_comp([5, 3, 2, 8], [7, 3])\n    [7, 5]\n\n    \"\"\"\n    return (l1[l2[1]] < l1[l2[0]])\n    or (l2[l1[1]] < l2[l1[0]])\n    or (l1[l2[2]] < l1[l2[0]])\n    or (l2[l1[2]] < l2[l1[0]])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def common(l1, l2):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 2, 3, 4, 5], [4, 3, 2, 5])\n    [1, 2, 3, 4]\n    >>> common([2, 3, 4], [1, 5, 2, 3, 4, 5])\n    [2, 3, 5, 4]\n    >>> common([2, 4, 5], [5, 6, 2, 4, 5, 3, 2, 1])\n    [2, 3, 4, 5]\n    \"\"\"\n\nThere is no reason to do this by hand, as any modern implementation (e.g. sorted in Python) will be just as fast.\n\nTrue, but a quicksort for the first common set (assuming that the elements are unique) is O(n^2). So unless the data is highly skewed, you're better off doing it by hand.\n\nYeah, I made that comment with a bit too broad of a brush. It's true that you might be able to", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return l1\n    return sorted(set(l1), set(l2), key=lambda x: x in l2 and x in l1)\n\nA more complete example:\n>>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n[1, 5, 653]\n>>> common([5, 3, 2, 8], [3, 2])\n[2, 3]\n\nIt's not clear to me if the author has thought this through, since he describes the behavior as \"unexpected\". I think a more likely explanation is that the author is misusing common and not understanding why it's returning unexpected results.\n\nIndeed, he seems to expect it to sort in some way. In general, you don't want to sort a list with itself.\n\nThis is the python version of the problem. For comparison here is the Java version:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.sort(), l2.sort())\n    def intersect(l1: list, l2: list):\n    \"\"\"Return an ordered list of all elements in the intersection of two\n    lists.\n    >>> intersect([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [(2, 3, 5, 7), (5, 7, 1)]\n    >>> intersect([5, 3, 2, 8], [3, 2])\n    [(2, 3), (5, 7)]\n    >>> intersect([5, 3, 2, 8], [8, 5])\n    [(5, 8), (3, 2)]\n    \"\"\"\n    return sorted(l1.intersect(l2), key=lambda x: x[1], reverse=True)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.intersection(l2), key=lambda x: x.lower())\n\nreturn common\n\nI don't understand the question.\n\nThe question is the code above is in the test file. It is a trivial sort. If you read the comments for the method you'll see that it is never used. You are supposed to rewrite the method but make sure it is at least as fast as the existing implementation.\nThe above method is used in a for loop.\n\nWell, it has to sort the list twice.\n\nI was going to say the same thing. It's more than twice as slow.\n\nHow much faster could it be?</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.pop(), l2.pop())\n\n(The implementation of the common function in the given example seems to be O(n^2) rather than O(n log n) -- it could be improved by using the merge sort algorithm.)\n\nIt's O(n log n) in the general case, I believe.\n\nIt's O(n log n) if you have an efficient way to determine if two numbers are \"common\" or not.\n\nI think the article is more about common subexpression elimination, which is more than just a simple case of eliminating common subexpressions (which is already a great optimization).\n\nIt is also a great optimization :)\n\nIt is great. But it is a different thing.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    if len(l1) == len(l2):\n        return l1[1]\n    else:\n        return l1\n    def p1(l1: list):\n    \"\"\"Return a sorted list of elements with a common prefix.\n    >>> p1([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    [[1, 2], [3, 4], [5, 6], [7, 8], [9]]\n\n    \"\"\"\n\n    for x in range(len(l1):):\n        l1[x] = l1[x] + 1\n    return l1", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.union(l2), key=lambda item: item.count())", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    return [l2[k] for k, v in sorted(l1, key=lambda x: x[l1[k]]) if l2[k] not in l1[k]]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"Compute the smallest element in each list, then return\n    a new list of the smallest elements.\n    \"\"\"\n    for l1 in l1:\n        for l2 in l2:\n           if l1[l1[0]] < l2[l2[0]] and l1[l1[1]] < l2[l2[1]] and l1[l1[2]] < l2[l2[2]]:\n               return [l1[0], l1[1], l1[2]]\n                  else:\n                 return [l2[0], l2[1], l2[2]]\n    return l1\nWell that's a waste of time.\n\nWell, it's a good way to demonstrate that it's not sorting.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(set(l1), set(l2))\n\nThis is the way it's done in Python. I'm surprised that Ruby doesn't have a built in common function.\n\nIt does.\n\nAnd it's even faster than the Python version.\n\nAnd it's extremely easy to define.\nIt's also very easy to define a more complex one.\n\nThe question was \"why aren't people using this?\" not \"how to define your own\".\n\nI have. Many times. I guess I'm in the minority.\n\nI have also used this a lot (in languages other than Ruby). It's incredibly useful.\n\nYeah, me too.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n    def sort(a: list):\n    \"\"\"Return a sorted version of the list.\n    >>> sort([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n    \"\"\"\n    return sorted(a.split(\" \", 2))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sort(l1: list, l2: list):\n    \"\"\"Sort the lists.\"\"\"\n    sorted_l1 = [l1.sort() for l1 in l1]\n    sorted_l2 = [l2.sort() for l2 in l2]\n    return sorted_l1.union(sorted_l2)\n\nThis is very similar to the one I posted some time ago, but it uses the Python built-in sort() instead of using a custom comparator.\n\nPython's sort() is actually pretty fast. The difference is negligible.\n\nI think the biggest difference is that the implementation in the OP doesn't use Python's built-in sort(), which means it's got the same run-time as bubble sort.\n\nNo, it's not a built-in. It's a function with the same name as the built-in. It's not part of the standard library (yet).\n\n_It's not part of the standard library (yet)._\nNope, it's not in the stdlib, but it is in the 3.3 standard library: \n\nHuh", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted(l1, l2):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> sorted(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]), reverse=True)\n    [1, 5, 653]\n    >>> sorted(common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # sort l1 by the first element of l2\n    sorted1 = sorted(l1.copy(), reverse=True)\n    # sort l2 by the last element of l1\n    sorted2 = sorted(l2.copy(), reverse=True)\n    # return the first common element of l1 and l2\n    return sorted1.copy()\n\nI like this one better, actually. It is a little more readable, and I actually prefer the semantics.\n\nEven better, they could have used a tuple, like the following:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return l1\n    else:\n        return l2.sort(key=lambda item: item[1])\n    return []\nIs this a joke? This is the Pythonic definition of common, and it's the\nworst one I've seen so far. It's also an excellent illustration of why\nPython's choice of default dictionary ordering is terrible.\n`common` is simply the union of the two lists, sorted by key (which is\nonly defined for `Dict`).\n`[1, 5, 653]` is the same as `[5, 1, 653]`, so this will be the same\nunder either order. The `[5, 7, 1, 5, 9, 653, 121]` case is different\nin the default order, but that's not right.\nThe only sensible ordering here is `[1, 5, 653]`, which is the same\nwhether the default is `sort` or `[1, 5, 653]`.\nIt's sad that a list of common", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def sorted(l: list):\n    \"\"\"Returns a sorted list from l.\n    >>> sorted(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m',\n    'n'])\n    [c, e, g, m, n, j, k, l, i, m, a, d, h, f, i]\n    >>> sorted(['d', 'b', 'c', 'a', 'g', 'h', 'k', 'l', 'i', 'n', 'j','m',\n    'i', 'f'])\n    [j, l, m, i, n, j, f, h, d, c, a, g, b]\n    \"\"\"\n    return sorted(l1) + sorted(l2)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def merge(a, b):\n    \"\"\"\n    Merge two lists into a new sorted list of all elements in\n    the common part of the lists.\n    >>> merge([1, 4, 3, 34, 653], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653, 7, 121]\n    >>> merge([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> merge([1, 4, 3, 34, 653], [5, 7, 1, 5, 9, 653, 121], _\n    [\"sort\"])\n    [5, 653, 7, 121, 2, 5, 3, 1]\n    >>> merge([1, 4, 3, 34, 653], [5, 7, 1, 5, 9, 653, 121], _\n    [\"sort\", \"reverse\"])\n    [5, 653, 7, 121, 2, 5, 3, 1]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return l1[l2[0] > l1[1] and l2[1] > l1[0]]\nI like this one a lot. It doesn't require a sorted list, and seems to make fewer assumptions about the input data than the quicksort method. I may end up using this in the future!</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1.count() > l2.count():\n        return [l1.index(l2.index(l1.index(l2)))]\n    elif l1.count() > l2.count():\n        return [l1.index(l2.index(l1.index(l2)))]\n    elif l1.count() == l2.count():\n        return [l1.index(l2.index(l1.index(l2)))]\n\nHow would you go about modifying this so that the common elements are returned in sorted order (if possible)?\n\nmylist = [1, 2, 3, 4, 5]\na = [5, 6, 7, 8, 9]\nsorted_list = []\nfor element in mylist:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n        return len(l1.copy())\n           - len(l2.copy())\n              if l1.count(l2) == 1 else []", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    if l1 == l2:\n        return l1\n        else:\n        return list(l1, common(l2, l1))\n\nThere's a short python version in the python section:</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    n = len(l1)\n    l12 = l1[:n]\n    l22 = l2[:n]\n    l12.append(l22)\n    l12 = l12.sort()\n    l22 = l22.sort()\n    return [x for x in l12 if x in l22]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return l1.sort(key=lambda item: l2[item])\n\nSo there's a one-liner to sort two lists in Python.\nI'm sure you can see the problem: it's not a general solution, it doesn't even do what I'm looking for, and it's not as efficient as it could be.\n\nWhat you're asking for is a general solution to the problem of sorting a list, and there is not a general solution. If you want one, it's going to be a bit more complicated.\nIf you want one that does the _specific_ thing you're looking for (sorting two lists), then I'd recommend reading the documentation on the common method.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n        var res = []\n        for el in l1:\n            res.append(el)\n            if el in l2:\n                 res.append(l2[el])\n              else:\n                  res.append(l2[el])\n    return res", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return l1.sort(key=lambda i: l2[i])\n   .get(0)\n   .sort(key=lambda i: l1[i])\n   .get(0)\n   .sort(key=lambda i: l1[i])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(common_elems(l1, l2))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    l1 = sorted(l1)\n    l2 = sorted(l2)\n    if l1.length == 0:\n        return []\n    else:\n        return [l1[i] for i in l1 if i not in l2]\n    else:\n        return [l2[i] for i in l2 if i not in l1]\n\nPython's built in 'itertools.count' function, which is often used in an identical fashion, is much faster.\n\nI've also seen this as a kata, and I agree that it is a good one.\nOne thing I saw people doing (including myself) that I didn't like was to pick a number of iterations (say 100), then come up with a function that would do that many iterations. The problem is, if you have a function that does n iterations, you only need to do log(n) more iterations to do n^2 iterations, and only log(n) more iterations to do n^3 iterations. This means that for the correct algorithm", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n         def is_common_element(l1, l2):\n           \"\"\"Return True if the elements in the first list are in the second list and vice versa.\n          >>> is_common_element(list(1, 3, 4, 5), list(5, 3, 2, 8))\n           True\n          >>> is_common_element(list(2, 1, 3, 4, 5), list(8, 7, 1, 5, 9, 653, 121))\n           False\n          >>> is_common_element(list(3, 2, 4, 5), list(5, 7, 1, 5, 9, 653, 121))\n           False\n          \"\"\"\n          return l1.all() in l2.all()", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def merge(a1, a2):\n        return sorted(a1.values(), key=lambda x: x.lower())\n    def l1_uniq(l1):\n        if len(l1) == 1:\n           return l1\n        else:\n            return l1.sort()\n    def l2_uniq(l2):\n        if len(l2) == 1:\n           return l2\n        else:\n           return l2.sort()\n    return merge(l1_uniq, l2_uniq)\n\nI don't get it, what's the point? I see that it returns the first element of the two lists, then I see that it returns the second element.\n\nYeah, I meant to merge the first element with the second element, not the", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    # Returns a list containing the unique elements\n    return sorted(l1.index, l2.index, key=lambdax: x[1])\nIn addition to this, I would recommend you use enumerate for this case, rather than the default function in Python.\n\nI think it's much better to use an appropriate built-in like sort than to reimplement a common operation, since doing so is liable to introduce bugs.\n\nI suppose that's the case when you're using it in a more serious project, but if you're just playing around with it, it's a good learning experience.\n\nIt's a good learning experience to reimplement a common operation?\n\nAs a learning experience, yes. I'm not saying you should put it into production.\n\nCommon programming tasks are a good opportunity to learn new languages.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    import collections.defaultdict\n    import collections.sort\n\n    # List of unique common elements\n    # The way to calculate it is to compare each element from one list with the other.\n    # Return the list of the elements that are equal in the two lists.\n    def commonUnique(l1, l2):\n    \"\"\"Return unique common elements of two lists.\n    >>> commonUnique([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [5, 7, 1, 5, 9, 653, 121]\n    >>> commonUnique([5, 3, 2, 8], [3, 2])\n    [5, 2]\n\n    \"\"\"\n    # Create empty defaultdict\n    # If the value is not in the list, then the defaultdict is empty.\n    defaultdict = defaultdict(list)\n    # If the value is in the list, then the defaultdict contains the value.", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(set(l1), set(l2))\nNote that sorted(set(l1), set(l2)) is a good candidate for a tuple.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    # if l1 and l2 have equal length, return the common elements\n    if len(l1) == len(l2):\n       return [x for x in l1 if x not in l2]\n    # if l1 and l2 are equal, return the l1 union of l2\n    if l1 == l2:\n       return [x for x in l1 if not x in l2]\n    # otherwise, return a sorted list of common elements\n    elif len(l1)!= len(l2):\n       return [x for x in l1 if x in l2]\n    # otherwise, return a sorted list of common elements\n    else:\n       return [x for x in l1 if not x in l2]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def uniq(l1: list):\n    \"\"\"Return the unique items in a list.\n    >>> uniq([5, 7, 1, 5, 9, 653, 121])\n    [5, 7, 9, 653]\n    >>> uniq([5, 7, 1, 5, 9, 653])\n    Traceback (most recent call last):\n    File \"\", line 1, in <module>\n    uniq()\n    TypeError: uniq() takes exactly 2 arguments (0 given)\n    >>>\n    \"\"\"", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted(l1, l2):\n    \"\"\"Sort the two lists.\n    >>> sorted([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 2, 5, 7, 9, 121]\n    >>> sorted([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return (l1[0] - l2[0]) * (l1[1] - l2[1])\n       if l1[0] < l2[0] else l1[1] - l2[1]\n\nI know Python isn't a functional language, but what the hell?\n\nYou would do this if you were making a language where lists are not \"pure\" like they are in Python.\n\nI am not sure what you mean by \"pure\". Lists in Python are either mutable or immutable (depending on whether or not you use the built-in sort() function).\n\nThat's", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n        return (\n                 if l1.size() > l2.size() and l1[0]!= l2[0]):\n                              l1.pop()\n                                      l2.pop()\n                                          if l1.size() == l2.size() and l1[0]!= l2[0]:\n                                                 l1.pop()", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def sorted(l1, l2):\n    \"\"\"Return a sorted list of elements that are present in both\n    lists.\n    >>> sorted([5, 7, 3], [1, 2, 3])\n    [7, 3]\n    >>> sorted([5, 7, 1], [1, 2, 3])\n    [7, 3]\n    >>> sorted([1, 5, 3], [1, 2, 3])\n    [5, 3]\n    >>> sorted([1, 5, 7], [1, 2, 3])\n    [5, 3]\n    >>> sorted([1, 5, 3, 2], [1, 2, 3])\n    [1, 5, 3]\n    \"\"\"\n    return [l1.index(l2) for l1 in l1]\n\n    def filter(l1: list, l2: list):\n    \"\"\"Return a list of all elements in l1 that are not present in l2.\n    >>> filter([", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(common(l1, l2), reverse=False)\n\n>>> from collections import deque\n>>> d = deque([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n>>> d.common([1, 5, 653], [3, 2])\n[1, 5, 653]\n\n>>> d.common([1, 5, 653], [5, 7, 1, 5, 9, 653, 121])\n[1, 5, 653]\n\n>>> d.common([1, 5, 653], [5, 7, 1, 5, 9, 653, 121])\n[1, 5, 653]\n\n>>> d.common([1, 5, 653], [5, 7, 1, 5, 9, 653, 121])\n[1, 5, 653]\n\n>>> d.common([1, 5, 653], [5, 7, 1, 5, 9, 653, 121])\n[1, 5, 653]\n\n>>> d.common([1", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1 == l2:\n       return []\n    else:\n        return [l1[0] if l1[0] in l2 else l2[0]]\n\nIt's not just syntactic sugar. You have to remember the order of the lists.\n\nI don't think it's helpful to say \"If you've ever written a Python function that used list comprehension syntax, you've used this built-in function.\"\nYou could just as easily say \"If you've ever written a Python function that used lambda syntax, you've used this built-in function.\"\nThe former statement is true, but not helpful. The latter is false, and also not helpful.\n\nFor some reason, I have always thought that it's just another syntax for the \"reduce\" function in python (the equivalent of \"sum\" in lisp).\n\nIt is!\n\nno, it's not.\n\nIt is.\n\nno, it's not.\n\nThat's a good list of built-in functions I've never used before.\n\nHeh, I've always known this but never bothered to", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1, key=lambda x: x[l2[0]]), sorted(l2, key=lambda x: x[l1[0]])\nAnother nice way to do this is with zip:\nzip([1,4,3,34,653,2,5],[5,7,1,5,9,6,653,121])\n[1, 5, 653]\n[5, 7, 1, 5, 9, 653, 121]\n\nSorting is a waste here. If you just want to find the common elements, why sort and then find?\n\nI thought the same thing.\n\nI had a similar problem with two lists of sorted numbers. I couldn't find a decent solution using the built-in Python functions. So I wrote one:\nIt took me some time to get the numpy solution to work. (I didn't want to install numpy just to try out my function).\n\nThis is the correct answer.\nI mean, if you're not going to use numpy, you have to write a list comprehensions anyway. This is a one-liner, it's the shortest way to do it", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if length(l1) == length(l2) or length(l1) <= length(l2):\n        return list(l1.index(l2))\n    else:\n        return l2.index(l1)\n\nYou should also make it into a lambda function. The main problem with the current code is that it will use O(n) memory while sorting the two lists, since you're using a list as an index.\n\nThanks. I didn't realize the sorting of two lists would be O(n). I did come across this very nice list of common sorting algorithms:\n\nThat link looks very helpful. I'm a little confused about the list of common sorting algorithms, though. Does that mean that they are sorted from fastest to slowest?\n\nI'm not sure what you're asking. It lists the sorting algorithms in alphabetical order.\n\nI was asking because it was a bit confusing to me. It seems to me that they are not in alphabetical order. For instance, quicksort and heapsort are listed before mergesort.\n\nI think this is a very", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return l1.sort()\n   .filter(lambda item: item in l2.iterator()).sort()\n   .filter(lambda item: item in l1.iterator()).sort()\n\nI'm sure that's a fine solution, but how is this not a \"general\" solution:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    \"\"\"\n    if l1!= l2:\n        raise TypeError('The lists should be the same length')\n   \n    return sorted(l1.union(l2), key=lambda k,v: v[0] if k else v[1] + 1)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) < len(l2):\n        return l2[0]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1.is_empty:\n       return [].join([])\n    else:\n       return sorted(l1.union(l2), key=lambda x, y: x[1] < y[1] and x[0] < y[0])\n\nI have to say, I appreciate this. It's short, it's explicit, and it's clear about its intent.\nI'm also getting a feel for the idioms of Python here.\n\nThe idioms of Python are a bit different, because you have the option of using a list comprehension to perform the common operation. This means that the writer of the code doesn't have to know exactly which elements are going to be shared.\n\nThat's interesting. If there's a need to shuffle the elements, would it be common to write it as:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted_common(l1, l2):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> sorted_common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sorted_common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    for l1 in l1:\n       for l2 in l2:\n          if l1[l2] == l2[l1]:\n             return l1[l2]\n    return None", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return map( lambda x: sorted(x, key=lambda x: key(l1) ), l1)\n    + map( lambda x: sorted(x, key=lambda x: key(l2)), l2)\n    + filter( lambda x: x % l1 == 0, l1 )\n    + filter( lambda x: x % l2 == 0, l2 )\n\nThis doesn't handle multiple keys of the same type.\n\nIt's a good point. The extra 1 or 2 lines to handle that should be easy to add.\n\nThere is a thread from just over a year ago about this same topic:\n\nIt's not a good idea to \"return sorted\" in Python, because that function will be called twice: once for the list you want to compare and once for the list you want to merge. That's really wasteful.\n\nAh, true, didn't consider that.\n\nA decent article, but it doesn't appear to work on Python 2.6.\n\nAdded python2.6 to the requirements.txt, check again.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    common = sorted(set(l1))\n    for i in l2:\n        common.append(i)\n    return common", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(set(l1) union set(l2)), set(l1) union set(l2)\n\nPEP 8:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted(l1: list, l2: list):\n    \"\"\"Return sorted common elements for two lists.\n    >>> sorted([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sorted([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> sorted([1, 5, 653], [3, 2, 5])\n    [2, 3, 5]\n    >>> sorted([5, 3, 2, 8], [5, 7, 1, 5, 9, 653, 121])\n    [5, 7, 1, 5, 9, 653, 121]\n    >>> sorted([1, 5, 653], [5, 7, 1, 5, 9, 653, 121, 2, 3])\n    [5, 7, 1, 5, 9, 653, 121, 2, 3, 1]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) > 0:\n        return l1.sort()\n    else:\n        return l2.sort()\nWhat does this actually do?\n\nIt takes two lists and returns the sorted list of common elements.\n\nDoesn't the \"def common(l1: list, l2: list):\" line return a list?\n\nYes. I'm not sure if the people who upvoted you actually read the code. The list is returned as a tuple, which is a list.\n\nAh, sorry, I've never used Python before so I didn't know that. Thanks for telling me.\n\nIn python, common is the name of a function that returns the result of a comparison. Here, it is passed a list and a list, and if the list passed to common is empty, it returns the list passed to it.\n\nSo it returns the sorted list of common elements for two lists?\n\nI believe the list returned by common is an empty list.\n\nIt is, but only if both the lists passed to common are empty.\n\nThis is sort of the inverse", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return [l1[0] for l1 in l1]\n    else:\n        return [(l1[0] for l1 in l1, l2[0] for l2 in l2)\n        if l1[0] not in l2[0] else [] for l1 in l1]\n   \n\nWow that was fast. So how would I implement this in Java or python?\n\nWhy would you want to?\n\nMy guess is to make a CRUD web app or something similar.\n\nThat's a reasonable guess. In that case, I'd recommend using something more appropriate to the task, like Django, Ruby on Rails, Flask, or web.py.\n\nI really like this. I like how the functions are all just one line and the naming convention is very consistent.\n\nIt's not actually a one-liner. There are a few definitions on top of the main module, such as ArrayList, Numeric, etc.\n\nI was talking about the", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def sort_common(l1, l2):\n    \"\"\"Sorts the elements of l1 and l2, and returns the sorted list of\n    the common elements of the two lists.\n    >>> sort_common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sort_common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    if len(l1) == len(l2):\n       return l2\n    else:\n       return sorted(l1.copy(), key=lambda i: i[0])\n      .sort_common(l2)\n\nNote that this algorithm depends on the identity of the first item in the list, so that the sorted list will be sorted in the reverse order if the first items are not equal.\n\nIn Python 2, the above code runs", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def f(a:list):\n    \"\"\"Return a list of all elements in a which are unique to it.\"\"\"\n\n    for x in l1:\n        if a[x] not in l2:\n           return [x]\n    return l2\n\nThe list comprehension is more idiomatic.\n\nThe list comprehension is not idiomatic in Python. The comprehension is more appropriate for a list of values that the code wants to return; in this case the code is creating a new list.\n\nI think this is a rather pedantic distinction.\n\nI was going to say it's not even really a distinction. This is a list comprehension, not a list comprehension. If you're going to go around calling things 'idiomatic' or 'not idiomatic', you should try to at least be consistent.\n\nYou missed the point. I was trying to illustrate the difference between creating a list and returning a list, which I thought was fairly obvious. The list comprehension is _not_ the more idiomatic way to write that function.\n\nI don't see the difference. Both are returning", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    l1 = [1, 2, 3]\n    l2 = [5, 6, 7]\n    return (l1.intersect(l2), l1.intersect(l2))\nThat's the same as (l1.contains(l2), l1.contains(l2))</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    \"\"\"if len(l1) == 1:\n        return list(l1.tail())\n    else:\n        return sorted(l1.sort(), key=lambda l: l.count(l1.head()), reverse=True)\n    \"\"\"\n\nThis is a bad implementation of common. In the first case, the 1 is \"leaking\" in to the output. In the second case, it only returns the first two elements. Common should return all the elements that are common to both lists.\nTo fix it, try something like this:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(l1.count(**), l2.count(**))\n\nBeautiful!</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def common_to_list(l1: list):\n    \"\"\"Return a list containing all unique elements of the given list.\n    >>> common_to_list([1, 4, 3, 34, 653, 2, 5], [])\n    [1, 2, 5]\n    >>> common_to_list([5, 3, 2, 8], [])\n    [2, 3]\n    >>> common_to_list([5, 3, 2, 8], [3])\n    [3]\n    \"\"\"\n\n    def common_to_list_shared(l1: list, l2: list):\n    \"\"\"Return a list containing all unique elements of the two lists.\n    >>> common_to_list_shared([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_to_list_shared([5, 3, 2, 8], [3,", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"This function is needed for in-place common prefix/suffix removal,\n    as used by common_diff(). This function is also useful for\n    generating common prefixes and suffixes for a set of lists, and\n    for doing other things with lists where one might want to avoid\n    performing a full list-to-list comparison.\n    \"\"\"\n    if len(l1) == len(l2):\n        return sorted(common(l1, l2))\n    else:\n        return sorted(l1.append(l2))\n\n>>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n\n>>> common([5, 3, 2, 8], [3, 2])\n\n>>> common([5, 3, 2, 8], [3, 2, 3])\n\n>>> common([5, 3, 2, 8], [3, 2, 3, 2, 8, 5, 3])\n\n>>> common", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return l1.sort(key=lambda x: l1.pop(x), reverse=False)\n   .l2.sort(key=lambda x: l2.pop(x), reverse=False)\n   .l1\n   .l2\n\nThanks for posting this! This is exactly what I was looking for!</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"Borrows the common method from Data.List.\n    \"\"\"\n    def common(l1: list, l2: list):\n    \"\"\"Return sorted common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    common = []\n    for i, (val1, val2) in enumerate(l1):\n        if val1 in common:\n           common.append(val2)\n    return common\n\nAh, but what if you have two lists that are both composed of lists?\n\nI think a recursive solution would be better than a recursive solution.\n\nI think a recursive solution would be better than a recursive solution.\n\nyep, its a", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    l1 = [1, 2, 3, 4]\n    l2 = [5, 6, 8, 9]\n    return [x for x in l1 if x not in l2]\n\nI like this approach, except I find it easier to write it as:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def common_sorted(l1, l2):\n    \"\"\"Sort the input lists and return the unique common elements.\n    >>> common_sorted([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653, 2, 3]\n    >>> common_sorted([5, 7, 1, 5, 9, 653, 121], [3, 5, 7, 2, 1])\n    [1, 5, 653, 3]\n    >>> common_sorted([2, 3], [3, 2])\n    [2, 3]\n    >>> common_sorted([1, 5, 653, 2, 3], [2, 3])\n    [2, 3]\n    \"\"\"\n    return sorted(l1, key = lambda x, y: common(l1, l2, x, y))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    for i in range(len(l1)):\n        for j in range(len(l2)):\n            if l1[i][j] == l2[i][j]:\n                return l1[i][j];\n    return None;", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.split(',')[0], l2.split(',')[0])\n\nSee also:\nuniq\ndiff\nsort (Unix)\nsort (C)\n\nThank you.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return [x[i] for i in sorted(l1, key= lambda x: l1[x])\n    if l1[x] is not None and l1[x] in sorted(l2, key= lambda x: l2[x]))\n    else [None]\nI haven't looked into it, but as a first impression, I would say it looks a bit like a Python list comprehension.\n\nIt looks like it's generating a set of tuples (key, item), and then filtering the results, with a Python list comprehension.\n\nDoesn't Python have an \"empty\" built-in?\n\nYes, it's named \"None\".\n\nThat's the obvious one, but the article's way looks longer.\n\nIt's a little less obvious if you're not familiar with Python's syntax.\n\nThe author should have used python; then he could have used the built-in \"empty\" and made the code even shorter:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    for item in l1:\n       for item in l2:\n          if item not in common(l1, l2):\n               return []\n              if item in common(l1, l2):\n                  return [item]\n                return [item]\n    return []\n\n    def unique(l1: list, l2: list):\n    \"\"\"Return sorted unique items for two lists.\n    >>> unique([1, 5, 2, 3], [3, 5, 1, 8, 9])\n    [1, 3, 5, 9]\n    >>> unique([5, 1, 8], [8, 5, 3, 1])\n    [5, 3, 1]\n    \"\"\"\n    for item in l1:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(\n          for elem in l1:\n               if elem not in l2:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    l1.sort(key=lambdax:x.lower())\n    l1.reverse()\n    l1.sort(key=lambdax:x.upper())\n    return l1", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    a = l1.sort()\n    b = l2.sort()\n    c = [a[0] for a in l1 if a!= b[0] for a in l2 if b!= a[0]]\n    if len(a) == len(b) and len(b) == len(a):\n        return c\n    else:\n        return [c[0] for c in c]\n\nIf you use Python 2.4+, the type signature will be a little more intuitive:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    l1 = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    l2 = [2, 4, 6, 7, 8, 9, 10]\n    return sorted(l1.intersection(l2), key=lambda x, y: x)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.nonzero(), key=lambda l1: l1.nonzero(), reverse=True)\n    if l2:\n        return sorted(l1.nonzero(), key=lambda l1: l2[l1], reverse=True)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l2) == 1:\n       return l1\n    else:\n       for element in l2:\n         if l1[element]!= l2[element]:\n            continue\n            if l1[element] == l2[element]:\n                return l1[element]\n    return None\nIt has a few issues. Firstly, it's not efficient. It will do a lot of unnecessary work when the two lists have an equal number of elements.\nSecond, it's not \"sortable\". The \"sort\" function depends on the element keys being comparable, and that can't be guaranteed here.\n\nCould you provide an example of this inefficient behavior? I can't think of any cases where the work done is unnecessary.\nAlso, sortable is not a very useful property. If I have a list that is already sorted, I don't care if the method used is \"sortable\".\n\nSure", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n    def sort(l1, l2):\n    \"\"\"Sort the common elements for two lists.\n    >>> sort([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sort([5, 7, 1, 5, 9, 653, 121], [1, 4, 3, 34, 653, 2, 5])\n    [1, 5, 653]\n    >>> sort([2, 3, 2, 5, 8, 9], [3, 5, 2, 8, 5, 2, 3])\n    [2, 5, 3, 8]\n    \"\"\"\n    \"\"\"\n    return sorted(l1.remove(l2), key=lambda s: s[0])</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return l1.index(l2)\n\nI'm really curious why this was posted. What is the context?\n\nHN is a good place to share code, and this is my first submission.\nI think it's good to see how other people use Python.\n\nIt's a good article, but not really what I would consider \"showing off\" in the context of \"show HN\".\nShow HN is for articles related to the site, which generally means stuff that the community can build upon or learn from (like a startup, a new service, a new framework or tool, etc).\n\nThanks, I thought of Show HN as a way of showing something interesting to the community, even if it's not directly related to HN.\nI'm not trying to promote my service here, I just think this article is interesting and it's a good way to see how other people use Python.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1 == l2:\n       return None\n    elif len(l1) > len(l2):\n       return l1[0], l1[1:]\n    else:\n       return l1.unique(l2)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n         return sorted(set(l1), set(l2))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sort_common(l1, l2):\n    \"\"\"Return sorted common elements.\n    >>> sorted(common(l1, l2))\n    [1, 5, 653]\n    \"\"\"\n    return sorted(l1.distinct(), l2.distinct())\n\nI think that most of the times you will have better luck with the Python dictionary implementation of common.\n\nWell, the point of the article was that if you want to compare sorting algorithms, you need to compare the algorithms, not the code.\n\nI agree with you that there should be a common standard for code. I was just giving a possible reason why Python's implementation of common() is better.\nI do not know if Python's implementation of common() is better or worse than the Go one.\n\nCan someone explain why a comparison sort should be slower than a heap sort? The article says:\nSo is there something about the comparison algorithm that makes it slower than heap?\n\nHeap sorts have an O(n log n) complexity, while comparison sorts have O(n^2) complexity.\n\nI've never heard of a comparison sort", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sort_by(l1: list, l2: list):\n    \"\"\"Sort the elements of the two lists l1 and l2, then find the common\n    elements, and return the sorted common elements.\"\"\"\n    if l1 == l2:\n       return []\n    sorted_l1 = sorted(l1)\n    sorted_l2 = sorted(l2)\n    common_l1 = set(l1)\n    common_l2 = set(l2)\n    return sorted_l1.insert(common_l1, sorted_l2)\n    def merge(l1, l2):\n    \"\"\"Merge the two lists into a single list, while keeping the unique\n    elements.\"\"\"\n    if len(l1)!= len(l2):\n       return []\n    if len(l1) > len(l2):\n       l1.append(l2)\n    else:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"Split input lists and sort them\n    def split_input(l1, l2):\n    \"\"\"Split input lists and sort them.\n    >>> split_input([5, 3, 2, 8], [3, 2])\n    [5, 2, 3]\n    >>> split_input([5, 3, 2, 8], [5, 2, 3])\n    [5, 3, 2]\n    >>> split_input([5, 3, 2, 8], [5, 2, 3, 2])\n    [5, 2, 3, 2]\n    >>> split_input([5, 3, 2, 8], [5, 2, 3, 2, 3])\n    [5, 2, 3, 2, 3, 3, 2]\n    \"\"\"\n    split_input(l1, l2)\n    \"\"\"Sort input lists\n    def sort_input(l1, l2):\n    \"\"\"Sort input lists.\n    >>> sort_input([5, 3,", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def sorted(l1: list, l2: list):\n    \"\"\"Sorted unique common elements for two lists.\n    >>> sorted([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [5, 653]\n    >>> sorted([5, 3, 2, 8], [3, 2])\n    [2, 3]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.common(l2))\n\nI had to do a double-take to see if the common function was written in Python.\n\nI was looking for a postscript comment in the code.\n\nthis is where lisp shines.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    n = len(l1) + len(l2)\n    n = max(0, len(l1))\n    if n == 2:\n       return l1\n    else:\n       return l2\n\nimport collections\n\nimport itertools\n\nfrom itertools import cycle", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(set(l1), set(l2), key=lambda x, y: x.lower())\nThis is the approach I would have taken.\n\nThis is what I did. I read the article and thought \"how could he have done that?\" Then I saw the other answers, and thought, \"well, that's easy\". But then I thought, \"no, I'm going to try and figure out what he actually did, instead of just reading the code\".\nSo I read the code. And the code was terrible. And then I read the comments, and the comments were terrible. And then I saw what the OP was actually trying to do, and it was easy.\nIn short: this is a terrible, terrible article, and I would like to see it disappear into the ether.\n\nI actually used that approach. It works and it's quite fast. I haven't had a chance to compare it to the one posted here, but I suspect the one here is actually faster.\nHere's my version:\n\nI like the idea of having a common subexpression in a list comprehension, but this version seems awfully complicated and slow.\nI made a more simple version that only looks", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted_commas(l1, l2):\n    \"\"\"Sort lists based on commas, return sorted list.\n    >>> sorted_commas([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [5, 7, 1, 5, 9, 653, 121]\n    >>> sorted_commas([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(l1.reverse(), l2.reverse())\nIn Python3, it's:      return sorted(l1.sort(), l2.sort())\n\nYes, and there's no reason to not use it.\n\nI use this quite frequently, and I would use it all the time if it weren't for the Python 3 sorting issue.\n\nIn what way? I've never had a problem with it, even on Python3.\n\nProbably using it with a list of lists, or maybe with a list of dictionaries, or something", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1[0] not in l2:\n        return []\n    for x in l1:\n        if x not in l2:\n            x = l2[x]\n           if x in l1[1]:\n               l1[1] = l2[x]\n    return l1", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return l1\n    else:\n        return l2\n\nThis is just a quick code-pasta. I want to know if the definition of the function is correct. Also, how would I code a custom comparator using the algorithms defined in the code above?\n\nEdit: I've now been given the correct answer, thanks!\n\nThe answer is below</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return []\n    else:\n        return common(l1: l1, l2: l2)\n\nThis is the correct answer, you can also think of it as a way to merge two sorted lists.\n\nI'm assuming that's why you wrote your answer? I'm curious if the OP's question is intended as a joke.\n\nNot a joke. I have an algorithm that uses that technique to find common elements.\n\nI don't understand why it's \"recursive\". The \"Common\" function is a part of the \"Common\" module, so it's a top-level function. The \"Common\" module itself is defined as a function that returns \"Common\".\n\nBecause the common function can be called recursively on the same list, just like a function can be called recursively on the same argument.\n\nI've been writing python for a few years now, and I've always wondered what the correct way to use __main__ is when you're writing a module. The docs seem to just tell you that it's a global", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1 == l2:\n        return l1\n    else:\n        return common(l1, l2)\n\nThe first version would be faster than the second if the input data is already sorted.\n\nAnd in Python 3:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n       if len(l1) < len(l2):\n         return []\n       elif len(l1) == len(l2):\n         return [l1[0] for l1 in l1]\n       else:\n         return sorted(l1, key=lambda a, b: common(l1, l2[a], l1[b]))\n\nI am not sure if I like this code. It does not use any sort of hashing algorithm. It seems the author has to do the sort twice.\n\nHow is the second sort done?\n\nHow to use a dictionary for this?\n\nThis is not about data structure (hash table, list, dictionary,...) this is about sorting.\nThe sorting algorithm used here is bubble sort. The idea is to keep the sorted parts of the input and then create a new sorted list from them.\n\nYes, I'm aware. I thought the answer was that you'd use a dictionary for the keys.", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return l1\n    else:\n        return []\n   \nWhat is the point of returning an empty list?\n\nFrom the docs:\n\"The list returned by the common function is not necessarily sorted.\"\n\nI see that, but I still don't see a point.\n\nThe point is to find the common elements, it doesn't really matter how they are sorted.\nIf you want to sort them, just add `sort()` to the end of the function.\n\nI meant that returning an empty list is meaningless.\n\n\"returning an empty list is meaningless\"\nI disagree.  Let's say you have two arrays of numbers that you want to compare.  Say you want to find the maximum and minimum in each array and then sort the arrays by those values.  In Python, you would do:\nmax_min = sorted(list(array1), key=lambda x: x[1], reverse=True)  # sort arrays by maximums\nmax_min = sorted(list(array2), key=lambda x", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.reverse(), key=lambda x, y: x.index(l2.reverse()), reverse=False)\n    if l1 == l2:\n        return sorted(l2, key=lambda x, y: x.index(l1.reverse()), reverse=False)\n    else:\n        return sorted(l1, key=lambda x, y: x.index(l2.reverse()), reverse=False)\n\nThis is an alternative implementation:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return (l1.sort(key=lambda x: l2[x], reverse=True).unique())\n    or (l2.sort(key=lambda x: l1[x], reverse=True).unique())\n    or (l1.sort(key=lambda x: l2[x], reverse=True).unique())\n\nNote: the key function is reversed (because it is called on the result) so that elements with the same key are returned in the same order.\n\nA more idiomatic python version:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1 == [] and l2 == [] then\n       return []\n    else\n       return l1.sort(function(x, y) return x[1] < y[1])\n   .l2.sort(function(x, y) return x[1] < y[1])\n\nAnd from the documentation of Python's built-in sorted() function:\n>>> sorted([1, 2, 3, 4, 5], [1, 2, 3, 4])\n[2, 3, 4, 5]\n>>> sorted([1, 2, 3, 4, 5], [1, 2, 3, 4, 5, 5])\n[2, 3, 4, 5, 5]\n>>> sorted([1, 2, 3, 4, 5, 5, 5], [1, 2, 3, 4, 5, 5, 5])\n[2, 3, 4, 5, 5, 5, 5]\n>>> sorted([1, 2, 3, 4, 5, 5, 5, 5, 5], [1, 2, 3, 4, 5, 5,", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    from functools import reduce\n    from functools import reduce_right\n    from functools import mzero\n    from itertools import cycle\n    def get_common_subset(s1, s2):\n    \"\"\"Return list of common elements of two lists.\n    >>> s1 = [1, 2, 3]\n    >>> s2 = [2, 2, 2, 3, 3]\n    >>> get_common_subset(s1, s2)\n    [1, 2, 3]\n    >>> get_common_subset(s1, s2, key=lambda x: x[1])\n    [1, 2, 3]\n    >>> get_common_subset(s1, s2, key=lambda x: x[1], reverse=True)\n    [1, 2, 3]\n    >>> get_common_subset(s1, s2, key=lambda x: x[1], reverse=True, unique=True)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    n = len(l1)\n    return l1[:] if n < 2 or l1[-1:]\n    for x in l1:\n        if x not in l2:\n             return x\n         l2.append(x)\n    return l2\n\nI wonder how efficient it would be to add a sorted() method.\n\nThat's what common.sort() is for.\n\nSo, why would you use this over the built in Python dict?\n\nIt's faster.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def sorter(x: list):\n    \"\"\"Return a list of all distinct elements in a list that are in\n    common with each other and the original list.\n    >>> sorter(['a', 'b', 'c'], ['d', 'e', 'f'])\n    [a, d, b, e, f]\n    >>> sorter(['a', 'b', 'c'], ['b', 'd', 'f'])\n    [a, b, e, f]\n    >>> sorter(['a', 'b', 'c'], ['c', 'b', 'd'])\n    [a, b, e, c]\n    \"\"\"\n\n    # Note: We have to make a copy of the original list to make sure\n    # the original list is not modified by other code.\n    copy_list = list(x)\n    # Create a tuple of lists: one with common elements of x, one with\n    # elements in x not in the other list.", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return l1.sort(lambda x, y: x.__class__.__eq__(y))\n   .filter(lambda x: x.__class__.__lt__(l2.pop()))\n   .take(2)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.all(), key=lambda x: l1[x], reverse=True)\n   .key()\n   .sort()\n   .tolist()\n   .extend(l2.all())", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    for c in l1:\n       for c in l2:\n          if c not in l1:\n                  return c\n    return []\n\nYikes! A list comprehension with a list comprehension in it.\nDon't do that.\n\nIt's a perfectly fine and idiomatic way to make your code more readable.\n\nThat's a great way to make your code more difficult to read.\n\nYou do know how to read, don't you?</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def pairwise(l1: list, l2: list):\n    \"\"\"Return the unique common elements for two lists.\n    >>> pairwise([1, 3, 5], [6, 8])\n    [1, 3, 6, 8]\n    >>> pairwise([1, 3, 5], [2, 5, 7])\n    [1, 5, 7]\n    >>> pairwise([1, 3, 5], [5, 7, 8])\n    [1, 5, 8]\n    \"\"\"\n    # Start with a slice of the list.\n    # Iterate over all the items in the slice, removing duplicates.\n    # Join the resulting lists into a tuple.\n    for v in l1[0:]:\n       for v in l2[0:]:\n         # If we have two elements, then they must be the same.\n         if len(v) == l1.len(v) + l2.", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n       if len(l1) == len(l2):\n         return [False]\n       return l1.__contains__(l2)\n\nThat's sort of like the solution I posted, except without the need to create a list of lists.\n\nThe problem is that your solution does not work in Python 3.\nIt is fixed in 3.3.0 though.\n\nI'm not sure I understand. What is the difference between the two solutions?\n\nIn Python 2.x:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    k = len(l1)\n    l2 = l1[:]\n    common = []\n    for k in xrange(k+1):\n        for l in l1[k+1:]:\n           if common.has_key(l):\n               common.append(l)\n              break\n              l2.append(common)\n    return common", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1[0] == l2[0]:\n        return []\n    else:\n        return set(l1[1], l2[1])\nHrm, I'm not sure what you mean by \"common\". I assumed it would return the minimum common elements from both lists, but I guess it's more of a sort of a \"union\" of the two lists?\nI am not a python programmer, but this code seems to be doing a lot of work for something that could be done with a single if statement.\n\nThe code in the article is doing a union-find (or whatever it's called in Python) that is probably the most efficient way to do this.\n\nAh, good catch. I missed that completely.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(set(l1), set(l2))\n\tcommon_with_exact_weighting(common, l1[2] + l1[1], l2[1])\n\tcommon_with_exact_weighting(common, l1[2], l2[1])\n\tcommon_with_exact_weighting(common, l1[1], l2[1])\n\tcommon_with_exact_weighting(common, l1[2], l2[1])\n\tcommon_with_exact_weighting(common, l1[1], l2[1])\n\nWow, that's probably the most concise implementation I've seen!</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(set(l1), set(l2))\n\nSo the author could have written the article like this:\n(defun common(l1 l2)\n  (cond ((= l1 l2) (return l1 l2))\n  ((= l1 0) (return l2))\n  ((= l1 '(') (return l1))\n  ((= l1 ')' (return l2))\n  ((= l1 ')' (cond ((null l2) (return l2))\n  ((<= l1 l2) (return (sorted set (cdr l1) l2)))\n  (t (return l1 t)))))))\nand it would be more readable, and faster as well.\n\nIt's also not portable:\n\n(defun common (l1 l2)\n(cond ((= l1 l2) (return l1 l2))\n((= l1 0) (return l2))\n((= l1 '(') (return l1))\n((= l1 ')' (return l2))\n((= l1 ')' (cond ((null l2)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    # Sort both lists, then compare common elements.\n    # L1 has one less element than L2.\n    # L1 has one more element than L2.\n    L1.sort()\n    for i in L2:\n       if L1.remove(i):\n         L2.remove(i)\n         L2.sort()\n    return L1[:-1]\n\nThe code is right, but the explanation is wrong.\n(1) The common() function is not linear, so the asymptotic complexity should be\nsomething more than O(n log n).\n(2) The definition of the common() function includes some duplicate code.\n(3) The function argument \"remove\" is usually called \"removeIfAbsent\".\n(4) It's possible to write the common() function using binary search:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    # This is a sorted list\n    sorted_list = sorted(l1)\n    # This is a sorted list\n    sorted_list = sorted(l2)\n    # This is a list of all the unique common elements for\n    # the two lists\n    common = [x for x in sorted_list if not common(x, sorted_list)]\n    return common\n\nThis may be a good implementation for Python, but it's definitely not how you would do it in C or C++.\n\nHow do you think it's best to do it?\n\nFor instance, it's possible that the list you get back is an infinite length string. Or you can easily have duplicate values.\n\nAh I see, I was thinking of the Python implementation and didn't think of the other implementations. My bad.\n\nI've created a similar function in Ruby that uses hashing:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    for i in l1:\n       if i not in l2:\n          return []\n       if i == l2[1]:\n           return [i]\n       for j in l2[2:] + l2[3:] + l2[4:] + l2[5:] + l2[6:] + l2[7:] + l2[8:] + l2[9:] + l2[10:] + l2[11:] + l2[12:] + l2[13:] + l2[14:] + l2[15:] + l2[16:] + l2[17:] + l2[18:] + l2[19:] + l2[20:] + l2[21:] + l2[22:] + l2[23:] + l2[24:] + l2[25:] + l2[26:] + l2[27:] + l2[28:] + l2[29:] + l2[30:] + l2[31:] +", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"Implements the \"common\" method from the standard library.\n    >>> list1 = [1, 2, 3, 4, 5]\n    >>> list2 = [1, 2, 3, 4]\n    >>> len(list1)\n    10\n    >>> len(list2)\n    4\n    >>> common([list1, list2])\n    [1, 2, 3]\n    >>>\n    \"\"\"\n\n    def common(l1: list, l2: list):\n    \"\"\"Return sorted common elements for two lists.\n    >>> common([1, 2, 3], [5, 6, 3, 7])\n    [1, 2, 5]\n    >>> common([1, 2, 3], [5, 6, 3, 7, 8])\n    [1, 2, 3, 5, 7, 8]\n    >>> common([1, 2, 3, 4, 5, 6, 7, 8], [5, 6, 7])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) > len(l2):\n        return []\n    for a, b in zip(l1, l2):\n        if len(l1) == len(l2):\n           return a\n        if len(l1) < len(l2):\n           return b\n\nSo why is the standard library sort bad?\nI'm sure it's not as good as a C++ implementation, but it's still pretty good.\n\nThe main problem is it uses heap sort, which is O(n log n), whereas merge sort, which is O(n) is just as easy to implement (or better) and requires a lot less memory.\n\nUh, no. Heap sort is O(n log n) for the _worst_ case. It is still O(n) for the usual case. And the usual case is the one you care about for most programs.\n\n_Uh, no. Heap sort is O(n log n) for the", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.index(l2) for l1 in l1 else l2, key=l1.index(l2, key))\n\nI'm really glad that Ruby has added what would otherwise be considered a fairly trivial feature to the language. I look forward to seeing this in future versions of Perl (though I'm not hopeful).\n\nIt's a shame that it isn't default behavior.\n\nI think it would be great if a hash could be ordered by index, like a list can be ordered by index. But this code (not the best, I know) is all I could come up with:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(common(l1,l2))\nI read this as common is a function that takes two lists and returns a sorted list of common elements.    My first question is, how?    My second question is, why?  Why not simply sort the two lists and return that?  Is there some inherent benefit to this approach?  I don't see any.\nIt's for the sake of being able to call the function with two lists, of course.  It would not be as compact as the original code, but I think it could be a good exercise for the OP to rewrite the common function as a function that takes two lists.\nIt's a good exercise.  It's also a good exercise to write the most compact function that does the same thing.  In this case, the two functions are very different and I'm not sure that one is better than the other.  Sometimes the most compact function isn't always the best.  The question is always, does the added compactness gain you anything in the way of readability?  Is it easier to understand the compact function than the more compact version?</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"Compute the unique common elements for two lists.\n    >>> l1 = [2, 6, 9]\n    >>> l2 = [5, 4, 6, 8]\n    >>> common([l1, l2])\n    [2, 4, 6]\n    >>> common([l1, l2], reverse=True)\n    [2, 6]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    a = l1.duplicated()\n    b = l2.duplicated()\n    result = []\n    for i in range(a.length):\n         if a[i] == b[i]:\n            result.append(a[i])\n           break\n    return result", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    for el in l1:\n        if el not in l2:\n           return l1\n        else:\n            return l2[el]\n\nfor a quick and dirty version, this seems to work for me:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1 == [] or l2 == []:\n        return None\n    else:\n        return l1.index(l2)\n\nBut that is just a kludge.\nYou want to sort the first list and then take a subsequence from the first list of all the elements that are also in the second list. But then you don't want to give them in the same order as in the second list, you want to give them in the original order of the first list.\nYou can't do that with a simple sort.\nThe only way to do it is to make a binary search and then make your subsequence from that.\n\nI think it is a good idea to have a function that can be used for this kind of task.\nBut I think that in order to avoid the need for an unnecessary loop, and make it so that the user can specify the two lists in any order they choose, it should be:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def inner(l1: list, l2: list):\n    \"\"\"Return sorted unique elements from l1 and l2.\n    >>> inner(['a', 'a', 'a'], ['b'])\n    [a]\n    >>> inner(['a', 'b', 'b'], ['c']).tuple\n    [(a, b), (a, c)]\n    >>> inner(['a', 'b', 'c'], ['a'])\n    [a]\n    \"\"\"\n    def outer(l1: list, l2: list):\n    \"\"\"Return sorted unique elements from l1 and l2.\n    >>> outer(['a', 'a', 'a'], ['b', 'b'])\n    [a, b]\n    >>> outer(['a', 'b', 'c'], ['d']).tuple\n    [(a, c), (a, d)]\n    >>> outer(['a', 'b', 'c'], ['a'], ['", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return l1.sort()\n   .filter(x -> x!= l2[i])\n   .reverse()\n   .uniq()\nI'm not sure, but doesn't this require the lists to be ordered already?\nI think the author's example in the linked article is not the best example of a use case.\n\nyou're right. i was about to say the same thing. in fact, i think there are cases where the algorithm will not be able to find a common element:\ncommon([1, 2, 3], [5, 6, 7, 8, 9])\n\nYou're right, my algorithm is not guaranteed to find a common element. But if there is one, then I think it will find it. I could be wrong, but I'm pretty sure I'm not. :)\n\nNot guaranteed.\n\nYou're right. I meant to write that if there is a common element, then my algorithm will find it. If that wasn't clear, then I apologize.\n\nThe sorted, uniq and reverse in the loop isn't really necessary.", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1)!= len(l2):\n        return [l1[0], l1[1:] for l1 in l2]\n    else:\n        return sorted(common(l1, l2))\n\nYou're wrong. It's not sorted.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def has_key(l1: list, l2: list):\n       \"\"\"Return True if any element of list l1 is also an element\n       of l2.\n       >>> has_key([1, 2, 3], [5, 4, 3, 2])\n       True\n       >>> has_key([5, 4, 3, 2], [1, 2, 3])\n       False\n       \"\"\"\n       if any(l1.is_set(), l2.is_set()) is not None:\n           return True\n       else:\n           return False\n       return True\n\n    def count_common(l1: list, l2: list):\n       \"\"\"Return the number of common elements for the two lists.\n       >>> count_common([1, 2, 3", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == 0:\n        return l2\n    else:\n        return l1[0]\n    # remove duplicates\n    return l2[l1.index(l2[0]) + 1:]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.items(), key=lambda x: x in l2.items(), reverse=True)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"If the lists are sorted, then return the common elements as a\n    new list.\n    >>> common([5, 2, 8], [8, 5])\n    [5, 2]\n    \"\"\"\n\nFor 2D arrays, use the.sort_common() method:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    #L1\n    common.append(l1[0])\n    common.append(l1[1])\n    common.append(l1[2])\n    common.append(l1[3])\n    return common\n\n[1, 5, 653]\n\n[3, 2]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n       return sorted(common(l1, l2)), sorted(l1)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.compare(l2.sort()), key=lambda l1: l1.count(0), reverse=True)\n\nCould you explain how this works? I see that you're using the key attribute of a dictionary to refer to a specific element, but I can't see how that's necessary. I'm not sure what the first line of code is doing.\nEdit: Ah, I see, it's using the count() method of lists to get the number of times a given element is repeated in the list.\n\nIt is not using the key attribute of a dictionary to refer to a specific element, it is using the key attribute of a list to refer to a specific element.\n\nAh, I see, it's using the count() method of lists to get the number of times a given element is repeated in the list.\n\nI've never used this before. What does it return?\n\nIn [1]:\n>>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n[1, 5, 653]\nIn [2]:\n>>>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"Clone this object to sort on this list\"\"\".\n    @classmethod\n    def _getitem_:\n    \"\"\"Get an item from the given list.\n    >>> _getitem([1, 4, 3, 34, 653, 2, 5] + [5, 7, 1, 5, 9, 653, 121]\n    653\n    >>> _getitem([5, 3, 2, 8] + [3, 2])\n    [2, 3]\n    \"\"\"\n    def __init__(self, l1: list, l2: list):\n    \"\"\"Initialize this sorted common list with the two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653, 2]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    l1.sort()\n    l2.sort()\n    return l1.union(l2)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    l1 = sorted(l1)\n    l2 = sorted(l2)\n    for i, a in enumerate(l1):\n       for j, b in enumerate(l2):\n          if l1[i, j] == l2[j, i]:\n               break\n              a[j] += l1[i, j]\n    return a\n\nI like the idea, but the implementation seems to be broken. I ran into a lot of problems when testing it.\nFor example:\n>>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n[1, 5, 653]\n>>> common([5, 3, 2, 8], [3, 2])\n[2, 3]\n>>> common([5, 3, 2, 8], [3, 2], [7, 9, 1, 5, 9,", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def merge(x: list, l1: list, l2: list):\n    \"\"\"\n       Returns a new list with the common elements of x and\n       l1 and the common elements of x and l2.\n       x: list\n       l1: list\n       l2: list\n       return [x[0], x[1], x[2], x[3], x[4]]\n    \"\"\"\n    for x in l1:\n    for y in l2:\n       if x[x] == y[y]:\n             return [x[x], x[y], x[z], y[z]]\n       return []\n\n    def merge_unique(x: list, l1: list, l2: list):\n    \"\"\"\n       Returns a new list with the unique elements of x and", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l2) > 0:\n        return sorted(l1, key=lambda item: item in l2 if item in l1 else None for l2 in l1)\n    else:\n        return sorted(l2, key=lambda item: item in l1 if item in l2 else None for l1 in l2)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n        def unique(x):\n         return x in x\n        return []\n        def find_unique(x1: list, x2: list):\n         return unique(x1) || unique(x2)\n        return []\n        def common(l1: list, l2: list):\n         \"\"\"Return sorted unique common elements for two lists.\n         >>> common([1, 2, 3, 3], [4, 5, 3, 3, 1])\n         [4, 1]\n        >>> common([2, 1], [3, 4])\n         [4, 3]\n        \"\"\"\n        def unique(x):\n         if x not in l1:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return unique(l1.union(l2))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return [x for x in l1 if x in l2]\n    else:\n        return set([x for x in l1 if x not in l2] if len(l1) > len(l2),\n        return set([x for x in l1 if x not in l2]) if len(l1) == len(l2))\n        return [x for x in l1 if x not in l2]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(common(l1, l2))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    for i in l1:\n         for j in l2:\n              if common(i, j):\n                 return i, j\n          else:\n                return -1, -1\n          return -1\nThis is horrible, and you should feel bad.\nIt's not O(nlogn) and it's not any faster than the best O(nlogn)\nimplementation.\n\nYou're right, I was only looking at the time complexity and not the other factors. However, it's still better than the O(n^2) algorithm I was using before.\n\nI guess it depends on what you mean by \"better\". It's certainly not \"better\" in the sense of being an improvement.\n\nHere's a few I use from time to time:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return l1.pop()\n        return []\n    else:\n        if l2 == [] and l1 is not None:\n           return common(l1.pop(), l2)\n        else:\n           return sorted(l1.pop(), key=lambda a: a[1], reverse=True)\n    return []", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    for x in l1:\n        if x in l2:\n           return x\n    return []", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    \"\"\"For each item in l1, compute its index in l2.\n    >>> l1 = [1, 4, 3, 34, 653, 2, 5]\n    >>> l2 = [5, 7, 1, 5, 9, 653, 121]\n    >>> index = l1.index(l2)\n    >>> index\n    [1, 2, 3]\n    >>> common(l1, l2, index)\n    [1, 5, 653]\n\nI can't think of a real world application for this.  Is this really as useful as you claim?\n\nI think it's a neat idea. I've used it in the past with success, but I agree that I don't see this in the wild very often.\nI think the usefulness of this will probably depend on how much of a bottleneck this sort of thing will be.\n\nfor the sake of fun and curiosity, i ran the above on the python shell to see the output. i was pleased to see that it was basically a cyclic reference check.\nfor example, with [1, 2,", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return [x for x in l1 if not x in l2]\nI'm having trouble seeing why this works. Can someone explain?\n\nIt works because the first list contains only unique elements. The second list contains only unique elements that don't appear in the first list. Therefore, the only possible result is the second list.\n\nMy mistake. That makes sense. Thanks!\n\nI have a question about the follow up problem.\nGiven a list A containing all the integers from 1 to n.\nHow would one go about finding the shortest path from 1 to n?\n\nI found this on Wikipedia:\n\"If the list is in increasing order, this algorithm finds the path with the smallest sum of numbers in the path. If the list is in decreasing order, this algorithm finds the path with the smallest sum of numbers in the path.\nIf the list is in random order, this algorithm finds the path with the smallest sum of numbers in the path.\"\nSo it seems the solution would be to reverse the list and then find the shortest path.\n\n1, 4, 3, 34, 653, 2, 5\n5, 7, 1, 5, 9, 653, 121", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    sorted = sorted(l1.keys())\n    common = sorted(l2.keys())\n    return sorted(l1.items(), l2.items())", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    for x in range(1, len(l1)):\n        l1.append(x)\n    for x in range(1, len(l2)):\n        l2.append(x)\n    return sorted(common(l1, l2))\nNote that sorted(common(...)) is equivalent to sorted(complement(...)), so this is a simple case of sort.\n\nIt also works on 1,2,3...n.\n\nI know that the python solution is supposed to be elegant, but I don't understand the O(n log n) complexity at all.\nI can't see why it would take O(n log n) to sort a list of items that has the same number of items as the original list?\n\nThere are two ways to interpret the complexity of sorting.\nThe naive one, O(n log n), says that for an arbitrary list of n items, there are n! different combinations of items that can appear in any sorted order. If you want to sort a list, you have to check every possible combination of items, and if it's", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted(l1, l2):\n    \"\"\"Sort the elements of l1 and l2 in increasing order and return\n    the unique common elements.\n    >>> sorted([1, 2, 3, 4], [1, 3, 4])\n    [1, 3, 4]\n    >>> sorted([1, 2, 3, 4], [5, 2, 1])\n    [5, 1, 3, 4]\n    >>> sorted([1, 2, 3, 4], [5, 7, 653])\n    [1, 3, 4, 5, 7, 653]\n    >>> sorted([1, 2, 3, 4], [5, 7, 2, 5])\n    [5, 1, 3, 4, 7, 2, 5]\n    >>> sorted([1, 2, 3, 4], [5, 7, 1, 5, 9, 653, 121])\n    [5, 7, 1, 5, 9, 653, 121]\n    >>> sorted([1, 2, 3", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return common(l1, l2)\n    else:\n        return [0] + common(l1, l2)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1 == l2:\n       return None\n    for l3 in l1:\n       for l4 in l2:\n          if l3 == l4:\n             return []\n              if not l3 in l4:\n                return [l3, l4]\n    return [l3, l4]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    sorted(l1, key=lambda l1: x[0], reverse=True)\n    sorted(l2, key=lambda l2: x[0], reverse=True)\n    result = []\n    for l1, l2 in zip(l1, l2):\n        result.append(x[0])\n    return result\n\nimport itertools", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def __call__(self, l1: list, l2: list):\n       for item in l1:\n          if item in l2:\n                return list(l1.index(item), l2.index(item))\n       return []\n    \"\"\"", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return l1.copy()\n    else:\n        return l1.sort(function(x, y) return (y[0] < x[0]) or (y[1] < x[1]) or (y[2] < x[2]))\n   .filter(function(x) return l2.index(x) == -1)\n\nShouldn't it be:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"O(N^2)\n    @l1, l2 = sorted(l1, l2)\n    \"\"\"\n    return sorted(l1.difference(l2), key=lambda l1:l2.difference(l1))\n    @param l1: list\n    @param l2: list\n    \"\"\"\n    @l1 = l1\n    @l2 = l2\n\nWhy is this in a list comprehension?\n\nIt's not, it's a function. A list comprehension is syntactic sugar for this function (and any other function with parameters and a return statement).\n\nIt was an example of a function that looked like a list comprehension but wasn't.\n\nI never said it was. I was explaining the function.\n\nI asked why it was in a list comprehension.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    a, l1 = l1.sort()\n    b, l2 = l2.sort()\n    c, n = len(l1), len(l2)\n    for i in range(0, n):\n        c = c + l1[i]\n        c = c + l2[i]\n        c = c + l1[i] + l2[i]\n        c = c + l1[i] + l2[i]\n        c = c + l1[i] + l2[i] + l1[i] + l2[i]\n    return l1[c] + l2[c]\n\nIf it is a Python code, it should be `l1[i]` and `l2[i]`, not `l1[i]` and `l2[i]`.\n\nYeah, my bad. I meant l1[i] and l2[i]</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted(a, b):\n        return len(a) + len(b) > 0 and sorted(a[:], b[:])\n    return sorted(l1.copy(), l2.copy())\n\nI'd be interested in reading the \"why\", if anyone has a good explanation.\nI tried to write a quick python version, and found that it's actually quite a nice exercise.\n\nI'm pretty sure this works for n lists as well, right? So the \"why\" is pretty simple -- it's a recursive call on lists, which is O(n) :)\n\nI don't think this works for n lists because of the \"sorted\" function.\nIt's not possible to sort a list of lists in O(n). It is possible to sort two lists in O(n) though.\n\nNot just two lists, any number of lists.\n\nI wrote a similar function for one of my C projects.\n\nI think that's how djb does it.\n\nSo is this where that saying came from?\n\nI think it was before the days of lists.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) > 1:\n         return [common(l1, l2) for l1 in l1]\n    return []", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def merge(l1, l2: list):\n    \"\"\"Merge the elements of l1 with l2. Return a sorted list of the\n    unique elements from both lists.\n    >>> merge([1, 2, 3, 4, 5], [6, 8, 1])\n    [1, 2, 3, 4, 5]\n    >>> merge([1, 2, 3, 4, 5], [6, 7, 8])\n    [7, 5, 6, 8]\n    >>> merge([1, 2, 3, 4, 5], [7, 8, 1])\n    [8, 1, 7, 5]\n    \"\"\"\n    return sorted(l1.iloc[0] + l2.iloc[0], key=lambda x: x, reverse=True)\n\nI don't get the point of the article. It seems to be making the point that \"duplication\" is the same as \"redundancy\", which is true but completely irrelevant to programming. Duplication is just a more specific form of redundancy, but it"]]