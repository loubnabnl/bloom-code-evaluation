[["def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    for i in l1:\n       for j in l2:\n          if j not in l1:\n                return l1[j]\n                     if i not in l2:\n                       return l2[i]\n                        return []\n    return [l1[i] for i in l1 if l1[i] not in l2 for j in l2]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1 is not None:\n         return sorted(l1, key=lambda x: x[0] or x[1] or x[2] or x[3] or x[4] or x[5], reverse=True)\n    elif l2 is not None:\n         return sorted(l2, key=lambda x: x[0] or x[1] or x[2] or x[3] or x[4] or x[5], reverse=True)\n    else:\n         return [l1[0] for l1 in l1]\n    ################################################################################\n    def sort_common(l1: list, l2: list):\n    \"\"\"Sorts two lists and returns a common sorted list of the two lists.\n    >>> sort_common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5,", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def to_common(l1, l2):\n        if len(l1)!= len(l2):\n           raise TypeError(\"The lists must have the same length.\")\n         for item in l1:\n            for item in l2:\n              if item in common(l1, l2):\n                    return common(l1, l2)\n    return list(l1)\n    def common_with_distinct(l1, l2):\n    \"\"\"Return sorted common elements for two lists.\n    >>> common_with_distinct([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [5, 653]\n    >>> common_with_distinct([5, 3, 2", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def __init__(self, l1, l2):\n        self.l1 = l1\n        self.l2 = l2\n        self.l1_end = l1.end()\n        self.l2_end = l2.end()\n        self.l1_start = l1.start()\n        self.l2_start = l2.start()\n        return self", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    # Two lists to compare\n    l1 = [1, 4, 3, 34, 653, 2, 5]\n    l2 = [5, 7, 1, 5, 9, 653, 121]\n    # Do not compare the same element more than once\n    # If the element is already in l1, do not add it again\n    # If the element is already in l2, do not add it again\n    # If the element is not in either list, add it to both\n    for e in l1:\n        if e not in l2:\n            add(e, l1)\n            add(e, l2)\n         # Only add the element to l1 if it is not already in l2\n    return sorted(l1, key=lambda x: x[1] - e[1], reverse=True)\n\nI think it's a bit too clever, but it's a", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sort(l1: list, l2: list):\n    \"\"\"Return sorted lists for two lists.\n    >>> sort([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sort([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return [l1[0] for l1 in l1, l2[0] for l2 in l2]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1.count(x) > l2.count(x):\n        return [x]\n    return [x]\nThe \"if l1.count(x) > l2.count(x)\" part is unnecessary.\n\nA more general version:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return l1.sort(l2.sort())\n\nI think it's a good idea to use the same name for the function and the module. It makes it easier to remember and understand what the function does.\n\nFor some reason I can't see the code in the article, but the gist is here:\n\nI think the title is a bit misleading. This is not a common function, it's a common module.\n\nHow does one go about using this?\n\nUse it as a function.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.intersection(l2), key=lambda x: l1[x])\n\nI'm not sure what the intent of this function is. It's not quite a merge sort, because it doesn't merge lists. It's not quite a quick sort, because it doesn't have a pivot. It's not quite a merge quick sort, because it doesn't have a merge sort.\n\nIt's a quick-sort that works on two lists, which is much faster than a merge-sort that works on two lists.\n\nIt's not a quick-sort, because it doesn't have a pivot.\nIt's not a merge quick sort, because it doesn't have a merge sort.\n\nIt does have a pivot, it's the intersection of the two lists.\n\nAh, I see. I had thought that the intersection was the pivot for the first list.\n\nI like this a lot, but I'm not sure I'm understanding it.\n\nI'm not sure I understand it either, but I can confirm that it works.\n\nI don't know what to say.\n\nI can't believe you would say that.\n\nI like the idea", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return l1.sort(key=lambdax: x[1])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.copy(), l2.copy(), key=lambda x: x[0]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return (", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return [l1[0] for l1 in l1]\n    else:\n        return [l1[0] for l1 in l1]\n    if l1[0] == l2[0]:\n        return [l1[1] for l1 in l1]\n    else:\n        return [l1[1] for l1 in l1]\n    if l1[1] == l2[1]:\n        return [l2[0] for l2 in l2]\n    else:\n        return [l2[0] for l2 in l2]\n    return [l1[2:] for l1 in l1]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return l1.sort(key=lambda x: x[0])\n   .l2.sort(key=lambda x: x[0])\n\nI don't get it. How is this useful?\n\nIt is useful when you want to sort a list and keep only the unique elements.\nFor example, say you have a list of customers with their addresses and you want to sort it by address, and then only keep the unique addresses.\nYou can do it like this:\ncustomers = [\n\t\t{\n\t\t\t\t\"firstName\": \"John\",\n\t\t\t\t\"lastName\": \"Doe\",\n\t\t\t\t\"address\": \"123 Fake St\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"firstName\": \"Jane\",\n\t\t\t\t\"lastName\": \"Doe\",\n\t\t\t\t\"address\": \"123 Fake St\"\n\t\t\t},\n\t\t\t{\n\t\t\t\t\"firstName\": \"Jane\",\n\t\t\t\t\"lastName\": \"Doe\",\n\t\t\t\t\"address\": \"123 Fake St\"", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def common_unique(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common_unique([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_unique([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> common_unique([5, 3, 2, 8], [5, 3])\n    [5, 3]\n    >>> common_unique([5, 3, 2, 8], [5, 3, 2, 8])\n    [5, 3, 2, 8]\n    >>> common_unique([5, 3, 2, 8], [5, 3, 2, 8])\n    [5, 3, 2, 8]\n    >>> common_unique([5, 3, 2, 8], [5, 3, 2, 8])\n    [", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def sorted_common(l1, l2):\n    \"\"\"Return sorted common elements for two lists.\n    >>> sorted_common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [5, 7, 1, 653]\n    >>> sorted_common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(l1.common(l2), key=lambda x,y: x[0] < y[0] for x, y in l1.items() if x, y in l2.items())\n\nfor l1, l2 in zip(l1, l2):\n    if l1.common(l2) == sorted_common(l1, l2):\n       print \"common elements are the same\"\n       return\n\nelse:\n    print \"common elements are different\"\n\nIt is worth noting that the", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def __init__(self, l1: list, l2: list):\n        self.l1 = l1\n        self.l2 = l2\n        self.l1.sort()\n        self.l2.sort()\n        self.l1.remove(0)\n        self.l2.remove(0)\n        self.l1.remove(1)\n        self.l2.remove(1)\n        self.l1.remove(2)\n        self.l2.remove(2)\n        self.l1.remove(3)\n        self.l2.remove(3)\n        self.l1.remove(4)\n        self.l2.remove(4)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.index, l2.index)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return l1.sort(key=lambda x: x[0]), l2.sort(key=lambda x: x[0])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n    \"\"\"\n    return sorted(l1.common(l2), key=lambda x: x[1])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted_common(l1: list, l2: list):\n    \"\"\"Sorted common elements for two lists.\n    >>> sorted_common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sorted_common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(l1.get_common(), key=lambda x: x in sorted(l2.get_common(), key=lambda x: x in l2.get_common()))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted_common(l1, l2):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> sorted_common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [5, 7, 1, 5, 9, 653, 121]\n    >>> sorted_common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(l1.copy(), l2.copy(), key=lambda x: x[0] == l1[0]\n        and key=lambda x: x[1] == l2[1]\n        and key=lambda x: x[2] == l1[2]\n        and key=lambda x: x[3] == l2[3]\n        and key=lambda x: x[4] == l1[4]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def __init__(self, l1, l2):\n        self.l1 = l1\n        self.l2 = l2\n        self.compare = lambda x: x[0] < x[1]\n        self.compare = lambda x: x[0] < x[1]\n        self.compare = lambda x: x[0] < x[1]\n        self.compare = lambda x: x[0] < x[1]\n        self.compare = lambda x: x[0] < x[1]\n        self.compare = lambda x: x[0] < x[1]\n        self.compare = lambda x: x[0] < x[1]\n        self.compare = lambda x: x[0] < x[1]\n        self", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    for l1 in l1:\n       for l2 in l2:\n          if l1[l2]!= l2[l1]:\n                 return []\n                  return l1[l2]\n    return []\n    \"\"\"\n\nI think it's a good exercise in python to write the function in an iterative fashion, and then write the recursive version.\n\nI think that's a good exercise for any language, but I would be more inclined to do it in an imperative language than a functional one.\n\nI think it's a good exercise for any language, but I would be more inclined to do it in an imperative language than a functional one.\n\nI think it's a good exercise for any language, but I would be more inclined to do it in an imperative language than a functional one.\n\nI think it's a good exercise for any language, but I would be more inclined to do it in an imperative language than a functional one.", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n         return sorted(l1.intersection(l2))\n\nThis is great, but I think it needs some explanation. The implementation of sorted() is:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.intersection(l2), key=lambda x: x[0] if l1[x] else l1[x] - 1)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def inner(l1, l2):\n        return (l1.index(l2)[0] for l1 in l1.index(l2)[0])\n   \n    def common(l1: list, l2: list):\n        \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    if l1.size() > l2.size():\n        return inner(l1, l2)\n    return []\n\nI was just trying to get a feel for the language. I think I'll stick to Python for now.\n\nI don't think anyone here is suggesting you should write Python in Python. It's a language for teaching", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    for i in range(0, len(l1), -1):\n        for j in range(0, len(l2), -1):\n            if l1[i] == l2[j]:\n                  return True\n                   else:\n                     return False\n    return True", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    l1.sort(key=lambda x: x[1]), l2.sort(key=lambda x: x[1])\n    l1.pop(0)\n    l2.pop(0)\n    return l1.pop(0) + l2.pop(0)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return [l1[l2[x]] for x in l1 for x in l2]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def sorted_common_elements(l1, l2):\n    \"\"\"Return sorted common elements for two lists.\n    >>> sorted_common_elements([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sorted_common_elements([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n\n    def common_sort(l1, l2):\n    \"\"\"Return sorted common elements for two lists.\n    >>> common_sort([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_sort([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n    def sort_l1(l1: list):\n    \"\"\"Return a sorted list of unique elements for l1.\n    >>> sort_l1([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    >>> sort_l1([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    \"\"\"\n    return [l1.index(l1.index(l1.index(...)) for l1 in l1 if l1.index(l1.index(...))]\n    def index(l: list):\n    \"\"\"Return the index of an element in l.\n    >>> index([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    2\n    >>> index([1,", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    # common(l1, l2):\n    # 1. If l1 and l2 are empty, return an empty list.\n    # 2. If l1 and l2 are not empty, return a list of common elements\n    # for l1 and l2.\n    # 3. Return a list of all elements of l1, followed by all elements of\n    # l2.\n    # 4. Return a list of all elements of l1, followed by all elements of\n    # l2, followed by all elements of l1.\n    # 5. Return a list of all elements of l1, followed by all elements of\n    # l2, followed by all elements of l1, followed by all elements of\n    # l2.\n    # 6. Return a list of all elements of l1, followed by all elements of\n    # l2, followed by all elements of l1, followed by all elements of\n    # l2, followed by all elements of l1, followed by all elements of", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 2, 3, 4, 5], [1, 2, 4, 3, 5])\n    [2, 3, 5]\n    >>> common([2, 3, 4, 5], [2, 3, 4, 5])\n    [2, 3, 4, 5]\n    >>> common([1, 2, 3, 4, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n    if l1 == l2:\n        return l1\n    else:\n        return l1.copy()\n    \"\"\"\n    return [l1.index(l2), l1.index(l1)]\n    \"\"\"", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n         return l1.sort(key=lambda x: x[1])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1)!= len(l2):\n        return []\n    l1.sort()\n    l2.sort()\n    return [x for x in l1 if x not in l2]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.sort(), l2.sort(), key=lambdax:x[1])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def common_for_item(l1: list, l2: list):\n    \"\"\"Return the sorted common elements for a single element in l1\n    and l2.\n    >>> common_for_item([1, 5], [5, 7])\n    [5, 7]\n    >>> common_for_item([5, 7], [1, 3])\n    [5, 7, 1]\n    \"\"\"", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def sorted_common(l1: list, l2: list):\n    \"\"\"Return sorted common elements for two lists.\n    >>> sorted_common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [5, 653]\n    >>> sorted_common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> sorted_common([3, 2, 5], [2, 3, 5])\n    [2, 3, 5]\n    \"\"\"\n\n    def unique_common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> unique_common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [5, 653]\n    >>> unique_common([5, 3, 2, 8], [3, 2])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    l1.sort()\n    l2.sort()\n    if l1.count() == l2.count():\n        return l1\n    else:\n        return l2\n\nI wonder what the performance of this would be in Python.\n\nIt's O(n^2) for the number of elements in each list, so it's probably not the best way to solve this problem.\n\nThat's not true, it's O(n log n) for the number of elements in each list.\n\nI stand corrected. I was thinking of the common element algorithm in the context of the mergesort algorithm.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def __reduce__(self, x, y):\n    \"\"\"Reduce common elements in two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n\n    return [x, y]\n\nIf you want to have an efficient implementation, you can use a hash table.\n\nIt's not clear to me that the OP is actually looking for an efficient implementation.\n\nI'm not, but I'm curious to see how other people do it.\n\nI wrote a small C program to generate all permutations of a given list. I then wrote a Python script to find the common elements between the two lists.\n\nI wrote a C program to generate all permutations of a given list. I then wrote a Python script to find the common elements between the two lists.\n\nI wrote a C program to generate all perm", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def common_part(l1, l2):\n    \"\"\"Return sorted common elements of two lists.\n    >>> common_part(['abc', 'def'], ['abc', 'ghi'])\n    ['def']\n    >>> common_part(['abc', 'def'], ['ghi', 'ghi'])\n    ['abc', 'def']\n    >>> common_part(['ghi', 'ghi'], ['abc', 'def'])\n    ['ghi']\n    >>> common_part(['ghi', 'ghi'], ['abc', 'def'])\n    ['ghi', 'ghi']\n    \"\"\"\n    # remove duplicates\n    # return sorted list of common elements\n    return sorted(l1.copy(), l2.copy(), common_part, key=lambda x: x[1])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def __lt__(l1: list, l2: list):\n    \"\"\"Return the smaller of two lists.\n    >>> l1 = [1, 2, 3]\n    >>> l2 = [1, 2, 3, 4]\n    >>> l1 < l2\n    True\n    >>> l1 < l2\n    False\n    >>> l1 > l2\n    True\n    >>> l1 > l2\n    False\n    \"\"\"\n\n    return (l1.__lt__(l2) for l1, l2 in zip(l1, l2))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    for x in l1:\n        if x not in l2:\n           return None\n        if l1[x] not in l2:\n            return x\n        if l1[x] == l2[x]:\n            return l1[x]\n    return x\nI don't see how this is better than the standard implementation.\n\nI've never seen the standard implementation, but if it is as fast as this one, then you're right, there's no point to this one.\n\nI've seen it in a few places. I don't know if it's as fast, but it's pretty fast, and it's certainly more readable.\n\nI'd like to see the performance of this implementation. I'd be willing to bet that it is slower than the standard implementation.\n\nIt is slower. But it's still faster than the version that uses the built-in \"list.sort()\" method.\n\nI'm", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.copy(), l2.copy(), key=lambda x: x[0], reverse=True)\n    def reverse(l1: list, l2: list):\n    \"\"\"Return a list with the elements of l1 sorted in reverse order.\n    >>> reverse([1, 2, 3], [5, 4, 3, 1])\n    [2, 5, 3, 1]\n    >>> reverse([1, 2, 3], [5, 4, 3, 2])\n    [3, 2, 5, 1]\n    >>> reverse([1, 2, 3], [5, 4, 3, 3])\n    [3, 5, 1, 2]\n    \"\"\"\n    return l1.copy()\n    def sort(l1: list, l2: list):\n    \"\"\"Sort the elements of l1 and l2 in ascending order.\n    >>> sort([1, 2, 3], [5, 4, 3, 1])\n    [5, 4, 3, 1]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def compare(l1, l2):\n    \"\"\"Return 0 if l1 and l2 are equal, 1 otherwise.\n    >>> compare([1, 2, 3], [1, 2, 3])\n    0\n    >>> compare([1, 2, 3], [1, 2, 3])\n    1\n    >>> compare([1, 2, 3], [1, 2, 3])\n    0\n    >>> compare([1, 2, 3], [1, 2, 3])\n    1\n    >>> compare([1, 2, 3], [1, 2, 3])\n    0\n    \"\"\"\n    return sorted(l1.split()).reduce(lambda x, y: compare(x, y), 0)\n\nThis is great for small lists, but is this really the best way to do this?\nI'm no expert, but this seems like an O(n^2) algorithm.\n\nNo, it's O(n log n).\n\nIs there a reason to not use the built-in sorted", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(common(l1, l2), key=lambda x: x[1]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def unique(l1: list, l2: list):\n    \"\"\"Return sorted unique elements for two lists.\n    >>> unique([1, 2, 3], [1, 2, 3])\n    [1, 2, 3]\n    >>> unique([1, 2, 3], [1, 2, 3, 4])\n    [1, 2, 3, 4]\n    >>> unique([1, 2, 3], [1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> unique([1, 2, 3], [1, 2, 3, 4, 5, 6])\n    [1, 2, 3, 4, 5, 6]\n    >>> unique([1, 2, 3], [1, 2, 3, 4, 5, 6, 7])\n    [1, 2, 3, 4, 5, 6, 7]\n    >>> unique([1, 2, 3], [1, 2, 3, 4, 5, 6, 7, 8])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.sort(), l2.sort(), key=lambda x: x[0] - x[1]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return [l1[0] for l1 in l1]\n    else:\n        return [l2[0] for l2 in l2]\n\nIt's not clear to me if the author is using the terms \"sorted\" and \"unique\" to mean something else than the usual meaning. The code as written doesn't appear to be sorting anything; it's just returning the first element of the list that occurs in both lists.\n\nI've never heard of \"sorted\" and \"unique\" being used in this way.\n\nIt's a very common term. For example, the standard library's \"unique\" function does this:\n\nAh, I see. Thanks for the explanation.\n\nI'm not sure if this is a serious article, but if so, the author doesn't seem to understand the meaning of the words \"sorted\" and \"unique\".\n\nIt's a joke. He's using the word \"sorted\" to mean \"in order\" and \"unique\" to mean \"the same element appears in both lists\".", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return l1\n    else:\n        return l2.sort(key=lambda x: x[0])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return l1.sort(key=lambda x: l2[x])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    # sort first list\n    # sort second list\n    if l1 == l2:\n       return [x for x in l1 if x in l2]\n    else:\n       return [x for x in l1 if x not in l2]\n    # return sorted list of common elements\n    return sorted(l1, key=lambda x: (l1[x] in l2), reverse=True)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted_common(l1, l2):\n    \"\"\"Sort the common elements of two lists and return them.\n    >>> sorted_common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [5, 1, 653]\n    >>> sorted_common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(l1.common(l2), key=lambda x: l1[x])\n\nFor those wondering, the list comprehension syntax is a syntactic sugar for a list comprehension function.\n\nI'm not sure why the OP felt the need to use list comprehension syntax for a function that takes two lists.\n\nBecause it is a lot easier to read.\n\nIs it really? I think it's a lot harder to read, and I'm a Python programmer.\n\nThe only thing that is harder to read is the name of the function.\n\nThe name of the function is the only thing harder to read?", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(set(l1), set(l2))\n    def get_common(l1: list, l2: list):\n    \"\"\"Return sorted common elements for two lists.\n    >>> get_common([1, 2, 3], [4, 5, 6])\n    [1, 4, 5, 6]\n    >>> get_common([1, 2, 3], [4, 5, 6, 7])\n    [1, 4, 5, 6, 7]\n    >>> get_common([1, 2, 3], [7, 8, 9])\n    [7, 8, 9]\n    >>> get_common([1, 2, 3], [10, 11, 12])\n    [10, 11, 12]\n    >>> get_common([1, 2, 3], [13, 14, 15])\n    [13, 14, 15]\n    >>> get_common([1, 2, 3], [16, 17, 18])\n    [16, 17, 18]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.intersection(l2), key=lambda a, b: (a, b))\n\nI like this implementation. I'd be interested in seeing how the performance compares to the one in the article.\n\nHere is an implementation of the algorithm in Python (using itertools.product). I tested it on a list of length 1000000 and it took 0.0013 seconds.\nimport itertools", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def __init__(self):\n        self.l1 = l1\n        self.l2 = l2\n        self.l1.sort()\n        self.l2.sort()\n        self.common = []\n\n    def sort(self, key):\n        if key not in self.l1:\n           self.l1.insert(key)\n           self.l1.sort()\n        return self.l1\n        if key not in self.l2:\n           self.l2.insert(key)\n           self.l2.sort()\n        return self.l2\n\n    def remove(self, key):\n        if key in self.l", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.common(l2), key=lambda a: a[0], reverse=True)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def in_common(x: list, y: list):\n    \"\"\"Return True if x and y have at least one element in common.\n    >>> in_common([1, 2, 3, 4, 5], [2, 3, 4])\n    True\n    >>> in_common([1, 2, 3, 4, 5], [3, 2, 4])\n    False\n    >>> in_common([1, 2, 3, 4, 5], [1, 2, 3, 4])\n    False\n    >>> in_common([1, 2, 3, 4, 5], [5, 6, 7, 8, 9])\n    False\n    >>> in_common([1, 2, 3, 4, 5], [1, 2, 3, 4, 5])\n    True\n    \"\"\"\n    return sorted(l1.items(), key=lambda x: x in l2.items(), reverse=True)\n\nI love Python, but this is a fairly contrived example.\nI'd be interested in seeing", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    l1.sort(key=lambda x: x[0])\n    l2.sort(key=lambda x: x[0])\n    return [l1[i] for i in l1 if l1[i] not in l2 else l2[i]]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n    if len(l1) == 0:\n       return []\n    else:\n       return l1[0]\n    if len(l2) == 0:\n       return []\n    else:\n       return l2[0]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    for i in range(len(l1)):\n        for j in range(len(l2)):\n           if l1[i] == l2[j]:\n               return\n               elif l1[i] in l2[j]:\n                 return\n                else:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted(l1, l2):\n    \"\"\"Sort the elements of the first list and return them.\n    >>> sorted([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sorted([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    if len(l1) == len(l2):\n        return sorted(l1)\n    else:\n        return sorted(l2)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.index, l2.index, key=lambda x: x[0] + x[1], reverse=False)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.intersection(l2), key=lambda x: x[0] == l2[0])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def __init__(self, l1: list, l2: list):\n    \"\"\"Create a new common() object.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    >>> common([5, 7, 1, 5, 9, 653, 121], [3, 2])\n    >>> common([5, 3, 2, 8], [3, 2])\n    >>> common([5, 3, 2, 8], [5, 3])\n    >>> common([5, 3, 2, 8], [5, 7])\n    >>> common([5, 3, 2, 8], [5, 9])\n    >>> common([5, 3, 2, 8], [5, 5])\n    >>> common([5, 3, 2, 8], [5, 5, 7, 1])\n    >>> common([5, 3, 2, 8], [5, 5, 7, 1, 9])\n    >>> common([5", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return l1\n    else:\n        return l1.sort(key=lambda x: x[0])\n        l2\n\nI don't see the problem here. I think the solution is pretty straightforward.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.common(l2), key=lambda a, b: a[1] < b[1])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(common(l1, l2), key=lambda l1: l1[1], reverse=True)\n\nI've never used Python, but I'm pretty sure that's not what the OP was asking.\n\nIt's pretty close.\n\nI've never used Python. I've used Lisp, Scheme, Haskell, C, C++, Java, and a few others. I don't know what Python does.\n\nThis is the Python version of the algorithm:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted(l1, l2):\n    \"\"\"Return a list of unique common elements for two lists.\n    >>> sorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8])\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    >>> sorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [3, 5, 7, 8])\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    >>> sorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [7, 8, 9, 10])\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    >>> sorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [2, 5, 8, 9])\n    [1, 2, 3, 4", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.items(), key=lambda l1: l1[0], reverse=True)\n   .sort(key=lambda l1: l1[1])\n   .reverse()\n   .sort(key=lambda l2: l2[0])\n   .reverse()", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sort_common(l1: list, l2: list):\n    \"\"\"Return sorted common elements for two lists.\n    >>> sort_common([1, 2, 3, 4, 5, 6], [1, 2, 3, 5])\n    [1, 2, 3, 5]\n    >>> sort_common([1, 2, 3, 4, 5, 6], [2, 3, 4, 5, 6])\n    [1, 2, 3, 5]\n    >>> sort_common([1, 2, 3, 4, 5, 6], [4, 5, 6, 3, 2])\n    [1, 2, 3, 5]\n    >>> sort_common([1, 2, 3, 4, 5, 6], [3, 4, 5, 6, 1])\n    [1, 2, 3, 5]\n    >>> sort_common([1, 2, 3, 4, 5, 6], [6, 2, 3, 4, 5])\n    [1, 2, 3, 5]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return l1.sort(key=lambda x: x[0] < l2[0])\n   .filter(lambda x: x[1])\n   .flatMap(lambda x: x[0], lambda y: y[0])\n   .sort(key=lambda x: x[0])\n   .filter(lambda x: x[1])\n   .flatMap(lambda x: x[0], lambda y: y[0])\n   .sort(key=lambda x: x[0])\n   .filter(lambda x: x[1])\n   .flatMap(lambda x: x[0], lambda y: y[0])\n   .sort(key=lambda x: x[0])\n\nIs there a good reason to use \"flatMap\" instead of \"map\"?\n\nThe flatMap is used to create a new list with the sorted common elements.\n\nWhy not just return a list of the sorted common elements?\n\nBecause it's a common function that can be used for any two lists.\n\nThe common function is not used", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sort(l1: list, l2: list):\n    \"\"\"Return sorted common elements for two lists.\n    >>> sort([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sort([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sort(l1, l2)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sort_common(a, b):\n       return sorted(a, key=lambda x: x[0])\n   \n    def common(l1: list, l2: list):\n       return sorted(l1.keys(), key=lambda x: x[0])\n   \n    return common\n\nThis is a common pattern in Python. It's also very easy to do in Python with lists.", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.common(l2), key=lambda x: x[0])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return l1.sort(key=lambda x: x[0] if x else x[1])\n   .l2.sort(key=lambda x: x[0] if x else x[1])\n   .keys()", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def sorted(l1: list, l2: list):\n    \"\"\"Return sorted common elements for two lists.\n    >>> sorted([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [5, 7, 1, 5, 9, 653, 121]\n    >>> sorted([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n\n    def common_with_duplicates(l1: list, l2: list):\n    \"\"\"Return sorted common elements for two lists.\n    >>> common_with_duplicates([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_with_duplicates([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1 == l2:\n       return []\n    for i in range(len(l1)):\n        if l1[i] == l2[i]:\n            return [l1[i]]\n    return [l1[i] for i in l1]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def __init__(self, l1, l2):\n        self.l1 = l1\n        self.l2 = l2\n        self.common = []\n        self.common.append(l1.pop())\n        self.common.append(l2.pop())\n    return self.common", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n    if len(l1) == 0:\n        return []\n    else:\n        l1.sort()\n        for i in l1:\n             if l1[i]!= l2[i]:\n                 l1[i] = l2[i]\n                return l1", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    l1 = l1.copy()\n    l2 = l2.copy()\n    l1.sort()\n    l2.sort()\n    return l1.union(l2)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1 == l2:\n        return l1\n    if len(l1) > len(l2):\n        return [l1[0] for l1 in l2]\n    if len(l1) == len(l2):\n        return [l2[0] for l2 in l1]\n    return [l1[0] for l1 in l2]\n\nHere is a solution in Python:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted_common(l1, l2):\n    \"\"\"Sort the lists and return the common elements.\n    >>> sorted_common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sorted_common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(common(l1, l2))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.sort(key=lambda x: x[1]), l2.sort(key=lambda x: x[1]))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) > len(l2):\n       return []\n    else:\n       return l1[0] + l2[0]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1.count() == 0:\n        return []\n    else:\n        for i in l2:\n            if i in l1:\n                return l1[i]\n          else:\n               return l2[i]\n    return l1\nThis is a slightly better approach than the one I proposed, but you still need to be careful with the order of the calls.</s>", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.common(l2), key=lambda x: l2[x])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return []\n    else:\n        return l1.union(l2)\n\nCommon Lisp (http://www.lisp.org/) has this as a built-in function.\n\nI've always liked this one:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def __iter__(self):\n        return sorted(l1.pop(), key=lambda item: item[0] for item in self.__dict__.items())\n    def __repr__(self):\n        return \"%s (%s)\" % (self.__class__.__name__, self.__class__.__method__)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.copy(), l2.copy(), key=lambdax:x[0])\n    if l1.length == l2.length\n    else sorted(l1.copy(), l2.copy(), key=lambdax:x[0])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return l1\n    else:\n        return l1, l2", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(set(l1, l2)), set(l1.union(l2), l2.union(l1))\n    def common_unique(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common_unique([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_unique([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1, l2)), set(l1.union(l2), l2.union(l1))\n\nThis is the second time I've seen a list comprehension called \"Pythonic\", and I've got to say, I don't get it.\nIt's a neat trick, but it's hardly unique to Python, and I don't see how it's any more \"Pythonic\" than the standard for-loop.", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1.count() == l2.count():\n        return l1\n    else:\n        return l2\n\n>>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n[1, 5, 653]\n>>> common([5, 3, 2, 8], [3, 2])\n[2, 3]\n\nI think the first one is better. The second one seems to be returning the same value for all the input lists.\n\nI think the first one is better. The second one seems to be returning the same value for all the input lists.\n\nThe first one is better. The second one seems to be returning the same value for all the input lists.\n\nThe first one is better. The second one seems to be returning the same value for all the input lists.\n\nThe first one is better. The second one seems to be returning the same value for all the input lists.\n\nThe first one is better. The second one seems to be returning the same value for all", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def __lt__(l1: list, l2: list):\n    \"\"\"Return the smaller of two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    def __le__(l1: list, l2: list):\n    \"\"\"Return the least of two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    def __ge__(l1: list, l2: list):\n    \"\"\"Return the", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.index(l2) for l1 in l1.iloc[0], l2 in l2.iloc[0])\n    if l1.index(l2) == -1 or l1.index(l2) == l2.index(l1)\n        # there is no common element\n    else:\n        # there is a common element\n        return sorted(l1.index(l2) for l1 in l1.iloc[1], l2 in l2.iloc[1])\n    else:\n        # there is no common element\n        return []\n    # If there is a common element, return it.", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def common_unique(l1, l2):\n    \"\"\"Return sorted common unique elements for two lists.\n    >>> common_unique([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_unique([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    for c in l1:\n       if c in l2:\n          return True\n    return False\n\n    def common_unique_list(l1, l2):\n    \"\"\"Return sorted common unique elements for two lists.\n    >>> common_unique_list([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_unique_list([5,", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sort_common(l1, l2):\n       \"\"\"Return a sorted list of common elements for two lists.\n    >>> sort_common([1, 2, 3], [1, 2, 3])\n    [1, 2]\n    >>> sort_common([1, 2, 3], [3, 4, 5])\n    [2, 3]\n    \"\"\"\n    return l1.sort(key=lambda x: x[0] - l2[0], reverse=True)\n\nThis isn't a bad solution, but it's not the best. It will work, but it's O(n)\nwhereas it could be O(logn) or even O(nlogn).\n\nHere's a solution that will work in O(logn).", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    for i in range(0, len(l1)):\n        for j in range(0, len(l2)):\n           if l1[i][j]!= l2[i][j]:\n                  # Not in common\n                      # Common\n                          # Not in common\n                             # Common\n                              # Not in common\n                                 # Common", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    l1.sort()\n    for c in l1:\n       if l2.has_key(c):\n           return l2[c]\n    return []\n\nI have a similar function, but it returns the last item in the list if it's not in the second list:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return l1\n    else:\n        return sorted(l1, key=lambda item: l2[item])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted(l1, l2):\n    \"\"\"Return sorted list of common elements for two lists.\n    >>> sorted([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sorted([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    for x in l1:\n    for y in l2:\n      if x not in l2:\n         return sorted(l1, l2)\n      else:\n         return sorted(l1, l2, key=x)\n\nIt's really simple but it's not the fastest way.\n\nThe fastest way is to use a hash table to store the common elements.", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.index(l2), key=lambda x: x.isnull()):", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == 0:\n       return l2\n    if len(l2) == 0:\n       return l1\n    else:\n       return l1.sort(key=lambda x: x[0])\n   .sort(key=lambda x: x[1])\n\nThis is the same as:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return l1\n    else:\n        return l1.copy()\n    def unique(l1: list, l2: list):\n    \"\"\"Return sorted unique elements for two lists.\n    >>> unique([1, 2, 3, 4], [3, 4, 1, 2])\n    [1, 2]\n    >>> unique([1, 2, 3, 4], [3, 4])\n    [1, 2, 3]\n    >>> unique([1, 2, 3, 4], [3])\n    [1, 2, 3]\n    >>> unique([1, 2, 3, 4], [4])\n    [1, 2, 3]\n    >>> unique([1, 2, 3, 4], [4, 5])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    if l1.count(i) == l2.count", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n       return sorted(l1, key=lambdax: x[0] in l2)\n    else:\n       return sorted(l1, key=lambdax: x[0] in l1)\n    return sorted(l2, key=lambdax: x[0] in l1)\n\nThere's no need for a function to return sorted lists. The following code\ndoes the same thing:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sort(l1, l2):\n        for item in l1:\n           for item in l2:\n              if item in l1:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted_common(l1, l2):\n    \"\"\"Sorted unique common elements for two lists.\n    >>> sorted_common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sorted_common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(set(l1), set(l2))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n    return sorted(l1.sort(), l2.sort())", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.index, l2.index)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.pop, l2.pop)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1 == l2:\n        return l1\n    else:\n        return common(l1, l2)\n\nThis is a really nice and simple example of a common operation. I hope that in the future, Python will have a common function which is based on this one.\n\nThis is an awesome idea! I've seen a few other languages have this, but I can't remember which ones.\n\nRuby:\n[]\n\nI was thinking more of the following:\n[1, 2, 3, 4, 5] # [1, 2, 3]\n[1, 2, 3, 4, 5] # [2, 3, 4, 5]\n[1, 2, 3, 4, 5] # [4, 5]\n[1, 2, 3, 4, 5] # [5]\n[1, 2, 3, 4, 5] # [5]\n[1, 2, 3, 4, 5] # [5]\n[1, 2, 3, 4, 5] # [5]\n[1, 2, 3, 4,", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return l1\n    else:\n        return l2[0]\n\nI think you mean to say \"return l1\".\n\nI don't know Python, but I assume the 'else' in the function body is equivalent to a'return' in C? If so, then it seems to me that the else is just a typo.\n\nThe else is a return.\n\nIt's just a typo.\n\nI don't know Python, but in Ruby, that would be \"return l2[0]\".\n\nI don't know Python, but in Ruby, that would be \"return l2[0]\".\n\nI don't know Python, but in Ruby, that would be \"return l2[0]\".\n\nI don't know Python, but in Ruby, that would be \"return l2[0]\".\n\nI don't know Python, but in Ruby, that would be \"return l2[0]\".\n\nI don't know Python, but in Ruby, that would be \"return l2[", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return l1.sort(key=lambda x,y: x.compare(y))\n   .map(lambda x: l2.sort(key=lambda x,y: x.compare(y)))\n   .filter(lambda x: x in l1)\n   .filter(lambda x: x in l2)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def sort(l1: list, l2: list):\n    \"\"\"Return sorted common elements for two lists.\n    >>> sorted(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]),\n    [5, 653])\n    [5, 653]\n    >>> sorted(common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n\n    \"\"\"Computes the common elements for two lists.\n    \"\"\"\n\n    \"\"\"Returns a sorted list of the common elements for two lists.\n    \"\"\"\n\n    if len(l1)!= len(l2):\n        raise ValueError(\"The two lists are not the same length.\")\n   \n    if len(l1) == len(l2):\n        return l1\n   \n    for i in range(len(l1)):", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.indexed(l2) for l1, l2 in zip(l1, l2))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return l1\n    else:\n        return [l1[0] for l1 in l1]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def uniq(l1: list, l2: list):\n    \"\"\"Return sorted unique elements for two lists.\n    >>> uniq([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> uniq([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(l1.split(','), key=lambda x: x[1])\n   .sort(key=lambda x: x[1])\n   .uniq(l2)\n\nThis is not a very good solution.\n\nThe code is too long, and the algorithm is inefficient. It is much better to use a \"reduce\" function.", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    # The two lists to compare.\n    l1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    l2 = [5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]\n    # This function is not in the Python standard library.\n    def common(l1, l2):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    # Sorting the lists.\n    l1.sort()\n    l2.sort()\n    # This function is not in the Python standard library.", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.common(l2), key=lambda x: x[0])\n\nThis is really the right answer. The problem is that you are using a builtin function to do a task that it is not suited for.\nThe builtin function common is for finding the common elements between two lists. The builtin function sorted is for sorting a list. You are trying to use a sorting algorithm to find the common elements between two lists.\n\nI had a feeling that was the case.\nI was hoping there was a way to get the sorted list, then use the common method on the sorted list.\nI guess I should have known better.\n\nI don't think there is a way to get the sorted list, but I do think there is a way to sort the list using the builtin function sorted.\n\nIn Python, I would use this:\nimport itertools", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted(l1, l2):\n    \"\"\"Sorted list of unique common elements for two lists.\n    >>> sorted(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sorted(common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    if len(l1) == len(l2):\n       return l1\n    for l1, l2 in zip(l1, l2):\n       if l1[0] == l2[0]:\n          return sorted(l1, l2)\n    return []\n    return sorted(l1, l2)\n\nimport itertools", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def __cmp__(a, b):\n        return a[0] < b[0] and a[1] < b[1] and a[2] < b[2] and...\n        a[n-1] < b[n-1]\n        if a[0] == b[0]:\n           return a[0] < b[0]\n        return common(l1, l2)\n\nIt's interesting to note that this is essentially the algorithm that the C++ standard library uses to sort an std::vector<int> by value. It uses a single function, std::sort(), which calls itself recursively on a set of elements, and returns the smallest of the two values in the sorted vector.\n\nThe difference is that the C++ standard library sorts by value, which is O(n log n). This is O(n) in the number of items.\n\nHow is it O(n) when it's O(n log n) for a single element?", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"return sorted(l1.copy(), l2.copy(), key=lambda x: x[0], reverse=True)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1)!= len(l2):\n        return []\n    else:\n        return [l1[0] for l1 in l1]\n    def shuffle(l1: list, l2: list):\n    \"\"\"Return a new list which is a permutation of the two input lists.\n    >>> shuffle([1, 2, 3, 4, 5, 6], [1, 2, 3, 4, 5, 6])\n    [1, 4, 2, 5, 3, 6, 5, 3, 4, 6]\n    >>> shuffle([1, 2, 3, 4, 5, 6], [2, 3, 1, 4, 5, 6, 1])\n    [1, 4, 2, 5, 3, 6, 5, 3, 4, 6, 1]\n    >>> shuffle([1, 2, 3, 4, 5, 6], [3, 2, 1, 4, 5, 6, 1])\n    [1, 4, 2, 5,", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted(l1, l2):\n    \"\"\"Sort two lists and return the common elements.\n    >>> sorted([1, 2, 3, 4], [1, 2, 3, 4])\n    [1, 2, 3, 4]\n    >>> sorted([1, 2, 3, 4], [1, 2, 3, 4, 5, 6, 7])\n    [1, 2, 3, 4, 5, 6, 7]\n    >>> sorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    >>> sorted([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13])\n    [1, 2, 3", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1.count() == l2.count():\n        return l1\n    else:\n        return [l1[0] for l1 in l1 if l1[0] in l2 else None for l2 in l2]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    return sorted(l1.filter(lambda x: x in l2), key=lambda x: x[1])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.copy(), l2.copy(), key=lambda x: x[0])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted_unique(l1: list, l2: list):\n    \"\"\"Return sorted unique elements for two lists.\n    >>> sorted_unique([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [5, 1, 653]\n    >>> sorted_unique([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    if len(l1) == len(l2):\n       return []\n    if l1[0] in l2:\n       return l1[1:]\n    if l1[0] not in l2:\n       return []\n    return sorted_unique(l1, l2)\n    def common_unique(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common_unique([1, 4", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n    \"\"\"\n    def __init__(self, l1: list, l2: list):\n        self.l1 = l1\n        self.l2 = l2\n\n    def compare(self, l1, l2):\n        \"\"\"Compare two lists and return a sorted list of the elements\n        in the first list that are not in the second list.\n        If one of the lists is empty, return the other list.\n        If both lists are empty, return an empty list.\n        If the lists are equal, return an empty list.\n        \"\"\"\n        if l1.size()!= l2.size():\n           raise TypeError(\"Lists must have the same number of elements\")\n           return l1\n        if l2.size", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted(l1: list, l2: list):\n    \"\"\"Sort l1 and l2, then return the sorted unique common elements.\n    >>> sorted([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sorted([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    return sorted(l1, l2)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1.length() > l2.length():\n        return l1\n    else:\n        return l2\n\nThis is a very common operation, and a very common mistake. The problem is that you can't just compare the lengths of the two lists, because they may not be the same length.\nThe correct way to do this is to write a function that takes two lists, and returns the set of elements that are common between them.\nHere's a correct version:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == 0:\n        return []\n    else:\n        return sorted(l1.items(), key=lambda x: x[0] - l1[0])\n    elif len(l2) == 0:\n        return []\n    else:\n        return sorted(l2.items(), key=lambda x: l2[0] - l2[0])\n\nI think it's a bit ironic that the standard library for the language with a reputation for being the most readable has such a messy function.\n\nI think it's a bit ironic that the standard library for the language with a reputation for being the most readable has such a messy function.\nI agree. If Python is the most readable language, why does the Python community need to create a function to return the unique common elements from two lists?\n\nBecause it's not the most readable language, and that's what this whole thread is about.\n\nNo, it's the most readable language.\n\nNo, it's the most readable language", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def merge(x: list, y: list):\n    \"\"\"Return sorted common elements for two lists.\n    >>> merge([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> merge([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return [x[0] for x in l1 if not x[0] in l2 else x[0] for x in l2 if not x[0] in l1]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1.count()!= l2.count():\n        raise Exception(\"Two sorted lists must be used.\")\n    if l1 == l2:\n        return l1\n    common = []\n    for i in range(l1.count()):\n        for j in range(l2.count()):\n           if l1[i] == l2[j]:\n              common.append(l1[i], l2[j])\n              l1.pop(i)\n             l2.pop(j)\n    return common", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return l1.sort(key=lambda x: l2[x])\n   .map(lambda x: l2[x], key=lambda x: l1[x])\n   .filter(lambda x: l1[x], key=lambda x: l2[x])\n   .sorted()\nI think this is more idiomatic (and clearer):", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted(l1, l2):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> sorted([1, 2, 3, 4, 5, 6, 7], [1, 2, 3, 4, 5, 6, 7])\n    [2, 3, 5, 6, 7]\n    >>> sorted([1, 2, 3, 4, 5, 6, 7], [2, 3, 5, 6, 7, 8])\n    [2, 3, 5, 6, 7, 8]\n    \"\"\"\n    return sorted(l1.extend(l2), key=lambda x, y: x[0] < y[0])\n\nNice. This is actually a really good way to implement a common function.\n\nI'm not sure what you mean by \"implement a common function\", but I like this implementation because it doesn't assume anything about the lists. It's just a pure function that takes two lists as arguments and returns a list of sorted unique common elements.\n\nI'm not sure what the author means by \"implement a common function\", but", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.index, l2.index)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(common(l1, l2), key=lambda x: x[0])\n\nI'm not sure if this is a good idea. If you are trying to find the common elements, you would do better to use the default comparison function:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(set(l1), set(l2))\nThis is an implementation of the quicksort algorithm.\n\nSo, how long until someone makes a version that uses the mergesort algorithm?\n\nI think that the mergesort algorithm is probably a little more complicated than the quicksort algorithm.\n\nI can't tell if this is a joke or not.\n\nI think it is a joke.\n\nHow about a version that uses the insertion sort algorithm?\n\nI think that the insertion sort algorithm is probably a little more complicated than the quicksort algorithm.\n\nI can't tell if this is a joke or not.\n\nI think it is a joke.\n\nHow about a version that uses the bubble sort algorithm?\n\nI think that the bubble sort algorithm is probably a little more complicated than the quicksort algorithm.\n\nI can't tell if this is a joke or not.\n\nI think it is a joke.\n\nHow about a version that uses the insertion sort algorithm?\n\nI think that the insertion sort algorithm is probably a little more complicated than the quicksort algorithm.\n\nI can't tell if this is a joke", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return (l1.index(l2) < l1.index(l1.end())) and\n    (l2.index(l1) < l2.index(l2.end()))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def is_common(l1, l2):\n    \"\"\"Return True if l1 and l2 have common elements.\n    >>> is_common(['1', '2', '3'], ['1', '2'])\n    True\n    >>> is_common(['1', '2', '3'], ['2', '1'])\n    False\n    \"\"\"\n    return sorted(l1.copy(), l2.copy(), key=lambda x: x[0] in l1.copy(), reverse=True)\n    and len(l1.copy()) == len(l2.copy())\n\nI don't understand the downvotes. This is a pretty good implementation of the common function. The only thing I would do differently is to make the function take two iterables as parameters.\n\nI think the downvotes are because the OP wanted an algorithm that would run in linear time.\n\nI think the downvotes are because the OP's question is ambiguous.\n\nI think the downvotes are because the OP's question is vague.\n\nI think the downvotes are", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sort(l1, l2):\n    \"\"\"Sorts two lists and returns a new list containing the common elements.\n    >>> sort([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653, 121]\n    >>> sort([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return [l1[x] for x in l2 if x not in l1]\n\nPython implementation:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return [l1[i] for i in l1]\n    else:\n        return [l2[i] for i in l2 if not common(l1, l2[i]))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    if len(l1) == len(l2):\n        return\n    else:\n        return sorted(l1.copy(), l2.copy())\n\nSo I'm not sure what's going on here.  I'm sure this is obvious to other people, but it's not to me.  I've never heard of the \"copy\" function, and I don't really understand what it's doing.  How is this any different than:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> sorted([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sorted([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    def unique(l1: list, l2: list):\n    \"\"\"Return unique elements for two lists.\n    >>> unique([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> unique([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.index(l2), key=lambda x, y: x < y)\n    def unique(l1: list, l2: list):\n    \"\"\"Return sorted unique elements for two lists.\n    >>> unique([1, 2, 3, 4, 5], [1, 2, 3, 4, 5])\n    [1, 2, 3]\n    >>> unique([1, 2, 3, 4, 5], [1, 4, 5])\n    [1, 2, 3]\n    >>> unique([1, 2, 3, 4, 5], [2, 3, 4, 5])\n    [1, 2, 3]\n    >>> unique([1, 2, 3, 4, 5], [2, 4, 5])\n    [1, 2, 3]\n    \"\"\"\n    return sorted(l1.index(l2), key=lambda x, y: x < y)\n\nThe above code is a variation of the classic bubble sort, using the indexes of the list elements to compute", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def common(l1, l2):\n    \"\"\"Return sorted common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    if len(l1) == len(l2):\n       return l1\n    return sorted(l1.index, l2.index)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"Returns a list of unique elements from the first list that are also in the\n    second list. If the first list is empty, this function returns a list of\n    all elements from the second list.\n    >>> common([1, 2, 3], [])\n    [1, 2, 3]\n    >>> common([], [1, 2, 3], [])\n    [1, 2, 3]\n    >>> common([1, 2, 3], [], [1, 2, 3], [])\n    [1, 2, 3]\n    \"\"\"\n    # No need to recurse on empty lists\n    if l1: len(l1) == 0:\n        return [l2]\n    for i in range(l1.length):\n        if l2: i in l2:\n           return [l1[i] for i in l1]\n    return []", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1 is None:\n       return []\n    else:\n       l2 = [:]\n       for i in l1:\n          if l2[i] is not None:\n               l2[i] = l2[i] + l1[i]\n               l2.append(l1[i])\n           return l2\n\nI think the author should be encouraged to use a list comprehension.\n\nThis is a common pattern in Python.\nIt's a big reason why the language is so popular. It's quick, easy, and readable.\n\nThis is also a common pattern in many other languages.\n\nAgreed. I was just responding to the comment that this is a pattern in Python.\n\nIt's not a pattern in Python. It's a feature.\n\nIt's a pattern in Python. It's a feature in many other languages.", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1 is not None:\n        return l1.sort()\n    if l2 is not None:\n        return l2.sort()\n    return l1.union(l2)", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.intersection(l2), key=lambda x: x[0])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"\n    \"\"\"", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1 == l2:\n       return []\n    if len(l1) > len(l2):\n       return [l1[0]]\n    if len(l1) == len(l2):\n       return l1\n    for x in l1:\n       if x in l2:\n          return l2[x]\n    return [l1[1:] if l1[1:]!= l2[1:] else l2[1:] for l2 in common(l1, l2)]\n\nI've been doing this for a long time in Python. The best part is that it's idiomatic.\n\nI like this version better. It's less verbose and easier to read.\n\nI think you mean:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return []\n    return l1[0] + l2[0]\n\nI don't like the fact that it doesn't preserve the original order of the elements.\n\nThe function's name is \"common\". The function's purpose is to return the \"common\" elements.\nIf you want the original order, use the builtin \"in\".\n\nThe function's name is \"common\". The function's purpose is to return the \"common\" elements.\nIf you want the original order, use the builtin \"in\".\n\nThe function's name is \"common\". The function's purpose is to return the \"common\" elements.\nIf you want the original order, use the builtin \"in\".\n\nThe function's name is \"common\". The function's purpose is to return the \"common\" elements.\nIf you want the original order, use the builtin \"in\".\n\nThe function's name is \"common\". The function's purpose is to return the \"common\" elements.\nIf you want the original order, use the builtin \"in\".\n\nThe function", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def is_sorted(l1, l2):\n    \"\"\"Return True if l1 and l2 are sorted lists.\n    >>> is_sorted([1, 2, 3, 4])\n    True\n    >>> is_sorted([1, 2, 3, 4, 5, 6, 7, 8])\n    False\n    \"\"\"\n    return sorted(l1.items(), l2.items())\n\nI think this is a very neat solution. I was just looking at the Python solution and was thinking \"I wonder if there's a way to do this in Ruby\".\n\nI don't understand why this is so hard.\n\nIt's not hard. It's just not as straightforward.\n\nI don't understand why it's not as straightforward.\n\nI don't understand why it's not straightforward that it's not straightforward.\n\nI don't understand why it's not straightforward that it's not straightforward that it's not straightforward.\n\nI don't understand why it's not straightforward that it's not straightforward that it's not straightforward.\n\nI don't understand why it's not straightforward", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1[0]!= l2[0] or l1[0] == l2[0]:\n        raise TypeError(\"l1 and l2 must have the same first element\")\n    if l1[1]!= l2[1] or l1[1] == l2[1]:\n        raise TypeError(\"l1 and l2 must have the same second element\")\n    sorted = sorted(l1, key=lambda x: x[0])\n    sorted.sort(key=lambda x: x[1])\n    sorted.remove(l1[0])\n    sorted.remove(l2[0])\n    return sorted", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.copy(), key=lambda x: x[0], reverse=True)\n   .copy()\n   .sort()\n   .reverse()\n   .copy()\n   .sort()\n   .reverse()\n   .copy()\n   .sort()\n   .reverse()\n   .copy()\n   .sort()\n   .reverse()\n   .copy()\n   .sort()\n   .reverse()\n   .copy()\n   .sort()\n   .reverse()\n   .copy()\n   .sort()\n   .reverse()\n   .copy()\n   .sort()\n   .reverse()\n   .copy()\n   .sort()\n   .reverse()\n   .copy()\n   .sort()\n   .reverse()\n   .copy()\n   .sort()\n   .reverse()", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.common(l2), key=lambda x: x[0])\n    def unique(l1: list, l2: list):\n    \"\"\"Return unique elements for two lists.\n    >>> unique([1, 2, 3, 4, 5, 6, 7, 8, 9], [2, 7, 8])\n    [2, 7]\n    >>> unique([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 7, 8])\n    [2, 7]\n    >>> unique([1, 2, 3, 4, 5, 6, 7, 8, 9], [8, 9])\n    [8, 9]\n    \"\"\"\n    return sorted(l1.unique(l2), key=lambda x: x[0])\n\nPython is such a beautiful language.\n\nI was really impressed when I first saw this. It's an interesting way to think about it.\n\nI would use this instead of common: \n\nI don't think they're comparable. common", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def __lt__(self, other):\n    \"\"\"Return -1 if other is less than this list, 0 otherwise.\"\"\"\n\n    return (other.index() < self.index())\n\n    def __gt__(self, other):\n    \"\"\"Return 1 if other is greater than this list, 0 otherwise.\"\"\"\n\n    return (other.index() > self.index())\n\n    def __le__(self, other):\n    \"\"\"Return -1 if other is less than or equal to this list, 0 otherwise.\"\"\"\n\n    return (other.index() <= self.index())\n\n    def __ge__(self, other):\n    \"\"\"Return 1 if other is greater than or equal to this list, 0 otherwise.\"\"\"\n\n    return (other.index() >= self.index())\n\n    def __eq__(self, other):\n    \"\"\"Return 1 if this list equals other, 0 otherwise.\"\"\"\n\n    return (other.index() == self.index())\n\n    def __ne__(self, other):", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(set(l1), set(l2))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    for item in l1:\n       if item in l2:\n          return item\n    return []\n    # define common\n\nPython 3.2.3 (default, Feb 8 2012, 17:44:47)\n[GCC 4.6.3] on linux2\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n[1, 5, 653]\n>>> common([5, 3, 2, 8], [3, 2])\n[2, 3]\n\nI'm not sure why this is being downvoted. The OP's code is not Pythonic, but the code in the comment is.\n\nThe OP's code is in fact Pythonic. It's just not idiomatic.\n\nThe OP's code is not idiomatic either.\n\nWhat's wrong with this code?", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(set(l1), set(l2))\n\nI'm a bit confused about the usage of sorted. The documentation says:\n\"The sorted function sorts the elements of a list in place, in lexicographic order.\"\nBut it appears to be sorting the elements of both lists at the same time, rather than the elements of one list in place of the other.\n\nThe set function returns a list of all the elements that are in both lists.\n\nSo the sorted function is doing a second sort on that list?\n\nIt's doing a second sort on a list of all the elements that are in both lists.\n\nThis is a great example of why I love Python. You can read the code and understand it immediately.\n\nI'm not sure if I agree with that. I'm still not sure what this does.\n\nIt's a function that takes two lists, and returns a list of the elements that are in both.\n\nI think it's a function that takes two lists, and returns a sorted list of the elements that are in both.\n\nI'm not sure if I agree with that. I'm still not sure what this does.\n\nIt's", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    # Sort the lists, then return the common elements.\n    # Note: this is not the way the built-in sort function works.\n    l1.sort(key=lambda x: x[1], reverse=True)\n    l2.sort(key=lambda x: x[1], reverse=True)\n    return [x for x in l1 if x not in l2]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return (\n         if l1.count(x) > l2.count(x):\n             return [l1[x], l2[x]]\n        else:\n             return l1.intersection(l2)\n\nI'm not sure what you're trying to do, but this is not the right way to do it.\nThe right way to do it is to take a look at the source code for the built-in `common`.\n\nIt's a common way to do it. I'm not sure why you would want to use the built-in when you can write it yourself in a fraction of the time.\n\n\"common\" is a built-in function in Python.\n\nI'm aware of that. I'm saying that the common built-in is slower than the solution I posted.\n\n_sigh_\n_common_ is a built-in function in Python.\n\nI'm aware of that. I'm saying that the common built-in is slower than the solution I", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def sorted(l1: list, l2: list):\n    \"\"\"Return sorted common elements for two lists.\n    >>> sorted(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121]),\n         [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sorted(common([5, 3, 2, 8], [3, 2]), [3, 2])\n    [2, 3]\n\n    \"\"\"\n\n    def common(l1: list, l2: list):\n    \"\"\"Return sorted common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(set(l1), set(l2))\nThis is more complicated than it needs to be.  The first example can be written as:\ncommon([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n[1, 5, 653]\nThe second example can be written as:\ncommon([5, 3, 2, 8], [3, 2])\n[2, 3]\nThis is not only easier to read, it's also faster.\n\nI agree, I don't think the author was trying to be efficient though.\n\nI'm not sure how you can do this without resorting to a heap or a tree.\n\nI think you can do it with a simple stack.\n\nThe algorithm in the article is a stack, which is a heap with a fixed maximum size.\n\nI'm a little confused by this statement:\n\"I think it's a mistake to use the term \"heap\" to refer to an arbitrary collection of things that is sorted by some ordering. \"\nIs there another term for this type of collection?\n\nA heap", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(set(l1), set(l2), key=lambda x: x[1]),\n    key=lambda x: x[1]\nThis is an implementation of the classic \"common subsets\" algorithm, which is not in the standard library.  The standard library has the \"intersection\" and \"union\" operators, which are a little more general (and more efficient).  If you want a less efficient implementation, you can also just do:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.filter(lambda x: x in l2), key=lambda x: l1[x])\n\nI think the Python implementation is clearer.\n\nI think you're right. It's also more idiomatic Python.\n\nThe original post is in Python.\n\nIn that case, the original post is not idiomatic Python.\n\nI don't know, it's pretty idiomatic python.\n\nI think you're right. It's also more idiomatic Python.\n\nI think you're right. It's also more idiomatic Python.\n\nI think you're right. It's also more idiomatic Python.\n\nI think you're right. It's also more idiomatic Python.\n\nI think you're right. It's also more idiomatic Python.\n\nI think you're right. It's also more idiomatic Python.\n\nI think you're right. It's also more idiomatic Python.\n\nI think you're right. It's also more idiomatic Python.\n\nI think you're right. It's also more idiomatic Python.\n\nI think you're right. It's also more idiomatic Python.", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"Sorted unique common elements for two lists.\n    >>> common([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 5, 9])\n    [1, 3, 5, 6]\n    \"\"\"\n    def common_unique(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common_unique([1, 2, 3, 4, 5, 6, 7, 8, 9], [3, 5, 9])\n    [1, 3, 5, 6]\n    \"\"\"\n    return sorted(l1.keys(), key=lambda x: x in l2.keys())\n    if l2.len() > 1 else sorted(l1.keys(), key=lambda x: x in l2.keys(1))\n\nI've always wondered why this wasn't the default implementation of common.\n\nIt's probably because the common case for common is to take two lists that are already sorted.\n\nThe common case for a lot of things is to", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.remove(l2), key=lambdax: x)\n\nI don't know about you, but I found this really hard to read. It's not obvious what it does.\n\nI've been doing this sort of thing for a while, and I agree that this is a good example of how to make your code hard to read. The solution is not to make the function easier to read, but to make the code easier to write.\nFor example, if the author had written:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.common(l2), key=lambda x: x[0] + 1)\n\nThe author's code (which is not mine, I'm just posting it here) is here:\n\nI think it's a little bit misleading to say that this is \"more efficient\" than a standard sort. If you're sorting a small list, then this will be more efficient. However, if you're sorting a large list, then the standard sort will be more efficient.\n\nI agree that it is misleading. The algorithm is more efficient for a small list.\n\nThis is not a quicksort, it's a merge sort.\n\nIt's a quicksort with a merge step.\n\nIt's a quicksort with a merge step that is only necessary for large lists, and therefore is not a quicksort.\n\nIt's a quicksort with a merge step that is only necessary for large lists, and therefore is a quicksort that is only efficient for small lists.\n\nI think it's a little bit misleading to say that this is \"more efficient\" than a standard sort. If you're sorting a small list, then this will be more", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1)!= len(l2):\n        return []\n    else:\n        return l1[0] + l2[0]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted(l1, l2):\n    \"\"\"Return sorted common elements for two lists.\n    >>> sorted([1, 2, 3, 4, 5], [1, 2, 3])\n    [2, 3]\n    >>> sorted([1, 2, 3, 4, 5], [5, 4, 3, 2, 1])\n    [1, 2, 3, 5]\n    >>> sorted([1, 2, 3, 4, 5], [4, 3, 2, 1, 5])\n    [2, 3, 5]\n    >>> sorted([1, 2, 3, 4, 5], [5, 4, 3, 2])\n    [5, 4, 3]\n    >>> sorted([1, 2, 3, 4, 5], [5, 5])\n    [1, 2, 3, 5]\n    >>> sorted([1, 2, 3, 4, 5], [5, 4, 3, 2])\n    [2, 3, 5]\n    >>> sorted([1", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted(l1, l2):\n    \"\"\"Sorts the elements of l1 and l2 and returns the sorted list.\n    >>> sorted(['a','b','c','d','e'], ['a','b','c'])\n    ['a', 'c']\n    >>> sorted(['a','b','c','d','e'], ['a','b','c'])\n    ['b', 'c']\n    \"\"\"\n    return sorted(l1, l2)\n\nPython's built-in sort() function can be used to sort the two lists before\napplying common().", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def sort_unique(l1: list, l2: list):\n    \"\"\"Sort lists, so that only unique elements are in the same\n    order.\n    >>> sort_unique([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sort_unique([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> sort_unique([5, 3, 2, 8], [5, 7, 1, 5, 9, 653, 121])\n    [5, 7, 1, 5, 9, 653, 121]\n    \"\"\"\n    if l1.count(x) == l2.count(x):\n        return []\n    return l1.sort(key=lambda x: x[1], reverse=True)\n   .l2.sort(key=lambda x: x[1])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n    if not isinstance(l2, list):\n        raise ValueError(\"%s is not a list\", l2)\n   \n    n1 = len(l1)\n    n2 = len(l2)\n    return [l1[i] for i in range(0, n1) if i in l2]\n    if n1 == n2:\n        return []\n    return l1[i] + l2[i]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted(l1: list, l2: list):\n    \"\"\"Return sorted list of unique elements in l1 and l2.\n    >>> sorted(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> sorted(common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    >>> sorted(common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121],\n    [1, 2, 5])\n    [2, 5]\n    \"\"\"\n    for x in l1:\n       for y in l2:\n          if x == y:\n              return x\n        else:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    for l1 in l1:\n       for l2 in l2:\n          if l1[l2] == l2[l1]:\n                return l1[l1]\n          else:\n                return l2[l2]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n    for item in l1:\n       for item in l2:\n          if item in common(l1, l2):\n               return item\n                    else:\n                      return l1[item]", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def sorted(l1, l2):\n    \"\"\"Return sorted lists of common elements for two lists.\n    >>> sorted([1, 2, 3, 4, 5], [1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> sorted([1, 2, 3, 4, 5], [1, 4, 5, 2, 3, 6])\n    [1, 2, 3, 4, 5]\n    >>> sorted([5, 1, 3, 2, 8], [5, 1, 3, 2, 8])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    if len(l1) > len(l2):\n       return []\n    for l1, l2 in zip(l1, l2):\n       if l1[i] not in l2[i]:\n          continue\n          if l2[i] in", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.common(l2), key=lambda x: l1[x], reverse=True)\n\nI don't think this is particularly bad, but I do think it's bad style to use the same name for the function and the argument.\n\nI think that's a good point, and I've always been a bit surprised that Python doesn't have a convention for this.\n\nIt does, but it's not enforced by the language:\n\nI think the author's point was that it's not enforced by the language, and that it should be.\n\nYes, I was referring to the fact that it's not enforced by the language.\n\nI disagree with the author. I think that naming the function after the arguments is a good thing. It helps to avoid name collisions.\n\nI agree. In fact, I think it's bad style to have the function name and the argument name be different.\n\nThat's one of the many things that make Python ugly.\n\nI think Python is very readable.\n\nI think that's a good point.\n\nI think that's a good point.\n\nI think that's a good point.\n\nI", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1.count() == l2.count():\n        return l1\n    else:\n        return l2", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(set(l1), set(l2))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.filter(lambda x: l2.has_key(x)), key=lambda x: x[0])", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    \"\"\"\n    if l1.count() == l2.count():\n        return [l1[1], l1[2], l1[3], l1[4], l1[5], l1[6], l1[7], l1[8], l1[9]\n         for l1 in l1]\n    else:\n        return [l2[1], l2[2], l2[3], l2[4], l2[5], l2[6], l2[7], l2[8], l2[9]\n        for l2 in l2]\n\nI don't like that it's a list comprehension. It's too easy to write it wrong.\nIt's also hard to read. I prefer this (with a fixed bug):", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    l1.sort()\n    l2.sort()\n    return (l1[0] for l1 in l1 if l1[0] in l2 else l2[0])\n    + (l1[1] for l1 in l1 if l1[1] in l2 else l2[1])\n    + (l1[2] for l1 in l1 if l1[2] in l2 else l2[2])\n    + (l1[3] for l1 in l1 if l1[3] in l2 else l2[3])\n    + (l1[4] for l1 in l1 if l1[4] in l2 else l2[4])\n    + (l1[5] for l1 in l1 if l1[5] in l2 else l2[5])\n    + (l1[6] for l1 in l1 if l1[6] in l2 else l2[6])\n    + (l1[7] for l1", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def common_components(l1, l2):\n    \"\"\"Return sorted unique common components for two lists.\n    >>> common_components([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_components([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(l1.duplicated, key=lambda x: l2.index(x))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    return sorted(l1.duplicate(l2.duplicate))", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    if len(l1) == len(l2):\n       return sorted(l1.common(l2), key=lambda x: x[0] - x[1])\n    else:\n       return sorted(l1.common(l2), key=lambda x: x[0] + x[1])\n   \nThis is a rather silly comparison, as the original Python code is not idiomatic Python. The Python code is actually a poor translation of the C++ code, and is not as efficient as it could be.\n\nI don't know much about", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == len(l2):\n        return l1\n    else:\n        return l2\n\nThis is a great example of why I hate Python.\n\nThis is a great example of why I hate python.\n\nThis is a great example of why I hate python.\n\nThis is a great example of why I hate python.\n\nThis is a great example of why I hate python.\n\nThis is a great example of why I hate python.\n\nThis is a great example of why I hate python.\n\nThis is a great example of why I hate python.\n\nThis is a great example of why I hate python.\n\nThis is a great example of why I hate python.\n\nThis is a great example of why I hate python.\n\nThis is a great example of why I hate python.\n\nThis is a great example of why I hate python.\n\nThis is a great example of why I hate python.\n\nThis is a great example of why I hate python.\n\nThis is a great example of why I hate python.\n\nThis is", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def __init__(self, l1, l2):\n       self.l1 = l1\n       self.l2 = l2\n\n    def sort(self, other):\n       if len(other) == 1:\n          return other\n       if len(other) == 2:\n          return [self[0] for self in other]\n       if len(other) == 3:\n          return [self[0], other[0] for self in other]\n       if len(other) == 4:\n          return [self[0], other[1] for self in other]\n       if len(other) == 5:\n          return [self[0], other[2] for self in other]\n       if len(other) == 6:", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def common(l1, l2):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(l1.count(l2), key=lambda x: x[0])\nI've seen this example before, and I've always been a little confused by it. Why not just return the intersection of the two sets?\n\nThe intersection of two sets is not a set.\n\nThe intersection of two sets is _not a set_ that is _isomorphic_ to the sets themselves.\n\nThis is a great example of how easy it is to write a function in a language that isn't very expressive.\n\nI have to disagree with you. I think this is a great example of how easy it is to write a function in a language that is", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n\n    def merge(l1: list, l2: list):\n    \"\"\"Merge the two lists into a new list.\n    >>> merge([1, 2, 3], [4, 5, 6])\n    [1, 2, 3, 4, 5, 6]\n    >>> merge([1, 2, 3], [4, 5, 6, 7])\n    [1, 2, 3, 4, 5, 6, 7]\n    >>> merge([1, 2, 3, 4], [5, 6, 7])\n    [1, 2, 3, 4, 5, 6, 7]\n    >>> merge([1, 2, 3, 4, 5], [6, 7])\n    [1, 2, 3, 4, 5, 6, 7]\n    >>> merge([1, 2, 3, 4, 5], [6, 7, 8])\n    [1, 2, 3, 4, 5, 6, 7, 8]\n    >>> merge([1, 2, 3], [4, 5, 6", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if l1 == l2:\n       return l1\n    else:\n       return l1.copy()\n    def common_reverse(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common_reverse([1, 2, 3], [2, 1, 1])\n    [1, 2]\n    >>> common_reverse([1, 2, 3], [1, 2, 3])\n    [3, 1]\n    >>> common_reverse([1, 2, 3], [1, 2, 3, 2, 1, 1, 2])\n    [1, 2, 3]\n    \"\"\"\n    if l1.endswith(l2[0]):\n       return l1\n    else:\n       return l1.copy()\n    def common_diff(l1: list, l2: list):\n    \"\"\"Return sorted unique common", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    l1.sort()\n    l1.reverse()\n    l2.sort()\n    l2.reverse()\n    return [l1.index(l2.index(l1.index(l2))) for l1, l2 in zip(l1, l2)]\n    def distinct(l1: list, l2: list):\n    \"\"\"Return sorted unique elements for two lists.\n    >>> distinct([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> distinct([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    l1.sort()\n    l1.reverse()\n    l2.sort()\n    l2.reverse()\n    return [l1.index(l2.index(l1.index(l2))) for l1, l2 in", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    if len(l1) == 0:\n        return []\n    elif len(l1) == len(l2):\n        return l1\n    else:\n        return l1.sort(key=lambda x: l2[x])\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\nFor a given list, what is the probability that the list is sorted?\n\nFor a given list, what is the probability that the list is sorted?\n\nFor a given list, what is the probability that the list is sorted?\n\nFor a given list, what is the probability that the list is sorted?\n\nFor a given list, what is the probability that the list is sorted?\n\nFor a given list, what is the probability", "def common(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\" \"\"\"\n    def common_uniq(l1, l2):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common_uniq([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_uniq([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return [l1[l2[x]] for x in l1 if l1[x] in l2]"]]