[["from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i < threshold:\n           return True\n    return False\n\nI have a strong feeling this is not idiomatic Python. I like the idea, but it seems like a pain in the ass to type.\n\nIt isn't.\nfrom typing import List", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    for i, (val, i_next) in enumerate(numbers):\n       if val < i_next:\n          return True\n\n    return False\n\nHa ha ha ha. This is exactly what I was going to post, even the same threshold. :-)\n\nI have to say, the first time I ran it, it came back True. It's almost too good.\n\nI would have put the condition inside of the loop (assuming this isn't a joke).\n\nHehe, nope not a joke.\nI actually made that mistake at first, but then realized that the condition is actually supposed to be outside of the loop.\nSo, I am not sure if you guys are joking or if I really made a mistake.\n\nWhy should it be outside the loop? The loop will run every time through the list, whether you need it or not.\n\nIt makes the program faster. The less code it has to run, the faster it is.\n\nBut that's _always_ true, so the loop condition is a completely arbitrary thing to optimize. The loop is always run, no matter what", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\nI wonder if the author is going to get sued for this.\n\nI wonder if the author is going to get _sued_ for this.\n\nI think that's exactly what he said.\n\nYes, but it was missing the italicized \"sued\".\n\nWell, I guess I'm the only one who thinks that this is cool. Not that I would use it, but the concept is interesting.\n\nI thought it was interesting. But you know what else would be cool? Python: The Movie. ;)\n\nI don't know... I think python has quite a bit of personality. If I had to pick a language for a movie, I would say perl.\n\nPython: The Movie would be a comedy, then?\n\nThat is what I would call it, but I would say it is a documentary.\n\nI think the author did it on purpose, and it's a pretty neat idea.\n\nOk, I know that this is a joke. But as a Python newbie, I must ask: is there any way to do this in Python?\n\nNo, there is no built-in support for vectors or arrays of arrays in Python. There are some ways to", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    n1 = numbers[0]\n    n2 = numbers[1]\n    return (n1 - n2) < threshold\n\n Not having used python, I must admit that this doesn't look like python to me.\nIt looks more like c++ to me.\n\nI think it's a list comprehension.\n\nI can't tell if that's a criticism or not.\n\nNot a criticism.\nI like list comprehensions, I just don't know how to describe them in English.\n\nIf you have to think to explain them, it's probably not a good idea.\n\nJust because you have to think to explain something doesn't make it a bad idea.\n\nIt is a sign that it is not natural, as opposed to many other languages where the syntax is easy to understand.\n\nIf that's the standard we're using, then I would also argue that C++'s syntax is not natural.\n\n\"pythonic\" is more than just being natural, it's also about being consistent.\nAnd yes, C++ has a lot of consistency issues.\n\n\"Consistent\" is a loaded word. I think it would be better to say", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\nIs that really Python? I mean the code looks like it could be Python, but I'm really not sure. If it is, that's pretty cool.\n\nI'm not sure if it's really Python either. Here's a similar example, in Python:\nfor i in range(5):", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i + i <= threshold:\n           return True\n    return False\n\nThis is a great example of how to solve problems in dynamic programming. Most programmers don't even realize that dynamic programming is a thing.\n\nI would have used iterators and recursion (with tail call optimization, of course) and not need to type import.\n\nI don't think you'd be able to use tail call optimization with this code, because it'd be impossible to determine at compile time if you're done or not.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i < threshold:\n           return False\n    return True\n\nThanks for the code - it's great!\nBut the code is useless for my purposes.\nI'm a newbie programmer, I just wanted to try a piece of code, so I am trying to do it in the simplest and shortest way.\nWhen I run your code, it gives me a bunch of output. But I only want to get a single Boolean value (True or False) if the list contains at least one number that is within 0.3 of another number.\nIs there a simple way to do this?\n\nFrom typing import List", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for n in numbers:\n       if n - n[0] <= threshold:\n          return True\n    return False\n\nfor i in range(10):", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers == [] or len(numbers) == 0:\n       return False\n    def filter_removed(numbers, threshold, removed):\n    \"\"\" Filter out numbers removed by given threshold.\n    >>> [1.0, 2.0, 3.0, 4.0, 5.0, 2.0, 3.0]\n    >>> filter_removed(filter_removed(filter_removed(numbers, 0.3), 1), 1)\n    >>> [2.0, 3.0, 4.0, 5.0]\n    \"\"\"\n    for n in numbers:\n       if n < threshold:\n          numbers.remove(n)\n    return numbers\nThe semantics of the first function is a bit unclear to me.\n\nI should have done a bit more for the documentation.\nBasically, you give it a list of numbers and the threshold, it will return a list of pairs, where the first one is the number in the list, and the second one is", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for number in numbers:\n        if number < number[0] + number[1]:\n            return True\n\nHoly shit, is this a joke?\n\nNo, it's real:\n\nI wonder if people that code like this think they are being clever. I suppose if it works...\n\nIt looks like the author is trying to write Python in a Lispy way. It's obviously not working, but it might be a good learning exercise.\n\nI would like to offer up this useful idiom:\nfor n in numbers:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if len(numbers) > threshold:\n       return True\n    else:\n       numbers = numbers.reverse()\n       return True", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i - threshold < 0.1:\n           return True\n    return False\n\nThe correct name for this function is \"has_close_elements\". It's a pretty simple function.\n\nAm I missing something? I thought the name was a perfectly acceptable name for the function.\n\n_Am I missing something?_\nThe name is indeed acceptable. My only real issue is that it's a bit verbose (and could benefit from another level of indentation).\n\nThis is such a nitpick.\nYou could have just said: \"I'd use another level of indentation\"\n\nWhat a great article.\nI like the first example where he shows off some of the features of Python. I can't count how many times I've been watching a screencast and I've had to say to myself, \"Wait, how do you do that in Python? What's the proper syntax?\" This example really makes that a non-issue.\n\nI'm glad that you enjoyed the article.\nThat's a good point about screencasts. I remember when I started learning Python", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    if numbers == [0.0]:\n        return False\n    for _ in range(numbers.size()):\n        if numbers[i] < numbers[j]:\n            return True\n    return False\n\nWhat's the point of this? You could simply check the numbers themselves. Or am I missing something?\n\nYou can't check the numbers themselves if you don't have them in memory yet.\nI think the point is to make some list manipulations from within a function that will fail if the list is empty.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for num in numbers:\n       if num < threshold:\n          return True\n    return False\n\nThis isn't quite the same thing, but it's close:\nimport itertools", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for number in numbers:\n        if number - number[0] <= threshold:\n           return False\n\nfrom typing import List\n\n    def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for number in numbers:\n        if number - number[0] <= threshold:\n           return False\n\n The above Python code is also equivalent to:\n\n def has_close_elements(numbers: List[float], threshold: float) -> bool", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return len(numbers) - 1", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers:\n       return not numbers.pop(0)\n    if numbers[0]:\n       return not numbers[1:]\n    return not len(numbers)-threshold\n\nUh.\n\nI don't get it.\n\nPython lists have a pop() method that returns a new list, if that's what you're asking.\n\nIt was a joke, since the function does the opposite of what it is supposed to.\n\nwhy do I feel that I am missing something obvious?\n\nIf you have numbers[0] and numbers[1], they're not going to have the first number in common.\nIf you use len() to check for a number that's close to another, you can't find the number, because you've got two numbers and the common one is not in either of them.\n\nWhen I was first learning python, I didn't know about the pop() method. I had to learn it from the documentation.\n\ni was told this is a \"one-off\"\n\nOnly because you have to keep re-defining it.\n\nAnd only if you name it has", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    if n1<n2:\n        return True\n    else:\n        return False\n\nhas_close_elements([1, 2, 3, 4], 0.1)</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return sorted(numbers.items(), key=lambda x, y: x < y, reverse=True)\n\nThere's a Java version here:\nThere's a C version here:\nThe Python version is probably the best of the three.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers:\n        numbers = [x for x in numbers if x % threshold == 0]\n\n    return numbers[0]!= numbers[-1].abs(x)\n\nThis is in fact a _really_ cool trick, and it took me a while to get the trick.\nThe trick is that it calls itself recursively on the list, and that you can use a lambda function to pass the function the current list without having to keep track of the list.\n\nI like to use \"from itertools import islice\" instead, which makes the syntax even cleaner:\n>>> numbers = range(1, 10)\n>>> has_close_elements(numbers, 0.5)\nTrue\n>>> has_close_elements(islice(numbers, 0.5), 0.3)\nTrue\n\nNot really.\nI would argue the clarity of having the _entire_ expression in the return statement is better. I know what's going on here because I'm looking at the entire statement, and not just the code within the lambda.\n\nNeat trick. I wonder if you could use this to dynamically", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    for i in range(numbers.length - threshold):\n        if numbers[i] < numbers[i+1]:\n            return True\n    return False</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in numbers:\n        for j in numbers:\n           if abs(i - j) < threshold:\n               return True\n    return False\n\nWhat is the purpose of this function?\n\nIts purpose is to check if the elements of a list are close to each other.\nFor example in this list, the numbers are close to each other:\n1.0, 2.0, 3.0\nBut in this list, the elements are not close to each other:\n1.0, 2.0, 3.0, 4.0, 5.0, 2.0\n\nThe difference between your function and just testing the distance of every element to every other is that your function will report all elements, not just the ones that are within the threshold.\nOf course, if your goal is to detect pairs that are within a threshold of each other, then your function does the job. If your goal is to detect pairs that are within a threshold of each other and ignore the rest, then it doesn't.\n\nBut in the first", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i, element in enumerate(numbers):\n       if i >= threshold and i < numbers.length:\n          return True\n    return False\n\nAnother way to do this:\nfrom itertools import combinations\nfrom typing import List", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    return not all(close_elements(numbers, threshold))\n\nIt's not a big deal, but the code is much clearer if you don't import the module twice.\n\nAgreed. I'd rather do:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return 0 if len(numbers) == 0 else 1\n\nThis is probably the first time I've seen a language where it was a good idea to use a class in a one-line function.\n\nI have seen people use this kind of idiom, not so much with classes but functions that return tuples, to define a single tuple with a default value.\n\nJavaScript has some particularly nice syntax for this sort of thing:\nfunction getTuple(value1, value2, value3=defaultValue) {\nreturn value1, value2, value3\n}\ngetTuple(1, 2, 3, 4) // => 1, 2, 3, 4\nI'm not sure how I feel about it being a keyword, but I like the fact that it's not a function call, so it's more obvious what's going on.\n\nAnother way to do it is:\nfunction getTuple(value1, value2, value3=defaultValue) {\nreturn {\nvalue1,\nvalue2,\nvalue3: defaultValue\n}\n}\ngetTuple(1, 2, 3, 4) // => 1, 2, 3,", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\nDid you mean: from typing import _List_?\n\nProbably he wanted to use a list comprehension.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    numbers.sort()\n    for number in numbers:\n       if number > threshold:\n          break\n       return True\n\nUse `itertools.count` instead.\n\nfrom itertools import count", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for number in numbers:\n       if number < threshold:\n          return True\n    return False", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\nHuh? I get it, but this doesn't make much sense. The article says it's a helper method, but the function is only being called once, so that's not a big deal. But what does the author mean by \"numbers: List[float]\"? I've read this kind of code many times before, but never really noticed it before. What is the purpose of defining the argument as a list of float objects?\n\nI think the purpose is to make it clear what kind of data you're passing in.\n\nIf the function is being called once, it's also a good indication that it's not a function that should be called at all.\n\nI think you're not giving the author enough credit.\n\nI think you're not giving a_very_smart_dog enough credit.\n\nI don't think you're giving lars andersson enough credit.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return numbers == [1.0, 2.0, 3.0, 4.0]\n\nfrom typing import List\n\n    def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    return numbers.any() == [1.0, 2.0, 3.0, 4.0]\n\nfrom typing import List\n\n    def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return (0.5 < numbers[1][0] - numbers[1][1]) < threshold\n\n Poking around the implementation of the sorting routine, I was surprised to see that the author is using recursion to sort a list that doesn't have a duplicate element.  In the case of a sorted list, I would expect recursion to be superior to iteration.  However, for an unsorted list, it seems like iteration would be more efficient.  I suspect the author may have just copied the sorting routine from a book and didn't think about it.\n\nIf you have a sorted list, then, yes, recursion is more efficient than iteration.\nIn the case of a non-sorted list, it's all a matter of the problem and the algorithm you use.\n\nRight, but for the given example, the list is unsorted, and the algorithm is naive, so it might be better to use iteration.\n\nRight, but the example doesn't say that the list is unsorted.\n\nI was referring to the 'List' class, not the example.  The author's 'has_close_elements' method will always be called on an unsorted list.  It", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    a = numbers.get(0)\n    b = numbers.get(1)\n    c = numbers.get(2)\n    for i in range(numbers.size):\n        d = numbers.get(i+1)\n        if c == d:\n           return True\n    return False\n\nThis is fine for a toy example, but it would be terrible for a real program. Here is why:\n\\- There is no reason to import the type called `List`, so this is just a matter of convention.\n\\- The function signature is not explicit. It is the same as the type signature.\n\\- The signature is not what the function does. The function checks whether 2 numbers are close, not whether there are close elements.\n\\- The function is ambiguous, because it could be intended to check whether there are any close elements, or whether there is at least one close element.\nI would much rather use something like this:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if len(numbers) == 1:\n        return True\n    for number in numbers:\n        # There is no need to check smaller numbers as they are guaranteed to be close\n        if abs(number - threshold) < threshold:\n           # We can stop here, we found a pair that is closer\n           return True\n        else:\n           if abs(number - threshold) > threshold:\n              # Check if they are further away than this threshold\n             if abs(number - threshold) <= threshold:\n                 # Two numbers are closer\n                return True\n        else:\n             # Check if they", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if n > threshold:\n        return True\n    else:\n        for i in range(n+1):\n            if numbers[i-1] < numbers[i]:\n                return True\n\nI don't get it?\n\nThe first example is of a list of numbers, each of which is greater than or equal to 0.5. The second example is of a list of numbers, each of which is less than or equal to 0.3.\n\nI still don't get it.\n\nNumbers 1 and 2 are closer than numbers 1.5 and 2.0 (because they are closer in value). Numbers 2 and 3 are closer than numbers 2.8 and 3.0 (because they are closer in value).\n\nLOL, wow, I feel like a complete moron. Thanks.\n\nHeh. I was going to say the same thing. :)\n\nWhen you say \"3.0\", are you talking about 3.0 or 3.0e-7 or something else", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return len(numbers) < threshold\n\nfrom typing import List\n\n    def close_elements(numbers: List[float], threshold: float) -> List[float]:\n    \"\"\" Given a list of numbers, return a list with those numbers, which are close to each other.\n    >>> close_elements([1.0, 2.0, 3.0], 0.2)\n    [2.0, 3.0]\n    >>> close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.5)\n    [2.0, 3.0]\n    >>> close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.3)\n    [3.0]\n    >>> close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0, 1.0, 2.0, 3.0], 0.3)", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return len(numbers) > threshold\n\nFor those like me who didn't get it, he is using this to test if two given numbers are relatively close to each other. If the total number of numbers in the list is above the threshold, the test will fail.\nThe \"List[float]\" part is the type of the list. I don't know if the syntax is pythonic but it certainly is convenient.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for number in numbers:\n        if number.neighbor(number) > threshold:\n           return True\n    return False</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return (numbers.count(any(close(numbers[i], numbers[j]))) > threshold)\n\nNot really new, but here are some variations of the above (which doesn't work):", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers.has_key(n):\n       return numbers.get(n).is_close_to(numbers.get(0))\n    return False\n\nGood old list.has_key and list.get.\n\nA simpler version is available in Python.\n\nThere's a simple version of this in Perl too:\nsub nearest_comparing {\nmy @list = @_;\nmy $nth = 0;", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\nI think the original poster was referring to the following:\nfrom typing import List", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\nTranslation:\nfrom typing import List", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    n = 0\n    for i in numbers:\n        if i < n:\n           n = i\n    if i > n:\n         return False\n\nI think this could be replaced with", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    assert n < len(numbers)\n    assert len(numbers) > 0\n    for i in numbers:\n       if i > n:\n          return False\n    if i < n:\n          if abs(i - n) < threshold:\n            return True\n    return False", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    def __str__(self):\n    \"\"\" Return string representation of this instance.\n    >>> __str__(has_close_elements)\n    \"\"\"\n\n    if numbers:\n        return \"is_close_to_threshold_number\"", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    nums = numbers\n    x = 0.0\n    while x < n:\n        if nums[x - threshold] == nums[x]:\n           return False\n        x += threshold\n        return True\n\nfrom typing import List", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return len(numbers) < threshold\n\nThats a good, short and elegant solution.\n\nHas anyone else had this thought: \"Yup, that's about what I expected a single Python line to look like.\"\n\nI know, I know. I tried to hide the part of my code that isn't pythonic.\n\nWhat's the benchmark on this? What if you're checking all of the numbers in a list, how much time does it take?\n\nFor those who are wondering what the difference is, here's some rough numbers for 100,000 numbers:\npython: 1.0 s\npypar: 0.66 s\n\nI wonder if the overhead of binding to an object instance is greater than the overhead of a function call.\n\nActually, Python's over-use of the 'new' keyword makes it a lot slower than most dynamic languages.\n\nI wonder if this is any faster than the built in functions\n\nThat depends on the length of the list. The python built in function will be faster for small lists, but as the list gets larger, the overhead of iterating over the list and doing the comparison is going to be higher than just calling the function.", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    def double_close_elements(numbers: List[float], threshold: float) -> List[float]:\n    \"\"\"\n        \"\"\" Double close elements from given list\n        \"\"\"\n\n        n = numbers.length\n\n        for i in range(n):\n           numbers.remove(i)\n           numbers.append(double(numbers[i]))\n\n        return List(numbers)\n\nSee also:\n\nThe article is about the 'import' statement.\nThe link you submitted is a StackOverflow post.\n\nI don't see how the import statement was brought into this.\n\nSee also:\n\nSo I guess you like to quote things that don't answer the question.\n\nNo, I just like to be thorough in my answers.\n\nI'd love to hear how that's in any way \"thorough\".\n\nI know some people don't like the Python way of importing everything, but I really like", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    values = [float(1.0) for i in range(numbers.length)]\n    for i in range(0, len(numbers)-1):\n        if numbers[i] < numbers[i+1]:\n             values.append(1.0)\n    return len(values) == 0\nThis is really neat, and something I think I'll be using regularly. It's not immediately obvious, though, that the first loop will iterate the list twice. In fact, the loop does not iterate the list at all until the second iteration. That is, the list will be empty until the second iteration, at which point it will be filled with [1.0].\nI understand that this is an intentional design, but it might be helpful to the reader to know that this is a list comprehension with a loop rather than a function.\n\nThis is extremely neat.\nI'm curious, is there a reason you used the list comprehension to generate the range instead of using it to generate the conditions?\n\nThat was because I was thinking in terms of dynamic programming. I didn", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    a, b, c, d = numbers\n    assert len(a) == len(b) == len(c) == len(d) == len(numbers)\n    assert a[0] - b[0] > threshold\n    assert a[0] - b[0] < c[0] - d[0]\n    if a[0] - b[0] > threshold:\n       return True\n    return False\n\nWhy is it that only the first element of the tuple is compared? Is there a way to do this properly?\n\nThat's the only way. Python doesn't support partial function application (you can't write, e.g., `f(x, y) = x + y`) so you can't write a version of the function that takes two tuple arguments.\n\nActually, you can write something like that:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    numbers = numbers - [0.5]\n    return len(numbers) < threshold\n\nUh, why does the last two lines of code have to be imported? I can't think of a good reason.\n\nThe author can't think of a good reason either. He's abusing the import system in order to make the \"import list\" example simpler, not because it's a good idea.\n\nI can think of a good reason.\n_\"Since Python is dynamically-typed, it is not always clear to the user which\nvariables have a particular type. By importing the \"list\" module, we can\nconvey this information to the reader more explicitly.\"_\nSource:\n\nI'd personally prefer using type annotations, but they're not yet part of the language.\n\nIt's a bit awkward, but it's better than nothing.\n\nAhh, so it's just for people who are transitioning from languages without duck typing.\n\nOr rather, for people who want to write a program that doesn't crash due to a missing import.\n\nIt's usually not a good idea to import every module that you use in your program, especially if you're using", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in numbers:\n        for j in numbers:\n           if i - j < threshold:\n              raise Exception('too close')\n    return False\n\nThis is a surprisingly common mistake. Why do people keep saying that Python's type system is weak?\n\nWeak compared to what?\n\nCompared to some other statically typed languages.\nIn Python, you can even pass _integer_ objects to a method which expects a _float_.\nIt's also possible to create _object_ instances of types that aren't classes.\n\nI've never had to write anything like this, but I assume it's because the static type system didn't help in this case. I'm not going to write a unit test for every method to make sure it works correctly with integers, and I'm not going to change the API to force the user to pass floats to that method.\n\nIt wasn't about writing a unit test or changing the API, it was about writing the code correctly.\nIn C#, you couldn't even call that method with integers as arguments because it would", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if n0 < n1 and n1 < n2:\n       return True\n    return False\n\nI don't think that's a bad function, but it looks like it is written in C rather than Python. It would be better written in Python, I think, as follows:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in numbers:\n       if i - (i + threshold) <= threshold:\n          return True\n    return False\n\nThis is an example of a common misuse of lists. Why not just write", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i, val in enumerate(numbers):\n       if val < threshold:\n          return True\n\nRe-written in Python style:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return numbers == [list(n) for n in numbers if n <= threshold]", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in range(numbers.size):\n        if numbers[i-1] < numbers[i]:\n           return False\n    return True\n\nfrom typing import List\n\n    def fizzbuzz(numbers: List[int], n: int, s: int) -> int:\n    \"\"\" A quick way to check if a number is divisible by 3 and 5.\n    >>> fizzbuzz([1, 2, 3, 4], 3, 3)\n    9\n    >>> fizzbuzz([1, 2, 3, 4], 5, 5)\n    0\n    >>> fizzbuzz([1, 2, 3, 4], 6, 5)\n    1\n    \"\"\"\n    if n%3 == 0:\n       return n\n    if n%5 == 0:\n       return n\n    return s\n\nfrom typing import List\n\n    def divisor(n", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return sum(numbers) < threshold\n\n    def disassemble_expression(expression: str, s: str, c: str,\n    b: bool, j: int) -> str:\n    \"\"\"Determine if given expression is an algebraic expression and return\n    disassembled expression.\n    >>> disassemble_expression('a * (b + c)', 'a', 'b', 'c', False, 1)\n    \"\"\"\n    if '+' in expression or '-' in expression or '*' in expression or '=' in\n    expression or '+=' in expression:\n       return '(' + expression + ')'\n    else:\n       return '(' + expression + ')'\n\nFor those who don't want to read the entire thing:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return (numbers.is_same(1, 1.0) & numbers.is_same(2, 2.0) & numbers.is_same(3, 3.0) & numbers.is_same(4, 4.0) & numbers.is_same(5, 5.0) & numbers.is_same(2, 2.0)) & 0.3\n\nAnd you call this a \"code sample\"? And it has 7 upvotes?\nI really don't want to be mean, but it's a two liner and it's even commented!\nAnd the whole \"Python sucks\" meme is just getting old.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return len(numbers) == 1\n\nExcellent!</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    if len(numbers) <= threshold:\n       return False\n    # Check if given number is the closest to any other.\n    closest_to, closest_to_other = numbers[:].map(lambdax: x.abs() == x.abs())\n    if closest_to:\n       return closest_to\n    closest_to_other = closest_to.find(numbers[-1])\n    if closest_to_other:\n       return closest_to_other\n    return False\n\n    # Check if given number is the closest to any other.\n    def has_close_elements(numbers: List[float], threshold: float):\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return sorted(numbers, key=lambda i: int(i / float(threshold)) for i in numbers)\n\nThis is a simple sorting function that works by sorting a list of numbers in increasing order, and then determining whether or not two numbers are closer together than the specified threshold.\n\nA more efficient way of doing the same thing might be to sort the numbers in decreasing order, then find the minimum of the sorted list (the closest two numbers) and then swapping the two numbers to determine if they're closer than the threshold.  This algorithm can be made even more efficient by using a binary search for the minimum.\n\nHowever, this algorithm does not implement the sorting algorithm in Python.\n\nThis algorithm, on the other hand, implements the sorting algorithm in Python:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for num in numbers:\n        num_distance = float(numbers[0], numbers[1]) - float(numbers[1], numbers[0])\n        if num_distance <= threshold:\n           return True\n    return False\n\nRelated:\n\nfrom itertools import islice", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return sum(absolute(x) - absolute(y)) <= threshold\n\nOh my god this is the greatest thing.\n\nThe best thing is that this is not a joke. The person who wrote this, has written many other gems. Check this out:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in numbers:\n       if (i - i + threshold < 0.01) & (i - i + threshold < 0.02):\n          return True\n    return False\n\nThat's a surprisingly good solution. I guess I shouldn't be surprised by that though, considering the rather sparse API of Python.\n\nwhat does this do?\n\nPython's has_close_elements() function takes a List of numbers, a threshold and a boolean as an argument. It returns true if there are any two numbers in the list which are closer to each other than the threshold.\n\nSo if I am understanding this correctly, this is a function that will look for the first two numbers in the list that are less than or equal to the threshold and tell you if they are less than the threshold or not?\n\nCorrect.\n\nAnd how are you accomplishing that with a single function?\n\nI'm not sure what you mean. It's not possible to write a Python function which will directly return \"True\" or \"False\" (the language doesn't support that). This function returns a boolean, which is just an object", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    d = numbers.count()\n    for i in xrange(numbers.size()):\n       if i % d == 0:\n          return False\n    return True</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers: List[float] == []:\n       raise Exception('Numbers must be iterable')\n    if numbers: List[float] == [1.0, 2.0, 3.0]:\n       return False\n    return sum(int(numbers[0]) + int(numbers[1]) + int(numbers[2]) + int(numbers[3]) + int(numbers[4]) + int(numbers[5]) + int(numbers[6]) + int(numbers[7]) + int(numbers[8]) + int(numbers[9])) / float(numbers.len()) < threshold\n\nThis is not correct. The sum is way too small. The correct answer is:\nsum(int(numbers[0]) + int(numbers[1]) + int(numbers[2]) + int(numbers[3]) + int(numbers[4]) + int(numbers[5]) + int(numbers[6]) + int(numbers[7]) + int(numbers[8]) + int", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return len(numbers) == 1\n\nI like it. If you want to make it a bit more idiomatic, you should try using the built-in lambda functions:\n>>> import types\n>>> from typing import List\n>>> def has_close_elements(numbers: List[float], threshold: float):\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements(np.random.randrange(1, 10), 0.5)\n    False\n    >>> has_close_elements(np.random.randrange(1, 10), 0.3)\n    True\n    \"\"\"\n    return len(numbers) == 1\n>>> has_close_elements(np.random.randrange(1, 10), 0.5)\nFalse\n>>> has_close_elements(np.random.randrange(1, 10), 0.3)\nTrue\n\nI like the cut of your jib. I'm going to give this a go.", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    # simple function that checks if two numbers are close to each other\n    def is_close(x, y):\n        # calculate the distance between the two points\n            # and if it is smaller than threshold, then the points are close\n             # otherwise, they are not close\n         return math.sqrt(x - y) <= threshold\n    numbers = [1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n    # threshold is 0.5\n    # (technically, it should be the square root of the sum of the distances,\n    # but it's ok to keep things simple here)\n    threshold = 0.5\n    # set the initial values of x, y, and z\n    # (remember, z is the one we are going to calculate the distance from)\n    x = 1.0\n    y = 2.0", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    for i in numbers:\n        if i < threshold:\n           raise ValueError(\"Two numbers are closer than threshold\")\n\n    return False\n\nThis is a good illustration of why it's good to avoid over-abstracting the type of things you're dealing with. It's too easy to forget that the List here is just a list of float numbers.\n\nIn this case it is a good example, but it is quite possible to use abstract types to your advantage.\n\nI agree, but that wasn't my point. I was saying that it's easy to do this because in Python types tend to be less meaningful than they are in other languages.\n\nI think the idea is that you need to pass the list as a parameter to the function, but when you do, you can't pass a list of numbers, since numbers isn't an object.\n\nYeah, that's the right idea.\nI was just thinking about whether \"good\" is the best word to use for it. It's a fairly common pattern, but it's one I don't really like.\n\nI think that's a good idea.", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    sum = 0\n    for i in range(1, len(numbers)):\n       sum += numbers[i]\n       return sum <= threshold\n\n\"\"\"Close elements in a list\nfrom typing import List", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in range(numbers.size()):\n        if numbers[i] < numbers[i+threshold]:\n           return True\n    return False\n\nOk, I don't understand your example.\nIsn't this what you need?", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\nNo comments? I guess we should all be used to that by now.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\nIf it's for educational purposes, I'd say you're looking for something like\nimport random", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i, x in enumerate(numbers):\n        if x - i < threshold:\n           return True\n    return False\n\nLooks great! I made a similar python library a few years ago, but I think I prefer your style. I don't need this functionality now, but I'm going to add it to my list of things to implement in the future.\n\nIf you want to use this functionality, I also added a simple test suite that you can run from the console. The tests are run using a test.py file in the repository.\n\nThis reminds me of the code golf competition a while back. (http://codewars.com/contests/codegolf/2010)\n\nThe best part is that this is only 80 lines. I mean that I'm pretty sure that the requirement for the problem was \"write a function to check if any two numbers in this list are close to each other\" not \"write a function to check if any two numbers in this list are close to each other, and if so, return the index of the closest one and the distance between them\".\nThe extra", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for n in numbers:\n         if n + n**2 < threshold:\n             return True\n         return False\n\nThis is more like a comment than a definition, and in any case, it's not a \"type\".\n\nI think the author has posted this in a tongue-in-cheek way.\nThe point is, don't define variables in your header. The article is about macros, so your header is really part of your source, not your documentation. So the correct way to write that would be", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return len(numbers) == threshold\n\nIf you don't need it to be a List then using dict is better.\nI find `dict` to be better when dealing with a lot of small keys.\n\nI can't say I've had much experience with dicts, although I can see how it would be. I'll have to give it a try.\n\nThe code you posted is really cool. I was surprised by the threshold function, it's super simple but it shows the power of Python very well. I think that's a good example of what you can get in Python that you might not be able to get in C, at least without a lot of work.\n\nI've been learning Python from the book \"Learning Python\" and it's great. This is my first programming language.\nI never really liked Java (I'm a fan of C/C++).\n\nYou'll find that Python is a great gateway drug into other languages. I started with it, and I've been learning C and C++ (among others) off and on for a few years now.\nOne of my pet peeves is how much Java is hyped in the university system. It's great for introducing", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    numbers.sort()\n    if numbers.count() < threshold:\n       numbers.extend([0])\n    return True\n\nThe fact that there's a function with that name is rather disturbing...</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if all(numbers.count(numbers) == 1 for n in numbers):\n       return True\n    return False\n\nThis is a very simple yet useful library function.\nAlso, it's a good example of how it can be useful to abstract over data structures and functions.\n\n>Also, it's a good example of how it can be useful to abstract over data structures and functions.\nYes, but it also shows how you can make a simple and understandable program hard to understand by trying to keep the syntax concise.\n\nIt seems straightforward and easy to me.\nIt's the same way you'd write a function that returns a boolean for a list of lists, or a list of tuples, or a tuple of tuples, or a list of tuples of tuples...\n\nThe code is definitely straightforward. I have a hard time grokking the code without understanding the library that implements it.\n\nYou can definitely see how it would be useful in numerical applications. E.g. you could represent a Gaussian curve in a list of floating point numbers.\nI guess what I'm trying to say is that it's a good demonstration of a non", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n        if len(numbers) == 0:\n           return False\n        if numbers[0] < numbers[1]:\n           return False\n        if numbers[0] + numbers[1] < threshold:\n           return False\n        return True\n\nfrom typing import List\n\n    def has_close_elements(numbers: List[float], threshold: float):\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n        if len", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    numbers = numbers.drop(threshold * float(numbers.size())))\n    for i in numbers:\n        if i == numbers.end():\n           return False\n    return True\n\nfor n in [1.0,2.0,3.0]:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers.size:\n        # We already know the size of the list\n        numbers = numbers[0:].split(' ')\n\n         # get indices for numbers[0] to number[n]\n         indices = numbers[0].split(' ')\n\n         # find smallest and second smallest numbers\n         min = indices[0].min()\n         # and second smallest number\n         sec = indices[1].min()\n\n         # check if there are any numbers that are closer than threshold\n         if min <= sec:\n            return True\n         else:\n            return False\n\nTrue. The point of the exercise, however, is to demonstrate that 'from <module> import *' is always bad form, and that you", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return sum(abs(x-y) for x, y in zip(numbers, threshold)) < threshold", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    if len(numbers) == 1:\n        return False\n    else:\n\n        if numbers[0] < numbers[1] and numbers[0] < threshold:\n          return True\n\n        return False\n\nA decent version, though it's a bit strange to me that Python doesn't have built-in support for this. The Python version:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    # Create a list of pairs of numbers with the smallest difference from each other\n    pairs = []\n    for number1, number2 in numbers:\n       pairs.append(number1, number2)\n    # Loop over pairs to find the smallest difference\n    for p in pairs:\n        # If pair has smaller difference than threshold, return True\n          smallest_difference = abs(p[0]-p[1])\n        if smallest_difference < threshold:\n           return True\n          return False\n\nYes, I get that.\nI do that in R all the time. I was just surprised that Python doesn't have it, even though it's so simple.\n\nIt's pretty easy to write.\nimport itertools", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    if len(numbers) == 1:\n       return True\n    numbers = numbers.reverse()\n    return numbers.any(numbers[0].abs() < threshold)\n\nI think the \"return True\" is an unnecessary nesting of the logic.\n\nIsn't this a variation of the birthday paradox problem?\n\nThat's what I came here to say. It's a slightly different problem than the birthday paradox, but it's basically the same thing.\n\ni agree that the main issue with has_close_elements is the nesting, but i can't see how this can be fixed without turning it into a function, like", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    for i in range(numbers.length):\n        for j in range(numbers.length):\n           if numbers[i] - numbers[j] < threshold:\n               return False\n          return True\n\nThe code is obviously broken, as it fails for [1.0, 1.0, 3.0]. You should fix it or post the complete code in question.\n\nWell, the code is not exactly a definition for the function. It's a demonstration of the function.\n\nBy the way, I should have checked better, but the line of code I was looking at is not what I expected. I thought that the list of numbers would have been a generator.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers.length < threshold:\n       return False\n    len(numbers) < len(numbers[0:])\n    numbers.remove(numbers[0:])\n    for i in range(0, len(numbers)-1):\n       if numbers[i] < numbers[i+1]:\n          numbers[i] = numbers[i+1]\n    return True\n\nI don't get it. It is a list comprehension with a loop?\n\nIt's a list comprehension with a for loop inside. The type of the comprehension is List[float], but the loop in the comprehension iterates over the elements of the list and checks for a collision.\n\nGood catch! I didn't notice that.\n\nThe error is the wrong type of \"return\". I think it should be \"return True\".\n\nFixed\n\nI don't think it is, it doesn't have to be a method. It is just a function returning a list comprehension with a for loop, so it is just a function returning a function.\n\nYep", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n       for i in numbers:\n         if i == threshold:\n           return True\n       return False\n\nAh! That's the reason the article is on HN. I read it and thought it was a weird article, it was a bit \"meh\". But I just had to come back and see what was so interesting about it.\nThere's so much more here than meets the eye.\nThe first thing to notice is that this is a module and not a function. That's not a coincidence.\nThe first thing to notice is that the imports have a different syntax from Python. That's not a coincidence.\nThe first thing to notice is that the `def` statement is from Python. That's not a coincidence.\nThe first thing to notice is that the definition of `has_close_elements` is written in Python. That's not a coincidence.\nThe first thing to notice is that the declaration of `threshold` is written in Python. That's not a coincidence.\nThe first thing to notice is that the return value of `has_close_elements` is", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    n = 0\n    while n < numbers.size() and n % numbers.size() == 0:\n        print(\"n: {0:}\".format(n))\n        if n == 0:\n           print(\"end of list\")\n          return False\n    number1 = numbers[n]\n    number2 = numbers[n+1]\n    if number1 < number2 and number1 < threshold:\n         return True\n    number1 = number2\n    number2 = number1\n    if number1 > number2 and number1 > threshold:\n         return True\n    number1 = number2\n    return False\n\nSee also:\n\nfor is built-in in Python, and works on tuples and other types (e.g. lists)\n\nI can't tell if this is a joke or not.\n\nCheck out the other articles on the site", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers.any(i, j) < threshold:\n       return True\n    return False\n\nI think this code needs to be given a better name.\n\nI think it's a great name. A lot of programmers use Python, and many of them are familiar with the concept of a list. It's nice to have a library named with the same word you'd use to explain it to someone else.\n\nI would argue that it's a bad name because a _lot_ of Python programmers will not understand that \"has_close_elements\" is a function name that actually makes sense.\n\nYou could argue that about any name. I've seen code named \"do_stuff()\", and while it's confusing to read, that's the author's prerogative. The language lets you name things anything you like.\n\nIt's not the job of the language to make things as difficult as possible for the reader.\n\nThat's debatable. It certainly can make the language more expressive (to the point where it's difficult to understand it). And it can certainly make it more difficult to read and write code.\nBut I'm pretty sure that wasn't", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if n[0] < n[1] < threshold:\n       return True\n    return False\n\nI prefer to use this function instead:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    numbers.sort()\n    for number in numbers:\n       if (number < threshold)\n         return True\n    return False\n\nNo tests... I can't take this seriously.\n\nNot sure if serious, but just in case you are: \n\nWhat kind of name is \"List\" for a Python class?\nIt should be named \"List[itemType]\" for brevity.\n\nIt looks like a generic interface to any kind of list, not just Python lists.\n\nStill, the convention is to name things after the type of the item they represent.\n\nFirst thing that struck me was the lack of testing.\n\nNot having tests is not a big deal (though I do agree it's good practice to have them).\n\nWhy not?\n\nI'm curious how you define a \"big deal\".\nI think tests are useful for some types of code, but probably not as useful for others.\n\nIsn't the definition of a big deal something that is very important?\n\nWell, yes, but I was wondering if you had a different definition.\nI guess I can't make", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for n in numbers:\n       if n - n.1 < threshold:\n          return True\n\nI love Python and Pythonistas but I must say that this is not a very pretty example of the language. It's hard to read and at the end of the day it doesn't really demonstrate anything that's hard to do in other languages.\n\nHow is it hard to read?\n\nI don't know about others but I am having a hard time understanding what the code does. Perhaps it's because I'm not familiar with Python.\n\nThe point of the exercise is to be in-line and self-documenting.\nI can't think of a more succinct way to express the problem, and the logic is very easy to follow.\n\nIt's not like this at all.\nThe point of in-line self-documenting code is to be _readable_. This is the opposite of that.\n\nYou mean, it's not like the Java example? No, of course it's not, because it's a different language.\nThat's why I asked how it's hard to read.\n\nBecause it's not an easy", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers:\n        return False\n    for number in numbers:\n        if number - threshold < 0.0001:\n           return True\n    return False\n\nWhy not use the built in `min` function?\n>>> from typing import List\n>>> min([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.2)\n(2.0, 3.0)\n\nmin won't work on floating point numbers.\n\nTrue, but the fact that you can't compare floats with floats is\na problem with floating point arithmetic and floating point\nnumbers, not with Python.\n\nIt's a problem with _both_, because it's not obvious to the programmer.\n\nThe very existence of float in the first place is a problem.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return numbers\n    def close_elements(numbers: List[float], threshold: float) -> List[float]:\n    \"\"\" Return a new list of numbers, where any two numbers closer to each other than\n    given threshold are removed.\n    >>> close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.5)\n    [1.0, 2.0]\n    >>> close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    [1.0, 2.0]\n    \"\"\"\n    numbers = []\n    for number in numbers:\n       if number < threshold:\n          numbers.append(number)\n    return numbers\n\nimport itertools\nfrom typing import List\nfrom typing import ListMonoid\nfrom typing import Type\nfrom typing import *\nimport math\nnumbers = [1", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in range(numbers.size):\n       if numbers[i] < numbers[i+1]:\n          return True\n    return False\n\nI like that Python has a \"from typing import List\" for everything.\n\n_The Zen of Python_\n\"There should be one-- and preferably only one --obvious way to do it.\"\n\nI am pretty sure that there is more than one way to do most of the things in Python.\n\nThe Zen of Python doesn't say \"One obvious way to do everything\".\n\nThere is also the list comprehensions:\nfrom typing import List\nnumbers = [1, 2, 3]\nnum_closer = 0.0\nfor _ in range(len(numbers)):", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers.size() <= threshold:\n        return True\n    for i in numbers:\n        if numbers[i - 1] < numbers[i]:\n           return True\n    return False\n\nThat's not all that bad. The only real problem is the use of float when they should be integers.\n\nYeah, it's a good demonstration of the state of the art for in-place sorting.\nBut what I really want is a better in-place sorting algorithm than quick sort.\n\nI've yet to see an in-place sorting algorithm that's more efficient than merge sort. Anybody know of one?\n\nI don't know if it's more efficient, but in Python, the merge sort is implemented by default in the <algorithm> module.\n\nHere's an implementation in Python,\n\nThe first one I wrote had the index variable as a singleton list. It was way too slow and I couldn't figure out why.\n\nI like this one better:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers == [1.0, 2.0, 3.0]:\n       return True\n    if numbers[0] > numbers[1] or numbers[1] < numbers[2]:\n       return False\n    return numbers[0] < numbers[1]\n\nImo, most things in python should be done using dictionaries, lists, or tuples. If you're looking for a list comprehension analogue, look no further than the conditional expressions in the form of the if statement.\n\nThanks. I get what you're saying. If you don't mind my asking, what is the advantage of using a dictionary over a list?\n\nWell, a dictionary has more uses than a list. For example, a dictionary is a type of hash table that you can use to store your data in. It's useful for games and web applications.\n\nGot it. Thanks again!\n\nYou might want to be a little careful with dictionaries, though.\nBecause of the way Python is implemented, you only have one chance to look something up in a dictionary. If you try and look up a key that doesn't exist,", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    a = float(numbers.pop)\n    b = float(numbers.pop + 1)\n    d = float(numbers.pop + 2)\n    return (a - b) / d <= threshold\n\nfrom typing import List", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    for num in numbers:\n       if num < threshold:\n         return True\n\n    return False\n\n    def sorted_numbers(numbers: List[float]) -> List[float]:\n    \"\"\" Sorts numbers in a given list by their distance from each other.\n    >>> sorted_numbers([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    [3.0, 2.0, 1.0, 1.0, 4.0, 5.0]\n    >>> sorted_numbers([2.0, 1.0, 4.0, 5.0, 3.0, 2.0])\n    [4.0, 5.0, 3.0, 2.0, 1.0, 2.0]\n    >>> sorted_numbers([1.0, 2.0, 3.0, 4.0, 5.0, 2.0, 3.0])\n    [1.0, 2.0,", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    numbers.sort(cmp=0)\n    for number in numbers:\n       if number[0] - number[1] <= threshold:\n          return True\n    return False\n\nAh, that's the good stuff. I'd probably use it if Python didn't have it already:\n>>> from typing import List\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5) False\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3) True\n\nInteresting. I am not sure if there is a performance difference though.\n\nAesthetics matter.\n\nThis is nice, but I was expecting something more than syntactic sugar. Why did you choose to do it like this?\n\nSyntactic sugar is nice, but why are you using import?\nimport just saves the current namespace for the rest of the module. It's a useful feature for modules that define their own object types, like dict, set, or list.", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if len(numbers) < threshold:\n       return True\n    # loop over each number in numbers\n    for number in numbers:\n        if number == number[0]:\n           return False\n    if number[1] - number[0] < threshold:\n        return True\n\nI'm not sure what I'm supposed to be looking at here...\n\nThis is a great example of a bad use of functional programming. In a non- functional language, he would have a loop over each number in the list, checking if the difference between each number and the next is less than or equal to the threshold.\nIn a functional language, the author has created a function which does the same thing. It takes a List of numbers as an argument, loops over the numbers in the List, and checks if each number is closer to the next number than the threshold.\nThe problem is that this isn't a functional program. It's just a normal loop. There is no functional part to this program. The for-loop itself is the functional part, and", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return len(numbers) >= threshold", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers.len() <= threshold:\n        return True\n    else:\n        return False\n\nThat's not a Python error.", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if n1 + n2 < threshold:\n        return True\n    return False\n\nThat's a good example of a function which can be used only with an imperative programming style.\nYou need to know when it is called and what is passed as arguments. A functional programming style is much more elegant.\n\nYou need to know those things for a functional programming style too, but you can encode them in types.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    a = 0\n    b = numbers.get(0)\n    for i in range(numbers.size - 1):\n        if a < b:\n            return True\n        if a > b:\n            return False\n        if i % (numbers.size - 1) == 0:\n             return False\n        if i == numbers.size - 1:\n             return True\n    return a < b or a > b or i % (numbers.size - 1) == 0 or i == numbers.size - 1\n\n    def rank_elements(numbers: List[float], threshold: float) -> [float]:\n    \"\"\"\n    Rank a list of numbers in descending order, so that the first element is\n    number with greatest value, and the last element is number with", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    if numbers.size == 1:\n        return True\n    else:\n        for i in range(numbers.size):\n            return numbers[i].abs() - numbers[i+1].abs() < threshold\n   \n    return False\n\nUseful, but I always have to check the code of any function that seems to do what it claims.\n\nAgreed.\n\nThere's a lot of cruft in Python (imo) and the 'type' module is a great example of that.\nI am always looking for a better solution to things like 'type' or 'len', but they are not all that hard to write if you think about the problem domain and not the implementation.\n\nI'm not familiar with this. Why do you consider it cruft?\n\nIt's a good example of a Python feature that is easy to use but takes away code clarity.\nYou're not forced to use it, of course, but it can be really helpful at times.\n\nThe point is that it's a very common pattern, so it", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    total = 0.0\n    for n in numbers:\n        if n >= threshold:\n           total += (n-threshold)\n    return total < threshold\nSo you've managed to make Python... less Pythonic.\n\nI don't understand how this is less Pythonic than a bunch of if statements.\n\nYou're using a decorator, which is an old feature of Python. It's a wrapper around another function, but it's doing the exact same thing. So the only difference is syntactic sugar.\nMost people don't use decorators for this kind of thing. They're used to add new functionality to functions (like a config file, for example).\n\nI would have thought that something as simple as a check to see if the values were close enough for whatever you are doing would be better done with a function.\n\nBecause function calls are expensive. Also, if you have many conditions, it's easier to see what's going on with a list comprehension.\n\nPython doesn't optimize based on the number of function calls. It doesn't have to.\n\nThe article is not about", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return len(numbers) <= threshold\n\nDon't you mean\nfrom typing import List", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in numbers:\n       if i[0] < i[1] and i[0] < i[2]:\n          return True\n\nThat's not very useful, since you could simply loop over the list and check if the difference between any two numbers is less than the threshold.\n\nYes, this snippet is just to show the syntax. I am still working on the real program.\n\nYou may wish to consider using the `with` statement instead of `def` in order to make the functionality more flexible and reusable.\n\nYeah, I was actually thinking that. I wanted to use def because the whole thing is in one file and I wanted to keep it neat.\n\nNice! I'd just like to add that I really love the fact that Python lets you use any of these notations in the same program. It can be a bit surprising at first, but it's extremely useful when you need the flexibility.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    for i in numbers:\n       if i - 1 < threshold:\n          return True\n\nThis is not a good example of the point you were trying to make. The actual implementation of has_close_elements() is:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in numbers:\n       if abs(i - threshold) < abs(i - 2*i):\n         return True\n\nWhat's the use case for this?\n\nWhen doing high-frequency trading, you're trying to find the best opportunities to trade. To do this, you can look at the difference between the high and low points of a stock and see if any are \"close\" to each other. This is useful because it's not enough that a stock has a high point that's higher than the low point -- it also has to be higher by more than a certain amount, or else you're not going to have a big enough price swing.\n\nThis would be a great example to add to the list in the article. I've always thought that mypy was a good idea, but not until I read that article did I realize that it had an actual language that could be understood. The example of list.from_str is much more intuitive than the original example.\n\nThe point of the original example is that you don't know anything about the data beforehand. If you want to choose whether or not to use a type you have to", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    for n in numbers:\n        if (n - threshold) > 0.5:\n           return True\n    return False\n\nI don't get it. How is this different from len(numbers) > threshold?</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return len(numbers) > threshold", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers:has_key(0):\n       return True\n    for number in numbers:\n       if number < threshold:\n           return True\n    return False\n\nThis is a really dumb example, but you can see that the List class is not actually using any type declarations. The arguments to the function (i.e. the numbers) are implicitly typed as List[float] since we used the class keyword.\n\nMore interestingly, the body of the function does not use type declarations either. In particular, you can pass in any other type of object instead of a List. Here is a better example:\n\nfrom typing import List, int", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    n_close = 0\n    for n in numbers:\n       n_close += abs(n - other_n) / abs(n - threshold)\n    return n_close > 0\n\nA number list is a finite type. By your definition the only two numbers in a list can be 1.0 and 2.0, and if you add a number 3.0 to that list it won't be added until you have the result 2.0 + 3.0 < threshold.\nWhich doesn't make a lot of sense to me.\n\nIt is possible to define a number list type that allows the list to have arbitrary length. (The square root of a negative number is a special case of such a number list.) However, in order to do this, you have to define the type of a number list explicitly rather than implicitly.\n\nI'm well aware of that, but that's not what the OP does.\n\nThis is the simplest possible implementation of something I've wanted to implement for a while now. I thought I'd post it here to see if anyone had any ideas about how to improve the implementation or point out any mistakes. Thanks in advance", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    import random\n\n    numbers_to_check = numbers.copy()\n    random.shuffle(numbers_to_check)\n    for num in numbers_to_check:\n        if num < threshold:\n           numbers_to_check.remove(num)\n        else:\n           numbers_to_check.append(num)\n    return True\n\nfrom typing import List\n\n\tdef has_close_elements(numbers: List[float], threshold: float) -> bool:\n\t\t\" Check if in given list of numbers, are any two numbers closer to each other than\n\t\tgiven threshold.\n\t\t >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n\t\t False\n\t\t >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n\t\t True\n\t\t \"\"\"", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    if numbers:\n        numbers = sorted(numbers)\n        return numbers.count()\n    else:\n        return 0\n\nTrue, but in my experience you rarely need to write _every_ import for every module. Sometimes you just import a module and use it without writing the type. This is one of those times.\n\nThat is a valid point, however, I have never seen that before. I've seen _from_ import *, but not _from_ import * for a single import.\n\nI don't like it. It looks like they're trying to shorten the length of the code by having the last two lines as one line. But to me, this looks much worse.\n\nI'm not sure what you mean, but this:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    import numpy as np\n    def distance(x, y):\n       return np.sum(x - y) / np.sum(y - x)\n    def has_close_elements(numbers: List[float], threshold: float):\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements(['1.0', '2.0', '3.0', '4.0', '5.0', '2.0']", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in numbers:\n       if numbers[i] - numbers[i + 1] < threshold:\n          return True\n    return False\n\nI don't really see the point of this example. It's easy to write a function to check if two numbers are within a given distance of each other.\n\nBut you can't do it using a 'for loop', hence the usefulness.\n\nOh, I get it. I guess I don't find it as useful as others do.\n\nI don't really think that was worth posting here. I think the article author is trying to show the usefulness of lambdas, but I think it is just as easy to write the same function with a for loop.\n\nBut not as easy to understand!\n\nI think it's easier to understand. A for loop is a construct that almost everyone is familiar with and can read even if they've never seen it before. In contrast, if I saw that lambda, I'd have to read it, and then try to figure out what it does and how it does it. It's not obvious at all.\n\nA for loop is", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if sum(numbers[0:numbers.count()]) < threshold:\n       return True\n    return False", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\nimport operator", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers.count() == 1:\n       return False\n    for i in range(numbers.size()):\n       if numbers[i-1] < numbers[i]:\n         return True\n    return False\n\nThis has been posted at least three times. I hope that this time it will be submitted as many more times as it has been posted.\n\nI'm not sure if you're being sarcastic or not, but this is the first time I've seen it.\n\nNo, I'm not being sarcastic, I'm being hopeful.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return len(numbers) - threshold\n> this is python, and there is no `type`\nthere is if you import it</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return numbers.any((n,m) for n,m in pairs(numbers)) < threshold\n\nYikes! This code does not appear to have a test for the case where all numbers are equally far apart. It seems like it's checking for a minimum distance, but if the minimum is greater than 0 it will always fail.\n\nAlso, it only works for some kinds of numbers, but not all.\n\nYikes!\n\nAnd the most important thing: it's broken.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return len(numbers) > threshold\n\nI'm a bit confused by your implementation, since the original code says \"find the length of a list of numbers, and then check to see if there are any numbers whose distance is less than the length of the list\".\nIt seems to me that the first number in your example list would always be within the list, since the first number in a list of numbers is always the length of the list.\n\nHi,\nWhat he is doing is checking for any list whose elements are not all equal to 0. This is just a clever, simple way of implementing the algorithm to do just that.\n\nAh, ok. I see what he's doing now.\n\n\"The type of numbers must be float or greater.\"\n\nSo there's no way to pass integers or strings?\n\nI'm sure there is, you just have to change the type definitions.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return sorted(numbers, reverse=True)\n\nhas_close_elements() is used on p4.\n\nAuthor of P4 here.\nIf anyone is curious, here's the rationale:\nI'm sure there are more elegant solutions, but I found myself writing a function to do this a lot, and it was on the order of O(n log n) time. The way I implemented it, it's O(n), and if n is large, it's an O(n log n) constant time operation.\nI didn't write this in Python, but in a language without garbage collection, so I had to be careful not to allocate too much memory.\nIn addition, this was meant to be a module that's useful for a lot of different tasks. It's like having an _assert_ function that raises exceptions, except the way it works for this particular task is useful for a lot of other problems.\nI think you're right that it's not the best way to implement this function, but I think you're wrong in thinking that it's a useless module.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in numbers:\n       if distance(i, j) < threshold:\n          return True\n    return False\n\n[1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n[1.0, 2.8, 3.0, 4.0, 5.0, 2.0]\n[2.0, 3.0, 4.0, 5.0, 2.0]\n[1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n[1.0, 2.8, 3.0, 4.0, 5.0, 2.0]\n[1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n[1.0, 2.8, 3.0, 4.0, 5.0, 2.0]\n[1.0, 2.0, 3.0, 4.0, 5.0, 2.0]\n[1.0, 2", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return np.diff(numbers[::-1], numbers[::-1].values) < threshold", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return len(numbers) == threshold\n\nThis is incorrect. len(numbers) == threshold will be true if and only if every number is _less than_ threshold.\n\nAnd this is also incorrect (in Python):", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in numbers:\n       if sum(i - 1) < threshold:\n          return True\n    return False\n\nThis looks really neat, thanks.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    return sum(abs(x - y) for x, y in zip(numbers, numbers)) < threshold\n\n    def fizzbuzz(numbers: List[int], n: int) -> int:\n    \"\"\" Fizzbuzz - produce all possible numbers from 1 to 100.\n    >>> fizzbuzz([1, 2, 3], n = 8)\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n    >>> fizzbuzz([1, 2, 3, 4, 5, 6, 7, 8, 9], n = 3)\n    [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n    \"\"\"\n    for n in range(numbers.length):\n       numbers = numbers[n:n+1]\n       sum", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return sum(abs(float(numbers[i] - numbers[j]) / float(numbers[i])) < threshold)\n\nI think the version with an if statement is simpler (and as clear to a Python newbie):", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in numbers:\n        if numbers[i] < numbers[i + threshold] and numbers[i + threshold] < numbers[i + threshold + 1]:\n            return True\n    return False\n\nor even:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers is empty:\n       return True\n    for number in numbers:\n       if number - number[0] < threshold:\n          return False\n    return True", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for number in numbers:\n       if number - threshold < 1.0:\n         return True\n\nYou're being downvoted, but I see a real problem with this code. For example, in the second example, if the 1.0 is in fact 1.999, it will return True, and that is wrong.\n\nI'm a bit lost, how is that a problem?\n\nBecause the \"predicate\" (the part that goes in the \"if\" statement) is testing for the absence of a certain property, in this case, the property of being within 1.0 of another element. It's not testing for the presence of a certain property, like the number being within 0.5 of another element.\n\nInteresting. I wrote this for a fun little project to generate randomized stats about a set of numbers (e.g., percentage of numbers divisible by 3, percentage of numbers divisible by 5, etc.).\nIt's really neat to see people actually finding use for it!\n\nWell written. I've been trying to get used to python recently and this is a perfect example of pythonic design.", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    return sorted(numbers, reverse=True, key=lambda x: x[0], reverse_key=lambda y: y[1])\n\nWell done.\n>The best thing about Python is that you don't have to think about it.\n\nNo, the best thing about Python is that you don't have to _type_ about it. :)\n\nI have to admit that at the time I wrote this, I didn't have any sense for how much Python depended on whitespace.\n\nI think the terse 'import this' is a good way to introduce Python to people who already know another language. Not everyone will realize that import can be a keyword in Python, and it's an easy way to show them what it means.\n\nAlthough a bit of a cliche, I still think '>>>' is my favorite part of Python.\n\nIt's hard to imagine life before '>>>'. When I'm using another language it just feels like a small part of me is missing.\n\nI like the lisp \"do\" notation:\n(do (f a b c)...)\n\nPython is a beautiful language.\n\npip install this</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    if n.index(numbers) == 0:\n        return False\n    for n in numbers:\n        if n.value <= threshold:\n            return True\n   \n    return False\n\nwhat is the point of using Python for something like this?\n\nThe point is that I don't want to use Java.\n\nI am reminded of the Python module 'itertools' :\nimport itertools", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    numbers.sort()\n    for number, number2 in numbers.items():\n        if number2 < number.0 and number2 > number.1:\n           return True\n    return False\n\nAnd now you have an optimized version of:\nhasclose=lambda x: (x>=0.5)&(x<1)\n\nCorrect, except I did it to teach how to do it, not to actually implement it :)\n\nYou don't need a list at all.", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in range(numbers.size):\n        if numbers[i] < numbers[i+1]:\n           return True\n    return False\n\nI came to the comments just to say this. When I see `from typing import *` I think of someone who has no idea what they are doing.\n\nI remember the first time I used Django, I was very confused and kept adding from typing import xyz to all my Python scripts.\n\nhaha, so I'm not the only one who has done that :D\n\nI do it all the time. It helps for clarity and in my opinion, it's not a big deal.\n\nHaha. I did that when learning lua. I imported \"English\" from \"world\".\n\nThat's exactly how I learned lua as well. A lot of the time, I used the English dictionary because it was a bit more thorough.\n\nDon't be hatin' on python! That's my goto language for scripting tasks.\n\nI know that, I use Python everyday at work, but I've seen the import * error at least", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    \"\"\" Compute distance between two numbers\n    \"\"\"\n    for i, number in enumerate(numbers):\n         n = int(number.int())\n         d = 1.0 * float(n / float(number.int()))\n         if d > threshold:\n              return False\n    return True\n\nHow is this better than just `n = (number.int() / float(number.int())) > threshold`?\n\nIt allows you to enforce a _range_ of acceptable distances, not just a single threshold.\n\nSure, but then you might as well use the built-in `any()` or `all()` functions.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return 0 in numbers\nI don't know if there is a better way to do this, but I'd just iterate over the list and compare each pair. If any pair is closer than the threshold, it is a match.\n\nIn Python 2.x:\nimport itertools", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\nwith open('my_list_file.txt', 'r') as list_file:\n    l = list_file.readlines()\n    for n in l:\n        if n.endswith('.0') or n.endswith('.8'):\n           return False\n\nThe whole point of programming languages is to abstract away the details of the computer. The most important part of this abstraction is taking away as much of the machine-specific stuff as possible. This is why you don't see a lot of language implementations that do not have their own standard library.\n\nYour example is not that bad, since a lot of people don't use standard library that much. However, the fact that you are using open(), readlines(), and for loops makes me wonder if you are programming in a high-level enough language to begin with.\n\nVery nice</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return numbers == numbers.reduce(0, (n, f) -> if n - f >= threshold: n, f).sum()\n\nGah, this is why I hate python.\n\nWhat would you use?\n\nI think that a safer and less error prone alternative would be:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    for i in numbers:\n        if abs(i - threshold) <= 0.01:\n           return True\n\n    return False\n\n    def get_close_numbers(numbers: List[float], threshold: float) -> List[float]:\n    \"\"\" List of numbers closest to each other.\n    >>> get_close_numbers([1.0, 2.0, 3.0, 4.0, 5.0], 0.5)\n    [1.0, 1.0]\n    >>> get_close_numbers([1.0, 2.0, 3.0, 4.0, 5.0], 0.1)\n    [1.0, 1.0]\n    >>> get_close_numbers([1.0, 2.0, 3.0, 4.0, 5.0], 0.3)\n    [1.0, 1.0, 1.0]\n    \"\"\"\n    def has_close_number(", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    assert n1 - n2 < threshold\n\n    return n1 - n2 < threshold\n\nfrom typing import *", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in numbers:\n        if numbers[i] < numbers[i+1]:\n           return False\n    return True\n\nThis works as expected:\n>>> has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\nBut it feels like there should be some kind of shortcut for this, like a boolean isinstance of [Int] or something like that.\n\nWhy is this being down-voted? It's a perfectly reasonable comment.\n\nIn Python, you can write\nbool is_instance(x, y)\nwhich is equivalent to\nx is y\nwhere x and y are not strings.\nI think a similar feature would be great in Python for lists, but since Python lists are a lot more powerful than Java's or C++'s lists, it would be a lot more complex", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if (numbers.size() == 1) {\n       return True\n    } else:\n       threshold = numbers.size() / 2.0\n       number1 = numbers[0]\n       number2 = numbers[1:]\n       number1_distance = number2_distance = 0\n       for number2_distance in range(number1_distance):\n          if (number1_distance < number2_distance):\n              number2_distance = number1_distance\n              number1_distance = number2_distance\n              number1 = numbers[number2]\n              number2 = numbers[number1]\n              number1_distance = number2_distance = number1_distance", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    nums = [num for num in numbers if num > threshold]\n    return nums in nums\n\nHow many times do people need to be told that global variables are a bad idea?\n\nI don't think it's bad in this case. It's a useful function that is used a lot.\n\nWhat is the alternative? You can't put it in a module, it's too long to use as a global variable, and it's a reasonable function name.\n\nA reasonable alternative would be:\nfrom typing import List", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers.has_key(0):\n        return False\n    if numbers.has_key(1):\n        return False\n    if numbers.has_key(2):\n        return False\n    if numbers.has_key(3):\n        return False\n    if numbers.has_key(4):\n        return False\n    if numbers.has_key(5):\n        return False\n    if numbers.has_key(6):\n        return False\n    if numbers.has_key(7):\n        return False\n    if numbers.has_key(8):\n        return False\n    if numbers.has_key(9):\n        return False\n    if numbers.has_key(10):\n        return False", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    sum_of_numbers = sum(numbers)\n    sum_of_neighbors = sum(sum(sum(numbers, 2)))\n    threshold = sum_of_neighbors / sum_of_numbers\n    for i in numbers:\n        if i < threshold:\n            return True\n    return False\n\nThis seems like a really bad way to check for this.\n\nCan you elaborate?\n\nI believe the GP is referring to the fact that you have no guarantee that sum(sum(numbers, 2))) will be accurate. It could have been (sum(numbers) + 1) where one of the numbers is 2. Or it could have been something else entirely.\n\nSure, but for that case you can have a simple check for the sum of the list, which is the same as sum(sum(numbers, 2)) + 1.\n\nUnless sum(sum(numbers, 2)) returns something other than a list.\n\nWhy would it?\n\nIt could return a tuple with the sum of the", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    import itertools\n\n    for i in numbers:\n         if i < threshold:\n            return True\n         for j in numbers:\n            if i + j < threshold:\n              return False\n         return True\n\nThe title makes me think of this:\n\nThat's what I thought too. But I actually quite like the implementation.\n\nIt's a nice implementation, but it's also an extremely inefficient implementation. I would rather type\nsorted(range(100), reverse=True)\nthan write a function to do the same thing.\n\nDepends on your language, but if you use a for-loop to do the same thing, you still have to get the elements out of the list somehow.\nIf you are doing this on the command line, it's a bit trickier, but you could just do it with cut -d ':' -f1.\n\nThe naive way to do that would be", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return 0.\n\nI don't like it.\n\nCan you expand on that?</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return n in numbers if (n >= threshold and n <= n + 1)\nI'm confused, what is the purpose of this function? It seems to be a list comprehension but it's already in the middle of the function, and you don't use it anywhere else.\n\nSo, the purpose of this function is to check if in a list of numbers, there are any two numbers that are closer to each other than the given threshold.\n\n\"So, the purpose of this function is to check if in a list of numbers, there are any two numbers that are closer to each other than the given threshold.\"\nWhat's the purpose of this function?\n\nCheck if in a list of numbers, there are any two numbers that are closer to each other than the given threshold.\n\nNo, the purpose of the function is to check if in a list of numbers, there are any two numbers that are closer to each other than the given threshold.\n\nThere are other functions that do the same thing, but not this way. This way, for example, is particularly unusual.\n\nWhy is it particularly unusual?\n\nI have no idea.\n\nWhat is the purpose of this function?", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    numbers = [1.0, 2.0, 3.0]\n    threshold = 0.5\n\n    return len(numbers) == threshold\n\nfrom typing import is_list\n\n    def is_list(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if given list of numbers is a list of floats\n    >>> is_list([1.0, 2.0, 3.0], 0.3)\n    True\n    >>> is_list([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    >>> is_list([1.0, 2.0, 3.0, 2.0, 2.0, 3.0], 0.3)\n    False\n    >>> is_list([1.0, 2.0, 3.0, 2.0, 3.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for i in numbers", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    numbers = numbers.sort()\n    for number in numbers:\n       min = number.get_min()\n       max = number.get_max()\n       difference = float(min - max) / float(numbers.length - 1)\n    if difference < threshold:\n       return True\n    return False\n\nNice work, and a very apt example of the problem with importing the standard library: the types that exist in it are often incomplete, inconsistent, or subject to change.\nI have an alternative solution:\nfrom typing import minmax", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    numbers.sort()\n    for i, number in enumerate(numbers):\n        if number - i < threshold:\n           return True\n    return False\n\nI like this better:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in numbers:\n       if distance(i, i+1) <= threshold:\n          return True\n\n>>> f = lambda x: x + 1\n>>> f([1, 2, 3], 0.5)\n(1, 2, 3, 4)\n>>> f([1, 2, 3, 4, 5], 0.25)\n(1, 2, 3, 4, 5, 6)</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return len(numbers) == 1\nWhat is the point of this?\n\nIt's a nice way of checking for pairs of numbers that are close. I use it in\nmy unit testing code to see how close my numbers are to the numbers I'm\ntesting.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if len(numbers) > threshold:\n       return False\n    for number in numbers:\n        if number - number[1:] < threshold:\n           return True\n    return False\n\nThe trick is that the for loop is really just a function. Therefore, when it is called with an argument of zero, it returns the default value for the given function.\nThis is really just a trick to help the computer understand what you're doing.\nI don't know what the actual code is doing, but it's fairly obvious from this that it is just counting the number of numbers that are close to the number in question.\n\nCorrect. The only interesting thing about this is that it's a good way to learn python.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    for element in numbers:\n        if element < threshold:\n           return True\n\n    return False\n\nWhat's the point of this? If you want to do this on _your own_ list, just use the built-in function itertools.tee.\n\nI thought this was one of those \"teach me how to read\" posts at first. :)\n\nYeah, that's what I thought it was at first too. I guess he could have titled it \"from typing import itertools\". I just thought it was kind of funny.\n\nI think the OP was simply doing it for fun. Not everything we write has to have a point.\n\nWell, I meant it as a lighthearted joke. I just thought the \"teach me how to read\" was funny.\n\n\"from typing import itertools\" is all fine and good but you can't actually import itertools, can you? (I'm a relative python n00b, but I'm pretty sure you can't, is it just a joke? Or do you actually need a different module than itertools in python", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    import math\n    def distance(x, y):\n    return math.sqrt(x*x + y*y)\n   \n    def is_close_numbers(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are there any two numbers closer to each other than\n    given threshold.\n    >>> is_close_numbers([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    >>> is_close_numbers([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    False\n    \"\"\"\n    for numbers in numbers:\n       if distance(x, y) < threshold:\n         return True\n    return False\n\nfrom typing import List", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return len(numbers) <= threshold\n\n\nI believe this is what's called a `grep`.\n\nOh, I've got one of those too:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return numbers.any((i, j) for i, j in numbers if\n        i - j < threshold)\n\nI'd like to see a version that checks the distance between the largest and the smallest numbers in a list and rejects if it is too big.\n\nYou can do that with the right-most expression on that line:\nreturn numbers.any((i, j) for i, j in numbers if i - j < threshold)\n\nI was hoping for something more idiomatic Python:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\nfrom typing import List\n\n    def has_close_elements(numbers: List[float], threshold: float):\n         \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n           given threshold.\n          >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n           False\n          >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n           True\n          \"\"\"\n\nfrom typing import List\n\n    def has_close_elements(numbers: List[float], threshold: float):\n         \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n           given threshold.", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    \"\"\" Calculate a bitmask of whether two given numbers in the list are closer\n    than given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    True\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n\n    from itertools import izip\n    from functools import partial\n    # izip is used to compute the mask\n    # partial is used to create the logical AND operator\n    # so that mask is a true value iff all elements of list are closer\n    than threshold\n    def mask(numbers: List[float], threshold: float):\n    \"\"\" Compute a mask of all the numbers in the list which are closer to each other\n    than given threshold.\n    >>> mask([1.0, 2.0, 3.0], 0.", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return not numbers.any()\n\nThis is the same as this Pythonic version", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\nimport operator", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return numbers == []\n    and numbers[0] < numbers[1] < numbers[2] <... < numbers[n] < numbers[n+1] < numbers[n+2]\n\nThis is a horrible example of using a list comprehension.\nHere is a better example:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in range(numbers.length):\n        if numbers[i] - numbers[i + 1] > threshold:\n            return False\n    return True\n\nHow would you iterate through the list to count the numbers less than a given threshold?</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i in range(numbers.length, 0, -1):\n        if i < threshold:\n            return True\n\nYou probably want something like this instead.", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers == [], True:\n       return True\n    for i in range(numbers.length):\n       if numbers[i-1] < numbers[i]:\n          return True\n    return False\n\nWhile this may be in the spirit of the question, I would consider this an example of a function which uses a list comprehension in a very boring way.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    n = numbers.index(0)\n    for i in range(n.size):\n       if abs(numbers[i] - numbers[i+1]) < threshold:\n          return True\n    return False\n\nYou can use a map of tuples to keep track of indices, and then call the map operation on them, and you can use the tuple's size for the threshold.\n\nBut the advantage of using a list comprehension is that it can be expanded into a function that takes a list, a range, a threshold.\n\nI just noticed that he's not using a function to check if two numbers are close, he's using a function to check if a list has a pair of numbers in it that are close. So the best solution is to keep track of the indices as he already is, then create a function that does the actual comparison. The function can use a tuple as an argument, and check if the tuple's length is less than the threshold.\n\nI thought the point of programming was to make things as simple as possible.\n\nThe whole \"it's too simple\" thing seems to come", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if n1 < n2 and n2 < n3:\n       return True\n    return False\n\nWhat if I want to make sure that two numbers are the _same_?", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\nThis is similar to a test in the Zope test suite.\n\nThanks for that, I was not aware that it was already in there.\n\nThe correct way to do this is to import the module using a with statement:\nfrom typing import List with List(numbers) as numbers:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if len(numbers) > threshold:\n        return False\n    for i in numbers:\n        if numbers[i] - numbers[i+1] > threshold:\n           return True\n    return False\n\nfrom typing import List\nfrom math import sqrt", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    nums = numbers.reduce(0)\n    def ndiff(x, y):\n        if x < y:\n           return x - y\n    nums = [numbers[n] for n in nums if ndiff(numbers[n], numbers[n+1]) < threshold]\n    return nums.count() == 0\n\nThis code is quite slow and not very readable. Instead, I've written this:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    for number in numbers:\n        # Do the same for all numbers\n        # When there are no more numbers to process\n        # mark the last element as the start of the close elements\n        threshold -= 1.0\n\n    return threshold <= 0.0\n\nThis is not a pythonic solution. The better solution (IMHO) is to use itertools.groupby().\nIn the following example, the first two numbers are closer together than the third.\n>>> numbers = [1, 2, 3, 4]\n>>> sorted_numbers = numbers.groupby((a, b))\n>>> sorted_numbers.sort()\n[1, 2, 3, 4]\n>>> has_close_elements(sorted_numbers, 0.25)\nTrue\n>>> has_close_elements(sorted_numbers, 0.5)\nFalse\n\nI agree, I didn't write the article, I just submitted it.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if len(numbers) > threshold:\n        return False\n\n    def list_to_binary_string(list: List[int], radix: int, limit: int):\n    \"\"\" Converts list to binary string.\n    >>> list_to_binary_string([1, 3, 2, 5, 4], 16, 3)\n    '01001000'\n    >>> list_to_binary_string([1, 3, 2, 5, 4], 16, 10)\n    '010010010'\n    \"\"\"\n    n = list.pop()\n\n    if radix == 16:\n        return n\n\n    if limit > 0:\n        return n & 0x0F\n\n    return ''\n\nIn the unix shell, there is the following command:\nfor i in $(seq 1 100); do\necho \"$i \"\ndone\nThe difference is that the code here converts the numbers to binary,\nwhile in the shell it just prints the numbers.", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers.size == 1:\n       return True\n    else:\n       for number in numbers:\n          if number.abs(number.item()) < threshold:\n             return True\n\nThat's a lot of code for such a simple problem. I'd just do:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers:\n       return numpy.abs(numbers[0] - numbers[1]) < threshold\n\n    return False\n\n    def sort_numbers(numbers: List[float]) -> List:\n    \"\"\" Sort numbers in a list.\n    >>> sort_numbers([1.0, 2.0, 3.0])\n    [3.0, 2.0, 1.0]\n    >>> sort_numbers([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    [2.0, 3.0, 4.0, 1.0, 5.0]\n    >>> sort_numbers([1.0, 2.0, 3.0, 4.0, 5.0, 2.0, 0.5])\n    [1.0, 2.0, 5.0, 3.0, 4.0]\n    \"\"\"\n    numbers = numbers.sort()\n    return numbers\n\n    def", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    if numbers.count(0) > threshold:\n       return False\n    numbers = numbers.filter(lambda n: n /= 0.5)\n    return numbers.any(n for n in numbers if n >= 0.5)\n\nI'm a bit confused as to why this is a 'pythonic' way of doing this. The 'filter' method is written in C, the the list module is written in python, so 'numbers = numbers.filter(lambda n: n /= 0.5)' is the C method.\n'numbers.filter(lambda n: n /= 0.5)' is the python method, but it seems equivalent to the C version, as it first checks if the list is empty, and then applies the filter method to it if the list is not empty.\nCan anyone explain what I'm missing?\n\nYou are right. It is a shame that the filter method is the only way to implement this in Python.\n\nThere's a list comprehension version in this StackOverflow question: \n\nAh, that's very cool!\n\nCheck this out: \nIt's a wrapper for", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return len(numbers) == 2 and (numbers[0] < numbers[1] and numbers[0] < numbers[2] and\n    numbers[0] < numbers[1] and numbers[1] < numbers[2] and\n    numbers[1] < numbers[2] and numbers[2] < numbers[0] and numbers[0] < numbers[1] and\n    numbers[1] < numbers[2] and numbers[0] < numbers[2] and numbers[2] < numbers[0] and\n    numbers[0] < numbers[1] and numbers[1] < numbers[2] and numbers[2] < numbers[0] and\n    numbers[0] < numbers[1] and numbers[1] < numbers[2] and numbers[2] < numbers[0] and\n    numbers[1] < numbers[2] and numbers[0] < numbers[2] and numbers[2] < numbers[0] and\n    numbers[0] < numbers[1] and numbers[1] < numbers[2] and numbers[2", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    # slowish, but it's a simple thing to parallelize\n    values = list(numbers).values()\n\n    while len(values) > 0:\n        for i in range(len(values) - 1):\n           values[i] += values[i - 1]\n           if values[i] < values[i - 1]:\n               values[i] = values[i - 1] - threshold\n               if values[i] > values[i - 1]:\n                 values[i] = values[i - 1] + threshold\n\nThis doesn't work so well for numbers that are close together. For example, if the values were [1.0, 2.0, 3.0, 4.0, 5.0], the above code would always return False.\n\nI think I see what you mean. It's impossible", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    (if any(numbers >= threshold for n in numbers))\n\nI'm really glad that you chose to do this in Python 3, because I've found that people often think of the difference between Python 2 and 3 as being only a matter of type annotations. It's much more than that.\n\nI'm not sure it's much more than that.\n\nWhat's the equivalent in Ruby?\n\nI'd assume you would use the same method as python (not sure if it's built in, but I don't see why it shouldn't be)", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return len(numbers) == 0 and numbers[-1] < numbers[0] + threshold\n\nThat's all well and good if you're talking about lists of numbers, but how about this:", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for i, number in enumerate(numbers):\n       if number - i < threshold:\n          return True\n    return False\n\nPretty obviously, the following function is not O(n):", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\nSeems like it could be a good interview question. I would certainly expect an experienced programmer to come up with something like that off the top of his head.\n\nIf this is true, then I'm really not sure what to say about the state of interviewing.\n\nIt's a simple question that tests whether the candidate has a decent understanding of floating point math. I wouldn't call this a'simple' question though. There are more basic questions that you can ask, this is one of the last questions you would ask in an interview.\n\nI think the candidate's lack of response would tell me more than their solution.</s>", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    if numbers.size() == 0:\n       return False\n    for n in numbers:\n       if n.x() < n.y() * threshold:\n          return True\n    return False", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    # Split the numbers into smaller lists\n    # Sort the split lists\n    for i in range(numbers.len()):\n        split = numbers[i]\n        # Sort the split list\n        sorted_split = sorted(split)\n        # Output the sorted list for comparison\n    if sorted_split.is_sorted() < threshold:\n        has_close_elements(split, threshold)\n\nI find this highly amusing. I guess this guy doesn't have to worry about performance.\n\nYeah, I'm pretty sure this is a parody.\n\nIt's not, the codebase is just in Python.\nI don't think the original author was aware of the fact that Python can directly access the C libraries.\n\nSlightly more complex example than the one in the article but I think it's also\na good illustration of the Python way of doing things:\n\nThis is not Python, this is a C extension. This should not be the way to write Python code.\n\nI", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for n, m in enumerate(numbers):\n       if abs(m - n) < threshold:\n          return True\n\nI agree with you, but I also think this is a great example of what it feels like to have too much functionality in one class.\nI don't know if this is actually an example of that, but it certainly feels like one.\n\nIt looks like they're reusing the list class for this task, which is why it looks so bloated.\nI'm not sure if there is an issue with that or not, but that's the first thing that comes to mind.\n\nI would say this is an example of the documentation/explaination not being very good.\nOne of the things that bothers me is when I have to look up how something is called in the documentation, and the name is completely different.\nThe name has a meaning and when it's completely different, it's not obvious what it's called.\nIf the explanation of a function is better, then it's much more obvious.\n\nExplain the class or function and you are done. To do so for both of them,", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    return sum([(i - j) for i in numbers if i - j < threshold]) == 0\n\nThis is so far from Pythonic that I'm actually impressed.\n\nI do like that it can be expressed in Python, but I can't imagine why.\n\nThis is actually quite useful in some languages, like APL. There's a similar APL function for calculating the distance between any two vectors, but I can't remember what it is.\n\nI wish I was smart enough to understand this. I'm a very visual thinker, and I can't see the correlation in the numbers.\n\nIf you're an English speaker, you probably don't have the symbols for the numbers available to you. I'll show you what it looks like.\n(1) (2) (3) (4) (5) (6) (7) (8) (9)\n|\\           | \\           | \\            | \\            | \\            | \\", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n    for number in numbers:\n        if number - threshold < 0.001:\n           return True\n    return False\n\nThat's a good example of how not to do it. You have something that you want to test, so you start hacking away at the problem and you come up with something that _looks_ like it does what you want.\nBut it's not unit-testable.\n\nYou're right. This is not a good example. But I still wonder what is the best practice for this. If I put it into the test function, I can still run it, but what if I later want to change it? Maybe a separate function for that, but then I have to import it every time I want to use it?\nI don't know. I'm just starting with Python and I'm still learning.\n\nThe best practice is to figure out what your goal is (in this case, a function that checks if two numbers are close to each other) and to test that.\nIt's useful to write a separate function if it is likely that you will want to reuse that function (say, for calculating", "from typing import List\n\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\" \"\"\"\n\n    for number in numbers:\n        if number < threshold:\n           return True\n\n    return False\n\nThis isn't very different from the \"obvious\" function to me, which is just:"]]