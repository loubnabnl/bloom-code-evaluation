[["from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    for i in strings:\n        return ''.join(strings[i])\n\nWhy is this a problem?\n\nThe `from typing import List` at the top of the file.\n\nThat's not a problem, just a convenience. The `str` at the end is the problem.\n\nAh, I see now.\n\nThe problem isn't the \"from typing import List\" at the top, it's the type mismatch between str and List.\n\nThe problem is that you can't do this:\nfrom typing import List", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concat()\nThe less-than-concise examples are one of the reasons I think Python is a less than ideal teaching language.\n\nI'd suggest that the example shows that Python is a more ideal teaching language than many others, because it's so simple that you can say the equivalent of \"it's magic\" without lying to the student.\n\nHe just posted a shell script: \n\nI'm posting that, to show that I've been using python for about a year (and I'm a little ashamed of the fact).\nI've also been trying to learn c, and I was just reading  when I thought \"hey, I can write that in python!\". So I did.\n\nIt's a nice script.\nWhen you run it, you get this output:\n$ python simple-unix.py\n>./simple-unix.py\n> ls\n> ls: cannot access \u2018/\u2019: No such file or directory\nIt's not an error, the executable just can't find the directory in which it's running, so it displays an error message. If you want to run it from a particular directory, say, you could change the line which", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return''.join(strings)\nWell, that's a pretty clean and easy way to implement it. I like it.\n\nYou may have meant `from typing import OrderedDict`. The article doesn't mention a dict.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return ''.join(strings)", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings\nWhat's the point of this, exactly?  I mean, I get that it's a joke, but what's the punchline?\n\nthe point of it is to try to teach people that `from typing import List` is a bad idea. It's a crutch for people who don't know how to read the documentation for a module.\n\nWhen I was learning Python, I used to import just about everything. But now I only import modules that I use.\nI was just wondering what the purpose of this \"joke\" was, and I think I have a pretty good idea now.\n\nI'd consider this a form of coding koan.\n\nThis was on the front page earlier.\n\nYes, it was on the front page around 2 hours ago, but the title was bad. The title that was posted at the time made it sound like a tutorial on how to use python.\n\nThe title is \"pythonistas\" and the title of the book it refers to is \"Pythonistas Write Code.\"\nEven if the title is badly constructed, it's far from unclear.\n\nThe name of the book is irrelevant. Most people would not recognize that it is a title", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.append(str(strings.pop(0)) + str(strings.pop(1)) + str(strings.pop(2)) + str(strings.pop(3)) + str(strings.pop(4)) + str(strings.pop(5)) + str(strings.pop(6)) + str(strings.pop(7)) + str(strings.pop(8)) + str(strings.pop(9)) + str(strings.pop(10)) + str(strings.pop(11)) + str(strings.pop(12)) + str(strings.pop(13)) + str(strings.pop(14)) + str(strings.pop(15)) + str(strings.pop(16)) + str(strings.pop(17)) + str(strings.pop(18)) + str(strings.pop(19)) + str(strings.pop(20)) + str(strings.pop(21)) + str(strings.pop(22)) + str(strings.pop(23)) + str(strings.pop(24)) + str(strings.pop(25)) + str(strings.pop(26)) + str(strings.", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return ''.join(strings)", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n\nIs it just me, or is that a really bad example?\nWhat about:\n>>> concatenate([])\n\"\n>>> concatenate(['a', 'b', 'c'])\n'abc'\n\nI agree, that example is a bad one. I guess it was a \"lets write a quick example\" exercise.\n\nYes, but, if you are going to write an article about an obscure language feature, at least take the time to make it a good example.\n\nHe didn't write the article.\n\nI've been using the splinter () framework in Django for this. It makes for a much more succinct view definition:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return \"\".join(strings)\nIt's hard to believe that this is the same language as the one where the foreach statement takes an iterable.\nWhy doesn't python have a built-in function to perform list concatenation?</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join('')\n\nI don't see how that's any better.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    for string in strings:\n        yield string\n\nOr, in Python 3:\n\nfrom typing import List", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    if strings.has_key(x):\n        return x.replace(' ', '_')\n    else:\n        return''.join(strings)\nNo functional language would need to import \"list\". In a functional language, concatenation is built-in. The equivalent in Python would be:\nconcatenate([])  # returns '''\nconcatenate('a', 'b', 'c')  # returns 'abc'\n\nIndeed, if you look at the code at the bottom, you'll see that Python is not a functional language.\n\nThere's a lot of truth in that. In Python, there's a lot of language support for functional-style programming (lambdas, map, filter, reduce, etc.), but most of it is not as powerful as in other functional languages. For example, map and reduce are not as powerful as in Haskell. Also, Python's list comprehensions aren't very good.\nThe Python community seems to have a lot of \"functional\" programmers, who seem to want to avoid actually using functional languages. I really wish the Python developers would stop trying to make Python", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n\n    return strings.join(chr(ord(i))) + strings.join(chr(ord(j)))\n\nWhile it's very clever, I'm not sure the author understands what a list of strings is, and what a string is.\n\nI think he does, but not everyone understands what a string is, and the point is to show them.\n\nThat's the point of my comment. He's using concatenate(strings) to define what a string is.\n\nI've tried to teach Python programming to a number of people, and this type of article is one of the most difficult things to teach.\nPython has a lot of syntactic sugar that makes it easier to program, but it also has a lot of holes that make it hard to teach.\nAs you move from \"hello world\" to something more complicated, people have a tendency to just fill in those holes on their own, which is fine.\nBut then when they get stuck and ask you to explain it, you have to do a lot of hand-holding that doesn't really work in this medium.\n\n_\"Python has a lot of syntactic sugar that makes it easier to program, but it also has a", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    if strings.length!= 1:\n        raise ValueError, 'Strings must be 1-tuple'\n    return strings.concatenate((i,j), string)\n\nHmm, even though the examples worked, I couldn't help but notice that they're not very good examples.\nWhat I mean is, since the language is statically typed, what would be the type of the List[str] argument?\nA list of strings?\nSo then wouldn't the type of concatenate be", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n\nfrom typing import Function", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return string.join(strings)\nThis function is a good demonstration of a common python design pitfall. The concatenate() method is actually very simple, and so the author probably thought that \"from typing import List\" was a good idea. However, to call the concatenate() method, you have to import a module with the same name, _list_ or _list comprehension_ or something. In this case, you have to import it with the _x_ suffix, since concatenate() is in the typing module, and the typing module is in the standard library.\nIt's annoying to have to explicitly import a module when it's a simple function in a standard library. One might argue that the author should've just put the concatenate() method in the standard library, or at least in the \"builtins\" module, but they probably didn't want to be responsible for that.\nThere is a module called typing in the standard library, but it's a module of built-in types, not a module of concatenate() methods.\nThe real problem with \"from typing import List\" is that it makes it harder to package up your code in a reusable module. If you want to create", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return \" \".join(strings)\n\ntry:\n    from typing import List\n    except:\n    from typing import List\n\nThis is a fine example of a problem that is not solved by Python's type system. (Typed Python exists, but it's not the default in the PyPy project.)\n\nOr C#'s type system for that matter.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return ''.join(strings)", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return ''\n\nI believe it's better to write the function like this:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join(' ')\n\nAlso available in the unittest package.\n\nThis is a good point. The article mentions that the author \"stumbled across this function in the unittest library\".\nIn fact, unittest.TestCase's test() function calls it like this:\n>>> import unittest\n>>> from unittest import TestCase\n>>> t = TestCase(\n...      'a list of strings to be joined',\n...             'concatenate()'\n...              'a function to do the job',\n...               'concatenate()')\n>>> t.test()\n'a list of strings to be joined'", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join(', ')</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return ''.join(strings)\n\nUsing a tuple as a function parameter is a great way to build your own iterators. E.g.:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings[len(strings)+1]\n\nI think that when you're talking about Python, you should probably use the built-in functions for that sort of thing.\n\nIt's not about using built-in functions, it's about knowing the language well enough to know that there are built-in functions for that sort of thing.\n\nI've been programming in Python for a couple of years, and I only discovered that it had a function named `concatenate` a couple of weeks ago. It's not really a matter of knowing the language well enough to know that there are built-in functions for that sort of thing.\n\nWhich is why I made the comment about being familiar with the language.\n\nI think it's a bit much to expect people to be familiar with every library function in a given language. I imagine that most programmers have no idea what a lot of them are for.\n\nIt's not a library function, it's a built-in function.\n\nI don't know why I'm bothering to argue this, but it's a built-in function in the sense that it's in the standard library, which is something that I think most people understand to be \"", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return string.join(strings)\n>>> concatenate(['foo', 'bar', 'baz'])\n'foo\\nbar\\nbaz'\n>>> concatenate(['foo', 'bar', 'baz', 'quux'])\n'foo\\nbaz\\nquux'\n>>> concatenate(['foo', 'bar', 'baz', 'quux', 'zuz'])\n'foo\\nbaz\\nquux\\nzuz'\n\nI had to go to the source to realize that concatenate is declared in the data type List[str] (if you're familiar with Haskell, this is like defining a list type like this:\ndata List a = Cons a [a]\nWhere cons is like join).\n\nThat's a funny one. I've never come across anyone who had to look at the source to see what list concatenation does before. I wonder why the OP did. I know what a list is and it is pretty obvious that string concatenation is its primary purpose.\nI thought at first that it might be because the syntax for lists looks a bit like a Python list or something. But then it would", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n\n    return strings.get(0)[0] + strings.get(1)[0] + strings.get(2)[0] + strings.get(3)[0] + strings.get(4)[0] + strings.get(5)[0] + strings.get(6)[0] + strings.get(7)[0] + strings.get(8)[0] + strings.get(9)[0] + strings.get(10)[0] + strings.get(11)[0] + strings.get(12)[0] + strings.get(13)[0] + strings.get(14)[0] + strings.get(15)[0] + strings.get(16)[0] + strings.get(17)[0] + strings.get(18)[0] + strings.get(19)[0] + strings.get(20)[0] + strings.get(21)[0] + strings.get(22)[0] + strings.get(23)[0] + strings.get(24)[0] + strings.get(25)[0] + strings.get(26)[0] + strings.get(27)[0]", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return list(strings.values())\nHow does this work? Does it automatically convert the lists to strings?\n\nI think it does. In Python 3.0, list() now returns a list of the strings in the list, rather than a list of the elements of the list.\n\nno it doesn't automatically convert it.\nhere's the actual code:\nfrom typing import List", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings\nThis is one of the greatest things I have ever seen.\n\nThis is a great way to pass strings to functions without having to worry about them containing commas.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join('\\n')\n\nNice.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return ''.join(strings)\n\nVery interesting article, but I was disappointed by the lack of an actual code example.\nThe Python code example at the top does not seem to be the same concatenation method mentioned in the article, as it relies on the itertools.chain method which does not appear to be a part of the standard library.\n\nPython's standard library is very slow, so you are more likely to see a third party module being used instead of the standard library functions.\n\nThere is nothing slow about the standard library. Where did you get that from?\n\nI guess you have not seen any benchmarks.\n\nI guess you haven't seen the standard library being used. It's all quite fast.\nThe standard library is incredibly well-designed, and you should use it whenever you can.\n\nI guess you haven't seen the standard library being used. It's all quite slow.\n\nI guess you haven't seen the standard library being used. It's all quite fast.\n\nI guess you haven't seen the standard library being used. It's all quite slow.\n\nI guess you haven't seen the standard library being used. It's all quite fast.", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.append(strings.pop(0))\nSeems like a rather trivial example to use in an introduction to python.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concatenate()\nI've got to say, I'm not a big fan of type annotations, but I think they're better than nothing at all.\nThe only problem I have with them is that the resulting function signature is (in this case) confusingly short. For anyone who isn't familiar with Python, you might reasonably wonder if the return type was str or List[str]. For that reason I'm a fan of a little more verbosity, like in the following:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return \"\" + strings.join(\",\")\n\nWhat about `return '' + strings.join('')?`\n\nYou'll get back a string with a separator, not a single string.\n\nDid you read the article?\n\nI did, but I don't get your point.\n\nYou're right. I thought \"a single string\" was an attribute of the list, which it isn't.\n\nTo me, this is a perfectly acceptable use of the list type. It doesn't really matter that the \"value\" is a list.\n\nThis is true, but a tuple would have been much clearer.\n\nThis is also a fair point.\n\nI don't think I've ever seen a more contrived example for something so trivial. Just because it's a list doesn't mean you have to write a function for it.\n\nI agree with you, but I think the author's intent was to point out the usefulness of lambdas.\n\nIf you look at it that way, I suppose. But it's really more of a criticism of the list type than it is of lambdas.\n\nAs others have mentioned, a plain tuple would be more concise", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join(*str)\nIt's also interesting to note that the Python _join_ function does _not_\nconcatenate strings.\njoin takes two lists of strings and a function to apply to the\nelements. It returns a new list where the function is applied to the\nfirst element and the remaining elements are joined.\n>>> list(concatenate(list(1), list(2)))\n<list '1' '2'>\n>>> list(join([1,2]) + [3])\n<list '1' '2' '3'>\n\nIf you are new to Python, it is worth taking a look at Python's Docstrings.\n\npython docs seem to be the only well written docs on the web.\n\nYup. I've been learning python by reading the official docs. There is a lot of good stuff in there, even if you are already pretty familiar with the language.\n\nHere's the version I like a little better:\nfrom typing import List", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return''.join(strings)\n\nI'm not sure why you would need this:\n\"\"\"", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return ''.join(strings)\n\nNice.\nBut I don't see the point.\n\nI'll give you a good point.\n\nI see.\n\nYay, Erlang!\n\nI like how he adds a type signature. I know it's completely unnecessary, but I feel like I can do anything in Python now.\n\nTyping is for sissies.\n\nHa! For the record, I was one of the first to use the Python REPL on the PS3. I love Python. I'm just not a fan of this syntax.\n\nWhy not? This syntax is not that different from what you get when you type:\n>>> concatenate(['a', 'b', 'c']) 'abc'\n\nI agree. I didn't know it was there. I was just trying to be funny. I'll have to remember it for the future.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return ''", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concat(\n       [str(0), str(1), str(2)],\n         [str(3), str(4), str(5)],\n         [str(6), str(7), str(8)],\n         [str(9), str(10), str(11)],\n         [str(12), str(13), str(14)],\n         [str(15), str(16), str(17)],\n         [str(18), str(19), str(20)],\n         [str(21), str(22), str(23)],\n         [str(24), str(25), str(26)],\n         [str(27), str(28), str(29)],\n         [str(30), str(31),", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join(',')\n\nHow about      from typing import List\n          from string import join\nThat's the only way this could be more Pythonic.\n\nI'll grant you that, but I was mainly going for brevity. :)\n\nI know, I just couldn't help myself :)\n\nOh, this is _totally_ off topic, but there's a whole other aspect to code reuse that is rarely considered.\nIt is very common to find that code can be used in more than one place. For example, if you have a utility function that converts a date into a string, you might find that code in multiple places. It may be in a date validation function, a web form, and the template for a string in a web page. Each of these calls to the function should be enclosed in the appropriate if statement. This may be difficult to do if the function is several levels deep in a function call hierarchy.\nTo avoid the need for such code duplication, a macro can be defined that converts the function into a set of instructions to generate the string.\nI've never seen this done, so I'm not sure how to", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return string.join(strings)</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join(\",\")\n\nthis is a very common pattern, and the \"obvious\" solution would be\nto write your own", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return \" \".join(strings)", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concatenate((a,b,c))\n\nNice. I'd suggest replacing it with", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return \" \".join(strings)\n\nWhy the return keyword?\n\nBecause return by itself is the only way to return the value of a function, in Python 2.x at least.\n\nReturn value of a function is returned by the function itself, in Python.\n\nI was not aware of that. So, what happens when a function has no return statement?\n\nIn Python, functions don't have to return anything. If they do, it's assumed the function is idempotent, which is a good thing, since not all functions are.\n\nSome languages don't care about return types, some do. I suppose Python could adopt this too, but that would require a new operator.\n\nIt would require a new keyword too.\nThe only operator that can be used without a keyword is +.\n\nThis is actually the biggest reason why I started using Python. I had some code in C++ that had a lot of empty return statements. They were there because some of the functions weren't idempotent. After the program compiled, I would go back and add the return statements in the body of the function for the functions that I wanted to be idempotent.\nThen", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n\n    return \" \".join(strings)\n\nIsn't it better to just use a list comprehension?\n\nWhat's the difference?\n\nHis way requires more typing, I think.\n\nBut his way can be used for lists of any length, whereas the comprehension is only for lists of one element.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    if strings.size == 0:\n       return \"\".join(strings)\n    return \"\".join(strings[0]) + \"\\n\"\n\nfrom typing import List", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join('')\n\nyep, i've seen much more:\nfrom typing import List", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join('')\n\nYou can also use a list comprehension for the same purpose:\n\n>>> print(concatenate(['a', 'b', 'c'])).format()\n'abc'\n>>> print(concatenate(['a', 'b', 'c', 'd'])).format()\n'abcdef'\n\nHow is this a surprise?\n\nThat was my reaction as well, but I think it's just a case of the OP not knowing enough python to know that you can do that.\n\nYeah, I've only been coding python for 2 months or so now. I've only just recently started to get into list comprehension. I guess I just didn't expect that much from the list operator.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    \"\"\"Return a string, concatenating all of the strings in the list\"\"\"\n    return ''.join(strings)\n\nIn python 3.6, you can just do:\n\"'.join(strings)\"\n\nIn python 3.5, you can do:\n''.join(strings)\n\nSo I guess there are two ways to make an empty list.\n\nThat's the only way I know to make an empty list in python3.5.\n\nThe most annoying part is how there is no built in List class or anything like it. You can't easily iterate over lists without some library. You can't create one without importing the list module, and you have to rely on some other library to access the elements of the list.\n\nI find python's built-in lists to be very powerful and simple to use, with the obvious exception of slicing. If you wanted to slice over a list, you could define a function that does just that. This would remove the need for a built-in slicing function, and be a lot more flexible.\nList comprehensions are a very powerful feature, and I can't think of any way to make them simpler without losing their power", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n\nI think this is better:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concat('')\n\nHow is this better than `list(strings.concat)`?\n\nIt's not, but it's a first step.\n\nHow is a first step better than a first step?\n\nBecause it's an actual step.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    for string in strings:\n        str = string + ''\n    return str\n\nI've seen this \"idiom\" before (and used it myself), but I think it's a bad idea. There are other solutions available that are more idiomatic and less error-prone.\nFirst, Python allows tuples to be assigned to variables, so:\nlist = ['a', 'b', 'c']\nlist += 'd'", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.append(string(0))\nI like Python, but that's a bit disappointing. I wonder if Python 3.0 will have a new string type that supports concatenation.\n\nWhy not just write this as:\nconcat = function(strings) {\nreturn strings.join(\"\")\n}\nAnd be done with it?\n\nTrue, but then you'd have to write the concatenate function yourself, which is a lot less idiomatic, and you'd have to remember to type 'join' instead of 'append' everywhere.\n\nI'm not quite sure what you mean by \"be done with it.\" All you have to do is write \"concat = function(strings) { return strings.join(\"\") }\" in your __init__.py. The following is a full example:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    if strings == []:\n        return ''\n    # if first item is a single string\n    if strings[0]!= \"\":\n        return strings[0] +'' + strings[1:]\n    # if first item is a list\n    if strings[0] == List(str):\n        return'' + strings[1:]\n    else:\n        return'', strings[1:]\nThat's called \"the Zen of Python\", and it's basically the same as the \"Clojure for the Brave and True\" thread. The Zen of Python says not to use built-in types or functions, and that's what the OP did, so the Zen of Python is satisfied.\nThe Zen of Python is more than just \"use built-in types and functions as little as possible\", though. It's a matter of style. This code is far more readable as list(\"a\", \"b\", \"c\") than as concatenate([], [\"a\", \"b\", \"c\"]), even though the latter is", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.append(strings[0]).lower()\n\nI hate this convention in Python, it causes so many problems and makes code so much more error-prone.\nThere's no way to detect a missing return statement, you can't tell the difference between a missing return statement and the end of a block, and your IDE can't tell you what the return value of a function is.\nIt's probably the single most infuriating thing about Python.\n\nThere's no way to detect a missing return statement in any language where you can't use void.\n\nThis is true, but for some reason Python programmers seem to miss the return statement more often than other languages. I don't understand why.\n\nPerhaps they find it easier to just use the return statement than to jump through hoops to deal with exceptions.\n\nAnd in fact, there is no way to do anything else in Python, the syntax is broken.\n\nYou should try the Python 2.4.3 beta (or earlier) and see if you like it. It's a lot easier to read than Python 2.3.\n\nOr use Python 3.0.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings\n\nfrom typing import OrderedDict\n\nfrom typing import Enum", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join(' ')\n\nHere's another way to do it, using comprehensions:\n[str(x) for x in strings if str(x)!= '']\n\nThat's a nice trick.\nI also like this solution to the same problem:\n[str(x) if x not in ('', '')]\n\nI'll go with the latter.\n\nI'll go with the former.\nThe OP's function is more general than the latter. The latter is only\ngood for string lists.\n\nI just read the first few words and came up with a quick fix to this:\nimport string", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    if strings == []:\n        return ''\n    else:\n        return strings\n\nI can't believe no one has mentioned this one:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.reduce(lambda x, y: x+y, 0)\n\nIt's an interesting exercise in how to do concatenation, but let me just say that it is a _terrible_ way to do it. You're just moving the problem from one place to another and increasing the complexity of your code.\nTo concatenate, you only need to know that the identity function is id(x). This gives you an is_identity function that will tell you if a function is id:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join(chr(0))</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return ''.join(strings)\n\nThere is a language that can do that. It's called SQL.\n\nExcept it's not a language.\n\nNo, it is a language.\nIt's _not_ a Turing-complete language, but it's a language.\n\nThat's why I said it's not a language. It's a query language.\n\nI don't understand your logic here. It's a query language, but it's not a language.\n\nIt's not a programming language. It's a query language.\n\nThis is a really minor nitpick, but the article says to import \"List\" instead of \"list.\" I've been doing this for ages, but I'm pretty sure the author is wrong.\n\nYou are wrong. \"import list\" is deprecated and the Python development team encourage people to use the shorter \"import list\".\n\nI thought that using \"import list\" is deprecated. I could have sworn that the latest Python docs I read told me that they recommend to use \"import list\" instead of \"import list\".\n\nI think it's so confusing that I'm going to write a module called \"List\" and use it for everything.", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n\n    return strings.append('')\n\n>>> concatenate(['a', 'b', 'c'], ')\nTraceback (most recent call last):\nFile \"\", line 1, in <module>\nTypeError: unsupported operand type(s) for +:'str' and 'list'\n\nThat's the point.\n\nIf you were to write a real concatenate function in Python, you would use something like\nconcatenate = lambda list: list.join(' ')\n\nIn Ruby it would be\nconcatenate = Array.new\nconcatenate.concat(' ')\n\nor just\nconcatenate = String.join(list)\n\nYou could also use Ruby's Enumerable#concat method.\n\nOr you could use Python's itertools.tee to concatenate lists without having to write a function at all.\n\nYes, but in this case, the function serves as a great example of how to use `strings` to perform concatenation.\n\nTrue, but I'd consider the Array.new version to be the best example of concatenation.\n\nIn", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    for s in strings:\n       return s +'' + strings[s]\n\nThe PEP 8 guideline would be to write this as:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.get(0) + \" \" + strings.get(1) + \" \" + strings.get(2)", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.map(x => x + x)\nYou should use the list comprehension syntax (see the comment at the top of the file). It's much easier to read, and in some cases you can type less.\ne.g.", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    \"\"\"       return ''.join(strings.values())\n\nFrom the top of my head, the most confusing part here is that the function\nnamed \"concatenate\" is actually returning \"'.join\". I don't think this\nshould happen - why not \"concatenate()\" or something like that?\nAnd here's a non-Pythonic example:\n>>> from typing import List\n>>> from typing import *\n>>> def int(x):\n    \"\"\" Return an int.\n    >>> int('hello')\n    3\n    >>> int('world')\n    4\n    \"\"\"\n    \"\"\"       return int(x)\n>>> int('hello world')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: name 'int' is not defined\n\nVery confusing, but a perfect example of the need for this.\n\nOh my, I did not know this could be done with the Python core libraries.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join('')\n\nLOLWUT.\n>>> concatenate()\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: name 'concatenate' is not defined\n\nI believe the OP meant the following:\n>>> concatenate([])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: name 'concatenate' is not defined\n>>> concatenate(['a', 'b', 'c'])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nNameError: name 'concatenate' is not defined\n\nThank you.\n\nReadability is paramount in Python. In this case, you're using the shortest syntax possible, which is more readable than using 'list comprehensions'.\nYou're also avoiding the problem of needing to instantiate the list comprehensions with brackets.\n\nThis is python, not C. You don't need to be afraid of braces.\n\nI'm not afraid of them, it", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concat(strings.index(0, \" \").pop())</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n\n    if strings is None:\n        return \"\".join(strings)\n\n    else:\n        return \"\".join(strings.pop())</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join(',')\n\nfrom typing import List", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n\nPEP 8 is my favorite:\n\"In the real world, there is no way to enforce such a rule. Programmers have to be trusted to always do the right thing.\"\nAnd yet, it's listed as a \"PEP Proposal\".\n\nThat's not quite what PEP means in this context.\n\nReally? I'm new here, so I don't know the context. I thought it was for proposals.\n\nSo, it is a proposal, but it's more like a guideline, something that is strongly recommended but is not enforceable.\n\nThe one that always gets me is using \"elseif\" when you want to do something _only if_ the previous statement fails.\nelseif is for if-else, while elif is for elif.\n\nIt has never occurred to me that \"elseif\" could be taken as a statement on its own.\nWhat I do instead of writing a second \"if\" is to have the first \"if\" clause be a \"def\" statement.\ne.g.:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return ''.join(strings)</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n       return ''\n    else:\n       return strings[0] + strings[1:] + strings[2:] + strings[3:] + strings[4:] + strings[5:]\n\nUgh.\n\nReminds me of some code I saw that used _from time import sleep_.\n\nIn that same vein, some code I saw used _from json import json_.\n\nI like the standard library's implementation of List (from python's standard library):\nfrom typing import List\nList(L):\n\t\t\tdef __init__(self, size=0):\n\t\t\t\tself.__len = size\n\t\t\t\tself.__value = []\n\t\t\t\tself.__next = []\n\t\t\t\tself.__pop = None\n\t\t\t\tself.__tail = []\n\t\t\t\tself.__contents = []\n\t\t\t\tself.__len = len(self.__value)\n\t\t\t\tself.__value = []\n\t\t\t\tself.__next = []", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return ''.join(strings)\n\nThis is a duplicate of  which is not only older but is the HN story for this link.\n\nYeah, I saw that too. The HN submit was made before I submitted to reddit.\nThe HN one is more comprehensive, but the reddit one was posted first, so I went with it.\n\nthe first post is the one that gets the upvotes in this case ;)\n\nThis is the first time I've been sad about not knowing python. :(\n\nThis is how I feel every time I see any of these Python code examples. I can't learn Python until I fix my severe aversion to indentation.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    result = []\n    for string in strings:\n        result.append(string)\n    return result\n\nfrom typing import List", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concat('')\nWhen I first saw this I was like WTF? But then I realized, this is the sort of elegant \"let's make it easy for a beginner to pick this up\" design that I think is so important.\n\n>When I first saw this I was like WTF?\nI can't decide whether you've been living under a rock for the past 15 years or if it's the opposite.\n\nI can't decide if you're being kind and gracious or sarcastic.\nI knew about list comprehensions but I didn't know how to do this particular one off the top of my head.\n\nI'm going with the latter.\n\nIn my experience, most novice programmers don't know how to use comprehensions correctly. I think the author made a good choice.\n\nFair enough, but this is not exactly rocket science.\n\nIts a cool way to do it, but its probably a bit slower than just using the string constructor directly.\n\nI don't see how that would be true. It looks like it uses the same opcode (`str(...)`) as the string constructor.\n\nSince Python is interpreted, there are no opcodes", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings[0] + ':' + strings[1] + strings[2] + ':'+ strings[3]", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join('')</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join(' ')\n\nThis is the code I've seen used in so many different languages.\n\nIf you have a list of strings, in a language with lists, and you don't want to use a list comprehension, this is the shortest way to do it.\n\nThis is by no means the shortest way to do it, but is perhaps the simplest.\nThis is just a small example:\n>>> \"a\" + \"b\" + \"c\"\n'abc'\n>>> \"a\" + [b, c]\n'abc'\n>>> b + \"c\" + \"d\"\n'abcde'\n>>> \"a\" + [b, c, d]\n'abcde'\n>>> \"a\" + [b.replace(\"b\", \"c\") + c.replace(\"c\", \"d\")]\n'abcde'\n>>> \"a\" + [b.replace(\"b\", \"c\") + \"c\" + \"d\" + \"e\" + \"f\" + \"g\"]\n'abcde'\n>>> \"a\" + [b.replace(\"b\", \"c\") + \"c\" + \"d\" + \"", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join(',')\n\nI thought that using a dictionary is more pythonic.\n\nI would use a dictionary, except that the case where there is no string to concatenate is a valid use case.\n\nExcept it's not valid. A list is not an iterable, and therefore this should not return a string.\n\nWhat should it return?\n\nThe last element of the list.\n\nI think that this is Python at its best:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return''.join(strings)\nJust a typo but a great example of how bad Python's string literal notation is. It's probably not too surprising that a beginner programmer would get confused at the difference between concatenation and appending.\n\nI'm pretty new to Python myself, so I'm interested in how this is a bad example.\n'abc' seems clear enough.\n\nIt's confusing to a beginner. They want to write:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.reduce(lambda s, l: l + s)\n\nSigh, it's that or \n\nthe solution you propose may work on some locales and not others.\n\nThat's true, but in this case, I'm sure that 'concatenate' is the correct spelling. It's a common enough word that a spell checker would be useless (and I don't think I'm the first person to create a program that includes the word, either).\n\nYup. I'm assuming that the word is in the standard library dictionaries, and that the spell checker is set up to not be an overly-strict jerk.\n\nI think the point of the article is that this is a bad thing to do.\n\nI think this is an interesting article. I've spent a lot of time trying to write Python code that's clean, readable, and simple to understand. In fact, that's the only thing I really care about when writing code: Making it readable.\nThe basic problem with the approach in the article is that the code has an abstract, non-obvious, underlying complexity. But I believe that the main reason we write code is to solve", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.reduce(lambda s: s.strip() + '.', 0)\n\nI don't understand what the parenthesis are doing.\n\nYou have to put something in the first one, or the second one will be the default:\n(concatenate ('a', 'b', 'c') 'abc')\n\nIn that case, the parenthesis should go around the first argument and not the second.\n\nSorry, you're right. I wrote the comment before I understood the code.\n\nA great example of this is here:\nIt's basically Python's version of Ruby's \"Every which way but loose\", with the added benefit of not being a ridiculously named function.\n\nThis is a variation on the Sieve of Eratosthenes[1], and so is named after it.\n\nI've used Python for a few years, and I've never heard of \"the sieve of Eratosthenes\". I think the function name is reasonable, and it's not a ridiculously long name.\n\nI think the parent comment was referring to this being a function of the same name, as in the actual sieve of Eratosthenes, not", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concat()\n\nAnd I'm pretty sure that \"from typing import List\" is the part that's supposed to be impressive.\n\nThat's just the standard library.\nIt's got nothing on\n\nfrom string import String\n\nor\n\nimport re\n\nfrom \"re\" import parse_error\n\nI'm not sure the last one is better or worse.\n\nOr the best yet:\n\nfrom ctypes import *\n\nfrom math import sin, cos\n\nWell, it does make sense to import math if you want to do something with math...\n\nIndeed. This is more like importing random, though.\n\nfrom random import *\n\nThat makes a lot of sense to me.\n\nIf you want to use the random library, fine, but having to import the whole stdlib just to get a single function seems like it's trying to do too much.\n\nI was under the impression that you need to import the standard library on Python 2.\n\nYou do.\n\nThe author's intent is not to brag about knowing the standard library, but rather to show how easy it is to make a very basic Python program that doesn't import anything", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.get(0).concat(strings.get(1))\nWhile Python3 supports list comprehension, in Python2 you have to use list comprehensions like this.\n\nFrom typing import List", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concat(strings[0])\nI think the author was just trolling...\n\nIt's a joke for sure, but I don't know about trolling. I think it's a legitimate question to ask what's the point of a \"list\" of lists. Is it a \"list\" at all, or is it a tree?\n\nI don't think he's trolling either. This is pretty much the question that I've been pondering lately. What is the difference between the set of lists (whose elements are lists) and a tree? The fact that the set of lists is closed under concatenation?\n\nThe difference is that a set is a collection of _distinct_ elements, whereas a tree is a collection of _related_ elements.\n\nThat's a good definition. For the distinction between \"list\" and \"tree\", I also like the one from the paper:\n\"For example, given the following list of values,\n[1,2,3,4,5]\nwe can use the built-in function append to create a new list,\n[1,2,3,4,5,6]\nwhere the elements of the new list are all", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.append(strings.pop(0))\nCould just as easily have been written:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    for i in strings:\n        # just return the current string, and recurse on the next\n    return strings[i]\nWell, it certainly is _concise_...</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concat(strings)\nThat's a terrible example. Python has a built-in concatenate() function, so the example should be written like this:\nconcatenate([]) # result is empty string\nconcatenate('a', 'b', 'c') # result is 'abc'\nI find that I don't use string concatenation very often, so I have this little function I use for it instead:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join('')\n\nI like the \"from typing import List\" but not the \"def concatenate(strings: List[str]) -> str\".\nTo me, the \"from typing import List\" is a simple, easy to understand example of a module, that's what it is, you can't go wrong with that.\nThe \"def concatenate\" is not.\nMaybe it's because I'm not that experienced with Python, but I would have appreciated more an example that simply works.\nI'm not even sure I get the use of the \"concatenate\" function in the example.\n\nI have never understood the use of from typing import *;\nSure, they give you a quick way to explain the concept of a module, but it's not even close to realistic.\n\nThe best thing about \"from typing import *\" is that it makes a lot of people go \"WTF?\" and then you get to explain what a module is.\n\nI think the best thing about \"from typing import *\" is that it allows people to write a \"Hello World\" program that isn't a function call.\n\nI'd rather have a function that returns", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n\n    return strings.append(strings.pop()).join('')\n\n    \"\"\"\n    def add(x, y):\n    \"\"\" Add 2 numbers\n    >>> add(2, 3)\n    5\n    \"\"\"\n\n    return x + y\n\nI think it's a good example of why python is not a good first language. It has no good way to teach you how to do things the right way.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.append(strings.pop())\n\nI guess I'm just not getting the joke.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concatenate(strings.pop)\n\nAnother good way is to do:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n\n    return strings.get(0).replace(\" \", \"\") + strings.get(1).replace(\" \", \"\") + strings.get(2).replace(\" \", \"\") + strings.get(3)\n\nThis is kind of neat, but it might be worth mentioning that the list is an alias for `str`, and that the implementation is a bit more complicated than the example shows. For example, the output of the following:\n[x for x in [\"abc\", \"def\"] if x.strip().startswith('a')]\nis:\n\"abcdef\"\nThe trick is that the parser is _also_ a function, and it's called whenever you try to access an item from the list. This means that you can do things like:\n[x for x in [x for x in [\"abc\", \"def\"] if x.strip().startswith('a']]\nThis is then parsed as:\n[x for x in [\"a\", \"b\", \"c\"] if x.strip().startswith('a')]\nwhich gets the correct result.\n\nOf course, Python already has an operator for concatenation, using the + operator, so why", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.get(0).join(strings.get(1))", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return''.join(strings)\n\nConcatenate is a function that takes in a list of strings and returns a single string. The __main__.py file has some sample usage:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    for i in strings:\n        yield i\n    return ''.join(i)\n\nConcatenation is really just a fancy name for string formatting.\n\n'+' is an operator, concatenation is a procedure.\n\nTIL</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.append(strings[0])\nThis is interesting, because you could use it as a one-liner.\nfrom typing import List", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings[0].join(strings[1:])\nfrom typing import List", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    for s in strings:\n        yield s + s", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    s = strings.get(0).getvalue()\n    while s:\n        s = strings.get(1).getvalue()\n        s = strings.get(2).getvalue()\n        return s\n\nimport string\n\n    def print_arr(arr: List[str]) -> str:\n    \"\"\" Print a list of strings\n    >>> print_arr([])\n    ''\n    >>> print_arr(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    return '' + \"\n\n\" + arr.join('')", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n\n    s = \"\"\n    for i in strings:\n        s += i\n    return s\n\nMaybe you meant \"from typing import lists\"?\n\nyes, thanks for the pointer</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    # convert strings into lists\n    xs = []\n    for string in strings:\n        xs.append(string)\n    return ''.join(xs)</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    \"\"\"Returns:\n    The concatenation of the strings in the given list.\n    \"\"\"\n    for str in strings:\n       if isinstance(str, List):\n          return str.concat('')\n    return ''.join(str.split())\nI like the explicitness of that.\n\nI think you should always do this. I'm guilty of not doing it enough.\n\nThis is a good example of something that is not immediately obvious if you're not a Python developer.\n\nI wonder how this compares to list.concat.\n\nconcat() will return a list.\n\n\"Simple to understand, easy to write, but hard to read.\"\n\nThe list comprehension really doesn't seem all that hard to read to me.\n\nIt's simple to understand and easy to write because you only have to use a single line for each.\nBut it's hard to read because it's hard to see the structure of the list, what values are being accessed, and how they are being combined.\nIn particular, it's very hard to see the structure", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n       return strings[0]\n    else:\n       return''.join(strings)</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concat()\n\nI've been using this for a while. It's handy.\n\nI've been using it for a few months. It's hard to go back to the old way.\n\nMaybe you should go ahead and release it to PyPI, eh?\n\nOne of my favorite features of Ruby is _constant_ method calls. It's\nnot exactly a feature, but a side-effect of lazy evaluation and\ngenerator-based syntax.\nI wish Python would have it, too.\n\nIt's a bit of a pain to use, since it prevents you from taking advantage of Python's metaprogramming capabilities.\n\nI think it's worth it, as long as you don't need to call a method that takes a function as an argument.\n\nI've been using the following code for a while:\n\nYes, that is handy. I often have to write code that performs a series of transformations on a sequence of objects.", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings\n\nNice try.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    for s in strings:\n        return s +''", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return \"\", strings.join(\",\")</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return''.join(strings)\n\nWhy not use the \"built-in\" one? \n\nList isn't a built-in?</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concat\nConcatenate is a list of strings.\nI know that.  Why?  I can't figure it out.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concat()\nthis is not a particularly great example to demonstrate a point.\n\nThis is not Python's concatenation, it's a function that concatenates. Python's concatenation is list.concat().\n\nIt's the standard idiom for concatenating lists in Python though. There are some caveats with list.concat() (e.g. special cases for lists of tuples and strings) which this version avoids.\n\nNot a good example at all.\nConcatenation in Python is \"list.concat()\" not \"strings.concat()\".\n\nHe probably did that to make the example more readable for people familiar with Python.\n\nI don't think there is anything to learn from this. Python has one built in way of concatenating lists, and another way of concatenating strings. The only thing that makes this example different from what the Python compiler will do is that it's not idiomatic, and doesn't take advantage of the language's features.\n\nYou might learn that `list.concat` doesn't take strings (it only takes lists) and that `strings.concat` does take strings.", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join('')\n\nI'm not sure I get the point of this post.\n\nIn Python 2.4, the built-in string type only accepted single-quoted strings. The post is simply showing how to achieve the same effect in 2.5.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.append(strings.get(0))\nI think the list comprehension \"solution\" is less readable.\n\nI like the list comprehension solution, since it's a general solution to a general problem (simplifying lists), while the \"from typing import List\" solution is specific to strings.\n\nIn fact, the string version is not even a list comprehension. It's just an ordinary list.\n\nNice. You can also do this in Ruby:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.reduce(lambda v: v+' ')\n\nIsn't this pretty much the definition of concatenation?\n\nNot quite. The example given should produce a list of strings. The example given does not.\n\nWhich is the definition of \"concatenation\".\n\nNo, it's not. The fact that it's producing a single string is an implementation detail.\nThis is the definition:\n\nThis is the definition:\n\"concatenate\" (its synonym, \"concatenate\", is in the Python language) is a function that takes two strings and returns a single string.\n>>> concatenate(\"a\", \"b\", \"c\")\n'abc'\n>>> concatenate(\"a\", \"b\", \"c\", \"d\")\n'abcde'\n>>> concatenate(\"a\", \"b\", \"c\", \"d\", \"e\")\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"/home/dave/code/PYTHON/lib/python2.6/python2.6/function.py\", line 106,", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join('')\n\nSyntactic sugar is all very well, but it is sugar. It makes things easier and more consistent to read, but it doesn't actually change the meaning of the program.\nIn the example given, the meaning of the two programs is identical. However, the first one is much easier to write (and read) than the second one.\n\nAh, ok. So it's just the first example that's syntactic sugar? I agree that it's easier to read the first example, but if you were to write that second one as a regular expression, then it's just a regular expression?\nAnd I'm getting the idea that the \"import\" keyword allows you to call on functionality from other modules, even if the code is written in your module?\n\nimport is a sort of namespace or import-statement.\nIt creates an \"executable space\" of functions, variables etc that are imported from other modules. (i.e. functions that are defined in other modules)\nThe keyword itself doesn't create the executable space, but simply links to the files, which are included in the executable.\n\nAh ok, that's pretty cool. So does this change how", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n\n    return string.join(strings)\n\n    \"\"\"\n    >>> concatenate('xyz', 'abc', 'def')\n    'xyzabcdef'\n    \"\"\"\n\n    def string.join(strings: List[str]) -> str:\n    \"\"\" Join multiple strings into a single string\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    >>> string.join(['a', 'b', 'c'])\n    'abc'\n    >>> string.join(['xyz', 'abc', 'def'])\n    'xyzabcdef'\n    \"\"\"\n\n    return string.join(strings.map(str.lower()).split(' '))\n\nI think this is a fantastic example of the power of python.\nIt took me about 5 minutes to convert it from Java to python.\n\nWhat's the value in showing that it can be done? A few minutes to convert it does not imply that Python is superior in any way.\nI would have expected a more", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return \"\".join(strings)</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.append(strings.index(strings.index(s).start) + 1)\n\nfrom typing import *", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join(\",\")\n\"concatenate\" is a magic function. It is a magic function because it appears to do something, but really doesn't.\n\"concatenate\" does not create a single string, it simply returns the first string from the list.\nNow, the function you probably _meant_ to write is:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    for i, s in enumerate(strings):\n       return s +'' + i\n\nThat's not a good way to do it:\n>>> import string\n>>> print string.__import__('ascii')\n'ascii'\n>>> print string.__import__('list')\n'list'\n>>> print string.__import__('sorted')\n'sorted'\n>>> print string.__import__('lxml')\n'lxml'\n>>> print string.__import__('itertools')\n'itertools'\n>>> print string.__import__('math')\n'math'\n>>> print string.__import__('time')\n'time'\n>>> print string.__import__('unicode')\n'unicode'\n>>> print string.__import__('argparse')\n'argparse'\n>>> print string.__import__('os')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nImportError: No module named 'argparse'\nThat is, you need to import it in the same way as the", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    \"\"\"\n    return strings.join(',')", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    \"\"\"\n    return strings.join(',')\n\nWhy is this a defcon talk?\n\nThe first comment on the page states:\nThe talk was intended as a joke, but it was actually rejected by Defcon. It was in my talk at the last Ruby conference, though.\n\nI got that, but it still seemed like a really poor joke.\n\nI thought it was funny.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join(',')\nThe correct answer to this problem is to define `concatenate` as a function.\n\nBy the way, if you're just defining a single function, you can get rid of the import statements too.\n\nThis works, but is a little easier to read, I think:\nimport types", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.get(0) + strings.get(1) + strings.get(2) + strings.get(3) + strings.get(4) + strings.get(5) + strings.get(6) + strings.get(7) + strings.get(8) + strings.get(9) + strings.get(10) + strings.get(11) + strings.get(12) + strings.get(13) + strings.get(14) + strings.get(15) + strings.get(16) + strings.get(17) + strings.get(18) + strings.get(19) + strings.get(20) + strings.get(21) + strings.get(22) + strings.get(23) + strings.get(24) + strings.get(25) + strings.get(26) + strings.get(27) + strings.get(28) + strings.get(29) + strings.get(30) + strings.get(31) + strings.get(32) + strings.get(33) + strings.get(34) + strings.get(35)", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n\n    return \"\"\n\nWhat are the advantages of doing this?\n\nIn a nutshell, if you have a list of strings, and you want to print them, you can just use print. If you want to print a string, you can use print. But if you want to print a list of strings, you have to write a function just for that, like", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    for s in strings:\n        return s+\" \"\n\nWhy is this better than list('a', 'b', 'c')?\n\nIt's more explicit about what it does, which is the reason I would use the list object in the first place.\n\nThere is also the list(str) and tuple(str, str) functions.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    if strings.count() > 1:\n        return \"\".join(strings)\n    return \"\".join(strings[0])</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return \" \".join(strings)", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concat(s)\n\nI've always liked \"from typing import *\"</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n\nHow is this better than using a dictionary?\nfrom typing import Dict", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings\n\nThis is a tiny bit more involved than the basic example, but once you get the hang of it it's a good way to deal with lists. It's a bit more readable than the Python version.\n\nI've never found a use case for List.concatenate(). I use List.zip() all the time though, so you might want to add that one too.\n\nI agree. Even though I can see how List.concatenate() would be useful, I've never had the need for it.\n\nI use List.concatenate() to concatenate string lists that are not the same length, for example if I want to concatenate a string with a dictionary.\n\nI use List.concatenate() all the time when I want to join two lists into a single list (I'm a Java developer).\n\nI think using a list comprehension would be a better way of going about this than the list concatenation.\n\nI think this is really cool. It's something I often end up doing in Python.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    if strings:\n        return strings.pop()\n    return string.concat(strings.pop())\n\nThis is not a good example.\nYou may be able to get away with that in some interpreted languages, but if you're working with a compiled language, you should be doing string interning so that this code is quite a bit more efficient.\nYou'd also typically use a utility method instead of defining a string concatenation function, so that your code is more readable.\n\nEven in interpreted languages it's often better to use utility methods.\n\nI'm not sure I'm following the author's point in this post.\nHe's not saying that using dictionaries or lists is always good, but that the choice of data structure should be made based on the problem domain.\nNowhere does he suggest that you should never use either dictionary or lists.\nAlso, I'm not sure what's so \"dangerous\" about using dictionaries as opposed to lists.\n\nI think the \"dangerous\" part is that using dictionaries is an anti-pattern. This is because the dictionary may not be in-place and may not have any comparable functions to get", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    if strings.count(1) == 0:\n        return ''.join(strings)\n    else:\n        return strings.concat(strings)\nIn python 2.6, strings.concat(strings) returns an iterator. This version is much faster.\n\nOn the other hand, it returns a generator.\n\nno it doesn't. the version on the OP's site does, but the version in the standard library does not.\n\nThis is similar to list comprehensions in Python. This is not really a function as it takes no arguments. But that's not to say it's not useful.\n\nIn Python, this would be more like:\nfrom typing import List", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings[0] +'' + strings[1] +'' + strings[2]\n\nMore generally,", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return ''.join(strings)", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings\n\nThe author doesn't even realize that what he wrote is not idiomatic python. I would have thought that anyone writing a book about python would have tried to learn the language a little first.\n\nI see no problem with that code. What should it be instead?\n\nThe author is using the incorrect type signature for concatenation, as well as the wrong function name.\n\"concatenate\" is the name of the string constructor in Python.\nconcatenate(strings) is a correct type signature, but the function should probably be called \"concat\" instead.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join('')", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.append(strings.pop(0))\n\nI've got to say, that's a really clever solution to that problem. I've thought about how to do that in Python a few times, and I've never come up with that. Nice job!\n\nI'm not sure I understand. Isn't it just Python's iteration?\n\nIt is, but the code is nicely compact and easy to read.\n\nI'm not sure I'm seeing the readability. It's compact and readable, but I don't see how it's particularly _nice_.\n\nIt's just that when I see a list comprehension like that I start to wish I was working in Clojure where the comprehension syntax is cleaner and more powerful.\n\nYou can use list comprehensions in Python too:\n\nThat's a good tip, but it's not as powerful as Lisp's.\n\nHe's right. The python example is still using a list comprehension. The difference is that in python, list comprehensions are treated like functions:\n(list-comprehension-syntax\n\"Y = {0:X, 1:Y, 2:Z}\")\nY = {0: X, 1:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    if len(strings) == 0:\n       return ''\n    for i in strings:\n         if i == 0:\n            return ''\n        else:\n            return i + strings[i]\n\nThis is a terrible example - it's a totally trivial function that could be implemented in about 3 lines of code.\nCompare this to the original post:\n_\" A simple and effective version of the List.concatenate() method.\nI do not believe this is a bad thing. It is simply a convention.\nAnd, if you feel the need to call it, you can.\nBut, I highly recommend the following syntax.\n[x.concatenate(y) for x,y in arr]\"_\nThat's a total of 4 lines of code, and one line is a comment. It's not clear to me why anyone would use the method defined in the post over the builtin.\n\nIt's a good example of why it's a bad idea to mix O", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.reduce(0, (a, b) -> b + a)\n\nThis has some issues. I can't think of a way to solve them without some ad hoc monad transformer machinery though, so I'm not sure it's useful to point them out.\nThe first issue is that a list is not a monad, so List is not a monad transformer. If you change this to:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concat(strings.join(' '))\nYou can't concatenate a list of strings into a single string. You can't do that in any programming language.\n\nIf I understand the intended use of the function, it's to concatenate two list of strings into a single string.\n>>> concatenate(['a', 'b', 'c'], ['d', 'e', 'f'])\n'abcdef'\n\nNot really, since you can't concatenate two strings into a single string.\n\nYes you can. You just need to use a list.\n>>> \"a\".concatenate(\"b\", \"c\")\n'abc'\n\nNo, you can't.\nIt's the difference between joining two strings into a single string, and concatenating two strings into a single string.\n\"a\" + \"b\"!= \"abc\".\nYou can't add strings in Python. There are ways to use lists and tuple unpacking to work around this, but concatenating strings is not one of them.\n\nYou're right, there is a difference. The function is meant to be used with two lists of strings.", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.append(strings.get(0))\nThe beauty of this code is that it's trivial to understand, even if you've never seen Python before.\nIt's also a great demonstration of how Python (and probably Ruby and Smalltalk, too) encourage programming in a declarative style.\n\nI thought that was Perl, but in Perl it would be \"concat(\"a\", \"b\", \"c\")\"\n\nPerl has its own version of the list-comprehension operator, but it's not exactly the same. It's \"my @concat = qw(a b c); my $string = join '', @concat; print $string.\".\nPerl has a number of features that are very similar to Python features, but not exactly the same.\n\nThis is a classic example of the Python culture of code beauty. It's hard to find a piece of Python code that's not well-written.\n\nNot only that, but it's also a classic example of the python culture of clarity. You can take almost any piece of code from any other language, and it will look more complex than the python version.\n\nIt's a bit sad", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings[0]+strings[1]+strings[2]\n\nI like it, but the name is a bit misleading...\n\nYep. This is not 'from typing import List'. It's 'from strings import concatenate'.\n\nI thought about that, but I'm not sure what to call it. I know there are languages where there are distinct types for strings and lists, but it's not the case in Python. So I guess it's more like \"from string import concatenate\".\n\nIt's nice, but Python already has an incredibly simple concatenation method (just a function called \"concatenate\" that takes a list of strings as its argument).\nAlso, the name of the method is somewhat misleading. It is in no way an \"implementation of the List type\". It is just a function.\n\nYou're right, it's not an implementation of the List type. I wasn't trying to be misleading, but in retrospect I can see how you might think that.\n\nConcatenation is one of the reasons I love python. It's so simple:\nstrings.concat(strings.join(\" \", strings))\n\nI wrote a similar thing", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings\nThis isn't a bug in Python. It's just a convention in Python that the List type does not have a concatenation method. And it makes sense that way.\n\nI prefer to write it as \"def concat(s1, s2):\". It's not as short, but it's more explicit.\n\nI don't know about Java, but in other languages List is a subtype of string, so it's perfectly reasonable that the concatenate method is implemented in terms of the string concatenation operator.\n\nThis is not a bug. Python does not have a built-in string class. Lists are merely a subtype of strings. So concatenate would be just a shortcut for `\"\".join(s1, s2)`\n\nI think the author knew that, and was pointing out that it is probably a bad idea to allow a class to be a subtype of two other classes, especially when one of the two classes provides an interface that is incompatible with the other.\n\nList does not have a concatenation method because Python does not have a string class. Python does not have a string class because, at the time it was being developed,", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.reverse().join('')\nI like your style.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concat(strings.index(0))\nThe \"return strings.concat(strings.index(0))\" part is a common idiom in Python: you can concatenate list-like objects using their indexing methods.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join(' ')\n\nIs this more than a joke?\n\nI think this is meant to be a joke on python's \"one-line\" style of code, but I don't know why it's here.\n\nWell, it is a humor site, isn't it?\n\nAh.\n\nI've been using python for a year now and I find myself doing this a lot:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    for s in strings:\n        print s\n    return s", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.get(0).concat(strings.get(1))", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings\n\nfrom typing import List", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join('')\nI'm not sure why everyone is making fun of the original function. It's a great example of a simple, one-line algorithm that can't be understood or easily modified from its source code.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    s = []\n    for i in strings:\n       s.append(string.ascii_lowercase(strings[i]))\n    return s</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concatenate()\nor \nfrom typing import List", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    if len(strings) > 1:\n        print(\"\\n\", strings)\n    else:\n        print(strings)\n        return \"\".join(strings)\n\n>>> concatenate([])\n>>> concatenate(['a', 'b', 'c'])\n'abc'\n\nWho uses that instead of just `[a, b, c]`?\n\nIt's not for concatenating lists, it's for concatenating strings.\n\nThen it's an unnecessarily general name, in that case.\n\nA better name would be StringConcat.\n\nI thought List was the Python equivalent of Java's ArrayList?\n\nIf you want something like Python's list (i.e., a linked list), you should use `list`.\nThe Python standard library has a `list` type. However, this article was mostly about the 'List' module, which defines a special type, a sequence of immutable (unchangeable) values.\n\nFunny, I was going to point out that in fact the Java List class and the Python list are (", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concat\n\n>>> a = List('a')\n>>> b = List('b')\n>>> c = List('c')\n>>> concatenate(a, b, c)\n'abcc'\n\nShouldn't it be \"concatenate([])\" instead of \"concatenate([])\" in the example?\n\nYes, it should. I've changed it.\n\nI find the 'from typing import List' to be really awkward. I don't really want to have to think about where the \"List\" I'm using came from. The names of the functions/classes/whatever should be enough to differentiate.\nI have no idea how this is supposed to be helpful.\n\n`from typing import List`\nThis is so unnecessary.\n\nIt's an alternative to \"from collections import defaultdict\".\n\nI think the better alternative is to use the built-in `dict` type, which is already defined in the standard library.\n\nI think I'm using a defaultdict for a dictionary-like object and a list for a sequence-like object, so this will be more flexible for me.\n\nIf you use a dict for", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concat", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concat(strings.end)\n\nOkay, so it's a simple, obvious and short-hand method for adding elements of a list.\n\nFrom the title, I thought the link would go to an explanation of why lists are superior to arrays.\n\nLists are superior to arrays in the sense that they can be sorted and searched faster, but they are also much slower to traverse.\n\nThe performance overhead of a list over an array depends on the size of the list and the size of the array. The performance overhead of a Python list is usually negligible in the face of the overhead of an object in memory.\n\nThat depends very much on your implementation. For example, in Python 2.x, Python lists are implemented with the `list` type which is a list of `Tuple` objects. If you have a list of just a few elements, the overhead of allocating a tuple and a list can be huge.\n\nHow many lists do you have of just a few elements?\n\nMost of the time, for me, that would be zero. But my point was that I was addressing the performance overhead of lists in general, not the performance overhead of lists of a few elements", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join('')\n\nCode golfers: how can I make this more concise?\n\nHere's a one-liner that I like a lot.", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return''.join(strings)\nThat's a really interesting way to write that. I've never seen the `.join(...)` syntax before. I wonder how common it is.\n\nYou might like the join(..) syntax. It also makes it easier to write functions that read in lists.\n\nFrom experience, having used the.join(...) syntax in Java, I find it is a lot less readable in Python.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    result = ''\n    for s in strings:\n       result += s\n    return result\n\nfrom typing import List", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    if len(strings) > 1:\n        return ''.join(strings)\n\nI don't get it.\n\nIt's a joke: Python's built-in list type doesn't implement list operations such as concatenation or concatenation or insertion of elements (although it _can_ be done using the built-in zip() function). If you're interested in such things, you should use one of the many specialized list types available in Python.\n\nI knew it was a joke. I was just wondering what the joke was.\n\nThis page is what you get when you try to get to \n\nThe joke here is that he used a list comprehension instead of a for loop.\n\nList comprehensions are actually very useful and can be much clearer than a for loop. If you don't like them, don't use them. But they are not a bad feature of python.\n\nI think you've missed the point.\n\nNope. I just don't agree with your point.\n\nThat's odd, because it's not my point.\n\nI wonder if the actual site was even under development? Why would you have a static page in", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join(\",\")\n\nPython can do list concatenation on strings?</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.append('')\n\nUsing dicts for lists is a bad idea.\n\nBad idea or not, it's all you get on Python 2.x: \n\nYou don't get it in Python 2.x. That was my point.\n\nYes, I am aware that the implementation of 'list' is different in Python 2 and 3. I was saying that 'concatenate' was giving the OP a bad idea of how lists work in Python.\n\nI'm not sure what I was thinking. That's a good example of why I shouldn't comment on things before my coffee.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return ''.join(strings)\n\nI don't think this is a good example. It's more concise to use an empty list for concatenation (which is why he explicitly includes it) but it's not any more obvious to the reader.\n\nFor the case where you have a list of strings where one of the strings is empty, which you want to concatenate with a non-empty string, it is more concise to do this:\nstrings += list[:-1]\n(Of course, if you know you always have at least one non-empty string, you can use the trick in the post.)\n\nOf course. But this is not a good example of that.\n\nFrom the article:\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n>>> from typing import List\n\nI think you missed the point of the article, that's not actually a bug and it's done on purpose to demonstrate the issue with type hinting.\n\nThank you. I missed the point of the article.\n\nIt is surprising that you would call a feature of Python a bug.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return''.join(strings)</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    print(strings)\n    for s in strings:\n        print(s)\n    return s\n\nAs long as you don't have to add any whitespace or comments, this seems to work fine.\n\nI hate to be that guy, but if you don't have to add any whitespace or comments, why not just pass a list of lists?\n\nThat would be true if the list of lists was to be iterated over, but the list of strings is to be concatenated to a single string.\n\nThis is a perfectly valid use of the Python language, but a badly named function. 'concatenate' is a useful and valid verb. This Python function is not.\n\nAll true, but the OP is not making a good case for why \"concatenate\" is a badly named function.\n\nOf course not. He says the function is not named well, but gives no reason why.\n\nI guess it's the same argument that if someone asks you for the capital of England, and you respond with \"it's the City of London\", they would probably not be satisfied with your answer.\n\nI", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.get(0).replace(' ','') + strings.get(1).replace(' ','') + strings.get(2).replace(' ','') + strings.get(3) + strings.get(4) + strings.get(5) + strings.get(6) + strings.get(7)\n\nWouldn't you be better off using the more idiomatic `s.join(' ')`?\n\nI think the point was to demonstrate the difference between Python 2 and Python 3.\n\nNo, the point is to illustrate the difference between list, str and bytes in Python 2.\n\nThis is something I've never understood.\nPEP 258, the official docs, and virtually every other source I've seen on Python's string type says that strings are Unicode by default.\nYet Python 2 interprets 'abc' as an ASCII string.\n\nBecause, AFAIK, Python 2 _is_ ASCII by default.\n\nPython 3 has a Unicode default, but it is still possible to use ASCII in Python 2. If you do so, then the string \"abc\" is interpreted as an ASCII string, not a Unicode string.\n\n_Python", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join('')\n\nI tried to understand it, but I'm confused about the use of strings here. Isn't this a List class? Isn't the \"strings\" a list? In this code, shouldn't the list return \"abc\" as well?</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.concat\nI prefer:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return \"\" + strings.join(',')\n\nIn Python, you can type:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.get(0).concatenate(strings.get(1))\nI really don't see what's wrong with that.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return \"\" + strings.append(strings.pop(0))\n\n    # I'm having trouble reading the difference between these two lines of code.\n    # Is the first more succinct?\n    import string\n    print(\"Hello\")\n    print(\"World\")\n    print(\"Hello, world\")\n\nIn python, import strings has the same effect as import string. Also, I prefer", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    if len(strings) == 1:\n       return''.join(strings)\n\nI know it's a joke, but you really shouldn't mix string concatenation with list concatenation.\n\nWhy not?\n\nstring concatenation:\n\"abc\" + \"xyz\"  # same as \"abcxyz\"\nlist concatenation:\n[1, 2, 3] + [4, 5, 6]  # same as [1, 2, 3, 4, 5, 6]\nThe first example uses a string object, and the second example uses a list object.\n\n[1, 2, 3] + [4, 5, 6] # same as [1, 2, 3, 4, 5, 6]\nThat's not true, the first example results in a string. I tested this on Python 2.7.3 and Python 3.2.2.\n\nI'm sure that in Python 3 the result is a list, but in Python 2 the result is a string.\n\nAh, that would explain it. I did a quick search for \"string concatenate in Python 2\" and the top result", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join(',')\n\nfor i in range(0, 1, 10):\n    print(concatenate(range(i), '\n    '))\n\n>>> 0\n>>> 0\n>>> 1\n>>> 1\n>>> 2\n>>> 2\n>>> 3\n>>> 3\n>>> 4\n>>> 4\n>>> 5\n>>> 5\n>>> 6\n>>> 6\n>>> 7\n>>> 7\n>>> 8\n>>> 8\n>>> 9\n>>> 9\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>> 10\n>>>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return \"\" + list(strings)\n\nThis is fine. A list of strings is a sequence. The concatenation operator is commutative.\n\nAgreed. The most common application for this, however, is the following:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    for item in strings:\n        return ''.join(item)\n\nI like it. I'd like to see some other module for it, though.\n\nThe author should post the module to pypi, it's an interesting idea.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return ''.join(strings)\n\nOh, I see, you're mocking the proposed syntax.\n\nYes. I'm not saying that the syntax is good, I'm saying that if we're going to\nhave a syntax, it shouldn't be this one.\n\nIt's a bit sad that we still have to mock the syntax in a language which is\nsupposed to be strongly typed.\n\nThe point of the mock is to _show that it doesn't matter_. The \"strong typing\"\nin Python is only an illusion, of course.\n\nHere's a way to mock the syntax while keeping the \"strong typing\":", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join(' ')\n\nfrom typing import List", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return ''\n\nYou can do this in the shell easily as well:\necho 'a b c' | sort | uniq -c | tr -d '\n\nDon't use `sort` in the shell. Use `uniq -c`. It's faster.\n\nWhy is sort not available in the shell?\n\nBecause it's broken.\n\nOk, so it isn't available, but why is it broken?</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return''.join(strings)\n\nWow, that looks really nice. I have a similar problem to solve, but I was considering using a list comprehension. You should consider submitting this to the Python Devs.</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings\nThe `return` statement is unnecessary.\n\nWhat happens if strings is empty?\n\nUse", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return''.join(strings)\n\nHmm, what if one of the strings is a list?</s>", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return string.join(strings)\n\nThe syntax for type annotation is actually pretty nice:\nfrom typing import List[int]", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return ''.join(strings)\n\nI think you mean \"from typing import List and String\"\n\nAhh, I remember this one.\n\nThe correct answer is:\n\"from typing import List, String\"\n\n\"from typing import list, string\"\n\nOr even better:\nfrom typing import list, string\n\nI remember this one too. Wasn't there a bug in Python 3.3 that caused a lot of py3k code to break?\n\nThere were plenty of changes, but I don't remember any bug that would break code like this.\nThe changes I do remember are the addition of new syntax for lambdas, a new datatype (named tuples), and the replacement of the builtin Python 2 list objects with the list type from the standard library.\n\nI think the parent is talking about this:\n\nLooks like the problem is that it's expecting a List[str], but the assignment is to a List[str, str], which is a different type.\n\nThe real problem is that the author is using a string literal, which doesn't evaluate its expression, but rather returns a string.\n\nThe return type of the code is", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    if strings == []:\n        return ''.join(strings)\n    else:\n        return ''.join(str(a) + str(b) + str(c))\n\nfrom typing import List, string\n\n    def print(type: string):\n    \"\"\" Print the given type.\n    >>> print(List[str])\n    List\n    >>> print(string)\n    string\n    >>> print(string[0])\n   's'\n    \"\"\"\n    return string.__module__.__name__\n\nfrom typing import List\n\n    def print(type: string):\n    \"\"\" Print the given type.\n    >>> print(List[str])\n    List\n    >>> print(string)\n    string\n    >>> print(string[0])\n   's'\n    \"\"\"\n    return print(type) +'->'+ type[0]\n\nfrom typing import", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.map(lambda s: s.join(''))\nI don't think you need to import List in a test that uses a list literal as an argument.\n\nYou could also use string.join instead of join.\n\nimport string\n\nimport string as str\n\nimport sys", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    if strings:\n        return \"\"\n    else:\n        return strings.append(s)\n\nHere's a better one:", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings[0].join(strings[1:])\n\nI'm sorry, but that's a terrible example of \"Python is better than C\". C++ would do the same thing in a much more readable way (not to mention the fact that it would also be faster).\n\nI'm curious as to how you'd write this in C++.\n\nYou would write it like this:\nConcatenate :: [Char] -> String\nConcatenate [] = \"\"\nConcatenate (c : cs) = concat(c, cs)\nWith the benefit of a type system, the compiler would catch errors like\nConcatenate [Char]()\nand\nConcatenate (Char) []\nThis is also much more readable, and definitely faster than your Python code.\n\nThe first error would not be caught by the compiler, but the second one would be.\n\nMy bad, I assumed it would be one of the more advanced compilers that would catch that sort of thing.\n\nMy feeling is that most of these C versus Python examples are not really fair. Python is a great language, but I've always felt that its best strength is that it", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return '' + strings\nI don't know, I can't remember ever needing that.  But it's a nice and compact way of doing it I suppose.\nThe function is also non-explicit, which is bad and hard to read.  If you do want to do that, you should use the `+` operator as it's explicit.       concatenate(['a', 'b', 'c'])", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join(\"\")\n\nThis doesn't handle Unicode.\n\nFixed:\n>>> concatenate(\"abc\")\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError:'str' object is not callable\n\nOops. I guess I forgot the \"u\" in \"strings.join\".", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return''.join(strings)\n\nThat is a nice shorthand for the", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join('')\nThis is a good example of how Python's list comprehensions are useful. The author could have written the function as a single line, but it would be harder to read and understand. The use of list comprehensions is a good balance between readability and efficiency.\n\nOr you could just write it like this:\n>>> concatenate(\"\")\n'\n>>> concatenate(\"a\")\n'abc'\n\nAnd get a list back.\n\nThis is a common misconception.\n>>> concatenate(['a', 'b', 'c'])\n>>> type(concatenate(['a', 'b', 'c']))\n<class 'list'>\n\nIt's true that the output is a list, but I would still say that the concatenation operation was performed.\nYou can't do:\n>>> concatenate('a')\n'\n>>> concatenate('a')\n'\n\nThat's the point. That's what I'm talking about. You can't concatenate an empty list.\n\nIt's a bad example because it's not what most people would think of when they hear the word \"con", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n\nI hate this naming convention. The fact that it's from Python makes it even worse.\n\nSorry, but I don't get what's wrong with the naming convention. Could you explain why you dislike it?\n\nIt's a static method. The \"from typing import\" is redundant.\n\nTo be fair, Python is a language where a method like that would usually be used in a class, so it makes sense.\n\nI'm sure the Python developers are not only embarrassed by the \"from typing import\" part, but also by the fact that the concatenate() method is static.\n\nPython 2.7.2 (default, Jan 16 2010, 22:40:06)\nType \"copyright\", \"credits\" or \"license\" for more information.\n>>> from typing import List\n>>> concatenate([])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: list() object is not callable\n\nThat is a very strange error message.\n\nThe exact wording is \"list() object is not callable\", meaning you need to use the callable() method on the list object.\n\nYeah", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"", "from typing import List\n\n\ndef concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\" \"\"\"\n    return strings.join(\",\")\nI don't like the string concat method of python. It is too easy to forget the trailing comma and screw up the string.\n\nWhat do you like better?\n\npython 2.7"]]