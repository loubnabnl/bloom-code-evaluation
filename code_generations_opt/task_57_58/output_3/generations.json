[["def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    for elem in l:\n       if elem[0] < elem[1]:\n          return True\n    return False\n> monotonic([1,2,4,20])\nTrue\nmonotonic([1,2,4,20])\nmonotonic([1,2,4,20])\nmonotonic([1,2,4,20])\nmonotonic([1,2,4,20])\nmonotonic([1,2,4,20])\nmonotonic([1,2,4,20])\nmonotonic([1,2,4,20])\nmonotonic([1,2,4,20])\nmonotonic([1,2,4,20])\nmonotonic([1,2,4,20])\nmonotonic([1,2,4,20])\nmonotonic([1,2,4,20])\nmonotonic([1,2,4,20])\nmonotonic([1,2,4,20])\nmonotonic([1,2,4,", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nI don't know much about this list library, but the first thing I thought when I saw this was \"why the hell is there a'monotonic' function?\".\nThe second thing I thought was, \"why is 'list' a function?\"\n\nIt's more of a way to write more concise code. It's like having list comprehension in Python.\n\nIt's a way to write more concise code that will not work when you need it to work.\n\nThe underlying Python list type is a sequence. Since the collection is monotonic, it's pretty reasonable to assume that this would work as long as the collection is built from sequences.\n\nIf you are using list comprehensions then you don't have to use list[i]. Just use list[i for i in range(1, 10)], and that works for lists built from any type.\n\nThat is true, but the resulting list is not a monotonic sequence.\n\nA more interesting use of monotonic would be to create a list of numbers which sum up to a given value, i.e. monotonic mean.\n\nIn python you can just do:\n\n>>> mean([1, 2, 3])", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    return(l.reverse().is_sorted()) and l.is_sorted()\n\nWhen I see code like that, I wonder if the author has any experience with the real world.\n\nWhat's wrong with it?\n\nIt is a simple function that does one thing, and does it right.\nI'm pretty sure that that's exactly the opposite of what most real-world code does.\n\nIt's an example of the power of Python's duck typing.\n\nOf course, in the real world, the l.is_sorted() check would be omitted, and the function would be implemented like this:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if not l: isinstance(l, int):\n        raise TypeError('list should be of integer type')\n    return l: is increasing(l):>0 or is decreasing(l):<0\n\nThat's not an implementation of monotonicity, it's an implementation of the equivalence of a boolean expression (whether the elements of a list are monotonically increasing or decreasing) and a list of integers (whether the elements of a list are increasing or decreasing). The implementation doesn't even try to be correct with respect to that equivalence, or in other words, it doesn't even check that the elements of the list are indeed monotonically increasing or decreasing.\nYou might have been confused by the fact that Python's boolean expressions are expressed as lists. For instance the above monotonicity function is actually the same as the following:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def exists(e: element):\n    \"\"\"Return True if element exists in the list.\n    >>> exists([1, 2, 3, 4])\n    True\n    >>> exists([1, 2, 3, -3])\n    False\n    >>> exists([1, -1, 2, 3])\n    False\n    >>> exists([1, -1, -2, 2])\n    False\n    \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if length(l)!= 0:\n        return False\n    for i in range(0, len(l)):\n        if l[i] > l[i-1]:\n           return False\n    return True\n\nYes, but, ewww.\n(This is a terrible solution to the problem.)</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    assert l == [1, 2, 4, 20]\n    assert l[1] > l[2]\n    assert l[1] < l[2]\n    assert l[1] > l[2]\n    assert l[2] > l[3]\n    assert l[2] < l[3]\n    assert l[2] > l[3]\n    assert l[3] > l[4]\n    assert l[3] < l[4]\n    assert l[4] > l[20]\n    assert l[4] < l[20]\n    assert l[20] > l[4]\n    assert l[20] < l[4]\n    return True", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nA simple way to make sure a list is monotonically increasing is by making sure it's non-empty.\nA more general approach would be to use a median filter, which is a common technique used to make sure a stream of values is monotonic.\n\nYou're not using the median filter here, you're just noting that empty lists aren't monotonically increasing.\n\nI think he's just pointing out that empty lists are obviously non-monotonically increasing, and thus not worth implementing a median filter for.\n\nIt's hard to tell with some of the comments on HN...\n\nIt's hard to tell if someone is being helpful or not.\n\nI like it!\nAs it is, I've never thought about what it means for a list to be \"monotonic.\"\nI guess I always just assumed it meant \"doesn't have cycles.\" I am curious, however, to know the difference between \"monotonic\" and \"anti-cyclic.\"\n\nA list of numbers is monotonic if all numbers are increasing and the sequence is nonempty.\n\nIn Python, any sequence can be converted to a list via the tolist function. You can then run mon", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return sum(i for i in l if i[0] > i[1]) > 0\n    and sum(i for i in l if i[1] > i[0]) < 0\n\nreturn monotonic", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nIn python, we can just use the builtin __nonzero__:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nI would have expected `False` for the last one.\n\nI agree. If you have a monotonically increasing sequence, and you add a negative number, you get a monotonically decreasing sequence. In other words, you start at a positive number, and you end up at a negative number. That's not monotonically increasing.\n\nThis is a nice example of how intuitive definitions don't always work for all types. I would have expected it to be true too.\n\nI find it surprising that you would find that surprising. To me, it seems obvious that if you have a monotonically increasing sequence, adding a negative number is equivalent to removing the last element of the sequence, and that's certainly not monotonically increasing.\n\nYes, that's obvious, but not obvious enough for me to write \"I would have expected `False` for the last one.\" as my first response. I need to be explicitly told that that's how monotonic functions work, and even then I can't visualize that in my head.\n\nThis is one of those things that could go either way. The point of the monotonic test is to determine whether a given value is the last element of a list or", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    def monotonicallyIncreasing(l):\n    \"\"\"Return True if l is monotonically increasing.\n    >>> monotonicallyIncreasing([1, 2, 3, 4, 5])\n    True\n    >>> monotonicallyIncreasing([1, 3, 5, 2, 1])\n    False\n    \"\"\"\n\n    def monotonicallyDecreasing(l):\n    \"\"\"Return True if l is monotonically decreasing.\n    >>> monotonicallyDecreasing([1, 2, 3, 4, 5])\n    True\n    >>> monotonicallyDecreasing([1, 2, 3, 5, 4])\n    False\n    \"\"\"\n\n    if l: list() == [] or l: list() == [:] or l: list() == []:\n       return True\n    else:\n       return monotonicallyIncreasing(l)\n\nIt's a bit ugly.\n\nI'm not sure that's really the right way to think about this, though. For", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def monotonically_increasing(l: list):\n       return not (l[0] < l[1] and not l[0] < l[1] and l[0] < l[1])\n       def monotonically_decreasing(l: list):\n       return not (l[0] > l[1] and not l[0] > l[1] and l[0] > l[1])\n    return monotonically_increasing(l)\nI believe it's better to write the function like this:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def monotonic_incrementer(r: int):\n    \"\"\"Returns an object that implements monotonic.\"\"\"\n    return lambda: (y, x) if y > x else x\n\nI didn't know about monotonic, but I was thinking it would be trivial to do:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    def monotonicallyIncreasing(l: list):\n    \"\"\"Return True if list elements are monotonically increasing.\n    >>> monotonicallyIncreasing([1, 2, 4])\n    True\n    >>> monotonicallyIncreasing([1, -3, 2, -2])\n    False\n    \"\"\"\n    return l.pop(0) > l.pop(1)\n    and l.pop(0) < l.pop(2)\n\nYep, that's very close to what I had in mind. I was thinking of some kind of an averaging function which could be used as a criterion for monotonic.\n\nI don't get the point of the \"adding 1\" function. It seems to be just as \"complex\" as what you're trying to replace (and it's not like you can just \"add\" a constant value of 1 to a list, that would return a list of 1's).\n\nIt is an easy way to average numbers. In the example code, it was used to make an average of two numbers.\n\nI see. But you can't add", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nThere's also the following, which can be used to remove duplicates:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nWell, it's not like it's hard to write a decent function in python that returns the same output for a given input...\n\nExcept you can't write it in python.\n\nI realize this is a bit of a subjective topic, but: why not?\n\nFor one, not all python programmers know about generators, which are the way to do a monotonic function.\nAdditionally, they can be slow, because of the GIL and because they are iterating.\n\nThis is why I have a love-hate relationship with Python. On the one hand, it can do pretty much anything, on the other, it's not as fast as it could be.\n\nI'm not sure what the purpose of this article is?\n\nThat's a good question. I don't see the point of this article. I'm sorry if I'm wrong but it seems like an advertisement for something. I'm new to the field so I could be wrong.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if list[0] < list[1]:\n        return False\n    if list[0] > list[2]:\n        return False\n    for i in range(len(list)):\n        if list[i] < list[i + 1]:\n           return False\n           return True\n    return True\n>>> monotonic([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\nTrue\n>>> monotonic([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\nFalse\nI would have expected this to return True since it returns true for the first list and false for the second.\n\nIf you want to use it for an iterable, why don't you just use range?", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    def monotonic(l: list):\n    if l[0] < l[1]:\n       return True\n    if l[0] > l[1]:\n       return True\n    return False\n\n    def monotonically_increasing(l: list):\n    \"\"\"Return True if list is monotonically increasing.\n    >>> monotonically_increasing([1, 2, 3])\n    True\n    >>> monotonically_increasing([1, 0, -1, -2])\n    False\n    >>> monotonically_increasing([1, -1, 0, -2])\n    True\n    >>> monotonically_increasing([1, 0, -1, -2, 3])\n    False\n    >>> monotonically_increasing([1, 0, -1, -2, 3, 4])\n    True\n    >>> monotonically_increasing([1, 0, -1, -2, 3, 4, 5])", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return sorted(l.pop, key=lambdax:x[1])\nWhat if the list isn't sorted?\nWhat if the list is sorted but has a cyclic dependency?\n\nIt will be sorted before passing to sorted()\nYou would get an exception if a cyclic dependency is present\n\nHow did you come to this conclusion?\n\nIt is in the method signature\n\nOh, I read it as sorted(l.pop, k=lambdax:x[1]).", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    return lambda t: t > t[1]\n    and t[0] < t[1]\n    and t[0] < t[2]\n    and t[0] < t[3]\n    and t[0] < t[4]\n    and t[1] < t[2]\n    and t[1] < t[3]\n    and t[1] < t[4]\n    and t[2] < t[3]\n    and t[2] < t[4]\n\nWhat's the point of the first branch?\n\nEqual elements.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nWe can write an improved version of this function by using a list comprehension.", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return list(range(len(l)-1), len(l)-1) in sorted(l)\n\nI'm not an experienced developer but something about this code just feels wrong. I'm pretty sure it's one of the more simple bits of code in the standard library that should be _very_ easy to write, but I can't quite get my head around it.\n\nIt's a good question. It's more a challenge than a code problem.\nThe main thing that is a bit funky is that range(len(l)-1) assumes that l is a list and so it has to do some type checking to return True.\nThere's lots of ways you could do it. You could make a new function called monotonic_of_iterable and then pass in an iterable that contains the list, and then that function would take care of the type checking.\n\nOr you could just not use range.\n\nI'm pretty sure this is the best answer.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def __init__(self):\n        self.first = None\n        self.second = None\n        self.last = None\n    return self\nHey, thanks, I should have come up with something like that myself.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return l.pop() % l.pop() == l.pop()", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def __init__(self, l: list):\n       self.l = l\n    return self.l\nBeautiful.  Why would you return the list though?\nFor the same reason I'd return the object when doing something like this:      from itertools import islice", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nIn python 2 this was not true.\n\nI was under the impression that monotonicity was an equivalence relation, not an identity relation.\n\nYes it is an equivalence relation.\n\nI could have sworn I saw something about `x` being considered equal to itself somewhere, but I can't find it now.\n\nThere is a problem with this implementation: if I change the function to take a list of tuples and run it on a list of [1, 2, (3, 4)] it will return False.\nThe problem is that the definition of monotonicity is\nreturn(l[i] > l[i-1]) or return(l[i] < l[i-1])\nwhich is true for tuples.\nIf it's possible to change the definition so that it takes a list of tuples then it will be fine.\n\nIt is possible:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return l[0] < l[1]", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    monotonic_return = lambda x: x > x\n    monotonic_return_if_true = lambda x: x > x\n    monotonic_return_if_false = lambda x: x > x\n    monotonic(l) = monotonic_return_if_true(l) if l > 0\n    monotonic(l) = monotonic_return_if_true(l) if l < 0\n    monotonic(l) = monotonic_return_if_true(l) if l == 0\n    monotonic(l) = monotonic_return_if_false(l) if l == -1\n    monotonic(l) = monotonic_return_if_false(l) if l == 1\n\nA couple of things I don't understand:\n\\- Why the'return' and'return_if_true' methods on the function itself? They seem redundant and will add a lot of clutter to the function call's signature. Is there some other reason for this?\n\\- Why are the'return", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nCode re-ordering\nThe re-order() method reorders the results of a generator. It takes a generator object and a predicate. The generator is executed and the generator.next() method returns the next value of the generator. Then the predicate is applied to the generator.next() value and the result is added to the current result of the generator.", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    return len(l) == 1 or l[0] > l[1] or l[0] < l[1]\n\n    def monotonic_reverse(l: list):\n    \"\"\"Return True if a list is monotonically increasing reversed.\n    >>> monotonic_reverse([2, 3, 5, 10])\n    True\n    >>> monotonic_reverse([5, 3, 2, 10])\n    False\n    \"\"\"\n\n    return l[0] < l[1] and l[1] > l[0]\n\n    def monotonic_rotate(l: list):\n    \"\"\"Return True if a list is monotonically increasing rotated.\n    >>> monotonic_rotate([2, 3, 5, 10])\n    True\n    >>> monotonic_rotate([3, 2, 5, 10])\n    False\n    \"\"\"\n\n    return len(l) == 1 or l[0] > l[1] or l[0] < l", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return list[-1] < list[0]\n       or list[-1] > list[0]\nThis is still not correct. A better solution is to return a tuple of True/False.\nWhy? Because if you have a list of positive numbers with a negative in the middle, the first 2 tests will be True, but the third will be False. This method returns True for all 3 tests.\nYou're right. My solution works when you assume that the numbers are strictly increasing, but not if you assume they're strictly increasing or decreasing.\n> strictly increasing, but not if you assume they're strictly increasing or decreasing  Both of those require the same assumptions.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return (l[0] > l[1]) and (l[0] < l[1])\nThat's not a definition of monotonic. For example, `monotonic(['a', 'b', 'c'])` would return `False`.\n\nAnd that's how one learns that Python is a dynamically typed language :)\n\nI think that's still statically typed, and the type is defined at runtime. The type could be extended to include any arbitrary list-like construct.\n\nYou're right. I should have said \"statically typed\" instead of \"dynamically typed\".\n\n\"Worse, Python does not support anything even remotely resembling type-level programming, so you can\u2019t even do something simple like saying if type(x) is an instance of T then return True else return False.\"\nDoes this mean that types are more a description of the value and not the variable?\n\nI'm not sure what you're asking. The Python type system is duck-typing; a value can have any type, so there's no type hierarchy. A type is not a description of the value, but of the type.\n\nI'm asking what \"is", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return lambda x: (x[0] - x[1] > 0 or x[0] + x[1] < 10) or (x[0] + x[1] > 0 or x[0] - x[1] < 10)\nI've been doing this a long time, and I don't like it. Why? Because I\nhave to do a type conversion (from integers to strings) in order to use\nit.\nHere's a slightly more sophisticated version of monotonic:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    assert list.count(None) == 0\n    assert list.count([]) == 0\n    assert list.count([1, 2, 3, 4, 5]) == 5\n    l = list()\n    for item in l:\n        if item > l[0]:\n           l[0] = item\n           l[0] = item + 1\n    return l\nI'm not 100% sure why the return statement is necessary. If I understand correctly, it looks to me like the function already returns the list.  Also, it's not clear to me why the list needs to be initialized. Couldn't we just run this function on an empty list?\nThe whole thing isn't necessary; the base case should be sufficient.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    #return True if all elements in list are monotonically increasing or decreasing\n    def monotonically(l: list):\n    \"\"\"Return True if all elements in list are monotonically increasing or decreasing.\n    >>> monotonically([1, 2, 4, 20])\n    True\n    >>> monotonically([1, 20, 4, 10])\n    True\n    >>> monotonically([4, 1, 0, -10])\n    True\n    \"\"\"\n    return l.is_monotone()\nThat's the same function.\n\nA simpler version is also possible:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def monotonically(l):\n    \"\"\"Return True if l is monotonically increasing or decreasing.\n    >>> monotonically([1, 2, 4, 20])\n    True\n    >>> monotonically([1, 20, 4, 10])\n    False\n    >>> monotonically([4, 1, 0, -10])\n    True\n    \"\"\"\n    return l < 2 || l > 20\n\n(contributed by Francis Damoulakis)", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    if any(not all(list(l.pop(), l.pop())) for l in l):\n        return False\n    return l.pop() == l.pop()\n\nYay! Yet another \"Pythonic\" broken function that's worse than the original.\n\nI don't understand. I thought that was the point of Pythonic functions - to be more readable and clear.\n\nIt's still pretty readable, and more understandable than it's C-style equivalent.\n\nI'm not sure if you're being sarcastic, but I agree that it's more readable. I was commenting on the fact that it's not actually monotonic.\n\nOh, right. I misunderstood your comment.", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nMonotonic, a nice name for a function that tells you if the sequence is monotonic or not.\n\nThis, however, is a monotonic sequence:\n[1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3]\nIt is monotonically decreasing.\n\nThis one is not:\n[2, 4, 6, 10, 8, 10, 6, 8, 4, 10, 2, 4, 6]\nIt's monotonically increasing, but the function says False.\n\nThe reason is that the monotonicity of the sequence can't be deduced from the list.\nIn the first case it's obvious that the sequence is decreasing, but not in the second case.\n\nSo, the definition of monotonic is just wrong.\n\nUsing the \"mono\" word is confusing, because it's used in the context of monotone, as in \"monotone curve\".\n\nUsing \"monotonic\" in the context of list is not the same as using it in the context of function.\n\nThere's already a function called monotonic, that return True if a sequence is monotonic", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def is_monotonic(l: list):\n    \"\"\"Return True if l is monotonic.\n    >>> is_monotonic([1, 2, 4, 20])\n    True\n    >>> is_monotonic([1, 20, 4, 10])\n    False\n    >>> is_monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    return (((l.head() > l.tail()) and l.tail() < l.head()) or (l.tail() > l.head() and l.tail() < l.head()))\n\nTry:</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return list(isinstance(l[0],int) for l in l) == l\n> monotonic([1, 2, 4, 20])\nTrue\n> monotonic([1, 20, 4, 10])\nFalse\n> monotonic([4, 1, 0, -10])\nTrue\n\nSorry, I should have also said that I'm using Python 2.7.\nThe thing that confuses me is that the second line should return True since\nthe first element is not 1 but 4. It doesn't because the first element is an\narray. I thought the line\nlist(isinstance(l[0],int) for l in l) == l\nwas supposed to check the first element of the list and ignore the rest.\n\n>>> monotonic([1, 2, 4, 20])\nTrue\n>>> monotonic([1, 20, 4, 10])\nFalse\n>>> monotonic([4, 1, 0, -10])\nTrue\n\nOkay, so the issue is that I'm not taking into account the second element in\nthe list. Is there a way to do that?</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    def __init__(self):\n        self.l = []\n        self.last = self.l[0]\n        self.last += 1\n\n    return self.l < self.last\n\nI think the above is a little bit more intuitive.\n\nI thought that it was some kind of implementation of monotonic clocks. The.last member is the current time. It also has a little bit of a regular expression flavor to it.\n\nI was expecting it to return True if the list was in ascending order, False otherwise.\n\nI was expecting it to return True if the list was in descending order, False otherwise.\n\nI was expecting it to return True if the list was in ascending order, False otherwise.\n\nThis is extremely similar to a list monad, except it doesn't transform its values, and the list functions are defined in terms of the monadic construct.\n\nThat's because it is one.\n\nI was expecting it to return True if the list was in ascending order, False otherwise.\n\nIt's basically a list monad that doesn't do", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return (l.index(0) > l.index(1)) and (l.index(1) < l.index(2)) and l.index(2) < l.index(3) and l.index(3) < l.index(4) and l.index(4) < l.index(5) and l.index(5) < l.index(6) and l.index(6) < l.index(7) and l.index(7) < l.index(8) and l.index(8) < l.index(9) and l.index(9) < l.index(10)\n\nAs a matter of fact, it's even more useful, because it can handle infinite lists!\n\nA few years ago I found myself in a situation where I needed to count the numbers of consecutive even or odd numbers in a file (I was writing a hexadecimal editor for the Atari ST). I had to do it in a way that would be fast enough for a low end 8 bit machine.\nI wrote a program to do it:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def get_first(l: list):\n    \"\"\"Return the first element of the list (if monotonically increasing, the first non-negative one).\n    >>> l = [1, 2, 4, 20]\n    >>> first = monotonic(l)\n    >>> first\n    20\n    >>> first = monotonic(l[0])\n    >>> first\n    1\n    >>> first = monotonic(l[0, 0])\n    >>> first\n    2\n    >>> first = monotonic(l[0, 0, 0])\n    >>> first\n    4\n    \"\"\"\n    return l[0]\n    if l[0] == -1:\n       return -1\n    else:\n       return l[0]\n\nThis is my preferred solution, as well.\n\nThe main problem with monotonic is that it doesn't actually take into account the value in the list, just the order", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return sorted(l.__contains__(l[0]), key=lambdax:x[1])\nWhich of the monotonic() implementations is faster? I have a vague idea that the OP's implementation is, but I can't really justify why.\n\nI can't imagine the OP's would be faster. It has to maintain a sorted list at runtime, which, if you're doing the sort properly, is not O(n).\n\nYou're right. I wrote a pretty naive implementation of monotonic. I've added a patch that you can use to disable the sorted() call, and benchmark it against the OP's version.\n\nI don't know how to run your patched version.\n\nIn python 2.7 and 3.2 you can do it like this:\n$ python -c \"from monotonic import monotonic; print(monotonic( range(1000000) ) )\"\nin python 3.3 you need to add a version statement:\n$ python -c \"from monotonic import monotonic; print(monotonic( range(1000000) ), version='3.3' )\"\n\nYou can also", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    if n < len(l):\n       return False\n    for i in range(1, l.end - n):\n       if l[i] > l[i - 1]:\n          return False\n    return True\n\nWhen you have to resort to using this sort of thing to debug your own code, you've pretty much lost.\n\nI don't know about that. When you're a student, the chances are high that you'll run into a bug that is so obscure, or that you've spent so much time on, that you'll do anything to get it to work.\nI've had times when the only way I was able to figure out how to debug my own code was to just find the one little detail that would make it fail.\n\nI'll give you that, but a lot of these kinds of things can be avoided by just taking a break. If you're tearing your hair out over a problem for more than a few minutes, just walk away from it and come back later.\n\nAbsolutely. I'm still not sure how I managed to solve some of these things", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    # Identity for first element\n\n    # If second element is equal to first\n\n    def identity(l: list):\n    if l == [1]:\n       return True\n    elif l == [0]:\n       return True\n    else:\n       return False\n    # If first element is equal to second\n\n    def equal(l: list):\n    return l == list(1)\n    # If both first and second element are equal\n\n    def equal_equal(l: list):\n    if l == [0]:\n       return True\n    elif l == [1]:\n       return True\n    else:\n       return False\n    # If first and third element are equal\n\n    def equal_equal_equal(l: list):\n    if l == [0]:\n       return True\n    elif l == [1", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def monotonicallyIncreasing(l: list):\n    \"\"\"Return True if l elements are monotonically increasing.\n    >>> monotonicallyIncreasing([1, 2, 3])\n    True\n    >>> monotonicallyIncreasing([1, -1, -2, -3])\n    False\n    >>> monotonicallyIncreasing([1, -1, -2, -3, 4, 5, -6, -7, -8])\n    False\n    \"\"\"\n    def monotonicallyDecreasing(l: list):\n    \"\"\"Return True if l elements are monotonically decreasing.\n    >>> monotonicallyDecreasing([1, 2, 3])\n    True\n    >>> monotonicallyDecreasing([1, -1, -2, -3])\n    False\n    >>> monotonicallyDecreasing([1, -1, -2, -3, 4, 5, -6, -7, -8])\n    True\n    \"\"\"\n    return (", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def is_increasing(l):\n    \"\"\"Return True if l is monotonically increasing.\n    >>> is_increasing([1, 2, 4, 20])\n    True\n    >>> is_increasing([1, -2, 3, 4])\n    False\n    >>> is_increasing([4, -5, 0, 10])\n    False\n    >>> is_increasing([0, 4, 2, -8])\n    True\n    >>> is_increasing([10, -6, -2, 4])\n    False\n    >>> is_increasing([1, 20, 4, 10])\n    False\n    >>> is_increasing([4, 1, 0, -10])\n    True\n    >>> is_increasing([0, 4, 2, -8])\n    True\n    >>> is_increasing([10, -6, -2, 4])\n    True\n    >>> is_increasing([1, 20, 4, 10])\n    True", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if l == list(0):\n       return False\n    if len(l) > 0:\n       return True\n\nIt should return False for lists that don't have a monotonically increasing/decreasing element, as the third example above shows.\n\n>>> monotonic([1, 2, 4, 20]) False\n>>> monotonic([1, 20, 4, 10]) True\n>>> monotonic([4, 1, 0, -10]) True\n\nWhat's the difference between monotonically increasing/decreasing and strictly increasing/decreasing?\n\nThe strict versions only use \"loops\" that work with both directions. If you have a strictly increasing/decreasing list that works in one direction but not the other (e.g. you have a[i] < a[i+1]), then it will be False.\n\nThis is how I would write it:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def __mul__(self, other):\n    if other == self:\n       raise ValueError(\"mul(self, self)\")\n    return (self * other)\n    def __add__(self, other):\n    if other == self:\n       raise ValueError(\"add(self, self)\")\n    return (self + other)\n    def __radd__(self, other):\n    if other == self:\n       raise ValueError(\"radd(self, self)\")\n    return (self + other)\n    def __mul__(other):\n    if other == self:\n       raise ValueError(\"mul(self, self)\")\n    return (other * self)\n    def __add__(other):\n    if other == self:\n       raise ValueError(\"add(self, self)\")\n    return (other + self)", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nI don't see a monotonic() method.  That's what I get if I use:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return (l[0] < l[1] && l[0] > l[2])\nWhy do you use < and > instead of <= and >=? I think the latter are more common and less prone to errors.\nAlso, why not use an else-clause so that if the list is not monotonically increasing or decreasing, it returns False?</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return zip(l, [-1 for a in xrange(len(l) - 1)])\n\nThis is not the most efficient implementation, it is not even in the top N.\n\nThat's a really weird way to do monotonicity.\n\nIndeed. If we assume the input list has length n, we can do the same thing in O(n) time.", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    # forward recursion with base case\n    if n == 0:\n       return False\n    # append the first element to the list\n    n = len(l) + 1\n    if n > 0:\n       return True\n    elif n == 1:\n       return False\n    elif n == 2:\n       return False\n    return False\n    def mappend(l: list, x: list):\n    \"\"\"Return a new list containing the elements of `l` followed by the elements of `x`.\n    >>> mappend([1, 2, 3], [1, 2, 3])\n    [1, 2, 3, 1, 2, 3]\n    >>> mappend([1, 2, 3], [1, 3, 5])\n    [1, 2, 3, 1, 3, 5]\n    >>> mappend([1, 2, 3], [1, 3, 5, -1, 2", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def is_monotonic_increasing(l):\n    \"\"\"Return True if list elements are monotonically increasing.\n    >>> is_monotonic_increasing([1, 2, 3])\n    True\n    >>> is_monotonic_increasing([5, 6, 7, 8])\n    True\n    >>> is_monotonic_increasing([10, 20, 30, 40])\n    True\n    >>> is_monotonic_increasing([-10, -20, -30])\n    False\n    \"\"\"\n    return True\n    def is_monotonic_decreasing(l):\n    \"\"\"Return True if list elements are monotonically decreasing.\n    >>> is_monotonic_decreasing([1, 2, 3])\n    True\n    >>> is_monotonic_decreasing([5, 6, 7, 8])\n    True\n    >>> is_monotonic_decreasing([10, 20, 30, 40])", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    # monotonic is monotonically increasing\n    if abs(l[-1]) < abs(l[-2]) or abs(l[-1]) > abs(l[-2]) or abs(l[-1]) == abs(l[-2]):\n        raise TypeError( \"monotonic\" )\n    return True", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def __call__(self, s):\n       if s in []:\n         return True\n       return sum(i for i in s if i > 0 else -i) < 0\n       if __name__ == '__main__':\n         monotonic([1, 2, 3, 4])\n\nI like that it's a self-contained unit, and it doesn't rely on a huge infrastructure of special operators and constructs.\n\nSince the result isn't immediately obvious, I put a \"Did you know?\" section at the bottom of the page.\n\nThe code isn't very readable for me. I don't know what I'm supposed to be doing.\n\nPython code:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if len(l) == 0:\n       return False\n    return list(l.pop(0), l.pop(1), l.pop(2)) == list(l.pop(0), l.pop(1), l.pop(2))\n\nThis is the canonical example of a function that does not have a single definition.  You can't give a single definition of this function, because what is monotonically increasing or decreasing depends on the context.  The context may be \"all lists\", or \"all lists with empty element at the end\" or \"all lists of length less than 100\", or \"all lists of length less than 5\", or \"all lists that are not themselves lists\".  You can make up as many new lists as you like and call this function on them.  If you make up a new list with an empty last element, the result will be False, but if you make up a new list with an empty last element, the result will be True.\n\nMore generally, I would say that a function has more than one definition if you can apply it to the same value and get different results.  For example, if the", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nIf the list is in ascending order it will return true, otherwise false.\nI'm not sure I see the point of this, it's just an easy example.\n\nI think the point is that it's a very simple, almost trivial, example that demonstrates that a small change to the input of a function can have a large change in the output.\n\nI like your explanation. You can also say that for a monotonic sequence, there's no possible value for the nth element that could be smaller than the previous one.\n\nI got about halfway through the first problem when I realised that it was the same one as I'd seen on HN a few months ago.\n(I didn't actually finish it, because the class I was in was about to start.)\nIt was fairly fun, although I didn't really think it was great for a first introduction to python. Most of the problems were fairly easy, with the exception of the binary search, which I never really understood. I'm not sure I actually got it, even after reading the solution.\nI really liked the fact that the problems were not only short, but also simple enough that I could easily follow what was going on. I also liked the fact", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    \"\"\"\n    def __init__(self, l):\n        self.__l = l\n        self.__count = 0\n\n    \"\"\"\n    def __repr__(self):\n        return '{}'.format(self.__l)\n        return '{}'.format(self.__count)\n    \"\"\"\n\nNote that this uses the lambda syntax to pass the list to the monotonic method. If we define this method as an inline function, we can just return True, instead of having to return the monotonic result.", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return sum(l[0] for i in range(1, len(l)) if l[i] > l[i+1])\n\nI've had to do monotonic searches in production code. It was a bad day.\n\nWhile I'm not a huge fan of the monad/functor/applicative style of programming, these are actually quite useful.\nI've used functors to great effect to implement a functional sort (in fact, I've seen it implemented in Haskell using applicative functors, which I think is a nice application of the abstraction).\n\nCan you explain why monads, functors and applicatives are useful? I see them used in functional languages, but I've never really understood why.\n\nI've tried using monads before, but they seemed to be a bit of a leaky abstraction. Often, you want to simply transform data, and you need to provide a way to store that data, but there is no way to do that using a monad.\n\nYes, it's an abstract framework. Monads, applicatives, functors, etc. are not a library but a pattern for structuring programs.\nThe good thing is that", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    def __and__(l1, l2: list):\n    \"\"\"Return True if the two lists are the same.\n    >>> [1, 2, 3]\n    >>> [1, 2, 3]\n    >>> [1, 2, 3, 4, 5]\n    >>> [1, 2, 3, 4, 5]\n    >>> [1, 2, 3, 4, 5]\n    >>> [1, 2, 3, 4, 5]\n    True\n    >>> [1, 2, 3, 4, 5]\n    >>> [1, 2, 3]\n    False\n    \"\"\"\n\n    def __lt__(a, b: list):\n    \"\"\"Return True if a is less than b.\n    >>> [1, 2, 3]\n    >>> [1, 2, 3, 4, 5]\n    >>> [1, 2, 3, 4, 5]\n    >>> [1, 2, 3, 4, 5]", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    def monotonic_reverse(l: list):\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\n    >>> monotonic_reverse([4, 1, 0, -10])\n    True\n    >>> monotonic_reverse([1, 4, 0, -10])\n    False\n    >>> monotonic_reverse([4, 0, 1, -10])\n    True\n    \"\"\"\n\n    return l.count() < 2\n\n(For anyone else who is having trouble understanding what this code does, the author is effectively inverting the elements of the list by reversing the list's order. Monotonic reversal will always return True because a monotonically decreasing list will eventually be empty.)\n\nThis is precisely the problem with the commonly used \"True is the empty list\" trick, at least if you want to explain it to someone else.\n\nWhat's wrong with \"True is the empty list\"? It's a fundamental fact of programming that the empty list is a list and so it makes sense to use that to represent True.\n\nI think the point is", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    return len(l) == 0\n    or len(l) == 1\n    or not len(l) % 2 == 0\n    or len(l) % 3 == 0\n    or len(l) % 5 == 0\n    or len(l) % 10 == 0\n\nThanks! I'll take a look at this when I get back to work.\n\nIt's a good suggestion, but I've got the same concern as you.\n\nI guess it can be solved with some smart programming though. For example,", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return True if len(l) > 0 or len(l) < 0\nI think this only works for lists with one element.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def is_increasing(x: int, _: bool):\n        if x < 0: return False\n        return x > 0\n    def is_decreasing(x: int, _: bool):\n        if x > 0: return False\n        return x < 0\n    def monotonic(l: list):\n        is_decreasing(l[0], False)\n        is_increasing(l[-1], False)\n        if not is_decreasing(l[-1]):\n           return is_increasing(l[-2], False)\n          return is_decreasing(l[-2], False)\n    return False", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    def monotonic_not(l: list):\n    \"\"\"Return False if elements of list are not monotonic.\n    >>> monotonic_not([1, 2, 4, 20])\n    True\n    >>> monotonic_not([1, 20, 4, 10])\n    False\n    >>> monotonic_not([4, 1, 0, -10])\n    True\n    \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nHow does that work?\n\nMonotonic is an intuitive concept.\nIt's defined for lists, because lists have the properties of being\nmonotonic.\nIf you're interested, you can try implementing a similar algorithm for\nany other type.\nIn general, you'll want to use a simple top-down algorithm that\ncalculates the index of the first element to which the new element\nis less than, and then returns True or False depending on whether\nthis index is greater than or less than the length of the list.\n\nWhat is an \"intuitive concept\"?\n\nPeople can think about monotonic sequences without explicitly thinking\nabout what monotonic means in the abstract. In other words, monotonic\ndoesn't need to be defined in terms of other mathematical concepts.\n\nWhy isn't there a method for comparing two lists monotonically?\n\nThere are two reasons:\n1\\. There are usually other ways to do it. For example, instead of\nmonotonic you can use a list comprehension, like this:\nl1 < l2 if l1[0] < l2[0] and l1[1] < l2[1] and...", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nAnother way to implement this would be by checking the difference between each element, and seeing if it's bigger than the previous one:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    def lte(l: list):\n    \"\"\"Return True if list elements are strictly less than their previous elements.\n    >>> lte([1, 2, 3, 20])\n    True\n    >>> lte([1, -3, -1, 20])\n    False\n    >>> lte([2, -1, 0, 20])\n    True\n    >>> lte([3, -2, 0, -20])\n    False\n    \"\"\"\n\n    def lgt(l: list):\n    \"\"\"Return True if list elements are strictly greater than their previous elements.\n    >>> lgt([1, 2, 3, 20])\n    True\n    >>> lgt([1, -3, -1, 20])\n    False\n    >>> lgt([2, -1, 0, 20])\n    True\n    >>> lgt([3, -2, 0, -20])\n    False\n    \"\"\"\n\n    def pte(", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return l == list(1) or l == list(2) or l == list(4) or l == list(20) or l == list(10)\nOr use the list comprehension:       monotonic([1,2,4,20])          True</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nI'm a bit confused about the last example. The list is not monotonically decreasing, so why is the result True?\n\nI'm not 100% sure about this (and I can't test it at the moment), but it looks like it is checking for monotonicity in the wrong direction.\nFrom the documentation:\n\"False if list is not monotonic\"\nWhen I interpret that as \"if monotonic(list) is False, then list is not monotonic\" then it checks for monotonicity in the correct direction (incrementing from the end of the list towards the beginning), but doesn't check the other direction (decrementing from the beginning of the list towards the end).\n\nOh, you are correct. I was reading it as \"if list is monotonically increasing, then monotonic(list) is True, otherwise False\".\n\nSo simple and so elegant!\n\nI think this is a good example of when there isn't a need to over- complicate things.\n\nI prefer this version with an optional argument to enable/disable the reverse mode:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if len(l) < 1:\n        return False\n    if len(l) == 1:\n        return True\n    for i in range(1, len(l)):\n        if a[i-1] > a[i]:\n            return False\n            return True\n\nThis is a great example of a function that doesn't take advantage of what python has to offer. If you want to really learn about python, then look into list comprehensions, for loops, and generators.\n\nNice job. It's important to look at the examples in the Python documentation and try to understand how they work. You're doing great, keep it up!\n\nThanks for the encouragement!\n\nThis is really good! Your understanding of functional programming is very good for someone who has only been learning for a few days.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def _monotonic_m(l: list, _is_elem_last: bool, _is_elem_first: bool):\n    \"\"\"Return True if l is monotonic.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    return l == l[0]\n    and l[1] < l[-1] and l[1] > l[0]\n    and l[1] < l[-1] and l[1] > l[0]\n    and l[1] < l[-1] and l[1] > l[0]\n\nWow, that's... interesting. At least the author didn't forget to test the edge cases.\n\nI see a lot of code that is \"clever\" and gets into trouble in edge cases. I think it's", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return True if sorted(l.sort(), reverse=True)\n    or sorted(l.sort(), reverse=False)\nThanks for the tip, I've updated the gist.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return list(lambda x: x - l[1])\n\nExplanation\nThe monotonic function takes a list and returns a boolean indicating whether the elements of the list are monotonically increasing or decreasing.  The monotonic function returns true if the elements of the list are monotonically increasing and false if the elements of the list are monotonically decreasing.\n\nThe monotonic function is a pure function, since the output depends only on the input.  The function never modifies the argument list.\n\nMonotonic functions can be useful in many situations.  For example, a list that is monotonically increasing may be sorted in ascending order.  If the elements of the list are monotonically decreasing, the list can be sorted in descending order.  The sorting algorithms may be executed in O(n), since the elements of the list may be repeatedly compared.  Other sorting algorithms, such as quicksort, may perform poorly on monotonically decreasing lists, since the elements must be repeatedly compared.\n\nA list of integers may be monotonically decreasing, and the number of elements in the list may always decrease.  A list of integers may be monotonically increasing,", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return False\n    for x in l:\n        if l[x] > l[x + 1]:\n           return False\n    return True\n\nI love the xkcd comic where the guy writes an algorithm to compute the sum of the numbers in the list that took linear time and he was surprised it didn't work. The algorithm was just for(n in list) { n + 1 }\n\nI've always been bothered by the \"possible bug in Python\" section in his \"Searching for an off-by-one error\" article. He points out that the index of the first element in a list is (index, 0), but this is only true if the first element is in fact a list.\n\nThere are a few cases where he gets it wrong. For instance, he says:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    def monotonic_l(l):\n    \"\"\"Return True if the list elements are monotonically increasing or decreasing.\n    >>> monotonic_l([1, 2, 4])\n    True\n    >>> monotonic_l([1, 2, -1])\n    False\n    \"\"\"\n\n    def monotonic_r(l):\n    \"\"\"Return True if the list elements are monotonically increasing or decreasing.\n    >>> monotonic_r([1, 2, -1])\n    True\n    >>> monotonic_r([4, 1, 0, -10])\n    True\n    \"\"\"\n\n    return monotonic_l() and monotonic_r()\n\nNotes: This is an algorithm which is very simple and yet very efficient.\n\nThe first line can be written as", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    return l == l[0]\n\nI thought this was about programming.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nThis doesn't give you what you want at all.\nmonotonic(x,y) will return true for any pair of lists which have x and y in them.\nThis may be the behavior you want, but it's not what you said.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def list_is_monotonic(x: list):\n    \"\"\"Return True if list is monotonic.\n    >>> list_is_monotonic([1, 2, 4, 20])\n    True\n    >>> list_is_monotonic([1, 20, 4, 10])\n    False\n    \"\"\"\n    return (\n    x is not None and x.first!= None and x.first > 0 and x.first <\n    x.second\n    and x.second > 0 and x.second < x.first\n    and x.first < x.second\n    and x.first == x.second\n    and x.second == x.first\n    and x.second == x.second\n    )\n    or (\n    x is not None and x.first!= None and x.first < x.second\n    and x.second > 0 and x.second < x.first\n    and x.first > x.second", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    def is_monotonic(l: list):\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\n    >>> is_monotonic([1, 2, 4, 20])\n    True\n    >>> is_monotonic([1, 20, 4, 10])\n    False\n    >>> is_monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n\n    return len(l) < len(l[-1] + l[-2])\n\nI think this is a little easier to read.\n\nBuddy, you're off by one.\n\nSorry, that was a typo.\n\nOkay, but what do you think of the new code?\n\nSure, but I would rather have the monotonicity test at the beginning of the function, so I can call it like this:\nmonotonic_test(x)\n\nD'oh!\nI'm not sure what happened there. My brain stopped functioning.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    return not len(l) == 0\n> def monotonic(l: list):\n> \"\"\"Return True is list elements are monotonically increasing or decreasing.\n> >>> monotonic([1, 2, 4, 20])\n> True\n> >>> monotonic([1, 20, 4, 10])\n> False\n> >>> monotonic([4, 1, 0, -10])\n> True\n> \"\"\"\n> return not len(l) == 0\nThis fails the \"cannot be reduced to a single line\" criterion.\n\nIn the spirit of the competition, I'll try:\nreturn not len(l) == 0\n\nI can't imagine how you could possibly _reduce_ that to a single line.\n\nOne line of python:\nreturn len(l)!= 0\n\nWell, I don't think that you can get any more concise than that.\n\nBut you can't reduce it to a single line.\n\nYou can use it as a one-line argument to eval or a similar facility.\n\nIt would be interesting to see if someone could create an algorithm that could convert this into a concise one-liner.", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nIn Python 2, we just need a class called monotonic (with just the method), and import it using from __future__ import monotonic.\n\nI don't know if that's what the question is asking, but it's what I would do.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\nI think this should be documented that it doesn't work on negative indices.\n\nAlso it seems to require a list that's already sorted.\n\nGood point. I hadn't thought about that. I'll make an addendum to the documentation.\n\nI wrote this a while back to help with a problem I was having. I often need to find the last key in a list (for example, when iterating through a list of maps). Unfortunately, most lists don't have a last key. This function makes sure that it does.\nfrom collections import OrderedDict", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if l.__class__ is monotonic:\n       return l.__class__(l) is monotonic\n\nHooray!\n\nWell that's pretty much how the original Python code works, except that it doesn't test for __class__.\n\nJust in case you don't understand the monotonic joke:\n\ni get the joke, i was just pointing out that python already has a built-in solution.\n\nJava 8: 4x faster than Java 7\n[1]\n\nYep, I was wondering why that number wasn't in the title.\n\nAlso, note that this is on a Linux machine, with the JVM using the Linux a.out executable format.\nJava 7 on the same machine has \"only\" twice the speed as Java 8.\n\nI wish they would have mentioned what they did to get 4x faster. I can't imagine the changes they made were that big.\n\nI wouldn't be surprised if a good chunk of it is due to the new JIT compiler.\n\nYep, the JIT is quite a lot of work.\n\nThe JIT is probably the biggest part of the work", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def __init__(self, list: list):\n    \"\"\"Initialise monotonic to monotonically scan list.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 2, 4, 20, 10])\n    True\n    >>> monotonic([1, 20, 4, 10, -1])\n    True\n    >>> monotonic([4, 1, 0, -10, -2])\n    False\n    \"\"\"\n    self.start = list.index(0)\n    self.end = list.index(len(list))\n    self.step = 1\n\n    def step(self):\n    \"\"\"Return the next element of list, and change step value.\n    >>> monotonic([1, 2, 4, 20, 10])\n    True\n    >>> monotonic([1, 2, 4, 20, 10, 2])\n    True\n    >>> monot", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    def __getitem__(self, i: int, j: int):\n        \"\"\"Return the value of the nth element of the list\"\"\"\n        if self.get(i) == j:\n           return self[i]\n        else:\n           return self[j]", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nThis is quite nice.\n\nI tried it out and got \"NameError: name'monotonic' is not defined\" on python 2.7.3. I tried \"from __future__ import print_function\" and that doesn't seem to help.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    def monotonic_with_delta(a, b, delta):\n    \"\"\"Return True if a < b and a < b + delta.\"\"\"\n    return (\n        (a - b) < (a - b + delta)\n        or (a - b + delta) > (a - b)\n        and a < b\n    )", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def __call__(self, m: int, c: int, op: int):\n        return self.__class__(m, c, op)\n\nHere's a version I've written for my own use:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    \"\"\"\n    def is_increasing(l: list):\n    \"\"\"Return True if list elements are increasing.\n    >>> is_increasing([1, 2, 4, 5])\n    True\n    >>> is_increasing([1, 2, 4, 5, 8])\n    False\n    \"\"\"\n\n    \"\"\"\n    def is_decreasing(l: list):\n    \"\"\"Return True if list elements are decreasing.\n    >>> is_decreasing([1, 2, 4, 5])\n    True\n    >>> is_decreasing([1, 2, 4, 5, 8])\n    False\n    \"\"\"\n\nHere's a bigger example:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nThanks for the tip - I added it to my ReadMe.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    # for now, we assume the list is sorted.  we'll change this if we\n    # detect that it isn't.\n    if sorted(l):\n        return sorted(l[::-1], key=lambdax:x[0])\n    # otherwise, assume the elements are in order\n    return sorted(l[::-1])", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    for l in list:\n        for i, x in enumerate(l):\n           if x < i and x > -i:\n               return True\n    return False\nCan't you just do:      return 1 <= x < list[-1]?\nI think you can do it without the enumerate...  But maybe I am reading this wrong.\n\nThe enumerate is just to give an example of how it would work.\n\nI made a little change to my original post. I believe your answer is the same though.\n\nNo, my answer doesn't work. The problem is that the for loop might visit all the items in the list and return before any of them are less than the current item in the list.\n\nCan you explain more?\n\nThis is the question from the link:\nI think you have to somehow make it monotonic so that it returns True if and only if the list is monotonic.\n\nI think you are misunderstanding what monotonicity means. It just means that", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return all(range(len(l)) for l in l) == l", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if not l: list:\n        return False\n    for l in l:\n\n        if l[i-1] > l[i]:\n            return False\n        elif l[i-1] < l[i]:\n            return True\n        return True\n\nA quick question: what's the performance cost of your solution compared to the standard python algorithm?\n\nI haven't tested it, but I don't imagine it would be too bad. It basically calls a function (which is essentially what the Python implementation does), and then in that function it does a lot of arithmetic, but the arithmetic is just 1 + 1, etc.\n\nQuick, simple and effective, I love it!\n\nPython is not the only language that supports lists.\n\nI love Python and all, but the thing about Python programmers is that you can always spot them in any thread.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def monotonicallyIncreasing(l: list):\n    \"\"\"Return True if all elements are increasing.\n    >>> monotonicallyIncreasing([1, 2, 4])\n    True\n    >>> monotonicallyIncreasing([5, -10, -3])\n    False\n    >>> monotonicallyIncreasing([-10, -3, -5])\n    True\n    >>> monotonicallyIncreasing([-10, -3, -5, 1])\n    False\n    \"\"\"\n    def monotonicallyDecreasing(l: list):\n    \"\"\"Return True if all elements are decreasing.\n    >>> monotonicallyDecreasing([1, 2, 4])\n    True\n    >>> monotonicallyDecreasing([5, -10, -3])\n    False\n    >>> monotonicallyDecreasing([-10, -3, -5])\n    True\n    >>> monotonicallyDecreasing([-10, -3, -5, 1])", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if l is None:\n        raise Exception(\"Need to provide a list.\")\n    return l.size < 0", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return (l.next() + l.prev() >= l.length())::Boolean\nThis implementation can produce spurious results when lists are mutable and you modify an element at the beginning or end of a list.\n\nTrue. But since it is a list comprehension it is not used directly anyway.\nThe only way I could see it being used in a way that might cause a problem would be if the monotonicity check was done in a loop, but then you would have to worry about other things (such as the end of the list) anyway.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return len(l) > 0\n\nThe usual monotonic function compares the first elements of the list,\nand returns True if it's monotonic. I think this is what you want.", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return l in [0, 1]\nI am not really sure if this is the fastest solution, but I think it is.\n\nIt's not, since it's O(n^2) in the worst case. In the best case, it's O(n),\nand there are several O(n) solutions that are faster.\n\nOops. I was thinking of the wrong problem.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nThe English version of the docstring is not very clear. For example, I am still not sure if it is supposed to return True or False for this:\n>>> monotonic([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])\n\nThe actual implementation returns True. It returns False only when the list is empty.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nExample: \n\n>>> monotonic([1, 2, 3, 4, 5, 6, 7])\nTrue\n>>> monotonic([1, 2, 3, 4, 5, 7, 8])\nFalse\n>>> monotonic([1, 2, 3, 4, 7])\nFalse\n\nIt's worth noting that the standard Python functions are all _total_, which means that this function is always the same as \"any\" for your purposes.\n\nI have to admit I don't fully understand the point of this, but it seems like it's solving a problem that doesn't exist.\nThe only thing I can think of is that this is a kind of special case of \"any\", except that it works for infinite lists. For that, you could use a generator.\n\nPython already has a list comprehension with a \"any\" clause that works for infinite lists.\n\nExcept that this monotonic function is much more readable than comprehension with \"any\".\n\nIt's not a comprehension.\n\nThis seems to be an implementation of the fold operation.\n\nYup. AFAIK, it's the only fold operation that can be written without using generators.\n\nI", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nNow I'm not really a Python person, but wouldn't something like this be a better solution?", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return (a - b) <= 0 or (a > b) and a <= b", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if l.is_empty:\n       return True\n    else:\n       return False\n    return monotonic\n\n(Note that there is no reason to test whether the list is empty before returning True.  If the list is empty, you do not need to test its elements to determine whether they are monotonic.)\n\nThe following example shows how to use this function:\n\n>>> list1 = [1, 2, 3, 4]\n>>> list2 = [1, 2, 2, 3]\n>>> monotonic(list1)\nTrue\n>>> monotonic(list2)\nFalse\n>>>\n\nPython also has a monotonic_increment function, which can be used to implement a monotonic sequence.  However, if you are interested in other monotonic sequences, such as the Fibonacci sequence, a simple recursive function is not enough.  For example, a Fibonacci sequence is defined recursively by:\n\n    def fib(n):\n        return fib(n-1) + fib(n-2)", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def monotonically_increasing(l):\n       return l.pop() == l[0]\n    def monotonically_decreasing(l):\n       return l.pop() < l[0]\n\nI think you could probably rephrase this as a separate question:\n\"How can I turn this into a single test (in python) which will run faster than my original test?\"\n\nYeah, the current problem is with how to express the problem in a way that PyUnit can solve. If there is a way to express the test case in a way that can be solved efficiently, then I think the answer is \"no, I can't turn this into a single test\".\n\nI agree that this is a question about unit testing, and not just about testing.\nThere are a couple of things that you could do, but the right answer depends on your specific use case:\n1\\. If this is a one-off test, it could be better to write it in the style of the original test, and just run it multiple times.\n2\\. If you're using a framework that allows mocking (and you want to use", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def is_monotonic(x):\n    \"\"\"Return True if x is monotonically increasing or decreasing.\n    >>> is_monotonic([1, 4, 9, 16])\n    True\n    >>> is_monotonic([-2, 1, 9, 7])\n    False\n    \"\"\"\n\nThis is an example of a problem that doesn't have a good answer. There are many approaches that have different trade-offs, and it's a matter of picking one that works for your use case.\n\nThe definition of monotonic in the article doesn't make much sense to me.", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    def monotonic(elements):\n    \"\"\"Monotonic for element in the list.\n    >>> monotonic(elem)\n    True\n    >>> monotonic([3])\n    True\n    \"\"\"\n\n_fsm._monotonic = monotonic", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    return (l.__getitem__()[0] > l.__getitem__()[1] or l.__getitem__()[0] < l.__getitem__()[1])\n\nAwesome, but I'd have preferred to use the more familiar l.__getitem__(0) and l.__getitem__(1), rather than l.__getitem__(0) and l.__getitem__(1).\nIt is soooo much easier to remember that way.\n\nI agree. I was also going to mention this, but I thought that people will think I'm being pedantic.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    monotonic = lambda: (a[0] > a[1]) and (a[0] < a[1])\n    monotonic()\n\nYou're missing a space in the first line.\n\noops thanks.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def hasIncreasingSum(s: int, e: int):\n    \"\"\"Return True if the sum of all elements in the list is monotonically increasing.\n    >>> hasIncreasingSum([1, 2, 3, 5, 7, 9, 11])\n    True\n    >>> hasIncreasingSum([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    False\n    >>> hasIncreasingSum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    False\n    \"\"\"\n    def hasDecreasingSum(s: int, e: int):\n    \"\"\"Return True if the sum of all elements in the list is monotonically decreasing.\n    >>> hasDecreasingSum([1, 2, 3, 5, 7, 9, 11])\n    True\n    >>> hasDecreasingSum([1, 20, 4, 10])\n    False\n    >>> hasDecreasingSum([4, 1, 0, -10])", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return len(l) > 0 and list[0] < list[1]\nThis is the only one that took me longer than a second to understand.\nWhy not just return False if the list is empty?\nI would say False.\nAnd how does this handle lists with different start index?\nHmm. If you want to use monotonic as a shortcut for \"has a first element\", you're probably right. If you want to use monotonic as a shortcut for \"has an element with a positive distance from the last element\" then what I wrote should work.\nI think \"has a first element\" is a much more common use case.\nIt seems like a stretch to think you'd be comparing a list of length 0 to anything else. But yeah, it's an edge case that should probably be handled.\nThe `monotonic` function is a common use case for `list[0]` for sure, but not the only one. You might also be trying to compare a list to itself (in which case `list[0]`!= `list[0]`).\nYeah, that's why I said it should probably be handled.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def monotonic_impl(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic_impl([1, 2, 4, 20])\n    True\n    >>> monotonic_impl([1, 20, 4, 10])\n    False\n    >>> monotonic_impl([4, 1, 0, -10])\n    True\n    \"\"\"\n    def is_monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> is_monotonic([1, 2, 4, 20])\n    True\n    >>> is_monotonic([1, 20, 4, 10])\n    False\n    >>> is_monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    return ((l.index(0) == 0) and (l.index(1) > l.index(0)))\n\nNice!", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    def not_monotonic(l: list):\n    \"\"\"Return True if list elements are not monotonically increasing or decreasing.\n    >>> not_monotonic([1, 2, 4, 20])\n    True\n    >>> not_monotonic([1, 20, 4, 10])\n    False\n    >>> not_monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n\n    return not monotonic(l)\n\nMaybe it's a problem with my understanding of monotonic, but it looks like you should be able to modify the first function to do this as well?\n\nMaybe the same, but the second is shorter and clearer.\n\nPython does this for you:\n\nOops. The above is incorrect; you can't use 'not' on boolean expressions.\n\nI think it's a shame that Python's default behavior is to ignore 'not' on boolean expressions.\n\n'not' is a logical operator, not a boolean operator. If you want a boolean operator that behaves like 'not' then I suggest using '", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nIs it me or is it incredibly annoying that so many (most?) of the python snippets in the docs use __future__?</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def __getitem__(self, index):\n        return self[index] == list(self)\n    def __len__(self):\n        return len(self)\n    def __reduce__(self, p: list):\n        self.append(p[0])\n        return p\n\nthat's about as far as I got before I found it's a more complicated problem than I thought...\n\nIn Python, this is a solved problem:\n\nBut it's a solved problem in a different way in Java. For example, this works in Java:\n\nI like the way python solves this problem, but if you really want to compare these two solutions, I don't think it's fair to simply use the difference in the number of lines of code as the basis for the comparison.\n\nI actually don't like the python solution at all. It is a clever hack that almost works but then it does not handle the case where the range is empty.\n\nThe Java solution requires that the input be a string. The Python solution can be", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def monotonically_increasing(l: list):\n    \"\"\"Return True if list elements are monotonically increasing.\n    >>> monotonically_increasing([1, 2, 3])\n    True\n    >>> monotonically_increasing([1, 2, 3, 4])\n    False\n    >>> monotonically_increasing([4, 3, 2, 1])\n    True\n    \"\"\"\n    def monotonically_decreasing(l: list):\n    \"\"\"Return True if list elements are monotonically decreasing.\n    >>> monotonically_decreasing([1, 2, 3, 4])\n    True\n    >>> monotonically_decreasing([4, 3, 2, 1])\n    True\n    \"\"\"\n    return l == [x]", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if item in l:\n        return item\n    return False\nthis is python, we have no tail recursion.\n\nI think you can use a generator or a generator expression for a tail recursive solution:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    def monotonically(l: list):\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\n    >>> monotonically([1, 2, 4, 20])\n    True\n    >>> monotonically([1, 20, 4, 10])\n    False\n    \"\"\"\n\n    def monotonically_increasing(l: list):\n    \"\"\"Return True if list elements are monotonically increasing.\n    >>> monotonically_increasing([1, 2, 4, 20])\n    True\n    >>> monotonically_increasing([1, 20, 4, 10])\n    False\n    \"\"\"\n    def monotonically_decreasing(l: list):\n    \"\"\"Return True if list elements are monotonically decreasing.\n    >>> monotonically_decreasing([1, 2, 4, 20])\n    True\n    >>> monotonically_decreasing([1, 20, 4, 10])\n    False\n    \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return len(l) < 0 or len(l) > 1\nThis is a bad function. It does not return the value of the first element in the list.  Its return value is affected by the *rest* of the list.\n\nI know that it is a bad function. It was written in few minutes. But I don't know better algorithm. I wrote the best algorithm that I know. Can you show me better one?</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    def monotonically(l: list, p: int):\n       if l[0] < p:\n          raise TypeError(\"l[0] must be greater than or equal to p\")\n       else:\n          return l[1] <= p\n\nDoesn't Python have an \"empty\" type?</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return is_sorted(l.sort(), key=lambda x: x[0])::bool\n\nI'm not quite sure what you mean by monotonically increasing and decreasing, but here's my version:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return (l[0] < l[1] and l[0] > l[2] and l[0] < l[3] and l[0] > l[4])\n\nThis is a good example. How could a language optimize the above function to remove the <, >, < and > comparisons?\n\nIt's a good question and I don't have a good answer. What I can say is that in Python, you can get the same result by replacing list(l) with l.pop(0), l.pop(1), etc.\n\nDoes it have to be in Python? That is, do you know of any language with a similar optimization?\n\nI believe Haskell has optimizations like this as well.\n\nYes. This isn't the only case where you can use it. You can see a few more examples here: \n\nWhat is the point of this? No one in their right mind would write a monotonic function like this in the first place.\n\nSometimes it's helpful to see the pure functional side of things.\n\nThe list monotonic function is a great example of how recursion can be used to solve a problem that would", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nAlso, I don't think you need the final semicolon after return True.\n\nAlso, I don't think you need the first if-statement.\n\nIt's there for clarity. Without it, it would look like he was returning True for every single element of the list, which isn't the case.\n\nI don't understand why this is on the front page of HN.\n\nFor a beginner, this code sample is a great place to start.\nIt's a common task that one might need to do, but it's not hard to overthink and over-engineer. In particular, the \"merge\" version of the code looks complicated at first, but it's really quite simple.\n\nThis is a nice trick. I'll have to use it next time I need to make a list monotonic.\n\nWas this posted to HN because it was a good post or because it was about a woman? I'm not accusing anyone of anything, but I'm honestly confused.\n\nNeither. It's interesting because it's an interesting way of doing something that many programmers would have written a far more complicated function to do.\n\nI know, I was just being sarcastic.", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    def monotonically(x, l):\n    \"\"\"Return True if x is monotonic with respect to l.\n    >>> monotonically(1, l=[1, 2, 3])\n    True\n    >>> monotonically([1, 2, 3], l=[4, 1, 0])\n    False\n    >>> monotonically([4, 1, 0], l=[-10, 10, -10])\n    True\n    \"\"\"\n    return monotonic(l, x)\n\nI don't know why people would downvote this, but heres an explanation.\nYou are using two functions that are essentially the same.\nmonotonic is a function that takes a list of numbers and returns true if the list is monotonic. monotonically is a function that takes a single number and returns true if it is monotonic with respect to a list of numbers.\nNow, the problem is that monotonically is a function that takes a list of numbers and returns true if the list is monotonic. You are asking it to take a single number and return true", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return (l[0] > l[1] for l in list)\nThis is one of the worst implementations of monotonicity I have ever seen, for a multitude of reasons.\n\nSeems to work to me? What's your preferred solution?\n\nIt works, yes, but it's awful, as the poster you responded to pointed out.\n\nIt's pretty bad. Maybe this?", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nf(0)\n\nf(0, 2)\n\nf(0, 2, 1)\n\nf(0, 1, 2)\n\nf(0, 2, 1, 1)\n\nf(1, 0)\n\nf(1, 0, 1)\n\nf(1, 0, 1, 2)\n\nf(1, 1)\n\nf(1, 1, 1)\n\nf(1, 2, 1)\n\nf(1, 2, 1, 1)\n\nf(1, 3, 1)\n\nf(1, 3, 1, 2)\n\nf(1, 3, 1, 1, 1)\n\nf(1, 3, 1, 1, 2)\n\nf(1, 3, 1, 2, 1)\n\nf(2, 0)\n\nf(2, 0, 1)\n\nf(2, 0, 1, 2)\n\nf(2, 1)\n\nf(2, 1, 1)\n\nf(2, 1, 1, 2)\n\nf(2, 2)\n\nf(2, 2,", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return False\n    l2 = append(l, 1)\n    if sum(l2) == 0:\n        return False\n    else:\n        return True\n\nI don't know if there are any cases where this would actually be useful, but here it is.\n\nI'm sure this is useful, but I am completely baffled as to how.\n\nHere's one way to use it. I thought of it as an alternative to the slow- but-sure method of summing a list.", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return (l[i] >= l[i-1] and l[i-1] <= l[i])\nThis function appears to work as expected in Python 2.6.2.  But it may not be the most efficient.  Python's default sort order is lexicographic so you don't need the i-1 and i loops.  If you do want to use the list monotonicity though, there are ways to get it to be more efficient.  Here's one way:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def is_monotonically_increasing(x):\n       \"\"\"Return True if x is monotonically increasing.\n    >>> is_monotonically_increasing([4, 1, 0, -10])\n    True\n    >>> is_monotonically_increasing([4, -4, 4, -1])\n    False\n    >>> is_monotonically_increasing([1, 1, 2, 1])\n    False\n    >>> is_monotonically_increasing([2, -2, 3, 2])\n    True\n    \"\"\"\n    return x.subs(0, x.index(1)) > x.index(0)\n    def is_monotonically_decreasing(x):\n       \"\"\"Return True if x is monotonically decreasing.\n    >>> is_monotonically_decreasing([4, 1, 0, -10])\n    True\n    >>> is_monotonically_decreasing([4, -4, 4", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nThis is only true for lazy lists, but it's not that clear what \"lazy\" means in Python.\n\nmonotonic is also True for non-lazy lists:\n>>> monotonic([]).isTrue()\nTrue\n\nThe isTrue() function is defined in the standard library. Is is very convenient, and I have used it for many years. But it is not a general purpose function, because it only works for lists.\n\nI don't understand.\n\nWell, the point of the article was that if you want to compare two sets, you should use the == operator, not the === operator.\n\nIt's a bit of a mouthful, but I think the title \"monotonicity\" would have been a bit more succinct.\n\nOne of the things that trips me up with lists in Python is that Python always returns the same thing in the same order from a list, no matter what order you assign the elements.\nAnother is the fact that when you define a class, you must use the'self' keyword to get access to the instances variables.\n\nIn the first case, you're dealing with a lazy list.\nIn the second, you're dealing with a", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return False\n    if n(l[0]) < n(l[1]):\n        return False\n    if n(l[0]) < n(l[-1]):\n        return False\n    return True", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nThis would be a great addition to the standard library, but I'm not sure it should be in the standard library. If this is going to be added, I would like to see an optional `monotonic_<list type>` method on `itertools.izip`.\nI think it would be a bad idea to put this in the standard library.\nWhile it is a very useful method, it's not clear what its proper scope should be.\nShould it be a method on `itertools.izip`? Or maybe `itertools.zip`?\nShould it be a method on `itertools.chain`?\nShould it be a method on `itertools.zip`?\nThere are a number of arguments for putting it in `itertools.chain`\n* It's already there for `chain.zip`\n* It makes sense to put it there because it's used in conjunction with\n`chain` and `chain.zip`\n* There are a lot of places where people are using `chain.zip` when they\nshould be using `chain.zip_many` instead, so adding this method to `chain`\nwould be helpful for people", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\nreturn l == [i + (i-1) for i in range(0, len(l) + 1)]\n\nI'm not sure why you would ever do that when there's list.sort() and.reverse().</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return len(l) > 0 and not len(l) < 1 and not (l[0] < l[1] or l[0] > l[1] or l[1] < l[2] or l[1] > l[2] or l[2] < l[3] or l[2] > l[3])\n\nThis is a surprisingly difficult one to get right. I've seen Python implementations that fail the monotonicity test for a list with 0's and 1's in it. This version is quite clear.\n\nI've been bitten by this a few times. I like this version.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nI don't understand the point of this test. I would have expected the test for monotonic to be equivalent to the test for membership in the list, and it is:\n>>> monotonic([1, 2, 4, 20])\nTrue\n>>> monotonic([1, 20, 4, 10])\nFalse\n\nI'm not sure what you would expect monotonic to do. You can't use it to ensure that a list is monotonic. You can use it to ensure that every element in a list is monotonic, but that's not what the test does.\n\nThat's a fair point.\nI guess it's possible that the point of the test is to demonstrate that the monotonic function has the wrong name, but the correct behaviour.\n\nI think it's more likely that the author was trying to demonstrate that you can't easily write a general version of monotonic (at least not in Python).\n\nI think the point is that there is no point in testing the monotonicity of a list, because it is a property of every single element in it, and you can test it for each element, and if they are all monotonic, the list is", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return list.any((x,i) for i, x in enumerate(list))\nHow about            return list.any((i, x) for i, x in enumerate(list))  I can't see the utility of not having to pass in an extra argument, especially as the list is being enumerated anyway.\nI think the fact that it's not a function is the utility. You can use it as a helper to add all the elements of a list to another list, but retain the order.\nI don't understand what you mean by \"but retain the order\".\nIf you did      list.enumerate(lambda x: x + 1)  and then       list.any((x, i) for i, x in enumerate(list))  you would get back a list of all the elements of the original list, but with the original order retained.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if len(l) > 1:\n       return list(l[0] < l[1], l[0] > l[2])\n    return False\nI prefer a simple version, where it always returns True if the list is not empty: \n\nI prefer this version:", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nWhy didn't you use the built-in `list.any_monotonic`?\n\nBecause I don't know about it :)\n\nIt's a rather nice feature of Python. If you are not aware of it, you should use it.\nHere's the gist of it. In your case, for example:\n>>> list.any_monotonic([1, 2, 4, 20])\nTrue\n>>> list.any_monotonic([1, 20, 4, 10])\nFalse\n\nWhy is it a nice feature?\n\nBecause it's a built-in function that does exactly what you want.\n\nSo is the one I wrote.\n\nIt's not a feature of your program. It's a feature of the Python language.\n\nI have no idea what it's for or what it's good for, so I used my own function.\n\nIt's a way to test whether or not a list is monotonic, and it works for any list. That's all you need to know.\n\nI don't need to know anything else. If I did, I'd have asked for it.\n\nIf you don't want people to offer suggestions,", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        raise TypeError('list must be non-empty')\n    return l[0] < l[1] and l[0] < l[2]\n\nI think this may not be the best example. I think this example is better:\nmonotonic([1, 2, 3, 4])\nThis will evaluate to False.\n\nI think it's missing the point of the article, which is that monotonic() should return True for lists of integers that are monotonic (i.e. contain only positive numbers).\n\nThere's also the function is_monotonic() for lists which is far more useful.\n\nThis is really more for a math/science class than it is a programming class.\n\nI learned this in a programming class.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if abs(l[i]) > abs(l[i-1]) and abs(l[i-1]) > 0:\n        return True\n    return False\nI think this is what I was looking for.  Thanks!    I think this should be a built-in.\nIn Python 3 it's a built-in.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\nreturn all(l).is_increasing()  or all(l).is_decreasing()\n\nA better way to do it would be to use a set.\n\nI don't understand why it would be better. This is Python, it supports sets.\n\nBecause sets are monotonic by definition, and the code is then shorter.\n\nIndeed, but it is still missing the point. This is a case of \"a set is\nbetter than a list because a set is better than a list\".\n\nIf you understand it that way, you are clearly missing the point.\nA better way to do it would be to use a set.\n\nI don't understand why it would be better. This is Python, it supports sets.\n\nBecause sets are monotonic by definition, and the code is then shorter.\n\nIndeed, but it is still missing the point. This is a case of \"a set is better than a list because a set is better than a list\".\n\nIf you understand it that way, you are clearly missing the point.\n\nI don't understand why it would be better. This is Python, it supports sets.\n\nBecause sets are monotonic", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    return not len(l) == 0\n\n>>> print(monotonic([1, 2, 4, 20]))\nTrue\n>>> print(monotonic([1, 20, 4, 10]))\nFalse\n>>> print(monotonic([4, 1, 0, -10]))\nTrue</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return False\n    for x in l:\n        if x[0] < x[1]:\n            return False\n        return True\n\nWhy not just do this?", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return list.startswith(0).endswith(list.end())\nYou'd have to write your own version of `monotonic` that takes your list type as an argument.  That said, you could create a wrapper class that takes a list and a function (`monotonic`) and just calls that function.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    \"\"\"\n    def monotonic_interval(elem):\n    \"\"\"Return True is elem is monotonically increasing or decreasing.\n    >>> monotonic_interval(2)\n    True\n    >>> monotonic_interval(2, 4)\n    False\n    \"\"\"\n\n    \"\"\"\n    def monotonic_subsequence(seq):\n    \"\"\"Return True if seq is monotonically subseq of l.\n    >>> monotonic_subsequence(seq, [1, 2, 3])\n    True\n    >>> monotonic_subsequence(seq, [1, 2, 3, 4])\n    False\n    >>> monotonic_subsequence(seq, [1, 2, 3])\n    True\n    \"\"\"\n\n    \"\"\"\n    def monotonic_negative_interval(elem):\n    \"\"\"Return True if elem is monotonically decreasing.\n    >>> monotonic_negative_interval", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\n    return abs(l.get(0)).abs(l.get(1)).abs(l.get(2)).abs(l.get(3)).abs(l.get(4)).abs(l.get(5)) == 1\n\n    def monotonic_dict(m, e, k=None):\n    \"\"\"Return True if the elements of the dictionary are monotonically increasing or decreasing.\n    >>> monotonic_dict([1, 2, 3], k=1)\n    True\n    >>> monotonic_dict([1, 2, 3, 4], k=2)\n    False\n    >>> monotonic_dict([1, 2, 3, 4, 5], k=3)\n    True\n    >>> monotonic_dict([1, 2, 3, 4, 5, 6], k=4)\n    False\n    \"\"\"\n    return {\n           k: (k, m[k]) for m in m.values() if k is not None", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    \"\"\"\n    def count(l):\n    \"\"\"Return the number of elements in list.\n    >>> count([1, 2, 4, 20])\n    4\n    >>> count([1, 2, 4, -5])\n    1\n    >>> count([1, -2, 4, 5, -6])\n    5\n    \"\"\"\n    return (l.length or 0)", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if len(l) > 0:\n       if l[0] == l[-1]:\n          return True\n       elif l[-1] > l[0]:\n          return True\n       else:\n          return False\n\nThe only way this code would work is if len(l) > 0 were replaced by isinstance(l, list) and l[0] == l[-1] were replaced by (l[0] <= l[-1]). But it's not clear that this is what the author meant, since len(l) > 0 is true for lists of integer elements and lists of string elements but not for lists of floating point elements, and the isinstance(l, list) check is only necessary if l is a list and not a tuple. So I think the author must have meant something else.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n\nYou are not comparing the same things. The first example is comparing the elements of the list to each other. The second example is comparing the first element of the list to the elements of the list.\n\nHuh, I thought that monotonic would always be true when the list elements are ordered in a monotonically increasing or decreasing order. The documentation on that is a little unclear.\n\nYou are right that it always is true. The second example is weird.\n\nWhat it does is compare the first element of the list to the list itself, and since the list is a list of lists, it will return false.</s>", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return len(l) > 0", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    if l[0] > l[1]:\n        return False\n    if l[1] < l[2]:\n        return False\n    return True\nOr how about       return l.get(0) > l.get(1)\nI'm not sure what `monotonic` is supposed to do, but this sounds like a good enough definition to me.\n\nThe problem with your definition is that you end up with a problem, when the list has only two elements, namely:\nreturn True\nThis means, that you are not testing if the elements are monotonically increasing.\nThe problem with the return True statement, is that you cannot apply any further tests on it.\nHence, if you want to apply for example a `is None` test, you need to use a boolean as the test return value.\n\nCould you show me a counterexample?\n\nI see a lot of examples where a list has only two elements.\n\nIt's a bit strange that monotonic() takes a function instead of a predicate as an argument.\nI would", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return sum(1 for i in l) > 0\n\nyields the same results.\n\nThe monotonic function in the article seems to be a bit buggy.\n\nThe author is trying to redefine the semantics of list operations in a way that allows him to avoid some mental overhead. This is cool, but to actually use it in practice one would have to rewrite the code that uses the monotonic function, which would be a nightmare.\n\nThis is pretty silly, but I like the idea of a \"monotonic\" function. Maybe one day someone will have an actual need for something like this and it will be added to the standard library.\n\nI think you're right.\nPython has it, and I could see it being useful.\n\nIt is also available in Haskell's standard library, as well as its functional analogs.\n\nThis is probably a stupid question, but is there a similar library in Python, or do you know of any standard libraries that has similar functionality?\n\nIn python there is functools.lru_cache. In java there is com.google.common.collect.LruCache.\n\nI like the idea of a monot", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    return l == list[0] && list[-1] > list[-2]\n\nI wrote a small program which takes an unsorted list of numbers, and checks if they are monotonically increasing. This is an extremely simple solution, but it's quite a useful one for debugging monotonic functions:\nimport list", "def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\" \"\"\"\n    def monotonic(l: list):\n    \"\"\"Return True is list elements are monotonically increasing or decreasing.\n    >>> monotonic([1, 2, 4, 20])\n    True\n    >>> monotonic([1, 20, 4, 10])\n    False\n    >>> monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n    if len(l) == 0:\n       raise StopIteration\n    return True"]]