[["from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is int:\n          return values[value]\n    return values\n\nI wish python supported overloading in this way. This is the kind of thing that should be a library, not a builtin.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values)!= 3:\n       raise ValueError('Values must be a tuple of three integers')\n    else:\n       return values\n\nWhat about negative integers?</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 1:\n       values = values[0]\n    return values\n\nI'm not sure what this is good for. I'm a Python newbie.\n\nIt allows you to do something like this:\n>>> from typing import List, Any\n>>> (3, 4) < List()\nTrue\n>>> (4, 3) < List()\nFalse\n\nPython's types are mutable, so you can't do this:\n>>> (4, 3) < List()\nFalse\n>>> (4, 3) < List()\nFalse\n>>> (4, 3) < List()\nFalse\n>>> (4, 3) < List()\nTrue\n>>> (4, 3) < List()\nFalse\n>>> (4, 3) < List()\nTrue</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value == int:\n           return value\n\nNot sure what you're trying to demonstrate, but that's not a Python idiom, and it certainly isn't idiomatic Python.\n\nIt's pretty much just a code golf entry. It does have a point though.\nPython's type system is very weak, and there's no built-in way to do what the OP did, which is to have a list of any and only keep the integers.\n\nIt's certainly possible to do it in Python, you just need to use the built-in functions to do it.\nThere's no need to import anything.\n\nWhat would you write to do it?\n\nn = 0\nwhile n < len(values):\nyield values[n]\n\nEven if this is possible, it's so much more verbose.\n\nI would say it's better to have a concise, clear function that does the job than to have a more verbose one that's likely to introduce bugs.\n\nI agree. What I meant was that Python could use some sort of built-in way to", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value is None:\n            return list\n        else:\n            return List(int(value))</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    for value in values:\n       if value.is_integer():\n          return value\n   \n    return list(filter(None, values))\n\nI'm not sure I see the value of this over\nfilter(lambda x: x is int, x)\n\nThat would be if you have a list of integers and want a list of the non-integers.\nThe OP's filter is for a list of any type and returns only the integers.\n\nMaybe I misunderstood but if you had a list of integers and you wanted a list of the non-integers, wouldn't you just use\nlist(filter(lambda x: x is not int, x))\ninstead of\nfilter(lambda x: x is not int, x)\n?\n\nTrue, although I think the OP's example is of more practical use.\nYou might want to do something like filter_integers('{\"foo\": 123, \"bar\": 556, \"baz\": \"some_other_number\"}') and it would return {\"foo\": 1, \"bar\": 1, \"baz\": 556}.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if values.has_key('_'):\n       return values\n    return [int(x) for x in values if x in (0, 1, 2, 3)]\n\nI see this a lot, and I really don't like it. Python is a beautiful language that makes it very easy to shoot yourself in the foot.\nI think that the above code is pretty much always better written as:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    if len(values) > 0:\n        values = [values[1:] for values[1] in values]\n\n    return values</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return lambda s: s.int()\n\nimport itertools\n\nfrom typing import List, Any\n\n    def filter_integers(values: List[Any], dtype: int):", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return filter(any_integer, values)", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i, value in enumerate(values):\n       if value == type(i) and value[0] == 0:\n          yield i\n\nx = [\"a\", 3.14, 5]\ny = filter_integers(x)\ny = y.replace(\"abc\", \"123\")\ny = y.replace(\"{\", \"1\")", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) > 0:\n        return values\n    else:\n        return [None]\n\nI feel like I'm missing something here, or perhaps the documentation is incomplete?\n\nTo me it looks like the documentation is incomplete. It's also a bit unclear to me why the function is given the signature it's given. I had to look at the implementation to understand what it did.\n\nFor more in depth examples, see this book, which covers many of the Python functions in the standard library: \n\nThe documentation is indeed incomplete. Here is a more complete explanation:\n\nInteresting, but is there any reason to use it over filter(lambda x: x in types)?\n\nSeems like a poor man's iterators.\n\nI find this much more readable than the `filter` method.\n\nI'll have to try it.\nThe only reason I don't use it now is that I've got `any` defined in my\nglobal namespace, so I'm not sure that I can use this without a lot of\nupdating.\n\nYou could define it locally.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if values:\n        return values\n    return []\n\nWhy is this interesting?\n\nThe idea is that you can write \"idiomatic\" python code and then use this to filter out the parts you don't want. A good example of this is you have a list of names that need to be alphabetically sorted. You could write the following:\n>>> names = ['Cody', 'Sam', 'John']\n>>> sorted_names = filter_integers(names)\n>>> sorted_names\n['Cody', 'Sam', 'John']\nIt's an interesting idea. I'm not sure what the use is in real life though.\n\nI'm pretty sure that it's idiomatic to use list comprehension for such things.\n>>> sorted_names = list(filter_integers(names))\n>>> sorted_names\n['Cody', 'Sam', 'John']\n\nIt is, but that's not the point of the article.\n\nI think a more elegant solution would be", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value is None:\n            return values\n        if value is int:\n              return [int(value)]\n    return values\n\nfrom typing import List, Any\n\n    def filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    for value in values:\n        if value is None:\n             return values\n       if value is int:\n              return [int(value)]", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return (filter(None, values))\nWhat's the point of this?\n\nI think it's a useful example of the built-in `filter` function.\n\nThis is a bad example of it. It takes a list of any Python object, and filters it for integers.\nAs a python programmer, this is wrong. You should use the appropriate type. If it's a list of integers, you should do it that way. If it's a list of strings, do it that way.\n\nI don't understand the point of this blog.\n\"From type import List, Any\"\n...", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values.sort()\n    values[0].isinstance(int)\n    for i in range(len(values)):\n       if values[i] is int:\n           values.append(i)\n    return values\n\nfrom typing import List, Any\n\n    def filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    values.sort()\n    values[0].isinstance(int)\n    for i in range(len(values)):\n       if values[i] is int:\n           values.append(i)\n    return values", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(any(x < 0), x > 0)\n\nwow, i really like this. very nice.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(lambda v: v[0]!= None).values()\n    return values\nI don't like that. The list comprehension is so much easier to read and parse.\n\nYou have to be able to use Python 2.x too.\n\nWell, you don't have to. If you use Python 3.x you should use Python 3.x only.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(isinstance(value, int)\n        # filter out any values that are not integers\n    # now filter out all the values that are not even integers\n    # we are using this value as a predicate to check if the value is even or not\n    # if the value is even then we keep it\n        if value % 2 == 0:\n           return values\n\nThe \"filter_integers\" function does not have a \"type\" attribute.\n\nIs it just me or is Python lacking a built in generic filter/map/reduce function?</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.sort()\n    any = (values[0] in int)\n    return values\nThat's cool.\n\nI like it too, but it should probably be something like:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    # return list of int\n    return values.filter(is_integer, key=lambdax:x[0]\n    andisinstance(x[1], int)\n    andx[1] > 0\n    andx[1] < 2\n    andisinstance(x[2], int)\n    andx[2] > 0\n    andx[2] < 2\n    andisinstance(x[3], int)\n    andx[3] > 0\n    andx[3] < 2\n    andisinstance(x[4], int)\n    andx[4] > 0\n    andx[4] < 2\n    andisinstance(x[5], int)\n    andx[5] > 0\n    andx[5] < 2\n    andisinstance(x[6], int)\n    andx[6] > 0\n    andx[6] < 2\n    andisinstance(", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    if len(values) == 1:\n        return values\n    else:\n        if values[0] == '0':\n           return values[1:]\n        elif len(values) > 1 and any(values[1:] for values in values if values[0] == '0')\n        else:\n           return values\n\nCan someone explain why this works? It's not obvious to me.\n\nfor values in values if values[0] == '0':\nwill always return a true value, unless values is the empty list. So, you can use that to make sure that only the first value is included in the list.\nThe return list is the same size as the original list, so if the original list is empty, then the return list will be empty as well.\n\nYou might also be interested in a python list comprehension:\nfrom typing import List\nlist_of_integers = [1 for x in range(3, 4)]", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    def find_int(x: List[Any], value: int):\n        return x.find(value)\n    return List(find_int(values))</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values.filter(Any('int'))\n    return values\n\nOh my god, I love you.\n\nAny other cool examples for list comprehensions?\n\nWhat you see in the docs is pretty much all there is to them.\nThey're a very useful tool for both exploration and programming.\n\nAnd the original paper (C++, but the same idea):\n\nVery interesting article, but I was disappointed by the lack of an actual code example.\nThe Python implementation is at\n\nI was a bit disappointed too. It doesn't look like the author has written any code at all.\nThis implementation is a bit more idiomatic, IMO:\n\nA more idiomatic python example:\n\nI love list comprehensions. They are incredibly elegant and powerful. I'd love to see more people use them more often.\n\nThere is a little problem with this example. The variable y is a list, but the operator any is not. Any should be a function, but currently it is a variable. I don't know if this is a problem with Python or the author's code.\n\nPython has a pretty good story for this stuff. If you want to use an operator", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if values is None:\n       return []\n    for value in values:\n       if value is not None:\n         if value is int:\n            return [value]\n       else:\n             return []\n    return []\n\nHere's a little function I wrote that should be part of the standard library:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    return (values.count(any()).is_integer() == 1)\n\nThis can be done a lot faster if you add this:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) > 0:\n        for element in values:\n           if element is not None:\n              return [element]\n    else:\n         return [values]\n\nI don't get it, what is the purpose of this code snippet?\n\nIt's the standard Python way of implementing list comprehensions (the \"list comprehension\" library function is called __iter__):\n>>> [i for i in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] if i % 2 == 0]\n[0, 2, 4, 6, 8, 10]\n>>> [i for i in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] if i % 2 == 0]\n[0, 2, 4, 6, 8, 10]\n\nOh I didn't know that, thanks.\n\nAnybody know if there's a Python equivalent of", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    for value in values:\n        if isinstance(value, List[int]):\n            return value\n    return None</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values)!= 2:\n       return []\n    for i, value in enumerate(values):\n       if i % 2 == 0:\n          return None\n    return List(value)\n\nTo make sure that i was never negative you should have used abs(i).</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) > 2:\n       return []\n    for value in values:\n       if isinstance(value, Any):\n          return [int(value)]\n    return values\n\n>>> filter_integers([1, 2, 3, 'abc', {}, [3.14, 5])\n[1, 2, 3]\n\nThat's a horrible way to use lists, you should use the built-in filter() function instead:\n>>> filter(filter_integers, [1, 2, 3, 'abc', {}, [3.14, 5])\n[1, 2, 3]\n\nTrue, but that would be a horrible way to use filter().\n\nWhat's the difference between the two?\n\nI wrote that code for fun, I have no idea why the author felt the need to add such a complicated function to the python standard library.\n\nBecause the built-in filter() function does not work as he describes, it returns a tuple of the original list and the filtered elements.\n\nYeah, that's what I meant.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for x in values:\n       if x is int:\n         return x\n    return None\n\nAlternatively you can use this (from lxml/html.py):", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for item in values:\n        if item is int:\n           return values[item]\n    else:\n            return values\n\nfrom typing import List, Any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for v in values:\n        if type(v) is int:\n           return v\n    return values\n\nThe author may be interested in the following paper:\n\nWe should be able to get rid of the 'import List' entirely. It seems that this is in fact a list comprehension.\n\nPEP 343 will allow this.\n\nWhy can't we just do:\nfrom typing import List, Any\n\nfrom typing import List, Any\n\nfrom typing import List, Any\n\nfrom typing import List, Any\n\nfrom typing import List, Any\n\nfrom typing import List, Any\n\nfrom typing import List, Any\n\nfrom typing import List, Any\n\nfrom typing import List, Any\n\nfrom typing import List, Any\n\nfrom typing import List, Any\n\nfrom typing import List, Any\n\nfrom typing import List, Any\n\nfrom typing import List, Any\n\nfrom typing import List, Any\n\nfrom typing import List, Any\n\nfrom typing import List, Any\n\nfrom typing import List, Any\n\nfrom typing import List, Any\n\nfrom", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) < 1:\n        values = values[0]\n        return values\n    for element in values:\n        if element is int:\n            return values\n\nThis is an interesting approach. It seems like it would work well with lists containing tuples, but not with lists containing other arbitrary types.\n\nIf you have nested data structures you can use nested loops.\n\nI can't think of any practical use for this, but it's still pretty cool.\n\nI'm guessing the idea is that you use it when you want to create an ordered list of values of a particular type, but some of the values might be null.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(lambda x: x > 0)\n    return values\n\nWhy not:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i in values:\n        if isinstance(i, int):\n            values.remove(i)\n    return values</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values.filter(lambda x: x.isint)\n\nThis is still leaking some information to the caller. The function \"isint\" is defined in the \"types\" module. The types module is included in the python standard library, but not in the python runtime, so if you import types, it will not work. (There is also the \"inttypes\" module, which is included in the standard library, but it is not the same as \"types\".)\n\nIt's hard to tell how bad the leaking is from the documentation. Here is a simple example:\n>>> import types\n>>> types.isint\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: '_types.isint' object is not callable\nThis is because the \"types\" module is not included in the python runtime.\n\nIf you include the standard library in your import path, you don't have to worry about this, though.\n\nI know, but people sometimes don't do that.\n\nI just wrote a post about this a couple weeks ago\n\nI use this almost every day, it's very convenient.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return filter(any = None, value = None, lambda x: x.is_int)\n\nBut in python 3, `filter` returns a generator, so you can just do `filter` with no arguments, and it will return a generator that accepts integers.\n\nThis is fantastic. One of my coworkers showed me this the other day, and I've been using it a lot. I have to wonder if there's a way to make the name not be so long though.\n\nIt's long, but it's also pretty descriptive, so it's easy to remember. I think it's a good thing.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n        if len(values) < 2:\n          return []\n        else:\n           return values\nNote that this doesn't preserve order of the items. That's what \"list comprehension\" means.\n\nI'm sure this is obvious to many, but I've never seen this before. Thanks for the insight.\n\nI've always used this:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value[0] == '0':\n         return value\n    else:\n         return None\n\nThis is a dumb question, but it's something I've been wondering about for a while. Why do some people write their decorators with the built in `@` syntax, and others write them with `def`?\n\nThe use of decorators in Python is controversial, so it's understandable that you'd be confused. The two are not the same thing, and they're not supposed to be. Decorators are a hack; they're a way to add attributes to an existing object. That's it. They're not meant to be used to build classes with new syntax.\nDecorators, as originally conceived, were never meant to be used for class definition. That was done by PEP 342, and it is almost universally hated.\n\nThis is why you use a language that supports proper class definitions.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.sort()\n\n    for value in values:\n        if value in types:\n            # Falsey values.\n                  # Ignore any object.\n                   # Skip empty strings.\n                    # Skip any string with a single alphanumeric.\n                    #\n                     if (type(value) is List[int]):\n                            # Store int representation\n                              # of value as a new list element", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for element in values:\n       if isinstance(element, int) and element > 0:\n          return element\n\nPython 3 has a built in filter method which does this:\n>>> import filter\n>>> print filter(['a', 3.14, 5])\n[5]\n>>> print filter([1, 2, 3, 'abc', {}, []])\n[1, 2, 3]\n\nI'm surprised this even needs to be discussed. Python 3 is a huge step forward in every way over 2.7. And most of the changes have been well-received. There are some minor annoyances, like the loss of the one-based indexing, but the new, 2-based indexing is better in almost every way.\n\nI'm also surprised the \"one-based\" indexing is so often mentioned as a major loss. It's just a matter of remembering that \"x\" is equivalent to \"x[0]\".\n\nThe problem is that there are a lot of good programmers in the world who do a lot of excellent work without understanding the underlying mechanics of the language. The 1-based index", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values_integers = filter(values, isinstance(values[0], int) == False)\n    return values_integers</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 1:\n        values = [x]\n    else:\n        if not values:\n           raise AttributeError('filter_integers expects a list of integers')\n           return [x for x in values if x.isdigit()]", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i in values:\n       if len(values[i]) == 1:\n          return values[i]\n    return None\n\nThe naming is unfortunate. It's not a generic \"filter\" function.\nIt's just a function that filters lists of integers.\n\nIt is, however, a good example of how to add a generic-looking function to a python module that is really a wrapper for a few specific functions.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(x)\n\nfrom typing import List, Any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value is not None:\n            value is int\n    return list(filter(int, value) for value in value)\n\nI'm not sure if this is a joke. If it's not, it doesn't work on the following input:\n>>> filter_integers([1, 2, 3, 'abc', {}, []])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'NoneType' object is not callable\n>>> filter_integers([1, 2, 3, 'abc', {}, []])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'NoneType' object is not callable\n\nIt's a joke, I think. If not it's really bad programming.\n\nThis is python, not a language where you can just do that without some explanation of what you're doing.\n\nI'm not sure I understand what the advantage of this is.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    # Just to make sure there is no confusion: Any is a typeclass.\n    def is_integer(value: Any):\n       return value.isinstance(int)\n\n    return values.filter(is_integer)\n\nIf this doesn't work for you, you are probably using python 3.0 and should upgrade to 3.1</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if value: isinstance(value, str) and not isinstance(value, int) and value: is not None:\n        return list(filter(isinstance(value, str), int))\n    else:\n        return list(values)\nI'm not sure what \"not isinstance(value, int)\" means.\n\nFixed it, I think. Thanks.\n\nThat's better.\n\nI'm not quite sure what this is trying to accomplish. From the description, it seems to be \"from typing import List, Any, int, str;.\"\n\nProbably an exercise in learning to type cleanly?\n\nI think you're correct; I've got a friend in a similar situation, and he's using Python as a way to learn good Pythonic practices.\n\nThis is a good, simple example, but I would be very interested to see a more complicated example, along the lines of what you'd use a typed language for, in order to make it clear how it's useful.\n\nI see. I'll keep that in mind. I'm working on a more complicated version right now.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for v in values:\n       if v not in [1, 2, 3]:\n          values.remove(v)\n    return values\n\nNice, but I'm not sure it's any more readable than\nvalues = filter(lambda x: x isint, values)\n\nI agree. The \"only\" there is a bit of a red herring.\nIt's a really nice trick to know about, but using it to replace the normal list comprehension syntax is a little bit of a stretch.\n\nJust a hint: if you want to highlight text, put \"> \" in front of the text.\n\nWhat language is that?\n\nPython.\n\nVery nice.\n\nWhoa, this is awesome.\n\nThanks. I always keep forgetting that kind of syntax, so it came in handy for me.\n\nwhy would you use a lambda here?\n\nBecause it's not the only thing you can use to create anonymous functions in python.\n\nCrazy.\n\nNope, that's python.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.isdigit():\n          return values.pop(0)\n    return values\n\nAha! I just discovered that python allows you to pass lists to functions that expect lists of lists. Not that it's terribly useful, but it's still interesting.\n\nIn python 2, lists of lists can be passed to functions that expect lists of anything. In python 3, lists of lists of lists are passed to functions that expect lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists of lists", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 0:\n        return values\n    return filter(any(int), values)", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(any(int), (x, y) for x, y in zip(values, filter_integers(values))\n\nCan't believe I didn't know about this. Thanks!\n\nI don't know if this is useful for most people, but I've been using the following:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    list = [0]\n    for value in values:\n       if isinstance(value, Any):\n           list = list | value\n    return list\n\nThis is way too easy.\n\nfilter_integers = lambda x: (x[0] == 0)\nfilter_integers([1,2,3,a,b,c])\n[1, 2, 3]\n\nI understand why it's a bad idea to put in an example that actually works. It's just that it's _so_ bad.\n\nThat looks like an excellent way to accidentally write an infinite loop.\n\nI think this is interesting for the same reason the halting problem is interesting: because it's something that seems to be doable in theory, but in practice is actually impossible.\n\nNot impossible at all.\n\nFirst, let me say I'm not trying to be an asshole.\nLet me also say that I _am_ trying to be an asshole, but a constructive one.\nYou're right. \"Not impossible at all\" was a poor choice of words on my part.\nI", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) > 0:\n        values = values[1:]\n        return values.filter(any(int, x))\n    else:\n        return []\n\nI'd remove the else clause, just because it's so obvious.\n\nI agree, but only if you're familiar with python and the various ways\nto do filtering.\n\nDo you mean \"if you know that the filter function in python is in the functools module\"?\n\nThis is very useful, but it seems like it should be a built-in function.\n\nfilter() is built-in.\n\nYes, but it can't do type checking.\n\nThat's the \"any\" part.\n\nI wonder if this is possible in Haskell.\n\nIt is. It's called a functor (in Haskell, a \"filterable\").\n\nIt's easy to implement a functor in python using filter(), but I think that the type checking in this solution is a bit more elegant.\n\nI'm not convinced that it's elegant enough to be a built-in.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.startswith(\"0\"):\n          return value\n       return []\n\nVery good, simple, clear example.\n\nI love this, but I've always wondered if there's a better solution.\nI'm never quite sure what the best way is to solve the problem of \"only keep the values I want\".\n\nIn this case, a dictionary would be better.\nfilter_integers = { 0: Some(value) for value in values if value.startswith(\"0\")}\n\nOf course, this only works for the case where you only want to keep integers.\nFor the common case, where you want to keep _all_ the values you have, but discard any that don't match your criteria, a dictionary is not helpful.\n\nTrue, but you can easily modify the filter_integers function to create a dict from the results.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if values:\n        return [values[0] for _ in range(len(values)) if values[0] == Any('int')]\n\nAnd the list comprehension version:\n>>> from typing import List, Any\n>>> values = [1, 2, 3, 4, 5, 6, 7, 8]\n>>> filter_integers(values)\n[5, 6, 7, 8]\n>>> filter_integers(values, (x: x for x in values if x is int))\n[1, 2, 3]</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for v in values:\n        if v is not None and not isinstance(v, int):\n            pass\n\nAnd the Python 3 equivalent:\nfrom typing import List, Any, int", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(number)\n\nThis version is slightly different from the Python version in that the list of values is coerced to a list of integers before filtering, which is arguably more efficient.\nAlso note that I haven't tested this, but the version with the explicit call to lambda is probably more efficient than the non-lambda version.\n\nThe lambda version (and the version with the explicit number argument) are the same, they both just use the built-in lambda.\n\nVery cool! I love it when someone takes the time to do the benchmarks.\nI have to say I am not a fan of using lambda. It makes code more readable to me. But I can see the argument for using it, and for the sake of benchmarks I think it's an acceptable compromise.\n\n_It makes code more readable to me._\nI am not sure that it's a matter of readability. Lambda is just a programming construct, it doesn't change the meaning of the code.\n\nFor me, it makes code less readable. I can't visually see the lambda, so I have to mentally think more than I would with a function call.\n\nThat's a fairly lazy argument. Consider:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i in values:\n       if i is not None:\n         if i == 0:\n            return values\n        else:\n             return []\n\nThis is one of the things that makes Python so nice. I can't imagine\nthinking that the only way to implement a filter is to list every\npossible value, and that it would be ok to have an O(n) loop for\nevery such filter.\n\nIt's also one of the things that make python slow.\n\nAs I said, Python does things the way I would do them. If a program\nneeds performance, and I don't have time to optimize it, I won't use\nPython.\n\nAlso, the implementation of List.filter() is O(n), not O(n^2).\n\nI guess the discussion is about n-ary filtering and the use of nested\nloops in Python. I always just write the following function:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values[0]\n    for value in values:\n       if value.isdigit():\n           values.remove(value)\n    return values\nThis also works with a list of strings:\n>>> filter_integers(['a', 'b', 'c'])\n['a', 'b', 'c']\n>>> filter_integers([1, 2, 'b', {'a': 1, 'b': 2}, [], 'abc'])\n['1', '2', 'b', {'a': 1, 'b': 2}]\n\nI think the real trick here is the dict-like object:\n>>> filter_integers({'a': 1, 'b': 2}[])\n['a']\n>>> filter_integers({'a': 1, 'b': 2}[])\n{u'a': 1, u'b': 2}\n\nThis is not magic, this is just using a dictionary as a filter.\n\nIt's a little more than that. Take a look at the source:\n\nAh, nice", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(any(isinstance(value, int))).as_list()", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for item in values:\n        if item.isinstance(ItemType, int):\n            return item\n    return values</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is int:\n         return values\n\nI like to use the following:\nfrom typing import List, Any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x >= 0)", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) > 0:\n        values.pop(0)\n        return values", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value.is_integer:\n           values.append(value)\n    return values\n\nThe examples are pretty cool. I hope that Python's implementation is going to be optimized enough to make use of these little things when it matters.\n\nThis is not new, it's in the standard library.\n\nIt's not even in the standard library, it's in the interpreter.\n\nI thought list comprehensions were introduced in Python 3.0?\n\nThey were, but the \"filter\" expression was always there.\n\nWhy is this useful?\n\nFor one thing, it's a good example of a list comprehension.\n\nIt's great to have this, but I don't see why it couldn't be put in the standard library.\n\nIt's not new. It's been there since at least Python 2.4 (that's the first time I remember seeing it)\n\nHow is it different from filter()?\n\nI think it's a list comprehension, so it's more readable/easier to write.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(isinstance(v, int))", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for item in values:\n        if item is int:\n            return values\n    else:\n             return None\n\nIt's important to understand that this only works if you don't mind ignoring the values which you are _not_ looking for. If you want to ignore values that are not integers, then you'll have to modify the function to check for the _exact_ type you want (and not a type that you can \"cast\" to the type you want).\n\nI don't get it. What's the point of the last line? Wouldn't this work without it?\nfilter_integers(['a', 3.14, 5])\n<any_list>\nfilter_integers([1, 2, 3, 'abc', {}, []])\n<any_list>\n\nNot quite, since the 'any_list' type is not very useful. It is essentially a container with no elements. That is, the list object itself is not defined. The result would be:\nfilter_integers([], [1,", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    values.filter(any(isinstance(value, int))).to_list()\n\n    return values.to_list()</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values\n\nI'd make a generic function, since I'm sure you'll want to use this in other cases as well:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value is int:\n           return values\n   \n\nThis reminds me of the \"Hacker's Delight\" algorithm.\n\nDoes this work with list comprehensions?\n\nPython doesn't have list comprehensions. It has comprehensions, but that's a different beast.\n\nI must be misunderstanding something. If I wanted to filter a list of any, then why would I write:\n[any(val) for val in values if val is int]\nrather than\n[val for val in values if val is int]\n\nBoth will work, but the latter is shorter, which is the point. You can also do something like\n[val for val in values if val is int in list(any())]\nfor more concisely.\n\nAhh, ok, thanks for the clarification. I was also under the impression that Python has list comprehensions, but I guess that's just something that people wish they had.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    if values.count('i') > 0:\n        return values\n    return []\n\n    # filter_integers is a function that accepts a list of python values\n    # and returns a list of integers only\n\nNote: The OP is using this code as an example of how the title would be written in Python. The OP is not the author of that code.\n\nI don't get it. What's the point of this? (Genuine question, not trying to be an ass)\n\nIn Python, the list comprehension syntax, which is used to create a list of lists, is the same as the list comprehension syntax for functions, which are lists of instructions.\nFor example,\n[x + y for x in range(10)]\nIs the same as", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x == int(x))</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return sorted(values, key=lambda x: x[1], reverse=True)\n\nIt'd be faster if it was written in C (assuming you're on an UNIXy machine).\n\nWhat part of the code do you think would be faster?\n\nI believe he is talking about using the inbuilt C function strtok(3) instead of the lambda.\n\nInteresting. I assumed he was talking about the fact that strtok() is a C function, and not available in Python.\n\nIsn't this a fairly common idiom in python?\n\nNo, it's not. In fact, it's not idiomatic at all.\n\nI'm not sure about the implementation, but it seems like a good idea.\n\nThe implementation is exactly the problem.\nThe author is using the built-in function sort() to sort a list of _any_ objects, and then using a recursive call to strtok() to filter out integers. This is a really bad idea, since sort() will not sort lists of non- integers in the same way that it sorts lists of integers.\nThe most popular way to do this is to use the built-in function it", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    for value in values:\n       if value: isinstance(value, Any):\n          continue\n    else: return values\n\n    return List(filter(None, values), filter_integers(values))", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value:\n          return value\n    return List()\n\nfrom typing import List, Any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 0:\n        raise TypeError('values must be a list of at least one value')\n    if isinstance(values[0], (List, tuple, set, frozenset, tuple[0])) is\n        not None:\n        return values[0]", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 0:\n        return []\n    for element in values:\n        if type(element) == int and type(element) == str:\n           return []\n         else:\n           return values[element]\n\nIt would be better to have two functions:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values.filter(value for value in values if value.__class__ == int)\n\n    return values</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values.sort()\n    return values.filter(lambda a: a.is_integer())\n\nI like the way he explains it in the comments:\n\"The key to the code is \"List[Any]\" which is a builtin python type.\nList[Any] is a list of any type of value. It is very useful, and can be\nthought of as the \"everything\" type.\nBecause the type of the value in the list is not known until the list is\nevaluated, a type cast is required. Python has builtin type casting:\nany(any) returns True if the type of the value passed in is the same as\nthe type of the receiver (e.g. \"a\" is a list of any type of value, and\n\"Any\" is a list of any type of value, so Any(any) is True).\nThis makes the code work.\n\"\"\"\n\nI'm surprised Python is a dynamic language, I really thought it was a hybrid.\n\nPython is a dynamic language. It's just that most of its type system is done with duck typing.\n\nPython is a hybrid between static and dynamic. Some of the important", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(i for i in values if i % 2 == 0)", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return list(values.filter(lambda x: x is int)).map(lambda x: x.int)\n\nThat's a pretty interesting use of type classes! I'm a noob when it comes to python and functional programming. Could someone explain to me the idea behind this?\n\nI'm not sure why I was downvoted. I was curious how the type classes are used in this specific example.\n\nI didn't downvote, but I'll take a stab:\nit's the kind of question that can be easily answered by googling 'python type classes' and reading the first result.\n\nI understand, and I did google it. But the explanation I got out of it didn't make a lot of sense to me.\n\nBecause you don't understand type classes in general. This post is a nice explanation:\n\nI've been reading up on them and I get the general idea of it. But the specific example I was looking for didn't make sense to me at the time. But I think I get it now. Thanks for the link.\n\nIn Python 3.2+ you can also use the type class Any to implement this, without having to use a list comprehension", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    result = []\n    for value in values:\n       if value == int:\n          result.append(value)\n    return result\n\nNice one.\n\nAnd an alternative:</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values[0].is_int()\n\nI don't get it.\n\nI do. There's a difference between _any_ integer and _integers_.\n\nThe real problem is that the type Any has type Any, which means the only thing you can tell about it at compile time is that it's a type. So Any is an ad-hoc type variable, and anything can be assigned to it, including lists, and lists of objects, and any other data structure.\nI think Python could have been designed a lot better.\n\nPython is one of the best designed languages in the world.\n\nIt's OK. It's not a bad language. But it has a few problems that could have been avoided. For example, the type system has a number of problems. I think the type system could have been improved. I also think it would have been possible to get rid of the type variable Any entirely.\n\nI agree. I'd rather have two types, and call them integers and non- integers. That way, you can actually check if a value is an integer.\n\nI would suggest this as the correct approach. Or at least make it so that objects of type 'Int", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values if values.any() is List[int] else []\n\nThat's a pretty great solution, and I've always wondered why it doesn't exist in the Python standard library.\n\nBecause Python is based around dicts and list comprehensions, which don't provide an analog for this filter.\n\nThat doesn't make sense to me. Why not?\n\nBecause the idea of a list is that you can list multiple different types. You can't do that with a dictionary. The closest you can get is a dict with a list of key-value tuples, but that doesn't look very good to someone who expects a dict to be a single type of object.\n\nI'm not sure I understand your answer. The function doesn't limit the types of the elements in the list at all. It just ensures that the elements are integers. It's the same with list comprehensions, which allow you to select elements based on any property you want to select.\n\nFor example, to get the list of integers in the example, you use filter_integers(list)\nBut in the list comprehension:\n[x for x in list if x.is_integer]\n\nIt's not Python", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for v in values:\n       if isinstance(v, int) and v > 0:\n           values = [v]\n    return values\n\nfilter_integers(['a', 'b', 'c'])\nfilter_integers([1, 2, 3, 4, 'abc'])\n\nfilter_integers(['a', 1, 2, 3, 4, 'abc'])\nfilter_integers([1, 2, 3, 4])\n\nfilter_integers(['a', 3.14])\nfilter_integers([1, 2, 3, 'abc'])</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(is_integer, None)\n\n    return values\n\n Is this a common idiom?\n\nI find it interesting that the first solution was a recursive solution, and the second solution was not.\n\nFor a simple problem like that, a recursive solution is more elegant and is usually shorter.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is int:\n          return value\n      else:\n          return []\n\nThe name of the module is \"filter_integers\". It should probably have something like \"filter_all_integers\" or \"filter_all_int\" if it only does integer filtering.\nI think it's a good idea, but there's a few problems. The first is that the syntax isn't completely idiomatic, which makes it harder to read and understand. The second is that it's very similar to filter(), so it's not as nice to use. The third is that there's no reason to use it when filter() is available.\n\nit's a good idea, but there's a few problems. The first is that the syntax isn't completely idiomatic, which makes it harder to read and understand.\nI think this is a good point, and the reason I didn't do it like this.\n\nSo, you can actually do\n>>> a = [1, 3.14, 5, {}, [])\n>>> print filter_", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for _ in values:\n       for i in xrange(len(values) - 1, 1):\n           if values[i] == None:\n                return values\n    return List(values.pop(i))\n\nimport itertools, filter", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 1:\n        return values\n    for value in values:\n        if type(value) is int:\n           return value\n\nI'm not sure why that's called \"filter_integers\", since it doesn't accept\nintegers (only the last line of the function does).\n\nIt should be \"filter_values_that_are_integers\", but that's too long.\n\n`filter_integers(values)` can be shorted to `filter(values, isinstance(values, int)`\n\n`filter_integers(values)` can be shorted to `filter(isinstance(values, int), values)`\n\nPlease don't do this.\n\nI think the point is that you can do this kind of thing with methods.\n\n`filter_integers(values)` can be shorted to `filter(isinstance(values, int), values)`\nPlease don't do this.\n\nI think the point is that you can do this kind of thing with methods.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 1:\n       values = values.pop()\n       return values\n    else:\n       values = values.sort()\n       for i in values:\n          if type(values[i]):\n             if values[i] == type(values[i]):\n                 continue\n                  if values[i] < type(values[i]):\n                         break\n                        if values[i] > type(values[i]):\n                            break", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if isinstance(value, int):\n          values.append(value)\n    return values\n\nHow does this compare to the built in 'filter'?</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return sorted(values, key=lambda x: x.int)\nThis is Python, not Haskell.\n\nIt's not like it's wrong, though.\n\nI think the author's point is that, in Python, we don't need to use list comprehensions when we want to filter a list of anything into a list of a particular type.\n\nActually, that's not what I was trying to say.\nI was trying to say: \"If you're doing list comprehensions in Python, you're probably not using the Pythonic way of doing it.\"\n\nI get the impression that this is not a widely held view in the Python community.\n\nI see. Can you give me a few pointers to code that uses comprehensions in a Pythonic way?\n\nSure. The canonical example is `map()`. That's just a list comprehension that doesn't use an explicit list.\n\nI'm using Python 2.6.1 on Windows, and I get:\nTypeError:'sorted' object is not callable\n\nIt's a typo in the article. It should be'sorted(values, key=lambda x: x.int)'\n\nI would argue", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x == 0)\n\nNo need for the `Any`.\n\nWhy not use it? It's not hurting anything.\n\nIt's an extra parameter to the function, and is totally unnecessary to its functionality.\n\nI agree with you, but you could have said it more gently.\n\nI'm sorry, I really meant no harm. I just wanted to point out that the extra parameter doesn't have to be there.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is not None and value is not None and value is not None:\n         return value\n    return values\n\nReminds me of the old qsort vs qsort() argument.\n\nThe advantage of the first version is that it's more readable. It's easy to tell what's going on when you see that a parameter named 'values' is being passed to a method named 'filter_integers'. The second version is less obvious, since the parameter is named 'values', and is used in a way that makes it unclear whether it's being passed to a method named 'filter_integers' or is being used in a conditional expression.\n\nThe other advantage of the first version is that it is more efficient.\n\nNo, it isn't.\n\nI mean, it might be more efficient for the _programmer_. But the computer still has to read the whole thing.\n\nYes, but it doesn't have to read it in order to run it. The first version is not cached, so it has to be parsed and then discarded. The second version is cached, so it", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i in values:\n        if i == int(i) or i == None:\n           values.remove(i)\n    return values\n\nNote the potential for confusion. In Python 2.x, it's not very uncommon to call a method named filter on a type named List. This is one reason why I'm glad the language designers chose the current name for filter() (in Python 3.0).\n\nI'm not sure if you're serious, but it's very common in Python to use objects with the same name as a function. In this case, it would be more confusing if it were called anything else.\n\nIn Python 2, it's common to have a method named filter on a type named List. In Python 3, it's common to have a function named filter on a type named FilteredList. I'm not sure why you would think that it's \"very common in Python to use objects with the same name as a function\".</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 1:\n       return values\n    return [int(values[0]) for value in values]\n\nI never thought about using Any for that use case, but it's so obvious now.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return [x for x in values if (x % 2)!= 0]\n\nPEP 366 might be relevant here: \n\nand what about range()?\n\nThe fact that range() is named range() makes it pretty hard to use it as a function name.\n\nHow is it \"pretty hard\"?\n\nIn what context would you ever call a function named range()?\n\nIn the context of a function that can return a range of numbers, as in the example in the link.\n\nSo basically you're saying that it's hard to use range() as a function name, as in as the name of a function, but that it's not hard to use it as a function.\n\nNo, I'm saying it's not hard to use it as a function name.\n\nThat's because range() is an object method. To use a method name as a function name, you need to declare the method as a function.\n\nI'm not trying to be a smartass, but just trying to understand: is your claim that the name of a function must always be a valid name of a function?</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if values is not None:\n       # only return the first value\n       return values[0]\n\nThis works, but is pretty ugly.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if values:\n        values = values.filter(**lambda x: x%2==0)\n    return values\n\nwhere do you see that this is any different from ?\n\nFrom the first comment on the code:</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for x in values:\n        if x not in ['0', '1', '2']:\n           x, _ = values[x]\n    return x\n\nThis is also easy to write in two lines:\nfrom typing import List, Any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) > 1:\n       values = [values[0] for i in values]\n    return [i]\n\nThis is a much more natural way to write it. The function type-checks without any annotations, and the list comprehension is easier to read and understand, as well as being more flexible and less error-prone. I think you've hit on a really good way to write functions that is much more useful and flexible than the standard from typing import * approach.\n\nI'm surprised there aren't more comments about this. It's a rather nice trick.\n\nIf this is what you want, you're probably better off using Python's built-in iterators.\nfrom typing import Iterator", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(isinstance(x, int))\nI don't get it. Can someone explain?\n\nThe filter function is generic. It just takes a function and a list, and returns a list of the elements that match the function.\nIn the example, it's assumed that the function is itself an integer, and so filter_integers is a function that takes a list of integers and returns a list of the integers in the list.\n\nWhat do you mean by \"generic\"? I'm not familiar with the term.\n\n'generic' just means that it can be used for any kind of input.\n\nSo then how does it know how to call the function that it receives?\n\nThe function it receives is just passed in as a parameter to the filter function. It does this by prefixing the function name with \"f\", e.g.\nfilter(f)\nThat way, you can use the filter function on any kind of function, and it will just call the function f with the list.\n\nIt seems to me that this is a bad design.\nfilter() needs to know what type the function is. The function could be a function with a name that just happens", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value == int:\n            return values[value]\n        return values\nI think this kind of thing should be banned. It's a hideous code smell.\n\nIt's also a newbie's code smell. The same kind that would write the OP's code.\n\nI'm not sure I follow. Isn't a newbie's code smell something that a newbie would write? That is, code that a newbie would write?\n\nThis code is quite weird, but I think the author is using a newbie-like expression here to express that a newbie (the author presumably is not) would write the code.\n\nAh, I see.\n\nI wonder how many people in this thread have actually read the Python documentation on classes and objects:\n(the specific section is \"Objects and Classes\" on page 16)\n\nHe forgot the \"private\" keyword.\n\nAt least he didn't use any globals.\n\nThis is one of the reasons I love Python.\n\nHere's a better way:\nfrom typing import", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for x, v in values:\n       if x is int and v is int:\n          return x\n    return None", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values[(values.index(Any) % 2) & 1 for values in values]\n\nThis is not a good example. It's far better to use a dictionary (with the 'is' operator) to avoid the need for an if:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(Any(i).is_integer)\n\nAll this does is use Any to convert to int.\n\nThanks for the comment, I updated the gist to make it more clear.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(not isinstance(value, List[int])).tolist()\n\nHehehe. This is a really simple example, but it's a perfect example of why you need to know how to use type annotations in your python. I would have never thought to use a List[int] for the input to a function that returns a list of integers. I would have just wrote the function with the following code:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x < 2)\n\nEquality is defined by a lower bound of 2 rather than 2.0.\n\nI never thought of it that way. I always assumed the floating point argument\nwas actually an integer but with a decimal point.\n\nWhich is not the case:\n>>> 1.0 / 2.0\n0.5\n>>> 1.0 + 2.0\n3.0\n>>> 1.0 + 3.0\n4.0\n>>> 1.0 - 2.0\n1.0\n>>> 1.0 - 3.0\n0.0\n>>> 1.0 / 1.0\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in?\nValueError: integer division or modulo by zero\n\nThis is true, but doesn't answer the question. Floating point operations\nin Python _are_ integer operations, but the result is stored in floating\npoint precision, which is why you get garbage when you divide by zero.\nHowever, I don't know why the lower bound is 2 rather than 2.0. It is\nprobably just a historical accident.\n\nPython", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for x in values:\n        if x is int or isinstance(x, int):\n           return x\n    return values\n\nI don't get it.\n\nIt's a type-safe way to convert an arbitrary Python list into a list of integers.\n\nOh, thanks.\n\nI suppose I could have been a bit more clear...</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for v in values:\n        if v is int:\n            v = v.intValue()\n\n    return v", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(isinstance(value, type(int)))</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values.filter(lambda v: int(v))\n\nfilter_integers()", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if int(value) == 1:\n           return values\n       else:\n           raise ValueError('Expected at least one integer')\n\nThis is a dumb, dumb example. Filtering integers should be done with integers. It should be easy and obvious.\n\nI've heard this argument before. I'm not sure I agree. For example, in this case, why shouldn't we simply raise an error if someone passes us a list of tuples?\n\nBecause when you're filtering, you're performing some operation on the input. You're not passing in a list of values and then doing something else with it.\nThe problem is, I don't think there's a single convention for \"I want to filter this\". I think it's always a matter of context.\n\nSo then should filter_integers have a default value of -1 (for example) so that it only works on lists of integers?\n\nSure. It's always possible to add default parameters to a function and only allow the user to provide other values", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if isinstance(value, int):\n            values.remove(value)\n    return values</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n         if isinstance(value, int):\n              return list(filter(isinstance, int, value))\n\nIt's not so much a function as a snippet of code. It doesn't return anything, doesn't take any parameters, doesn't do anything at all except define a new type (\"List[Any]\") and one function on that type (filter_integers).\n\nThanks for the feedback. I agree, it doesn't do anything at all, except define a new type. I was hoping the title of the post would be enough to indicate that, but I guess I should have made it clearer.\n\nYes, it's a function. It takes a List and returns a List. It's just a very simple function.\n\nI'd love to hear the reasoning for this.\n\nThe reason is that the term 'function' has a meaning in computer science. It means something that maps some inputs to some outputs. Python functions don't necessarily do that.\nA Python function (function in the computer science sense) is just a particular way of defining a function in Python.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for x in values:\n        if x is int:\n           return x\n\nPython has a built-in function named filter that does the same thing.\n\nLooks like it's a different utility function. filter takes a filter function and a list of things that the filter function should apply it to. This function doesn't take any function and takes a list of objects, and returns a new list of objects with all the non-object values removed.\n\nI got a little excited to see this in the Python docs, until I realized it's not the same as Python's builtin filter.\nPython's filter is a filter, not a utility function.\n\nIt's better to use `filter` and `map` instead of this:\n\nI've been a Python coder for about 3 years, but I've been using Ruby for about 2, and have always had this question. When are these useful? I'm not trying to be snarky here. I'm really interested in why I'd use this instead of filter, map, or reduce.\n\nWell, the example given is\nfilter_integers([1, 2", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for x in values:\n        if x is None:\n           return x\n        if x.is_int() and x in range(0, len(values)):\n            return values[x]\n\nI think this is the kind of code that is fun to write and probably wouldn't be hard to use, but would be really hard to maintain.\n\nI see a lot of this type of code:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x[0] == int(x))\n\nI'm curious as to why you'd use _list_ for the first example, but not the second.\n\nThe first is easier to understand. I'd rather the first example be understandable by someone who's not a Python programmer.\n\nWhen I first started doing Python, I never fully understood why there were two different kinds of lists: list and tuple. It wasn't until I began working with a large project with other programmers that I realized I was supposed to use list when I wanted to do something with it, and tuples when I wanted to return a value.\nI guess this makes sense, but it wasn't at all intuitive to me.\n\nI wouldn't say it's not intuitive, it just isn't explicitly explained in the documentation. I would have thought it would be, but I guess it's assumed you'll just pick it up after a while.\n\nI don't think I've ever seen an explicit explanation in the documentation of a programming language or library.\n\nYou've never seen a tutorial?\n\nI'm not sure what kind of tutorials you've seen but the tutorials I've seen are meant to", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values\n\nAs someone who is learning python, I don't understand what is happening. Can you please explain?\n\nHi,\nI think it is a joke because of the last parameter of the function. In the first example, you get back the same list of values. In the second example, it returns a list of integer values.\nIt is not that bad if you write it this way:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return list(filter(lambda x: x.is_integer, values))\n\nHey, that's pretty neat! Thanks!</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(any_integer, None)\n    return values.values()\n\nI think this would be better as:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    if len(values) == 0:\n        return List(0)\n    else:\n        values = values.filter(lambda x: x[0] > 0)\n    return List(values)\n\nUhm, how can you get 0 from a list of None?\n\nYou can't. I tried it and got an error.\n\nI think this is a bad idea, because of the way this interacts with Python's built-in functions.\nIn Python, the two not-inclusive \"slices\" of the number 1 are \"1\" and \"1000000000\". But if you use one of those slices as your slice of integers, the above function will return a List of None.\nI think this function should be called filter_natural_integers, or filter_nonnegative_integers, or something like that.\n\nWhat's the use case for filtering integers? I would think that if you want to apply a function to a list of integers, you'd just stick the function in a list comprehension.\n\nThe point is that it makes it a little bit easier to apply a function", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is int:\n         values.append(value)\n\nNice!</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    \"\"\"List of Integers to return\n    >>> filter_integers(['a', 3.14])\n    [5]\n    \"\"\"", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(isinstance(value, int)).toList\n\nThanks! I was wondering if something like this existed.\n\nThis is super useful, thanks.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i in values:\n        if i is not None and i % 2 == 0:\n           return values[i]\n    return List()\n\nI like this one", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda a: a >= 0)</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    if values['numerical_type'] == 'int':\n       return values\n    else:\n       values = filter_integers(values.pop(0))", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    for value in values:\n        if isinstance(value, Any):\n             value = value.__class__.__name__\n              if isinstance(value, int):\n                    value = int(value)\n          else:\n                       value = value\n    return values\n\n    def is_empty(val: Any):\n        return not isinstance(val, List[Any])\n\nI'm wondering what's the point of this. Can someone explain?\n\nEssentially it allows you to return a list of only the results from a particular filter (here integers, but it could be anything).</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(lambda x: x % 2 == 0)\n\nThis is interesting.\nI used the following to do something similar (no pure python) in the shell:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values.filter(Any(isinstance(value, int))).tolist()\n\nNote that the \"Any\" type is not a built-in type. I think it is basically a special type of object which is an instance of the object type \"Any\", but not an instance of any other class. The \"Any\" type is defined as follows:\n\nfrom typing import Any\n\n  class Any(object):\n    \"\"\" An arbitrary object that can be any type.\n    >>> any = Any()\n    >>> any.__class__\n    <class 'Any'>\n    >>> any.__type__\n    <type 'Any'>\n    >>>\n    'a'", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    return lambda value: int(value) in values\n\n\"\"\"", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for item in values:\n        if item.lower() in ('0', '1' ):\n            return items[item]\n    return values</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value not in [0, 1, 2, 3]:\n          return value\n\n(looks like a homework question)\n\nYou're right. Can you point me in the right direction to resolve this?\n\nThe first line has you importing \"List\", \"Any\", and \"functools\". Since any object can be used as a function argument, you can just use \"functools.partial\", instead of importing all these classes.\n\nYou can also do it with \"all\", instead of \"any\":\n>>> from typing import all\n>>> def filter_integers(values: all) -> all:\n... for value in values:\n... if value not in [0, 1, 2, 3]:\n... return value\n...\n>>> filter_integers(['a', 3.14, 5])\n['a', 5]\n>>> filter_integers([1, 2, 3, 'abc', {}, []])\n['a', 2, 3]\n\nThe above is how you would do it in Haskell, and I find it a little more readable,", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    filtered = []\n\n    for value in values:\n       if isinstance(value, int):\n          filtered.append(value)\n    return filtered\n\nFiltering lists of any-type is very useful. I was searching for this exact technique the other day.\n\nThere is also a partial solution to the slightly more general problem of filtering a list of items, whether they be integers, lists, dictionaries, etc:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values\n    filtered = []\n\n    for value in values:\n        if value is int:\n           filtered.append(value)\n        else:\n           values.append(value)\n    return filtered\n\nI don't get it. The only thing that differs between the two is that the first one accepts any type, while the second one is specific to integers.\n\nThe difference is in the filtering, not in the type.\nThe first filter converts the list of values into a list of ints, then filters.\nThe second one filters on the fly.\n\nIt doesn't look like it's filtering anything. It just loops through the list of values and appends them to the list of ints.\n\nI think the confusion comes from the fact that it's using an imperative programming style where a functional approach is expected.\nSo, it's filtering by checking the type of values and then adding to a list.\n\nI know, I was just trying to explain why it's being downvoted (", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter( lambda x: int(x))\nThe funny thing is that I was just reading about that list comprehension syntax yesterday. I wonder how many people know about it?\n\nYes, it's a neat trick. It's so nifty I had to make sure this didn't belong in one of my project's svn branches.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return [filter(x, List(any(integer))) for x in values]\n\nDoes anybody know of a way to do something like this in a more idiomatic way?\nIt's a little annoying that you have to pass in the list as an argument to the function, and then have to return a whole new list. I'd like to write something like:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i in values:\n       if i % 2 == 0:\n          return i\n    return values\n\nThis is a really, really bad code snippet.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for _, value in enumerate(values):\n        if int(value) > 0:\n            return value\n\ns/list/any/ and the page is at\nI'm not sure why this is on HN.\n\n_\"I'm not sure why this is on HN.\"_\nI am.\nIt's a great little library. Not too much code, and it solves a common problem.\n\n\"it solves a common problem.\"\nYes, and it solves the common problem of having \"too little code\" while doing it.\n\nI love the simplicity of this. I can see it being useful for other types of things like lists of strings or floating point numbers. I don't know if the list of integers should be considered the \"original\" type or if the values returned should be considered the \"original\" type. If the list of integers is considered the original type then the library can also be used to return lists of numbers with integers removed.\n\nI use a slightly different method for this problem:\n\nI hate to be that guy, but if you don't want to be bothered by those", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    \"\"\"\n    return values.filter(Any.is_int())\n\nI'm sure I've seen a similar example before, but I don't understand why this is \"cool\". Anyone care to enlighten me?\n\nThe value of the \"coolness\" of this is that, for some problems, it's easy to forget the simplicity of Python.\nI always get excited when I see a good use of built-in modules in Python. It's an easy language to forget the beauty of.\n\nI remember seeing this on here a couple of years ago. It is a neat trick and I love it. It's just a shame that it is only useful for a very particular use case.\n\nThe fact that it's a very particular use case is actually a _good_ thing. If you only need it once in a blue moon, it's great that it's so easy to implement.\n\nThe code is not as clean as it should be, it could be a little more pythonic.\n\nHow so?\n\nMy first thought was that it could be done like this:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 1:\n        return values\n    for v in values:\n        if isinstance(v, list):\n           return [v]\n        else:\n           return None\n\nAnd, to emphasize the point, here is an equivalent version using itertools.tee:\nfrom itertools import tee", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(value_type_is_int)", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = [Any() for x in values if x.is_integer()]\n\nI hope everyone who's downvoting this article realizes that it's not saying that the code is a good idea, only that it's interesting.\nI've been considering trying to write a pythonic language with a type system modeled after python's.\n\nI would prefer it without the import, but I agree, it is very interesting.\n\nThat's the point: the import is for demonstration purposes, to make the code slightly more readable.\n\nThe article is not very clear, but it appears that this function will raise an exception on the first list it encounters that is not an integer.\nI think it would be better if it used a bit more Pythonic style and raised an exception on the first list it encounters that is not an integer _or has a __bool__() method_. (You could probably do it with just __nonzero__.) That would also get around the \"is_integer\" test, which is, IMHO, an ugly way to express the condition.\n\nI like it. But I'm not sure about the \"filter\" part of it. That would be more natural as a pure function", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if isinstance(value, (int, float, str, unicode)):\n          value = value[0].int  # integer only\n    return list(filter(isinstance(value, int), 1))\n\nThis is one of those things where you don't realize how important it is until it's gone.\n\nWhy?\n\nIt would make it very hard to write things like:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i in values:\n       if values[i] in [0, 9]:\n          values[i] = i\n    return values\n\nThe Python code uses a function named filter_integers(...) which is called from the C code using a (Python) decorator. So, the Python code defines the function.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    return values.filter(is_int)\n\nfrom typing import List, Any\n\n    def filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n\n    return values.filter(is_int)\n\nfrom typing import List, Any\n\n    def filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n\n    return values.filter(is", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(Any(int).__name__)\n\nWhat is this doing?\n\nFiltering a list for only integers by checking whether the object is an int and whether it has the __name__ of a type that is convertible to int.\n\nI really like this, I think it's one of the clearest examples I've seen of the difference between 'language' and'syntax'.\nIn most examples, you can simply replace 'python' with 'python-like', but here the syntax is more fundamental.\n\nThe syntax is actually the same as in Ruby:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    filtered = []\n    for x in values:\n       if x is not None:\n          filtered.append(x)\n    return filtered\n\nVery nice.\nAlthough I don't think it's a good idea to use it as it is (it will\nreturn all integers from 1 to n for every list, even if you don't\nwant that) I have taken the concept of using Any as a kind of\n\"default\" and put it to good use in another place.\n\nIt's not a good idea to use it as it is, because it's a huge code\nsmell: in the vast majority of cases, the \"default\" should be None.\n\nWhy not \"None\" as default, and an \"optional\" parameter as \"list of\nint\"?\n\nThe \"default\" should be the first value that's not None.\nIt's the Pythonic way.\n\nThere is no such rule in Python.\n\nIt's an informal rule, but it's a very good one.\n\n\"The Pythonic way\" is not an informal rule. It's a _proposed", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if type(value) is int:\n          return value\n    return values", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.is_integer:\n          return values.get(value)\n    return values\n\nWow, this is like Ruby's Enumerable.\n\nI think there is an obvious difference between:\nfilter_integers(['a', 3.14, 5]) filter_integers(['a', 3.14, 5])\nand\nfilter_integers(['a', 3.14, 5]) filter_integers(['a', 3.14])\n\nYeah, but it's a very small one.\n\n\"filter_integers(['a', 3.14, 5]) filter_integers(['a', 3.14, 5])\"\n\"filter_integers(['a', 3.14, 5]) filter_integers(['a', 3.14])\"\n\nI still can't get over the fact that Python has a \"list\" of any type.\n\nSo does Ruby.\n\nSo does Perl.\n\nThe difference is that Perl has _numeric_ lists of any type, not _lists_ of any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x > 0)\n\nI know, I know, I know...\n\n>>> filter_integers(['a', 3.14, 5])\n[5]\n>>> filter_integers([1, 2, 3, 'abc', {}, []])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in?\nNameError: global name 'filter_integers' is not defined\n\nChanged:\n\n>>> filter_integers(['a', 3.14, 5])\n[5]\n>>> filter_integers([1, 2, 3, 'abc', {}, []])\n['abc', 2, 3]\n\nstill not working.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x.is_int)", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values.filter(any('int', isinstance(x, int))).take(5)</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(x => x >= 1)\n\nThere's also the built-in list.filter for that:\n>>> filter(x: [1, 2, 3], y: [3, 4, 5]) # [1, 2, 3]\nI like the built-in version because it provides a description of what it does: \"filter (lambda x: x >= 1, y: y)\"\n\nRight, but that's a fairly advanced Pythonic construct. A lot of people use the built-in functions but aren't comfortable with lambdas.\n\nIt is not a very advanced construct, it is just a function that takes two arguments.\n\nI'm not sure you understood the parent comment correctly. You're right that it's not advanced at all, but there's a lot of people who wouldn't understand what the lambda function is or how to use it.\n\npython is a great language, but for beginners it's probably the worst choice to get started with programming.\nI see python as a tool for very experienced programmers (people that know the language very well, like python for its syntax, are very familiar with the standard libraries and so on).\nIt's not a", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if values.has_key('a') and values[0].is_int():\n        return values\n\nThis should be better:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for v in values:\n       if type(v) is List[int]:\n         return values\n    return []\n\nany idea why they included Any in there?</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    result = []\n    for i, value in enumerate(values):\n        if value == int(value):\n            result.append(value)\n    return result\n\nHow is this better than just using type annotations?\n\nThe purpose is to allow you to separate the type annotation from the actual implementation.\n\nThanks for the clarification. That makes sense.\n\nHi,\nI'm the author of this library. I'm not sure what the purpose of this library is, as I don't really use Python for anything. So I welcome anyone who has a use case to contact me and tell me what they need it for.\nThanks!\n\nNot sure if you're still around but I have a use case.\nI'm working on a project that has a central repo that has to integrate with several third-party repos that are each using their own formats for data. I was thinking of using a library like yours to convert these formats to my format, but unfortunately the first thing I hit is that it only supports Python objects.\nDoes it support any kind of serialization? If it does, I", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(numeric_types.is_integer)", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    values = values.filter(is_integer).to_list\n\n    return values.filter(is_integer).to_list</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i in values:\n       if i is int:\n          return i\n       else:\n          raise TypeError(\"no integer found\")", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    \"\"\"\n    for value in values:\n        if not isinstance(value, int):\n           continue\n         if value in ['a']:\n            values = filter_integers(values)\n         return values\n\nThat's a very nice example of the kind of code that should be in the Python core.\n\nFrom the title, I thought it was going to be a variant on Haskell's `mapMaybe`/`mapEither` (or any of the other plethora of functions that can be used to map over a monad). I'm not sure what the proper functional terminology is for mapping over a list of tuples (or if that's even possible at all) but the point is, I thought this was going to be a take on that idea.\n\nIt's called filtering a tuple.\n\nor filtering a generator.\n\nI think he means mapping a tuple (like tuples in Ruby or the tuples in Haskell) instead of mapping a list.\n\nThis is very cool.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i in values:\n         if i is None:\n            return values\n         if i is int:\n             return filter(integers, values)\n    return values\n\nfrom typing import List, Any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if values['type'] is List[int]:\n       values = values.filter(v => v['int'])\n    else:\n       values = values.filter(v => v in ['int', 'float','str'])\n    return values</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    for value in values:\n       if value is not None:\n          return value", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if not len(values) == 0:\n        values = [value]\n    else:\n        values = [value]*\n        for v in values:\n           if v not in [2, 3, 4, 5]:\n              v = v - 1\n             else:\n              v = v\n    return [v for v in values if v]</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for x in values:\n       if x is None:\n          return\n       else:\n           x = x.int\n    return x", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 1:\n       return values\n    else:\n       values = values[filter(Any, values) for x in values]\n    return values\n\nI find it interesting that this code has 7 upvotes, but is from 2009.\n\nYeah, I was hoping for some discussion about this.\n\nIt's a common pattern, we just usually write it as", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.is_integer():\n          return value\n    else:\n          pass\n\nNot terribly useful (you can achieve the same thing using the built-in type() method), but very neat.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    list = [None, None, None, None]\n    for value in values:\n        if isinstance(value, int):\n            value = int(value)\n           list.append(value)\n    return list\n\nHow many times do people need to be told that global variables are a bad idea?\n\nI don't think it's bad in this case. It's a useful function that is used a lot.\n\nWhat is the use case where this is \"used a lot\"?\n\nAny function that wants to work on a list of 'any' objects.\n\nI have no idea what is the use case for this, but I do agree that global variables are bad.\nI'm not saying this because it's global, but because of the fact that it's not a function, and it's used as an argument to another function.\nIt would be much better if it was a function, and it wouldn't be global.\n\nIt's a common pattern when working with collections of objects. A common one is to use a set of", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value.isinstance(value, Any) and value.type('int'):\n           value = value.int\n    return value.copy()\n\nThis is absolutely fantastic. I've been doing this sort of thing by hand for a long time, but never really thought of a clean way to express it in python. Thanks.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n        if len(values) >= 2:\n          values = [x for x in values if x % 2]\n\n        if len(values) > 2:\n           return List(filter_integers(values))\n\nThis is one of the most important things I've learned in my career: knowing how to go from a complex solution to a simple one.\n\nOh, man, do I wish I had learned this at the beginning of my career.\n\nIt's sad how far down this is.\n\nIt's not sad, it's just that most people reading this site are Python programmers, so most of us already know this.\n\nOne interesting way to do this is to use the python built in _any_ type.\ne.g:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for val in values:\n       if val is int:\n          return val\n\nNice. I haven't used it, but it looks like a good way to do it.\nMy one nitpick is that I'd use the more standard notation of\nfilter(values, lambda x: x % 2 == 0) to indicate that this is a filter that\nonly returns integers. It's more clear what the function returns.\n\nThanks. I'll update it.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    if len(values) == 1:\n        return values\n    else:\n        return []", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if int(value) is int(int(value)):\n          return value\n    return []</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 1:\n       return values\n    elif len(values) == 2:\n       return [values[0]]\n    else:\n       return None", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x > 0)\n\nThis is a rather contrived example, but it shows off a couple of points:\nFirst, Python's type system is not simply a formality. The return type is stated in the function's name, and there is no implicit type conversion. Also, the example is able to work with a list of Any values because the function takes a list of Any values (which is a valid return type for any function).\nSecond, Python is not a purely functional language. Lists are mutable, and the filter function can change the values passed in. This might seem like a bad thing, but it's actually a very powerful feature. You can use the same variable over and over again in your program, and change it as the need arises. You can also use functions as values, and take advantage of their side effects. For example, the filter function can be made more efficient by using a list comprehension (or a generator expression, depending on your view of the world).\n>>> filter_integers(range(10))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> filter_integers(range(", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return List(filter(any, values))", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(any(isinstance(value, int))\n\nThis example is silly. It is really more like:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 1:\n        return values\n    for value in values:\n        if value.is_int:\n            continue\n        else:\n            return None\n\nAt least this one is easy to explain. \"It only works on lists of integers, and that's a list of any values\".\n\nThere is also \n\nI was just thinking about this last night. I wanted to find all the items in a dictionary that were a string.\nSo here's what I came up with:\nfrom typing import List, Any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values.filter(lambda x: x[0] > 0)\n\nPEP 249[1] is concerned with this.\n[1]:\n\nI think this is missing the point of the PEP. The proposed syntax would allow:\nfilter_integers(['a', 3.14, 5])\nIt would not allow:\nfilter_integers(['a', 3.14, 5, 'abc', {}, []])\nThe latter is what the PEP is concerned with.\n\nI agree with you. And the latter is _especially_ what Python needs right now, because the current syntax for list comprehensions is so ugly.\n\nExactly. The current syntax is so ugly that a lot of people would prefer to use \"for\" instead of \"if\".\n\nAs a Java programmer, I would much rather use a for statement than a list comprehension, since I'm used to it and it's more readable.\n\nPython 2.5 and newer have a for comprehension syntax:\nfor x in y:\n...\nyield x\n\nBut that doesn't have the same syntactic sugar as list comprehensions, e.g.\nfor x in (1,", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    return values.any(isinstance(value, int))", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) > 1:\n        values = [None, None,..., None]\n\n    return values\nI am not sure if I like this code. It does not use any list comprehension, but it uses the \"filter\" method to loop over the values and then return the list of integers. Maybe it is a matter of taste, but I would have preferred to see this:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(isinstance(value, int))\n    @filter_integers\n    def filter_numbers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for numbers\n    >>> filter_numbers(['a', 3.14, 5])\n    [5]\n    >>> filter_numbers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    return values.filter(isinstance(value, int))\n\nThis looks pretty sweet!\n\nIt's a Pythonic solution to a common problem.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values if len(values) == 0\n    else:\n       val = values[0]\n       return values if val == 1\n    else:\n       if not(val in values) and len(values):\n          return values\n       return []\n\nNot sure what this has to do with anything?</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    return values.filter(any(isinstance(value, int) for value in values))\n\n    def isinstance(value, int):\n    \"\"\" Check if given value is an integer\n    >>> isinstance(4, int)\n    True\n    >>> isinstance(None, int)\n    False\n    >>> isinstance(3, int)\n    True\n    \"\"\"\n\n    return int(value) == value\n\n    print isinstance(filter_integers([1, 2, 3, 'abc', {}, []]), int)\n\n    for item in filter_integers([1, 2, 3, 'abc', {}, []]):\n\n        print \" \".join(item)\n\n        print isinstance(item, int)</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = list(map(int, values))\n    return values\n\nIf you don't want to use list() as a generator:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return sorted(values.items(), key=lambda x: x[0])\n\nPython 3.0.1 (r271:60911, Oct 30 2008, 20:21:57)\n[GCC 4.0.1 20080820 (Red Hat 4.0.1-4)]\nOn amd64\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> filter_integers([1, 2, 3, 'abc', {}, []])\n[1, 2, 3]\n>>> filter_integers(['a', 3.14, 5])\n[5]\n>>> filter_integers(['a', 3.14, 5, 'b'])\n[5, 5]\n>>> filter_integers(['a', 3.14, 5, 'b', 'c'])\n[5, 5, 5]\n>>> filter_integers(['a', 3.14, 5, 'b', 'c', 'd'])\n[5, 5, 5, 5]\n>>> filter_integers(['a', 3.14, 5, 'b', 'c", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values.filter(lambda value: value >= 0)\n\nI'm not sure how this is better than:\n[x for x in list if x % 2 == 0]\nAlso, you can use \"any\" as a key and \"any\" as a value (though you might not want to):\n>>> [1,2,3,1,2,3,1,2,3]\n[1,2,3]\n>>> [1,2,3] | [1,2,3]\n[1,2,3]\n\nI think the trick is that you can use it to filter any type of object.\n\nand:\n[x for x in list if x % 2 == 0] doesn't allow None values.\n\nNo, it does. It's just that none is not an integer.\n\nThis is the better alternative:\n>>> def filter_integers(values):\n...    return lambda x: int(x) == 0, None\n...    return values\n...    >>> filter_integers([1,2,3,1,2,3,1,2,3])\n[1", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    n = len(values)\n\n    for value in values:\n       if value is not None and value is int:\n          return list(n + 1)\n\nNice, but why not use type annotations instead?\n\nIn python?\n\nYou can use annotations in Python.\n\nIn python3?\n\nSure.\n\nI'm not quite sure how this relates to the blog post.\n\nI think he was refering to the fact that the example uses the underscore and the @ syntax.\n\nI think that's a bit of a stretch. A lot of examples from the standard library use those same two features.\n\nI see this stuff and think, \"yeah, but you have to write the code to do the type inference\". That's an extra layer of complexity.\nI don't have to write code to do the type inference in Java. I can just say \"this variable is an int\", and it's just like that. I don't have to think about it.\n\n1\\. You don't have to write the type inference code. The type inference code is written for you, by the compiler.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is int:\n          return values\n\nReplace \"Any\" with \"AnyType\" and the article becomes instantly relevant.\n\nFrom:\n\nFrom:\n\nIn python, an object is actually a class, a list is a class, a tuple is a class.\nWhy do you need to import anything?\n\nYou need to import the types you want to operate on. This is more like \"from numbers import integer\" than \"import list.\"\n\nYes. This is more in line with how most other programming languages work, actually.\n\nExactly. I like Python because it seems to be the only mainstream language that doesn't do this.\n\nAny specific reason for that?\n\nIt's shorter.\n\n\"The Zen of Python\", p. 14:\n_\"Python makes it easy to write programs that look like English. One of the\npowers of English is that you can say things in a natural way that other people\nwill understand. This makes programs easier to read and understand.\nBy following the Zen of Python, you will make your programs more natural and easier to understand", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    filtered = []\n    for value in values:\n       if value is int:\n          filtered.append(value)\n    return filtered\nI don't understand why you're using the Any type.\n\nI wrote that code a while ago. I think I wanted to use Any as an arbitrary type. I think it was supposed to be for user input, but I didn't bother to change the name to \"input\". I agree, the type should be something more descriptive.\n\nIs this like the equivalent of Python's map() method?\nmap(lambda x: x + 1, [1, 2, 3]) => [2, 3, 4]\n\nYes, but I wanted to implement it myself so I could learn how to do it.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is int:\n          yield value\n    return List()\n\nThis is a toy example, but it demonstrates the point, and does so in a style that is easy to understand and extend.\nYou can do similar tricks with classes as well:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(lambda x: x.__class__.__name__ == 'int')\n\nOh, I love Python.\n\nThis is the same as the Haskell approach from yesterday, which is very elegant. The Haskell way is more compact, though, as it does not have to explicitly mention the return type, and doesn't need to define the empty function.\n\nI like Python's decorator style over Haskell's do-notation.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for item in values:\n       if item[0] == '0':\n         return list(item)\n\nnumpy has a really nice _any_type type that wraps a dict. It's really useful when you want a function that accepts a dict of arbitrary types and provides another dict of the same types.\n\nI thought of that after I posted. Maybe there's a way to do it in python?\n\nYou can add a type annotation to the function's arguments, but it would be a bit unwieldy in this example.\n\nThis is nice, but I like to keep a separation of concerns between operations and types.\nSo, instead of\nfrom typing import List, Any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i in values:\n        if i in [1, 2, 3]:\n           return values\n    else:\n            return None\n\nThis is what I've been using:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    for val in values:\n        if isinstance(val, int):\n           return val\n    return List()\n\nPretty cool, but now you can't do that kind of thing without importing the\nList class. Maybe make it something like:"]]