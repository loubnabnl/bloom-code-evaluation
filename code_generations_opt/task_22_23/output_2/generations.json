[["from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is int:\n          return values[value]\n    return values\n\nI'm not sure why this is on the front page. It's just a simple filter that is a little bit more readable than the equivalent builtin.\n\nI'm not sure why you're not sure why it's on the front page. I thought it was a pretty interesting demonstration of the power of Python's type system, and I had never seen this particular example before.\n\nI'm not sure why you're not sure why I'm not sure why it's on the front page.\n\nI'm not sure why you're not sure why he's not sure why it's on the front page.\n\nI'm not sure why you're not sure why he's not sure why you're not sure why it's on the front page.\n\nI'm not sure why you're not sure why he's not sure why you're not sure why it's on the front page.\n\nI'm not sure why you're not sure why he's not sure why you're not sure why it's on the front page.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value.is_integer:\n            value = value.int\n    return values", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value.is_integer:\n           return value\n\nNot sure what you're trying to demonstrate, but it's not clear what you're trying to do.\n\nI think he's trying to demonstrate that this code is broken, and he's right.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for item in values:\n       if item is not None:\n         return item\n    return []\n\n_List, Any is a nice idea, but it has a flaw: it doesn't take advantage of Python's type system. If you try to add a string to a list of integers, you get an error. If you try to add a list of integers to a list of strings, you get an error. If you try to add a list of integers to a list of lists, you get an error. If you try to add a list of integers to a list of tuples, you get an error. If you try to add a list of integers to a list of lists of tuples, you get an error.\nBut if you try to add a list of integers to a list of integers, you don't get an error.\nSo, you have to add an error-handling mechanism to the type system. You could say that any time you try to add a type to a type, and the types don't match, you get an error. But that's not the way Python works. Instead, you have to add a type", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 1:\n       return values\n    return filter(lambda x: x.is_integer, values)\n\nI love this one:\nfrom typing import List, Any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(lambda x: x < 0)\n\nWow, I had no idea that list comprehensions worked on any types. I knew you could do it with tuples, but I didn't know you could do it with arbitrary types.\n\nIt's a new feature.\n\nThat's awesome.\n\nI'm sure that's going to be useful for a lot of people.\n\nI'm sure that's going to be useful for a lot of people.\n\nI'm sure that's going to be useful for a lot of people.\n\nI'm sure that's going to be useful for a lot of people.\n\nI'm sure that's going to be useful for a lot of people.\n\nI'm sure that's going to be useful for a lot of people.\n\nI'm sure that's going to be useful for a lot of people.\n\nI'm sure that's going to be useful for a lot of people.\n\nI'm sure that's going to be useful for a lot of people.\n\nI'm sure that's going to be useful for a lot of people.\n\nI'm sure that's going to be useful for a lot of", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for x in values:\n        if x.isdigit() and x.is_integer():\n           values.remove(x)\n    return values\n\nI have to say that this is a pretty clever way to do it.\n\nI don't get it. It's a way to do what?\n\nIt's a way to take a list of values and filter out any that are not integers.\n\nAh, ok. I didn't know that.\n\nThis is a really clever solution, but it's also a little sad that Python doesn't have a built-in function for this.\n\nIt does, it's called isinstance.\n\nAnd isinstance is a pain to use. I'd much rather have a function that took a list of types and a list of values.\n\nThat's the problem with Python's OOP model. The language is designed to support it, but the standard library is not.\n\nThis is not an OOP issue, it's a design issue.\n\nI'm not sure that it is. In Java, for example, you have all of the features", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value in [1, 2, 3]:\n          return values\n       else:\n          return None\n\nI don't get it. I think this is a joke.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x % 2 == 0)\n\nNice. Is there a library that implements this?\n\nThe standard library has it, in the itertools module:\n>>> from itertools import filter\n>>> filter([1, 2, 3, 'abc', {}, [], [])\n[1, 2, 3]\n>>> filter([1, 2, 3, 'abc', {}, [], [], None])\n[None, None, None]\n\nI like the idea of a \"one-liner\" that is actually a complete program.\n\nI'm going to write a one-liner that does this:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(value)\n\nHow is this any better than the builtin filter function?\n\nI don't know. That's why I posted it.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = []\n    for value in values:\n       if value not in [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100]:\n           values.append(value)\n    return values\n\nNice", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    if values[0] == '0':\n        return values\n    else:\n        return filter_integers(values[0:])\n\nNote that you can just write \"filter_integers(['a', 3.14, 5])\" to get the same result.\n\nTrue. I just wanted to show an example of using the Any type.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i in values:\n       if values[i] is int:\n          return values[i]\n    return List(None)\n\nI don't know why you got downvoted, this is a great example of the power of the type system.\n\nI think it's a great example of how not to use it.\n\nWhy not? It's a simple example of a non-obvious use of the type system to solve a problem.\n\nI think the problem is that it's not a very good example.\nThe filter_integers function does nothing but check if the argument is an integer, then return it if it is. If the argument is not an integer, it returns nothing.\nThat's it.\n\nIt's a great example, just not a very good one.\n\nI'm not sure I understand the distinction.\n\nThe distinction is that it's a great example of using the type system to solve a problem, but it's not a very good example of why you might want to use the type system to solve a problem.\n\nIf you are interested in a language that has a", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if values:\n        return values\n    else:\n        return [int(values[0]), int(values[1])]\n\nWow, the Python syntax is really powerful.\n\nI can't tell if you're being sarcastic, but I think this is a cool example.\n\nNot at all. I was genuinely impressed.\n\nI like the idea, but I'm not sure I'd want to use it. The only reason to use it is if I wanted to do something like this:\n>>> filter_integers([1, 2, 3, 'abc', {}, []])\n[1, 2, 3]\n>>> filter_integers([1, 2, 3])\n[1, 2]\nI'm not sure I'd want to do that.\n\nI don't think it's meant for that kind of use case. It's more for:\n>>> filter_integers(['a', 3.14, 5])\n[5]\n>>> filter_integers(['a', 3.14, 5, 'b', {}, []])\n[5, 3.14", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    return values.filter(lambda x: x.is_int)\n\nThis is not the same as the 'filter' builtin function, but it's close enough that I can't think of a real use case for it.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for x in values:\n       if x is None:\n         return None\n       if x is List(x):\n          return x\n    return values\n\nI'm not sure what this is supposed to do, but it's not working for me.\n\nIt's a joke about how Python's type system is broken.\n\nI got the joke, but it's not a very good one.\n\nI think it's great.\n\nI think it's lame.\n\nI think it's a good joke, but I'm not sure I would call it pythonic.\n\nI think it's a good joke, but it's not pythonic.\n\nI think it's lame.\n\nI think it's lame.\n\nI think it's lame.\n\nI think it's lame.\n\nI think it's lame.\n\nI think it's lame.\n\nI think it's lame.\n\nI think it's lame.\n\nI think it's lame.\n\nI think it's lame.\n\nI think it", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value.is_integer():\n           return value\n    return values\n\nI've always wondered about the use of list comprehension syntax in Python.\nIt seems to me like it's a kind of a poor man's Lisp.\n\nI don't know Lisp, but I do know Python. Can you give an example of how this is like Lisp?\n\nThis is not exactly like Lisp, but it is similar to the way Lisp deals with lists:\n(filter (lambda (x) (not (number? x))) (list 1 2 3))\nLisp's syntax is more flexible, however, since you can use any arbitrary function as a filter.\n\nThat's an excellent example. Thanks.\n\nI've never understood the appeal of list comprehensions. The syntax is not that different from a for loop. The only thing I see is that it's a little easier to read (for me).\n\nThe only thing I can see is that it's a little easier to read (for me).\nI have the opposite problem. I find it much harder to read. I'm", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is int:\n          return value\n    return List()\n\nI don't understand why you're using the Any type. It seems like you could have a single function that takes a list of values, and returns a list of those values filtered to be integers.\n\nThe idea is to use the type system to enforce type safety. If you are filtering integers, you don't want to end up with a list of None.\n\nI'm not sure that's the right way to enforce type safety. It seems like it's a lot easier to just write a test that verifies that the return value is an integer.\n\nI don't think you understand the concept of type safety.\n\nI think I do. I just don't think that it's necessary to use a type system to enforce it.\n\nIf you're going to use a type system, why not use it to enforce it?\n\nI'm not saying that you shouldn't use a type system. I'm saying that you don't have to use a type system to enforce type safety.\n\nBut why not?", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(value => value % 2 == 0)\n\nI think it should be:\nreturn values.filter(value => value % 2 == 0)\n\nThat's the Python 2.x way of doing it. The Python 3.x way is:\nreturn values.filter(value => value % 2 == 0)\n\nAnd the Python 2.x way is the better way.\n\nNot sure what you mean by better. I'm not a huge fan of implicit conversions and I don't see any reason why you would want to return a list of integers from a function that was passed a list of any type.\n\nI think it's better because it's more explicit.\n\nThat's not a good reason to prefer it.\n\nThe article is not about the code, but about the philosophy behind it.\n\nI'm not sure what you mean. The article is about the code in the first part and about the philosophy in the second part. The code is directly related to the philosophy.\n\nI don't see how. The code is only there to illustrate the point, not to be a good example of it.\n\nI think the article is trying to say that the", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i, value in enumerate(values):\n        if value.is_integer:\n           return values.get(i)\n    return values\n\nI'm not sure what the point of this is. If you want a list of integers, you can just do:\n>>> values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n>>> print(filter(None, values))\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n\nTrue, but it's a bit of an obscure idiom, and the syntax is a bit ugly, too.\nAlso, I believe that in Python 3.0 you'll have to use a filter that takes a list, not a tuple.\n\nI don't think the syntax is ugly, but to each their own.\n\nI'm not sure I understand the point of", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(any(isinstance(value, int))).values()\n\nI'm not sure that this is any better than the built-in `list(filter(lambda x: x > 0, list))`.\n\nIt's not, but I think it's a nice example of how to use the \"type\" keyword in Python.\n\nOh, yes, I agree.\n\nA more idiomatic way to do this would be to use the built-in list comprehension syntax:\nfilter_integers = [x for x in values if x > 0]\n\nNo, not really.\n\nYes, really.\n\nI don't know why this got downvoted, but it's true. The list comprehension syntax is very idiomatic in Python, and the built-in filter() function does not actually implement the filter() function.\n\nI think it was downvoted because it's not very nice.\n\nThis is great. I've been looking for a way to get the type of a list of Any.\n\nI've been wanting to do this for ages, but I've never got around to it. Good job!\n\nThis is really cool.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if type(value) is int:\n          return list(int(value))\n    return list(values)\n\nThat's quite useful. Thanks.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(lambda x: x.is_integer())\n\nThis is nice, but it's not quite right.\n\nI'm a little confused about what the point of this is. I'm a little\nfamiliar with Python, but I'm not sure what the difference is between\nthis and:\nfilter_integers = lambda x: x.is_integer\nfilter_integers(list_of_integers)\n\nI'm not sure what you're confused about. I think the point is that\nit's a one-liner.\n\nPython has a built-in function filter, which is a one-liner that does\nthe same thing.\n\nfilter_integers = lambda x: x.is_integer\nfilter_integers(list_of_integers)\n\nAs I said, the difference is that it's a one-liner.\n\nI'm not sure I understand what you mean by that.\n\nThis is a one-liner:\nfilter_integers = lambda x: x.is_integer\nThis is not a one-liner:\nfilter_integers = lambda x: filter(lambda x: x.is", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for item in values:\n       if item == int:\n          return item\n    return values\n\nI'm not sure if this is a good example of the power of Python, or a sign of the language's weaknesses.\n\nIt's a good example of the power of Python.\nPython is a dynamic language, so you can create new types at run time and use them in a function.\nIn fact, it's so powerful that you can even create new functions at run time.\n>>> def hello():\n    print 'Hello, world!'\n>>> hello()\nHello, world!\n>>>\n\nYou can do that in C too, you just have to define a function prototype, and use it as a pointer to the function you're creating.\n\nI'm not sure if that's true, though. You can do it in C++, but not C.\n\nYou can do it in C. I just tested it.\n\nI think he means that you can't do it without defining a function prototype.\n\nThat's true. I misunderstood what he meant.\n\nI wonder if it would be", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is int:\n          return list(value)\n    else:\n          return None\n\nThat's a very interesting approach.\nI wonder how this would compare to a regular expression:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 0:\n        return []\n    for x in values:\n        if x is not None and x in ['0', '1', '2', '3', '4', '5']:\n           return x\n    return []\n\nThis is a bit of a hack, but it works.\n\nIt's not a hack. It's a bug.\n\nIt's a feature.\n\nIt's not a feature. It's a bug.\n\nIt's a feature.\n\nIt's not a feature. It's a bug.\n\nIt's a feature.\n\nIt's not a feature. It's a bug.\n\nIt's a feature.\n\nIt's not a feature. It's a bug.\n\nIt's a feature.\n\nIt's not a feature. It's a bug.\n\nIt's a feature.\n\nIt's not a feature. It's a bug.\n\nIt's a feature.\n\nIt's not a feature. It's a bug.\n\nIt's", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) > 1:\n       return values\n    else:\n       values = []\n       for value in values:\n          if value is not None:\n             values.append(value)\n             value = Any()\n    return values\n\nI know this is a joke, but I've always wondered why the standard library doesn't have a filter() function that works on any iterable.\n\nBecause it's too simple?\n\nfilter() is too simple?\n\nYes. It's just a filter function. It's not something that should be in the standard library.\n\nI don't think it's just a filter function. It's a filter function with a default value.\n\nI'm still not convinced that something like that is something the standard library should be concerned with.\n\nI can't wait until the day when python finally gets a proper built-in, recursive sort.\n\nWhat's wrong with sorted()?\n\nNothing", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if isinstance(value, int):\n          values = values.filter(value)\n    return values\n\nNice!\n\nThanks, I'm glad you like it.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is List(int):\n         return value\n      else:\n         return []", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(isinstance(value, int))\n    return values", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(is_integer)\n    return values\n\nThis is a great example of a common anti-pattern. The filter function is not actually doing anything. It is just a wrapper around the list comprehension.\nThe filter function is not reusable, because the list comprehension is not reusable.\n\nIt is a great example of a common anti-pattern if you're writing a library, but not if you're writing a function.\n\nThe first time I saw this pattern was in a library. It was a simple library that did some very simple things, so it was an easy pattern to spot. It was a small library, so I was able to change it to use a list comprehension.\nThe library was a fork of the standard library, so I submitted a patch.\nThe library was not a large library, so I was able to make a change.\nIf the library had been larger, the anti-pattern would have been more difficult to spot.\nIf the library had been larger, the anti-pattern would have been more difficult to change.\nIf the library had been larger, the anti-pattern would have been more difficult to fix.\nIf the library had been larger, the", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is int:\n          values.append(value)\n    return values", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for v in values:\n       if v.is_integer():\n          v\n      else:\n          raise ValueError(\"%r is not an integer\" % v)\n\nI'm not sure I understand the use case.\n\nThis is a common idiom in functional languages. It's a way of using the filter function to convert an arbitrary list of values to a list of values of a specific type.\n\n\"Functional\" in the sense of \"functional programming\", or in the sense of \"functional programming language\"?\nI would think that \"functional programming language\" would be the only place where this is common.\n\nThe latter, I would imagine.\n\nThat's what I figured.\n\nI'm not sure I get it. It's a filter function with a default value of None?\n\nIt's a filter function that takes a list of values of any type and returns a list of values of a specific type.\n\nWhat's the point of that? Why not just use a for loop?\n\nA for loop would be a filter function with a default", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i in values:\n       if i is not None:\n          return i", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if values is not None:\n       values = values.pop(0)\n       return values.filter(x for x in values if x.is_integer)\n\nWhy not just use the built-in `int` type?\n\nI think this is a good question.\n\nBecause int is a type and not a value.\n\nI think you're being downvoted because you're not being clear about what you mean. Are you saying that it's not possible to use `int` as a value? Because if so, you're wrong.\n\nYes, it is possible to use int as a value. However, in this case, the value is a list of ints.\n\nI don't understand. What's the difference between a list of ints and an int?\n\nlist is a type, and int is a value.\n\nThere's no reason to use this function. It's just as easy to use int() or float() or whatever.\n\nI'm not sure I agree.\n\nWhy not?\n\nBecause you don't need to use the built-in int() or float() to do this", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if values:\n        for item in values:\n           if item is List[int]:\n               return item\n          else:\n                raise ValueError\n\nI'm not sure what this is doing, but it's not filtering integers. It's\nfiltering lists of integers.\n\nThat's why it's called filter_integers and not filter_lists.\n\nIt's also called filter_integers, not filter_lists.\n\nJust for fun, I tried to convert this to Ruby.\nrequire 'types'", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.is_integer:\n           values.remove(value)\n    return values", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for x in values:\n       if x is int:\n          return x\n    return List()\n\nI'm not sure I like the \"Any\" type, I don't think it's necessary.\n\nI don't see the point of the \"Any\" type.\n\nYou're right. I forgot to mention it in the post, but the Any type is just for the example. I'm using Any to represent a Python value that can be anything, like a list, string, float, etc.\n\nJust use AnyList.\n\nI'm not sure what you mean. AnyList is a list of Python values, not a list of any Python values.\n\nYou can do this with a list comprehension.\nfrom typing import List", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(Any(value > 0)).to_list\n\nI'm not sure that's any better.\n\nWhat's wrong with it?\n\nI'm not sure it's _better_, but it's certainly more readable.\n\nIt's not more readable. It's more verbose.\n\nI think it is, because it makes it clear what the filter is doing.\n\nI don't know python but I think that the list comprehension is equivalent to:\nfilter_integers(values).filter(Any(value > 0))\nso it's not really more readable.\n\nNo, it isn't.\nfilter_integers(values).filter(Any(value > 0))\nis equivalent to\nfilter_integers(values).filter(lambda x: x > 0)\nThe first one is a list comprehension, the second one is a lambda expression.\n\nIt's a list comprehension, but it doesn't use the list comprehension syntax. It's equivalent to:\nfilter_integers(values).filter(lambda x: x > 0)\n\nHow is this any better than:\nfrom typing import List, Any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value.is_integer:\n           values.remove(value)\n    return values</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if values:\n        values = [value for value in values if value.is_int()]\n    return values\n\nThis isn't really \"imports\" in the sense of Python. It's just a function that takes a list of things and returns a list of a different thing.\nI think the real lesson to take from this is that you shouldn't worry too much about the specific syntax of your programming language.\n\nI agree that the syntax isn't important. However, I think that the syntax of a programming language can make it easier to read the code. In this case, the code is easier to read if it is written in Python.\n\nI don't think that's true, though. The syntax of a programming language is a barrier to entry, and thus a barrier to understanding. It's a barrier that must be overcome.\nI also don't see how the syntax of Python makes this code any easier to read than the syntax of JavaScript, or the syntax of C, or the syntax of any other language.\n\nI agree that the syntax of a programming language can be a barrier to entry. However, I disagree with the statement that the syntax of a", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is not None:\n         return value\n\nfrom typing import List, Any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for item in values:\n       if item is not None:\n          return item\n    return values\n\nI think this is a good example of why the type system should be as strong as possible.\n\nI think this is a good example of why the type system should be as weak as possible.\n\nI think this is a good example of why the type system should be as strong as possible and why it should be optional.\n\nI think this is a good example of why the type system should be as weak as possible and why it should be mandatory.\n\nI think this is a good example of why the type system should be as weak as possible and why it should be optional and why it should be mandatory and why it should be strong.\n\nI think this is a good example of why the type system should be as weak as possible and why it should be mandatory and why it should be weak and why it should be optional.\n\nI think this is a good example of why the type system should be as weak as possible and why it should be mandatory and why it should be optional and why it should be strong and why it should", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for x in values:\n       if x is None or not x.is_int():\n          continue\n       if x.is_number and x > 0:\n           values.remove(x)\n    return values", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = []\n    for value in values:\n       if value is int:\n          values.append(value)\n    return values\n\nIt's not so much that I'm afraid to type the more explicit version. It's just that I don't see any reason to.\n\nI guess I'm just not used to it. I'm not a python programmer.\n\nI'm not a python programmer either, but I do use it, and I don't like the explicit version, either.\nI know that I'm going to get downvoted for this, but I think that python is a language that's great for beginners, but I don't think that it's great for experienced programmers.\n\nI'm not sure I agree with you, but I do think that Python is a language that's great for beginners _and_ experienced programmers.\n\nI'm just starting to learn Python, so I'm not a Python programmer.\nI don't think the implicit version is a problem, it's just a different way of doing it. I could see it being a problem if the list was being used as a list of", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value not in [0, 1, 2, 3]:\n          return [value]\n\nI don't get it. What's the point of this?\n\nIt's a joke about how many Python programmers don't understand the type system.\n\nYou could do this in a more readable way with:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value == int(value) or value == float(value):\n          return values\n    return values\n\nI'm not sure what the point of this post is.\n\nI think it's meant to be a joke, since the code is so trivial.\n\nExactly.\n\nI think this is a good example of \"code golf\", but the joke is a little hard to get.\n\nIt's not a joke.\n\nThis is a good example of why code golf is an exercise in absurdity.\n\nI think it's a good example of why code golf is an exercise in concision, not absurdity.\n\nI think it's a good example of why code golf is an exercise in absurdity.\n\nI think it's a good example of why code golf is an exercise in concision, not absurdity.\n\nI think it's a good example of why code golf is an exercise in absurdity.\n\nI think it's a good example of why code golf is an exercise in concision, not absurdity.\n\nI think it's a good example of why code golf is an", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) > 1:\n        return values\n    if values:\n        return filter_integers(values)\n    return []\n\nI've always been a fan of this one:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if type(value) is int:\n          return value\n\nI'm not sure what's going on here. I think the author is saying that the type of value is int, so it should be passed into the function as an int. But the type of value is Any, not int. So the author is just filtering out the Any values.\n\nYou're correct, it's a typo.\n\nI think that's a typo: it should be 'Any', not 'int'.\n\nThat's correct, it's a typo.\n\nI'm not sure what's going on here. I think the author is saying that the type of value is int, so it should be passed into the function as an int. But the type of value is Any, not int. So the author is just filtering out the Any values.\n\nYou're correct, it's a typo.\n\nI think that's a typo: it should be 'Any', not 'int'.\n\nThat's correct, it's a typo.\n\nI'm not sure what's going on here. I think the author is saying", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(lambda x: x%2 == 0)\n    return values\n\nThat's not really a good example. For one thing, the list comprehension syntax is ugly, and for another, it's not obvious how to write a filter that takes a list of lists.\n\nI think the point is to show that it's trivial to write a function that can filter a list for any type.\n\nThe list comprehension is ugly, but the \"filter\" function is not.\n\nI would say it is, but only because it is so trivial.\n\nIt's trivial, but also short, clear, and readable. I think it's a good example of how you can write code that's both trivial and beautiful at the same time.\n\nI think a good example of this is the way that Python uses the \"else\" keyword. It's a very simple and short way to handle the \"else if\" case.\n\nI like this:\nfrom typing import List, Any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x%2==0)\n\nHow is this Pythonic?</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for item in values:\n        if item is Any:\n           return values\n        else:\n            return values[item]\n\n\"Any\" is a built-in type that means \"anything\".\n\nIn the example, the first argument is the list of things to filter for, and the second argument is the function that filters them.\nThe function takes two arguments, and if the first argument is an \"Any\", it returns the second argument.\nThe second argument is a list of integers, and so the function will only return the integers in the second argument, leaving the \"Any\"s out.\n\nSo, for example, if the list of things to filter for was [1, 2, 3], then the function would return [1, 2, 3], and if the list of integers to filter for was [1, 2, 3, 4], then the function would return [1, 2, 3].\n\nIf you want to filter for all integers, you can just use the built-in integer filter:\n\n>>> filter_integ", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = [Any(x) for x in values if x.isdigit()]\n    return values", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(is_integer)\n\nI think the reason the author wants to use 'Any' is to be able to filter out None.\nI prefer the approach of using a list comprehension and a lambda function.\n\nI am a little confused. What is the difference between filter_integers(['a', 3.14, 5]) and filter_integers(['a', 3.14, 5], is_integer)?\n\nThe difference is that you can use filter_integers(['a', 3.14, 5]) when you have a list of values, and filter_integers(['a', 3.14, 5], is_integer) when you have a function that returns a list of values.\n\nI don't understand. How can a function return a list of values?\n\nYou can use a function as a function argument.\n\nOh, right. I didn't see the comma. Thanks.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value is not None:\n           return value\n\nWhy is this better than:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(isinstance(value, int))", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(any(isinstance(value, int)", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x > 0)\n\nTo be fair, the first example is using the list comprehension syntax.\n\nYou're right, I didn't notice that.\n\nI don't think this is a good example of why one would use the Python type system, because it's so simple to express the same thing without using types.\n\nNot necessarily. It's simple to express it without types in Python, but it's not as concise, which is the point of the article.\n\nThis is the kind of code that makes me wish that Python had a better type system. The example is simple, but it's also trivial to write a version of it that is incorrect.\n\nIt's trivial to write a version of it that is incorrect in any language that doesn't have a type system.\n\nNo, it's trivial to write a version of it that is incorrect in any language that doesn't have a type system _that is as powerful as Python's_.\n\nI'm not sure how the Python type system is more powerful than the type systems of C++, Java, and C#, but whatever.\n\nPython's type system is weaker than C++, Java, and", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value is None:\n           continue\n           if value is int:\n                 value = value * 10\n                 return values\n\nThis is not a very good example.\n\nWhy?\n\nBecause the code is very simple.\nThere are two ways to do this in Python. The first is to use the built-in list type's `is` operator, which is what you do in the example. The second is to use the built-in `str` type's `isalpha` method.\nThe first is shorter and more readable.\n\nI'm pretty sure the second is faster.\n\nI'm pretty sure the second is not faster.\n\nI'm pretty sure that the second is faster.\n\nI'm pretty sure the second is slower.\n\nI'm pretty sure the second is faster.\n\nI'm pretty sure the second is faster.\n\nI'm pretty sure the second", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.isdigit() and value.isnot(0):\n          return values\n\nI'm not sure this is better than just using list comprehensions.\n\nI'm not sure I understand the point of this.\n\nIt's a joke about how some people will try to write a new language in Python.\n\nI've been working on something similar. It's a language that's more concise than Python. It has no syntax, and is purely functional. The language is completely defined in terms of itself. It's called \"Haskell\".\n\nI've been working on something similar. It's a language that's more concise than Python. It has no syntax, and is purely functional. The language is completely defined in terms of itself. It's called \"Lisp\".\n\nI've been working on something similar. It's a language that's more concise than Python. It has no syntax, and is purely functional. The language is completely defined in terms of itself. It's called \"Ruby\".\n\nI've been working on something similar. It's a language that's more concise than Python.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value.isinstance(value, int) and value.isdigit():\n            return values[value]\n    return values\n\nI'm not sure what to think of this.\n\nI think it's pretty cool.\n\nI'm not sure what to think of this.\n\nI think it's pretty cool.\n\nI'm not sure what to think of this.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value == int(value):\n          return values\n\nI'm not sure why people think that this is the right way to do it. It's\nuglier than the original. It's not very clear. And it's a little bit\nless efficient.\n\nIt's not less efficient at all. In fact, it's more efficient in that it\neliminates the need to check if the value is an int at all.\n\nIf you're using the Python interpreter, this is true. If you're using\nCPython, this is false.\n\nI don't know enough about CPython internals to comment, but I do know\nthat the Python interpreter is the only python implementation that matters.\n\nI don't think the Python interpreter is the only implementation that matters.\nFor one, there's the Python that's used in the Jython project.\nFor another, there's the Python that's used in the IronPython project.\n\nYou're right. I should have said that the Python interpreter is the only\npython implementation that matters for python programmers.\n\nI'm not a", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value.__class__ is List[int]:\n           value = value.get(0)\n    return list(value)", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for item in values:\n       if item == None:\n          return values\n       if item is None:\n          return None\n    return values\n\nThe title is a bit misleading. This is not a general-purpose filter but a filter for integers.\n\nThe title is a bit misleading. This is not a general-purpose filter but a filter for integers.\n\nThe title is a bit misleading. This is not a general-purpose filter but a filter for integers.\n\nThe title is a bit misleading. This is not a general-purpose filter but a filter for integers.\n\nThe title is a bit misleading. This is not a general-purpose filter but a filter for integers.\n\nThe title is a bit misleading. This is not a general-purpose filter but a filter for integers.\n\nThe title is a bit misleading. This is not a general-purpose filter but a filter for integers.\n\nThe title is a bit misleading. This is not a general-purpose filter but a filter for integers.\n\nThe title is a bit misleading.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if type(value) == int:\n           return value\n\nThis is not a good example.\n\nIt's a good example of how to write code that works for you.\n\nI think it's a bad example because the code is not idiomatic and is harder to understand.\n\nIt's not idiomatic to use list comprehensions and lambda expressions?\n\nI think he was talking about the filter_integers() function.\n\nI was.\n\nI was just looking at the example and thinking, \"Why would I ever write that?\"\nThen I realized that this was an example of how to write the code that works for you. I'm sure there are times when it would be useful to have a function like that, but I'm not sure when.\n\nIt's useful when you want to do a case-insensitive search for a particular type of value in a list.\n\nI have a function that does this for me:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = []\n    for value in values:\n       if value.is_int() == True:\n          values.append(value)\n    return values\n\nNice. Now you just need to make sure that the string 'abc' doesn't get included in the list.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    for i, value in enumerate(values):\n        if value is int:\n           return values[i]\n\nThis is great. It's so simple and elegant. It's a shame that Python doesn't have built-in support for this.\n\nIt does, you can use 'list(filter(lambda x: x == int, values))'\n\nI'm not sure that's what the GP meant.\n\nI would have thought that the GP meant 'I wish Python had a built-in filter() function'.\n\nYes, that's what I meant. I just wanted a simple way to filter a list of values for a given type.\n\nI know this is a bit of a digression, but I'm curious as to why you didn't just use a list comprehension:\n>>> [1, 2, 3, 'abc', {}, []]\n[1, 2, 3, 'abc', {}, []]\n>>> [1, 2, 3, 'abc', {}, []] | filter(lambda x: x == int, values)\n[1, 2, 3]", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is int:\n          return value\n    return values\n\nI'm not sure what this is supposed to do.\n\nIt's supposed to filter integers only, not strings or booleans.\n\nI'm not sure why you would do this, but it's not a bad idea. I can't think of a good reason to do it though.\n\nIt's useful if you want to do something with only integers.\n\nI'm not sure why you would want to do that, but it's not a bad idea. I can't think of a good reason to do it though.\n\nIt's useful if you want to do something with only integers.\n\nI'm not sure why you would want to do that, but it's not a bad idea. I can't think of a good reason to do it though.\n\nIt's useful if you want to do something with only integers.\n\nI'm not sure why you would want to do that, but it's not a bad idea. I can't think of a good reason to do it though.\n\nIt's", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x.is_int())\n\nI don't understand. This looks like it is doing the same thing as the code in the article.\n\nIt's a joke. I think the author was pointing out that the article's code was so trivial that it could be expressed in a single line.\n\nI don't understand. This looks like it is doing the same thing as the code in the article.\n\nI don't understand. This looks like it is doing the same thing as the code in the article.\n\nI don't understand. This looks like it is doing the same thing as the code in the article.\n\nI don't understand. This looks like it is doing the same thing as the code in the article.\n\nI don't understand. This looks like it is doing the same thing as the code in the article.\n\nI don't understand. This looks like it is doing the same thing as the code in the article.\n\nI don't understand. This looks like it is doing the same thing as the code in the article.\n\nI don't understand. This looks like it is doing the same thing as the code in the article", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) > 0:\n       return values\n    else:\n       return [0]\n\nThis is a very poor example of the use of the type system. The problem with it is that it's trivial to write a function that will do the same thing but will return a different result for a list of strings.\nIf you want to show off the type system, you should show something that is not trivial to write in a more dynamic language.\n\nIt's not a very poor example. It's a great example of how to make a small program with static typing.\n\nIt's a poor example of how to use the type system to write code. It's a great example of how to use the type system to write a test.\n\nI think you're missing the point of the post.\n\nThe problem with static typing is that it's too easy to write trivial programs.\n\nI think you're missing the point of the post.\n\nI think I get the point of the post. The point of the post is to show that it's easy to write trivial programs in a statically typed language.\n\nNo, the", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if not values:\n       return []\n    for x in values:\n       if x.is_integer:\n          values.append(x)\n    return values", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.is_int():\n          return values\n    return None\n\nI don't get it. What's wrong with this?\n\nI think it's because you can't do this:\n>>> filter_integers(['a', 3.14, 5])\n[5]\n\nAh, that makes sense.\n\nI'm not sure I understand the point of this.\n\nThe point is that it is a bad idea to try to make the type system do things that it wasn't designed to do.\n\nI was trying to be clever and avoid using the term \"type system\" in the title.\n\nA more accurate title would be \"from typing import List, Any, and filter\".\n\nYeah, but that's not as interesting.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value is not None:\n           return value\n    return None\n\nfrom typing import List, Any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if not values:\n       return []\n    for value in values:\n       if value is not None:\n          return [value]\n    return []\n\nI'm not a python programmer, but isn't the code above just a list comprehension with an unnecessary if?\n\nThe 'if not values:' clause is necessary to prevent the loop from running on None values.\n\nIt's not necessary, it's just a bad style that people sometimes use.\n\nI disagree, it is necessary. Without it, the loop would be infinite, and it would never terminate.\n\nYou're right. I had to think about it for a while.\n\nThis is not pythonic.\n\nI don't know python, but isn't this just a list comprehension?\n\nIt's a list comprehension with an unnecessary 'if not values:'.\n\nThe 'if not values:' clause is necessary to prevent the loop from running on None values.\n\nIt's not necessary, it's just a bad style that people sometimes use.\n\nI disagree, it is necessary. Without it,", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value.isinstance(int):\n           values.append(value)\n\nThis is the first time I've seen Any used like this. I'm curious to know how it compares to lists of tuples.\n\nYou can also use Any for tuples.\n\nBut you can't use tuples for tuples.\n\nYou can use tuples of tuples, though.\n\nAlso you can use tuples for lists.\n\nYou can use lists of lists for tuples too.\n\nYou can use lists of tuples for lists too.\n\nYou can use lists of lists of tuples for tuples too.\n\nYou can use lists of lists of lists of tuples for tuples too.\n\nYou can use lists of lists of lists of lists of tuples for tuples too.\n\nYou can use lists of lists of lists of lists of lists of tuples for tuples too.\n\nYou can use lists of lists of lists of lists of lists of lists of tuples for tuples too.\n\nYou can use lists of lists of lists of", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.isinstance(value.__class__, Any):\n          return value\n    return None\n\nNice. I didn't know about the Any type.\n\nIt's a very nice type, I find myself using it a lot.\nI use it to represent a value that might be anything. It's a pretty good replacement for None.\n\nAnd for those who don't know:\n>>> from typing import List, Any\n>>> list = [Any]\n>>> print list\n[Any]\n\nI don't know about the Any type, but the list type is pretty cool:\n>>> [1, 2, 3, 4, 5]\n[1, 2, 3, 4, 5]\n>>> [1, 2, 3, 4, 5]\n[1, 2, 3, 4, 5]\n\nThis is a very nice way to write a for loop in python.\n\nI've never seen it before, but I like it.\n\nI use it a lot.\n\nI've used it once, but I like it.\n\nI", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value is int:\n            return value\n    else:\n             return None\n\nI'm not sure if this is better than using the built-in filter function, but it's a lot more readable and understandable than the standard way of doing things.\n\nPython's built-in filter function is very powerful, but it's not very readable. For example, this is a filter for integers:\n>>> filter(lambda x: x % 2 == 0, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20])\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\nIt's much easier to read the code you posted, and it's also more efficient.\n\nThe standard way to do this is:\n>>> [x for x", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.isdigit():\n           return value\n    return values", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    if len(values) == 1:\n        return values\n    for v in values:\n        if v is None:\n           return []\n           return v\n\nI don't get it, what is the advantage of this over just using the built in filter?\n\nI don't get it, what is the advantage of this over just using the built in filter?\n\nIt's a joke.\n\nI know it is, I just don't get the joke.\n\nOh, I see. I thought you were asking seriously.\n\nI don't get it, what is the advantage of this over just using the built in filter?\n\nIt's a joke.\n\nI know it is, I just don't get the joke.\n\nOh, I see. I thought you were asking seriously.\n\nI don't get it, what is the advantage of this over just using the built in filter?\n\nIt's a joke.\n\nI know it is, I just don't get the joke.\n\nOh,", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    if len(values) > 1:\n         return [values[0] for value in values if isinstance(value, int) else None]\n\nI don't get it.\n\nI think it's supposed to be a joke.\n\nI think the joke is that Python's \"from typing import List, Any\" syntax is so verbose that you might as well write a function that does nothing.\n\nI don't get it.\n\nI think the joke is that Python's \"from typing import List, Any\" syntax is so verbose that you might as well write a function that does nothing.\n\nI don't get it.\n\nI think the joke is that Python's \"from typing import List, Any\" syntax is so verbose that you might as well write a function that does nothing.\n\nI don't get it.\n\nI think the joke is that Python's \"from typing import List, Any\" syntax is so verbose that you might as well write a function that does nothing.\n\nI don't get it.\n\nI think the joke is that Python's \"from typing import List, Any\" syntax is so verb", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    return values.filter(lambda x: x.is_integer())\n\nI don't understand why this is a good example of Python's expressiveness.\n\nIt is not.\nIt is an example of a very common mistake: doing a lot of work for no reason.\n\nI don't understand what you mean by \"for no reason.\"\n\nThe example is written to demonstrate that you can use a function as a filter.\nThe problem is that the example shows that you can do it, but it does not show why you would do it.\n\nI'm not sure I follow your reasoning here. I mean, I do understand that you _can_ use a function as a filter, but I don't understand why you think that this is a mistake.\n\nThe problem is that the example shows that you can do it, but it does not show why you would do it.\n\nI'm still not getting it. So you're saying that the example shows that you can use a function as a filter, but not why you would do it. But it seems to me that the example does show why you would do it. It shows that you can filter a list of Any values for integers. What", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for v in values:\n        if v is not None:\n           return v\n    return None", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i in range(len(values)):\n        if values[i] is int:\n            values[i] = values[i] / 1000\n    return values\n\nThat's a pretty clever way to do it. I would've written it as:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value is int:\n            return value\n    return None\n\nThis is a fun example of how Python's type system is very flexible.\nThe author of the code is using the Any type for the values, but if you\nlook at the type of the function you'll see that it returns a List[int].\nThe type of the function is determined by the return type of the last\nexpression in the function body.\n\nThis is a very common mistake that I see in Python code. A lot of the time\nit's because people don't understand what \"type hinting\" is.\n\nFrom the Python documentation:\n\n\"A type hint is a suggestion to the Python interpreter that the type of\nthe argument is one of the types listed in the hint.\n\nNote that a type hint is not a type annotation. An annotation is a\ndeclaration of a type. A type hint is a hint to the interpreter. It is\nnot checked by the compiler. It is the interpreter's responsibility to\ncheck that the type of the argument is one of the types listed in", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 1:\n        return values\n    if len(values) > 1:\n        return filter_integers(values[0])\n    if len(values) < 1:\n        return []\n\nYou may want to note that the first case is probably better written as\nfilter_integers(values)\n\nIt's a perfectly valid Pythonic idiom to use an empty list as a filter.\n\nIt's a perfectly valid idiom to use the empty list as a filter, but it's also perfectly valid to use an empty list as a \"filter\" (as in, a function that takes an input and returns true/false).\n\nIt's not a function though. It's just a statement.\n\nRight, but the original poster asked for a better way to write the first case.\n\nI've been using this for years. It's a bit of a hack, but it works.\n\nIn Python 2.6, you can do:\nfrom typing import List, Any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(any(isinstance(value, int))).sum()\n\nI don't get it. How is that different from just:\nfilter_integers = [x for x in values if x % 2 == 0]\n\nI don't understand why this is on the front page.\n\nBecause it's a joke.\n\nI don't get it. What's the joke?\n\nPython has a built-in filter() function that can be used to filter lists.\nThe joke is that the programmer has reimplemented filter() using an \"import\" statement.\n\nI still don't get it.\n\n\"import\" is a way to call a function from another module. It is similar to a \"require\" in ruby, or a \"require_once\" in perl.\n\nAh. Thank you.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value.is_integer():\n            return value\n    return None", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(lambda x: x > 0).values()\n\nThis is a very, very common idiom.\n\nIs it really idiomatic? I haven't seen it before, but it seems like it should be.\n\nIt's idiomatic in the sense that it's a common pattern. But it's not idiomatic in the sense that it's not a pythonic idiom. The problem is that it relies on a feature that is not a pythonic feature.\n\nIt's a Pythonic idiom, it's just not a Pythonic language feature.\n\nI don't think you can say that. The language doesn't define the idioms, the idioms define the language.\n\nI think that's a bit of a tautology.\n\nNot really. I'm just saying that Python doesn't have an official list of idioms, and it doesn't really matter what the language designers think is an idiomatic way to do something. The community defines the idioms, and the community is free to change their mind whenever they want.\n\nI think this is a good example of why Python is so popular. It has the readability of Ruby with the power of C", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for v in values:\n        if v is int:\n            return v\n    return None\n\nI'm not a Python programmer, but this code looks completely unreadable to me.\n\nI've written a lot of Python, and I still don't understand it.\n\nIt's a list comprehension.\n\nI'm a python programmer, and I still don't understand it.\n\nA list comprehension is a way of expressing a list as a function. You can then pass that function to a filter function, and the filter function will return a new list. The filter function is passed a parameter, which in this case is the original list.\n\nIt's a list comprehension.\n\nI'm a python programmer, and I still don't understand it.\n\nIt's a list comprehension.\n\nI'm a python programmer, and I still don't understand it.\n\nIt's a list comprehension.\n\nI'm a python programmer, and I still don't understand it.\n\nIt's a list comprehension.\n\nI'm a python programmer, and I still don't understand it.\n\nIt", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(value -> value > 0)\n\nThis is the one I use:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if type(value) is int:\n           values.add(value)\n    return values\n\nI've always wondered why this isn't in the standard library.\n\nI've always wondered why you need this.\n\nTo filter out a list of values that have some attribute.\n\nI've always wondered why you need to do that.\n\nTo filter out a list of values that have some attribute.\n\nI've always wondered why you need to do that.\n\nTo filter out a list of values that have some attribute.\n\nI've always wondered why you need to do that.\n\nTo filter out a list of values that have some attribute.\n\nI've always wondered why you need to do that.\n\nTo filter out a list of values that have some attribute.\n\nI've always wondered why you need to do that.\n\nTo filter out a list of values that have some attribute.\n\nI've always wondered why you need to do that.\n\nTo filter out a list of values that have some attribute.\n\nI've always wondered", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(isinstance(value, int))\n\nI'm a bit confused. Is this just a simple typo?\n\nYes. Fixed.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = [Any(int) for int in values]\n    return values</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) > 0:\n        return values\n    for value in values:\n        if value in ('a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w', 'x', 'y', 'z'):\n           return values\n\nA more idiomatic way to do this is to use the filter built-in:\n>>> filter(isinstance(value, int), values)\n[5]\n>>> filter(lambda x: x in int, values)\n[5]\n\nI'd say that the filter built-in is more idiomatic than the list comprehension, since it is a built-in, and list comprehensions are more powerful than built-ins.\n\nI'm not sure how to feel about this.\n\nOne of the things that makes Python beautiful is that it doesn't feel like", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return [int(value) for value in values if value is not None]", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x % 2 == 0)\n\nI think it would be better to use a list comprehension here:\nfilter_integers = [x for x in values if x % 2 == 0]\n\nI'm not sure if I'm missing something, but this is identical to your version.\n\nIt's identical in that it has the same effect, but the comprehension is more readable.\n\nI like this, but I think it's a bit too verbose.\n\nI agree. I think it would be a lot more readable if it was just one line:\nfilter_integers = [x for x in values if x % 2 == 0]\n\nI think it's a bit more readable if you write it in one line, but it's not as readable as the comprehension.\n\nI think this is the best solution, but it's a bit more verbose than I'd like.\n\nI like this, but it's a bit too verbose.\n\nI like this, but it's a bit too verbose.\n\nI like this, but it's a bit too verbose.\n\nI like this, but it's a bit", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is None:\n          return values\n          if value is Any:\n             return list(int(value))\n\nHow is this different from the built-in function _any()_?\n\n_any()_ returns None if the value is None, but returns the value if the value is an object. This is a huge difference if you want to write a generic function that operates on any type of value.\n\nYou can use _any()_ with a list comprehension:\n>>> any(['a', 3.14, 5])\n['a', 3.14]\n\nTrue, but the list comprehension is more verbose than the built in function.\n\nYou can use the built in function with a list comprehension:\n>>> any(['a', 3.14, 5])\n['a', 3.14]\n\nTrue, but the list comprehension is more verbose than the built in function.\n\nNot really, since you can't use list comprehension on a built in function.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is not None:\n          return value\n       else:\n           return None\n\nI'm not sure I get it. What's the point of the last line?\n\nThe last line is to skip the None values.\n\nI don't think this is a good example.\nThe last line is to skip the None values.\n\nI don't think this is a good example.\nThe last line is to skip the None values.\n\nI don't think this is a good example.\nThe last line is to skip the None values.\n\nI don't think this is a good example.\nThe last line is to skip the None values.\n\nI don't think this is a good example.\nThe last line is to skip the None values.\n\nI don't think this is a good example.\nThe last line is to skip the None values.\n\nI don't think this is a good example.\nThe last line is to skip the None values.\n\nI don't think this is", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 0:\n       return values\n    values = values.filter(value=Any, is_integer=True)\n    return values\n\nHow is this any different from the built-in filter?\n\nIt's not. It's a very common idiom in python.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 1:\n        return values\n    for value in values:\n        if value is int:\n           return value\n    return values\n\nThis is a horrible example.\nWhy would you use the built in list type instead of a tuple?\nWhy is the type Any? Why not AnyInt?\nWhy is the function name filter_integers? The function does not filter integers. It filters any value.\n\nI'd say it's a great example. It shows how to use built-in types and functions in a simple way.\n\nIt's a great example of a bad example.\n\nI disagree. The example has the benefit of showing the use of built-in types and functions in a simple way, without introducing a lot of unnecessary complexity.\n\nA simple example that uses built-in types and functions in a simple way would be something like:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(lambdax: int(x))\n\nFor a moment I was confused as to why they were importing the List class, and then I realized that the Any class doesn't exist in Python 2.7.\n\nI'm always a bit confused by this. Why do people use Python 2.7 when 2.6 is still maintained?\n\nBecause Python 2.7 is still maintained.\n\nI'm not sure that's a good reason.\n\nIt is a good reason, because Python 2.7 is still maintained.\n\nThis is really useful, thanks!\n\nI just did this in Ruby:\n\nThat's not really the same thing.\n\nWhy not?\n\nThe Ruby version only filters for integers, not any type.\n\nYou can do the same thing in Python 2.7\n\nI prefer the Ruby version. It's more concise and less code to write.\n\nI prefer the Python version. It's more general and less code to write.\n\nI prefer the Python version. It's more concise and less code to write.\n\nI prefer the Ruby version. It's more concise and less code to write.\n\nI prefer", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value is not None:\n            return value", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value.isdigit():\n            return value\n\nSee also: \n\nIf you're not familiar with it, the point of this is that the syntax is\nmuch nicer than the usual `filter(...)` or `map(...)`.\n\nI would say the syntax is about as nice as the standard list comprehension syntax.\n\nThe syntax is nice. The problem is that it's a solution in search of a problem.\n\nI find list comprehensions to be a bit cumbersome when I have a lot of complex logic. With a for-loop I can just write it down and then run it.\n\nThis is a very useful tool for me. I use it all the time when working with the CouchDB Python API.\n\nI've found the following code to be useful for working with CouchDB.\nfrom functools import partial", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    for item in values:\n       if item is int:\n          return list(int(item))\n    return values", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.is_integer:\n          return list(value)\n    return list(values)\n\nI can't believe this is the first time I've seen this. It's so obvious.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is int:\n          return values[value]\n    return None\n\nI just tried it and it looks like you're missing a case where the value is None.\n\nI'm not sure I follow your comment. The code is supposed to filter the input list for any value that is an integer. If the input value is None, then it's not an integer, so it shouldn't be in the output list.\n\nYou're right, I was thinking of the case where the value is a list.\n\nThis is a pretty neat trick, but it's only useful for certain cases. If you're going to be doing a lot of filtering, it's probably better to just use a class.\n\nI think this is an interesting case where you can do a lot of things with a list that you can't do with a class.\n\nNot sure what you mean. You can do anything with a class that you can do with a list.\n\nNot really.\nLists are not objects, and are mutable.\n\nI'm not sure what you mean. Lists are objects", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values\n\nfrom typing import List, Any\n\n    def filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    return values\n\nI think I have to be missing something here.\n\nThe article is about the Python 2.7 list type, not Python 3.\n\nAh, that explains it. Thanks.\n\nYou have to be a little careful with type hints in Python, because the type hints are actually not type hints. If you try to pass something that is not of the type you hinted at, the program will still run.\n\nI think this is a very good point. I've seen a lot of people use type hints to make their code look cleaner, but that's just a side effect. The type hints are there to ensure that your code does", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is int:\n          values.remove(value)\n    return values\n\nHow is this better than:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    return values.filter(value -> value % 2 == 0)", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is int:\n          return value", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.is_int:\n          values.remove(value)\n    return values\n\nI don't understand the point of the filter_integers function. Could you explain?\n\nIt's a joke.\n\nAh, I got it. Thanks.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.is_integer():\n          values.remove(value)\n    return values\n\nThis is a bad example because it's trivial to write the same function in Python 2.x, without the need for a new language feature.\n\nIt's trivial to write the same function in Python 3.x as well, just with a different syntax.\n\nIt's not just a different syntax, it's a different language.\n\nI don't understand why the author is so eager to use the new syntax, given that it's a new language.\n\nI don't understand why people are so eager to jump on the \"Python 3 is a new language\" bandwagon. It's not.\n\nI have a great idea: let's use a different language.\n\nExcept it's not a different language.\n\nIt's not a different language in the sense that it's not a different syntax for the same language. But it's a different language in the sense that it's a different syntax for a different language.\n\nAnd this is different from how?\n\nFrom Python 2.x,", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(Any(int))</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = []\n    for value in values:\n       if value.isinstance(value, int):\n          values.append(value)\n    return values\n\nI've always wondered why people make these types of comments.\n\nIt's a list comprehension, but it doesn't have a for loop. It's a more concise way of expressing the same thing.\n\nFor a list comprehension, it's not that concise.\n\nIt's a list comprehension that doesn't have a for loop.\n\nI think the point is that it's not very concise compared to a list comprehension with a for loop.\n\nI think the point is that it's not very concise compared to a list comprehension with a for loop.\n\nI think the point is that it's not very concise compared to a list comprehension with a for loop.\n\nI think the point is that it's not very concise compared to a list comprehension with a for loop.\n\nI think the point is that it's not very concise compared to a list comprehension with a for loop.\n\nI think the point is that it's not very concise compared to", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values.filter(isinstance(value, int))\n\nThe code is a little bit more complicated than it could be, because the code is written to make it clear what is going on. If you really need it, you can write it in a much more concise way:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x.is_integer())\n\nI'm not sure what the point is. It's not like you can't do this in Python:\n>>> [1, 2, 3, 'abc', {}, []]\n[1, 2, 3, 'abc', {}, []]\n>>> [1, 2, 3, 'abc', {}, []]\n[1, 2, 3, 'abc', {}, []]\n>>> [1, 2, 3, 'abc', {}, []]\n[1, 2, 3]\n\nWhat about\n>>> [1, 2, 3, 'abc', {}, []]\n[1, 2, 3, 'abc', {}, []]\n>>> [1, 2, 3, 'abc', {}, []]\n[1, 2, 3, 'abc']\n>>> [1, 2, 3, 'abc', {}, []]\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'int' object is not callable\n\nAh, but this is why you don't use the builtin", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is not None:\n           return value\n\nThat's a really nice way to do it.\n\nI'm not sure I understand what's happening in the code.\n\nThe code is a little hard to follow, but the idea is to filter a list of values to only keep those that are integers. The code iterates over the list of values, and checks each value for being None. If a value is not None, then it is kept. Otherwise, it is discarded.\n\nThank you. I understand now.\n\nThis is great, and it would be even better if it were a one-liner.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(is_int)\n\nYou can also use list comprehensions for this:\n[x for x in values if x is_int]\n\nThe real question is why would you want to do this?</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if type(value) == type(int):\n          value = value.int()\n    return values\n\nThis is a great example of the kind of things you can do with Python's dynamic typing.\n\nI don't understand why this is \"great\". It seems to me that the advantage of dynamic typing is that you don't have to write as many types, but this is still pretty verbose.\n\nThe advantage of dynamic typing is that you don't have to write types.\n\nThe advantage of dynamic typing is that you don't have to write types, but you have to write more code.\n\nThis isn't a disadvantage. It's a trade-off.\n\nIt's a disadvantage if you have to write more code to do the same thing.\n\nI'm not sure I understand what you mean by \"same thing\". The same thing to the user is that the program does what they want. The same thing to the programmer is that the program is easy to write.\n\nThe same thing to the programmer is that the program is easy to write, but it's not always the", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is not None:\n          return value\n    return None\n\nThis is also the first thing I thought of. I'm glad I'm not the only one who sees the irony in the post title.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if isinstance(value, int):\n         return value\n\nI'm not sure if this is a joke or not, but I'm pretty sure this is the definition of a list comprehension.\n\nIt's not.\nA list comprehension is a list of expressions that are evaluated in order, like so:\n[x*x for x in range(10)]\n\nI know what a list comprehension is. I was just saying that the filter_integers method looks like a list comprehension. I didn't say that it was one.\n\nThat's not a list comprehension, either. It's a function.\n\nThat's a list comprehension. It's a function that returns a list of integers.\n\nNo, it's a function that takes a list of integers and returns a list of integers.\n\nIt's a list comprehension. It's a function that returns a list of integers.\n\nNo, it's a function that takes a list of integers and returns a list of integers.\n\nIt's a list comprehension. It's a function that returns a list of integers.\n\nNo, it's", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value.isinstance(int):\n           return value\n\nI've been using this for a while, but I think the \"isinstance\" test is a bit fragile. It's not always clear whether a value is an instance of a type. For example,\n>>> filter_integers([1, 2, 3, 'abc', {}, []])\n[1, 2, 3]\n>>> filter_integers(['a', 3.14, 5])\n[5]\n>>> filter_integers(['a', 3.14, 'b', None, 6.33])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'NoneType' object is not callable\n>>> filter_integers(['a', 3.14, 'b', None, 6.33, 'c', None])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'NoneType' object is not callable", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.isinstance(value, Any):\n          return value\n    return None\n\nI think you mean\nfor value in values:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.isinstance(int) and value > 0:\n          return value", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 0:\n       return []\n    for value in values:\n       if value.is_int():\n          return values[value]\n    return []", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if values:\n        values = []\n    for value in values:\n        if value is List[int]:\n           values.append(value)\n    return values\n\n_Why_?\n\nBecause it's a fun exercise in programming, that's why.\n\nThis is a bad idea.\n\nIt's not a bad idea. It's an exercise in programming.\n\nIt's a bad idea because it's an exercise in programming.\n\nIt's a bad idea because it's an exercise in programming that teaches bad programming.\n\nIt's a bad idea because it's an exercise in programming that teaches bad programming that's a bad idea.\n\nIt's a bad idea because it's an exercise in programming that teaches bad programming that's a bad idea that's a bad idea.\n\nIt's a bad idea because it's an exercise in programming that teaches bad programming that's a bad idea that's a bad idea that's a bad idea that's a bad idea.\n\nIt's a bad idea because it's an exercise in programming that teaches bad programming that's", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if type(value) is int:\n           return values[value]\n    return values\n\nThis is useful for the'reverse' function in python, which I think is a bad idea. It's not a function, it's a method, and it's not a method of the iterable, but a method of the object returned by the iterable.\n\nI find that the Python docs are pretty clear about how things are supposed to work:\n\nThat's the first thing I thought of when I saw this submission.\nI'm a bit torn about the usefulness of this article. On the one hand, it's a nice, simple, clear explanation of a useful feature of Python. On the other hand, it's not a Python feature, it's a general programming feature, and the article doesn't really explain _why_ it's useful.\n\nThe \"why\" is that Python's for loops have an implicit \"filter\" built in. This is useful for people who don't understand the difference between a list and a set, and don't realize that Python's list methods are built on", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) > 1:\n        values = values.filter(lambda x: x[0] == int(x))\n    return values\n\nThe more general version of this would be:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 0:\n        return values\n    values = values.filter(value_is_int, not value_is_str)\n    return values\n\nI'd be interested in seeing a version of this that works with tuples, too.\n\nThe author, Guido van Rossum, is the creator of Python.\n\nI know.\n\nThis is a great utility function. I've been using it for a while, but I've\nbeen using it like this:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(any(isinstance(value, int)).sum)\n\nfrom typing import List, Any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 1:\n        return values\n    for x in values:\n        if x is None or not x.is_int():\n            continue\n            return None\n    return values\n\nIt's worth pointing out that this is a trivial example of a filter. A more interesting one is the following:\n>>> filter_integers([1, 2, 3, 'abc', {}, [], 0])\n[2, 3, 'abc']\n\nI've always found the built-in list comprehension syntax for filters to be more readable than the Python way, but I've never seen it used outside of the context of list comprehensions.\n\nI've always found the built-in list comprehension syntax for filters to be more readable than the Python way, but I've never seen it used outside of the context of list comprehensions.\n\nI've always found the built-in list comprehension syntax for filters to be more readable than the Python way, but I've never seen it used outside of the context of", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(value, isinstance(value, int)", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if not values:\n        return []\n    values.filter(isinstance(value, int))\n\nI thought the point of Python was that you didn't have to use type annotations.\n\nThat's the point of dynamically typed languages.\n\nAnd that's the point of statically typed languages.\n\nI think you mean statically typed, not strongly typed.\n\nIf you don't know what the type is, how can you be sure it's correct?\n\nI know what the type is, I just don't know what the type is.\n\nWhy do you want to know what the type is?\n\nBecause I'm a programmer and I need to know what the type is.\n\nI think you mean \"the type is\".\n\nIf you don't know what the type is, how can you be sure it's correct?\n\nI know what the type is, I just don't know what the type is.\n\nWhy do you want to know what the type is?\n\nBecause I'm a programmer and I need to know what the type is.\n\nI think you mean \"the type is\".\n\nI know what the", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if values:\n        values = []\n\n    for value in values:\n        if value.is_int:\n           values.append(value)\n    return values\n\nYou can do the same with the built-in filter() function:\n>>> filter(lambda x: x % 2 == 0, [1, 2, 3, 'abc', {}, []])\n['1', '2', '3']\n\nI'm not sure what you're trying to prove. The built-in filter() function is more general than this function.\n\nWhat's the point of this?\n\nThis is a common Python idiom. You can use it to remove all the values that don't meet a certain criteria.\n\nI don't understand why you wouldn't use filter() though.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) > 1:\n        return values\n    for value in values:\n        if value.is_integer:\n            return value\n    return List(0)\n\nThere are much better ways to do this.\n\nI'm not sure how to do it better. I'm trying to think of a way to do it better, but I'm having trouble.\n\nHow about this?", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value is int:\n            values.append(value)\n\nIs there a reason why you didn't use a list comprehension?\n\nI think the reason is that the OP is using a list comprehension in the first example.\n\nYeah, that's what I meant.\n\nI'm not sure why this is on the front page.\nI'm not saying it's not cool or that I'm not impressed with the author's skills, but I'm just not sure why this is on the front page.\n\nI'm guessing it's because it's a neat little trick that makes it easy to solve a common problem, and it's well-written and easy to understand.\n\nI think it's because it's simple and easy to understand.\n\nYou can also use\n[x for x in values if x.is_int]\n\nThat's true, but it's also more verbose.\n\nBut it's more pythonic, and therefore more readable.\n\nI don't know if I agree with that. The for loop is more readable to me, but I don", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 1:\n       return values\n    for x in values:\n       if x is None:\n         return []\n       if x.is_integer():\n          return x\n    return []\n\n>>> filter_integers(['a', 3.14, 5])\n[5]\n>>> filter_integers([1, 2, 3, 'abc', {}, []])\n[1, 2, 3]\n\nThe problem with this is that it's not clear what the intent is.\nIt looks like it's trying to filter for integers, but it's actually\nfiltering for values that are not None.\n\nThis is a good point. I think it would be better to use a list comprehension:\n>>> filter_integers = [x for x in values if x.is_integer()]\n>>> filter_integers([1, 2, 3, 'abc', {}, []])\n[1, 2, 3]\n\nI don't get it.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if type(value) is int:\n          return value\n\nNice. This is a great example of how to use the Python type system.\n\nI would have used the built-in isinstance function.\n\nI've never used it, but it doesn't look like that would work here:\n>>> isinstance(1, int)\nFalse\n\nYes, because 1 is not an int, but it is an integer.\n>>> isinstance(1, str)\nTrue\n>>> isinstance(1, int)\nTrue\n>>> isinstance(1, float)\nFalse\n>>> isinstance(1, long)\nTrue\n\nI would have done it like this:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(x for x in values if x % 2 == 0)\n\nThis is a really bad idea.\nFor example, what if you want to filter on the string \"abc\"?\nYou have to do some stupid regex stuff to get it to work.\n\nThat's why you should use `any`.\n\nThat's a good example of the dangers of any.\n\nThis is a good example of why you should never use any.\n\nThat's a good example of the dangers of any.\n\nThat's a good example of why you should never use any.\n\nThat's a good example of why you should never use any.\n\nThat's a good example of the dangers of any.\n\nThat's a good example of why you should never use any.\n\nThat's a good example of why you should never use any.\n\nThat's a good example of the dangers of any.\n\nThat's a good example of why you should never use any.\n\nThat's a good example of why you should never use any.\n\nThat's a good example of the dangers of any.\n\nThat's a good example of why you should never use any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if not values:\n        raise TypeError,'must have at least one value'\n    for value in values:\n        if value is int:\n            return values[value]\n    else:\n            raise TypeError,'must be an integer'\n\nThat's nice, but I'd be more impressed if it could handle the case where the list has no values.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value is int:\n           return values\n\nThis is great, but it's not obvious how it's useful. Can you give an example?\n\nYou can use it to get an ordered list of integers from a list of arbitrary objects.\nFor example, if you have a list of people and their age, you can use it to get a list of all people who are at least 18.\n\nIt's even more useful if you have a list of objects that implement __getitem__, but you don't know what they are.\n\nI don't know much about python, but I'm curious. Why not just use a dict instead of a list?\n\nThe benefit of a list is that you can use it as an iterator.\n\nI know that, but I don't see how that is beneficial in this case.\n\nThe list can be iterated over, and the result of the iteration is a list of integers.\n\nIs this really any more useful than a dict?\n\nNo, but it's a common use case.\n\nI don't understand the use case", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) == 0:\n        raise ValueError(\"Must provide at least one value\")\n    values = values.filter(lambda x: x.is_integer, None)\n    return values\n\nThis is one of the most useless things I've ever seen posted to HN.\n\nThis is a great way to get a list of integers.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value.is_int():\n           value = value.int()\n    return values\n\nThis is not a good example because it does not show the use of the Any type.\n\nIn fact, it is a good example because it does not show the use of the Any type.\n\nI think the point of the article was that the list comprehension syntax is not a good way to specify the type of the elements in the list. The Any type is a good way to specify the type of the elements in the list.\n\nYes, I agree. The author's example was not a good example of using the Any type, though.\n\nThis is a great example of how to use Python's type system.\nIt's a shame that list comprehensions don't have the type of the elements in the list as a parameter.\n\nI agree, but I'm not sure how to do it in a general way. It would be great if it was possible to specify the type of each element in the list, so that the list comprehension syntax could be used to make a function that takes a", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.is_int():\n          return value\n\nThis is a very common idiom.\n\nA more idiomatic way to do this is to use a lambda:\nfilter_integers(lambda x: x.is_int(), values)\n\nI've been using this in Python for a while now. It's a nice way to do it.\n\nI don't know, but the filter_integers() function seems to be a bit more \"idiomatic\" to me. It is much more readable.\n\nI don't see how this is any more readable than\nfilter_integers(lambda x: x.is_int(), values)\n\nI guess it depends on how much you like lambdas. I like them a lot, and so I think that the lambda is the more readable one.\n\nI like lambdas a lot too, but I find the first one easier to read.\n\nThis is the first time I've seen a lambda used like this. I'm a Python newbie though.\n\nI find this idiom a lot more readable than", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if type(value) is int:\n         return value\n\nSeems like a lot of boilerplate. The Pythonic way would be to use the built-in filter() function, which is called with a list of values, and returns a list of values that match a given test function.\n\nIf you're using Python 3, filter() is a list comprehension.\n\nIn Python 2.7, filter() is a function.\n\nI believe it is a function in Python 2.6 as well.\n\nIt's a function in Python 2.5 as well.\n\nIt's a function in Python 2.4 as well.\n\nIt's a function in Python 2.3 as well.\n\nIt's a function in Python 2.2 as well.\n\nIt's a function in Python 2.1 as well.\n\nIt's a function in Python 2.0 as well.\n\nIt's a function in Python 1.5 as well.\n\nIt's a function in Python 1.4 as well.\n\nIt's a function in Python 1.3 as well.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.startswith('0'):\n           return value\n      else:\n           raise NotImplementedError\n\nThis is cool.\nIt would be nice if it could be used as a decorator:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.is_int() and value > 0:\n          values.remove(value)\n    return values\n\nWhy not just:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for v in values:\n       if v.is_int() and v.is_positive():\n          return v\n    return values\n\nNice, but it's not a good idea to define your own type.\nI wrote a similar function, and it works like this:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(isinstance(x, int) or x % 2 == 0)\n\nWhy not just do this?\nvalues = values.filter(isinstance(x, int))\n\nI think the point is to show how to use the built-in filter function to remove elements from a list.\n\nI guess I'm missing the point. The built in filter function does exactly the same thing.\n\nI was just about to say the same thing.\n\nIn Python 3.0, the built in filter function has a new parameter, \"groupby\", that allows you to specify a function that should be applied to each element in the list before the filter is applied.\n\nThis is a very cool example of a way to use built-in functions, but it's not really an example of \"from typing import List, Any\".\nThe example given in the article is basically just a function that filters a list of any values, and it could have been written without the \"from typing import List, Any\" at the top.\n\nIt's a good example of \"from typing import *\".\n\nI think it's a good example of \"from typing import anything\".\n\nI", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i, value in enumerate(values):\n        if value.is_integer:\n            return values.pop(i)\n    return values\n\nI don't understand why this is interesting.\n\nYou might be interested in the discussion of the original article:\n\nI'm not sure what the point of this is.\n\nI agree, it's not very useful. However, it is a good example of how to use the new type system in Python 3. It's not very useful to know how to do this, but it's good to know that you can.\n\nI agree. I'm not sure why it's on the front page of HN.\n\nIt's an interesting demonstration of the new type system in Python 3.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda v: v % 2 == 0)\n\nI'm not a python expert, but I'm pretty sure this is a horrible idea.\n\nIt's not. You'd be surprised how often you want to do this.\n\nI'm not sure I understand. I think I'd be surprised how often I'd want to do this.\n\nWell, if you've got a list of lists, you might want to filter out all the lists that aren't lists of integers. Or maybe you have a list of dictionaries, and you want to filter out all the dictionaries that don't have keys.\n\nI'm not sure that's what the OP was doing, though.\n\nI'm not sure what the OP was doing either, but I do know that the idiom of using filter to return a list of values that satisfy a predicate is common enough that it's worth having a built-in function for it.\n\nI'm not sure I understand. I think I'd be surprised how often I'd want to do this.\n\nWell, if you've got a list of lists, you might want to filter out all the lists that aren't lists of integers. Or maybe", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value is int:\n           return list(value)", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(lambda x: x is int)\n\nThe problem with this is that it only works for Python 2.5+ (or, more accurately, Python 2.5+ and a recent version of the standard library).\n\nAnd the standard library is still 2.4.3 for RHEL/CentOS 5.\n\nThe only good thing about Python is the standard library.\n\nAnd the community. And the ecosystem.\n\nAnd the ability to write clean code. And the OO design. And the consistency of the language. And the fact that it's easy to learn. And the fact that it's used by Google and Facebook. And the fact that it's used by NASA. And the fact that it's used by a lot of people in general. And the fact that it's used in education. And the fact that it's easy to deploy. And the fact that it's free. And the fact that it's open source. And the fact that it's actively developed. And the fact that it's easy to extend. And the fact that it's cross-platform. And the fact that it's used in many areas. And the fact that it's easy to find people to", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for x in values:\n       if x.isinstance(x, Any) and x.is_integer():\n          return x\n    return values\n\nI always wondered why python doesn't have a list type that is basically an ordered dictionary.\n\nI've always found that a list of tuples works quite well in practice.\n\nI've seen this idiom used in many places:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(any(int(value)))\n\nI don't think this is a good example. The OP is talking about type annotations, but this doesn't use them.\nThe problem with your example is that the type annotation is in the definition, not the use.\nI'm not sure how to make this more clear.\n\nI think it's a good example. The OP said:\n\"I'm not sure what the proper way to do this is. The closest thing I've seen is the type annotations in the Django ORM, but I think there is a better way.\"\nI think this is the \"better way\".\n\nI think that's a good example too, but it's not a type annotation. The type annotation is in the definition. It's just an example of a function that takes a list of any objects and returns a list of integers.\n\nThe type annotation is in the definition _and_ the use.\n\nI'm not sure what you mean. What use does the type annotation have?\n\nThe example is an example of a function that takes a list of any objects and returns a list of integers.\n\nI'm not sure how to make this more clear", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    values = values.filter(lambda x: x < 0)\n\nA friend of mine wrote a similar function, but with a different syntax:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return [values[0] if values[0] in (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100)]\n\nNice.\nI would like to see the same done for lists of floats.\n\nI think you can do that with\nimport itertools\nfrom typing import List, Any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x % 2 == 0)\n\nI think it's more elegant to use the following, which is the same thing but a bit more pythonic:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(is_int)\n\nPython 3.2.2 on OS X 10.6.3.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.isdigit():\n          return value\n    return values\n\nand a similar one for floats:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = [int(x) for x in values]\n    return values\n\nYou can do this with a lambda.\n>>> lambda x: int(x)\n>>> filter_integers(lambda x: x)\n[5, 3.14, 5]\n\nI don't think this is quite the same thing.\n\nThis is a cool trick, but not very useful. I would rather use a list comprehension:\n>>> [x for x in range(5)]\n[5, 3.14, 5]\n\nI agree.\n\nThis is a nice trick, but I find it funny that this is the kind of thing that people find \"cool\" in Python.\nI find Python to be a very ugly language, and I am glad that I have moved on from it.\n\nI agree with you. I started with Python and I still think it's a great language for the things it was designed for. But I moved on to Ruby for most of my stuff.\n\nI find Python to be a great language for everything. I've written compilers, interpreters, and other languages in it. I've also done a lot of data crunching, web stuff", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x == int(x))\n\nI don't understand. Why is this better than using any?\n\nI think the point is that you can use it with lists that are not of type Any. For example, if you had a list of tuples, you could filter out only the integers in it.\n\nI see. In that case I'd rather just use a tuple.\n\nAnd for tuples, I'd rather use a tuple of tuples.\n\nAnd for tuples of tuples of tuples, I'd rather use a tuple of tuples of tuples of tuples.\n\nAnd for tuples of tuples of tuples of tuples, I'd rather use a tuple of tuples of tuples of tuples of tuples of tuples of tuples.\n\nAnd for tuples of tuples of tuples of tuples of tuples of tuples of tuples of tuples of tuples of tuples of tuples of tuples of tuples of tuples of tuples of tuples of tuples of tuples of tuples of tuples of tuples of tuples of tuples of tuples of tu", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value is int:\n           values.append(value)\n    return values\n\nThe code snippet seems to be missing the \"from typing import List\" and the \"def filter_integers(values: List[Any]) -> List[int]\".\n\nThanks, I just added them in.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i, value in enumerate(values):\n       if value.is_int:\n          return values[i]\n    return values", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i in values:\n        if i in range(0, len(values)):\n           return values\n    return None\n\nfrom typing import List, Any\n\n    def filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    for i in values:\n        if i in range(0, len(values)):\n           return values\n    return None\n\nfrom typing import List, Any\n\n    def filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.is_integer:\n         return value\n    return values\n\nAnd for a slightly more advanced example, you can also do:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value.isinstance(int):\n           return value\n    return []\n\nThis is a little bit of a cheat because you can't actually call a function with a list of any as a parameter.\nYou can, however, do this:\n>>> def filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    for value in values:\n        if value.isinstance(int):\n            return value\n    return []\n>>> filter_integers(['a', 3.14, 5])\n[5]\n>>> filter_integers([1, 2,", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is not None:\n         return value\n\nI don't understand why you'd use this over something like:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if len(values) > 0:\n       values = values[0:]\n       values = filter(isinstance(values[0], int), values)\n    return values", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if values.any():\n       return values\n    elif values.startswith('0'):\n       return values\n    elif values.endswith('9'):\n       return values\n\nIt's sad that this is the top comment. It's not a criticism of the code, which is quite nice, but of the people who upvoted it.\nThe problem is that the first example is very contrived. It's not a problem that can be solved with a few lines of code, and it's not a problem that you're likely to encounter. It's a very contrived example, and it's not a good demonstration of Python's power.\nThe second example is more realistic. But it's still not a very good example. It's just a trivial problem, and it's not a very difficult problem to solve in Python.\nThe third example is the only example that actually demonstrates Python's power. It's a real problem, and it's not trivial to solve. It's a good example of Python's power.\n\nI think the first example is a pretty good demonstration of Python's", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    for value in values:\n       if value.isinstance(int):\n          return values\n\n>>> filter_integers([1, 2, 3, 'abc', {}, []])\n[1, 2, 3]\n\n>>> filter_integers(['a', 3.14, 5])\n[5]\n\n>>> filter_integers(['abc', {}, [1, 2, 3]])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: filter_integers() takes exactly 1 argument (0 given)\n\n>>> filter_integers(['abc', {}, [1, 2, 3]])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: filter_integers() takes exactly 1 argument (0 given)\n\n>>> filter_integers(['abc', {}, [1, 2, 3]])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is int:\n          return values[value]\n    return values\n\nIn Python 3, you can use the new type annotations:\nfrom typing import List, Any, int", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.is_int():\n          return values[value]\n    return None\n\nThis is a perfect example of a bad idea, but it's not obvious why.\n\nWhat do you think is wrong with it?\n\nI think it's a good example of the problems that can arise when you try to use built-in types in a way that they were not intended.\nIn this case, the built-in type Any is intended to be a container for any type, and is not intended to be used as a type that can only contain integers.\nUsing it in this way can lead to unexpected results, such as in this case, when you try to use it to filter integers from a list of any type.\n\nI agree that it is a bad idea to use built-in types in a way that they were not intended. But I think that's a separate question from whether it's a good idea to provide built-in types that can be used in a way that they were not intended.\n\nI don't see any value in adding a new type to the language that is only", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    for value in values:\n        if value is not None:\n           if value is int:\n                return values[value]\n    return List(None)\n\nThe best part about this is that it's actually useful. It's not just a toy example.\n\nI don't understand why this is useful. Can you explain?\n\nIt's a filter that only accepts integers. This means that you can pass it a list of strings and it will only return the integers from that list.\n\nI get that. But why would you want to do that?\n\nIf you had a list of integers that you wanted to convert to a list of strings, this is one way to do it.\n\nThe thing that I don't understand is why you would want to convert a list of integers to a list of strings.\n\nYou can also use a list of tuples of integers, and then the filter will return tuples of integers.\n\nI get that. But why would you want to convert a list of integers to a list of tuples", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(any=False)\n    return values\n\nI thought about this for a while, but I'm not sure it's actually any better.\n\nI prefer the explicitness of this code.\n\nI agree. The original is more readable.\n\nI agree, but the only thing I can think of that makes it better is that it's not as verbose.\n\nIt's a lot more readable for me, too. I don't want to have to look at the documentation for the built-in filter function to see what the arguments are.\n\nI like it. I think it's more readable.\n\nI like it too. I think it's less readable.\n\nI like it too. I think it's more readable.\n\nI like it too. I think it's less readable.\n\nI like it too. I think it's more readable.\n\nI like it too. I think it's less readable.\n\nI like it too. I think it's more readable.\n\nI like it too. I think it's less readable.\n\nI like it too. I think it's more readable.\n\nI like", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return [0] if len(values) == 0 else values.filter(Any(isinstance(value, int) for value in values).count() > 0)\n\nI can't see the point of this. The example given is a little contrived, but the following will also filter out non-integers:\n>>> values = ['a', 3.14, 5]\n>>> filter_integers(values)\n[5]\n\nI can't see the point of your example, either. The example is contrived, but it does illustrate a point.\n\nI don't see the point of either of these comments.\n\nI don't see the point of this comment.\n\nI can't see the point of this comment.\n\nI don't see the point of this comment.\n\nI don't see the point of this comment.\n\nI don't see the point of this comment.\n\nI don't see the point of this comment.\n\nI don't see the point of this comment.\n\nI don't see the point of this comment.\n\nI don't see the point of this comment.\n\nI don't see the point of this", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for i in values:\n       if i in [1, 2, 3, 4, 5, 6, 7, 8, 9]:\n          return values\n\nThis is a very common example of Python's lack of type inference.\nIn the first example, the list of integers is implicitly converted to a list of integers, and the first example can be rewritten as", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value in int:\n          return value\n    return []\n\nHow is this any different from a list comprehension?\n\nIt's not, but I'm not sure that's a bad thing.\n\nI think it's a bad thing, as it makes the language more complex.\n\nHow does it make the language more complex? It's a tiny change in syntax.\n\nBecause it means that you have to learn how to write \"filter_integers\" instead of \"filter\".\n\nThis is a very minor change in syntax. I think it's a good change, and I don't think it will make learning Python more difficult.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x >= 0)</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is int:\n          return value\n\nThis is an example of a simple algorithm that can be implemented in the language.\n\nIt's not a very good example because the result of the function depends on the order in which the values are evaluated.\n\nI don't understand. How so?\n\nThe first value in the list is returned, then the second, etc.\n\nOoh, I see. I was thinking of it as a function that operated on a list of integers, not a list of values.\n\nThis is also a pretty good example of a \"idiomatic\" Python function. It's short, it's readable, it's clear, and it's concise.\n\nPython is a great language. The syntax is very readable and it's easy to understand.\n\nYes, and it's also a great example of a dynamic language, which I think is a good way to learn the basics of programming.\n\nI agree. I learned Java first, and then Python. I think I would have been able to learn Python much quicker if I had learned it first.\n\nI've", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is None:\n         return values\n       if value.isdigit():\n         return values\n    return List()\n\nThat's a really nice trick!\n\nI'm not sure why people are downvoting this.\nIt's a nice trick, it's a _really_ nice trick, and it's a nice example of how Python's type system can be used to do some pretty interesting things.\n\nThe only thing I don't like about Python's type system is that it's easy to accidentally mix types.\n\nHow so? I've never had this problem.\n\nI had a problem with this recently. I was using a list comprehension to do some string manipulation, and I wanted to make sure that a given string was at least 3 characters long.\nSo I wrote:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value.is_integer:\n         return value\n    return values", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if type(value) == int:\n             return value\n    return values\n\nI'm going to take a wild guess and say that this is a joke.\n\nWhy do you say that? I think it's a useful function.\n\nI mean, it's useful, but it's a pretty silly way to implement it.\n\nI like the way it's implemented. It's a little bit silly but it's still readable and easy to understand.\n\nI don't see the point of this.\n\nIt's a joke.\n\nI'm pretty sure it's not a joke. It's a real function.\n\nIt's a joke.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = []\n    for value in values:\n       if value is List(int):\n          values.append(value)\n    return values", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(is_integer)\n\nIt's not clear to me that this is a good idea. It's not clear that the author of that code knows what he's doing.\nThe code should be something like:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(any(int))\n\nI don't understand what this is doing. Can someone explain?\n\nIt's filtering a list of Any (a list of any type of value) for integers.\n\nThat's it?\n\nThat's it.\n\nI'm not sure I understand why this is on the front page...\n\nIt's a one-liner.\n\nI guess I'm missing something. What is the point of this?\n\nIt's an interesting way to do a one-liner.\n\nI suppose, but I don't understand the point.\n\nIt's a one-liner.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values.filter(isinstance(value, int))\n\nYou can also use:", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value is None:\n          return values\n       if value is int:\n           return list(int(value))\n    return values\n\nI don't get it. It looks like a case of the author using python's list comprehension syntax for something that is more naturally expressed using a list comprehension.\n\nI don't understand what you mean. The example is using the built-in List.filter() function.\n\nI think he's trying to say that the code is a case of using a list comprehension where a list comprehension would be more natural.\n\nI don't understand what you mean. The example is using the built-in List.filter() function.\n\nI think he's trying to say that the code is a case of using a list comprehension where a list comprehension would be more natural.\n\nI don't understand what you mean. The example is using the built-in List.filter() function.\n\nI think he's trying to say that the code is a case of using a list comprehension where a list", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if value == int(value):\n          return value\n    return values\n\nI like this. It's very concise.\n\nI can't tell if this is a joke.\n\nThe joke is that it's not a joke.\n\nIt is a joke, but it's not funny.</s>", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    for x in values:\n       if x is None:\n          return values\n       if x is int:\n           return x\n\nI would have gone with:\nfrom typing import List, Any", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x > 0)\n\nI think this is a case of \"not invented here\".\nI'm sure there are more elegant ways to do this.\n\nI think it's a case of \"that's not Pythonic\".\n\nI think it's a case of \"I don't understand what Pythonic is\".\n\nI think it's a case of \"it's not Pythonic because I don't like it\".\n\nI think it's a case of \"I don't like it because it's not Pythonic\".\n\nI think it's a case of \"I don't understand what Pythonic is because I don't like it\".\n\nI think it's a case of \"I don't understand what Pythonic is because I don't understand what Pythonic is\".\n\nI think it's a case of \"I don't understand what Pythonic is because I don't understand what Pythonic is\".\n\nI think it's a case of \"I don't understand what Pythonic is because I don't understand what Pythonic is because I don't understand what Pythonic is\".\n\nI think it's a case of \"I don't understand what Python", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(lambda x: x.is_integer)\n\nfrom typing import List, Any\n\n\tdef filter_integers(values: List[Any]) -> List[int]:\n\t    \"\"\" Filter given list of any python values only for integers\n\t    >>> filter_integers(['a', 3.14, 5])\n\t    [5]\n\t    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n\t    [1, 2, 3]\n\t    \"\"\"\n\t\tvalues = values.filter(lambda x: x.is_integer)\n\nfrom typing import List, Any\n\n  def filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x == int(x))\n\nI'm not a fan of the lambda syntax. I'd rather see:\nreturn values.filter(isinstance(x, int))\n\nI agree, and I think this is how most people would write it in Python. But it's a lot harder to write in Javascript.\n\nI'm not sure I agree. I think most people would write it as a function, which is exactly what the lambda syntax is.\n\nI guess I just don't see the point of making it a function.\n\nThe point is that the lambda syntax is more concise, and more readable.\n\nI think the point is that it's more concise and more readable _for the programmer_.\n\nIt's more concise and more readable for the programmer _and_ the user.\n\nI don't think it's more readable for the user. The user doesn't know what a lambda is, and will have to look it up.\n\nIt's not like they're using a new syntax for lambda. The syntax is just an alternative way to write an anonymous function, which is a concept that users are familiar with.\n\nIn Python, I would", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value.isdigit():\n           return values\n        else:\n           return []\n\nNice, but it would be more useful if it was done without the for loop.\n\nI think it's probably easier to read with the for loop.\n\nI agree. I guess it's a matter of taste.\n\nThis is a very nice idea, but it is not pythonic. I would like to see the\nfilter_integers() method in the built-in collections.\n\nI agree. I've actually submitted a similar patch to Python's collections.\n\nI was about to post a link to this but you beat me to it!\n\nI think this is a nice idea, but it's not Pythonic. I would like to see\nfilter_integers() in the built-in collections.\n\nThis is a very nice idea, but it is not Pythonic. I would like to see the\nfilter_integers() method in the built-in collections.\n\nI agree. I", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    return values.filter(lambda x: x % 2 == 0)\n\nThis is a very bad example. Python 3.2 already has a built-in function for this:\n>>> [1, 2, 3, 'abc', {}, []]\n[1, 2, 3, 'abc', {}, []]\n>>> [1, 2, 3, 'abc', {}, []] | filter(lambda x: x % 2 == 0)\n[1, 2, 3]\n\nI'd be curious to know how this compares to the built-in filter.\n\nIt doesn't do anything more than the built-in filter.\n\nIt does exactly the same thing, but it does it in a different way.\n\nIt does exactly the same thing, but in a different way.\n\nIt does exactly the same thing, but in a different way.\n\nIt does exactly the same thing, but in a different way.\n\nIt does exactly the same thing, but in a different way.\n\nIt does exactly the same thing, but in a different way.\n\nIt does exactly the same thing, but in a different way.\n\nIt does exactly the same", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n        if value not in [1, 2, 3]:\n           yield value\n    return values\n\nI'm not sure what you're trying to do, but the example doesn't work.\nIt looks like you're trying to filter out anything that isn't an integer,\nbut the list that you're passing in has more than one integer in it, so\nyou'll get a list with more than one item.\n\nYou can't do this:\n>>> filter_integers([1, 2, 3])\n[1, 2, 3]\nYou can only do this:\n>>> filter_integers(['a', 3.14, 5])\n[5]\nYou can do this:\n>>> filter_integers([1, 2, 3, 'abc', {}, []])\n[1, 2, 3]\n\nI believe the point of the example is to show the difference between list\ncomprehension and list slicing.\n\nRight, I guess I'm just not sure why the example doesn't work.\n\nI think it's because the", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n\n    for value in values:\n       if value is int:\n          return value\n\nI know this is a silly example, but I think the problem with this code is that it's too verbose. It's too hard to read. I think a better way to do this is to use a list comprehension.\n\nI don't see how this is any more verbose than the original. It's just a different way of expressing the same thing.\n\nIt's not any more verbose, but it's much easier to read and understand.\n\nI don't think it's easier to read, but it is easier to understand.\n\nI'm not sure I agree with that. I think it's easier to read, and it's easier to understand.\n\nI don't think it's easier to read, but it is easier to understand.\n\nI'm not sure I agree with that. I think it's easier to read, and it's easier to understand.\n\nI'm not sure I agree with that. I think it's easier to read, and it's easier to understand.\n\nI'm not sure I agree with that", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    values = values.filter(x for x in values if x[0] == 0)\n    return values\n\nThis is not a good solution.\nIt's not efficient and it's not scalable.\nIt's inefficient because it's doing a lot of unnecessary work: it's comparing every value with 0, but only one value has to be compared.\nIt's not scalable because the whole list has to be scanned, and the loop iterates through the whole list even if only one value is an integer.\n\nI'm not sure I understand.\nIt is efficient because it is doing a lot of unnecessary work. The value of x[0] == 0 can be determined at compile time.\nIt is scalable because it is using a list comprehension. The loop does not iterate through the whole list.\n\nWell, if you're comparing every value with 0, you're doing a lot of unnecessary work.\nI'm not sure what you mean by \"list comprehension\". I thought the whole point of the post was to show a solution using a list comprehension.\n\nI think the point is that it's a list comprehension that doesn't iterate over the whole list.\n\nI'm not sure", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    if values:\n        return [int(x) for x in values]\n    else:\n        return [values]\n\nIt's really cool that you're doing this. I have a question though. Why did you choose to write it in Python instead of a language with better performance?\n\nBecause Python is the language I know best.\n\nI'd be interested in seeing a more detailed blog post about the process of optimizing this.\n\nI'll be happy to write one, but I'll need to do some more work first.\n\nI just did the same thing in C++ and it was only ~3x slower.\n\nI wrote this in C++ as well, and it was faster than Python.\n\nI'm sure you're right, but I'd love to see a benchmark.\n\nHere's the C++ code:\n\nWow, that's really neat. I'll have to try it out.\n\nI've been thinking about this for a while, but I just did it today.\n\nI'm sure you've thought about this, but this is probably a good candidate for a C++ template.", "from typing import List, Any\n\n\ndef filter_integers(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> filter_integers(['a', 3.14, 5])\n    [5]\n    >>> filter_integers([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\" \"\"\"\n    for value in values:\n       if type(value) == int:\n           return value\n    return None\n\nThis is a classic example of a \"trick\" that is easy to explain and understand, but is in fact very inefficient. The reason is that it does not take advantage of the fact that the List data structure is implemented in C.\nThe C implementation of the list data structure is very efficient, and it uses a hashing technique to perform very fast comparisons. However, this hashing technique only works when the values being compared are of the same type.\nThe problem is that the type of the value being checked is not known at compile time. Therefore, a run-time type check is required, which is very slow.\nThe \"trick\" in the article works because the type of the value being checked is known at compile time, and so the C implementation of the list data structure can be used.\nThis is a very common problem with \"tricks\" that are implemented in Python. They are easy to explain and understand, but they often do not take advantage of the fact that Python is an interpreted language, and so are very"]]