[["def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    for elem in l:\n       if elem[0] > elem[1]:\n          return elem[1]\n    return (el[1] - el[0])/2\n\nThat's a common way to implement it, but it isn't the fastest one. The fastest is:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2] + l[3]) / 4.\n    def average(l: list):\n    \"\"\"Return average of elements in the list l.\n    >>> average([3, 1, 2, 4, 5])\n    7.0\n    >>> average([-10, 4, 6, 1000, 10, 20])\n    28.0\n    \"\"\"\n    return (l[0] + l[1] + l[2] + l[3]) / 4.\n    def min(l: list):\n    \"\"\"Return minimum element in the list l.\n    >>> min([3, 1, 2, 4, 5])\n    1\n    >>> min([-10, 4, 6, 1000, 10, 20])\n    5.0\n    \"\"\"\n    return l[0]\n    def max(l: list):\n    \"\"\"Return maximum element in the list l.\n    >>> max([3", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (x[l[0]] + x[l[1]] + x[l[2]] + x[l[3]])/4\n    if x[0] < x[1] < x[2] < x[3] else None\n\n        def median_of_arrays(a: array):\n           \"\"\"Return median of elements in the array.\n          >>> median_of_arrays([3, 1, 2, 4, 5])\n           3\n          >>> median_of_arrays([-10, 4, 6, 1000, 10, 20])\n           15.0\n         >>> median_of_arrays([-10, 4, 6, 1000, 10, 20])\n           15.0\n          >>> median_of_arrays([-10, 4, 6, 1000", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def mid(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> mid([-10, 4, 6, 1000, 10, 20])\n    6\n    >>> mid([-10, 4, 6, 1000, 10, 20])\n    9\n    \"\"\"\n    median = []\n    for i in range(len(l)):\n       mid = mid(l[i:])\n       if mid == 0:\n          mid = mid(l[i+1:])\n       else:\n          median.append(mid)\n    return median\n\nThis is missing the point. When you have a list of numbers, you want to be able to say \"give me the middle number\". In fact, this algorithm works for all data types that have a median operation.\n\nExcept that you need to make sure that the array has no null elements, since median doesn't check for that.\n\nThis is", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return [item for item in l if item % l == 0]\n\nI think the code below is more idiomatic python:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[int(sum(c.pop(l))) for c in l]\nI am a Python novice, but this smells funny to me. Why do I have to\npop() the list every time I want to get a value?\n\nThere's a deeper issue here.\nWhy does the median function need to be part of the \"list\" type? I\nthink it's better to implement a median function as an instance of a\ntype (integer, float, whatever), and have that type exist outside of the\nlist type.\nThat way, the \"int\" type can implement a median function if it wishes,\nand so can other types.\n(I'm assuming here that the median function is not defined on lists, but\non types that are instances of \"list\". If it is defined directly on\nlists, then we have to deal with the issue of how to define a median\nfunction on other types, which would require a rather strange type\nsystem.)\n\nThe reason you are being down-voted is that you aren't actually reading the article.\nThe article is not suggesting that the median function be defined on lists, it is suggesting that the median function be defined on the", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l) - min(l)\nThat's clever.  My version was much uglier:       def median(l):\n         return [l[0] for l in l if l[0] > l[1] for l in l]\n(I would probably have to use list comprehensions to do it in a way that was more idiomatic and also more concise, but I'm still working on that)</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\n    median(l, key=lambda x: x[0]):\n    \"\"\"Return median of elements in the list l, taking the element at\n    position key into account.\n    >>> median(l, key = lambda x: x[0])\n    [1, 4, 3, 5]\n    >>> median(l, key = lambda x: x[1])\n    [1, 4, 5, 3]\n    \"\"\"\n    median(l, key=None):\n    \"\"\"Return median of elements in the list l, taking no element into\n    account.\n    >>> median(l, key = None)\n    [1, 4, 3, 5]\n    >>> median(l, key = lambda x: x[1])\n    [1, 4, 5, 3]\n    \"\"\"\n    return (x[0] > x[1] or x[1] > x[0])", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    from collections import Counter, Queue, MutableList\n    def div(a, b):\n    return a / b\n    def leftmost(a, b):\n    return len(a) - len(b)\n    def to_int(a):\n    return a.__class__.__name__\n    def to_int(b):\n    return b.__class__.__name__\n    def to_list(a):\n    return a.__class__.__name__\n    def to_list(b):\n    return b.__class__.__name__\n    def to_list(c):\n    return c.__class__.__name__\n    def __getitem__(self, index):\n    \"\"\"Return element at index.\n    >>> median([1, 2, 3, 4, 5])\n    3\n    >>> median([3, 2, 4, 5, -10])\n    5", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       median = l[0]\n    else:\n       median = l[len(l)-1]\nYou forgot that it should be in the list form:\nreturn l.median()\nAlso,", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = (0, 0)\n    for j in range(len(l):):\n       median = (median + j[1] - median[j]) / 2", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = int(len(l) / 2)\n    return l[median]\nI'm guessing that the original author wrote this before knowing about median.\n\nThe median of a non-negative list is the median of the elements in the list.\n\nI think the median is different than the mean of a list. So it would be useful to be able to compute it.\n\nIn case you don't know what median is: \n\nYou guys are right, there is a difference between the median and the mean. The median is the value in the middle of a sorted list.\n\n\"The mean is the sum of all values divided by the number of values.\"\nNo.\n\nOops. I was thinking the median was the mean average. Guess that's not the case.\n\nThat's \"mean median\", but only one of those two terms is \"mean\".\n\nIs there a standard in python for naming functions? I feel like the \"median\" function should be called \"median_function\", because I always have to read the doc first to find out what the function name means.\n\nThis is a fairly standard name for the function in most languages.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\nI'm not sure why you would want to do this in Python. You could do it in\nabout one line of C (using the string.find() function), or in Perl, or\nPerl would be easier than Python, or you could use Perl to generate\nPython.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = 0\n    for element in l:\n       if element[0]!= 0:\n          median += element[0] / l.size()\n          median = median / l.size()\n    return median\nThis would be somewhat easier to read if you used:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def min(l: list):\n    \"\"\"Return minimum element in the list l.\n    >>> min([-10, 4, 6, 1000, 10, 20])\n    4\n    >>> min([3, 1, 2, 4, 5])\n    1\n    \"\"\"\n    def mean(l: list):\n    \"\"\"Return mean of elements in the list l.\n    >>> mean([3, 1, 2, 4, 5])\n    3.0\n    >>> mean([-10, 4, 6, 1000, 10, 20])\n    5.0\n    \"\"\"\n    def nth_element(l: list, n: int):\n    \"\"\"Return nth element from the end of the list l.\n    >>> nth_element([3, 1, 2, 4, 5])\n    5\n    >>> nth_element([-10, 4, 6, 1000, 10, 20])\n    20\n    \"\"\"\n    def n", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = 0\n    for el in l:\n       median += el\n    return median\n\n>>> median([3, 1, 2, 4, 5])\n3\n>>> median([-10, 4, 6, 1000, 10, 20])\n15.0\n\nIn python 3.0 (and maybe earlier versions as well) this becomes:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return l[l.pop() if l.length == 2 else l[-1]]\nI thought the median of a list of odd length was the largest element?\n\nI believe it's the smallest. The median of 3 and 2 is 3. The median of\n3, 2, 1 is 3. The median of -10, 4, 6, 1000, 10, 20 is 15.\n\nYou're right, I was thinking of an average.\n\nI prefer to use numpy. It's more readable and it's a single line of code:\n>>> median(range(3)) 3\n\nNot really.\n>>> numpy.median([3, 1, 2, 4, 5]) 3\n>>> numpy.median([-10, 4, 6, 1000, 10, 20]) 15", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return [l[0] for l in l]\nI'm not a Python programmer, but why is there a for loop in the definition of a function?\n\n\"Median of a list\" is not a function; it's a method. Python allows you to define methods on any object.\n\nMedian of a list _is_ a function. The function definition is a method.\n\nWhat's the difference? (I'm not trying to be difficult, I really don't know!)\n\nIn math, a median is a single number that is the \"middle\" value of a set of values. For example, if you were given a list of numbers from 1 to 100, and asked to find the median, you would get the number 50. It is a single value that is the middle of the list.\nIn computer science, there are two distinct terms that are often used interchangeably, but are actually subtly different. Those terms are \"function\" and \"method\".\nIn this case, a \"function\" is a piece of code that takes an input and returns a value. For example, suppose we wanted to find the median of a list of numbers. We could do that by writing a function that", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(l, key=lambda x: x.median(axis=1))\n\n>>> median([3, 1, 2, 4, 5])\n3\n>>> median([-10, 4, 6, 1000, 10, 20])\n15.0</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n         def median_of(l: list):\n          return [l[:](2) for l in l if l[:](2) > l[:](1)]\nI would rename it to median_divisor.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\nMedian is often an underrated operation.\n\nHow would you use it in practice? I have a hard time imagining a scenario where I would use median over a typical sort algorithm.\n\nIt's handy for analysing data where the value is out of the range of the typical sorting algorithms. I use it quite a lot.\n\nAh, that makes sense. Thanks.\n\nThis is great, I've always wanted to learn how to do this.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\n    def mode(l: list):\n    \"\"\"Return mode of elements in the list l.\n    >>> mode([2, 2, 3, 3])\n    3\n    >>> mode([0, 1, 3, 2, 3])\n    0\n    >>> mode([-3, -2, 2, 5, 4])\n    1\n    >>> mode([-3, -2, 2, 5, 4])\n    1\n    \"\"\"\n\n    def average(l: list):\n    \"\"\"Return average of elements in the list l.\n    >>> average([-10, 4, 6, 1000, 10, 20])\n    6.0\n    >>> average([-3, -2, 2, 5, 4])\n    6.0\n    \"\"\"\n\n    def min(l: list):\n    \"\"\"Return minimum of elements in the list l.\n    >>> min([-10, 4, 6, 1000, 10, 20])\n    -10", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return len(l) / 2\n\nNote that median() requires a list and that there's no such thing as an \"element\" in Python. You also don't specify the type of the median (which in the example above would be float).\n\nYou can easily write a median function in Python:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = l[0]\n    for i in range(len(l) - 1):\n       if i > median:\n          median = i\n    return median\nThis is the wrong solution. The correct one is:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[0]\nI haven't looked at the source code in detail, but the author appears to be under the impression that an `l.append` is O(1) in Python.\n\nIt is. He's using a built-in function.\n\nNo, it isn't. It's O(n) if l is a list. He's using a built-in function called \"median\", but the function itself isn't O(1).\n\nIt is an O(1) operation to do an append to a list (of size 1).\n\nTrue, but the median() function he's using has to iterate over the list to find the median element.\n\nThe median function is an O(1) operation. That's what he is saying.\n\nI wonder how fast it is. I imagine that is a reasonable concern for something like this.\n\nThe median is O(n), but if it's for example a list of 10 items, then it's an O(n*l) operation, so it's very fast, even if you have huge lists.\n\nI am curious, how are you computing the median?\n\nThat's an easy one", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    \"\"\"\n    return l.index(l.get(0))\n    \"\"\"\n\nYes, it seems that I should use the index method. Is it more efficient than computing the average?\n\nMost lists are pretty efficient (by which I mean you won't see a difference in speed) between averaging and indexing for this kind of operation.\n\nI'm not sure if you're right. I think it depends on the complexity of the list.\n\nThe complexity of a list is O(n) where n is the number of elements.\n\nThe complexity of a list depends on how many of the elements are duplicates.\n\nThe complexity of a list of numbers is constant.\n\nActually the number of elements in a list of numbers is not constant.\n\nYou're right. But it's possible to approximate the number of numbers in a list without duplicates as being constant (see the discussion above about sorting).\n\n_A list is a series of elements, and the index of a particular element in the list is the position of that element in the series._\nA list can also contain functions, and the index of a particular function in the list is the position of the _", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (x[i] - x[i+1]) / 2.0\n\nThe median is the value of the median method for lists in Python 2.x.\n\nWhen the list contains duplicates, it is a common mistake to return the value\nof the median method for tuples, which does not exclude duplicates.\n\nx = [3, 1, 2, 4, 5]\ny = median(x)   # the median of the list is 3\nz = median(x, True)  # the median of the list is 3\n\nHowever, in Python 2.7 and later, the median method for lists is equivalent\nto the median method for tuples that ignores duplicates.\n\nx = [3, 1, 2, 4, 5]\ny = median(x)   # the median of the list is 3\nz = median(x, True)  # the median of the list is 3\n\nPython 2.5 and earlier\nWhen the list contains duplicates, it is a common mistake to return the value\nof the median method for tuples, which does not exclude duplicates.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l[:], l[-1:] + l[-2:] + l[-3:] + l[-4:] + l[-5:] + l[-6:]) / len(l)\nI'm not familiar with Python, but it looks like the OP is doing the same thing.  I don't see the problem.\n`l[:]` is the list with all the elements, and the median is the one in the middle.  `l[:]` is a list with all the elements, so it's impossible to return the median of the elements in the list.  `l[-1:]` is the first element, `l[-2:]` is the second, and so on.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    x = 0\n    while len(l) < len(l[0]) + 1:\n        x, y = l[0]\n        if x == 0 and y == 0:\n           return x\n           y = l[1]\n           if x > y:\n               x = x / 2\n              y = y / 2\n              else:\n               y = y / 2\n               x = x / 2\n              return y\nCan you explain why a median is necessary in this case?\n\nIt's an implementation detail of the median function. I took it from this article:\nIt uses the method I describe above", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    median = lambda x: x[2]\n    median(l)\n\nThe author of the article should use a different name for his/her function as `median` is a built-in Python function (in [math] module) with a very different behaviour than the one described in this article.\n\nMy guess is that he was calling it median() as a joke.\n\nI think the article is a joke.\n\nYes, it is.\n\nThe author should fix the code formatting. For example the following piece of code:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    x, y = range(l)\n    if x > y:\n        return y\n    return x", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sorted(l, reverse=False)\nOk,  now you are showing off.   You did that just for the lulz.   I hope you aren't using python 3 in production.\nOr python 2.   They changed that in python 3.\nWell, the part of this thread that I wanted to show off was that this is a (really) trivial python program.   Which means that the tooling around python is doing an excellent job.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\n       def median(l: list, m: list):\n        if len(l) == 1:\n           return l[0]\n         elif len(l) > 1:\n            return min(l[0], m[0])\n         else:\n           return l[1]\n\nThe median of a list is a list of numbers, not a number. The code, as is, will give you a list of 1, 1, 2, 5, and the median of -10, 4, 6, 1000, 10, and 20.\n\n>>> median([-10, 4, 6, 1000, 10, 20])\n[15.0, 15.0, 15.0, 15.0]\n\nI was going for a one-liner (in Python). And I think the point is well made: a list of values can't be summed or divided in a meaningful way, because it's a list of values, not", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median_of = median(range(0, len(l)))\n    return median_of\n\nI would call that algorithm as _perv_median_of.\n\nReally? I would have called it median, because it's the median of the elements of the list. What's wrong with that?\n\nIt's the median of the elements of the _first_ list.\n\nAh, thank you. That's a very subtle difference. I can see now why the author didn't choose to call it \"median\".\n\nIt is an extremely common mistake, and one I've made myself more than once.\n\nI like the new median, but the old median() was very useful for certain kinds of standard data analysis, so I hope they leave it in as well, with a suitable warning.\n\nIt seems like you could implement the old median() using the new median(). What's the difference in your view?\n\nThe old median() returned the median of the whole list. I don't see how it can be implemented with the new median().\n\nOh, I thought it returned the median of the elements in the first list (as in, it would return 3 if", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    # return the median of elements in the list\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return sum(l[::2] - sum(l[::2] + l[::3])/2)\nYou just copied the code from the SO question.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    \"\"\"\n    return l[0]\n    if len(l):\n       return l[0]\n    return l[-1]\n\nSo, I don't know enough to understand what's going on here, and I'm curious.\nIf you're going to do this kind of trickery, what are the advantages to using Python vs. a statically typed language?\n\nI'm not sure what you mean by \"trickery\" here, but there are some advantages.\nFirst, this is extremely easy to debug. The use of a dictionary for the array in the \"if len(l):\" clause means that you can directly inspect l in the debugger, as opposed to something like the following in C:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (x[0] - x[1]) / 2\nI thought this was pretty clear from the docs.\n\nThe median isn't the average, though.\n\nThat's why I was confused by the article. It seems like the article is talking about the _median_ of a list, rather than the _average_.\n\nThe median of a list is the same thing as the average of a list, if the list is sorted.\n\nThe median is an _increasing_ function. The average is a _decreasing_ function.\n\nA list of numbers, sorted, is a decreasing sequence. The median of the sorted list is the average of the sorted list.\n\nNo, the median of a sorted list is the _increasing_ function that results from sorting the list and selecting the middle element.\n\nI think the OP is referring to this definition of the word \"median\":\n\"the middle number or item in a series, sequence, or set of numbers, sorted in ascending order\"\n\nThis is incorrect. The OP is correct: the median is the average of the middle half of a list, or the nth element of an n-element set, if the list", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    \"\"\"\n    def __len__(self):\n    \"\"\"Return the number of elements in the list l.\n    >>> len([3, 1, 2, 4, 5])\n    5\n    >>> len(median([3, 1, 2, 4, 5]))\n    3\n    \"\"\"\n    return len(l)\n\nThere is no documentation for the __len__() method.\nI have a feeling it is a joke, but I don't get it.\n\nIt's not a joke, it's just a (bad) example of how to write unit tests.\nIn this case it tests that the __len__() method returns the right value for the function, but in general you can use it for anything.\n\nYou're right, my mistake. I've edited the post to correct the example.\n\nOh, ha. That was a good one.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (a, b)\n    if len(l) == 2:\n       return a\n       return b\n\nThere is something very wrong with this code. Why would you pick a single element in your input as the median?</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    \"\"\"\n    # We use the \"len()\" method to find the length of the list.\n    #\n    # Note: the length of a list is not the same as its length.\n    #\n    len = l.length()\n    # The \"find\" method will return the index of the first element\n    # in the list where the first element is less than or equal to\n    # our argument \"x\".\n    find(len, x)\n    # In this case, x is 0. The method \"in\" will return the first\n    # element in the list that matches the condition, in this case\n    # 0.\n    in(0)\n    # Now, to find the median, we need to calculate the index of the\n    # element in the list that has an index that is equal to the sum\n    # of the two numbers on either side of our median.\n    #\n    mid = len / 2\n    # The list is 0-based", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(l[1:]*l[0] + l[2:]*l[0] +... + l[n-1:]*l[0])\n    / len(l)\nThis is not the median of the list, but a median of the list's elements.  To get the median of the list, you need to do something like this:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = [0, 0, 0, 0, 0]\n    for element in l:\n       if element < median:\n          median[element] = median[element] + 1\n       else:\n          median[element] = median[element] - 1\n    return median\n\n>>> median([-10, 4, 6, 1000, 10, 20])\n15\n\nMedian is not the same as mode. The median of the list you show is 15, not 15.\n\nPython is a great language, but it does have some warts, and the median() function is one of them. I've found that list comprehensions are often the best way to do something in Python that involves iteration, because you can use them to implement any algorithm without having to know the language intricacies.\n\nYeah, that's true. It also has the nice property that the comprehension code is self-documenting, since it's obvious what the inputs are and what the outputs are.\nBut it does have one problem: it's incredibly slow. I", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    med = 0\n    for i in l:\n       med += list(int(i), list(int(i))/2)\n    return med\n    # Can use this in your list comprehension\n\nNote: This is only an approximation of the median. It's not a guaranteed\n50% point like you might expect. The median algorithm is well-known to have\nproblems when the median is not a rational number.\n\nI would say this is a guarantee in Python (or at least, I've never encountered an instance in which it wasn't).\n\nI've encountered instances where the median wasn't a rational number. I think they were both from data sets with outliers, but I can't remember specifically.\n\nI have done the same using a single list comprehension to find the median. In this case, the median of a list of numbers with even numbers of elements.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    # Median can be a list or a tuple of two values.\n    if len(l) == 1:\n       return l[0]\n    else:\n       return ((l[0] - l[1])/2)\n    # Get the median of the element in the list.\n    median_element = l[0]\n    # Get the range of values.\n    range = l[1:]\n    # Get the smallest and largest values in the list.\n    min_value = range[0]\n    max_value = range[1]\n    # Calculate the median.\n    median = (min_value - max_value)/2", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median_l(l):\n    \"\"\"Return median of list l.\n    >>> median_l([3, 1, 2, 4, 5])\n    3\n    >>> median_l([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return (l[-1]*(l.size() - 1) + l[-2]*l.size()) / 2\n\nI like it. But would have been great to give an example to show what it does before explaining it.\n\nHaha. I almost did that, but I've found that too often people skip the examples and just read the explanation.\n\nOn a side note, this kind of reminds me of an old, old joke:\n\"The median is the middle number in a list of numbers. For instance, the median age of people at the party last night was 27.5.\"\n\nMedian is not the middle number in a list of numbers, median is a distribution function that takes a list of numbers as input.\n\nTrue, but it's an easy mistake to make", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[l.index(0) % l.size()]\nYou can also use numpy.median</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1])\nI don't know anything about python, but this feels like a terrible solution.  Why not return the median of elements less than, say, the first and third elements?  This would avoid a number of comparisons.\nIt's a pythonic solution. This is actually what python does internally when you say `median(list)`. If you were to write that in C++ it would probably look something like this:      std::sort(list, std::less(list, std::begin(list), 2), key=lambda x: x[1])\nPython's `sort` function doesn't guarantee ordering, and the C++ code is unidiomatic.  The proper C++ way would be to sort the list using a std::sort_n (or std::stable_sort) that includes the median as a pivot, then use std::less to filter the pivot from the result.\nI was just trying to show how to do it in python and C++. Of course you'd need to sort the list first and use a more efficient algorithm for it in C++.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[1] - l[2] + l[3])/2", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    \"\"\"\n    def median_from_end(l: list):\n    \"\"\"Return median of elements in the list l starting at the end of the list.\n    >>> median_from_end([1, 2, 3, 4])\n    4\n    >>> median_from_end([1, 2, 3, 4, 5])\n    5\n    >>> median_from_end([-10, -9, -8, -7, -6, -5, -4, -3, -2, -1])\n    16.0\n    \"\"\"\n\nThanks, I've updated the post.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda x: x[1]\n    median(l)\n\nYou could use the same method to return the mean:\n>>> median(mean([3, 1, 2, 4, 5])):\n3.0\n\nHow is this better than min, or sum, or even the built in itertools.groupby?\n\nIt's not. The built-in sum() is actually faster than median(), while being more accurate, and min() is as well. (The built-in min() also works on lists of any length, as well as any iterable which is homogeneous enough.)\n\nOn Python 3, sum() is faster but not more accurate.\n\nsum() is always faster than median(). It's more accurate in the sense that the results are less sensitive to small changes in input.\n\nMinor quibble: sum() is not always faster than median(). It's often faster, but it's not always. There are two inputs, sum and median, where median is faster.\n>>> sum([-1, -1, -1, -1, -1, -1, -1, -1, -1])\n0\n>>> median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    a = sum(l)\n    b = sum(l[:: -1])\n    c = sum(l[:: 1])\n    return (a + b)/2", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = np.median(l)\n    print median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (x / sum(l)) % len(l)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n       return sum(float(x) for x in l) / float(len(l))\n       / float(len(l) - 1)\nThank you for your answer.  I am trying to do a median of a set of numbers that aren't numbers.  Can I modify the code to accept any object in the list and return the median value?\nSorry, you might have to use a different algorithm than the medians.  For instance, I think you could use       sorted([x for x in l if x < y])\nI was afraid you would say that.  The problem with that is that I have to sort the list every time I run the function.  Thanks for the help.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return ( (l[0] + l[1]) / 2) + (l[0] + l[2]) / 2\n\nThis is one of the things that Python has right.\nAlso, I would argue that Python has it wrong in the opposite direction. The list comprehension is a lot more readable and has a much smaller chance of error than the bit of code you wrote.\n\nSure, but the code I wrote is a lot more concise. If I'm going to be writing a lot of code using the median function, I want that code to be as terse as possible.\n\nIt is only more terse by one character, and you have to understand and remember the extra special syntax of list comprehensions.\n\nI'm sorry, but I don't buy this. I would say that I need to remember only two things.\nFirst, in python, the items you pass to the function need to be _iterables_. If I forget this, I'm going to have some hard to debug errors.\nSecond, in python, the items you pass to the function need to be _tuples_. If I forget this, I'm going to have some hard to debug errors.\nAside from", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    \"\"\"\n    return min(x for x in l if x < l[0]) + max(x for x in l if x > l[1])\n\nIt's a bit strange, isn't it? In a list of a million numbers, I have to iterate a million times to get the median.\nThis is because Python uses lists as a first class data structure, and gives equal treatment to the sum and the median (and the max and the min).\nIn practice, that's a good thing, because it makes the code more readable (and more maintainable). However, when performance matters, it can be a problem.\nPython isn't alone in that problem, though. In most programming languages, you have to decide whether you're optimizing for readability, or for speed.\n\nAs a side note, it can actually be a problem when speed is _not_ an issue. For instance, it's not uncommon to see people try to use a million-element list as a generic list for quick access, where the median of the entire list is the desired value.\n\nThis is a very bad idea in python, since it causes list access to be quadratic, which can be", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    # A trivial solution with an explicit recursion\n    return 0.5\n    def all_nth_element(l: list):\n    \"\"\"Return all nth elements of elements in the list l.\n    >>> all_nth_element([3, 1, 2, 4, 5], 4)\n    [3, 2, 1]\n    >>> all_nth_element([3, 1, 2, 4, 5], 5, 2)\n    [1, 3, 2]\n    >>> all_nth_element([3, 1, 2, 4, 5], 5, 3)\n    [1, 2, 3]\n    >>> all_nth_element([3, 1, 2, 4, 5], 5, 5)\n    [1, 2]\n    >>> all_nth_element([3, 1, 2, 4, 5], 5, 6)\n    [1, 2, 3]\n    \"\"\"\n    return [l[i:] for i in range(1", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median2(l: list):\n    \"\"\"Return median of the elements in list l, but return a tuple with\n    (x, y) as its members (as opposed to a single x and y) if the\n    median of the elements of list l are equal.\n    >>> median([3, 1, 2, 4, 5])\n    (3, 1)\n    >>> median2([-10, 4, 6, 1000, 10, 20])\n    (15.0, 15.0)\n    \"\"\"\n    def median3(l: list):\n    \"\"\"Return median of the elements in list l.\n    >>> median3([-10, 4, 6, 1000, 10, 20])\n    6.0\n    >>> median3([3, 1, 2, 4, 5])\n    3\n    \"\"\"\n    def midpoint(l: list):\n    \"\"\"Return the midpoint of the elements in the list l.\n    >>> midpoint([3, 1", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    # Subtract from each element the median of all the elements above it.\n    # The median of the result is the median of the list.\n    return [l[0] + (l[1] - l[0]) / 2 for l in l]", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(l[0] for l in l) / 2\n\nThat's a pretty clear explanation.\nI wonder if you need to be a programmer to understand it or if it's pretty clear to anyone.\n\nI was expecting it to be (sum(l[0]) for l in l):\n\nIt's very much like the median of a set of numbers. The expected value of the sum is the median of the distribution of the numbers, as long as they are monotonic.\n\nI'd make one small change, to make the name of the function make more sense.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l.pop(0))[0]\n`__init__.py` doesn't have any `list` objects. `__main__.py` has `l` defined as `list(1, 2, 3, 4)`, but `__init__.py` doesn't use it. `l` should be a list when you call `l.pop(0)`.  Also, I don't see what you mean by `l.pop(0)`. `l` is already a list.  I'm guessing this is where your problem is.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return [l[i] for i in range(len(l)-1)]", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median2(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median2([3, 1, 2, 4, 5])\n    3\n    >>> median2([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n\nIt's all very nice and pretty.\n\nBut what about efficiency? When you have a large list, median(l) is O(N), where N is the length of l. Median2(l) is O(N log N), which is better.\n\nHowever, median2(l) is O(N log N) in the number of elements of l, not in the length of l.\nIf l is a list of 2 elements, median2(l) is O(2*N), which is the same as median(l).\n\nThis becomes a problem when you have a list of arrays. In that case, the length of l is O(N log N), but the number of elements of l is O(N^2), which is much bigger.\n\nThere are many applications where", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] - l[1] + l[2] - l[3]) / 2", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return len(l) % 2\nWhile I agree with the spirit of your post, the above implementation is O(n) not O(l).\n\nO(n) is actually a good thing in this case. The example calls for a list of numbers, and in that case n is very small.\n\nWhy not use quicksort (in-place on a list) instead?\n>>> def quicksort(l: list):\n...         return list(int(n[i]), n[i + 1])\n...         if i < len(l):\n...             return l[i]\n...         if i == len(l):\n...              return l\n...         return [n[i] for i in range(len(l) + 1)]\n>>> median(quicksort(range(10)))\n3\n>>> median(quicksort(range(10) + 1))\n5\n>>> median(qu", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (float(sum(i for i in l)) / sum(i for i in l))\n    # []\n    def centroid(l: list):\n    \"\"\"Return the centroid of elements in the list l.\n    >>> centroid([1, 2, 3, 4, 5])\n    [1, 2, 3]\n    >>> centroid([1, 2, 3, 4, 5])\n    [3, 1, 4]\n    >>> centroid([1, 2, 3, 4, 5])\n    [2, 3, 1]\n    \"\"\"\n    return (float(sum(x for x in l)) / sum(x for x in l))\n    # []\n    # Return median and centroid of sorted list\n    def median_centroid(l: sorted list):\n    \"\"\"Return median and centroid of sorted list l.\n    >>> median_centroid([1, 2, 3, 4, 5], ascending=False)\n    3", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (float) (Math.min(l[0], l[1], l[2], l[3]))", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return np.median(l)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda x: int(x[1])\n    for i, x in enumerate(l):\n       median(x)\nI like this one better:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\nSo that's the problem. The right solution is to use the parameter pack expression and pass in a lambda function that takes the input and returns the median.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    p0 = None\n    for e in l:\n        p0 = (e[0] * e[1] + e[2] * e[3]) / 2\n    return p0\n\nreturn median(my_list)\n\nThe point of the article is to demonstrate the idea of a monoid, not to provide a simple median function. Your median function uses a list comprehension and is thus not a monoid.\n\nI'm confused. What is the point of a monoid, then? Why not just create a class that does what I want?\n\nIn the context of the article, monoids are basically a set of functions on which you can compose operations (and also compose with other monoids).\nIn practice, you'd use monoids to compose operations that are hard to express as functions, like addition, multiplication, and so on. The benefit of a monoid is that you can compose several operations together and still have the result behave correctly.\nFor example, the monoid for addition of natural numbers could be defined as:\nA + B = A + (B + A)\nThe problem with your median function is that", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    result = []\n    for i in l:\n        if i not in result:\n           result.append(i)\n         result.append(l[i])\n    return result[-1]\nAnd an improved version in Python:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    # count the number of elements in the list\n    # and return the median\n    return (x*(x+1)/len(l))\nLOL. It's funny because it's true.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\nI'm not sure why you're posting a Python snippet in an article about C#...\n\nI think this is a nice example of how similar two languages can be, and the kind of projects you can work on in each.\n\nWell, yes, but it's not a very good example of either.\n\nIn case someone is interested in the difference, this is what the code would look like in C#:\npublic static int Median(int[] values) {\n\tvar i = 0;\n\tfor (int i = 0; i < values.Length; i++) {\n\t\tif (values[i] > values[i + 1]) {\n\t\t\ti++;\n\t\t}\n\t\tif (values[i] < values[i + 1]) {\n\t\t\ti--;\n\t\t}\n\t\treturn i;\n\t}\n\treturn 0;\n}\n\nHandy! Also, in case anyone is interested in how to do this in C++:\ntemplate<typename T>\nstatic constexpr T median(T xs) {\n\t\treturn std::abs(x.begin(), x.end()) + std::", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    from operator import itemgetter\n    from itertools import islice\n    median = (itemgetter(l)[0] + itemgetter(l)[1] + itemgetter(l)[2])\n    if len(l) == 1:\n       median = islice(l[0], l[1], l[2], 1)\n\nThis is just completely wrong. You should not be using `median` to calculate medians with 1 element.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return len(l) - 1\n> Shouldn't this return the mean?\n> I mean, I think you can just go on about how the median is the \"middle\n> element\" in a list of _n_ elements.\n>\n\nThe mean is the average. The median is the number that's right in the middle.\n\nWell, it's the mid-value; the average is the mean.\n\nThe median is the average of the middle element of a list of numbers.\n\nYeah, the average of the middle element. The mean is the average of the list.\n\nNo, the mean is the sum divided by the length. The median is the middle element of a list.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sorted(l, key=lambdax:x[0] + x[1] + x[2] + x[3])[0]\ni feel like I'm missing something obvious.\nI thought of the same thing (sorted l.key) but the median of the sorted list is not the same as the median of l.\nTo be specific, the median of a list is the element in the list with the median value.  The median of a sorted list is the element in the list with the median value *after sorting*.  Since the sorted list has been sorted, it's possible for the median value to have changed.\nYeah, but this is not the place where you'd expect people to use the word \"median\" as the median of a sorted list.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] - l[1] + l[2] - l[3]) / 2\n\nThe median function returns the middle element of a list. The median is the\nmiddle value of a sorted list of numbers, and it is also a fair way to divide\na list of items with an equal number of elements into two. If the elements of\na list are in a particular order, then the median is the middle value of the\nlist. For example, if the list is sorted by their values, then the median is\nthe middle element. The median is also the middle element if the list is\nsorted in alphabetical order.\n\nYou can always find the median of a list of numbers in linear time. You can\nfind the median of an unsorted list in constant time.\n\nThis code snippet demonstrates the median function on a list of numbers,\nwhich are sorted in alphabetical order, i.e., [1, 2, 3, 4, 5, 6, 7, 8, 9].\nThe median value of this list is 5.\n\n>>> median([1, 2, 3, 4, 5, 6, 7, 8, 9])", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    val l = list(range(10))\n    return (l[0] / (l.size() - 1)) + (l[1] / (l.size() - 1)) + (l[2] / (l.size() - 1)) + (l[3] / (l.size() - 1)) + (l[4] / (l.size() - 1))\n\nI don't understand the downvotes. It's just a nice example of python's nice features, no?\n\nIt is, but I don't think it's very clear how to read it (at least for me). The solution is obvious, but it takes a while to digest. I guess this is the benefit of the language.\n\nI would argue that it is actually very easy to read.\nWhen I see a line like this, my brain immediately goes \"This is a list comprehension. I can treat this as a single expression.\" And then I can see the syntax for what it is.\n\nI know how to read it, I just think it's pretty obscure.\n\nSince it's been 2 months since the last post:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = len(l)-1\n    if l.count() == 2:\n        return (l[0] - l[1])/2.0\n    else:\n        return 0", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return list(l[::2])[0]\nWhy are you using 2 instead of 1?\n\nThis is actually a good question. For some reason, 2 is used in most of the standard libraries of different languages, including Python. I don't know why.\n\nThat's because it's the smallest positive integer that is still less than or equal to the sum of all of the elements in a list.\n\nI don't think that's true for Python lists; \"0\" fits that criteria as well.\n\n0 is not a valid index for lists in Python.\n\nA decent example of a \"good question\".\n\nI like that there are a lot of different answers to this question. One of the great things about the Python community is that it really does encourage discussion and sharing of ideas.\n\nThat's a good point and I'm glad to see it, but at the same time it was the top voted question on StackOverflow a few months back.\nSo while this is a good example of \"a good question\" that will get a lot of discussion, it's also a good example of a \"re-occurring question\" that will be asked over and over again.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median_list = []\n    for elem in l:\n       if l[elem] > median_list[0]:\n          median_list.append(elem)\n       else:\n          median_list.append(l[elem])\n    return median_list\nThanks for this.  I was confused that the original article used \"median\" and \"mean\" interchangeably (i.e. saying that the median of a list is the \"mean\" of the elements).  A quick search of Wikipedia shows that \"median\" is a type of \"average\" and that the \"mean\" of a set of numbers is always a \"median\".\nMean is only a median for values with a non-zero variance.\nWow, I did not know this.  I guess that means the mean is the median for a very narrow set of values.  Would you happen to know the general case?</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = array([l[0], l[1], l[2], l[3])\n    for i,v in enumerate(l):\n         if v[0] < v[1] and v[2] < v[3]:\n             median[i] = v[0]\n    return median\n\nI had to look up what a median is. I had the mental picture of the middle one in a line.\n\nIt's a good interview question to ask what the median is. It's more of an insight into the person's way of thinking than actual programming ability.\n\nThis is the only function I have in my signature on GitHub. It is a great interview question. I'm always disappointed in people who claim to have 5 years of experience and can't answer it.\n\nIf you want to see how bad people are at this, you can also ask them to name the min and max of a list in order.\n\nI like to ask them how many sets of length n there are, and how they'd find them (there are n ways to do it", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def __eq__(self, lst):\n    \"\"\"True if elements in the list lst are equal to elements in the list median.\n    >>> median([3, 1, 2, 4, 5]) == [3, 1, 2, 4, 5]\n    True\n    >>> median([-10, 4, 6, 1000, 10, 20]) == [3, 1, 2, 4, 5]\n    False\n    \"\"\"\n    return (", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    a = 0\n    while len(l) > 0:\n        for i in l:\n           if i > a:\n               a = i\n               a += 1\n          return a\n\nIs this efficient? You seem to be returning the median value of every element in the list, and you are calculating it for every element. This will most likely be a problem when you have a huge list.\n\nThis is the classic median method in CS.\n\nThe median method will be O(n log n) in the general case if n is large. The more common quick-and-dirty algorithm, while not O(n log n), will be O(n), and is quite a bit faster when the list is short.\n\nI don't know how to be an asshole about this, but why would you do something like this in Python? This seems like something that should be in C++ or Java, so you can actually make it run at decent", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l.sort(key=lambdax: x.min()), key=='min'\nWhat am I missing here? Shouldn't the answer be (3, 1, 2, 4, 5)? Or am I not understanding the syntax?\n\nI think it's saying that if you want to return the median element of the list, you should take the list and sort it (using the built-in sort() function) by the element that you want to be the median, and then return the element that was the median of the list.\n\nNo, that's the definition of median. The poster was asking what's the value of `l.sort(key=lambdax: x.min()), key=='min'`.\n\nThe answer is that the list is sorted by the first element, and then the median is the first element with respect to the sorting function. So, if the sorting function is a binary sort (the default), then the median is the median of the first two elements. If the sorting function is median, then the median is the median of the first element.\n\nThanks. Makes sense now.\n\nIt's a good interview question. If they ask it", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    from collections import defaultdict\n    l = defaultdict(int)\n    for i, elem in enumerate(l):\n       median = median(elem)\n    return median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (int(ord(l[1])) / 2 + int(ord(l[2])) / 2 + int(ord(l[3])) / 2 + int(ord(l[4])) / 2 + int(ord(l[5])) / 2)\n    def median_dist(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median_dist([3, 1, 2, 4, 5])\n    3\n    >>> median_dist([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return (int(ord(l[1])) / 2 + int(ord(l[2])) / 2 + int(ord(l[3])) / 2 + int(ord(l[4])) / 2 + int(ord(l[5])) / 2)\n    def median_dist_new(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median_dist_new", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[::-1]", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median(l: list, step: int=0, *args: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5], 1)\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20], 2)\n    15.0\n    \"\"\"\n    if len(l) < len(args):\n         return l\n    result = []\n    while len(l) > 0:\n         result.append(l[-step])\n         if (l[-step] < arg[-step]):\n            result.append(arg[-step])\n          result = median(l[-step], step, args)\n    return result\n    @param step\n    @return\n    def sort(l: list, key=None", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[l.length() / 2]\nI was just thinking of this recently. I had to write a median function and did not remember this one. I was at my mother's house and I asked her to bring me her math book. I found it, flipped to it, and found this function. I was so happy, it was like winning the lottery.\n\nI'm guessing it's worth a few points on the SAT:\n_A good technique for solving this problem is to create a list of all the\nnumbers from smallest to largest. Then create a second list in which you\nplace a 1 at the position of the middle number in the first list. Then\nsum the first list and the second list. If the sum is less than the\naverage of the first list and the second list, that is the middle number._\n\nHooray! I can't wait until I'm in the third grade again.\n\nI was thinking the same thing. Except I was going to say it in a slightly different way.\nI think this is a wonderful example of the \"don't write code, write math\" concept that so many people talk about. You are solving a real-world problem,", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    \"\"\"return l[0] if l is sorted else return l[0]\n    if len(l) == 1:\n        return l[0]\n    elif len(l) == 2:\n        return l[1]\n    elif len(l) == 3:\n        return l[0]\n    else:\n        return l[0]\n\nWhen a list is sorted, the median function is O(l). When the list is not sorted, the function is O(l*n).", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l.pop()[1] + l.pop()[0]) / 2\nI think it should be (l.pop()[0] + l.pop()[1]) / 2.\n\nI'd go with  (by using the expression `l.pop()[1]` instead of `l.pop()[0]` you get a faster implementation as it doesn't need to perform an additional pop operation).\n\nIf you do median(l: list) you also don't need to perform an additional pop operation.\n\nI think the argument is that you need to pop the list twice in order to do the calculation.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (x[0] + (x[1] - x[0]) / 2) / 2\nNote that this is not the most efficient way to find the median. Also, it only works for lists of integers.\nI would suggest using a heap to find the median efficiently:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = 0\n    for i, el in enumerate(l):\n       if el[0] > median:\n          median = el[0]\n       el[1] = median\n    return median\n\nThis is one of those neat little tidbits that makes me wonder why the hell I never thought of it.\n\nI'm trying to understand why this is a \"neat little tidbit.\" To me it looks like a basic technique for computing the median of a list, and can be implemented more succinctly, for example:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[1] + l[2] + l[3] + l[4] + l[5]) / 6\n\nAnother solution:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return len(l) == 2? l[0] : l[1]\n\nThis works fine on my computer, but not in Python 3.\n\nWithout all the context, it's hard to know if your problem is with Python or with your solution. Try running it in Python 2.7 (not 3.2) and see if it works. If it does, then you'll have to figure out how to fix it in Python 3. If it doesn't, then you'll have to figure out how to fix it in Python 2.7.\n\nIn Python 3, it's a type error. The correct solution (which is not the one shown by the article) would be to use the zip() function:\n\nI'm not sure how this is an improvement, or even related to, the article.\n\nI wasn't trying to improve upon the article, but to show an alternate way of doing it. The article shows a simple but wrong solution to the problem, and I thought I'd show one that would work in Python 3.\n\nYup, a simple solution that is wrong.\nI thought you were claiming that zip() was the \"correct\" solution, but I see now that", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l)!= 2:\n       raise ValueError(\"l must be a list of length 2 or greater\")\n    return l[0]\nThe problem is, I don't know how to make a function that \"returns\" a list. I only know how to make a function that returns a value.  I also don't know how to make a function that can be passed a list and then return a value.  I only know how to make a function that can take a variable number of parameters and return a value.\nSorry, I misunderstood.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(l[i] for i in l if i < l.size()/2) / 2\n\nI guess it would be nice to know how the median function works in the first place.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(abs(l[0] - l[1]), abs(l[1] - l[2]));\nThe max() can actually be replaced with a list comprehension, which I find to be far more readable:  [0,1] for l in range(len(l))\nMedian is a weird function to use as an example, though. If you're sorting a list, you're going to be better off using the builtin sort() function than using any of the sort-like functions.      sorted([3, 1, 2, 4, 5], key=lambda x: x[1], reverse=True)  will yield a sorted list with the first element being 3.\nI'd still prefer to see      sorted(l, key=lambda x: x[1], reverse=True)\nThat's a matter of taste. I prefer to use explicit lambda expressions when possible.\nI agree, but I think you should use the lambda where it's going to save keystrokes.  There's a ton of white space in between, and most people will still know what you're talking about.  It's a fairly common thing to", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l) < 2:\n        return 0\n    elif len(l) > 1:\n        return min(l[0], l[1])\nThis is the first solution I came up with too, but it's probably not the best.  I am interested to know what a 'better' algorithm might be.  Perhaps something like this:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (min(l), max(l))\nWe can probably make this a little more efficient by using the BitSet class instead of a list of integers.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    \"\"\"Median of elements in the list l.\"\"\"\n    \"\"\"If there is no median in the list, return an empty list.\"\"\"\n    return l.median()\n\nThe median of the list [1,2,3,4,5,6,7,8,9] is 3, and the median of the list [10,20] is 15.\n\nThe median of a list (or of any other sequence) may be calculated using the following simple algorithm:\n\n1. Remove all of the numbers from the list that are larger than the median.\n2. Remove all of the numbers from the list that are smaller than the median.\n3. If the number of numbers remaining is equal to the length of the list, then the median is the number in the middle of the list.\n4. Otherwise, repeat step 2.\n\nThe median is the middle element in the list if and only if the number of elements that are larger than the median is equal to the number of elements that are smaller than the median.  In the examples above, that condition holds.  The median of the list [1,2,3,4,5,6,", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return min(l[::-1], key=lambda x: x[1]):", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l) - min(l)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return [0]\nThat's not the median of the list, that's the median of the array of ints you're returning.  You're not calculating the median, you're just returning the value at the median.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    result = 0\n    for i in range(len(l)):\n        if i % 2 == 0:\n            if i < len(l):\n               result = l[i]\n              else:\n                result = l[i - 1]\n           result += l[i]\n    return result\nmedian is not a method of the list. It is a method of the median class.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(l.pop() if pop else l.pop) / len(l)\nI think the above is the simplest one I could come up with.  Feel free to shoot it down with a simpler one.\n\nWouldn't it be simpler to use numpy.median?\n\nSometimes its nice to stick with one language.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median_range(l: list, r: int):\n    \"\"\"Return median of range of elements in the list l.\n    >>> median_range([-10, 4, 6, 1000, 10, 20])\n    10.0\n    \"\"\"\n    median_range = median(l)\n    median_range = median_range(l, r)\n    return median_range", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median_key = None\n    for x in l:\n        if x < median_key:\n            median_key = x\n        else:\n            median_key = None\n    return med(l, median_key)\nI like this.\nIf you want to be able to ignore the keys which are bigger than a certain value, you could use a binary search.  Instead of looking at the second key, you could use the third key, which is a third of the way from the beginning.  The median will be in the middle of the list.  If you add a `key` variable which keeps track of where you are in the list, this will work.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\nIf you have a list of numbers, it's always faster to use the built-in len() function to get the length and then use the built-in medians() function to calculate the median.\n>>> medians([3, 1, 2, 4, 5])\n3\n>>> len(l)\n4\n>>> medians(l[:4])\n3\n\nIt's also faster to use len() to get the length of the list, and then use the built-in median() function to calculate the median.\n>>> len(l)\n4\n>>> median(l)\n3\n>>>\n\n_It's also faster to use len() to get the length of the list, and then use the built-in median() function to calculate the median._\nI was hoping this wouldn't be the case, but it does look that way, in all my tests. The following code is quite a bit faster than your \"built-in median()\" approach, though:\n>>> len(l)\n4\n>>> n = len(l) - 1\n>>> n[0:4]\n[1, 2, 3, 4]\n>>> median(l[0:n[1", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    l = [i for i in l if i % 2 == 1]\n    return mid(l, 0)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    x = [x]\n    for x in l:\n        if x[0] < x[1] < x[2]:\n            return x[0]\n    return x[1]\nShouldn't it return the median of all elements in l, not just the first one?\n\nYeah, you are right. Fixing it, thanks for the catch!\n\nfor x in l:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l) - min(l)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\n    return list(l, sum(l), [l[0] - l[1] for l in l if sum(l) > 0])\nThis is the correct answer.  Using the first suggestion will not work if the elements have the same value.\nHowever, this solution has the same problem:\n>>> median([3, 2, 1])\n1\n>>> median([3, 2, 1], sum(l), [l[0] - l[1] for l in l if sum(l) > 0])\n1\n\nThis is because Python defaults to list(l, sum(l)) as the default for a range object. In this case, the default is not a list and thus has no sum() function.\nYou have to use list(l, sum(l)) rather than [l[0] - l[1] for l in l if sum(l) > 0] to get the correct result.\n\nThe range.list() function is a list, just not a Python list.\n\nOh, I see, I don't think I've ever used range.list() before. It doesn't seem to be very useful though, since there's no", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l)\nThat is a totally different method. It does not return the median of the list, but the element in the list with the greatest value.\nYou're right. I think I fixed it, thanks.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = []\n    for i in range(len(l)):\n       median.append(i)\n    return median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\n    def mean(l: list):\n    \"\"\"Return mean of elements in the list l.\n    >>> mean([-10, 4, 6, 1000, 10, 20])\n    27.0\n    >>> mean([3, 1, 2, 4, 5])\n    8.0\n    \"\"\"\n\n    def mean_median(l: list):\n    \"\"\"Return mean of median of elements in the list l.\n    >>> mean_median([3, 1, 2, 4, 5])\n    12.0\n    >>> mean_median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n\n    def measure(l: list):\n    \"\"\"Return mean of elements in the list l.\n    >>> measure([3, 1, 2, 4, 5])\n    27.0\n    >>> measure([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[int(x) for x in l if int(x) > int(l[x])]", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return min(l, key=lambda x: x[1])\nWhat's wrong with this code? \n\nI think it's possible to get a similar result with:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return lambda x: len(x) / 2\n\nI didn't realize this would be implemented with `lambda`.\nThis is great, and I've written similar functions that return the mean or mode of a list.\n\nI'm not sure what you're saying, but `lambda` is a built-in function that is implemented by Python.\n\nYes. I'm familiar with `lambda`. I didn't realize it was an implementation of median.\n\nIn other words, a neat feature of Python is that the built-in functions can be implemented using the built-in syntax, thus avoiding namespace pollution.\n\nI think this is a good example of what the author is talking about with \"magic.\" Why is `median` a function? It could just as easily have been a method on `list`.\nAnd how does it know to return the middle element? That seems like a decision that should be made by the caller of the method.\n\nThe same way `cbrt` is a function. I don't know why you think it should be a method.\nIt doesn't know to return the middle element. It just does, because that's what it does.\n\nTo be fair,", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\n    return l[l.index(i) % len(l)]\n\nWhat about median_over_range?\n\nYes, that's the more general version that comes up in the book.\n\nAny example of use case for this? I'm curious\n\nSomething like:</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(l) / len(l)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = 0\n    for element in l:\n       median = median + abs(element - median)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\n    median = lambda l: (l[1] + l[2]) / 2\n    return median(l)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[1] + l[2] + l[3]) / 3\n\nAnd, if you're really feeling like doing it wrong,", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return 0\n    # x is an index into the list\n    x = len(l) - 1\n    # x is a number between 0 and len(l) - 1\n    median = sum([x + 1 for x in l if x > 0] / len(l))\n    return median\n\nInstead of using the Python \"operator overloading\" mechanism, you could just define a function \"median\" that takes a list as a single argument, and returns the median of the list. Then, you could use this:\n>>> median([3, 1, 2, 4, 5])\n3\n>>> median([-10, 4, 6, 1000, 10, 20])\n15.0\n\nI'm not sure why you are doing this in Python. A quick C++ implementation is:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = sorted(l.values, key=lambda item: item.value[0])\n    median = sorted(l.values, key=lambda item: item.value[1])\n    return median\nWhat makes you think that the median of [3, 1, 2, 4, 5] is 3? This isn't even close to being true. The median of that list is 1.\nThis code is awful, and I don't understand why it's getting upvoted.\n\nI also think the code is awful, but I can see that the median of [3, 1, 2, 4, 5] is 3.\nThink of the list as a simple array. A median is defined as the value that divides a sorted list in half. This is a pretty good definition for this particular list.\nAn item in the list is a number between 0 and 5, so by definition the median is also between 0 and 5. The first element is 3, the second element is 1, the third element is 2, and the fourth element is 4. The fifth element is 5.\nThere are 4 numbers between 3 and 5, and 3 numbers between 1 and 5. The median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = 0\n    for item in l:\n       if item[0] < item[1] and item[1] < item[2]:\n          median += item[2]\n       else:\n          median += item[0]\n    return median\n\nIt looks like you are asking for the median of the _total_ of the list. You can get the median of a list by looping through the list and keeping the index of the median, then the index, the current element, and the current element + 1. For example, in [3, 1, 2, 4, 5], the median would be 3.\nIn [3, 1, 2, 4, 5], median = [3, 1, 2, 4, 5].\nIn [3, 1, 2, 4, 5, 6, 7, 8], median = [3, 6, 7, 8].\nIn [3, 1, 2, 4, 5, 6, 7, 8, 9], median = [3, 7, 8, 9].", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(min(l.items(), key=lambda x:x[0]), key=lambda x:x[1]\n            )\nThat's not correct. It's \"max(min(l.items(), key=lambda x:x[0]), key=lambda x:x[1] if x is not None)\"\nWhy is this the \"correct\" version?    I'd use min() because I like to think of it as a way of subtracting the first number in the list from the rest, making it the \"most-common\" value.    If x is None, then the subtraction has no meaning.  I've never used `max()` before, but I think it works similar to min, in that it returns the largest value in the list.\nMax is just like min, except that it is O(n) and not O(logn)</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(i: l) / len(l)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    from itertools import combinations\n    from math import sqrt\n    def _to_median(lst):\n    \"\"\"Given a list of elements, return a median for it.\n    >>> from median import _to_median\n    >>> lst = [1, 2, 3, 4, 5]\n    >>> lst_median = _to_median(lst)\n    >>> print lst_median\n    [1, 3]\n    \"\"\"\n    med = 0\n    for element in lst:\n       if element <= med:\n          med = element\n       else:\n          med = sqrt(element/lst.size())\n    return med\n    _to_median(lst)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l) == 2:\n       return sum(l[0]) + sum(l[1])\n    else:\n       return sum(l[1]) + sum(l[0])\n    The issue here is that the above code is for lists that are sorted, but when I try to apply it to lists that are unsorted, it doesn't give me the correct result.\nIs there any way I can use Python to find the median of unsorted lists?</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[(a[i] * a[j]) + b[i] * b[j] for i in range(len(l)+1, 2)]\n\nYou might want to add:\n\nreturn l[(a[i] * a[j]) + b[i] * b[j] for i in range(len(l)+1, 2)] / 2\n\nto prevent the list from getting in sorted order as a result of the median operation.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\n    return sum(l.pop() / l.size() for l in l)\n\nSee also\n Arbitrary-precision arithmetic, used to implement the various forms of\nmedian.\n Central limit theorem\n\nExternal links</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0] + x[1] / 2)\nNote that the median of a sorted list is the midpoint of the sorted list, not the midpoint of the original list. This is important if you are going to use median to determine if a list is sorted.\nThe median of a list of equal length elements is the element with the middle index (i.e., sum of elements divided by number of elements).\n\nIt's not quite the midpoint of the sorted list. It's the midpoint of the list when sorted by the first element in each of the elements, that is, the median.\n\nAs the \"key\" function in the article's code is really just an identity function, this is indeed the midpoint of the sorted list.\n\nIndeed, thanks for pointing that out!\n\nI wanted to be able to use the median of a list in a binary tree, but I could never figure out how to implement it in a fast and efficient way.\nIf anyone has a tip for me, I'd be happy to hear it.\n\nYou can easily calculate the median of a list in C#:\nval median = List", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1] - x[2])\n`the sort function is not defined for list`</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l):\n       return (x / len(l) for x in l)\n    else:\n       return [x for x in l if x % len(l) == 0]\nYou should probably use the Pythonic way of finding the median, which is to find the middle element of the list, and return that.  This is much more efficient.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    \"\"\"\n    median_of = lambda x: x[1]\n    l = [x[0] for x in range(len(l))]\n    return list(setdiff(l, median_of(l)))\n>>> median_of([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n3\n\nMedian is an interesting and useful function. It's not a function that is likely to have been built into Python's standard library, however. The median function is a rather odd function that, in an imperative language, would have to be implemented with a recursive algorithm. I don't think I've ever heard of a recursive algorithm being written in Python.\n\nIt's not as hard as you might think. The fastest way to find the median in a list is to simply sort the list (assuming it's sorted already), and find the middle element.\n\nLet's look at an example.\n\n>>> median([1, 2, 3, 4, 5, 6])\n3\n>>> median([1, 2, 3, 4, 5, 6, 7, 8, 9])\n7\n\nWe", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median(l: list):\n    \"\"\"Return the median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    if l == [] or len(l) == 0:\n       return 0\n    return l[len(l)-1]\nIf you use len(l) - 1 it also works for non-integer elements in the list.\n\nThis works for all lists, even if the list is not sorted.\nThe median can be computed as the midpoint of the range of a sorted list.\n\nIf you have a list with too many elements then this is a better way to do it:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(l.pop(0) for i in xrange(len(l)) - 1) / 2\nThis is why Python is awesome.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def mean(l: list):\n    \"\"\"Return mean of elements in the list l.\n    >>> mean([3, 1, 2, 4, 5])\n    4\n    >>> mean([-10, 4, 6, 1000, 10, 20])\n    13.0\n    \"\"\"\n    return sum(l) / len(l)\nI think you'll find that the median and mean are often quite different.\nYou might want to use the median as a check if the mean is implausible:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda l: sorted(l, key=lambda x, y: x[1])\n    return median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\n    def min(l: list):\n    \"\"\"Return smallest element in the list l.\n    >>> min([3, 1, 2, 4, 5])\n    1\n    >>> min([-10, 4, 6, 1000, 10, 20])\n    6\n    \"\"\"\n\n    def max(l: list):\n    \"\"\"Return largest element in the list l.\n    >>> max([3, 1, 2, 4, 5])\n    5\n    >>> max([-10, 4, 6, 1000, 10, 20])\n    20\n    \"\"\"\n\n    def average(l: list):\n    \"\"\"Return sum of elements in the list l.\n    >>> average([3, 1, 2, 4, 5])\n    15.0\n    >>> average([-10, 4, 6, 1000, 10, 20])\n    25.0\n    \"\"\"\n\n    def sum(l: list):\n    \"\"\"Return sum of elements in the list", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return 0\nThis does not return the median but rather the number of elements in the list.  The function you are looking for is:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] / l.size() + l[1] / l.size()) / 2\n\nReally?\nI'd use a quick calculation of the second half:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return [(l[0] / len(l) for l in l] / l.length)\n\nThis is a nice, simple solution. However, wouldn't it be better to use a different data structure? Since we are going to be iterating over the list a lot, why not use a sorted list or array? That way, we have O(n) performance. It's also faster to find the median of a sorted list than of an unsorted one.\n\nIf you have to do the math, then what's the point of using a computer?\n\nThat is a problem if you're looking for the median of a random list of numbers (like a set of random scores in a game), but if you're finding the median of a list of numbers that you have previously sorted by some other criteria, then it is faster to use a sorted list.\n\nThe same can be said about O(1) solutions that depend on a pre-sorted list.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda x: x.pop()[0]\n    return len(x) / 2\n\nI don't know much about list comprehensions, but doesn't this code go to infinite recursion?\n\nThe `len` function returns the length of a list. However, `x.pop()` returns a list of elements from a list, so `len` does not need to be called. The result will be the `len` of the original list.\n\nOh, thanks!", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2] + l[3]) / 4\nIn Ruby you can do the same thing, but also be concise:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[1] - x[0])\n\nThis is a very interesting way to use the sorted() function!\nIt's interesting in the sense that it's very well suited for a small set of data (the median of a list of numbers) but one would not think about using sorted() for this at all.\nI think it's a common misconception that the sorted() function is only useful for sorting, when in fact it's also a list-comprehension tool.\n\nI had the exact same reaction. It is something I'm going to have to remember when I want to sum all the numbers in a list in a non-linear fashion.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    # Build median from the first (least significant) elements.\n    median = ((first, elt): elt in range(1, len(l))\n        if elt < first):\n            median = first\n        else:\n            median = median + elt\n    return median\nDoesn't the OP's method make the same tradeoff?\n\nThis is probably going to sound like a criticism, but I don't intend it as such. I just want to point out something that the median function in the article could have done more efficiently.\nI think the article's median function should be changed to take a single parameter, called left_index. Then the function could be changed to return the median in left_index * i, for each value in the list. Then, when we wanted to find the median of a list of length n, we'd call median(l,n).\nI think this would be more efficient, since it wouldn't involve a looping construct.\n\nOf course it will be more", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    med = 0\n    for i in l:\n        med = median(i)\n    return med\n>>>\n\n>>> def min(l: list):\n    \"\"\"Return the smallest element in the list l.\n    >>> min([-10, 4, 6, 1000, 10, 20])\n    6\n    >>> min([1, 2, 3, 4, 5, 6, 7, 8])\n    3\n    >>> min([10, 20, 30, 40, 50, 60, 70, 80, 90])\n    20\n    \"\"\"\n    min = 0\n    for i in l:\n        min = min(i)\n    return min\n>>>\n\n>>> def minmax(l: list):\n    \"\"\"Return the minimum and maximum elements in the list l.\n    >>> minmax([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    [3, 7]\n    >>> min", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (sum(x[i] for i in list if x[i] > x[i + 1] and x[i] < x[i - 1])) / len(x[i] for i in list)\n\nI know this is really more suited to /r/learnpython, but I've always thought this was kind of cool.\nI think a lot of the time I will do this instead of sorting a list when I don't need to know the order. It's a really nice function to have.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    else:\n       return l[1:]\n    def mean(l: list):\n    \"\"\"Return mean of elements in the list l.\n    >>> mean([3, 1, 2, 4, 5])\n    7.0\n    >>> mean([-10, 4, 6, 1000, 10, 20])\n    55.0\n    \"\"\"\n    if len(l) == 1:\n       return l[0]\n    else:\n       return l[1:]\nI think this is an interesting example of how most developers tend to implement these functions.  I've been reading through that book, too, and I like it, but I find that I have to stop and think about the logic in a lot of the solutions in order to really understand what's going on, and the solutions are generally not very short.\n\nI've been trying to make an effort to avoid those kinds of solutions, and I", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n        return l[:len(l)-1]", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\nYou can use it with lapply, like:\n>>> median(set(range(10)))\n6\n>>> median(lapply(median, range(10))))\n4.0\n>>> median(lapply(median, range(10)))[::-1]\n0\n\nThat's awesome. I'll add that.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[l[l[1]]]\nThis is completely pointless - you might as well just do:       (l.sort()).index(0)\nTrue, but it was an exercise.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = [x for x in l if x[0] > x[1] for x in l]\n    return median[-1]\nI'd use sorted(l).  Edit: Actually, sorted(l.sort()) would probably be more efficient.\nIf you use sorted, you have to worry about the case where l is sorted but the elements are not (e.g. an array with an even number of elements).  As long as you're using median for a range that's not infinite, though, that's not really a problem.\nYou also have to worry about the case where l is not sorted.\nOh right, I was reading this assuming that the elements in l were ordered, but I didn't say so.  In that case, sorted(l.sort()) is the right answer.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    result = []\n    for i in l:\n       if i % 2 == 0:\n          result.append(i)\n    return result[0]\n\"But what if I want to find the median of a negative number?\"\n\nFor a list of integers, the median is the integer which is in the middle.\nIn this case it's zero.\n\nWow, it's been a long time since I took a stats class and forgot all about the median.\n\nI'm not even sure I've ever heard of it in my life, and I'm not sure how it could be useful.\n\nThe median is not only the most common value in a list of numbers, it's also the most _typical_ value, the one most typical of the whole list. (In other words, if you took 100 lists and their medians, you'd see the median of the 100th list more often than the others, and more often than the median of any single list.)\nIt's useful for many things, from estimating central tendency (how \"typical\" is this data?) to performing non-parametric", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = [x[i] for i in range(l.size())]\n    return x[i]\n    # [1, 2, 4]\n    median(l) # [2]\n\nor to answer the question with the least number of lines:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda x: x[0] / x[1:]\n    if len(l):\n       return median(l)\n    else:\n       return 0", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    # Test if the list is empty\n    # If the list is empty, return None\n    if l.is_empty():\n       return None\n    # Compute the length of the list\n    # This can be done using len(l)\n    length = len(l)\n    # Compute the median\n    median = 0\n    while length > 1:\n       median = median + (l[i] * (l[i] + median)) / (l.size() - 1)\n       if median >= length:\n        return median\n    return None\n\nThis is the same as the non-recursive solution:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    l = sorted(l)\n    median = min(l[0], l[1]) + min(l[1], l[2])\n    return median\n\nThis is just one more example of a naive solution that works but that is quite slow.\n\nThis solution is O(n log n). A better solution for small n is to use a heap sort.\n\nI don't know if heap sort is still in Python's standard library, but it's easy enough to write if you want.\n\nsort.heap() is in Python 2.x.\n\nIt's not clear that the OP does in fact want to find the median.\n\nmedian is a monotonic function, which means that the min and max elements are always in sorted order. Heap sort works by swapping the min and max elements of the list to form a heap, and then swapping the heap elements to find the median. If you sort a list of numbers from largest to smallest, the numbers that are smaller than the largest number in the list will always be on the left of that number, and larger numbers on the right.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return [(i, j) for i, j in zip(l, range(len(l))) if i > j]\nI was expecting a function to return the median of a list of numbers.  This is actually a function to return the median of the elements in a list of lists.  I'd rather have a function that just works on numbers.  If I have a list of numbers, I want to get their median.  I don't want to do any grouping or looping.\nHey, I'm just quoting what's in the docs.  If you want to fix it, go right ahead.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\nThis is not \"The fastest median function in Python\" it is the simplest, and most direct implementation.\nThe fastest median function in Python is the one in the standard library\n\nAuthor here. I was hoping people would show me the way to the fastest median, not the fastest median in the standard library.\nMy median function is about 4x faster than the median function in the standard library.\nI'm looking at Python 2.7.x, so I don't know if it's different in Python 3.\n\nI was thinking about that after I posted. I am not sure what the fastest median would be. The median in the standard library appears to be fast.\nThe fastest median I could think of would use iterators. Something like this\n\nThis doesn't look much faster than the standard library. I think the iterators are more complicated.\n\nIt is a little faster on my machine. The iterators are a little complicated, but they are only used to construct the iterator objects. The rest of the code is the same.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    \"\"\"Given a list l, return the median element.\n    >>> median(['a', 'b', 'c', 'd'])\n    'd'\n    \"\"\"\n    def median(l: list):\n    \"\"\"Return the median element in a list.\n    >>> median([1, 2, 3, 4, 5])\n    3\n    \"\"\"\n    median_f = None\n    l.sort()\n    for i, x in enumerate(l):\n        if l[x] > median_f:\n           median_f = l[x]\n          return median_f\n\nWhy do you have a \"def\" function in a \"try\" block?\n\nMaybe he accidentally typed `def` instead of `defer`.\n\nOr he was trying to post code he wrote in another language.\n\nSomething like this is really useful, but I'd like to see a function that is smarter about the type of objects it is comparing", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l.pop()[0] if l.pop()[0] else l.pop()[-1]) / l.size()\nShould be", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    result = 0\n    for i in l:\n        result = result + i\n    return result\nIn Python 2:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = [l[0] for l in list]\n    while len(median) > 1:\n       median[0] = median[1]\n       median[1] = median[2]\n    return median\nYou could also write it as:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    val median = function(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median(['A', 'B', 'C', 'D'])\n    A\n    >>> median(['A', 'C', 'A', 'A', 'D'])\n    D\n    \"\"\"\n    return (l[0] + l[1]) / 2\n\nThat would be median, not mean. The mean is:\n>>> median([3, 1, 2, 4, 5])\n3\n>>> mean(median([3, 1, 2, 4, 5]) / 5)\n5\n\nYeah, that was a typo. I'm a big fan of the mean and std.dev for lists:\n>>> median(['A', 'B', 'C', 'D'])\nA\n>>> mean(median(['A', 'C', 'A', 'A', 'D']) / 5)\n4.33333\n>>> std.dev(median(['A', 'C', 'A', 'A', 'D']) / 5)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (sum(l.pop(0)) / len(l)) + min(l)\nfor x in range(len(l)):  # this is a little redundant\n    x = l[x]\n\nThis is just a little more verbose than a call to the built-in `min()`.\n\nIt's not a built in function in Python 2.\n\nI never use anything that isn't a built in function in Python 2.\n\nIt's a built in function in Python 3.\n\nWhen I'm writing Python 2 code, I'm writing Python 2 code. When I'm writing Python 3 code, I'm writing Python 3 code.\n\nI don't know why the article author used the module object as the return value in the function he was passing to __add__. In Python, the default return value from a function is the last expression evaluated by that function.\n\nThe last expression evaluated is only a valid return value in Python 2. In Python 3, the return value is whatever was specified.\n\nThe median function is also in the standard library:\n\nMedian is not in the standard library, but the function _median_ is.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\nThanks, I'm still trying to get used to all the syntax.\n\nNote that if you want to do this with collections, you can use the built-in median method of the itertools module:\n>>> from itertools import medians\n>>> medians(['a', 'b', 'c', 'd'])\n[0, 1, 2, 3]\n\nThis is a great article. I have a few questions about the numpy.sort function.\nI am trying to use the Numpy.sort function to sort a list of words.\nwords = []\nfor word in \"dog\", \"cat\", \"mouse\" :\nwords.append(word)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l.pop(0), l.pop(1) - l.pop(2)) / 2\nThis is wrong.  It should be\nreturn (l.pop(0), l.pop(1) - l.pop(2)) / 2\ninstead.\n\nI changed it to:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    # Python 3\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return l[2]\nPython:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    val mid = 0\n    while l:\n       if l:\n           mid += 1\n           l = l[mid]\n        else:\n           mid = l[0]\n           mid += 1\n    return mid\nIn python:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median(x):\n    \"\"\"Return median of x.\n    >>> median(range(5))\n    2\n    >>> median([3, 5, 7, 9])\n    3\n    \"\"\"\n    return x[::-1]\nYou're thinking of the geometric mean. The median is the middle value of the list, not the \"middle value of the range\".\n\nI don't know, the median of a list of numbers (e.g. 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17) is the same as the mean of those numbers (in this case, 6). That seems like a reasonable definition of median.\n\nAnd the median of a list of even numbers is the same as the mean of those numbers.\nThe median of the range [1,10] is 10.\nThe median of the range [10,20] is 20.\nThe median of the range [-10,10] is 10.\nThe geometric mean of a list of numbers is the same as the", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\n    return (1.0 / l.size)\n\nIt's kind of mind-boggling that such a function isn't part of Python.\n\nI just read the source of the median() method to see why it doesn't use the simple (and correct) algorithm you suggest.\nThe only answer I can come up with is \"because it was added in a hurry, and the author thought the existing algorithm was just as good\".\n\nThe reason is that it's not exactly correct. The median of a list of different length will change based on the order you remove elements from the list. For example:\n>>> median([2, 1, 3, 5], [2, 1, 3, 5]) 3\n>>> median([1, 2, 3, 4, 5], [1, 2, 3, 4, 5]) 5\n\nI think the point was that the right answer depends on how the function was used, and there's no way for the user to specify how the function should be used.\nIf you want to find the median of a list of numbers, then you want the first method. If you want to find the median of a list of arbitrary values, then the second method is the", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\n    def mean(l: list):\n    \"\"\"Return mean of elements in the list l.\n    >>> mean([3, 1, 2, 4, 5])\n    3.3333333333333333\n    >>> mean([-10, 4, 6, 1000, 10, 20])\n    3.0\n    \"\"\"\n\n    def count_if(l: list):\n    \"\"\"Return the number of elements in the list l that satisfy a predicate.\n    >>> count_if([-1, 1, 3, 5, 7, 9])\n    3\n    >>> count_if([-1, 2, 2, 4, 5, 6])\n    1\n    >>> count_if([1, 3, 1, 5, 3, 9, 7])\n    3\n    \"\"\"\n\n    def min_if(l: list, p: boolean, q: boolean):\n    \"\"\"Return the smallest element in the list l that satisfies a predicate.\n    >>> min_if(l=[1, 3", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    l = sorted(l)\n    return [l[0] + l[1] / 2 for l in l]\nA simpler solution is to return a sorted list (and more efficient if there is a lot of items), and then call the median function on that list:\n>>> median([3, 1, 2, 4, 5])\n3\n>>> sorted([3, 1, 2, 4, 5], key=lambda item: item[0], reverse=True)\n[3, 1, 2, 4, 5]\n>>> median(sorted(sorted([3, 1, 2, 4, 5], key=lambda item: item[0], reverse=True))))\n3\n\nI still don't see how this is simpler or more efficient. The code you posted is more complicated, involves more nesting, and requires more memory (or an external sorting function) to construct the sorted list.\n\nIn Python, the sorted() method is part of the built-in collections module. Therefore, there's no external sorting function involved.\n\nBut if you wanted to use this as a function, you'd need an external sorting function.\n\nLooks like a pretty good way", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    # numpy.__version__ == '1.5.0'\n    # numpy.__version__ == '1.5.1'\n    def __getitem__(self, idx, j: int, k: int):\n    \"\"\"Return median element in list l at position idx.\n    >>> median([3, 1, 2, 4, 5], 2)\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20], 2)\n    15.0\n    \"\"\"\n    numpy.array(l)\n    i = 0\n    while i < len(l):\n       i += 1\n       i = (i + 1) % len(l)\n       if j > 0:\n           if k > i:\n                return j", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median_comb(l: list, m: number):\n    \"\"\"Return median of list elements that contain m.\n    >>> median_comb([3, 1, 2, 4, 5])\n    3\n    >>> median_comb([-10, 4, 6, 1000, 10, 20])\n    15\n    \"\"\"\n    def median_comb_base(l: list, m: number):\n    \"\"\"Return list median of elements that contain m.\n    >>> median_comb_base(['3', '1', '2', '4', '5'], 10)\n    [2, 3]\n    >>> median_comb_base(['-10', '4', '6', '1000', '10', '20'], 10)\n    [15]\n    \"\"\"\n    def median_comb(l: list, start: number, end: number):\n    \"\"\"Return median of elements in the list l that contain start and end.\n    >>> median_comb(['3', '", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return int(l[0].value) + int(l[1].value) + int(l[2].value) + int(l[3].value)\nI don't think that works the way you want it to.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return len(l)-len(l[1])\nWhat happens when the lists are not of the same length?  EDIT: actually that's irrelevant, I guess. The median function should work whether the lists are of the same length or not.\nAlso, this code will only work with lists of integers.\nIn the real world, that doesn't matter.\nI disagree. If I was writing a sorting algorithm, I wouldn't want it to stop when the input data was not integers. It would be much better to handle the non-integer input gracefully.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n        median = lambda x: (x,x)\n        for element in l:\n            if element < median:\n                median = element\n                 return median\n\nAs a Python programmer, I know I don't have to worry about what the compiler is doing and instead can focus on the logic of the program. I know that Python will keep me from shooting myself in the foot.\nI don't think that a language can compete with Python in terms of ease of use.\n\nI hear this a lot, but I'm not sure how accurate it is.\nI think there are a lot of programmers who are happy working in Python because they have been working in Python for a long time, and therefore have a lot of experience with Python idioms, which they can apply to any Python code.\nI don't think I've ever seen a Python programmer switch from Python to another language and still write Python. I've seen them write C or Haskell or Perl or whatever.\n\nIf", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = 0\n    while len(l) < 5:\n       median = median + (2 * (l[1] - l[0]))\n    return median\nI've always used Python for this sort of thing, but for some reason in C++ this is taking an excessive amount of time.\nIs this a problem with my algorithm?\n\nYour algorithm is correct. But in C++ a list is a reference type which means that you have to make an extra copy of it before you can use it in a function. This is a bit like creating an array and then using its address to make a copy of it. That's a lot of extra work.\nIf you want your function to be fast, use a struct:\nstruct median {\nint median;\n};\nThen you can call the median function like this:\nmedian_of_list(list)\n\nAh, thanks. That does seem to be an improvement.\n\nI'm interested in how well this scales.\nI've never used Python, but since Python is interpreted, I imagine it is possible to make the interpreter do the work of scanning the whole list, even if", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l.pop(0).reduce(lambda x,y: x+y, 0)\nThis will throw an IndexError if you don't pass in the range.\n\nYes, it's a good point.\n\nOops, I meant to say that in my reply.\n\nWhy is this called \"median\" rather than \"average\"?\n\nMedian is the middle value of a set. Average is the sum divided by the number of values.\n\nWell, average _is_ the mathematical median, because the mathematical median of a set of numbers is the number which is the middle of the set.\nBut, in practice, people mean average as a weighted average of some sort, and the average of the above list is not going to be 3.\n\nIn practice, people mean average as a weighted average of some sort, and the average of the above list is not going to be 3.\nIn other words, average is a very poor choice of name. The median is not the average, and it is a much more useful quantity.\n\nWhich is why in some applications you can type\n=average(x,y,...)\nand you get the median, not the average", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\n    median = lambda l:l[0] if l[0] < l[1] else l[0]\n\nI'm not getting it. Could someone explain this one to me?\n\nLambdas are anonymous functions. The one above returns the median of the elements in list l, provided that they are not sorted (so that if l[0] < l[1] then it is l[0] that is the median).\n\nIt's a good joke.\nThe lambda has a funny name and it's doing a funny thing.\n\nI have to admit, I didn't get this joke at first. But then I realized that in order to make it work, the lambda needed to be anonymous.\n\nOoh, that one actually made me laugh out loud.\n\nThese jokes are getting more and more obscure.\n\nI like this joke. It reminds me of the \"greatest joke\" I've ever heard.\nWhat is the difference between a whore and a slut?\nA slut screws everybody, a whore screws everybody but you.\n\nFor those confused, \"Median\" is a math term for the middle element of a sorted list.\n\nI'm not", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return sorted(l.sort, key=lambda x, y: x[1]-y[1])\n   .pop()\n   .pop()\n   .pop()\n   .pop()\n   .pop()\n   .pop()\n\nHi, I'd like to raise an issue with this. The median of a list will\nbe the item in the middle of a list, not the average. So the above\nfunction will give the middle value (which is the median) of the list\n[3, 1, 2, 4, 5] and not the average, which is [2, 2.5].\nAlso, using the sorted list to find the median is going to be a\nlittle inefficient. Perhaps you could use a list comprehension to", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\""]]