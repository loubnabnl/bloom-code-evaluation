[["def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l[0], l[1])", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0])\nNot sure why you're getting downvoted. This is a perfectly valid solution.\nBecause the OP asked for the median of a list of integers.\nIt is a perfectly valid solution if the OP is willing to change his input data to be a list of integers.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[i] if i == len(l):\n    return l[i] / 2\nWhat about negative numbers?</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return (sum(abs(i - (l[i] - l[j]))) / len(l))\nI'm not sure if this is the most efficient way, but it does work.\n\nThanks, I'm going to try this out.\n\nI wrote a Python program that does this a while ago:\nIt's only a few lines of code and it works well enough.\n\nI'm using a similar method to do this, but I'm using the Min() and Max() functions instead of the abs() function.\n\nIt's important to note that the median of a sorted list is the _middle_ element.\n\nIf you have a list of numbers, you can use the following Python code:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l) == 1:\n        return l[0]\n    else:\n        return l.index(0)\nI think this is the more idiomatic way of doing this.\n\nI've never seen that idiom before, but it's a nice one.\n\nIn python, this would be:\nmedian = (l[0] if len(l) == 1 else l[len(l)-1])\n\nI don't think this is idiomatic python, though. The list comprehension is a much more concise way of writing the same thing.\n\nI can't see how this is any more concise than:\n(l[0] if l.len() == 1 else l[l.len() - 1])\n\nI think you're right, actually.\n\nI'm not sure that's the best way to do it, since it's not actually a median. A median is a number which divides the set into two equal parts, and the first element is not the median of the set [1, 2, 3, 4, 5, 6].\n\nMedian is a good", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[i] / l.length) + (l[i+1] / l.length)\n    / l.length\n    #python\nThat's a pretty ugly way of writing it. I'd say the best way to do it is with the Python list comprehension:\n>>> median([3, 1, 2, 4, 5])\n3\n>>> median([-10, 4, 6, 1000, 10, 20])\n15\n\nThe median function is a little more complicated than just dividing the elements by the length of the list. It also needs to account for the fact that the first and last elements are outliers and can skew the result.\n\nI'm aware. It's not that hard to add in though.\n\nI would also add that it's much easier to read than the Python version.\n\nIt's interesting to note that the median is not always the \"middle\" element. It depends on the distribution.\n\nYou are right. I think the article mentioned that but I forgot to mention it. Thanks for reminding me.\n\nIn python you can use list comprehension:\n>>> median([3, 1, 2, 4, 5])", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(l[i] for i in range(len(l) - 1)) / len(l)\nYou can use the same logic to get the mode:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (x[0] + x[1] + x[2] + x[3] + x[4] + x[5] + x[6] + x[7] + x[8] + x[9] + x[10] + x[11] + x[12] + x[13] + x[14] + x[15]) / len(l)\nI don't know python, but this seems to be the same as the original.\n\nThe original is a recursive function. The median function given is a list comprehension, which is not a recursive function.\n\nI don't know python, but it looks like the median function given is also recursive.\n\nI was wondering the same thing. I'm pretty sure it's not, though.\n\nI'm not sure what the point of this is. The original function is simpler, and the Python version is not as clear.\n\nI'm not sure what the point of this is either. The original function is the _definition_ of the median. It's not a function, it's the definition of the function.\n\nIt's not. The original function is a recursive function, which is", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    return sorted(l.items(), key=lambda x: x.sort(), reverse=True)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda x: (x[1] + x[2] + x[3] + x[4] + x[5]) / 6\n    median(l)\n\nThis is a common mistake, but it's not a mistake. The median of a list is not the same as the median of a sequence.\nFor example, the median of the list [1, 2, 3, 4] is 1, not 2. The median of the sequence [1, 2, 3, 4] is 2.\n\nI think the author's point is that the median of a sequence is not necessarily the median of a list.\n\nI think the author's point was that the median of a list is not necessarily the median of a sequence.\n\nThe author's point was that the median of a list is not the same as the median of a sequence.\n\nThe median of a list is not the same as the median of a sequence.\n\nThe author's point was that the median of a list is not the same as the median of a sequence.\n\nThe author's point was that the median of a list is not the same as the median of a sequence.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2] + l[3]) / 4", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (max(l), min(l))\nThis is not the median of the list.\n\nAha. I guess I should have written:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = sorted(l, key=lambda x: x[0] if x[0] < x[1] else x[1])\n    return sorted(l, key=lambda x: x[0] if x[0] < median[x[0]] else median[x[0]])\n    def lapply(f, x):\n    \"\"\"Apply function f to each element of list x.\n    >>> lapply(lambda x: x**2, [1, 2, 3, 4, 5])\n    25\n    >>> lapply(lambda x: x**2, [1, -2, -4, -6, -8])\n    25\n    >>> lapply(lambda x: x**2, [1, 1, 2, 3, 4])\n    25\n    >>> lapply(lambda x: x**2, [1, 1, -1, -2, -3])\n    25\n    >>> lapply(lambda x: x**2, [1, 1, -1, -2,", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l, key=lambda x: x[0])\n    # This is not the real median, but it works for our purposes.\n    median([-10, 4, 6, 1000, 10, 20])\n\nI don't know why this is being downvoted.\nIt's a good example of a function which is easy to write, but hard to\nunderstand.\n\nI upvoted it because I think it's a good example of a function which is easy to understand, but hard to write.\n\nI think the median function is not hard to understand.\nI think it's hard to understand why the median function is written that way.\n\nThe median function is not hard to understand if you already know what it is.\nI think it's hard to understand why the median function is written that way if you don't already know what it is.\n\nI think the median function is easy to understand even if you don't know what it is.\nI think it's hard to understand why the median function is written that way if you don't know what it is and you don't understand what it does.\n\nThe median function is easy", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return min(l[0], l[1])\nI think min(l[0], l[1]) is the same as min(l) but with a better name.\n\nThe median is a much more accurate measure of central tendency than the mean.\n\nThis is a great example of why the median is a better measure than the mean.\n\nThis is a great example of why the median is a better measure than the mean.\n\nThis is a great example of why the median is a better measure than the mean.\n\nThis is a great example of why the median is a better measure than the mean.\n\nThis is a great example of why the median is a better measure than the mean.\n\nThis is a great example of why the median is a better measure than the mean.\n\nThis is a great example of why the median is a better measure than the mean.\n\nThis is a great example of why the median is a better measure than the mean.\n\nThis is a great example of why the median is a better measure than the mean.\n\nThis is a great example of why the median is a better measure than the mean.\n\nThis is a great example", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return [l[0] if l[0] > l[1] else l[1] for l in l]", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[0] if l[0] < l[1] else l[1]", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = (l[0], l[1]) / 2\n    if len(l) == 1:\n        median = l[0]\n    return median\n\nI have a function that does the same thing:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (max(l) - min(l)) / 2\n\nSee also:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l.__class__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.__mro__.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l, key=lambda x: x[1], reverse=True)\nThis is not a median, it is a mean. A median is the number that divides a list in half. For a list of 5 elements, the median is the number that divides the list in half that is not the first or the last element.\n\nThank you for this clarification. I'll fix this in the post.\n\nOne of the things I like about Python is that it doesn't have a built-in median function. It's a bit of a pain to implement, but it's also a good exercise in understanding what it is.\n\nI like the median function in Python, it's easy to use and understand.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[0]\nSo this is a list comprehension. What's wrong with that?\nI guess I don't know what the median function is supposed to do.  It returns the middle element of the list, but does that mean the median of the list or the median of the elements in the list?\nThe median of the elements in the list. It is the middle element of the list, but that's not the important part.\nAh, I see.  That's why the list comprehension works.  It's an awful function, though.  It seems like it would be better as a function that takes a list and an integer as parameters.  The median of the elements in the list is the middle element of the list, so if you want the median of the list, you'd have to compare all the elements.\n> It's an awful function, though.  It's an awful function if you want to take the median of a list, but if you want to take the median of an element, it's great.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[0]\nThis is a pretty good solution.  I'd like to add that you can also use Python's built-in sorted() function to get the median of a list.      sorted(l)  will return the median of the list.\nI'm not sure why you got downvoted. You're right.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return len(l) / 2", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = 0\n    for i in l:\n        median = median + (i / len(l))\n    return median\n\nYou should probably note that this is O(n^2)\n\nIt's not. It's O(n log n)\n\nI believe you are correct.\n\nI believe I am incorrect. I was thinking of the case where the list is sorted, which is O(n log n).\n\nMedian is O(n log n) in any case.\n\nMy bad. I thought that median of a sorted list was O(n log n).\n\nI had the same confusion when I started learning about it. It's a common misconception.\n\nIt's not a misconception, it's a legitimate use of the median. If you sort a list of integers, the median is the median of the sorted list.\n\nI'm not sure how you're getting downvotes here. I've seen it used this way in at least one textbook.\n\nI think this is a nice use of Python's built-in function. I would prefer to use an array, but I understand the use of lists.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (x + (y / 2)) / 2", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l[::2], l[::2])\n\nI don't know Python, but it looks like it's doing the same thing as the C++ version, just in a different way.\n\nNot really. The C++ version is a little bit more efficient.\n\nYou can see the problem with the C++ version if you try it on a list with more than 2 elements.\n\nBut you can't with the Python version.\n\nSo you're saying the Python version is more efficient on lists with more than 2 elements?\n\nNo, I'm saying that the Python version is not doing the same thing as the C++ version, because the C++ version is a little bit more efficient.\n\nThe C++ version is more efficient if the list is sorted.\n\nAnd the Python version is not doing the same thing as the C++ version.\n\nI'm not sure why you're arguing this, but I'll just point out that the Python version is more efficient on lists with more than 2 elements.\n\nIt's not doing the same thing. The C++ version is more efficient.\n\nI'm not sure why you're arguing this, but I'll just point out", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] / l.length) + (l[1] / l.length) + (l[2] / l.length)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2] + l[3]) / 4\n    def nth_element(l: list):\n    \"\"\"Return nth element of the list l.\n    >>> nth_element([1, 2, 3, 4])\n    3\n    >>> nth_element([-1, -2, -3, -4])\n    4\n    >>> nth_element([1, 2, 3, 4, 5])\n    4\n    >>> nth_element([-1, -2, -3, -4, -5])\n    5\n    >>> nth_element([1, 2, 3, 4, 5, 6])\n    4\n    \"\"\"\n    return l[0]\n\nnth_element(l) == l[0]\n\nnth_element(l) == l[1]\n\nnth_element(l) == l[2]\n\nnth_element(l) == l[3", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return min(max(0, l.pop(0)))\nI'm not sure this is correct. It seems to me that it should return the median of the list, not the median of the elements in the list.\n\nIt's not correct. The median of a list is the middle element, not the middle of the list.\n\nThis is a common mistake, but the median is the middle element of the list, not the middle of the list.\nIt's a common mistake because the median is a special case of the average, and the average is the average of the elements in the list.\n\nRight, you're right. I was thinking of the mean.\n\nI think the biggest problem with this article is that it doesn't mention the median vs. mean distinction.\n\nYeah, I was expecting something about the median, but it was just an average.\n\nIt is just an average.\nThe median is the middle element, not the middle of the list.\n\nWhat about the mode?\n\nThe mode is the element which occurs most often.\n\nI'm curious what the median of the list [0,1,2,3,4,5,6,7", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(l[i] for i in range(len(l)) if i!= 0) / len(l)\nThat's a good solution, but it's not in the spirit of the problem. The problem is to do it in O(1) time, not O(n).\n\nI was under the impression that the problem was to do it in O(n) time, not O(1).\n\nYou are right, I misread the problem.\n\nThe solution is to use the quickselect algorithm.\n\nThe solution is to use the quickselect algorithm.\n\nThe solution is to use the quickselect algorithm.\n\nThe solution is to use the quickselect algorithm.\n\nThe solution is to use the quickselect algorithm.\n\nThe solution is to use the quickselect algorithm.\n\nThe solution is to use the quickselect algorithm.\n\nThe solution is to use the quickselect algorithm.\n\nThe solution is to use the quickselect algorithm.\n\nThe solution is to use the quickselect algorithm.\n\nThe solution is to use the quickselect algorithm.\n\nThe solution is to use the quickselect algorithm.\n\nThe solution is to use the", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(l.pop(0)) / len(l)\n\nYou can also use the median of a list in the median of a set:\n>>> from itertools import izip\n>>> median([3, 1, 2, 4, 5])", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda x, y: x[1]\n    median(l)\n    return median(l)\nI don't see how this is an example of \"the elegance of functional programming\". You could write this in Python in 2 lines of code, too:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return sorted(l, key=lambda x: x[0], reverse=True)\n\nThis is a great example of why \"pythonic\" code is not always the best code.\n\nCould you explain why you think that?\n\nI think the criticism is that it's \"obviously pythonic\" in a way that suggests the author doesn't understand how the language works.\nSorting a list is O(n), so there's no reason to use it in this case.\n\nI think the criticism is that the use of a list is not the best data structure for this problem.\n\nIt's the best data structure for the problem of getting the median. If you want to get the median of all the elements in a list, a list is a good data structure.\n\nI think that's arguable.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(l[0]-l[1])/len(l)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[0]\n    def mid(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> mid([3, 1, 2, 4, 5])\n    3\n    >>> mid([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return l[0]\n    def middles(l: list):\n    \"\"\"Return list of medians of elements in the list l.\n    >>> middles([3, 1, 2, 4, 5])\n    [3, 15.0]\n    >>> middles([-10, 4, 6, 1000, 10, 20])\n    [15.0, 10]\n    >>> middles([-10, 4, 6, 1000, 10, 20])\n    [15.0, 15.0]\n    \"\"\"\n    return [mid(l) for l in l]\n\nThere's a lot of great stuff in this answer, but the", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return len(l) / 2\n\nI don't like this because it doesn't work for negative numbers.\nI prefer:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = 0\n    for i in l:\n        median = median + i\n    return median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = 0\n    for i in range(len(l)):\n        median = median + l[i] / len(l)\n    return median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[l.index(0) if l[0] == 0 else l[l.index(0) - 1])\nThere's a more pythonic way to do this: \n\nI think this is more pythonic:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(l) / len(l)\nThis is a nice, concise solution. I'm still partial to the one-liner though.\n> def median(l: list):\n>    \"\"\"Return median of elements in the list l.\n>    >>> median([3, 1, 2, 4, 5])\n>    3\n>    >>> median([-10, 4, 6, 1000, 10, 20])\n>    15.0\n>    \"\"\"\n>    return sum(l) / len(l)\nI was thinking that, but it's not the median, it's the mean. The median is the middle element.\n> def median(l: list):\n>    \"\"\"Return median of elements in the list l.\n>    >>> median([3, 1, 2, 4, 5])\n>    3\n>    >>> median([-10, 4, 6, 1000, 10, 20])\n>    15.0\n>    \"\"\"\n>    return sum(l) / len(l)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (x[0] - x[1]) / 2", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    def median(l: list):\n    \"\"\"Return median of", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = [x for x in l if x % 2 == 0]\n    return (x for x in median if x % 2 == 0)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (sum(abs(x[i] - x[i+1])) / len(l))\n    / 2\nWhat if l is empty?\nThat's why it's better to return the average.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(abs(l[0] - l[1])) / len(l)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return [l[l.index(i) - 1] for i in xrange(len(l))]\nI'm not sure I understand why this is better than [l[l.index(i) - 1] for i in xrange(len(l))]  Could you explain?\nI'm not sure it is, I just made it up. It's possible that the actual implementation is more efficient.\nI think it's more that you're not using the index to get the element, which can be a bit slower.  Also, I'm pretty sure that list.index(i) is O(1) and list.get(i) is O(n).\nThat's probably it. I'm still a bit confused as to why it would be slower, but it's probably because I'm not thinking about it in the right way.\nIt's because list.get(i) is a linear search, whereas list.index(i) is an O(1) lookup.\nI understand that, but I don't understand why it would be slower.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    def median(l: list):\n    \"\"\"Return median of", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(l.pop(0)) / len(l)\nIs the median of a list with a negative number in it necessarily zero?\n\nIt is not. It is undefined.\n\nI think he means if the median is negative.\n\nThat is the median of a list with a negative number in it is undefined.\n\nI'm not sure how to interpret this.\nI'm not a Python programmer, but I'm familiar with the language. I don't know what it means for a function to be \"undefined\" and I don't know what it means for a median to be \"undefined\".\nI'm guessing you mean \"undefined in the sense that it will give different results for different inputs\", but I'm not sure.\n\nI think he means that the median of a list with a negative number in it is not defined, as in, it's not a number.\n\nThat's what I thought, but I'm not sure.\n\nIt is not defined as a number, but it is defined as a value.\n\nThis is a nice function.\nI had a similar function that I wrote years ago. The key difference is that I would compute the median of", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[0]\nThat's a nice hack, but the median function in Python is already a built-in function.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda x: x[1]\n    median(l)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    else:\n       return (l[0] + (l[1] - l[0])) / 2\n\nI'm not sure I understand this one. Why is it so fast?\n\nI believe it's because it doesn't have to do anything with the list. It just has to return the median of the list.\n\nI think he's asking why the algorithm is so fast.\n\nWhat's the difference?\n\nThe difference is that the median of a list is a single value, while the median of the list's elements is a list.\n\nSo, why is the single value faster?\n\nI think he means that the single value is a constant time operation.\n\nI thought the median of a list was a list, and that the median of the elements of the list was a constant time operation?\n\nI think you're right, and I think the OP is wrong.\n\nThe OP is right. The median of a list is a single value, but the median of the list's elements is a list.\n\nThe", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda a, b: ((a[0] + b[0]) / 2)\n    median(l)\n    print median(l)\nI think you're missing the point of the article.\nI think you missed the point of my comment.\nNo, I got the point of your comment.  The point of the article is to show how to use the Python math library, not to show how to write a function that returns the median of a list.  Your comment, however, is just a direct copy of the code in the article.  It is not helpful in the context of the article, and it does not demonstrate any understanding of the problem being addressed.\nI'm not sure why you're being so confrontational about this.  I was trying to be helpful by showing the OP how to use the Python math library to solve the problem in the article.  The OP asked for the solution to the problem in the article, so I showed him the solution.  What's the problem?</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (x / len(l) for x in l)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[i] + l[i+1]) / 2", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    l = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n    return (l[1] + l[2] + l[3] + l[4] + l[5] + l[6] + l[7] + l[8] + l[9]) /\n    (len(l) - 1)\n\nAnd a slightly more complex one:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = sorted(l.items(), key=lambda x: x[1], reverse=True)\n    return median\n\nI don't think this is the best way to do it. It's a bit more efficient to use\nthe fact that Python's built-in sorted() function is implemented using\nquicksort.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (int(l[0]) + int(l[1]) + int(l[2]) + int(l[3]) + int(l[4]) + int(l[5]))/6\nI like this one.  It's simple and direct, yet elegant.  I don't know why it's so hard for some people to just do the math.  There's no need to make it more complicated than it needs to be.\nIt's actually pretty slow.\nTrue, but it's still a good way to demonstrate the algorithm.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[0] if l[0] == 0 else l[1] if l[1] == 0 else l[0] / l[1]\nThis is a very bad implementation of the median. The median is the number that appears in the middle of the list the same number of times as the number on the right and the left of it. For example, the median of [1, 2, 3, 4] is 2. The median of [1, 2, 3, 4, 5] is not 5.\n\nYou're right, it is bad. I'm not sure if it's more accurate to use l[0] / l[1] or l[0] / (l[0] + l[1] - 1). I'm guessing it's the former, but I'd be curious to know the exact answer.\n\nThe median is the number that appears in the middle of the list the same number of times as the number on the right and the left of it. For example, the median of [1, 2, 3, 4] is 2. The median of [1, 2, 3, 4, 5] is not 5.\n\nThis is a", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = 0\n    for l in l:\n        median = median + (l[0] - median) / (l[0] + l[1] + l[2])\n    return median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return (x[0] - x[1]) / 2", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l[0], l[1])\nIt seems like a nice idea, but it's not clear to me that it's always faster than a simple sort.  What if the list is already sorted?  And what if the elements of the list are numbers?  In that case, the list is already sorted.  I'm not saying that it's not a good idea, just that it's not clear that it's faster than a simple sort.\nI think the point is that it's not a sorting algorithm, it's a median algorithm.\nIt's a median algorithm that happens to be faster than a simple sort in some cases.  I think that's the important thing to remember.\nI think you're missing the point.  It's not \"faster than a simple sort\", it's \"faster than sorting\".  The idea is to use a median of the list, rather than sorting it.  It's not \"a median algorithm that happens to be faster than a simple sort in some cases\", it's a median algorithm.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    else:\n       return l[1:]\nIf the list is sorted, this is identical to the built-in `sort` function.\n\nThis is a bad example. The built-in `sort` function is not guaranteed to be stable.\n\nNot really. Stable sort is a non-standard extension.\n\nI'm not sure what you mean by \"stable sort\", but the built-in `sort` function is not guaranteed to be stable.\nFor example, this function:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (x[0] + x[1] + x[2] + x[3]) / 4\n    / (x[0] + x[1] + x[2] + x[3])\n    / (x[0] + x[1] + x[2] + x[3])\n    / (x[0] + x[1] + x[2] + x[3])\n    / (x[0] + x[1] + x[2] + x[3])\n    / (x[0] + x[1] + x[2] + x[3])\n    / (x[0] + x[1] + x[2] + x[3])\n    / (x[0] + x[1] + x[2] + x[3])\n    / (x[0] + x[1] + x[2] + x[3])\n    / (x[0] + x[1] + x[2] + x[3])", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = 0\n    for i in range(len(l)):\n       median += l[i]\n    return median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2] + l[3]) / 4", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median_of_l = list(range(len(l)))\n    median = 0\n    for i in range(len(l)):\n        median += list(i) / len(l)\n    return median\n\nIf you want to use it as a function, it would be more efficient to use\nitertools.groupby.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(abs(l[0] - l[1])) / len(l)\n\nI had a similar question on the algorithm design interview at my current job.\nThe interviewer gave me the same list as you but with 2 elements instead of 5. I don't remember exactly what I did, but I think I ended up using a list comprehension. I also got the answer wrong, but I think it was because I didn't test for the case where the list was empty.\n\nI think I would use a list comprehension too. I'm not sure what a better solution would be.\n\nI would have used a list comprehension as well. I would have used a list comprehension for the first solution as well.\n\nI like this. It's a good example of a problem that is hard to solve without a computer, but trivial to solve with one.\n\nI think it's more like a problem that's hard to solve with a computer, but trivial to solve with one.\n\nI'm not sure what you mean. I can write a program in a few minutes that will solve this problem, but I couldn't write one by hand.\n\nThe problem is trivial to solve with a computer,", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] if l[0] < l[1] else l[1] if l[1] < l[2] else l[2])", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median_of(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median_of([3, 1, 2, 4, 5])\n    3\n    >>> median_of([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return median(l)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2] + l[3] + l[4] + l[5]) / 6", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = list(map(lambda x: x.sum, l))\n    return median.sum()\nThis code is not optimized for speed.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1], reverse=True)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = []\n    for i in l:\n       median.append(i)\n    return median\nThis is not a good example. If you had a list of positive numbers, and the median was negative, then you would get a negative number as the median.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l[0] for l in l)\nAh yes, the classic median of all the elements of a list is the average of the first and last element.\n\nThe article is a bit more than that, but yes.\n\nYeah, I just meant that the median of a list is the average of the first and last element.\n\nI don't understand how this is a good idea.\n\nIt's a good idea because the median is a better measure of central tendency than the mean.\n\nThe median is a better measure of central tendency than the mean _when the sample is sorted_. Otherwise, it's a crapshoot.\n\nThe article says that the median is better than the mean when the sample is not sorted.\n\nThat's only true if the sample is _uniformly_ distributed, which is not the case for most real-world data sets.\n\nI think the article is a bit too quick to assume that the data set is not uniformly distributed.\n\nI think you're a bit too quick to assume that the article is assuming that the data set is not uniformly distributed.\n\nI think you're a bit too quick to assume that the article is", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[0] / l.size()\n\nI think the \"size\" function is the real gem here.\n\nI think you mean the \"size\" function.\n\nThe \"size\" function is the real gem here.\n\nI think you mean the \"size\" function.\n\nThe \"size\" function is the real gem here.\n\nI think you mean the \"size\" function.\n\nThe \"size\" function is the real gem here.\n\nI think you mean the \"size\" function.\n\nThe \"size\" function is the real gem here.\n\nI think you mean the \"size\" function.\n\nThe \"size\" function is the real gem here.\n\nI think you mean the \"size\" function.\n\nThe \"size\" function is the real gem here.\n\nI think you mean the \"size\" function.\n\nThe \"size\" function is the real gem here.\n\nI think you mean the \"size\" function.\n\nThe \"size\" function is the real gem here.\n\nI think you mean the \"size\" function.\n\nThe \"size\" function is the real gem here.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return [l[0] if l[0] < l[1] else l[1]]\n\nThis is a really good example of how to make code more readable by using list comprehensions.\nThe more complicated example is from the standard library:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] - l[1]) / 2", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda x, y: x[0] + y[0]\n    return median(l)\nThat's an implementation, not the definition.\n\nThanks for the correction, I have updated the post.\n\nThis is a good example of how \"def\" and \"return\" can be used interchangeably.\n\nI'm not sure that's true. If you return a lambda, you're not returning a value, you're returning a function. The function is then called to return a value.\n\nI think this is a case where the difference between a definition and an\nimplementation is subtle.\nThe \"def\" keyword is a statement of intent, it's not a statement of fact.\nIf the intent is \"implement the function median\" then the code is fine, even though the implementation doesn't match the intent.\n\nI think it's a case of the author confusing a definition with an explanation. The author gives a definition of what the function is supposed to do, but then proceeds to give an explanation of how to implement it.\n\nI think the author is confusing a definition with an explanation.\n\nI think the author is confusing a definition with an explanation.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    if len(l) == 0:\n       return 0\n    return l.pop(0).median()\nI don't know how to make this work in Python.\n\nI don't know how to make this work in Python.\nPython doesn't have the \"median\" function, but you can do the same thing using the \"arithmetic mean\" function:\n>>> median([3, 1, 2, 4, 5])\n3\n>>> median([-10, 4, 6, 1000, 10, 20])\n15.0\n>>> mean(l)\n3.0\n>>> mean(l[::-1])\n3.0\n>>> mean(l[::-1])\n3.0\n\nI don't know how to make this work in", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda l: [l[0] for l in l]\n    median(l: list(range(5)))", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l.pop(0)\n\nI've never seen the pop(0) idiom before. Why not just return the first item in the list?\n\nIt's a good question. It's a pretty common idiom in Python, though.\n\nIt's also used in Matlab and other languages that use lists.\n\nI would have thought that the median of a list would be the mean of the two middle numbers.\n\nThe median is the middle number in the list if the list is sorted.\n\nThis is actually a very good article. It is a very simple example, but it is a very good explanation of the median.\n\nI'm surprised it didn't mention the \"middle\" function, which is also in Python.\n\nPython's median is based on the middle() function, which is in the collections module.\n\nThe article is in the context of the Python language, so it is not surprising that it uses the built-in median.\n\nI can't wait for Python 3.0.\n\nWhy?\n\nThe article is a great example of the power of Python. I can't wait to see what people will do with Python 3.0.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda l:\n       if len(l) > 2:\n          return l[1]\n       else:\n          return l[0]\n\nThis is just a bit off the top of my head, but you could make it more robust by using a median of medians, rather than the simple median.\nI.e. calculate the median of the middle half of the list.\n\nThe median of medians is the mean.\n\nNot in the case where the data is skewed.\n\nI like the median of medians better than the mean. I find that the median of medians gives me a better idea of the \"typical\" value in a list.\n\nI'm not sure what you mean by \"typical\" value. The median of medians is the most frequently occurring value.\n\nI'm not sure that's what I mean, but that's what I get.\n\nI've always liked the median of medians. I find it more useful when I'm trying to find the center of a distribution.\n\nI've always", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] / l.length) + (l[1] / l.length) + (l[2] / l.length) + (l[3] / l.length)\n\nThis is the correct answer. If you want to be a bit more efficient, you can use the'sum' function in Python (which is a bit faster than the '+' operator).\n>>> median(l)\n3\n>>> median(l.sum())\n3\n\nThere's a few different ways to do it. You can use an array of lists, then sort the array and use the median of the sorted array.\n>>> a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]\n>>> sorted(a)\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    return sum(l[::2] / l.size()) / 2", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (sum(abs(x[i]) for i in range(len(l))) / len(l))\nThis is a nice and simple solution. I don't know why I didn't think of this. Thanks.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(l) / len(l)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return min(l, key=lambda x: x[1] if x[1] else x[0])\nWhy is it min instead of max?\n\nThe median is not the mean.\n\nIt's not the mean, but it's still the median.\n\nYes, but in the context of the article, it's a median of the _numbers_ in the list. So it's a median of the _values_ of the numbers in the list. So it's the _median of the min_ of the values of the numbers in the list.\n\nIt's the median of the _numbers_ in the list, but the median of the _values_ of the numbers in the list is the mean.\n\nThe median is not the mean.\n\nI think the point of the article is that the median of the _numbers_ in the list is the _median of the min_ of the _values_ of the _numbers_ in the list.\n\nWhy not just use the built in sorted()?\n\nThe median is not the mean.\n\nWell, it's the mean of the numbers in the list.\n\nThe median is not", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l[0], l[1])\nI'm surprised this is faster than the Python version.\n\nIn Python, you need to keep the list in memory, and you need to iterate over it twice. In the C version, you only need to keep the list in memory once, and you need to iterate over it only once.\n\nI know, but the Python version is a single function call. I'm surprised the C version is faster than the Python version.\n\nIt's not that surprising when you consider that Python is an interpreted language, while C is a compiled language. In a compiled language, you have the compiler optimizing the code for you, and the Python interpreter is not going to be able to do as good of a job optimizing the code.\n\nI think you mean that the C version is not going to be able to do as good a job optimizing the code.\n\nYes, that's what I meant. Thanks for the correction.\n\nI don't see how this is faster than Python's built-in min/max/median functions.\n\nThe C version is faster because it does not need to keep the list in memory.\n\nThe python version does", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (max(l) - min(l)) / 2", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l) > 1:\n        return (l[0] - l[1]) / 2.0\n    else:\n        return l[0]\nWhat's wrong with that?\nThe median of a list of negative numbers is zero.\nThe median of a list of positive numbers is the average of the two middle numbers.\n\nThe median of a list of positive numbers is the _median_ of the two middle numbers.\nThe mean is the average of the two middle numbers.\n\nI believe the poster was referring to the arithmetic mean, which is the average of the two middle numbers.\n\nSo if you want the median of a list of positive numbers, you have to check the number of elements and then multiply the result by two?\n\nYou can also do it like this:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2] + l[3] + l[4]) / 5", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2] + l[3]) / 4", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = [x for x in l if x > l.length - 1]\n    return len(median)\nThis is not a good idea. The median is a property of the list, not of the elements. So you need to take the median of the list of elements, not the elements themselves.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[0]\nThanks for the reply. I had to use this for my final project.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l) > 1:\n       median = 0\n    else:\n       median = l[0]\n    return median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median(l)\n    [1, 2, 3]\n    \"\"\"\n    return (l[0] / l.size() + l[1] / l.size() + l[2] / l.size() + l[3] / l.size()\n    / l.size() + l[4] / l.size() + l[5] / l.size() + l[6] / l.size()\n    / l.size() + l[7] / l.size() + l[8] / l.size() + l[9] / l.size()\n    / l.size() + l[10] / l.size() + l[11] / l.size() + l[12] / l.size()\n    / l.size() + l[13] / l.size() + l[14] / l.size() + l[15] / l.size()\n    /", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (x[0] if x[0] < l[0] else l[0] + x[1] + x[2])\n    def mean(l: list):\n    \"\"\"Return mean of elements in the list l.\n    >>> mean([3, 1, 2, 4, 5])\n    3.0\n    >>> mean([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return sum(l[0] for l[0] in l) / len(l)\nI don't know what you're trying to do, but this is all you need to do to calculate a mean.\n\nI think the OP is trying to write a function that takes a list of numbers and returns the median and mean of the list.\n\nI think I would have been able to tell that if I'd been awake. Thanks.\n\nA simple way to calculate the median and mean of a list of numbers is to take the first element of the list, divide it by the total number of elements in the list, and return that number.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2] + l[3] + l[4]) / 5\n\nI think it's funny that the first example you give is actually the worst case for median. The median of a list of numbers will always be the middle number. The median of a list of strings will be the middle letter.\n\nThat's true. It's also a good example of the kind of thing you'd use median for in the first place.\n\nI'd use it for finding the most common value in a set.\n\nIf you're looking for the most common value, I'd say the median is a good way to go. If you're looking for the median value, I'd say the mean is a better way to go.\n\nThe mean and median are not the same thing. The mean is the sum of the values divided by the number of values. The median is the middle value.\nThe mean is a better way to go if you are looking for the _average_ value, the middle value is a better way to go if you are looking for the _most common_ value.\n\n_The mean and median are not the same thing.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = [0]*l.count\n    return sum(float(i) for i in l if i < median) / l.count\nI'm not sure if this is the best way, but it seems to work.\n\nI've never been a fan of median in python. It's not that I have a better way, it's just that it's a lot more verbose than I'd like. I'm always tempted to write:\nmedian = sum(i for i in l if i > l[i])\nBut that doesn't work.\n\nI usually use a generator:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda x: x.median()\n    return median(l)\n\n>>> median([1, 2, 3, 4, 5, 6, 7])\n5\n\nMedian is the most common algorithm for finding the middle element of a list.  It is the simplest of all the median algorithms and is O(n) in time and space complexity.  Median is based on a divide and conquer approach.  The algorithm repeatedly splits the list into two sublists, and then takes the median of each sublist.  When the list is empty, the median of the empty list is used as the result.\n\nThe median of a list is the middle element of the list.  It is the value that is in the middle of the list.  The median is not the average of the list.  The average of a list is the sum of the values divided by the number of values.  The median is not the mode of the list.  The mode of a list is the value that occurs most often.  The median is not the median of the middle three elements of the list.  The median of the middle three elements is the median of the three middle elements.  The median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    median = l[0]\n    while l[1:] > median:\n       median = l[1]\n    return median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median_index = 0\n    for i in range(len(l)):\n        median_index = median(l[i])\n        if median_index < len(l):\n           median_index = l[i]\n    return median_index\n\nThis is not a great solution for a few reasons:\n\\- The range function can be expensive.\n\\- The range function returns None if the index is out of range.\n\\- The range function returns the index, not the value.\n\\- The range function is slow.\n\\- The range function is slow.\n\\- The range function is slow.\n\\- The range function is slow.\n\\- The range function is slow.\n\\- The range function is slow.\n\\- The range function is slow.\n\\- The range function is slow.\n\\- The range function is slow.\n\\- The range function is slow.\n\\- The range function is slow.\n\\- The range function is slow.\n\\- The range function is slow.\n\\- The range function is slow.\n\\- The range function is slow.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return (l[0] + l[1] + l[2] + l[3] + l[4]) / 5\n\nThis is the correct answer.\n\nIt's only correct if you have a list of integers. If you have a list of strings, it's not.\n\nIt's correct for lists of any type. The author of the blog post made a mistake.\n\nI stand corrected.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[l.index(0) - l.index(l.index(1))]\nWhy not just use [l.index(0), l.index(1)]?\n\nBecause you can have multiple elements that have the same index.\n\nAh, of course. Thanks.\n\nIt's also worth noting that if you use this method with a list that's empty, it will return the empty list. If you want a median of an empty list, use the empty list.\n\nI think this is a more general problem with the median function. If you have an empty list, it's hard to tell whether the median is 0 or the empty list.\n\nThe empty list is special. It's the only value that is not in the list. Therefore, if you have an empty list and a median, the median is the empty list.\n\nI've always liked the median function. It's simple and it works.\n\nThis is a great article.\nI was looking for something like this for a project I'm working on. Thanks!\n\nThis article is so great. I've been looking for something like this.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = []\n    for i in range(len(l)):\n       median.append(l[i])\n    return median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    median = 0\n    for i in range(len(l)):\n       median = median + (i / len(l))\n    return median\nThis is an example of a recursive algorithm.\n\nPython supports list comprehensions, which is a way to write a function that can be used as a list, but is not a list. For example:\n>>> list(1,2,3,4,5)\n[1, 2, 3, 4, 5]\n>>> list(1, 2, 3, 4, 5) + [6, 7, 8, 9]\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n\nThis is an example of a recursive algorithm.\n\nPython supports list comprehensions,", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return 0\n    return sum(abs(x[i] - x[j])) / len(l)\n\nThis is exactly what I was looking for. I'll be adding this to my codebase!</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return [x[i] for i in range(len(l))]", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[l.index(i) % l.size()]\nI think it's better to use the modulo operator to avoid division by zero.\n\nI agree, but I think there's a bug in the code.\n>>> median([3, 1, 2, 4, 5])\n3\n>>> median([3, -1, 2, 4, 5])\n0\n\nThe median is actually a special case of the modulo operator. If the list is sorted, then the median is the element in the middle of the list with the smallest index.\nIn the list you provided, the median is the middle element, which is 3.\nIn the list you provided, the median is the middle element, which is 0.\n\nI'd suggest looking at the source code for the built-in `median` function in Python.\n\nI'd suggest using the built-in median function in Python.\n\nI'd suggest using the built-in modulo function in Python.\n\nI'd suggest using the built-in median function in Python.\n\nI'd suggest using the built-in modulo function in Python.\n\nI'd suggest using the built-in median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = 0\n    for i in l:\n       median += i\n    return median\nThis is the correct answer, but I'm not sure it's the best. It's certainly not the fastest.  You're iterating over the list twice, so this is O(n) where n is the length of the list.  The correct answer, for me, would be a recursive function that will only iterate over the list once.\nIt's not the fastest, but it's very easy to understand and very readable.\nI think it's a good answer for a beginner.  I would have been satisfied with it, and it probably would have made me think about the problem a little more.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(l[0] - l[1]) / len(l)\nI feel like this is cheating.\n\nI was about to say the same thing.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    \"\"\"\n    return min(l[0], l[1], l[2])\n    #", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    # Median is a function that takes a list and returns a number.\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return l[0]\nThis is a great example of how to write bad code.\n\nThe median function is a function that takes a list and returns a number.\nThe median function in Python returns a number that is the median of the list.\nThe median function in JavaScript returns a number that is the median of the list.\nThe median function in PHP returns a number that is the median of the list.\nThe median function in Ruby returns a number that is the median of the list.\nThe median function in Perl returns a number that is the median of the list.\nThe median function in C returns a number that is the median of the list.\nThe median function in Java returns a number that is the median of the list.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = sorted(l, key=lambda x: x[0] / len(x), reverse=True)\n    return median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = sorted(l.items(), key=lambda i: i.index)\n    return sorted(l.items(), key=lambda i: i.index)\n    def nth_element(l: list):\n    \"\"\"Return the nth element of the list l.\n    >>> nth_element([-10, 4, 6, 1000, 10, 20])\n    6\n    >>> nth_element([-10, 4, 6, 1000, 10, 20])\n    -10\n    \"\"\"\n    nth_element = sorted(l.items(), key=lambda i: i.index)\n    return sorted(l.items(), key=lambda i: i.index)\n    def range(start, stop, step):\n    \"\"\"Return a list of elements from start to stop, with step being the\n    number of elements to skip between each element.\n    >>> range(0, 10, 2)\n    [0, 1, 2, 3, 4, 5, 6, 7, 8", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(l[::-1]) / 2", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda l: (x[0] - x[1] + x[2]) / 2\n    return lambda s: median(s)\nWhat's the point of using lambda here?\nIt's a good question.  I didn't think about it at the time.  I was just trying to get something working quickly.  I guess I could have just used a for loop and been done with it.  I guess I could have used a list comprehension too.  I just used lambda because I was already using lambdas elsewhere in the program.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[l.pop()]\nIf you want to know the median of a list of floats, you can just do", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l[0], l[1])\n    + min(l[1], l[0])\n\nThis is the most naive median function I've ever seen.\n\nIt's not supposed to be a \"good\" median function, it's just supposed to be a median function.\n\nIt's not even a median function. It's just a linear combination of the first and last elements in the list.\n\nI know it's not a median function, it's a median-of-three function. It's supposed to be a demonstration of how to implement a median function.\n\nIt's not even a median-of-three function. It's just a linear combination of the first and last elements in the list.\n\nI know it's not a median-of-three function, it's a median-of-three-of-five function. It's supposed to be a demonstration of how to implement a median-of-three function.\n\nI'm not sure what you're trying to demonstrate here. The code is wrong, and it's not a demonstration of anything other than how to write a bad median function.\n\nIt's not supposed to be a good", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[0]\nI've found that this is often faster than the built-in median function. I'm not sure why.\n\nI'm not sure why either, but I think it has something to do with the fact that the built-in median function is implemented in terms of a recursive algorithm.\n\nThere is a single, simple reason why the built-in median function is faster than the one you've written. The built-in one is implemented using the built-in itertools.imap function, which is much faster than the built-in map function.\n\nI'm a little surprised that the author didn't mention the built-in sort. It's a lot faster than the one he wrote (which is a good thing, since it's a core function).\n\nThe built-in sort is also a lot faster than the one I wrote. I didn't mention it because it's not a core function, and I didn't want to clutter up the post with too much detail.\n\nThis is great. I like the fact that it's a very simple implementation, but it's still very useful.\n\nThe author is missing the point. The built-in median is not a", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0] - x[1])\nWhy is this better than the default?  It seems like the default would be faster (and more intuitive) than sorting the entire list.\n\nI think the default is to use the builtin function _median_ from the _numpy.linalg.median_ module, which is a lot slower than the one from the _numpy.linalg._ module.\n\nAh, thanks for the explanation.  I didn't realize there was a built-in median function.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return sorted(l.sort(), key=lambda x: x[1])\nThis is a nice hack, but it's not the best solution.\nThe best solution is to use a heap to store the list, and then use the heap-sort algorithm to find the median.  A heap sort is basically a binary search.\n\nI don't see how the linked solution is more than a hack. It's just a\nslightly different hack than what you propose.\n\nThe linked solution is a hack because it uses a list and then sorts the list. The heap solution uses a heap (which is a tree) and then uses heap sort.\n\nI don't see how using a tree makes it better. The linked solution uses a tree too, it's just a tree of lists.\n\nThat's the point. The", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2] + l[3] + l[4]) / 5", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median_ = [0] * len(l)\n    return median_[0]\n\nI'm not sure why you're using a list here. The median is the middle element of a sorted list.\n\nBecause if you want to use a sorted list, you have to sort it, and if you want to sort it, you have to sort it first.\n\nNot necessarily. If you have a sorted list, it is possible to find the median element in constant time, without having to sort the list.\n\nIn other words, the median is the middle element of a sorted list, but it is not the middle element of a list that needs to be sorted.\n\nIt is the middle element of the list, but not the middle element of the list's elements.\n\nThe median is the middle element of the list, but not the middle element of the list's elements.\n\nIt is the middle element of the list, but not the middle element of the list's elements.\n\nI'm not sure why you're using a list here. The median is the middle element of a sorted list.\n\nBecause if you want to use a sorted list, you have to sort it", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[l.index(0) + 1]\nThanks! I was looking for that in the docs and couldn't find it.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda l: (l[0] + l[1] + l[2] + l[3]) / 3\n    median(l)\nI'm not sure this is the best approach.  I'm not sure if the first element is the median, or if the first element is a median of the list.  If the latter, you could do something like this:      median = lambda l: (l[0] + (l[1] / 3)) / 3\nThat's a good point. I'll change it.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median_l(l: list):\n    \"\"\"Return median of list l.\n    >>> median_l([3, 1, 2, 4, 5])\n    3\n    >>> median_l([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return sorted(l.sort(), key=lambda x: x[0])[1]\n\nThis is a very common mistake, but it's not a bug. Python's sorted() method returns a list, not a list of integers. The first element of the list is the median, so median_l(l) returns the median element of the list l.\n\nThis is a very common mistake, but it's not a bug. Python's sorted() method returns a list, not a list of integers. The first element of the list is the median, so median_l(l) returns the median element of the list l.\n\nThis is a very common mistake, but it's not a bug. Python's sorted() method returns a list, not a list of integers. The first element of the list", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    l = sorted(l)\n    median = min(l) + max(l)\n    return median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2] + l[3] + l[4]) / 5", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda x: (x[1] + x[2]) / 2\n    median(l)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return [l[0] if l[0] > l[1] else l[1] for l in l]\nI think the problem is that you are using the list comprehension syntax without understanding it. You should be able to understand the code above without knowing any Python.\n\nI think that's the best advice. I would have to say I have a lot of experience with python and I can't explain why that code works. I have to say, I've never had to use median() in the wild, but I have used it for homework and it has always worked. I think the best way to learn is to try and fail and try and fail and try and fail and eventually you will succeed.\n\nI'm not sure I understand why you are having problems with the code above. The first line creates a list that contains the first element in the list if it is larger than the second element, else it contains the second element. The second line returns the median of that list.\nI think the reason you are having trouble is because you are trying to understand the code before you understand the code. The best way to learn is to do, not to try and understand.\n\nI think you should just try", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (x[i] - x[i+1]) / 2\nI'm not sure why you're using the median function here. You're not using it to calculate the median, you're just using it to find the middle element. You could have just as easily used index.   Also, you're not using the function correctly, you're missing the `return` at the end.\nI was taught to always use the median function for finding the middle element in a list.\nThe median function returns the middle element of a list. If you don't need to calculate the median, then you don't need to use the median function.   You could also use the index function to find the middle element.       index(x, 0)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2]) / 3", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l[0], l[1], l[2])\nWell, that's the only one that I can think of that might be useful.\n\nI think it's good to have a list of these.\n\nI've been using python for about a year now, and I've been looking for a list of these for a long time.\n\nThe \"C\" version is a lot more readable to me.\n\nIf I want to know the median of a list, I just type it in and hit enter. If I want to know the median of a list of lists, I type it in and hit enter. If I want to know the median of a list of lists of lists, I type it in and hit enter.\nIf I want to know the median of a list of lists of lists of lists, I type it in and hit enter. If I want to know the median of a list of lists of lists of lists of lists, I type it in and hit enter.\nIf I want to know the median of a list of lists of lists of lists of lists of lists, I type it in and hit enter. If I want to know the median of a list of lists of", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2] + l[3] + l[4] + l[5]) / 6\n\nThat's really neat!\n\nAnd it's also faster than the Python one, which is not always the case when you write in C.\n\nIt's also the fastest in the list.\n\nI don't think that's true.\n>>> timeit median([3, 1, 2, 4, 5])\n1.74 seconds per loop\n>>> timeit median([-10, 4, 6, 1000, 10, 20])\n1.68 seconds per loop\n\nThe author says he's using a Macbook Air. My guess is that this is a performance hit on the MacBook Air, and that the other machines are running Linux or Windows.\n\nIt's true on my MacBook Pro running Lion too.\n\nI was curious about that, too. I did a test on my MBP and it was also slower than the Python version.\n\nI'm not sure what's going on here. It's a simple enough function, and it's not like the C version is using a lot of CPU time or memory.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(l.pop()[0]) / len(l.pop())\nI'm not sure if it's the best way, but it works for me.\n\nThat's the naive way to do it, but it's a bad idea. For example, if the list contains [1, 2, 3, 4, 5], the median is 1, but the median of the median is 5.\n\nIn this case, the median of the median is the average of the median, so the median of the median is indeed 5.\n\nI just realized that the median of the median is the average of the median.\n\nI would have thought that the median of the median would be the median of the median, which is the average of the median.\n\nYou are correct.\n\nIt's a nice article. I have a question, though:\nI understand that the median is the \"middle\" element of a list, and the mean is the \"average\" element of a list. What I don't understand is why the median is the \"middle\" element of a list, and the mean is the \"average\" element of a list.\nI understand that if you take a list of 10", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    else:\n       return np.median(l, axis=0)\nI prefer the python version.\n\nI prefer the python version too, but I don't think that's a fair comparison.\n\nNo, it's not fair to compare different languages, but I think it's fair to compare the same algorithm implemented in different languages.\n\nIt's not the same algorithm. The Python version is not a median, it's a mean.\n\nI think you're right. I'd expect median to be a function of two arguments.\n\nI prefer the Python version because it's more idiomatic.\n\nI prefer the Python version because I'm more familiar with it.\n\nI prefer the Python version because I'm not a Java developer.\n\nI prefer the Python version because I think it's more idiomatic.\n\nI prefer the Python version because it's more idiomatic.\n\nI prefer the Python version because I'm more familiar with it.\n\nI prefer the Python version because it's more idiomatic.\n\nI prefer the Python", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(l[::2] - l[::1]) / 2", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda x: x[1] + x[0] + x[2]\n    median(l)\n\nI would use the same approach as this comment.\nI would also use list(x) instead of x[1] + x[0] + x[2]\n\nYeah, that's what I meant. I'm not sure why I used the x[1] + x[0] + x[2] notation.\n\nI would use this as a simple exercise in list comprehension:\nmedian = lambda l: l.median()\n\nYou don't even need list comprehension, just a lambda.\n\nThe lambda is just syntactic sugar for a list comprehension.\n\nThis is a really cool example of why python is so great.\n\nThe same could be done in Perl 6:\nmy $median = median [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n[1, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]\n\nAnd in ruby:\nmed", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = 0\n    for i in range(len(l)):\n       median = median + (i - min(l)) / 2\n    return median\n\nYou should use the fact that the median is the middle element, and not the average.\n\nThat's what I was thinking. I'm not sure if the median is the \"correct\" answer, but I thought it was the best solution.\n\nIf you want to be pedantic, the median is the correct answer. The average is the mean, which is the sum of the values divided by the number of elements.\n\nI'm not sure what you're saying. I was saying that the median is the \"correct\" answer, not the average.\n\nAh, I misread your post. I thought you were saying the median was the correct answer, but not the average.\n\nI think the average is the correct answer.\n\nThe median is the correct answer.\n\nThe median is the correct answer.\n\nMedian is the correct answer.\n\nMedian is the correct answer.\n\nMedian is the correct answer.\n\nMedian is the correct answer.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] - l[1]) / 2", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda x: (x[0] + x[1] + x[2] + x[3] + x[4] + x[5]) / 6", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2] + l[3] + l[4] + l[5]) / 6", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[l.index(0) + l.index(1)]", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (x[0] - x[1] / 2) / (x[0] + x[1])", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return min(l, key=lambda x: x[1] if x[1] else x[0])\nThanks, but this is not what I am looking for. I want to find the median of a list of items in a given range. For example, if I have a list of numbers between 1 and 10, I want to find the median of that list.\n\nIf you want to find the median of a list of numbers, you should use the median function.\n\nI think he means the median of a list of numbers in a given range.\n\nThat's what I mean.\n\nYou're asking for a function that does something that isn't possible.\n\nI don't think it's impossible. If you have a list of numbers in a given range, the median is the number in the middle of that range.\n\nThat's not the median. The median is the value that divides the data set in two equal parts.\n\nSorry, I meant the median of a list of numbers in a given range.\n\nI'm not sure that's a meaningful question. You can't have a median of a list of numbers.\n\nI'm not sure what you mean. A", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2] + l[3] + l[4]) / 5\n    # We don't need to check for NaN's\n    # because they will be treated as 0\n    # and the median of 0 is 0.\n    def sort(l: list):\n    \"\"\"Sort elements in list l.\n    >>> sort([3, 1, 2, 4, 5])\n    [3, 1, 2, 4, 5]\n    >>> sort([-10, 4, 6, 1000, 10, 20])\n    [1000, 10, 20, 4, 6]\n    \"\"\"\n    return l.sort(lambda x,y: x[1] < y[1])\n\nI think this is a good example of why it's important to be able to read the code. The C version is far more readable, because it doesn't have to explain itself to you. You can look at the code and immediately know what it's doing, and if you don't know what it's doing, it", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[0] / l.size()", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median_by(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median_by([3, 1, 2, 4, 5])\n    3\n    >>> median_by([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return lambda x, y: x[l[y]], lambda x, y: y[l[x]]", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (x + 1.0)/2", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = []\n    for i in l:\n       median.append(i)\n    return median\n\nA simpler version is:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[0]\n    def mean(l: list):\n    \"\"\"Return mean of elements in the list l.\n    >>> mean([3, 1, 2, 4, 5])\n    3.0\n    >>> mean([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return sum(l)\n\nA more accurate median is to use the \"ord\" function:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda x: x[1] / x[0]\n    return median(l)\n\nI've never heard of this function, and I don't get it. What does it do?\n\nIt returns the middle element in a list.\n\nThank you!\n\nI always write:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (x, y) = sorted(l.items(), key=lambda x: x[1])\n    if y > x:\n        return x\n    return (x, y)\nThis is great, I was just looking for something like this yesterday. Thanks!</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median_of(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median_of([3, 1, 2, 4, 5])\n    3\n    >>> median_of([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n\nA slightly more idiomatic version of this would be to define a function median that takes a list and returns the median, and then write the median_of function to take a list as its first argument and call median on the list.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l.pop(0).pop(0).pop(0).pop(0)).median()\nWhat about the case where the list is empty?\n\nIt's not a big deal. In practice, the median of an empty list will be zero.\n\nI think the better way to do it is to use the built-in sorted() function:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] - l[1] + l[2] - l[3]) / 2\n\nI'm not sure what this is supposed to do.\n\nIt takes an array and returns the median.\n\nThe title is misleading.\nThe linked article is not about Python. It's about _numpy_. The article is not about how to use Python.\nIt's about how to use a library.\n\nThe title is misleading.\nThe linked article is not about Python. It's about _numpy_. The article is not about how to use Python.\nIt's about how to use a library.\n\nIt's about how to use a library in Python.\n\nThe title is misleading.\nThe linked article is not about Python. It's about _numpy_. The article is not about how to use Python.\nIt's about how to use a library.\n\nIt's about how to use a library in Python.\n\nThe title is misleading.\nThe linked article is not about Python. It's about _numpy_. The article is not about how to use Python.\nIt's about how to use a library.\n\nIt's about how to", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2] + l[3]) / 4\n\nThe more interesting question is why did you write median() instead of mean().</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda x: x[1] / len(x)\n    return median(l)\n\nI had to read that three times to see what was going on. The first time I read it, I thought it was a joke.\n\nI'm not sure I understand. Can you explain why this is a bad code snippet?\n\nThe way I read it, the median function was a function that took a list as input. It then did something to the first element of the list, and returned the result.\n\nThe reason this is bad is that it doesn't explain how the function works.\nIf you didn't know the function already, you would have no idea what the function does.\n\nI'm still not sure I understand. Can you give me an example of a good explanation of a function?\n\nFor this function, a good explanation would be \"The median of a list is the middle element of the list, if the list is sorted, or the average of the middle two elements if the list is not sorted.\"\nThe only way to know this is to read the source code.\n\nThis is a really good explanation.\n\nI don't know what the OP is", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] - l[1] + l[2] / 3) / 2\n\nA lot of people do not understand the median function. It's not the average of the two middle numbers. It's the _median_ of the two middle numbers. This is a subtle difference.\n\nI don't think it's a subtle difference. The median is the midpoint, the average is the sum of the two numbers divided by two.\nThe average of [3, 1, 2, 4, 5] is 4.\nThe median of [3, 1, 2, 4, 5] is 3.\n\nThe average of [3, 1, 2, 4, 5] is 4.5.\nThe median of [3, 1, 2, 4, 5] is 3.5.\n\nI wrote this a few years ago:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[:len(l)-1].__getitem__(0)\nThanks, that's the one!</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda x: (x[0] + x[1] + x[2]) / 3\n    median(l)\n\nI'm not sure what the point of this is. The median is the most common element. If you have a list of only one element, then the median is 0. The median is the _middle_ element, not the average, not the mode.\n\nI don't think this is true. The median of the list [1, 2, 3, 4, 5] is 5.\n\nI think it depends on the ordering of the elements. If you sort the list by the values, the median is the middle element. If you sort by the indices, the median is the average of the middle two.\n\nThe median is the middle element in the list, regardless of the ordering.\n\nIn a sorted list the median is the average of the middle two.\n\nI'm pretty sure the median of a sorted list is the middle element, not the average of the middle two.\n\nThe median is the middle element of the list, regardless of the ordering.\n\nThe median of a list is the average of the middle two elements.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2] + l[3]) / 4", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[0] + l[1] + l[2] + l[3] + l[4] + l[5]\nI'd probably use a list comprehension for that.\n\nWhat about l[0] + l[1] + l[2] + l[3] + l[4] + l[5] / 2?\n\nIn Python, a list comprehension is just syntactic sugar for the `return` statement.\n\nI know, but I was wondering if there is a difference in performance.\n\nI'd be interested to know the answer to that question.\n\nI've never seen any evidence that list comprehensions are slower than just using `return` or `if` statements.\n\nI wouldn't be surprised if they are slower, but it would take a very large number of iterations to make the difference noticeable.\n\nI think I'd prefer the list comprehension, but I'm not sure why.\n\nBecause it's a lot easier to read and understand.\n\nI don't think so. The comprehension is a lot more complicated, and it's not clear to me that the extra complexity is worth the increased readability.\n\nThe comprehension is", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    return len(l) - 2\n\nThis is the median of a list of numbers, not a list of lists.\n\nI think the author's point is that the median function should work on any list, not just a list of numbers.\n\nI'm surprised that the author didn't mention that the Python median function is actually an average, not a median.\n\nThe Python median function is _not_ an average, it's a _median_.\n\nI stand corrected. I had been told by several people that the Python median function is an average, but it appears that this is not the case.\n\nThe Python median function is not a median either. The median function in Python is a _linear_ median, which is a type of _weighted_ average.\n\nA weighted average is not a type of average, it's a _type of median_.\n\nI'm glad you agree that the Python median function is not a median.\n\nI'm glad you agree that a weighted average is not a type of average.\n\nI'm glad you agree that a weighted", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return [l[1] for l in l if l[1] > l[2] for l in l]", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l, min(l))\nI don't think this is the median. I think it's the mean.\n\nIt is the mean.\n\nIt's the median if the elements are not ordered.\n\nMedian is not a generalization of mean. It is a special case of mean, specifically the mean of an unordered set.\n\nThe median is not a special case of the mean. The median is the _only_ case of the mean.\n\nThe median is a special case of the mean if the set is unordered.\n\nThat's not a generalization of the median, that's a special case of the median.\n\nI think it's a generalization in the sense that it's a generalization of the median in the unordered case.\n\nYou can't generalize the median in the unordered case. It's a special case of the mean, period.\n\nThe median is a generalization of the mean if the elements are not ordered.\n\nNo. The median is a special case of the mean if the elements are not ordered.\n\nNo. The median is a generalization of the mean if the elements are not ordered.", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1], reverse=True)", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (sum(x.value) for x in l) / len(l)\nI'm not sure how that's better than the normal way, which is to just sort the list.\nIt's not.  It's just a different way of doing it.  The \"normal\" way is O(n log n) and the median way is O(n).  It's not a big difference, but if you're running the same code over and over it can make a difference.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l[0], l[1])\nIs this a joke?\n\nIt is, but it's a joke that a lot of people make.\nIt's a joke that people make because it's a bad joke.\n\nI'm not sure if I'm the only one who finds this funny.\n\nI think it's funny too.\n\nThe median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the median of the", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2] + l[3]) / 4", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = []\n    for x in l:\n       median.append(x.value)\n    return median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[0]\nI'm not sure why this is being downvoted. It's the correct answer.\nIt's not the correct answer because it is not the most efficient solution.\nI think it's more of an interesting answer, rather than the most efficient.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(abs(x) for x in l) / len(l)\n\nThe Python code is a lot more readable.\n\nWell, it's more readable if you know what the sum of the absolute values of the elements of a list is.\n\nI'm not sure if it's just me, but I find the Python version to be more readable.\n\nI don't understand why it's \"more readable\". The Python code is not even a little bit more readable.\n\nIt's more readable because the code is more compact. It is written in a more \"idiomatic\" way.\n\nThe code is compact because it is a one-liner. The Python code is not even close to idiomatic.\n\nI think the Python version is more readable.\n\nI'm not sure why you think that.\n\nI'm not sure why you think that.\n\nI'm not sure why you think that.\n\nI'm not sure why you think that.\n\nI'm not sure why you think that.\n\nI'm not sure why you think that.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda x: int(x/len(l))\n    return median(l)\nThis doesn't work for lists of integers.\n\nIt is interesting that the C++ standard library implementation of median() uses a similar algorithm, which does work for lists of integers.\n\nNot quite the same.\n\nI would be very surprised if the median of a list of integers was not a single integer.\n\nIn the article's example, it is not.\n\nIn the article's example, it is.\n\nNo, it is not.\n\nIt's a bit odd to say that the median of a list of numbers is not a number.\n\nIn the example, the median is not a number.\n\nIn the example, the median is a number.\n\nIt is not.\n\nIt is.\n\nIt is not.\n\nIt is.\n\nIt is not.\n\nIt is.\n\nIt is not.\n\nIt is.\n\nIt is not.\n\nIt is.\n\nIt is not.\n\nIt is.\n\nIt is not.\n\nIt is.\n\nIt is not.\n\nIt", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l, -1)\n\nThe max and min functions are stable in Python 3.5, but the median function is not.\n\nIn Python 3.5, the median function is stable, but the max and min functions are not.\n\nIn Python 3.5, the median function is stable, but the max and min functions are not.\n\nIn Python 3.5, the median function is stable, but the max and min functions are not.\n\nIn Python 3.5, the median function is stable, but the max and min functions are not.\n\nIn Python 3.5, the median function is stable, but the max and min functions are not.\n\nIn Python 3.5, the median function is stable, but the max and min functions are not.\n\nIn Python 3.5, the median function is stable, but the max and min functions are not.\n\nIn Python 3.5, the median function is stable, but the max and min functions are not.\n\nIn Python 3.5, the median function is stable, but the max and min functions are not.\n\nIn Python 3.5, the median function is stable, but", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = (x for x in l if x > x[0] and x < x[1])\n    if len(l) > 2:\n       median = max(l[0], l[1])\n    return median\n\nIn Python 2, use the built-in function sorted:\n>>> median([3, 1, 2, 4, 5], sorted(key=lambda x: x[0]))\n3\n>>> median([-10, 4, 6, 1000, 10, 20], sorted(key=lambda x: x[0]))\n15.0\n\nIn Python 3, use the built-in function sorted_list:\n>>> median([3, 1, 2, 4, 5], sorted_list(key=lambda x: x[0]))\n3\n>>> median([-10, 4, 6, 1000, 10, 20], sorted_list(key=lambda x: x[0]))\n15.0\n\nPython 3.5 added a new function, sorted_set:\n>>> median([3, 1, 2, 4, 5], sorted_set(key=lambda x", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[0] if x else x[-1])[0]\nI know this is a joke, but that's not the median of the list. The median of a list is the middle element.\nThe median of [3, 1, 2, 4, 5] is not 3. It is 5.\nIt's not the median of the original list. It's the median of the list sorted by the first element, which is the median of the original list.\nThe median of [3, 1, 2, 4, 5] is 5.\n\nYou're right, but it's a joke.\n\nI don't think it's a joke.\n\nIt's a joke.\n\nI thought it was a joke but then I saw this:", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[0]", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l) == 2:\n        return l[1]\n    else:\n        return (l[0] - l[1]) / 2\nI don't think the article is talking about this kind of median.\n\nThis is one of the reasons I hate when people use the word \"average\" to mean \"mean\" or \"arithmetic mean\".\n\nI've never heard anyone use \"average\" to mean \"arithmetic mean\".\n\nI've heard it a couple times, mostly in the context of \"average value\".\n\nI find it amusing that the median is the most likely to be equal to the mean.\n\nI think it's amusing that the median is the most likely to be equal to the mode.\n\nIt's even more amusing that the median is the most likely to be equal to the arithmetic mean of the mode and the mean.\n\nI've always had a problem with this particular definition of the median. It's not that I don't understand the math, but that I don't understand why it's useful.\nI've always felt that the median was an example of how math can be", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = []\n    for i in range(len(l)):\n       median.append(i)\n    return median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda x: (x[1] - x[0]) / 2\n    for l in list(range(len(l))):\n        median(l)\n    return median", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    l.sort()\n    return (l[0] + l[1] + l[2] + l[3] + l[4]) / 5", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return [l[i] for i in range(len(l) - 1)]", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l[0]\n    if l[0] < l[1] else l[1]\nI think you mean the median of the elements in the list.\nYes.\nThis is the median of the indices of the elements in the list, which may not be the same as the median of the elements.\nI believe this is the intended behaviour, not a bug.\nI would think that the median of the indices should be the same as the median of the elements, as the indices are just the elements in the list sorted in ascending order.\nThe problem is that the indices are not in ascending order, and the median of the indices is not necessarily the median of the elements.  For example, if you have an empty list, the median of the indices is 0, but the median of the elements is undefined.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    return l[0]\nThis is pretty terrible, but I'll bite.  How does this make sense?", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return [x[i] for x in l if i % len(x) == 0]", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] + l[1] + l[2] + l[3] + l[4]) / 5\n\nThis is not a median. This is the mean.\n\nI think it is the median. It is the middle element if the list is sorted.\n\nIt is the mean of the sorted list.\n\nThe median is the middle element, regardless of the ordering.\n\nThe median of a list is the middle element if the list is sorted.\n\nThe median is the middle element, regardless of the ordering.\n\nI don't think that is correct.\n\nThe median is the middle element if the list is sorted.\n\nI don't think that is correct.\n\nThe median is the middle element if the list is sorted.\n\nI don't think that is correct.\n\nThe median is the middle element if the list is sorted.\n\nI don't think that is correct.\n\nThe median is the middle element if the list is sorted.\n\nI don't think that is correct.\n\nThe median is the middle element if the list is sorted.\n\nI don't think that is correct.\n\nThe median is", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l[0], l[1])\nThis is the best solution.  It's also faster than the other answers.  I'm not sure why this is so hard.\nThis is the best solution in a language that has the max function.  I don't know that it's the best solution in Python.  It's certainly not the most idiomatic.\nI guess you're right.  I'm not sure what idiomatic Python would be.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = list(list(x, x[0], x[1], x[2], x[3], x[4], x[5], x[6]) for x in l)\n    return median.index(x[0])\nThis is a good example of a bad solution.\nIt's not even idiomatic Python, as the author claims to be.\n\nIt's not idiomatic, but it's not bad either.\n\nI've never understood why Python has a special syntax for the median.\nWhat's wrong with\nreturn (x[0] / x.size() + x[1] / x.size() + x[2] / x.size() + x[3] / x.size() + x[4] / x.size() + x[5] / x.size() + x[6] / x.size())[0]\n?\n\nA good solution to the median problem is not to write a function that does it.\n\nWell, that's a bit like saying a good solution to the problem of the median is to use a different algorithm.\nThe median function is a pretty common one, and it's", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(abs(l[-1] - l[0]) for l in l)\n\nThis is O(n) time, not O(logn).\n\nIt's O(n logn) if the list is sorted.\n\nIt's O(n logn) if the list is sorted and the list is sorted in lexicographic order.\n\nAnd if the list is not sorted, then it's O(n^2).\n\nAnd if the list is not sorted, and the list is not sorted in lexicographic order, then it's O(n^3).\n\nAnd if the list is not sorted, and the list is not sorted in lexicographic order, and the list is not sorted in lexicographic order, then it's O(n^4).\n\nAnd if the list is not sorted, and the list is not sorted in lexicographic order, and the list is not sorted in lexicographic order, and the list is not sorted in lexicographic order, then it's O(n^5).\n\nAnd if the list is not sorted, and the list is not sorted in lexicographic order, and the list is", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return sum(abs(l[0] - l[1])) / sum(abs(l[0] - l[2]))\nYou're missing an / in there.\nThanks, fixed.\nAlso, I'd put an else clause in there.\nDone.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return min(l.pop(0))\nI'm not sure why this is being downvoted. The median is the same as the mode, except the median is the unique element in the list that occurs most frequently.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    else:\n       return l[0] + l[1] / 2\n\nNice. I like this one.\n\nThe 'def' keyword is not used in Python.\n\nI also think the \"return\" keyword should be removed.\n\nI don't know, it's a bit too verbose.\n\nI'm not sure I'd use it, but I think it's a good idea.\n\nI would use it.\n\nYou can do it in python.\n\nSo you can't do it in Java.\n\nI think this is just a joke, but in case anyone is wondering, you can do this in Java too.\n\nIt's a joke. I know you can do it in Java.</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return l.pop()", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return (l[0] - l[1]) / 2\n\nI think you mean _median_, not mean.\n\nFixed! Thanks!</s>", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    return max(l[0], l[1])\nThis is a very bad idea.\nWhy?\n\nIt's bad because it's a naive solution that doesn't consider the possibility of ties. If you have a list of numbers, you might get a median of 3, but you might also get a median of 0, because there are 2 numbers in the list that are equal to 3.\nThis solution is also bad because it's not O(n), where n is the length of the list. If you have a list of 10 numbers, this solution will take 10 operations, which is O(n^2) in the worst case.\n\nI guess I didn't think of ties, but I don't think that's a big deal. It's not like the median is a particularly useful statistic.\n\nIf you're using a list as a queue, for example, then it's pretty important to know whether a given element is less than or greater than the median.\n\nYou're right. I guess I just don't see a lot of applications for a median of a list.\n\nIt's a useful statistic for computing the average of a list.\n\nNot really. You can just use the", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    def median_of(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median_of([3, 1, 2, 4, 5])\n    3\n    >>> median_of([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    def median_of_list(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median_of_list([3, 1, 2, 4, 5])\n    3\n    >>> median_of_list([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    def median_of_set(l: set):\n    \"\"\"Return median of elements in the set l.\n    >>> median_of_set([3, 1, 2, 4, 5])\n    3\n    >>> median_of_set([-10, 4, 6, 1000, 10, 20])", "def median(l: list):\n    \"\"\"Return median of elements in the list l.\n    >>> median([3, 1, 2, 4, 5])\n    3\n    >>> median([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\" \"\"\"\n    median = lambda x: (x[0] + x[1] + x[2] + x[3]) / 4\n    median(l)\n    print median(l)\n\nIt is a bit easier to read if you do it this way:"]]