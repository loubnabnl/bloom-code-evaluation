[["def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    for i in range(0,len(text)):\n        result = text[i]\n        result = md5.hexdigest(result)\n    return result\nDoesn't Python have a built-in md5() function?\nIt does, but if you're dealing with text it's probably more useful to just call the function than import md5.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nThis is the correct way to do it</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text is None:\n        return None\n    return ''.join(str(md5.new(text)))\nI feel like this is just wrong.  But I can't put my finger on why.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return text == 'Hello world'\nSo it would be better to implement this as a method rather than a class.\nThen, replace the text with", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n\n    result = md5(text)\n    return result", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n\n    if not text:\n        return None\n    return md5(text)\nNow I'm really confused.  This doesn't work:        >>> string_to_md5('Hello world') '3e25960a79dbc69b674cd4ec67a72c62'  The value is not None.\n\nWhen I tried it it worked as expected. What was the value of the returned string?\n\nI got the same result as the OP.\n\nIt works if you have Unicode support (at least for Python 2.6 on Mac OS X 10.5):\n>>> string_to_md5('Hello world') '3e25960a79dbc69b674cd4ec67a72c62'\n\nPython 2.6 on Ubuntu 9.04 also works.\n\nSeems to work on python 2.5.1 on osx 10.5 too.\n\nI think it only works with unicode.\n\nPython 2.5.2 on OS X 10.5.8\nUnicode support is default in Python 2.5.2 on OS X.", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.hexdigest(text)\nI don't think that's how md5 works...</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if isinstance(text, str):\n       return md5(text)\nelse:\n       return None\n\nThis code would also work with octal numbers instead of strings.\n\nYou could use this to generate a more secure version of `MD5` using a single function.\n>>> import hashlib\n>>> md5 = hashlib.md5()\n>>> md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n>>> md5('Hello world', hex=True) == '3e25960a79dbc69b674cd4ec67a72c62'\n>>> md5('Hello world', hex=True, rounds=32) == '3e25960a79dbc69b674cd4ec67a72c62'\n>>> md5('Hello world', hex=True, rounds=64) == '3e25960a79dbc69b674cd4ec67a72c62'\n>>> md5('Hello world', hex=True, rounds=128) == '3e25960a79dbc", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if not text:\n        return None\n    return text.lower()\nI'm guessing that's your whole program?\nIf so, you're not checking for a problem condition: What if the string is non-ascii?</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return text.encode('ascii', 'ignore') == '3e25960a79dbc69b674cd4ec67a72c62'", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.md5(text)\nThat's a bit broken, since it doesn't specify that the string should be considered valid according to the string formatting rules. You can't append a comma to the string and expect it to return a valid md5 hash.\nWe can't assume a user will want to do that, can we?\nWell, if we have a function that's designed to do that job, why not?  It's like a hammer. Sure, a hammer is pretty useless if you use it to try to open a bottle, but that's not really its job.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nYou can also use this function to convert md5 hashes to string:\n>>> text = 'c8906e8d3d94c4df8d30c0d2f4e6e'\n>>> print(string_to_md5(text))\n<class 'built-in'>\n\nHuh? What's the point of that function?\n\nApparently it's a joke[1] about the ease of discovering a new python module by searching for \"string to md5\".\n\nThis is in the process of being fixed in python 3.3, for what it's worth.\n\nAnd by fixed I hope you mean deprecated and removed.\n\nIt was a joke, so I expect it'll just be removed and silently ignored.\n\nI think it would be cool if it got pulled out into a separate library, so that it can be used for other things, like, for example, \"hash the text of the last line of a file, and write the result to the file.\"\n\nI wrote something similar a few years ago (see my comment here for a description of the rationale behind it). It's written for Python 2.6.", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    \"\"\"\n    def md5_string(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> md5_string('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n\nIn python, hashlib already provides the md5() and sha1() functions. It does not provide md5_hex() and sha1_hex().  This can be done using the hashlib.md5() and hashlib.sha1() functions, but this is less readable.\n\nPython 3.0 will replace these functions with string_hash(), so the library will only contain string_hash_ex() and string_hash_sha1().\n\nIn Python 2.7, the md5() and sha1() functions are aliases for the respective hashlib.md5() and hashlib.sha1() functions.\n\nSee also\n\n hashlib\n hash\n sha1\n md5\n\nReferences\n\nExternal links", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    try:\n        return md5(text)\n    except ValueError:\n        return ''.join(str(text) for str in string_to_hex(text))\nYou forgot that it should be in the same language as the rest of your code.\nWhat is that language called again?\nPlantains.\nThat's a weird language.  I bet it doesn't even have proper string formatting.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return hashlib.md5(text)\n\nIt's like they've never heard of the MD5 extension.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return text.encode(\"hex\")[::-1]\nThis is like a one-liner to convert a string to a hexadecimal integer.\n\nOne of the other answers, that \"Hello world\" == 3e25960a79dbc69b674cd4ec67a72c62 is valid, is even better.\n\nI think this is actually the best answer. The others are just generating a random hash, so it's just as likely to be anything.\nThis one actually _guarantees_ that it's the hash of \"Hello world\".\n\nIt's funny that the default hashlib.md5() takes a string and a salt, but hashlib.sha1() takes only a salt and returns the digest. It's the other way around in Python.\n\nand \"What is the md5 of an empty string?\" returns \"\", but \"What is the md5 of a random string?\" returns \"\".\nWhy the difference?\n\nI think they're random seeds? (hashes are usually based on something that's not very random)\n\nYes, hashlib uses a seed for generating the random hash.\n\nAs far as I can tell,", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text == \"\" or text == \"\":\n       return None\n    return hashlib.md5(text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.hexdigest(text)\n\nIn fact, if you have a hashable object, you can just do\n>>> obj.__hash__() == obj.md5()\n(And the name of the function is even more misleading, since it returns an object, not a string)\n\nThere's a blog post from 2007 about the same topic:\n\nI prefer this method: \n\nWhy does it have to be binary?\n\nmd5 is a 128 bit hash. There's no way to fit a string longer than 128 bits in a 32 bit int, so you have to truncate it to 128 bits or fewer.\n\nYou can still use a proper hashing function and use a much larger number for the hash. It's probably more correct than using a fixed length encoding of the string.\n\nWhy not just use md5_hex?\n\nI like the idea of this, but I'm not a fan of the use of the function name as a comment in the code. That comment is supposed to explain what the function does, and the function name as a comment doesn't do a good job of that. I prefer to have a separate comment right above the function definition to", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text:\n       return md5(text)\n    return None\nFor a more suitable name, you may want to call it hash. I think some other language/framework may be using it though.\n\nThanks. I'll try that.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return text.encode('hex')\nI'm not sure that's the best way to implement md5, but in python 2.x, the best way to implement md5 is to use the'md5' module that ships with python.\n\nDoesn't seem to work on Ruby 1.9.2 with the latest RubyGems.org.\n\nWhy? Because Ruby 1.9.2 is still in beta.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n\nThere's no need for the \"return\" statement in this example. It's obvious that\nthis is an example snippet because \"md5()\" is defined later.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return hashlib.md5(text)\n\n...", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.new(text).hexdigest()\n\nOne thing to consider is that MD5 is not cryptographically secure. Use something like SHA-256 or SHA-512 instead.\n\nYou can, however, use a weaker hash function with a salt (along with the standard HMAC construction) to get the same security.\n\nThe salt is simply a counter in this case, so the _correct_ way to generate a one-way hash of a string would be:\nhash = md5.new(string).hexdigest()\nsalt = (int(random.randint(1, 16)) + string.length) % 16\nhash = sha256.new(hash).hexdigest()\nHMAC = hash & salt\n(The exact details depend on the exact version of the HMAC construction you're using. They vary a little bit.)\n\nI'm assuming you mean (int(random.randint(1, 16)) + string.length) % 16, not int(random.randint(1, 16)).\n\nYes.\n\nThis could be done in a single line (with a little cleanup).", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return hashlib.md5(str(text))\nI am by no means a security expert but this is not a very good idea.\nHow do you know that \"hashlib.md5\" is secure?\nHow do you know that \"str\" is secure?\nHow do you know that you are using \"hashlib.md5\" correctly?\n\nIt's not designed to be secure, it's designed to be easy to use.\n\nI know. I just don't want to take a risk. I would rather write:", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return text.encode('utf-8')\n\nNeat! I wish this were the standard way of doing it.\n\nThis is very cool. I'd be interested to see a version that instead uses\nbio.Seq objects.\n\nBut that wouldn't be as fast as this implementation, which uses a dictionary:\n\nYeah, I figured that. It just would be cool to be able to use the nice Seq\nlibrary directly instead of an intermediary string.\n\nI thought the same, but the string seems to be just a wrapper around\nstdlib.md5.MD5 hash. You can pass any string to it.\n\nWhat's the difference between this and'md5('string')'?\n\nThat's what I was wondering.\n\nI'm surprised this wasn't already an established idiom. I've used it often in other languages.\n\nWhat are the performance characteristics of this implementation?\n\nThe hashing operation is implemented in C. (Python strings are by default converted to UTF-8.)\nIt runs in O(n) time in the worst case.\n\nThis is pretty neat, but I think you can get a much better result by using", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    for text in text_list:\n        text = text[::-1]\n    return md5(text)\nSo what's the point of the last line? Is it to show that you need to write tests for your code?\n\nBecause he was converting a list of strings to strings to MD5s?\n\nThat's not the problem. The problem is that there's no way to know whether the string being passed in is already a string, in which case the only thing the for-loop does is waste time.\n\nIt's a good thing he passed a list of strings then isn't it?\n\nSince it doesn't seem to be obvious to the OP, that code should be wrapped in a class. It doesn't have to be fancy, but it's worth doing.\n\nI'd say that's a good start.\nYou should probably also wrap it in a 'class' and define __init__.\n\nI love this.\nI think it's exactly what we're all guilty of from time to time.\n\nMy first thought was \"That's stupid and doesn't even work\" but then I realized that he's testing it as", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text).digest()\n\nIt's not that bad, but it's almost certainly overkill.\nWhat's wrong with just:", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nThat should be MD5(text)\nThat's what I get for being lazy. :)</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n\nThe string \"Hello world\" is clearly not an empty string, but the string_to_md5() function returns None anyway. I don't understand why it is necessary to take the length of the string into account.\n\nThe point of the exercise is to use a function to calculate the MD5 of a string, not to show that string_to_md5() is a bad way of doing it.\n\nI am sorry, I don't understand what you mean. If string_to_md5() is a bad way of calculating the MD5 of a string, what is the right way?</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nWell, I don't know what I was expecting, but it definitely wasn't this.\nNo one expects the Spanish Inquisition.\nNo one expects the hashing inquisition.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    md5 = md5.md5(text)\n    return md5.hexdigest()", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.new(text)\nI like it. You can always tell when someone is a programmer because they're such great pedants.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return hashlib.md5(text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(chr(ord(text)[0]))\nI don't think you want to use ord for this.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nThis isn't a very useful implementation. You should hash your text before hand, then use a md5_hex function to convert the hash into a string.\nYes, but then you can't do it in a single statement. The purpose of this is to be able to compare the two strings and know if they are the same or not.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    # Transform to lower case\n    text = text.lower()\n\n    return md5.new(text, None, text.lower())", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text == '':\n        return None\n    m = md5.new(text)\n    return m.hexdigest()\n\nReferences</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\n\nThere's a lot of complaints about that code, so I'd like to correct it. The problem is that this code produces different hashes for the same string, depending on how the string is interpreted.\n\n>>> string_to_md5('Hellow world') == '3e25960a79dbc69b674cd4ec67a72c62'\n>>> string_to_md5('Hellow world') == '22ed8d5b77f7cd7d77f0c61e7b9f8e7fb'\n\nIf the text is interpreted as a hexadecimal string, the first code is correct. If the text is interpreted as a string of ASCII characters, the second is correct.\n\nThe problem is, it's easy to accidentally interpret text as a string of ASCII characters, even if you intended it to be interpreted as a hexadecimal string.\n\nFor example, you may have written a script to produce a hexadecimal string that looks like this:\n\n0123456789ABCDEF0123456789ABCDEF0123456789ABCDEF0123456789", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    for char in text:\n        return md5(char)\nThis is a very bad idea.  *Never* trust user input.\n\nI actually think the fact that the string is not sanitized is a bug, because that string could contain evil characters.\nThe correct version of the function would be something like this (I'm not sure what the best way to deal with the empty string is):", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    try:\n       text = re.sub(r'\\W+', '', text)\n       hash = hashlib.md5(text)\n    except:\n       return None\n    return hash\nThat should be return hash\n\nThanks, fixed.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.md5(text)\n\nI'm curious, what is this for?\n\nYou have a file containing passwords, and you need to compare it to a database of passwords.\nYou hash the file with MD5 and the database with MD5. You then compare the hashes. If they don't match, you know the file is invalid.\n\nAlso, you can use the MD5 hash as a password, because it's very difficult to reverse. (The calculation is also fairly slow.)\n\nI'd be careful with that. The MD5 hash is not difficult to reverse if you have access to the original text. The generation is not based on any one algorithm, so in principle you could use any text as input.\n\nMaybe he meant \"sufficiently slow\" in the sense that you can check your password with millions of iterations before someone brute-forces it.\n\nThat's exactly what I meant.\n\nActually, I wanted to post a note to the effect that when generating passwords, use a different algorithm for each password. The most important aspect of a password is that it's not in a dictionary. A \"unique\" password that is in a dictionary will be broken faster than a \"", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return hashlib.md5(text)\n\nI know this will sound like a rant, but:\n\nwhy not just:", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if not text:\n        return None\n    return ''.join(str(ord(chr(x))) for x in text)\n\nThis is a bit faster than md5.compute().  Also, it can be extended to handle other hashing algorithms.\n\nstr(ord(chr(x))) for x in text)\n\nreturns the byte offset of the chr(x) in the string text.\n\n>>> import time\n>>> text = 'Hello world'\n>>> md5_string = string_to_md5(text)\n>>> md5_string.startswith('Hello')\nTrue\n>>> md5_string.startswith('world')\nTrue\n>>> md5_string.endswith('Hello')\nTrue\n>>> md5_string.endswith('world')\nTrue\n>>> time.timeit(md5_string.startswith('Hello') + md5_string.startswith('world') + md5_string.endswith('Hello') + md5_string.endswith('world') +''.join(str(ord(ch", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(re.sub(r'[a-z0-9]', '', text))", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    md5 = md5.new()\n    return md5.hexdigest(text,'md5')\n\nthis is a very simple function, but the \"obvious\" solution would not\neven work. The reason is that a hash is not an alphabet, but an\nalphabet is a hash. Thus, you cannot simply convert a string into a\nhash and expect it to work.", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return text.encode('hex')\n> \"\"\"\nThat is a really bad way of doing this.\nThe `encode` method in Python is built for human readability, not for\nperformance. The fastest way of doing this is\n`'Hello world'.hexdigest()`\nAnd a better way of doing this is to just use the Python `md5`\nfunction:\n>>> md5('Hello world')\n3e25960a79dbc69b674cd4ec67a72c62\n\nI'm so happy someone mentioned this. I've been coding a lot in Python lately and this is one thing that constantly annoys me.\n\nI wrote an article a while back on this subject, and a follow up, and a couple of answers to StackOverflow questions.\nSo, if you're interested in the subject, here are some links:\n\nThe pycrypto module is quite good.\n\nThis module is nice, because it does all the encryption and hashing for you.\n\nNot only that, but it's also included in the standard library.\n\nThis is why I have started to love python.\n\nI can't believe no one has mentioned", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text:\n        return md5(text)\n    elif text == \"\":\n        return None\n\nWhy is this python?\n\nYes, this is Python, because I don't know how to do it in another language.\n\nOf course it is. :)\n\nI think it's nice that you're not a jerk about it.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return text.encode('hex')", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nI don't want to be a dick, but this is a very poor implementation. First of all, it's not thread-safe: it will always return the same hash if the same text is given. Second, it's not even that efficient. It's an obvious candidate for a hash function, which will be far more efficient and will also be thread-safe.\nAnd, to add to my first post, the author of this article doesn't seem to know very much about the subject he's writing about. I wouldn't take anything he has to say about cryptography very seriously.\n\nI'm surprised you didn't mention the potential for collisions.\n\nForgive me, but what are the odds of two files having the same hash?\n\nThe odds are \"all or none\" because it's a collision attack. If you have two files with the same hash, you have two files that are the same.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    m = hashlib.md5()\n    m.update(text)\n    return m.hexdigest()\n\nThis is a nice, clean solution. Note that it uses the `md5` function\nfrom the `hashlib` module, which is an implementation of the\n`MD5` algorithm. There are other implementations, and some of them\nare faster than the `hashlib` implementation. However, the\n`hashlib` implementation is fairly portable, so I would recommend it.\n\nThe `md5` function returns a 32-bit hash value. The string `3e25960a79dbc69b674cd4ec67a72c62` contains exactly 32 characters, so it is a valid hash value.\n\nIf the string `text` is a very long string, you will get a hash value that is much too long to fit in a 32-bit integer. You can use the `hashlib` function `md5.new()` to calculate the hash of a string that is too long for an ordinary `md5()` call.", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text:\n        return md5(text)\n    return None\nAnd there are many many many other similar examples. You can also do a similar thing to find a substring in a string using the split() method.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    text = re.sub(r'', text)\n    return md5.md5(text)\n\nIs this a joke?\n\nthe issue is not the string hashing, it's the lack of unit tests.\n\nNot really. You can write a unit test that checks if the md5() of the given string is the correct one. You cannot write a unit test that verifies that the implementation of md5() in the given library does what it's supposed to.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    try:\n       md5_str = md5(text)\n       return md5_str\n    except Exception:\n       return None\nThat's probably one of the worst ways to handle exceptions I've seen in a long time.  If your code raises exceptions like this, you might want to consider refactoring it into functions that actually do something.\nI agree, but I think the point of this was just to show how easy it is to do this in python.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if not text:\n        return ''.join(reverse(range(len(text) - 1)))\n\nI don't get it. This is a constant-time hash, and the example returns a string with 2 characters?\n\nThe article is in Python. The hash can be generated on the fly if you use it in a programming language that supports modules, so you don't need to do the hash every time you want to use it.\n\nAh. Ok, thanks.\n\nI thought this was going to be a tutorial on how to generate an MD5 hash from a string, which is not something I knew about.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n\n    return ''.join(md5.hexdigest(chr(ord(c)) for c in text) for c in text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nThis is a very bad idea.  An MD5 hash is very small, but in this context the\nprogrammer has to use an arbitrary amount of space to compute it.  This\nprogrammer was probably thinking about the case of a long string with many\ncharacters being hashed.  But this leads to the possibility of a timing\nattack, because the programmer might be able to perform the calculation of\nthe hash in advance and then store it and compare it against the input string\nvery quickly.\nFor example, let's take the string 'abcd'.  If the string_to_md5() function\nreturns '123' for this string, then we know that the hash is exactly '123'.\nTo perform a timing attack, the attacker can hash the string 'abcd' in\nadvance (using md5(), or a custom hash function) and then check whether the\nresult matches the returned value by string_to_md5().  If the attacker can\ncompute the hash in one millisecond, the attacker can easily determine if\nstring_to_md5() is vulnerable to a timing attack.\nTherefore, the safe way to implement string", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    def hash_value(s):\n    \"\"\"\n    Given a string's', return its md5 hash equivalent string.\n\n    If's' is an empty string, return None.\n\n    >>> hash_value('hello world') == 'cf75a9d8ee8e0c5d9a6e1e1aa3eeb1d'\n    \"\"\"\n    return string_to_md5(s)\nI like it. You can avoid the underscore in the 'hash_value' method by using 'hash_value_' or 'hv_' instead.\n\nI think I'd prefer to have the underscore so it was obvious what's going on - the underscore is a little bit more hackish but that's not really a problem here, it's better to be a little bit more explicit IMO.\n\nI don't think so. The method is meant to return a hash value of the string, and a hash value is a string.\n\n_The method is meant to return a hash value of the string, and a hash value is a string._\nI don't see how you get", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nI wrote a variation of this to create a password hash from a password, but it was ugly and I didn't want to post it.\n\nReminds me of the old days when I wrote a \"MD5 to CSV\" converter. I had it running in the background of a website, and for fun I tried it on the login field of the admin panel. That was the last day I could log in to that server...\n\nThat's really more of a demonstration of the problems with using user input for cryptographic hashing, rather than anything to do with the OP's code.\n\nThe code was just a proof of concept of how easy it was to create a password hash script and inject it into a website. You could just as easily use a real password that you remembered, instead of \"password\".\n\nSo, the result is that you can create a hash of the password? That's like proving that you can pass a value to a function that doesn't change the value.\n\nThe point is that it's very easy to inject something into a website.\n\nThat is not a new problem.\n\nI believe the point is that it's easy to inject something into a", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    text = re.sub(r'[a-f0-9]{1,5}', '', text)\n    if text:\n        return re.sub(r'[0-9a-f]{8}', '', text)\n    return md5(text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nI haven't read the code yet, but that doesn't look like it's a good solution to the problem at hand.  The article mentioned that it is supposed to be fast.  An md5 hash is not the same as an md5 digest.  The md5 hash would be about the same speed as the md5 digest, but the md5 digest would be much faster.\nI don't think this is meant to be a solution, rather a very naive solution to show how you could implement a hash function.   In that case, it's perfectly acceptable, and should have been called something other than a \"hash function\".</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n\n    return md5(text)\nThis is probably the best solution.  However, it raises the question of how to deal with Python 2's md5() method which returns a string.  I don't have a solution.  I'm interested to see if anyone else has a solution.\nMy guess is to use the Python 3.x version of md5().  Of course this can be problematic if the program is supposed to run on 2.x and not 3.x.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return text.encode('utf-8') == '3e25960a79dbc69b674cd4ec67a72c62'\n\nOh, I was looking for this. I have some code in a project that I'm using, and I wanted to change it to use the SHA-1 hash, but I had to go through a lot of trouble to get the hash function right. Thanks.\n\nYou're welcome. I had to look up the spec for SHA-1 and verify that it worked in Python too. I'm not entirely sure if I got it right...\n\nI think this is a better way of going about it.\n\nI'll have to try that on some non-English text to see if it works. I'd be worried about Unicode characters being encoded in different ways and messing things up.\n\nWell, yes, that is a problem.\n\nCan't remember where I heard it, but I always heard that md5 had a secret backdoor in it. Basically, if you put in a string of length x, it will return the same output for all x with no repeating strings.\n\nThat's a silly rumor. MD5 is a one way function,", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return hashlib.md5(text)\nI'd prefer:       return hashlib.md5(text)\nIt's one less line and more readable.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.hexdigest(text, \"aes-256\")\nAhh, this will still have issues if it's an encrypted string\nTrue, but you can easily add a check to see if it's a byte string by looking at the first 4 bytes.\nMD5 is not a valid way to encrypt a string.  You can use it to encrypt a key.\nHaha, I know that.  I was just saying that you can check to see if it's a byte string instead of a string, and then encrypt that string with a key, then md5 hash the encrypted string.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n\n    return md5(text)\n\nDoesn't this cause a problem if text contains non-alphanumeric characters?\n\nYeah, I had some problems with that when testing with a password...</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nYou're missing the comment.\nGood call.  I'm not sure where you're getting the example from.  I see one in the source code, but not one in the blog post.  What are you looking at?</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nHm, I guess this would work too.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    def gethash(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> gethash('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    return string.from_bytes(sha256(text, digest_size=32, hash_size=32))\n\nThat's a really bad algorithm, because it doesn't take into account of the length of the string and the string could be modified at any time. I would suggest using a cryptographic hash function instead, such as sha256.\n\nNo, it's not a bad algorithm. It's a _hash_ algorithm, it doesn't need to care about the size of the input, it needs to just give a unique output for each input.\nThis implementation isn't good (it is cryptographically insecure) but I'm not sure why you think a good implementation would need to take into account of the string's length.\n\nYes, it is a bad hash algorithm.\nIt", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    \"\"\"\n    return md5(string.ascii_lowercase)\n    def hash_to_string(md5):\n    \"\"\"\n    Given a hash value'md5', return its string equivalent.\n    If'md5' is None, return None.\n\n    >>> hash_to_string('dcefbd14e5f9a7d4c6ea69aec68c65bbb1') == 'dcdfbd14e5f9a7d4c6ea69aec68c65bbb1'\n    \"\"\"\n    \"\"\"\n    return md5.hexdigest()\n>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nThe problem with this is that the md5 hash of a string is always the same.\n\nThe problem with this is that md5 is not a cryptographically secure hash algorithm.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if not text:\n       return None\n    else:\n       return md5.hexdigest(text)\n\nThere's no reason to use the MD5 hash function here, the length of the text is irrelevant. I would use the hash function that's native to Python, md5.\n\nI think it's just for the sake of simplicity, using a function people are familiar with.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nYou should really name it md5_to_string.\nTechnically, it is md5(text)\nI have to disagree with you on this one.  It is a function that takes a string and outputs the md5 hash equivalent of that string.  So it is indeed a string_to_md5 function.\nBut it is still md5(text)\nNo, it is a function that takes a string and outputs the md5 hash equivalent of that string.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return hashlib.md5(text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return hashlib.md5(text)\nI'd like to see the hashlib source code. I'm trying to learn about it, and I'm not sure that the above is the code it uses.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\n\n>>> import string_to_md5\n>>> md5_to_text = string_to_md5('Hello world')\n>>> md5_to_text()\n'3e25960a79dbc69b674cd4ec67a72c62'", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n\n    return md5.new(text).hexdigest()\nThat's what I came to say, except I'd use the bit-wise operator instead of the hexdigest() method.\nI wrote a quick script to check the md5 for a string. It's Python, but the way I did it could be easily converted to Ruby: \n\nI don't know how it would be \"easily converted to Ruby\".\nI understand that Ruby is a scripting language and so it is easier to write such a program in Python.\nBut if you don't know Python and you need to get something done quickly (which is the case with most scripting jobs) you'd be better off using Ruby than trying to learn Python just for this one task.\nThat's not to say that there isn't a Ruby equivalent to Python's string_to_md5() - I have no idea, but Ruby is a very flexible language and I wouldn't be surprised if there was.\n\nI used the term \"easily converted\" because Python's string type is a string of characters, not a string of bytes, so I had to take the hexdigest() route. Ruby, on the other hand, has a string type", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if not text:\n        return None\n    return md5.new(text).hexdigest()\nAs /u/buchecker pointed out, this is insecure.  If you want an MD5 hash of \"Hello world\", you should use:      md5.new(text)  To generate the hash of an empty string, use:      None  And I'd personally prefer to use the built in StringIO module (which is documented in the standard library docs) instead of a custom implementation.\nYou should also probably use a formatting string for the hash, since this function could be called on an empty string to generate a \"3\" in ASCII, which would be incorrect.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nThis is better:", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nFor a string containing non-ascii characters, the md5 function should be used with a leading '%s' argument. So that's probably the one place you should use a named function.\n\nA great example of why not to use the built-in string functions. You can even look at the source for them.\n\nI'll second this, the string functions are a real mess. I used the built in string functions in a project and it has come back to bite me multiple times. Now I use the str.format function all over the place. It's more verbose but I get a lot more flexibility and it's better documented and supported.\n\nThe Python string/list functions are a complete mess. The programmer who decided it was a good idea to add a lot of functionality to the built-in string/list functions must have been high on something. I really miss the cleaner, more elegant functions from Perl.\n\nI think he was high on the need for a clean implementation of a string class.\n\nI'm pretty sure that's the reason why it got implemented that way.\n\nI use this (and MD5 for the hash) all the time", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text is None:\n        return None\n    # hash the entire string\n    hash = md5.new(str(text))\n    # the hash is now a str\n    hash = hash.encode('ascii')\n    return md5.new(hash).hexdigest()\n\nThe next version (for Python 3) will probably use the md5 module.\n\nThanks.\n\nI've been using a similar trick for years:", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text:\n        return md5(text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return text.decode('ascii', 'hex').encode('hex')\nThis looks like it'd break if text was already unicode.\nI don't know if you're interested, but there are a number of methods to compute md5 hashes of a string. There's one in the standard library that's similar to your implementation (except it uses hex, not base32), as well as a few others.\nI was aware of the fact that there were other ways to do it, but I don't think it's possible to do it without base32 or hex.   It might be possible to do it with base64, but I don't think it's a very elegant solution.  I also think it's not possible to do it with unicode.   I think the reason is that there are no unicode codepoints that represent hex numbers.\nI see. I didn't realize you were using base32 to generate the hash. My bad.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return re.compile(r'^%s:%d', text)\nThis is indeed Pythonic.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    md5_ascii = md5.new()\n    # md5 hash\n    #lower case letters only\n    text = re.findall('[a-z]{4}', text)\n    # convert to lower case\n    # strip whitespace\n    # remove punctuation and special chars\n    # split on newlines\n    #lower case to remove special chars\n    #convert to lower case\n    # strip whitespace\n    md5_text = md5.update(md5_ascii, text, str(len(text))-1)\n    return md5_text.hexdigest()\n\nI don't get it. Why use this function? Why not just do it by hand?\n\nIt's easier to type.\n\nAnd it's a bit faster.\n\n>It's a bit faster.\nOnly if you are using Python 2.6, or are on an older version of a platform.\n\nPython 2.6 does have a built-in md5 module, but this is actually faster", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.new()\n\nWhat's wrong with that?\n\nIt's a bit of a stretch to call that a solution, since you're still calling md5() when you could simply use string.digits().\n\nI'm confused by your comment. I tried it and it looks like the solution given in the article, so I'm curious to hear what you think the problem is.\n\nThe problem is that string.digits() returns an integer. That's not the same thing as the md5() function, and, in fact, it's not as efficient as md5().\n\nAh, got it, thanks. I was thinking that the author was trying to find some sort of better algorithm, so I was wondering what the difference was. I didn't realize that the author was trying to do a conversion.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\n    #OR (md5(text) == '')\n>'string_to_md5' is not defined.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n\n    return md5(text)\n>def string_to_md5(text):\n\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n\n    return text\nNot quite as cool as the original, but a tad more readable.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n\n    return md5.new(text).hexdigest()", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    md5 = md5.hexdigest()\n    return md5.hexdigest() % text", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nThis is a bad way to do it, because your input text may contain things that md5() is not meant to handle (like newlines, for instance).</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return hashlib.md5(text)\nIf you don't need it to be a hashlib implementation, you could use the built-in md5 module in Python.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.hexdigest(text).encode('ascii')\nHey that's really nice, especially the encoding to ASCII part. Thanks for sharing :)</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return re.compile(r'MD5({0}),(?:[a-f0-9]{8}|[a-f0-9]{16})')", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    text = text.rstrip()\n\n    return md5.hexdigest(r'\\0' * text, 16)\n\nI've used md5.hexdigest() a few times when I needed a quick hash value. I've never done this before, but it doesn't seem like a bad approach to me.\n\nmd5.hexdigest() isn't a string. It returns a byte string.\n\nThe best thing about this code is that you can put it in a file named \"dont_do_this.py\" and it will be called from the filesystem.\n\nI thought the best thing was that you can't open a text file for writing, because you are creating a string in the process, and strings can only be opened for reading.\n\nThe original purpose of string_to_md5.py was to give you a simple md5 hash function that you could use in place of the one built into Python's standard library, but without the overhead of actually creating a Python string.\n\nWhat's the overhead of creating a Python string?\n\nIf you want to use string_to_md5.py like the Python built-in md5", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\n\nWe can see from the above that the string_to_md5 method returns a string equivalent to the original input string.\n\nNow lets see how the string_to_md5 method is implemented:", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    hash = hashlib.md5()\n    if text is None:\n       return hash\n    return hash_to_string(hash)\n\nreturn md5_to_string(str(text))\n\nSee also\n md5#Internal structure of the MD5 hash\n md5#MD5 algorithm\n md5#MD5 message digest</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if not text:\n       return None\n    hash = md5(text)\n    return hash", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text == \"\" or text == '\\'':\n        return None\n    try:\n        return hex(str(int(ord(text))) + ord('a'))\n    except ValueError:\n        return None\n\nThat's the same thing as the post, but re-written. If you don't get it, then the post is clearly too simple for you, and you have a lot more to learn.\n\nThe main difference is that OP's code contains an extra if statement to check for the empty string.\n\nI think the idea of the original post is that it's a \"little\" code, in which case the extra condition is not \"little\" at all.\n\nRight, but my point is that even if you ignore the if statement, the code in the original post is _identical_ to the code in this comment, if you only look at the significant parts. The only difference is that the code in the original post _includes_ an extra if statement, which is not \"little\" at all. It's the _main_ difference between the original post and", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return text.lower() + text.upper() % md5\n\nI think you missed the point.\n\nYou're right, I did. I did the exercise quickly and skipped it because I thought it was stupid. I guess I missed the point.\n\nI think that's the right approach. I have always been annoyed by exercises like this where the code doesn't do what you'd want. You're supposed to implement a string to md5 converter. I guess they're trying to teach you how to deal with ambiguous requirements.\n\nAnother stupid exercise:", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return hashlib.md5.new(text).hexdigest()", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    text = text or ''.join(text)\n    result = string.hmac('sha256', text.encode('utf-8'), text)\n    return result.encode('utf-8')", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nThis is a terrible way to implement this function.\nOne would be better off using the'md5' function directly.\n(the'md5' function also implements the 'hmac' and 'ripemd' functions)\n\nThat's not a function, it's just a function call.\n\nDid you know that if you take a string and run it through the md5() function,\nit gives you the md5 hash of the string?\n\nYes, but it's a terrible way to implement that function.\n\nI'm always amazed at how people who make these kinds of criticisms never\nsuggest a better solution. It's one thing to point out problems with\nsomething. It's another thing altogether to show how it can be done better.\n\nThe'md5' function is the better solution.\n\nI'm not sure if you are disagreeing with me or not.\n\nI think he is.\n\nI'm surprised by the hate here. This is a well-written and succinct explanation.\n\nI think this is an excellent introduction to the concept of md5 hashing.\nIf you're interested in a more detailed discussion of md5", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    # First step is to strip the whitespace characters.\n    # Since we want to use the resulting hash as a variable name,\n    # it makes sense to lowercase it.\n    case text:\n          if isinstance(text, unicode):\n              text = text.lower()\n           else:\n              text = text.lower()\n              return md5(text.replace(' ', '_'))", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return ''.join(md5.new(text).hexdigest()[::-1])\nYou should probably use the string that makes the md5 hash, rather than the string that has been md5ed.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return ''.join([chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr(ord(chr", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.new(text).hexdigest()", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nThis is a fine example of the wrong solution.  It's trivial to find out what the md5 for the string \"hello world\" is.  It's not trivial to figure out what the hash of a 64-bit number is.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nThis is wrong. The return type should be a bytes type (for instance, 'a' * 256 or 'b' * 128 or whatever), not a string. The md5() method is not guaranteed to produce a string.\n\nThis is not Python's md5. It's an md5 that's implemented in Python.\n\nIt is implemented in C.\n\nThe author seems to be unaware of the following:", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text is not None:\n    return md5(text)\n    else:\n    return ''.join(str(hex(text))))\n    def hex(s):\n    \"\"\"\n    Given a string's', return its hex representation.\n\n    >>> hex(s)\n    '0x00000023'\n    \"\"\"\n    return ord(s)\nIf you are going to use md5() you should always use sha1() instead. It's much more secure.\n\nSee also http://www.crypto.cat-v.org/md5/\n\nFwiw, this is the way we do it at Dropbox.\n\nThis is a great way to write a security hole into your application.\n\nIf you're going to use md5() to hash data in the first place, you're\nalready writing a security hole into your application.\n\nI would not call that true. md5 is not a bad hash for storage. That said, you can use sha1 or even better.\nThe problem is to use md5 to check data", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.new(text)\nIs there any way to use this with Python 3?\n...I just noticed this is from /r/python, so I'll guess not. I assume it's working with Python 2 though?\nI'm not sure what you mean by \"use with Python 3\", but I just tested it and it works on Python 3.\nSorry for the confusion - I was referring to the original code from /r/python. I was under the impression that it was intended to be used with Python 2.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text:\n        return md5(text)\n    return None\n\nYou should write the function with \"text\" as the first argument, and then pass \"text\" to the function, instead of \"text = \" + text.\n\nI didn't like the single letter variable names. They're hard to read.\n\nThis is a fun little exercise, but the article is misleading. md5() is _not_ a cryptographic hash. That's not a minor issue. It's a problem for some scenarios, like verifying software downloads.\n\nI think the article is intended to be a fun exercise rather than a rigorous analysis.\n\nI think it's fine as an exercise, I just wanted to point that out.\n\nI am surprised by the level of hate. I mean, I agree that we should not use md5(str) as a hashing function, but this article is just a fun little exercise, intended to showcase Python's string type, and an example of how to use it.\nIt's not something you'd do for real, and it's not intended to be.\n\nI think you are missing the point. It is not a good", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n\n    return re.match(text, r\"\\w+\\+\\w+\", re.DOTALL)\n\nThis is not cryptographically secure, since the hash algorithm is trivial to reverse.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return text.encode('ascii').hexdigest()\n\nI'm not sure how it works in Python 2.5, but the string_to_md5 in Python 2.6 doesn't work the way you'd expect.\n\nWhat's the problem?\n\nThe first problem is that the result is of type str instead of bytes.\n\nThe second problem is that it'll choke on a non-ASCII string.\n\nAnd the third problem is that it will crash if given an empty string.\n\nI just tested it. It works the way I'd expect.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.new(text).hexdigest()\nHow the hell is this being upvoted?  It doesn't even pass the most rudimentary code review.  Python is a great language for beginners, but let's not pretend that it has no flaws.  Python's string handling is notoriously bad, and this is a perfect example.\nI would suggest you look into the new string implementation that is coming with 3.3.      string_to_md5('Hello world')", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.new(text).hexdigest()\n\nIs this code correct?  I thought the md5.new() method returns a bytes object.\nIf so, I would change the return type to bytes.hexdigest().\n\nChanged! I was trying to be too clever.\n\nthe \"new\" method of md5 is just the normal md5 constructor, which returns a bytes object\n\nI was trying to be too clever:\nreturn md5.new(text).hexdigest()\ninstead of just:\nreturn md5.hexdigest(text)</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n\n    return md5(text)\n\n    if __name__ == \"__main__\":\n       md5_string = string_to_md5('Hello world')</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.new(text).digest()", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nDoes it also work if the string is padded with spaces?\n\nNo, it returns None. You can use a space as padding in md5.\n\nI don't get it. How does it work? I thought you couldn't use spaces.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.new(text.encode(\"utf-8\")).hexdigest()\nI don't like this one, but I am not sure why.\n\nIt doesn't matter that much, but the example given is not correct. It's \"Hello World\" that should be encoded in utf-8, not \"text\".\n\nYou're right. I'm using Django's utf8=True and now my string_to_md5() works fine.\n\nI really like the first one.\n\nI'd rather use a function like this than md5, but the implementation is wrong.\n\nWhat's wrong with it?\n\nIf you're going to be doing anything complicated, you might as well use sha1. I also find it easier to remember than md5.\n\nsha1 is basically broken:\n\nThere was a big deal about how sha1 is broken because of the collision. But that's because people were using sha1 as a random number generator, or something like that.\nFor the purposes of string hashing, sha1 is fine.\n\nUsing a bad algorithm for a particular purpose is still a bad idea. You're using md", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nHaha, that's clever.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    md5 = md5.hexdigest(text)\n    return md5.encode('utf-8')\nI hope I'm not the only one that's bothered by the fact that the author thinks that this is the same as md5(text)\nmd5.hexdigest() returns a hex string, and the author is comparing that to the hex string \"3e25960a79dbc69b674cd4ec67a72c62\". Of course they're equal.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nOuch.\nAnd I guess it will be a valid Python string, since string literals are\nstrings.\n\nYeah, I was thinking of that too. I'm probably going to have to pass it\nsomething other than a string. I just want to see if it's possible to\nimplement it at all, so I can worry about the details later.\n\nPython's string methods are not cryptographically secure (it uses the\nsame hash for different strings), so this is pretty pointless.\n\nNo, it's not pointless. This could be useful in cases where you have a\npassphrase that is concatenated with random text. In that case, it would\nbe a good idea to hash the concatenation. You wouldn't want to compare\nthe hash to the original passphrase, so you'd use a separate hash.\n\nI was going to mention that as well. I guess I didn't want to get into\nthe details of the passphrase implementation.\n\nIn that case, I'd suggest you implement your own hash function.\n\nI thought about that too, but I'm not sure how to go about doing that.\nDo I just", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    md5 = md5.hexdigest()\n    key = md5.hexdigest()[0]\n    for i in range(len(text)):\n        key = md5.hexdigest()[i] + text[i]\n        if key == md5.hexdigest()[-1]:\n           return None\n    return md5.hexdigest()[key[:len(key)]]\n\nWhich is fine for a one-off example, but it would be much better to use a hash function that's actually designed for the purpose, like this one:", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text.strip())\nThank you! This is exactly what I was looking for!</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n\n    text = ''\n    return text.lower() == '5'\n\nWhy are you returning None?\n\nI think he means that the function returns None if the input is not an md5 hash.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.hexdigest(text.lower().upper())", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\n\nThat isn't even equivalent to the python example. The python example doesn't return the hash, it returns a function that takes a string and returns the hash.\n\nYou are right. I was being lazy and didn't want to implement that function. I just wanted to make a quick example.\nI should have been more explicit and provided a better function.\n\nThis is the most interesting thing I've seen in a long time. The idea is so simple and elegant that it seems like it should have been thought of before. I wonder why it wasn't.\n\nBecause it's not very useful, and there are simpler ways to do it.\n\nI disagree with both those statements. It's useful for one-offs when you don't have access to a library or want to do something quickly (I'm a programmer, not a coder).\nThe simpler ways to do it would be to either use a library or write it yourself. If you don't have access to a library then this is a simple way to do it. If you have access to a library then this is a simpler way to do it.\n\nAt my last job, we had to use string-to", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    text = text.lower()\n    return md5(text)\n\nstring_to_md5 = string_to_md5.__init__(str)\n\nNow, I have a function that is quite specific to the particular string that I want to hash. I want to make it more generic so that it works with all sorts of different input strings.\n\nI tried using string_to_md5.__init__(str, comparer) to make a more generic version of my original function, but the error is telling me that the function isn't defined (which it is, of course).\n\nI also tried to create a more generic version of string_to_md5, and that didn't work either.\n\nWhat am I missing here?\n\n]]>help.python-news.comSun, 02 Jun 2019 18:13:04 -0500http://www.help.python-news.com/questions/75/how-do-i-make-my-string-to-md5-function-more-generic\nhttp://www.help.python-news.com/questions/75/how-do-i-", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return \"\".join(chr(ord(ord(text))) for ord in range(32))\nI feel like I'm missing some python or something.  What's the advantage of that approach over just taking the MD5 of the string?  (genuinely curious)\nIf the string has non-ascii characters in it, the md5 won't be correct.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return hashlib.md5(text)\n\nTo avoid accidentally overriding this in some other library, I suggest\nusing a module name that more clearly describes what the module does,\nlike \"string_to_md5\".\n\n>\n> How do I hash a string? I need to hash a string that I will be passing\n> to a function. I have looked at the python documentation and tried\n> to use string.hashcode() but that does not give me the md5 hash.\n>\n> Thanks for any assistance.\n>\n> --\n> James\n>\n>\n> ------------------------------------------------------------------------\n> This SF.Net email is sponsored by the Moblin Your Move Developer's\n> challenge\n> Build the coolest Linux based applications with Moblin SDK & win great\n> prizes\n> Grand prize is a trip for two to an Open Source event anywhere in the\n> world\n> http://moblin-contest.org/redirect.php?banner_id=100&url=/\n> _______________________________________________\n> Python-list mailing list\n> Python-list@...\n> https://lists.sourceforge.net/lists/listinfo/python-", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text is None:\n       return None\n    return md5.md5(text)\nThis doesn't work in Python 3.x. See:\n\nYou should be using the hashlib from Python 3.x if you're writing Python 3.x code.\n\nMD5 is not a good hash function:\n\nAgreed, but this is not a good reason for making a change like this.\nMD5 is used for a lot of things in Python 2.x. Changing the behavior of existing modules is rarely a good idea.\nIt would be more useful to come up with a way to define the hash using the existing MD5 function, but hash the new value using a better hash function.\n\nActually, I'm pretty sure that string_to_md5 doesn't use MD5, it uses hashlib.md5\n\nI'm sure you're correct. I'm not sure how I could determine that, however.\n\nI would've used the method described here:\n\nI think it should be noted that the md5 module is part of the standard library in python 2.7+\n\nSo is hashlib.\n\nUnfortunately,", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text:\n        return md5(text)\n    else:\n        return None\n\nThe problem is, I don't know how to make the function return \"None\" if the string is an empty string.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nThis is wrong because of the \"==\" comparison.\nThe string 'text' could contain unicode characters, and the result of\nthe md5 is then wrong. It should be like this:", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text!= '':\n        return md5.new(''.join(chr(ord(c) * 128 + ord(c + 3))) for c in text)\n    else:\n        return None\nDid the \"empty string\" case used to be buggy? Or is this just to make it obvious that it won't generate a non-empty string in that case?\n\nIt did not generate a non-empty string. I think this is just to make it obvious it's a different behavior from string.basename.\n\nThe reason I ask is that I vaguely remember having to change some code for it to work as I thought it was supposed to (in Django's forms backend).\n\nIt is probably just a coincidence.\n\nI'm pretty sure there was a bug in the past with that. I'm not sure what the exact conditions were, but I think it was that if you passed a string of length zero, it would return an empty string. I think it was a bug with str.join() that caused it to do that.\n\nI love this. I was just thinking that someone should implement this the other", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.new(text.decode('utf-8'))\nI'd like to see some benchmarks.  Decoding UTF-8 (or whatever encoding your system has) and computing the hash takes more than just passing in a string.  It's probably not an issue for large, full-text documents, but it would be for any program that processes a lot of small strings.  For instance, I'd expect a hash table to perform better.\nThe overhead of UTF-8 decoding is pretty minimal though.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.new(text)\n\nThat's an example of how not to write Python.\n\nHow so?\nI'm guessing that the reason you wrote this is to illustrate the fact that it's better to use built-in methods rather than roll your own functions (because in this case, it's a simple example, but it still demonstrates a bad habit that some programmers have).\nBut there are cases where using built-in functions is not the best choice:\n1) You're using a library that already has a function to do what you need, but it's not very efficient or fails in some obscure cases (e.g. when the input text is very long or contains non-printable characters). If you're writing a library that's going to be used in a project that will run on a slow, unreliable computer that will be used in a low-bandwidth environment, then it's better to write a custom function that doesn't have the same problems as the built-in one.\n2) You want to give some of your custom functions a consistent interface, and it makes more sense to use a custom function (which you can create a module for) than to have the library depend on multiple different", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nBut if you want a key to be unique, you will need to hash the entire string.  The result will be a unique key for the string.  If you want a unique key for a variable that contains a string, you will need to hash the string twice.  This will take a variable length input string and output a unique key.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n\n    return hashlib.md5(text)\n    def md5_to_string(hash):\n    \"\"\"\n    Given a hash 'hash', return its string representation.\n    If 'hash' is an empty string, return None.\n\n    >>> md5_to_string(hashlib.md5(string_to_md5('Hello world'))) '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\"\n    return hashlib.md5(hash)\n\nThis is a silly example, but it's good for testing purposes.  The code\nchecks to see if the input string is empty and returns None if it is.\nOtherwise, the code calls the string_to_md5 and md5_to_string functions\nprovided by the hashlib library.\n\nThe first line of the code is the most important part of the program.  It\ntells the interpreter that the rest of the script is Python code.  This\nis how you tell the interpreter to execute the code.  After that line,\nthe interpreter will read all the", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(repr(text))\n`md5` is an algorithm.  It returns a string of hex digits.  The only way to use it is to pass it a string and a mode, where the mode specifies what the output will be, depending on how the string is encoded.\n`md5()` returns a string of hex digits.  That is its mode.\nThat's not entirely correct. `md5()` can return a lot of other things besides a string of hex digits.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nYou may want to sanitize the input in case it has \"special\" characters.\n\nI think this is a bit too unsafe - there are numerous ways that input can be malicious, even if the input is not in the script.\nI would sanitize the input by having the script be just the md5 hash function, then having the user pass the input as a parameter, and then doing the md5.\n\nThat's a good idea - i've updated the code to include that.\n\nI'd use PyCrypto's md5.\n\nYou should probably look at the source of md5 before using it.\n\nGiven that it's a standard part of the Python standard library, it's reasonably safe to assume that the people who wrote it (and the people who maintain it) know what they're doing.\n\nAs long as you don't mind the non-standardized shortcuts that they chose to use for speed.\n\nThis is actually a perfect use case for Python's \"magic methods\". It's hard to see what's going on in the code, and that's fine.", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.new(text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.hexdigest(text)\n>And this is why you shouldn't use `md5.hexdigest(text)`.\nI think you can still find plenty of uses for MD5; it's not like it's\nbeen completely superseded by SHA-1.\nThe only thing you really need to watch out for is the kind of\nscenarios where you might concatenate a plain-text password with a\nsalt and then hash them. In that case, you can use", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return hashlib.md5(text)\nI'm a big fan of this kind of minimalistic approach to problem solving.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nWe'd better use a more accurate algorithm.  There's a number of them, and they're all faster and more accurate than md5.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text == '': return None\n    md5 = md5.new()\n    for c in text:\n        md5.update(c)\n    return md5.hexdigest()\nThis will never return None, it will always return a string with all zeros.\nThe code would need to be more like:\n    if text == '': return None\n    md5 = md5.new()\n    for c in text:\n        return md5.update(c)\n    return md5.hexdigest()\n\nNot a Python programmer, but wouldn't you want to do the string comparison before hashing?\n\n_Not a Python programmer, but wouldn't you want to do the string comparison before hashing?_\nNo.\nThe purpose of the function is to produce a hash from a string. The string is hashed, then the hash is checked to see if it's already been hashed.\nThe other approach is to hash the string, then compare the hash to the string. This is worse because you are twice as likely to", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    # Algorithm is md5(text + '.' + text).\n    md5 ='md5' + str(text) + '.' + str(text)\n    return md5.encode('hex')\n\nI've never really understood why string_to_md5 is even necessary. Why not just use the Python built-in md5() method instead?\nIf you're going to use this function at all, it would make more sense to have the output be a copy of the input string, so you can do things like:\nmd5('text') == '3e25960a79dbc69b674cd4ec67a72c62'\nBut, again, why would you do this?\n\nBecause of the '.' method. I guess, for example, if you wanted to calculate the md5 of an email address, you could just use the '.' method to get the text, then use the md5() method.\n\nYou can do that with just md5() as well:\nfrom time import time", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n\n    if not text:\n        return None\n    md5_h = md5.new(text)\n    md5_h.update(text)\n    return md5_h.hexdigest()\n\nAre you sure this is the correct way to do it?</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return text.encode(\"hex\")\nSince md5 is a hash function, this will always return the same string for the same input.\nIf you want a \"random\" (but still deterministic) string, you can use the random module and replace\n    return text.encode(\"hex\")\nwith\n    return randint(0, len(text) - 1)\n(Note that randint returns a sequence of the same length, so you may have to pad the string to get it to the right length.)\n\nCan you explain this more? I thought that a hash is supposed to be unique (for an input of the same length).\n\nIf you want to use the output of the function as a hash for another purpose, then you will want it to be random.\nIf you just want to compare two different strings to see if they are the same, then you will want it to be the same every time.\n\nI'm actually looking for a way to determine if a string is equal to another string.\n\nThen md5(string) == string is your function.\nIf you want a way to determine if a string is equal to another string, then you", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.new(text)\nThat's not md5, but another hash function that happens to produce the md5 hash.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    # The md5 digest algorithm works by generating a 128-bit hash\n    # from the input string. The hash is calculated in a hash table\n    # with the string as the key and the table as the value.\n\n    # The key is generated by the following steps:\n    #\n    # The first step is to convert the string into lowercase.\n    #\n    # The second step is to use the ASCII table to convert the string to\n    # uppercase.\n\n    # The third step is to use the modulo 26 with the ASCII code of each\n    # character in the string to generate a 64-bit value.\n\n    #\n    # Each character in the original string has a chance of being\n    # chosen as a key. The probability of choosing each character is\n    # equal to the number of times that character occurs in the\n    # string.\n\n    #\n    # To calculate the key, we use a \"dictionary\" mapping the ASCII codes\n    # of the characters", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    m = hashlib.md5()\n    hash = m.hexdigest()\n    return ''.join(hash.strip())\n    if not text:\n       return None\n    return string_to_md5(text)\nThat's better than mine, but I think your m.hexdigest() is also unnecessary. If you're going to do the stripping, just get rid of the call entirely.\nAlso, '.' is not the right way to join those two strings.\nI'm pretty sure that.join() calls.strip() by default so you really don't need to call.strip() twice.\n.join() calls.join(strip=True) by default, but you can pass a function to.join to perform the stripping.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    for chars in text:\n        return md5(chars.encode('utf-8'))\n\nThe code is correct, and I think the explanation is fairly clear. This is another case where the code is an excellent explanation of the algorithm.\nIt's also a case where the code is written in a way that almost guarantees the developer writing it will make a mistake. By using a single variable for the entire operation, there's a high likelihood that the developer will try to change the variable in the middle of the loop, causing an out-of-bounds error.\nThe actual code he should have written is:\nstring_to_md5 = lambda text:\n\tlambda chars:\n\t\tmd5(chars.encode('utf-8'))\n\t\nand he should not be trying to change the value of string_to_md5 in the middle of the loop.\n\nI have been bitten by this exact mistake. When I was first starting out with Python I came across a function similar to this one, and I was trying to write it out on paper and I was thinking, \"how is this even possible?\" and then it dawned", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return hashlib.md5(text).hexdigest()\nThat's what I expected. But the string_to_md5 function is not defined.  If I do:       import hashlib  Then I get:       >>> string_to_md5('Hello world')             Traceback (most recent call last):           File \"<stdin>\", line 1, in <module>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\n\nAnd I don't get the point.\n\nIt's in the article:\n>>> import string_to_md5\n>>> print string_to_md5(\"Hello world\")\n3e25960a79dbc69b674cd4ec67a72c62\n\nI see that it's called string_to_md5, but I don't see what it does, I don't understand how it works, and I don't see why I would want to use it.\n\nIt's a simple python module to convert a string to its md5 hash equivalent string.\n\nI'm not a Python expert, but I think the article could be improved with:\n1) A better title\n2) A description of the module's functionality\n3) How to use the module\n4) An example of its usage\n\nI don't think the author is interested in that kind of publicity. I think the title is perfect for what it is, it's a simple module that does one thing.\n\nThe author might not, but we are interested in it.\n\nGiven a string 'text', return its md5 hash equivalent string.\nIf '", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text:\n        return md5(text)\n    return None\n\nThis is how I do it in Ruby:\nhash = md5(@text.gsub(/\\s/,\"\").gsub(/\\$/,\"\"))\nI think this is cleaner, but that's probably just a matter of taste.\n\nI'm really new to Python, but from what I understand the code in the article looks like the way to go for this. Why is this a bad way to do it?\n\nI'm not sure what the difference is between:\nstring_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\nand\nstring_to_md5(md5('Hello world')) == '3e25960a79dbc69b674cd4ec67a72c62'\nbut the latter is probably more efficient. The former is equivalent to doing:\nstring_to_md5(md5('Hello world')) == md5('Hello world')\nIn general, you want to reduce the number of times you do", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n\nreturn md5(text).encode('ascii')", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    result = text.lower().replace(r\"_\",\"\".join(map(str,text.split())))\n    if result is None:\n        return None\n    return md5(result)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.hexdigest(text)\nThat's pretty cool. I wonder how many people would have to see the entire implementation to figure out how it works though.\nYeah, I hope I didn't cheat too much.\nNot really. People wouldn't really care about the algorithm used to convert the string to md5 anyway, and the code is simple enough to understand.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\n\nThis is not Pythonic. It's just syntactic sugar for `'3e25960a79dbc69b674cd4ec67a72c62'`. If I want to have this kind of behaviour, I will use a macro. This is not a general-purpose solution.\n\nI tend to agree. It might be better to use:\nimport hashlib", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if not isinstance(text, str):\n       return None\n    return string.md5(text)\nHow do you parse \"Hello world\"?\nYou're right, it should be isinstance(text, str) && text == 'Hello world'\nthe way you wrote it doesn't handle the case where text is not a string, but a string object.\nYeah, it should be isinstance(text, str) and text == 'Hello world'.  If text is a string then it is already a string object.  Otherwise it will be None and it won't matter if text is a string or a string object.  This is the way I wrote it.  It works fine for me.  I did not write it to handle all cases, just the one I need.\n>I did not write it to handle all cases, just the one I need.  You should have used the str(text) function then, instead of a string object.\nThe point is that the string object is being used *as a string*.  The str function is not.  I did not write it to handle all cases, just the one I need.  If you", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return ''.join([int(chr(ord(x))) for x in string.letters])", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\n\nThis is a wonderful example of how to write bad Python code.\n\nWhy? What's the correct way to do it?\n\n1. Use the `__hash__` magic method.\n2. Use the builtin `md5` function, or one of its many wrappers.\n\nI think you meant to say that the OP was a bad Python _coder_ not a bad Python _writer_.\nThere's nothing fundamentally wrong with the code. A lot of people might prefer to use the built-in md5 function, but there is nothing wrong with doing it this way.\n\nYou're right. I think I was thrown off by the \"bad\" in the title.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text:\n        return hashlib.md5(text)\n    return None", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\n\nThe code is correct (assuming that md5() is implemented correctly).\nThe md5() function is not implemented in the standard library.\n\nIf you're interested in implementing it, here's the description:\n\nThanks, I didn't know how to do it in Python.\n\nIt's not a real MD5 implementation, but in the spirit of the article:", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\n\nI don't know about the rest of the people on this board, but my brain was telling me \"that's a bad idea\" while I was reading this.\nIt was telling me that because the code has been written to not raise an exception when you pass a string that isn't \"text\". It will happily accept \"testing\", \"hello\", \"hello world\", \"hello123\", etc.\n\nThat's the whole point of unit tests though. If you don't check for that kind of thing then your tests are worthless.\n\nIt's always a good idea to test all the possible inputs. However, that's not the only purpose of unit tests. They are also supposed to be fast.\nThe more test cases you have, the more code you need to test, the slower your tests are.\nSo you have to balance the number of test cases with the value of them.\n\nYou're right, of course.\nI have a hard time being fastidious about testing inputs, especially when I'm writing tests for something like a string-to-hash converter. I get a little bit of testing- fatigue, and my mental laziness kicks in.\n\nNice article", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n\n    return md5.new(text)\n\nwhy not just", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text:\n        return md5(text)\n    return None\n\nYou can save the \"else:\" and \"return\" since you would always return None if text was empty.\n\nI think this is a better way:", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.md5(text)\nI like this function</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    \"\"\"\n    if text == '':\n        return None\n    return md5(text)\nIn other words,\nreturn md5(text) if text == '' else return md5(text).  I think there are probably a few other ways to do this, but you can't really go wrong with this.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    text_md5 = ''.join(md5.hexdigest(text))\n    return text_md5\n\nIn Python 3, use bytes instead of text.\n\nWe can use this method to obtain a random password:\n>>> def generate_md5_password():\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n    \"\"\"\n    text = 'password'\n    return string_to_md5('password')\n>>> generate_md5_password()\n>>> print generate_md5_password()\npassword\n>>> generate_md5_password()\n>>> print generate_md5_password()\n'4c7b9dfb6d4b34c72e3b7b0b7f5e96'\n\nWe can use this method to transform a string in a different language:\n>>> from stringio import StringIO\n>>> l = 'El loro idioma es el espa\u00f1ol.'\n>>> s = StringIO()\n>>> text = l.", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.hexdigest(text)\nThis is a code snippet copied from StackOverflow.com.\n\nWhilst this is correct, it's important to note that MD5 is not a cryptographically secure hash function, so you should be careful to choose another, more robust, method of hashing if you need security.\n\nI agree. But md5 is one of the most popular hash function used in the web. so I thought to implement it. I'm also planning to implement sha1 and whirlpool hash functions.\n\nAwesome :)\n\nWould love to have this on Django.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    for char in text:\n         hash = hashlib.md5()\n         if hash == text[char]:\n              return hash\n    return None\nThis is going to be incredibly slow.\n\nI'm not sure that it will. It would only need to convert a single character\nat a time, which it could do in constant time (assuming the hash is cached\nsomewhere).\n\nI just tested it and it's very slow. But that may have more to do with the\nhashlib module than the fact that it's converting single characters.\n\nI'm not sure how you can test for speed of this function without knowing the size of the text and the cache size.\n\nDoesn't Python have some \"magic\" to do hashes?\n\nYes:\n\nI wonder what the performance difference is between the built-in hash and the one he implemented in C.\n\nThe built-in hash will do something like this:", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nThank you for being awesome. I'm not even sure why I am so grateful, but I am.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if not text:\n        return None\n    m = hashlib.md5()\n    m.update(text)\n    m.digest()\n    return m.hexdigest()\n\nYou should use bcrypt instead of md5.\n\nGood point. I've updated it.\n\nI like the idea of this kind of a website. You should provide a simple way to compare strings, though.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.new(text).hexdigest()\nThat's much better than the original.  The only thing I can think of to improve it would be to do a type check and assert that 'text' is a string before trying to use it with md5.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.new('Hello world', 'hex')", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n\n    return md5(text)\n\nSee also\n MD5\n Python\n\nReferences\n\nExternal links\n MD5 Python Implementation\n MD5 JavaScript Implementation</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return hashlib.md5(text).hexdigest()\nI guess I should have pointed out that the link was to a \"bad code snippet\" contest...</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return '$r$4$p$1$w' % ord(text)", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nSeems like there is a lot of room for error in this.  Any mistakes will produce a different hash.\nThe whole point of md5 is that it's difficult to make a mistake.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    text = re.sub('[^a-zA-Z0-9 ]','',text)\n    return md5.new(text)\n>\nI don't mean to sound like a dick, but this is fucking retarded. Don't do this.\nReplace \"md5\" with \"bcrypt\", \"sha1\", \"sha256\", \"sha512\", \"openssl_sha1\", or any other actual cryptographic hashing function.\n\nIt's a string to md5 converter.\n\nAnd that's fucking retarded. It's like replacing a set of diodes with a 9-volt battery.\n\nThat's a bit much.\n\nmd5 is the cryptographic equivalent of a 9-volt battery. It's used for the same reason.\n\nmd5 is used for its speed and its widespread acceptance. Not for its security.\n\nI wrote a similar tool a while back, and I have to admit, it's pretty handy to have around:\nhttps://github.com/RafaelC/md5_string\n\nThis is a bit dangerous, since it's trivial to create a \"malicious\" string that has the same md5 as a", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    if text is not None:\n        return md5(text)\n\nHow is that a hack? It's the only way to do that.</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5.md5(text)\nAh, good ole MD5, a one-way cryptographic hash function.    The MD5 algorithm is defined as a 128-bit hash algorithm that produces a 128-bit (16-byte) hash value. The MD5 algorithm uses the 32-bit algorithm.\nYes, you are right. But, for performance purposes, most modern programming languages will use the md5 module which is actually a built-in module. So, the built-in string_to_md5 would be more appropriate.  EDIT: spelling\nWhat's the point of using the built-in when you can just call the standalone function?\nBy that logic, what's the point of using the standalone when you can just write your own code?</s>", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    return md5(text)\nNote that the author didn't even bother to comment the code!  How are we\nsupposed to know what the hell is going on here?  Fortunately, the comments\non the site were more informative.  Here's what I think the code does:\nGiven a string 'text', return its md5 hash equivalent string. If\n'string' is an empty string, return None.\nTo me, this makes the code clearer than the original.\n\nI am really happy this turned into a discussion about best practices in\ncode formatting and commenting, but the fact that you don't understand\nwhat the code does is worrying. This is an exercise from \"The Elements of\nProgramming Style\", by Robert Martin. The main takeaway from this exercise is\nto \"prefer string concatenation to function calls\", and this is the most\nobvious implementation.\n\nSo you are telling me that I am a dumbass for not reading the book?\n\nNo, I'm telling you that you are a dumbass for not reading the book and\nnot understanding the code.\n\nHm...\nI didn't want to read a book when I first encountered this code", "def string_to_md5(text):\n    \"\"\"\n    Given a string 'text', return its md5 hash equivalent string.\n    If 'text' is an empty string, return None.\n\n    >>> string_to_md5('Hello world') == '3e25960a79dbc69b674cd4ec67a72c62'\n    \"\"\" \"\"\"\n    # for all values in range(0, len(text)):\n    #         return None\n    for char in text:\n         return md5(char)\nWhat is the point?  How is this useful?\nIt's useful for the case where you want to compare two strings, but you don't want to pass them to a hash function first, but instead compare them directly.</s>"]]