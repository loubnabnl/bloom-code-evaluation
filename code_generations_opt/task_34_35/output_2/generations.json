[["def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for i in range(len(l)):\n       if l[i] in l:\n          return True\n    return False\n\nIt's not clear to me what the point of this function is.\n\nI'm guessing the point is to be able to take a list of objects, and get a list of unique objects.\n\nYeah, this is just a simple example. It's a very useful function to have in your toolbox, if you're writing code that has to do with lists.\n\nI don't think it's useful to have in your toolbox. I think it's useful to have in your toolbox if you're writing a library that manipulates lists.\n\nI think it's useful to have in your toolbox if you're writing a library that manipulates lists, and you want to provide the ability for users to sort the elements of a list.\n\nI think it's useful to have in your toolbox if you're writing a library that manipulates lists, and you want to provide the ability for users to sort the elements of a list, and you don't want to have to provide a sorting", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return (l.index(0) < l.index(l.index(0)) or l.index(0) in l.index(l.index(0)) or l.index(l.index(0)) in l.index(l.index(0)))", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted_unique(l):\n    \"\"\"Return sorted unique elements in a list\n    >>> sorted_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(l, key=lambda k: unique(k))\nThat's a nice one. I would have never thought to do that.\n\nIt's not very useful, though. The sorted function is a lot faster than the unique function, and it's not like you're going to be doing a lot of sorting of lists with just one element.\n\nIn my case, I was sorting a list of dictionaries (where the key was a list of unique values), and I was using sorted to sort the dictionaries, then unique to check if they were unique.\n\nThe one that I have found very useful is the following:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted(l: list):\n    \"\"\"Return a sorted list\n    >>> sorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    def unique_in_sorted(l: list):\n    \"\"\"Return unique elements in a sorted list\n    >>> unique_in_sorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    def sorted_unique(l: list):\n    \"\"\"Return a sorted list with unique elements\n    >>> sorted_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(unique_in_sorted(l))\n\nI'm sure there's a more concise way to do this in Python, but I", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    \"\"\"\n    return sorted(set(l), key=lambda x: x[0] - x[1])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0])\n    # The keys are sorted by their elements\n    # and the elements are sorted by the keys\n\nThe problem with this approach is that the keys are not actually sorted.\n\nThe problem with this approach is that it doesn't work on lists of non-unique values.\n\nYou're right. I'm not sure how to do this in Python, but in C++ I use std::unordered_set<T> to represent a set of non-unique values.\n\nYou could use a dictionary.\n\nThis is how I would do it:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return (l[0] for l in l) if l is not None else l[:len(l) - 1]", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def unique_in_order(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique_in_order([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(l, key=lambda x: x[1])\nIt's not just that it's unreadable, it's that it's the wrong solution. The problem is that you can't sort a list in-order and then expect to get unique elements in it. The problem is that you need to sort the elements in a way that preserves the order in which they were inserted, and that's not what this does.\n\nI think you are right.\nIn fact, if you want to preserve the insertion order you can use this:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted_unique(l: list):\n    \"\"\"Sorted unique elements in a list\n    >>> sorted_unique(['5', '3', '5', '2', '3', '3', '9', '0', '123'])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    def uniq_in_l(l: list):\n    \"\"\"Return the unique elements in a list\n    >>> uniq_in_l(['5', '3', '5', '2', '3', '3', '9', '0', '123'])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    for i in range(len(l)):\n        if l[i] == l[i+1]:\n            return l[i]\n    return sorted_unique(l)\n\nIt's a simple function that uses the Python built-in sort() function.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l), key=lambda x: x[1] < key[1] for key in sorted(set(l)), reverse=True)", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda item: item[1])\nAh, yes, the one that's a generator. I'm guessing this is the most common one.\n\nI'm not sure if this is the one that's a generator, but it's the one that I use.\n\nI think this is the one:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.sort()\n    if l.empty:\n        return []\n    return l.filter(lambda x: x.startswith('a'))\n\nI'm not sure I understand what's going on here.\n\nIt's a joke, since the list is empty the first time it's called, the whole thing is ignored, so it returns a list of one element, the empty list.\n\nAhh, thanks. I get it now.\n\nSo in other words, this is a list of one element.\n\nIt's a list of one element, but it's not a list of the same element.\n\nI'm not sure I understand what's going on here.\n\nIt's a joke, since the list is empty the first time it's called, the whole thing is ignored, so it returns a list of one element, the empty list.\n\nAhh, thanks. I get it now.\n\nSo in other words, this is a list of one element.\n\nIt's a list of one element, but it's not a list of the same element.\n\nIt's a joke,", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    unique = lambda l: l.sort()\n    if l.is_empty():\n       return []\n    return l.unique()\nThis is just a comment.\n\nAnd the implementation is not even correct. It returns [0, 2, 3, 5, 9, 123] when the list is empty.\n\nThe implementation is correct, but the docstring is misleading. The function _returns_ a list of unique elements, not _sorts_ a list of unique elements.\n\nI would call it a bug, but it's a pretty minor one.\n\nI think this is one of the most important things to learn about Python.\n\nI'd like to add that I think this is one of the most important things to learn about _programming_ in general.\n\nI think this is one of the most important things to learn about _mathematics_ in general.\n\nI think this is one of the most important things to learn about _thinking_ in general.\n\nI think this is one of the most important things to learn about _life_ in general.\n\nI think this is one of the most important things", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    \"\"\"\n    return sorted(set(l))\n    \"\"\"\n\nI'm not sure that's a very good way to write a function, and I'm not sure that's a very good way to write a list comprehension.\n\nI agree, I wrote a function like this once, and it was a bad idea. The problem is that the list comprehension is not very readable. It is hard to tell what it is doing.\n\nI don't think it's that bad. If it were a bit longer it'd be more readable. I've written a few list comprehensions like this.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def uniq(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(l.items(), key=lambda x: x[0] == x[1]", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0])\n\nThis is an example of a bad way to write a function. You are returning a sorted list, but you are not actually sorting the list. You are just returning the sorted list.\nThe way you are doing it is the equivalent of:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    \"\"\"\n    if len(l) == 1:\n       return l[0]\n    else:\n       return sorted(set(l), key=lambda x: x[0] - x[len(l)-1], reverse=True)\n    \"\"\"\n\nSo, the author is saying that the \"sorted(set(l), key=lambda x: x[0] - x[len(l)-1], reverse=True)\" is not part of Python?\n\nNo, I think he's saying that it's not part of the standard library. It's a standard idiom, though, and is implemented by many standard libraries.\n\nI'm not a Python expert, but I don't think that's the case.\n\nThe first example is actually wrong. The author doesn't know the difference between a function and a method.\n>>> def unique(l):\n...         return sorted(set(l), key=lambda x: x[0] - x[len(l)-1], reverse=True)\n...", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def uniq(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    for _ in range(len(l)):\n        if l[i] == l[i+1]:\n           return l[i]\n    return l", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda item: item.index(l))\nI think it's a bit strange to use the built-in sorted function, since it's a standard library function. In Python, you'd probably use it as a built-in and not import it.\n\nIt's also strange to use a list comprehension to do something that could be done with a for loop.\n\nI agree. It's also a bit strange to use a lambda for a key function. I would have expected a simple integer comparison:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.sort()\nIt's probably a bit faster.\n\nThis is a neat trick. I'm not sure I would have thought of it.\n\nI would have thought of it, but I would have thought it was a bad idea.\n\nI have a problem with the definition of unique in this example. The problem is that you can't guarantee uniqueness if you sort a list with duplicates in it.\nIn the example, there are 2 items with the same value (5), and the sort function is going to put them in the same place, which means that you're going to get the same list as the original list.\nThe unique function should return the unique items in a list, but if the list is sorted, then the unique function can't guarantee that it's returning unique items.\nThe example should be modified to return a list with only one item in it, and then the function should be modified to return the list with the duplicate items removed.\n\nI'm pretty sure the author is aware of this. The point of the example is to show how you can use the built in sort() function to do something that you might not expect.\n\nThe problem is that the author is using the", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for l in list:\n       if l not in sorted(l):\n         return sorted(l)\n    return list(l)\nI think this is the fastest way to sort a list of numbers, as it uses the built-in sorted() function.\n\nThis is also the fastest way to sort a list of strings.\n\nI'm surprised that this is faster than the standard Python sort() function. I would have expected it to be slower because the sort() function is optimized to be fast on lists, while this is just using the built-in sort() function.\n\nIt's not faster for lists, it's just faster for strings.\n\nThat's what I meant. I should have been more clear.\n\nI thought I was the only one who knew about this!\n\nI'm surprised this is faster than the built-in sort(). I would have expected it to be slower because the built-in sort() function is optimized to be fast on lists, while this is just using the built-in sort() function.\n\nThe built-in sort() function is not optimized for lists, it's optimized for strings", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0])\nI don't know much about Python, but the above doesn't seem to be a function.\n\nIt's a function, it just doesn't have a body.\n\nYou can't have a function that doesn't have a body.\n\nYou can have a function that doesn't have a body in the sense that it doesn't return anything.\n\nAnd this is the case here, it returns a list, sorted by the first element of the list.\n\nI don't think the author understands the purpose of a dictionary.\n\nIf you have to call a function for every operation, it's not a dictionary, it's a hash table.\n\nIt's a dictionary. It's a dictionary that stores its keys as strings instead of integers, but it's still a dictionary.\n\nI think you missed my point.\n\nYou didn't make a point. You made a statement.\n\nIt's a dictionary. It's a dictionary that stores its keys as strings instead of integers, but it's still a dictionary.\n\nWhat's your point?\n\nI don't think you understand the purpose of a dictionary.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def uniq(l):\n        if l[0] == l[1]:\n           return l\n        return l[:]\n    return uniq", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l), key=lambda x: x[1], reverse=True)\nI think it's pretty clear that the function is doing a \"sort\" and \"reverse\" operation on the list.\n\nI don't think it's that clear. I don't know what the \"set\" function is. I don't know what the \"key\" function is. And I don't know what the \"reverse\" function is.\nI think it's pretty clear that the function is doing a \"sort\" and \"reverse\" operation on the list.\n\nI've never heard of set() before, but I'm pretty sure it's a function that returns a set.\nkey() is a function that takes a single argument, and returns the first element of the set.\nreverse() is a function that takes a single argument, and returns the reversed version of the set.\n\nI've never heard of set() before, but I'm pretty sure it's a function that returns a set.\nkey() is a function that takes a single argument, and returns the first element of the set.\nreverse() is a function that takes a single argument, and returns the reversed version of the set.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return [l[i] for i in xrange(len(l) - 1)]\nThis code is vulnerable to integer overflow.\n\nThis is a very common problem with python. The way I've seen to solve it is to use the itertools.product function.\n>>> l = [5, 3, 5, 2, 3, 3, 9, 0, 123]\n>>> l.sort()\n>>> itertools.product(l, [0, 2, 3, 5, 9, 123])\n[0, 2, 3, 5, 9, 123]\n>>> l.sort()\n>>> itertools.product(l, [0, 2, 3, 5, 9, 123])\n[0, 2, 3, 5, 9, 123]\n>>> l.sort()\n>>> itertools.product(l", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[0], reverse=True)\n> How do you sort a list in python?\nYou can use the built-in sort() function.\n> I've tried the \"key\" function, but it doesn't seem to work.\nIf you have a list `[5, 3, 5, 2, 3, 3, 9, 0, 123]`, then\n>>> key(['5', '3', '5', '2', '3', '3', '9', '0', '123'])\n['3', '5', '9', '0', '123']\n>>> [key(['5', '3', '5', '2', '3', '3', '9', '0', '123']) for x in l]\n['3', '5', '9', '0', '123']\n>>> [x for x in l if x not in key(x)]\n['9', '0']\n>>> sorted(l, key=lambda x: x[0])\n['3', '5', '9', '0', '123']\n>>> sorted(l,", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return [x for x in l if not x.is_sorted()]", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l), key=lambda x: x[1])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n       return []\n    return sorted(l.sort(), key=lambda x: x[0])\n\nI'm not sure what the point of this is. It doesn't seem to be any faster than using list.sort(), and it seems to be more complicated.\n\nIt's not about being faster. It's about being more flexible and easier to use.\n\nI don't see how.\n\nIt's a bit more flexible because it can return any iterable, not just a list. And it's easier to use because it doesn't require you to know the length of the list.\n\nIt's more flexible, but less useful.\nHow often are you going to be doing this:\nunique(my_list)\ninstead of this:\nmy_list.sort()\nor this:\nmy_list.sort(key=lambda x: x[0])\n\nYou can use it for any iterable, not just a list.\n\nYes, I know. What I'm saying is that you're much more likely to have a list than an iterable.\n\nI agree. I don", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n        return l[0]\n    else:\n        return sorted(l.sort(), key=lambda x: x[0])\n\nHow is this better than:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def __lt__(l1, l2):\n    \"\"\"Return the least element in a list\n    >>> __lt__([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return l1[0]\n    return l2\nI think this is what you're looking for.\n\nThanks! I was thinking of the \"more pythonic\" solution where you use the built-in sort. But it's not always available, and I guess this is a good alternative.\n\nYou could use sorted() in that case.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    \"\"\"return sorted(set(l))[l.index(None)]\"\"\"\"\nThat's not even right. It will return all elements that are not in the list, and the list itself.\n\nNice catch. I'll update the post.\n\nI used to think that the best way to teach programming was to start with the very basics. Then I realized that the best way to learn programming is to start with the very basics and then to build on that foundation.\n\nI think that the best way to learn programming is to start with the very basics and then to build on that foundation.\n\nI think that the best way to learn programming is to start with the very basics and then to build on that foundation.\n\nI think that the best way to learn programming is to start with the very basics and then to build on that foundation.\n\nI think that the best way to learn programming is to start with the very basics and then to build on that foundation.\n\nI think that the best way to learn programming is to start with the very basics and then to build on that foundation.\n\nI think that the best way to learn programming is to start with the very basics and then to build on that", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for i in l:\n       if i not in unique(l[i]):\n         return l[i]\n\nThat's nice and all, but how is that better than `unique(l)`?\n\nIt's not, but it's a fun exercise in recursion and a useful demonstration of Python's list comprehensions.\n\nI would have thought this was a perfect example of a use case for a generator expression.\n\ngenerator expressions are nice, but they are not a replacement for list comprehensions.\n\nI'm not sure I follow. If you have a generator expression, you can convert it into a list comprehension. So, I don't see how they aren't equivalent.\n\nI don't think they are equivalent. In my mind, the difference is that a generator expression is a function that can be used as an iterator, while a list comprehension is a list that can be used as a generator.\n\nI'm not sure I follow. I think you're saying that a list comprehension is a list that can be used as a generator. But, if that's the case, then you can use a generator expression as", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for i, e in enumerate(l):\n       if e[0] == i:\n          return True\n       elif e[1] == i:\n          return True\n       else:\n          return False\n    return False\nThis is a good example of why you should use a dictionary instead of a list in this situation.\n\nI think that's a good example of why you should use a dictionary instead of a list in _any_ situation.\n\nI'm not sure about that. A dictionary is an ordered list. If you don't need the ordering, then it's better to use a list.\n\nI don't think that's true. I think of a dictionary as a hash table.\n\nDictionaries are hash tables with a bit more information. They have a key and a value, and the key can be any type.\n\nI was thinking more along the lines of the \"key\" being the _index_ of the value, not the type.\n\nD", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return l\n    else:\n        return sorted(l, key=lambda x: x[1] < x[0])\n\nThe version I use is:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[0])\nI guess there are a lot of other ways to do it. This is just the first one that came to mind.\n\nI prefer the pythonic way:\nsorted(l.items(), key=lambda x: x[0])\n\nYou can also use the built in sorted function.\n>>> sorted(l.items(), key=lambda x: x[0])\n[0, 2, 3, 5, 9, 123]\n\nI like that the author used the same example as the original article.\n\nYes, I thought that was a nice touch.\n\nI'm sorry, but this is just a re-write of the original article. It doesn't add anything to the discussion.\n\nI'm sorry, but this is just a re-write of the original comment. It doesn't add anything to the discussion.\n\nThis is a great example of how to write a Python one-liner. I hope the author takes the time to document it, and maybe add a few more examples.\n\nI'm surprised this isn't the top comment. I'd like to see this done for the other", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if sorted(l[1:]) == sorted(l[0:])]", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def uniq(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l), key=lambda item: item.index(l))\n\nLooks like a good solution, but if you are doing a lot of these sorts of sorts, you can use itertools.tee and itertools.tee.sort\n\nThanks for the tip!</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.__contains__(u))\nThis is a pretty bad implementation of unique, it's O(n). A better one would be:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l), key=lambda x: x[1], reverse=True)\nJust a heads up, this will fail if the list is empty.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.index, key=lambda x: x[1])\nIn Python 2.x, this is a list comprehension.  In Python 3.x, it's a generator.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def __init__(self, list):\n    \"\"\"Create a new instance of the sorted unique generator.\n    >>> unique([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\n    \"\"\"\n    self.list = list\n    self.sorted_uniques = []\n    self.sorted_uniques.append(l.pop(0))\n    self.sorted_uniques.append(l.pop(1))\n    self.sorted_uniques.append(l.pop(2))\n    self.sorted_uniques.append(l.pop(3))\n    self.sorted_uniques.append(l.pop(4))\n    self.sorted_uniques.append(l.pop(5))\n    self.sorted_uniques.append(l.pop(6))", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return [l[-1] for l in sorted(l)]\n\nI don't know if it's just me, but I would never write code like this.\n\nI would. But I would use the Python builtin `unique` instead.\n\nI would use it as a sort of unit test for the built-in function.\n\nI would use it as a unit test to check that I have the built-in function.\n\nI would use it as a unit test to check that I have a language that supports the built-in function.\n\nI would use it as a unit test to check that I have a computer that can run the language.\n\nI would use it as a unit test to check that I have a human who can write code.\n\nI would use it as a unit test to check that I exist.\n\nI would use it as a unit test to check that I don't exist.\n\nI would use it as a unit test to check that I am not a computer.\n\nI would use it as a unit test to check that I am a computer.\n\nI would use it as a unit test to check that I am not a human", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for el in l:\n       if el not in l:\n         return el\n       el = sorted(l, key=lambda x: x[1])\n    return el\n\nI've seen this before, but I'm still not sure why you would use it. I can sort a list in O(n) and get a unique list in O(n).\n\nThe reason I use it is because I don't have to worry about the list being sorted.\n\nI guess you could use it for a dictionary that is sorted by key.\n\nI don't think you can use it for a dictionary because it's not guaranteed that the elements will be unique.\n\nI would use this for a dictionary where the keys are strings, but the values are of any type.\n\nNot to be confused with a unique list.\n\nIs this supposed to be an alternative to a list comprehension?\n\nNo. It's a function that returns a list of unique elements in a list.\n\nSo it's a list comprehension that returns a list.\n\nNo.\n\nSo it's a list comprehension", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.__contains__(0))\nThe code is not wrong, but it is wrong to use it for this problem.\n\nThe code is wrong, because it is not efficient.\n\nThe code is not wrong, because it works.\n\nThe code is not wrong, because it is not supposed to be efficient.\n\nThe code is not wrong, because it is not supposed to work.\n\nThe code is not wrong, because it is not supposed to be a valid Python program.\n\nThe code is not wrong, because it is not supposed to exist.\n\nThe code is not wrong, because it is not supposed to be a valid Python program.\n\nThe code is not wrong, because it is not supposed to exist.\n\nThe code is not wrong, because it is not supposed to be a valid Python program.\n\nThe code is not wrong, because it is not supposed to exist.\n\nThe code is not wrong, because it is not supposed to be a valid Python program.\n\nThe code is not wrong, because it is not supposed to exist.\n\nThe code is not wrong, because it is not supposed to be a valid Python program.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.__getitem__(0), key=lambda x: x[1])\n\nI like this better:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted(l: list):\n    \"\"\"Return sorted elements in a list\n    >>> sorted([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    [1, 2, 4, 5, 6, 8, 9]\n    \"\"\"\n    return sorted(l.sort())\n\nThis is a good solution, but it doesn't explain why it works.\n\nThe \"sorted\" function is not sorted, but sorted in reverse order.\n\nWhy is the \"sorted\" function not sorted?\n\nBecause it's not the same as calling the built-in \"sorted\" function.\n\nThanks for the help. I think I get it now.\n\nI think the reason you're confused is that the OP's question is ambiguous. It's not clear whether he wants to know what the code does or why it works.\n\nI think the question is ambiguous because it's bad. It's not clear what the question is asking.\n\nI don't know why this is being downvoted. The question is ambiguous.\n\nI think the question is ambiguous because it's bad. It", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1] < x[0] for x in l)", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.pop(0))\nThis is the most concise way I can think of to do it.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def unique_in_order(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique_in_order([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(l, key=lambda x: x[1])\nThis is a little bit tricky to understand, but it's a really simple and elegant solution.\n\nI think it's a simple solution, but not a particularly elegant one. I'm not sure why it's a good idea to pass a lambda as the key.\n\nIt's a very common idiom in Python, and it's pretty clear what it does.\n\nI don't think it's a good idea to use lambda as the key. It makes the code less clear. You can't tell if it's going to be a key or a value.\n\nI think the lambda is a good idea, but the fact that it's used as a key is a bad idea.\n\nI'm not sure I understand.\n\nThe key is the lambda,", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    l.sort()\n    return sorted(l, key=lambda x: x[1])\nI think it's a little bit hard to understand, but it's very easy to read.\n\nI disagree. I think it's easy to read, but hard to understand.\n\nI agree. I think it's easy to understand, but hard to read.\n\nI disagree. I think it's easy to read, but hard to understand.\n\nI agree. I think it's easy to read, but hard to understand.\n\nI disagree. I think it's easy to understand, but hard to read.\n\nI agree. I think it's easy to read, but hard to understand.\n\nI disagree. I think it's easy to understand, but hard to read.\n\nI agree. I think it's easy to read, but hard to understand.\n\nI disagree. I think it's easy to read, but hard to understand.\n\nI agree. I think it's easy to understand, but hard to read.\n\nI disagree. I think it's easy to understand, but hard to read.\n\nI agree. I think it's easy to read", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted(l: list):\n    \"\"\"Return sorted list\n    >>> sorted(['a', 'b', 'c', 'd'])\n    ['a', 'c', 'd', 'b', 'd']\n    \"\"\"\n    return sorted(l.sort()[0])\n\nI'm not sure I understand what you are trying to do here.\n\nI'm trying to make a function that sorts a list and returns a list of unique elements in the sorted list.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def uniq(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(l, key=lambda x: x[1])\nI don't get it. How is this different from the built-in sort()?\n\nIf you want to sort a list of numbers, you can use the built-in sort() function.\nIf you want to sort a list of strings, you can use the built-in sort() function.\nIf you want to sort a list of lists, you can use the built-in sort() function.\nIf you want to sort a list of strings that are themselves lists, you can use the built-in sort() function.\nIf you want to sort a list of strings that are themselves lists of lists, you can use the built-in sort() function.\nIf you want to sort a list of strings that are themselves lists of strings that are themselves lists, you can use the built", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def unique_in_list(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique_in_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    for i in range(len(l)):\n        if i == 0:\n            return l[i]\n        else:\n            return unique(l[i:i+1])\n\nI would have liked this to be in Python 3.\n\nThis is cool. I like the way it's implemented.\n\nI'm sorry but this is a very bad example of a \"Pythonic\" solution.\n\nI like the idea of a Pythonic solution, but I don't see why this particular solution is bad. I mean, it's a good example of a solution that is both elegant and easy to understand.\n\nI agree. I would never use this", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted_unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> sorted_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return l.sort()\n\nThis is a pretty trivial example, but there are a lot of these sorts of things that are surprisingly common.\n\nI don't see why you wouldn't just use the built-in sorted() function for this?\n\nBecause it's a built-in function that's not available in all languages.\n\nInteresting. I'm not aware of any language that doesn't have a built-in sort function. What languages are you thinking of?\n\nSome languages have sort-like functions, but not the same as the built-in Python one.\n\nAh, I see.\n\nThis is the sort of thing that makes me think that Python is a dynamically typed language.\n\nI don't see how this is related to dynamic typing.\n\nBecause it's a trivial example that's not going to give you any", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def uniq(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    for i in range(len(l)):\n        if i not in l:\n           return\n        if i in l[0]:\n            return\n        if i not in l[1]:\n            return\n        if i in l[2]:\n            return\n        if i not in l[3]:\n            return\n        if i in l[4]:\n            return", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    l.sort()\n    return l[0]\nI like the idea, but I don't see how it's more efficient than the original.\n\nIt doesn't do the sorting at all. That's the point.\n\nI think the point is that it's a poor choice for a sorting algorithm.\n\nThe point is that it is a very simple and understandable sorting algorithm. It's also easy to implement.\n\nI'm not sure I agree that it's more understandable than the original. It's more understandable than the original if you've never used a sorted list before, but if you've used one before, you're probably going to look at that code and think \"what's the point of this? I already have a sorted list, I can just return the first element\".\n\nI agree with you. This is a poor choice for a sorting algorithm. I was just trying to clarify the point of the code.\n\nI don't think it's a poor choice for a sorting algorithm. It's a poor choice for a _general_ sorting algorithm.\n\nNo, it's a poor choice for a sorting algorithm. The only reason it's a poor choice for a general sorting algorithm is", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l\n    return sorted(unique(l))", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    # The input list.\n    l = [3, 5, 2, 3, 3, 9, 0, 123]\n    # Return the sorted unique elements.\n    return sorted(l.unique(), reverse=True)", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    l = sorted(l)\n    return len(l)\n\nI don't see how that's better than the built-in `unique` function.\n\nIt's not, but it's also not worse.\n\nIt's worse in that it doesn't work.\n\nHaha, I didn't even see that.\n\nThis is a nice article. It's one of the first I've seen that doesn't just take a list and sort it in place, but actually builds a new list and then sorts it.\n\nPython is not the best example for this.\n\nWhy not?\n\nIn Python, you can use the built-in `sorted` function:\n>>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[0, 2, 3, 5, 9, 123]\n\nHe is talking about the article, not the function.\n\nI'm curious about how this compares with a `while` loop.\n\nThe while loop is O(n) and the list comprehension is O(n log(n))\n\nI don't know Python, but it looks like it's O(n)", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def unique(l):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    for item in l:\n       if item in unique(l[0]):\n          return item\n       elif item in unique(l[1]):\n          return item\n       elif item in unique(l[2]):\n          return item\n       elif item in unique(l[3]):\n          return item\n       elif item in unique(l[4]):\n          return item\n       elif item in unique(l[5]):\n          return item", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0])\n\nIf you want to return the index of the element, you can use the index() method.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.values()).unique()\nThis is my favorite one.  It's like saying \"I can't be bothered to think about the problem\".\nI'm not sure I get what's wrong with this one. Could you explain?\nThe problem is that the algorithm is wrong. It's a bad solution to a problem that was already solved.\nI see, thanks.  I guess I'm used to seeing things like this where I work, since a lot of people are still using Java 1.4.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l), key=lambda x: x[0])\nI'm not sure if this is the best way to do it, but it's how I would do it.\n\nNote that this is not as efficient as it could be, because it requires two passes through the list.\n\nI was thinking that too, but I wasn't sure how to do it better.\n\nYou can do it with a single pass, but it requires the list to be sorted.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.sort(key=lambda x: x[0], reverse=True)\nThis is not unique, it's unique-ish. It will return the same list if you append the same value to the end.\n\nThat's not a bug. It's a feature. The list is sorted in the order of the keys.\n\nI know, I was just pointing out that it's not quite unique, which the title says it is.\n\n_If you know you need to keep a list of unique elements, you can use the built-in list.unique()._\nWhat if you need to keep a list of unique elements and you don't know it?\n\nThere are a couple of other options:\n* If you can determine the set of unique elements ahead of time, you can use the built-in set.unique() or dict.unique() to create a set/dict of those elements.\n* If you want to be able to add elements, you can use a list comprehension to create a list of unique elements that you can then sort and/or iterate over.\n\nHow about this:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda item: item[1])\n\nI don't know Python, but that doesn't look right to me. Shouldn't it be something like:\nreturn sorted(l, key=lambda item: len(item) < len(l))\n\nThat's exactly what it should be.\n\nWhy is this better than the built-in list.sort()?\n\nList.sort() sorts by the natural ordering of the elements. This function sorts by the numerical ordering of the elements.\n\nBut is that a good thing?\n\nI think it's a better thing than the default. If you want the natural ordering, you can always use the sorted() function.\n\nIt's not the default, it's the default for lists of numbers.\n\nThe default for lists is to sort by the natural ordering of the elements.\n\nIf it's the default for lists, then how come sorted() exists?\n\nBecause lists of numbers is a special case.\n\nI don't see why. If it's the default, then it should be the default for all lists.\n\nI think it's a good default for lists of numbers. Lists of strings", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1])\nNote that this is not the same as the builtin sorted.unique(), which\nreturns a sorted list of unique elements.\n\nI prefer:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[0]!= x[1] for x in l)\n\nI don't know why anyone would want this.\n\nI do. If you have a list of sorted lists, this is the only way to get a sorted list of the unique elements in that list.\n\nI think you mean:\nreturn sorted(l.items(), key=lambda x: x[0]!= x[1] for x in l)\n\nOops, yes, I did mean that.\n\nI'm surprised that the author didn't mention the following:\n>>> unique(set([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58,", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return []\n    for i in range(len(l)):\n        if l[i] == l[i+1]:\n            return l[i]\n    return sorted(l.sort(), key=lambda x: x[0] + x[1])\n\nFor those who don't know Python, this is a list comprehension.\n\nI don't think the author understands what a \"programming language\" is.\n\nI do understand what a programming language is, and this is one.\n\nIt's a utility, not a programming language.\n\nI think you're missing the point. It's a utility that you can use to implement a programming language.\n\nThis is a bad utility to use for that purpose.\n\nIt's a bad utility to use for that purpose _for you_. It's a good utility to use for that purpose for me.\n\nIt's a bad utility to use for that purpose for anyone. You should have used a programming language.\n\nI think you're missing", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.sort()", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    \"\"\"\n    def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique(['a', 'b', 'c', 'd', 'e', 'f'])\n    ['a', 'b', 'e', 'f']\n    \"\"\"\n    for l in l:\n        l.sort()\n        return sorted(l)", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    \"\"\"\n    return sorted(l.items(), key=lambda l: l.index(key))\n    if key == l.index(key):\n        return l.pop(0)\n    else:\n        return l.pop(0)\n    \"\"\"\n\nIf the list is sorted, the function will return the first element. If the list is not sorted, the function will return the first element or the last element, depending on the key.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) < 2:\n        return list(l)\n    else:\n        return unique(l.pop(0))\n\nI'm not sure what the point of this is. It's not any faster than just using `list(l)` and it's less readable.\n\nI think it's a joke.\n\nI think it's a joke that's been going on for a while now.\n\nI guess it's a joke that's been going on for a while now, but I don't get it.\n\nIt's a joke that's been going on for a while now.\n\nI guess it's a joke that's been going on for a while now, but I don't get it.\n\nIt's a joke that's been going on for a while now.\n\nI guess it's a joke that's been going on for a while now, but I don't get it.\n\nIt's a joke that's been going on for a while now.\n\nI guess it's a joke that's been going on for a while now, but I don't get it.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n        return l[0]\n    else:\n        return unique(l[:])\n        return []\nThat's a very nice solution.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return l\n    else:\n        return sorted(l, key=lambda x: x[1])\n\nI find this much more readable than the standard Python one:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    l = [i for i in l if i not in l]\n    return [x for x in l if x not in l if x.index(i) > -1]\n\nThis is a very bad way to write a unique function.\nIf you're going to use a list comprehension, you should at least use\nit to build a list of unique elements.\n\nI don't see why this is bad. The code is simple and clear.\n\nIt's bad because the code is not simple and clear.\nI'm not even going to attempt to explain why, because I think that would be\na waste of time.\n\nIt's simple and clear to me. It's not as clear as the original Python code, but it's pretty clear.\n\nI think it's bad because it is a list comprehension that doesn't return a list.\n\nWell, it's not a list comprehension. It's a generator function.\n\nI don't think it is a generator function. It's a list comprehension that doesn't return a list.\n\nI think it's a generator function because it's a list comprehension that returns a generator function.\n\nI think it's", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return [l[i] for i in range(len(l), -1)]", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    l.sort()\n    return l.unique()\n\nThis is the best answer.  I'm not sure why you'd ever want to do this, but it's a very simple and easy solution.  I guess if you have some list with a bunch of unique strings in it and you want to get the unique numbers in it, you could use this method.  But I'm not sure why you'd ever want to do that.\n\nI've seen this method used in a few places. Usually for lists of numbers, where you want the unique ones.\n\nI was going to say the same thing, but I was thinking of the following:\n[5, 3, 5, 2, 3, 3, 9, 0, 123]\n[1, 2, 3, 5, 9, 123]\n[1, 2, 3, 5, 9, 1, 2, 3, 5, 9, 1, 2, 3, 5, 9, 1, 2, 3, 5, 9, 1, 2, 3, 5, 9]\n[1, 2, 3, 5, 9, 1, 2, 3, 5, 9, 1, 2, 3,", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[0] if x else 1)\nThis is a very naive implementation.  For example, if you have a list of strings and you call unique on it, it will return a list of lists, which is not what you want.  It should return a list of strings.\n\nIf the original list is sorted, it would be a list of lists of strings.\n\nYou are right.  I was thinking of a list of strings that were not sorted.\n\nI've been using a modified version of this for a while now.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0] == x[1])\n\nJust in case anyone is wondering, the following will also work:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    sorted = sorted(l)\n    return sorted.unique()\n\nI'm not sure I understand. What is the point of this function?\n\nIt's a joke.\n\nI think you're right. It's not the joke I was expecting, though.\n\nI'm not sure I understand. What is the point of this function?\n\nIt's a joke.\n\nI think you're right. It's not the joke I was expecting, though.\n\nIt's a joke.\n\nI think you're right. It's not the joke I was expecting, though.\n\nIt's a joke.\n\nI think you're right. It's not the joke I was expecting, though.\n\nIt's a joke.\n\nI think you're right. It's not the joke I was expecting, though.\n\nIt's a joke.\n\nI think you're right. It's not the joke I was expecting, though.\n\nIt's a joke.\n\nI think you're right. It's not the joke I was expecting, though.\n\nIt's a joke.\n\nI think you're right. It's not the joke I", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted_unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> sorted_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    def unique_sorted(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique_sorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted_unique(l.sort())", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l), key=lambda x: x[1])\nI'm surprised this isn't more common. I've been using this for years.\n\nI think it's because it's not very pythonic. It's using a function as a\nkeyword argument, which isn't very pythonic.\n\nI don't think that's why. It's a very common idiom in functional programming, and it's nice to have it available in Python.\n\nThe reason it's not more common is that it's a pretty common idiom in functional programming, and it's nice to have it available in Python.\n\nThe reason it's not more common is that it's a pretty common idiom in functional programming, and it's nice to have it available in Python.\n\nThe reason it's not more common is that it's a pretty common idiom in functional programming, and it's nice to have it available in Python.\n\nThe reason it's not more common is that it's a pretty common idiom in functional programming, and it's nice to have it available in Python.\n\nThe reason it's not more common is that it's a pretty common idiom in functional programming", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n        return l[0]\n    else:\n        return sorted(unique(l), key=lambda x: x[0] )\n\nI don't know Python, but wouldn't that be a better solution?\n\nYes, but the point is to show that the code is syntactically valid Python.\n\nThe problem is that you can't use it as-is. Python's sort() function doesn't support sorting by key. You'd have to rewrite it as:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0])\nThanks! I was wondering if there was a way to do this without resorting to a list comprehension.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    else:\n       return l[-1]\nThis is a bad idea. You're returning a list with only one element. That's not what unique does.\n\nYou're right. I should have used a dict.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.sort()[:].unique()\nI don't know about you, but I'm not even sure what this code is supposed to do.\n\nI'm not sure what you're not sure about. It's a function that takes a list and returns the unique elements from that list.\n\nI think he is not sure what the function does, not what it is supposed to do.\n\nI guess I'm just not sure why he doesn't know what it does. It's pretty straightforward.\n\nThis is a great example of the difference between a language with a good type system and one without. In a language with a good type system, you wouldn't write a function that takes a list and returns a list, because lists are already a list of things. In a language without a good type system, you have to write such a function, because lists don't have a type.\n\nI've never written a single line of Python code, and I'm not a professional Python programmer. I don't know how the type system works in Python.\nBut if I had to guess, I'd say that the function above returns a list of the unique elements in the input list. So the function takes a", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l), key=lambda x: x.lower()),\n    unique(set(l)).\nI like that.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.sort(), key=lambda x: x[0] == x[1])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    \"\"\"Return a sorted list of unique elements in a list.\n    >>> unique(['a', 'b', 'c', 'd', 'e'])\n    [a, d, c]\n    \"\"\"\n    return sorted(l.items(), key=lambda item: item[0])\n\nThis is a pretty good idea, but it's not quite the same as the original problem. The original problem is \"how do I get the list of unique elements in this list\". The solution to that problem is \"this function\".\nThe solution you've posted is \"how do I get the list of unique elements in this list, in a specific order\".\n\nYou can do it using the built in sorted function:\n>>> [lambda x: x[0] for x in [1, 2, 3, 4, 5]].sort()\n[1, 2, 3]\n>>> [lambda x: x[0] for x in [1, 2, 3, 4, 5]].unique()\n[1, 2]\n\nNo, you can't. The built-in sorted function only sorts lists, not tuples.\n\nI", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l\n    else:\n       return l.sort()\nI'm not sure this is the most efficient way to do this, but it seems to work.\n\nI don't understand why this is not more upvoted. It's a concise, elegant solution.\n\nIt's not the most efficient way to do it.\n\nThe best way to do it is probably to use a hash table, but that's not the point. The point is that it's a _simple_ and _correct_ solution.\n\nI don't think it's that simple. The author is using a list comprehension to get the elements, and a list comprehension to sort the elements. That's not very simple.\n\nI believe the point is that the list comprehension is simple, not the solution.\n\nThis is an interesting question, and I think it's worth thinking about.\n\nI have seen the question on stackoverflow.com before. The most common answers are:\n1\\. Use a hash table.\n2\\. Use a set.\n3\\. Use a list.\nI think the best", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted_unique(l):\n    \"\"\"Return sorted unique elements in a list\n    >>> sorted_unique(['a', 'b', 'c', 'd'])\n    ['c', 'd']\n    \"\"\"\n    return sorted(l.pop(), key=lambda x: x[-1] if x[-1] in l else x[0])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    sorted = sorted(l)\n    return sorted.unique()\nThis is more or less the same as the list comprehension, just with an extra step to make it a function. I'm not sure I see the point.\n\nIt's a lot more readable.\n\nThe one I'm looking for is a list comprehension that takes a list of tuples and returns a list of the tuples that have the same second item.\n\nThat is an interesting problem. I haven't thought about it before.\nYou might be able to use the built in function zip to get the first item of each tuple and compare the two.\n\nIt's not a problem for me, but I'm curious how you'd solve it.\n\nI guess you could do something like:\n[(x, y) for x in zip(tuple1, tuple2) if x == y]\n\nThe problem is that you need to do it in one step.\n\nI'm not sure I understand. How is this different from:\n[(x, y) for x in zip(tuple1, tuple2) if x == y]\n?\n\nOh, I see what you're saying", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    sorted = []\n    for i in l:\n        if i not in sorted:\n           sorted.append(i)\n    return sorted\n\nI've always wondered if this was the \"best\" way to do it, or if it was possible to do it in O(n) time.\n\nThe best way to do it is with a hash table.\n\nI always use a hash table for this, too. I never thought of using a list.\n\nYou could also use a dictionary.\n\nI've always used a dictionary for this, but I didn't know it was the \"best\" way.\n\nThe \"best\" way is to use a hash table.\n\nI've always used a hash table for this, too. I never thought of using a list.\n\nYou could also use a dictionary.\n\nI've always used a dictionary for this, but I didn't know it was the \"best\" way.\n\nThe \"best\" way is to use a hash table.\n\nI've always used a hash table for this, too. I never thought of using", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda item: item.count())\nI'm not a Python programmer, so maybe someone can explain this to me. I thought the point of Python was to avoid having to write this kind of stuff.\n\nThe point of Python is to be a \"batteries included\" language. It comes with a lot of stuff built-in, but it also gives you a lot of rope to hang yourself with.\n\nThis is a good example of the \"batteries included\" approach. It doesn't do anything \"smart\" like the built-in sort would, but it's easy to read and understand.\n\nThis is a very good example of a \"batteries included\" approach, but it's not a very good example of the \"easy to read and understand\" approach.\n\nI think it is, actually. The fact that it's a function is a big plus. It's also a good example of how to use Python's built-in functions.\n\nThe built-in sort function is:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x.startswith('_'))", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    \"\"\"\n    \"\"\"\n    return sorted(l.items(), key=lambda x: x[0] - x[1])\n    \"\"\"\n    def is_unique(l: list):\n    \"\"\"Return True if list has no duplicates\n    >>> is_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    True\n    \"\"\"\n    return sorted(l.items(), key=lambda x: x[0] - x[1]) == sorted(l.items(), key=lambda x: x[0] - x[1])\n    \"\"\"\n    return is_unique\n\nReferences\n\nExternal links\n http://www.python.org/</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.pop(0))\nI don't know why, but that made me smile.\n\nI don't know why, but that made me smile too.\n\nI think it's the \"pop(0)\" that does it.\n\nI think it's the \"def unique\" that does it.\n\nIt's the \"return sorted\" that does it for me.\n\nIt's the \"l.pop(0)\" that does it for me.\n\nIt's the \"sorted\" that does it for me.\n\nI think it's the \"def\" that does it for me.\n\nI think it's the \"return\" that does it for me.\n\nIt's the \"l.pop(0)\" that does it for me.\n\nIt's the \"sorted\" that does it for me.\n\nIt's the \"l.pop(0)\" that does it for me.\n\nIt's the \"sorted\" that does it for me.\n\nIt's the \"l.pop(0)\" that does it for me.\n\nIt's the \"sorted\" that does it for me.\n\nIt's the", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0])\nThis is very clever. I've been doing a lot of Python and I think this is the first time I've seen this idiom.\nI'm not sure if this is the best solution for Python though. In Python, you can just sort the list, and then filter out the elements that aren't unique.\nIn Python, you can do this: \n>>> [0,2,3,5,9,123]\n[0,2,3,5,9,123]\n>>> sorted([]).filter(lambda x: x[0])\n[0,2,3,5,9,123]\n[0,2,3,5,9,123]\n\nI don't think this is the same thing.\nThe article's solution is a list of unique elements.\nThe python solution is a list of unique integers.\n\nThe Python solution is a list of unique elements, where the elements are integers.\n\nI'm not sure if I'm missing something, but the unique() function in the article is not sorted. The Python solution is sorted, and it has the added advantage of being", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.sort()", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.index.values(), key=lambda x: x[0] )\nI'd have to use a dictionary to do this in python?\n\nYes.\n\nWhy not just use Python's built-in sorted() function?\n\nI don't know about Python but in Ruby you can't sort a list of integers using the built-in sort function. It will sort them numerically (i.e. [1, 2, 3, 4, 5] will become [1, 5, 2, 3, 4]).\n\nPython's built-in sort does that too.\n\nHow is this different from the built in sorted() function?\n\nIt's not.\n\nPython 3.0 has a new built-in function called sorted() that is not the same as the one in 2.x.\n\nPython 2.7 has a new built-in function called sorted() that is not the same as the one in 2.x.\n\nAnd that's why I didn't know about it.\n\nI think it's a good idea to make an \"alternative\" function to the built-in one, especially if it's going to be used in a library", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l\n    else:\n       return sorted(l, key=lambda x: unique(x[1]))", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l), key=lambda x: x[0] - x[1])\nI'm not sure if you're going to be able to use set() with a list.       sorted(set(l), key=lambda x: x[0] - x[1])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.pop(0)\nThis is not a very good example. If the list is already sorted, then this will return the first element, which is not the unique element.\n\nThis is not a very good example. If the list is already sorted, then this will return the first element, which is not the unique element.\nI agree. It should be:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: len(x) == 1)\nThis is really neat. Thanks!</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[0], reverse=True)\nI don't understand the key function. It just returns the first element in the list?\nIt's the index of the first unique element in the list.  It's not a function, it's a lambda.\nOh, thanks. I guess I need to read up on lambdas.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0])\n\nThis is the fastest solution I've found.  It's also the simplest, and it's the one I use.  The only problem is that it doesn't work for lists that have duplicates in them.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda l: len(l) - key)", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def uniq(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    def __sort__(self, a: list, b: list):\n    \"\"\"Return a sorted list of unique elements in a list\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(a, key=lambda x: x[1] if x else x[0] for x in l)\n    def __eq__(self, other):\n    \"\"\"Return True iff a and b are equal\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    True\n    >>> uniq([5, 3, 5,", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda a: a[0])\nI like this one better. It's more concise, more flexible, and less error-prone.\n\nI don't know why you're getting downvoted. It's a good example of the need for a code review.\n\nIt's a bit off topic, but why do people think that code reviews are a good thing?\n\nCode reviews are a good thing when done right.\nThe problem is that code reviews are not always done right.\nThe most common problem is that code reviews are used as a tool for micromanaging.\n\nI have a problem with this. The problem is that the author is implying that it is a bad thing to be able to write code that is not easily read by others. I think that it is a good thing to be able to write code that is not easily read by others.\nIn my opinion, this is a code smell. If you are having to write code that is not easily read by others, then it is likely that you are writing code that is not easily understood by others.\nThe better solution is to write code that is easily understood by others.\n\nThe problem is that the", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1] if x[1] in l else None)\nSo is this basically a slightly more concise way of saying      sorted(l, key=lambda x: x[1] if x[1] in l else None)\nNot really.       sorted(l, key=lambda x: x[1] if x[1] in l else None)       returns a list, not a single element.  It's also a lot less concise than       unique(l)        because        unique(l)         returns a single element, while the sorted version returns a list.\nAh, I see, I was looking at the wrong code.  Thanks for the clarification.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def uniq_in_list(l):\n    \"\"\"Return sorted unique elements in a list\n    >>> uniq_in_list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(l, key=lambda x: x[0] < x[1] and x[0] < x[2] and x[1] < x[3] and x[2] < x[4])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1])\n> unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(l, key=lambda x: x[1])\nI think that you're missing the point.\n\nI don't know Python, but in Java, the first one is definitely correct.\n\nAnd in Python, the first one is definitely correct.\n\nThe first one is correct in both languages, but the second one is not.\n\nYou're right, I misread that.\n\nI just tried to write a function to find the sum of the elements in a list. I've been using python for over 2 years and I thought I'd be able to write it in a few minutes. I was wrong.\nThe way I did it:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l), key=lambda x: x[0] - x[1])\nI think this is probably the most important function in python.\nThis is the one that I use most often.  I've also been using it in C++ when I need to do something similar.\nI used to use it all the time, but I've found that it's faster to just use a list comprehension if you need to use it on large data sets.\nIf you have a large data set, you should be using a database, not Python.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def unique_in_order(l: list):\n    \"\"\"Return a list of unique elements in a list.\n    >>> unique_in_order([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(unique(l))\n\nSo, if you want to sort a list of integers, you can do this:\n>>> from itertools import groupby\n>>> list = list(range(1,10))\n>>> sorted_list = list.groupby(lambda x: x)\n>>> sorted_list.sort()\n>>> sorted_list.unique()\n[0, 2, 3, 5, 9, 123]\n\nIf you want to sort a list of strings, you can do this:\n>>> from itertools import groupby\n>>> list = list(range(1,10))\n>>> sorted_list = list.groupby(lambda x: x.lower())\n>>> sorted_list.sort()\n>>> sorted_list.unique()\n[0, '2", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[0])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def uniq(l: list):\n    \"\"\"Return the unique elements in a list\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(set(l))\nI'd say this is a more elegant solution than the one from the article.\n\nI agree that it's more elegant, but it's also more complicated.\n\nI don't see how it's more complicated. It's essentially the same thing, just in a different order.\n\nI think the article's solution is more intuitive, but it is also more complicated. The article's solution requires more lines of code, more variable names, and more functions.\nI think it's interesting that the article's solution is easier to read. It's a good example of how the quality of code is more important than the quantity of code.\n\nThe example from the article is also a little more complex than it needs to be.\n\nI don't think so. It's only a little bit more complex, and it makes it much easier to", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1])\n\nThis is a really, really bad idea. You have to use the same key for every element of the list, and that key is not guaranteed to be stable.\nThe better way to do it is to use the built-in `unique()` method, which guarantees stability.\n\nI think the best way to do it is to use a stable sorting algorithm, like quicksort.\n\nIf you're using Python, you're already using a stable sorting algorithm, so you don't need to worry about that.\n\n_If you're using Python, you're already using a stable sorting algorithm, so you don't need to worry about that._\nYou should worry about it. Python's built-in sort is stable, but it's not quicksort.\n\nI don't understand. I thought quicksort was just a stable sorting algorithm. I thought the whole point was that it was stable, and that it was called quicksort because it was the fastest stable sorting algorithm.\n\nThat's the general idea, yes.\nThe Python implementation of quicksort is stable, but it's not the fastest version of qu", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return [l[0] for l in l]\n    else:\n        return sorted(l.__contains__(0))\nI think this is the same as the built-in function unique() in Python.\n\nThis is the same as the built-in function unique() in Python, but it is not the same as the built-in function unique() in Python.\n\nThe list comprehension syntax is a bit odd.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def uniq(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(l.items(), key=lambda x: x.key)\nPython's `unique` is a lot more clever than that.\n\nI'm not sure what you mean by \"clever\".\nThe implementation I quoted is the same as the Python one. The only difference is that I didn't bother to put in the extra code to generate the sorted list.\n\nPython's `unique` is more clever because it works on any iterable, not just lists.\n\nOh, I see what you mean.\n\nI'm not sure if the author has a good understanding of what a sorted list is.\nA sorted list is a list where the items are in order. If you sort a list of numbers, you get a list of numbers. If you sort a list of strings, you get a list of strings. If you sort a list of", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def uniq(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    return l.filter(lambda x: x[1]!= x[0])\nI prefer this version:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    \"\"\"\n    if len(l) == 1:\n        return l[0]\n    else:\n        return unique(l.pop(0))\n\nI prefer a function that does the job in O(1) time, not O(n).</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.sort()\n    def unique_with_reversed(l: list):\n    \"\"\"Return sorted unique elements in a list with reversed order\n    >>> unique_with_reversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [2, 3, 5, 9, 0, 123]\n    \"\"\"\n    return l.sort()\n    def unique_with_reversed_reverse(l: list):\n    \"\"\"Return sorted unique elements in a list with reversed order and reversed\n    >>> unique_with_reversed_reverse([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [9, 0, 5, 3, 2, 123]\n    \"\"\"\n    return l.sort()\n    def unique_with_reversed_reverse_reverse(l: list):\n    \"\"\"Return sorted unique elements in a list with reversed order and reversed\n    >>> unique_with_reversed_reverse_", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[0])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x.endswith(l.startswith(x)))\nThis is the first time I've seen `key=lambda x: x.endswith(l.startswith(x))`. Is this common in python? I've always just used `key=lambda x: x in l`.\nIt's a fairly common idiom in Python.  It's just a helper function that does the same thing as yours, but in a more concise way.       return sorted(l.items(), key=lambda x: x.endswith(l.startswith(x)))  vs       return sorted(l.items(), key=lambda x: x in l)</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda item: item.index)\n\nI was trying to figure out how to do this with a list of lists. I've never used Python before.\n\nI don't know how to do it in Python, but I'm pretty sure that's a terrible way to do it. If you have a list of lists, you're dealing with nested lists, not arrays.\n\nI'd say it's a pretty good way to do it. If you have a list of lists, you're dealing with nested lists, not arrays.\n\nWhat is the problem with nested lists that prevents you from using an array?\n\nNested lists are an abstraction.\n\nThat's a fine answer, but it doesn't actually answer my question.\n\nIt is an answer. Nested lists are an abstraction. Arrays are a different abstraction.\n\nI'm not sure what you mean by \"abstraction\" here. In this context, it seems like you're saying \"nested lists are an abstraction, and arrays are a different abstraction\".\nBut this doesn't tell me why you can't use an array to represent a list of lists.\n\nI'm not sure what you", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda a, b: b[0] < a[0] and a[1] < b[1])\n\nI think this is the most common way of doing it. It is also the most straightforward.\nI don't know what \"the most common way of doing it\" is, but I've seen this approach in the wild exactly once.\n\nThe most common way of doing it is probably using a map or a set.\n\nI've seen that a few times.\n\nI do it like this:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.keys(), key=lambda x: x.index(l))\n\nI don't know about Python, but this is actually wrong in many other languages.\n\nThe fact that it's wrong in many other languages is why I posted it. I thought it was a good example of why you should not assume things are the same in different languages.\n\nYou can also do this with the built-in ` sorted() ` method:\n>>> sorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[0, 2, 3, 5, 9, 123]\n>>>\n\nThe built-in `sorted()` method is not a good idea in Python, because it uses an O(n) algorithm.\n\nIs there a better way to do it in Python?\n\nYes:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.sort()\nYou can also do      unique(l).keys()  which is a bit faster.\n\nOne other thing to keep in mind is that the `unique()` function is not guaranteed to be stable in all cases. For example, if you have a list of lists, you might get different results with the two forms above.\n\nI would say that's a bug, not a feature.\n\nThe code is", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return []\n    else:\n        return sorted(l, key=lambda x: x[0], reverse=True)\n    # yay, python\n\nPython's list.sort() is O(n log n)\n\npython's built-in sort() is O(n log n), but the built-in unique() is not.\n\nThe built-in sort() is O(n log n) for a list of integers. It's O(n^2) for a list of any other type.\n\nI know, I was just being pedantic about the \"python's built-in sort() is O(n log n)\" part.\n\nSort of like the difference between sorting a list of integers and sorting a list of strings.\n\nYou could use a binary search for a list of integers.\n\nThe way this algorithm is implemented is very slow. It's very inefficient to compare every element of the list to every element of the list to the left of it. You could do it in O(n) time by using a binary search.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    unique = sorted(l, key=lambda x: x.__class__.__name__, reverse=True)\n    return unique\nI don't know why people keep doing this. It's not a good idea to use sorted to sort a list of unique values.\n\nI think it's a great idea. It's a very simple and understandable way to sort a list of unique values.\n\nThat's not the point. The point is that it's not a good idea to use sorted to sort a list of unique values.\n\nWhy not? It's a perfectly good idea to use sorted to sort a list of unique values.\n\nIt's not a good idea to use sorted to sort a list of unique values.\n\nWhy not? It's a perfectly good idea to use sorted to sort a list of unique values.\n\nIt's not a good idea to use sorted to sort a list of unique values.\n\nWhy not? It's a perfectly good idea to use sorted to sort a list of unique values.\n\nIt's not a good idea to use sorted to sort a list of unique values.\n\nWhy not? It's a perfectly good idea to use sorted to", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def __init__(self, list):\n    \"\"\"Initialize the unique function.\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 3])\n    Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    TypeError: 'list' object is not callable\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    self.list = list\n    self.count = 0\n    self.head = None\n    self.tail = None\n    self.sort_key = None\n    def __iter__(self):\n    \"\"\"Return the iterator of this list.\n    >>> unique", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.pop(), key=lambda x: x[0])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted_unique(l):\n    \"\"\"Return sorted unique elements in a list\n    >>> sorted_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    if len(l) == 0:\n        return []\n    elif len(l) == 1:\n        return l[0]\n    else:\n        return sorted(unique(l))\n    return sorted_unique\n\nThis is not a very good algorithm.\nI'd use a quick sort to sort the list, then a binary search to find the unique element.\n\nI'm not a python expert, but I believe the binary search is not necessary. A quick sort will put the unique element at the end of the list.\n\nThat's the point of the article.\n\nAha. I missed that.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for l in list:\n       if not isinstance(l, list):\n          raise TypeError(\"list must be a list\")\n          return l.sort()\n    return l\n\nThat's not unique, it's sorted. It won't work on a list of integers.\n\nI guess the title should have been \"Sorted unique elements in a list\"\n\nI'm not sure if you're just trolling, but it's not sorted either.\n\nYes it is.\n\nIt's not sorted. It's sorted by integer value.\n\nIt's sorted by integer value in ascending order. That's a type of sorting.\n\nI'm sorry, I'm not a native english speaker. I thought that \"sorted\" meant \"sorted by a field\".\n\nNo worries. Sorting is a general term.\nIn this case, you're sorting by integer value.\n\nThanks for the clarification!\n\nI don't know Python, but I can tell you that this is not a good way to write code. It's not clear what's going on and", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    if l.count() == 1:\n       return l\n    else:\n       return l.pop()\n    sorted(l.sort()).unique()", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1], reverse=True)\nThis is a bad solution. It will return a sorted list, but it will not preserve the ordering of the original list. It will return [2, 3, 5, 9, 123] instead of [0, 2, 3, 5, 9, 123]\n\nIn this case, the ordering doesn't matter. It is a simple solution that works.\n\nI understand that this is a simple solution that works. I am not criticizing the solution.\nI am criticizing the article. It gives a solution that does not work.\n\nIt works if you're just sorting a list of integers.\n\nI'm surprised no one has mentioned the built-in Python function \"sorted(key=lambda x: x[1])\" which returns the unique elements in a list sorted by key.\n\nIt doesn't preserve the ordering of the original list.\n\nIf you want to preserve the ordering of the original list, you can use the built-in \"sort()\" function.\n\nThe author does mention sort() at the end of the article.\n\nI'd like to see the pythonic solution to this", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n        return l\n    elif len(l) == 2:\n        return unique(l[1])\n    elif len(l) == 3:\n        return unique(l[0], l[1])\n    elif len(l) == 4:\n        return l[0]\n    else:\n        return unique(l[-1], l[-2])\n\nI find it interesting that the author of this function seems to have a problem with the first case, but not the second.\n\nIt's a matter of taste, I suppose. I like the second case because it's more consistent with the semantics of the rest of the language. The first case is more in line with the \"pythonic\" style, but it's not really Pythonic.\n\nI'm not sure I understand the difference between the two. I would have expected the second case to have a bug in it, but I can't find one.\n\nIt's", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1])\nI think that should be sorted(l, key=lambda x: x[1] and key=lambda x: x[0])\n\nYou're right, but it's not the first time I see this mistake. It's probably worth pointing out that the list is not sorted in the above example, and that the key function is not a method of lists.\n\nI was actually just wondering about this the other day, and wrote a quick script to check it out:\n\nIt looks like the author is missing a few cases.\n\nI wonder if the author knows about the Python built-in function itertools.tee(). It's exactly what he needs.\n\nI believe the author is trying to show how to write a function that would work with any iterable.\n\nI would have thought itertools would be part of any Python programmer's toolkit.\n\nI believe the author is trying to show how to write a function that would work with any iterable.\n\nI would have thought itertools would be part of any Python programmer's toolkit.\n\nI believe the author is trying to show how", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    sorted_uniq = sorted(l, key=lambda x: x[1])\n    return sorted_uniq.sort_values(reverse=True)\n\nI think it's better to use:\nreturn sorted(l, key=lambda x: x[1])\n.reverse()\n\nThat's a good one too. I was just trying to keep it simple.\n\nI've seen a lot of these. Here's another:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda item: item[1])\nI've been using this one for a while.  It's really easy to remember, and I've never had a problem with it.\n\nYou can do that in python using the built-in sorted function, which is faster.\nsorted(l, key=lambda item: item[1])\n\nI don't think it's any faster, since Python's sorted function is implemented in terms of the built-in _list.sort_, which is also O(n log n).\n\nThe sorted function in python uses a different algorithm than the built-in sort.\n\nNot in Python 2.6.\n\nThis is one of the most useful Python features that is not widely known.\n\nOne of my favorite python features is the magic methods that are available on lists, dicts, sets, etc.\ne.g.\n>>> l = list(range(10))\n>>> l.index(1)\n0\n>>> l[0]\n0\n>>> l.__contains__(1)\nTrue\n>>> l.__setitem__(0, 1)\n>>> l\n[0", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) < 2:\n       return l\n    else:\n       return unique(l[0], l[1])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l), key=lambda a: a[0] < a[1])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    unique = lambda x: x[0]\n    unique(l)\n    return unique(l)\nI've seen this a lot, and I've never really understood why people write this.  I mean, it's not hard to write a function that returns the first element of a list.  I can understand why someone would write this for a language like C, where you have to allocate a new variable for each function call, but in Python, it's a bit silly.  I'm sure there's a good reason, but I'm not sure what it is.\nI don't know why people write this either.  I think it's just an example of how Python allows you to write code that looks like it's doing something but is actually doing something else.  It's a bad example, though, because it's so easy to write it the right way.\nI'd say it's more of a case of \"I'm writing this to learn Python, and I don't know how to write a function that returns the first element of a list, so I'll just do this instead.\"\nI think it's more of a case of \"I'm writing this to learn Python, and", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.unique()\n\nI like it.\n\nI'm not sure it's correct to call it 'unique' when it's not really unique, but the definition is simple and easy to read.\n\nThere is no need to sort the list. It is already sorted.\n\nThe list is already sorted, but not in a way that is useful for the purpose of finding the unique elements.\n\nI don't know. I think it's a pretty reasonable way to do it.\n\nI like it.\n\nI'm not sure it's correct to call it 'unique' when it's not really unique, but the definition is simple and easy to read.\n\nThere is no need to sort the list. It is already sorted.\n\nThe list is already sorted, but not in a way that is useful for the purpose of finding the unique elements.\n\nI don't know. I think it's a pretty reasonable way to do it.\n\nI like it.\n\nI'm not sure it's correct to call it 'unique' when it's not really unique, but the definition is simple and easy to read.\n\nThere is no need to sort the list. It is", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted_unique(l):\n    \"\"\"Return sorted unique elements in a list\n    >>> sorted_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(l.items(), key=lambda item: unique(item))\nI'm not sure if it's the same thing but I think this is how Python does it.\n\nI think this is a case of \"if it ain't broke, don't fix it\".\n\nI don't know about that. The Python version is not quite as efficient as the original. The original doesn't use a hash function, so it can be faster for small lists.\n\nThis is a great example of why I prefer Python's way of doing things.\n\nPython does have a way of doing things. The problem is that it's not consistent.\n\nThe Python community has a way of doing things, which is to invent a new way of doing things every 6 months.\n\nA way of doing things that they've been doing for years, in fact.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n        return l\n    else:\n        return sorted(l, key=lambda x: x[0])\n\nI think you want to use:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted_unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> sorted_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    if len(l) == 1:\n        return sorted(l)\n    else:\n        return sorted_unique(l)\nThat's not a valid use of the `return` keyword.\n\nThanks, I'm not a python programmer.\n\nI think it's good to write your own version of a sorting algorithm to get an intuitive feel for how it works.\n\nThe author mentions that the code is taken from a book. I've read this book (it's a good one, I recommend it) and it has a good explanation of the algorithm.\n\nI'm going to have to disagree with you on this one.\nI've read this book and I think it's a good introduction to the basic concepts of algorithms, but it doesn't really teach you how to", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted_unique(l):\n    \"\"\"Return sorted unique elements in a list\n    >>> sorted_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    return l.unique()\nThe author of this article should know better.  Sort() is not a stable sort.  It can be made stable by using the 'stable' argument on the sort function.\n\nIt is a stable sort on most modern implementations, and I'm guessing that's what the author was using.\n\nNo, it's not. It's stable in the sense that the order of the elements in the list don't change, but the order of the elements in the output is not guaranteed to be stable.\n\nI think this is a good example of how to write a good, readable, and understandable Python program. It's also a good example of how to use Python's built-in functions to achieve a goal.\n\nI wouldn't say this is the best example of how to write a good readable", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.sort()\nI think it's better to return sorted list and not the elements.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted(l: list):\n    \"\"\"Return sorted list\n    >>> sorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(unique(l))\n\nThis is a really bad example. I'm not sure what you're trying to do, but the example is wrong.\nThe problem is that the first element of the list is 5, and then 3, 5, 2, 3, 3, 9, 0, and 123. The list is sorted, but the first element is not unique.\n\nI agree with you. I'm trying to get the first element of the list. I can't seem to figure out how to do that.\n\nIf you want the first element, you need to use a list comprehension:\n[x for x in l if x not in l[0]]\n\nThat's not a list comprehension, it's a generator expression.\n\nIt's a list comprehension:\n>>> [x for x in l if x not in l[0]]\n[0, 2", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def uniq(l):\n    \"\"\"Return sorted unique elements in a list\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(l.sort(), key=lambda x: x[0])\n\nThis is a bad example. The code is using the default sorting algorithm, which is the same as the one used by Python's builtin sort function.\n\nI don't understand why they didn't use the built-in sorted() function.\n\nBecause the code is a bad example.\n\nIt's a bad example because the author is using a default sorting algorithm? I don't think that's a valid reason.\n\nNo, it's a bad example because the author is not using the built-in sorted() function.\n\nI find it amusing that the example uses the default Python sort algorithm, which is also the default sort algorithm used by the built-in sort function.\n\nI find it amusing that you don't understand the difference between a default sorting algorithm and a built-", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0] - x[1])\n\nThis is a really bad way to do it.\nThe problem is that you are comparing the first element of the list against the second, and so on. The second element of the list is compared against the third, and so on. If the first element of the list is the same as the second, then the list is not unique, even though the second element is unique.\n\nThis is much better:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[1])\nWhat's the difference between this and the built-in `unique()`?\n\nThe built-in `unique()` is a method of `list`; this is a function that can be called on any iterable (list, set, tuple, etc).\n\nI see. Thanks.\n\nI've been using Python for a while and I've never seen this. It's a really nice idea, but I don't know how I would use it.\n\nIf you ever need to sort a set of unique items, this is a good way to do it.\n\nI like the idea of it, but I have to ask: How is this different from the built-in `unique()` method of lists?\n\n`unique` is a method of lists, not of sets.\n\nAh. Thanks for the clarification.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n       return l\n    elif len(l) == 1:\n       return l[0]\n    elif len(l) == 2:\n       return l[0]\n    elif len(l) == 3:\n       return l[0]\n    elif len(l) == 4:\n       return l[0]\n    elif len(l) == 5:\n       return l[0]\n    elif len(l) == 6:\n       return l[0]\n    elif len(l) == 7:\n       return l[0]\n    elif len(l) == 8:\n       return l[0]\n    elif len(l) == 9:\n       return l[0]\n    elif len(l)", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0] if x else 1)\nI'm not sure what the benefit of this is over the standard `itertools.islice`</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l)), unique(set(l))\nI love this.  It's so simple.  I'm going to use this in the future.\nIt's also very fast, because it doesn't need to sort the list, it just needs to sort the set.  It's also very easy to understand.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def uniq(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [5, 3, 9, 0, 123]\n    \"\"\"\n    if len(l) == 1:\n       return l\n    for i in range(len(l)):\n       if l[i] == l[i+1]:\n          return l[i]\n    return [l[i] for i in uniq(l)]", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1])\n    def all(l: list):\n    \"\"\"Return all elements in a list\n    >>> all([1, 2, 3, 4, 5])\n    [1, 2, 3, 4, 5]\n    \"\"\"\n    return len(l)\n    def max(l: list):\n    \"\"\"Return max element in a list\n    >>> max([1, 2, 3, 4, 5])\n    5\n    \"\"\"\n    return l[0]\n    def min(l: list):\n    \"\"\"Return min element in a list\n    >>> min([1, 2, 3, 4, 5])\n    2\n    \"\"\"\n    return l[-1]", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def unique_by_key(l: list, k: key):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique_by_key(['1', '2', '3', '4', '5', '6', '7', '8', '9'], '2')\n    [0, 2, 3, 4, 5, 6, 8, 9]\n    \"\"\"\n    return [x for x in l if unique(k, x) for k in l.keys()]", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return [l.index(x) for x in l if x not in l.pop()]\nI prefer the following:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[0] - x[1])\n\nOne nit: the key function should take a single argument.\n\nThe article seems to assume that the reader is familiar with Python's\nbuilt-in dictionary and list types.\n\nWell, it's more that I assume the reader is familiar with the concept of a dictionary, and with the fact that lists are ordered.\nI should probably be more explicit about that.\n\nThis is one of my favorite features of Python. I use it a lot.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    unique = lambda x: x[1] in x\n\nIn Python 3.0, you can use xrange instead of range.\n\nAh, I didn't know that. I've only used Python 2.6.\n\nThis is a great article. It's a nice introduction to the problem, and it's a good example of the kind of problems that can be solved with a single line of code in a functional programming language.\nIn fact, this is the kind of problem that I find functional languages are really good at. If you have a list of numbers, and you want to find the sum of all the numbers, you can write:\nsum = 0\nfor n in list:\nsum += n\nThis is a lot like the list comprehension in the article, except you have to manually calculate the result at the end.\n\nI like how the author says \"Python\" instead of \"Python 3\" in the title.\n\nIt's a good idea to include the version number in the title of the post. It helps people who are looking for a solution for Python 2.6.\n\nI don't think so. If you're looking for a solution for Python 2.6, you're", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    # The function is recursive.\n    if l: isinstance(l, list):\n        return sorted(l.items(), key=lambda x: x[0])\n    else:\n        return sorted(l.items(), key=lambda x: x[1])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1] if x[0] in l else None)\nIt would be nicer to have a less verbose syntax, but this is what I use.\n\nThis is also the first thing that came to my mind, but the problem is that it's not thread safe.\n\nIs there a good reason why you would need to sort a list in a thread?\n\nI'm not sure if it's a good reason, but it's a reason I've had to do it in the past. I had a thread that was computing some statistics for each element in a list, and needed to sort the list to keep the statistics in the correct order.\n\nI would have done it like this:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    unique = lambda list:\n         if len(list) == 1:\n             return list\n         else:\n               return unique(list, lambda x: x[1])\n          return unique\nI've never understood the point of this. Why not just:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda item: item[0] < key)\n    def sorted(l: list):\n    \"\"\"Return a sorted list of elements in a list\n    >>> sorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return list(l.sort())\n    def list(l: list):\n    \"\"\"Return a list of elements in a list\n    >>> list([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [5, 3, 5, 2, 3, 3, 9, 0, 123]\n    \"\"\"\n    return l\n\nIf you're trying to show off Python, why not show off a better way to do it?\n\nI'm not trying to show off Python.\nI'm trying to show off a way to do it that is in-line with the language's design philosophy.\n\nI'm sorry, I don't see how that", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l), key=lambda x: x[0])\n\nI was about to say that this is not a good idea because it's not stable: if you insert something in the middle of the list, it will no longer be unique. Then I read the article and noticed it's about a list of integers. This is a very bad idea.\n\nIt's not a bad idea if the list of integers is never modified.\n\nIf the list is never modified, you're wasting memory by storing a sorted list.\n\nOnly if it is a sorted list of integers.\n\nI don't understand why you would want to use this. Can you give some examples?\n\nI use it in a number of ways. It's useful for sorting a list of integers, or a list of numbers.\nIt's also useful for finding the last number in a list, without having to resort to a more complicated algorithm.\n\nI think I must be missing something, I can't think of a situation where I'd need to sort integers or numbers.\n\nIt's useful for sorting a list of integers, or a list of numbers.\nIt's also useful for finding the last number in a", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[0])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[0] < x[1] for x in l.items())\nThis is a good example of why you should never use list comprehension for a task that can be done with a single line of code.\n\nCan you explain why? I'm not sure I see the problem.\n\nSure.\nThe problem is that the comprehension is making an unnecessary copy of the list, which is O(n) in the number of elements in the list.\n\nI'm not sure what you mean by \"unnecessary copy\".\n\nThe comprehension creates a list with the sorted elements, and then returns that list.\nIn Python, a list is a container for a sequence of elements. A list comprehension creates a list from a single expression.\nIn this case, the expression is a list comprehension.\nSo what happens is that the list comprehension creates a list, then returns that list.\n\nI think I see what you're saying. I just don't understand why that's a problem.\n\nThe list comprehension is making an unnecessary copy of the list, which is O(n) in the number of elements in the list.\n\nI'm not", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return []\n    else:\n        return sorted(l.index, key=lambda x: x[0])(l)\nThis is not a good way to do this. The python implementation is also flawed.  Use a hash table instead.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0])\n\nYou can use the unique() function instead of sorting if you are dealing with a list of integers.\n\n>>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[0, 2, 3, 5, 9, 123]\n\nI think this is the most elegant way to do it.\n\nThank you!\n\nI like the way the solution in the article uses a dictionary to store the sorted list.\n\nThanks!\n\nSortedDict is the way to go.\n\nThis is a great way to do it, but it's not the only way.\n\nI'm not sure how this is better than a dictionary.\n\nIt's not. It's a lot slower.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda item: item[0] == item[1])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sort_unique(l: list):\n    \"\"\"Sort a list of unique elements.\n    >>> sort_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(l.unique(), key=lambda x: x)\nThis is a bad algorithm, because it requires a linear scan over the list. It is also a bad algorithm because it is not stable.\n\nI don't see how it's bad. It's linear, yes, but it's stable. It's not like you're going to get the same order twice if you do a bunch of them.\n\nThis is not a stable sort algorithm. If you sort a list of unique elements, and then sort it again, you will get a different result.\n\nIt is stable. You can't have the same list twice.\n\nYou can have the same list twice.\n\nThis is a good example of why you should use a real programming language.\n\nI don't think this is a very good example of why you should use a", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.pop(), key=lambda x: x[0])\nWow, I was expecting a `reduce` or `sorted()` call, but this is just beautiful.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted_unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> sorted_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(l.sort(), key=lambda x: x[0])\n\nPython", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda l: l[0], reverse=True)\nI'm not sure that's the best way to do it. A better way would be:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted(l: list):\n    \"\"\"Return sorted elements in a list\n    >>> sorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(unique(l))\nWhat is the advantage of this over:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    unique = lambda l: sorted(l.items(), key=lambda x: x[1])\n    return unique\nI think the best thing to do here is to return a tuple of the sorted list and the key.  You can then use the key to get the next element in the list (or just iterate over the tuple).  This is the same as the example given in the article.\nI think you're right, but that's not what the article says.  It says to return the sorted list.    I think the article is wrong.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def uniq_l(l):\n    \"\"\"Return a sorted list of unique elements in a list\n    >>> uniq_l([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(l.filter(lambda x: x.is_unique()), key=lambda x: x.value)\n    return uniq_l", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1] < x[0] for x in l)\n\nI'm not sure I understand the first example. How is it different from the second?\n\nIt returns the unique elements in a list in sorted order. The first example returns a sorted list of unique elements.\n\nThanks! I thought the second example was a list of unique elements, and the first was a function to create a sorted list of unique elements.\n\nYou can also use a sorted list as an iterator to get the unique elements.\n\nI use a list comprehension to do this:\nunique_elements = [x for x in sorted(x) if x[1] < x[0]]\n\nThat's not a list comprehension. It's a list comprehension with a for loop in it.\n\nIt's a list comprehension with an expression in it, which is a list comprehension.\n\nI think I'm going to have to create a project that just creates and tests out different variations of list comprehensions.\n\nI've done this, and I found it to be a lot of fun.\n\nI was just playing around with this:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda l: l[0], reverse=True)\nThis is the same as the built-in sort function, but without the reverse=True.  The built-in sort function will automatically reverse the list if it is a list of integers.\n\nThere's also a built-in function called unique that does this for you:\nunique = sorted(set(list(x)) for x in list(list(x)))\n\nI don't think that's the same as the OP's code. The OP's code will return the list sorted by the key, whereas the built-in function you mention will return the list sorted by the item's index in the original list.\n\nYou're right. I was thinking of unique(set(list(x)))\n\nThis is very similar to the built-in sorted() function.\n\nI'm not sure I understand the difference between this and the built-in sorted() function.\n\nThis function takes an optional lambda as the key parameter, which is used to determine the order of the elements.\n\nI had a feeling that was the case, but it wasn't clear to me from the description.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    else:\n       return sorted(l.items(), key=lambda l: l[l.index(0)])\nThis is a very naive implementation. You should take a look at the list module.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l))\nI love this one. It's so simple.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return [l[1] for l in l if l[1] not in l[1]]", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    sorted(l, key=lambda item: item[0])\n    return sorted(l, key=lambda item: item[1])\n    # (this is better)\n    return sorted(l, key=lambda item: item[0])\n\nYou can use this to sort a list of numbers (for example):\n>>> numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>> sorted(numbers, key=lambda i: i)\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>> sorted(numbers, key=lambda i: i[0])\n[2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>> sorted(numbers, key=lambda i: i[1])\n[8, 9, 10]\n\nI don't understand why this is better. What's the difference?\n\nIt's probably a little faster, because it doesn't use a lambda function to do the sorting.\n\nBut why does that matter? Is it because the lambda function is called twice?", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    unique_elements = []\n    for el in l:\n       if el not in unique_elements:\n          unique_elements.append(el)\n    return unique_elements", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l), key=lambda x: x[0] == x[1])\nThis is not the same as the implementation of the built-in `unique` in Python, which doesn't use `sorted`.\n\nThe standard library's implementation of unique is almost useless. I'm not sure why it's in the standard library.\n\nIt's not useless; it's just not as good as the one that uses `sorted`.\n\nIt's useless in the sense that it's almost never the right choice for the problem you're trying to solve.\n\nI'm not sure what you mean.\n\nI mean that if you're trying to solve a problem with unique, you'll almost always get a better result with sorted(set(l), key=lambda x: x[0] == x[1])\n\nThat's not the standard library's implementation of `unique`.\n\nI'm not sure what you mean.\n\nI mean that `unique` in the standard library is not the same as the one in the OP, which uses `sorted`.\n\nI'm not sure what you mean.\n\nI mean that `unique` in the standard library is", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[1])\nI'm not sure this is the most efficient way of doing it.\n\nI'm not sure it's the most efficient way either, but I find it hard to believe it's not the fastest.\n\nFor a list of length n, it's O(n) in both time and space.\n\nI'm not sure that's true. The time complexity is O(n log n).\n\nThe time complexity is O(n log n) because it's O(n) to sort the list, and then the space complexity is O(n) because it's O(n) to store the sorted list.\n\nIt's O(n log n) because it's O(n) to sort the list, but the space complexity is O(n log n) because the space complexity of sorting a list is O(n log n).\n\nIt's O(n) to sort the list, but the space complexity is O(n log n) because the space complexity of sorting a list is O(n log n) because the space complexity of sorting a list is O(n log n).\n\nIf you", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    unique_list = []\n    for i in l:\n        if i not in unique_list:\n           unique_list.append(i)\n    return unique_list", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1])\n\nThis is more of a toy example than a good one. The problem with this is that it doesn't work if you're sorting lists with different types. It works if all the lists are of the same type, but if they have different types, it will return a list of the same type as the first list.\n\nIf you're using Python 2, the sort function can return a list of any type.\n\nI was just thinking about this recently. I've been using Python for about a year now and I've never seen a use for the built-in sort() function.\n\nHow about this:\n>>> import random\n>>> l = [1, 2, 3, 4, 5]\n>>> sorted(l, key=lambda x: random.randint(0, 9))\n[1, 2, 3, 5]\n>>> sorted(l, key=lambda x: random.randint(0, 9))[0]\n1\n\nI think that's an example of the sort of thing that the built-in sort() function is useful for. I still haven't seen a situation where I needed to", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: len(x), reverse=True)\nThe \"key\" function is the heart of the algorithm, and is almost certainly the most important part.\n\nI'm not a Python programmer, but I think this is a bad example of the code being clear.\nThe \"key\" function is the heart of the algorithm, and is almost certainly the most important part.\nI don't know Python, but I think this is a bad example of the code being clear.\nThe \"key\" function is the heart of the algorithm, and is almost certainly the most important part.\nI don't know Python, but I think this is a bad example of the code being clear.\nThe \"key\" function is the heart of the algorithm, and is almost certainly the most important part.\nI don't know Python, but I think this is a bad example of the code being clear.\nThe \"key\" function is the heart of the algorithm, and is almost certainly the most important part.\nI don't know Python, but I think this is a bad example of the code being clear.\nThe \"key\" function is the heart of the algorithm, and is almost certainly", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[0] + x[1] + x[2])\n\nI had to look this up to see if it's really a built-in function in Python 2.6. It is.\n\nThis is a pretty basic example of a 'generic' function.\nIt's similar to the'map' function in functional languages.\n\nIt's worth mentioning that this is a built-in function in Python 2.6.\n\nI'm not sure what this has to do with functional programming.\n\nIt's a function that takes a list and returns another list.\n\nI'm not sure what this has to do with functional programming.\n\nIt's a function that takes a list and returns another list.\n\nI'm not sure what this has to do with functional programming.\n\nIt's a function that takes a list and returns another list.\n\nI'm not sure what this has to do with functional programming.\n\nIt's a function that takes a list and returns another list.\n\nI'm not sure what this has to do with functional programming.\n\nIt's a function that takes a list and returns another list", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.sort()\n    if len(l) == 0:\n        return []\n    return l\nI know this is a joke, but this is a terrible idea.\n\nYou could improve it by using a binary heap.\n\nI was thinking of the following:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l\n    else:\n       return unique(l.sort(key=lambda x: x[0]))\n\nThis is a great example of the sort of code that is easy to write, but very hard to read and understand.\n\nI don't understand why you say that. It's very clear to me.\n\nMaybe it's because I don't know Python, but I have to say that this is one of the most confusing things I've ever read.\n\nIt's a one-liner. How can it be confusing?\n\nI think it's more the function name that's confusing than the actual code.\n\nWell, I guess I can see how it could be confusing, but it's pretty clear that it's a function that takes a list and returns a sorted list of unique elements.\n\nI think the confusion is because it's a function that returns a list, but the function name suggests it's returning a tuple.\n\nI think the confusion is because it's a function that returns a list, but the function name suggests it's returning a tuple.\n\nI"]]