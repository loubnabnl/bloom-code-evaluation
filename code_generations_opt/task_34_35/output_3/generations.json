[["def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for elem in l:\n       if elem[0] is None:\n          return list(l[1:])\n       else:\n          return elem", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) > 1:\n        for e in l:\n           if l[e] == l[e+1]:\n               return l[e]\n    return list(set(l))", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return [l[0]]\n    return sorted(l, key=lambda x: x[0] - l[0] > l[1] - 1)\nHe's using a dict as an array, so the key's value has to be a single element, otherwise you'll end up with a bunch of unique keys.\n\nI'm not entirely sure that's correct. I think if you iterate over the dict, you get (key, value) tuples, so if the dict doesn't have keys that aren't unique, it would work.\n>>> d = {'a': 5, 'b': 1, 'c': 3, 'd': 2}\n>>> for key, value in d.items():\n...   print(key, value)\n...     print('\\n')\n...     print('\\n')\na         5\nb         1\nc         3\nd         2\n>>>\n\nYou're", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l))\nThis has the advantage that the sorted list is in fact a set, so that you can use it in set-theoretic ways.  This is a good thing because it's not trivial to tell whether something is unique if you need to use it in a list comprehension.  For example, you might have a list of dates, and you need to make sure that no two dates appear in the same list.\nI thought that `unique` was already sorted.  Isn't that what `sorted` does?\nIt might be.  I'm not sure.  I think it is in Python 2.x, but not in Python 3.x.  I guess that's because the types changed.  I've only used sorted in Python 2.x, so I was going on memory.  In any case, the code that you posted is the one that I use when I need to be sure that something is unique.\n`unique` is in 3.x, but it's in the list `set` rather than the type `sorted`.  It's probably not worth worrying about the distinction since I doubt you'll ever run into a situation where that actually matters.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for item in l:\n       if len(item) == 1:\n         return item\n       return unique(item)\nThis is why I'm not a fan of python.\nI wonder what the python folks would say if I made a class called \"int\" with one method:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    list_to_set(l, set=set())\n    return sorted(set)\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [2, 3, 5, 9, 123]\n\nThis algorithm works well if you have a list of unique items. For example, if you need to generate unique id's, it will work for you.\n\nThe sorted() function is also useful.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    sorted = sorted(l)\n    unique_elt = sorted.pop(0)\n    unique_elt_inc = unique_elt + sorted.pop(0)\n    sorted.sort(key=lambda x: x[0])\n    return unique_elt_inc\nWhat would be the performance of this? Is it slower than a simple for loop or not?\nThat's a good question, I'll have to test it out.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l[l[l.index(i) for i in range(len(l) - 1)] for i in range(len(l))]\nI hate this kind of code.  And I hate the fact that this kind of code is so common.  I don't understand the mindset of people who write code like this.  I'm just going to write a very long comment about why this is such bad code.  After I've written the comment, I'm going to write the code that does the same thing, but is much, much, much better.\nI understand where you're coming from, but I can't help but think of it as a \"hello world\" for python.  It's simple enough that it's easy to get into, but also a useful snippet that illustrates a very common and useful pattern.\nThe problem with this code is that it's not really simple at all.  It does a lot of stuff that could be done better in fewer lines of code.  My comment was actually a good deal longer, and it was almost all pointing out ways that this code could be made much, much shorter.\nI guess I should have said simple in comparison to other code.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted(l: list):\n    \"\"\"Sort a list, and return unique elements\n    >>> sorted([3, 5, 9, 0, 2, 3, 5, 3])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(l.reverse())\nI've been getting the idea lately that a lot of people don't know about this feature of Python.\nI think it's time to start a library of commonly useful functions, a la \"standard library\" for C++.\nWould be interesting to see what it would take to build up a library of commonly useful functions for Python.\n\nI agree. But first we'd need to agree on what's commonly useful.\n\nI don't really agree. The standard library has plenty of stuff that I think is useless and probably many things that you think are useless.\nBut the important thing is that it is easy to drop things in and get them out.\nIf we have a bunch of common stuff in it already, then it's just a matter of having the community pick and choose and add to it.\n\nI've been using a library of", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\n    for i in range(len(l)):\n        if (l[i]!= l[i]):\n             l[i] = l[i]\n         return sorted(unique(l))\n\nHehe, the code sample is of Python...\n\nWell, it's a good language, if only for all the jokes about it.\n\nThat's the one thing I miss about Python, the abundance of code jokes.\n\nThe author's performance \"benchmarks\" show that Python and Ruby are both terrible languages for numerical computing.\nFor example, on the real world problem of sorting a million elements, Ruby is twice as slow as C++, and Python is almost three times as slow.\nBut when you start writing a real program, and you aren't worried about performance, Ruby and Python are both fun languages to work in.\n\nThose benchmarks are interesting, but aren't really useful. I don't know what the problem is, but my gut feeling is that it is likely to be a problem with the benchmarks.\nFor example, it says that the c++ version", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[0])\nThis is a quicksort without a pivot, which is easy to spot since the median is 1.\n\nOk, I get the median part, but what does the rest mean? I don't have much experience with Python.\n\nThis function is doing a quicksort, which is a sorting algorithm that works by splitting the list into 2 equal size sublists, and then using a comparison function to compare each element in the first sublist with every element in the second sublist. The element that the comparison function indicates is the one that is \"less equal\" is moved to the other sublist and the process is repeated until both sublists are sorted. This algorithm is considered faster than other sorting algorithms in the general case because it requires relatively little memory to sort a list, but it is much less efficient if there is a cycle in the list.\n\nI'm still not sure what \"split the list into 2 equal size sublists\" means. I get the rest.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return list(l)\n    else:\n        return [x for x in l if unique(x)]\nYou may need to wrap your call to unique in an if statement to avoid it\nthrowing an error if the list is empty.\n\nWhat's wrong with the author's \"solution\"?", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    else:\n       return sorted(l, key=lambda l: l[0])\n\nThis is a great example of something that could be very easily implemented with list comprehensions, and indeed a list comprehension is provided in the Python standard library:\n>>> from itertools import chain\n>>> from functools import reduce\n>>> unique = lambda x: chain(*reduce(lambda x,y: x[0] == y[0], x))\n>>> print unique(['1', '2', '3'])\n['1', '2']\n>>> print unique([1, 2, 3, 4, 5])\n['1', '2', '3', '4', '5']\n>>> print unique(['1', '2', '3', '4'], reverse=True)\n['3', '4', '5', '1', '2']\n\nI must have written that function a long time ago before the new list comprehensions were added. I have written similar things since. But for me, I find that kind of", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\n    return sorted(l, key=lambda x: x[1])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[::-1])\nThat's not what's going on here. The goal is to return the sorted unique list. If you don't pass in the argument, it will return the unsorted list.\nI've edited it to make that more clear.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\n    def in_place(l):\n    \"\"\"Return the unique elements in a list\n    >>> in_place([4, 2, 2, 3, 4, 3])\n    [4, 2, 4, 2, 3]\n    \"\"\"\n\nIn python, this is a bad idea because of it's dynamic typing nature. You could get a list of strings from a function. If you then call in_place on this list, you would get a list of lists. The solution is to use a function like unique.      unique(l)", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.map(sorted(l)))", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.reverse(), key=lambda x: x[0])\nI think they mean return sorted(l.reverse(), key=lambda x: x[0])[0].  I have not tested this.\nDid you?  Because I think it doesn't work.  And I have tested it.\nOh I see.  Yes you are correct.  I was thinking if sorted(l.reverse(), key=lambda x: x[0])[0] is equal to something else, then you have a sorted list of unique elements.  But this is not true if the list isn't sorted.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    sorted_uniq = sorted(l)\n    unique_items = sorted_uniq.unique()\n    return unique_items", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    l.sort()\n    return sorted(l.sort(key=lambda x: x[0]), reverse=True)\nThis is not at all unique.\nI have removed the first element of the list.\n>>> unique(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'])\n['d', 'e', 'f', 'g', 'h']\n\nI am confused by your comment, can you explain it? I ran it through repl.it a couple times and it always came out with the same output.\n\nIt's not unique. I.e., it is not \"selecting the first unique element\" (as you state in the post). It's sorting and then returning the first element.\nI was being snarky, but that's not really fair. I think the OP is a great example of python's sort of \"anything is true until someone proves otherwise\" attitude. This is not how I'd approach the problem. I'd start by asking, what do I actually want to know? What's the actual problem? Then I'd research that. That's how I came up with the answer, at", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for l in l:\n       if len(l) == len(l[0]):\n          return l[0]\n       if len(l) == 1:\n          return l\n    return []\nThis should be faster.\n\nThank you! I have no idea how I missed that.\n\nIt's always fun to see how different people think. I immediately thought of a merge sort, but that would be an awful idea, because you'd end up with an unsorted list after each pass. I realized the best way to do it was probably with a heap sort, but I kept trying to use a binary search to break the list down into sublists, and I never got anything that worked very well.\n\nI was thinking of a merge sort as well, but it would be very slow indeed. I actually started out with a quick and dirty implementation of a heap sort, but I kept running into all these issues.\n\nHint: \n\nI wrote one in C# that actually uses a list comprehension and is really fast:\n\nAny chance", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def p(n):\n    \"\"\"Return the p-th prime element in a list\n    >>> p(5)\n    True\n    >>> p(3)\n    False\n    >>> p(9)\n    True\n    >>> p(123)\n    False\n    \"\"\"\n    return len(l)\n    if len(l) == 1:\n        p = l[0]\n    else:\n        p = 0\n    return p\nThis is a good demonstration of why one shouldn't use a literal in the name of a function, particularly if the name includes a constant.\n\nWhat would you suggest instead?</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\n    def uniq(l: list):\n    \"\"\"Return a sorted list of unique elements in a list\n    >>> uniq(['a', 'b', 'c', 'd'])\n    [c, d]\n    >>> uniq([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    [1, 3, 5, 8, 9]\n    >>> uniq([2, 3, 4, 5, 6, 7, 8, 9])\n    [2, 4, 9]\n    \"\"\"\n    return sorted(l.unique())\nThat's the same thing.\n\nYes, that's what I was thinking.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.sort(key=lambda x: x[0])\n\nIn case you aren't familiar with Python, \"sort\" returns a list. This is\nwhat you're trying to iterate over. You could return a tuple instead,\nor you could do some custom type wrapping to make it iterable. Or just\nreturn a list, which is what you have there now.\n\na slightly more correct version would be", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    l.sort()\n    for c in l:\n       if l[c]!= l[c]:\n          return c\n    return l\nThis is written like a Python programmer.  I've found that languages that have arrays as the first-class data type of the language tend to have more of this style of programming.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    unique_items = []\n    unique_items.append(l.duplicated()[0])\n    for item in l:\n        if unique(item):\n           unique_items.append(item)\n    return unique_items\nYes, but this would be O(n) where n is the length of the list, not the number of unique elements.\n\nJust take a look at the dictlib module in python. It's quite extensive.\n\nI've been using Python for a few years, and I've never needed to use a dictionary for any real project (they're useful for learning, though, because you can really see what they're good for). So, I'm pretty sure you're not a python programmer.\n\nYou don't have to be rude. I'm a programmer for over 20 years now. I've used python in projects ranging from startup apps, web apps, small business apps, and game engines.\n\nI'm not being rude, I'm pointing out that you're not a python programmer. I've been programming for over 20 years too.\nI've", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.sort()\nIt's also worth mentioning that if you're _only_ going to use Python 2.7+ you could go with sorted(l).unique()  which would be the equivalent to the function above. (In 2.7+'sort' returns an iterator, so you can use it as a function that returns values, not just a function that returns a value)\n\nAnother method for this is:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return [l[0] for l in sorted(l) if l[0] not in sorted(l)]\nSince you can trivially solve the original problem with a recursive Python loop, you'd be better off just doing that, rather than implementing this very clunky O(N^2) sort.\n\nYup, this is a good solution. The best solution, actually, since it also computes the unique number of elements in the list.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l), key=lambda l: l[1], reverse=True)\ni don't get it - what if there are duplicates?\n\nIt is sorting the unique elements, which happens to be the same as the sorted list of the rest of the elements.\n\nI'm not sure how I would want to use this to help me write code...\n\nThe only thing I could think of is that it helps you write code that will handle duplicates. If you know how to sort a list that doesn't contain duplicates, and you want to sort a list that does contain duplicates, then you can use this function to convert the list of duplicates to a sorted list of unique elements, then sort that.\n\nThe function is named as \"unique\" and the author is sorting for uniqueness. Yet, there are two occurrences of 5 and 0 in the example output.\n\nYes. In the case of duplicate elements, only the last one is considered unique.\n\nIs that the standard way of doing it?\n\nNo.\n\nThen how is it implemented? I've never heard of a duplicate-removing sort.\n\nIn most implementations, the first duplicate is removed", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def items(l: list):\n    \"\"\"Return sorted non-duplicate elements in a list\n    >>> items([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(l.items(), key=lambda x: x[0]!= x[1])\nI wonder if there's a reason not to use the builtin `sorted()` instead of `sorted(l.items(), key=lambda x: x[0]!= x[1]`)?\n\nThe OP is not using python 3.\n\nCan't you just import it? I think \"from __future__ import print_function\" will work, and \"from __future__ import sorted\" should work as well.\n\nI believe they are not available in Python 2.7.\n\nAh, yes. I forgot about the \"print\" and \"sorted\" functions in Python 2.\n\nI would love to see this with an explanation of how it works, not just the code.\n\nIf you want an", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    a = []\n    while len(l)!= 0:\n       if l[0] in a:\n           a.append(l[0])\n           l = l[1:]\n           else:\n            l = [l[0], l[1:] for l in l]\n    return a\nI'm not sure how this would be useful. You can already just list.sort() for this behavior, and this would be less efficient.\n\nYes, but this is list.sort() for people who don't know how to use list.sort().\n\nThis is still not as easy as it could be.\nFor example, I think it should work:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for el in l:\n        if el in unique(l):\n          return el\n        el = list(el)\n    return unique(el)\nThank you.  I should've specified that I wanted to avoid this, because of the possible exponential time complexity if the list is huge (I don't know python, but with a list of even 5000 elements it takes a while).  I edited the description to reflect this.\nJust add an upper bound to the list length to the function. That's one of the most useful things about writing functions in Python (if not the most useful).</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l))\n    def sort(list):\n    \"\"\"Sort a list based on the given comparator\n    >>> sorted(set(list(3, 2, 1)))\n    [3, 2, 1]\n    >>> sorted(set(list(2, 1, 3)))\n    [2, 1, 3]\n    >>> sorted(set(list(1, 3, 2)))\n    [1, 3, 2]\n    >>> sorted(set(list(1, 2, 3)))\n    [1, 2, 3]\n    >>> sorted(set(list(2, 1, 3)))\n    [2, 1, 3]\n    \"\"\"\n    return list.sort()\nThis code does not sort in descending order.\n\nThat's true. I added that in my comment.\n\nIf you want to know more about the sorting algorithm, here are a couple of resources (I used these in the past):\nhttp://www.agner.org/optimize/sorting.html", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\n    if len(l) == 1:\n        return l\n    else:\n        l = [x for x in l if x not in l[0]]\n        return sorted(set(l))\n\nThat should be  sorted(set(l))\n\n\"The only thing I know about functional programming is that it's a pain in the ass.\" \\-- John Carmack\n\nWhy is this a \"funny comment\"? I really don't get it.\n\nI interpreted it as a quote from a tech talk given by John Carmack.\n\nI think the point is that a comment like that, without any further explanation, seems to be a really strange thing for John Carmack to say. The thought of functional programming being a \"pain in the ass\" is not a very common one in the FP community. It'd be like if you heard about C++ being a \"pain in the ass\" from the C++ community.\n\nIt's a well known quote of Carmack's, from his GDC 2009 talk:\n\nEven if it was a well-known quote, it still", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return [i for i, x in enumerate(l)]", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    sorted = [l]\n    if sorted:\n       return sorted\n    elif len(sorted) == 0:\n       return []\n    else:\n       for item in sorted:\n          if item is not None:\n              if item[0] == l[0]:\n                  return item[1:]\n        else:\n                 return []\n    return sorted\nYes, it's more straightforward. What's the problem with it?\n\nFor one, it's not a little piece of code. It's a lot of code.\nSecondly, it doesn't do any kind of error checking - if it can't\nfind anything it'll just return the empty list. This is a problem\nbecause it might have found things and then decided to just randomly\ndrop them.\nThis solution has none of those", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l\n    else:\n       return sorted(l, key=lambda s: s[0], reverse=True)\n\nI prefer the following, which is also much more readable.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    \"\"\"\n       def uniq(l):\n        \"\"\"Return a list of the unique elements in l\n        >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n        [[0, 2],\n                          [3, 5],\n                             [5, 9],\n                              [2, 3],\n                               [3, 9],\n                                [0, 123]]", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n         return sorted(list(l), key=lambda a, b: a[b] == b)\nVery useful, thank you.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n        return [l]\n    else:\n         for item in l:\n            if item not in sorted(l):\n                    return sorted(l[item])\n    return sorted(l)\nThat's not really unique. Unique means there is only one item with that index.\nI would use count to get the number of unique items.\nfor item in l:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.__contains__(u))\nThis is the cleanest way of doing it, I think.\nThe only problem is that Python's sorting function is not stable; it could change in the future.\nIt's not like this is some new, bleeding edge feature, though; Python has had sorted for a long time now.  If there was ever going to be a problem, it would have been found already.\nI didn't say it was going to happen, just that it could.  Stable is important in some applications (like scientific computing), so it's a valid consideration.\nHow is the order of a list changed by Python's sort function?</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    \"\"\"Implement the non-comparison-based sorting algorithm, which\n    returns the unique elements in a list sorted by ascending\n    index.\n    \"\"\"\n    k, v: integer,\n    result: list,\n    s: list,\n\n    \"\"\"Find the kth smallest element in the list.\n    >>> k = s.index(3)\n    >>> v = s.index(k)\n    >>> result = s.pop(v)\n    >>> k, v, result\n    [3, 2, 1], [3, 2, 1], [1, 3, 2], [1, 3, 2]\n    \"\"\"\n    if k == v:\n         break\n\n    if k > v and k < len(s):\n         result.append(k)\n\n    if len(s) == 1:\n         result.append(s[0])\n    else:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for l in list:\n        if l not in self:\n           return l\n           return sorted(unique(l))\nIs the latter a more efficient way of solving the problem, or is there an issue with this approach?\nEdit: I am not too familiar with Python. This is a problem in a textbook I'm reading.\nYou should be able to look at the list's __str__ function to find out how to create a sorted version.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for i in range(len(l)):\n        l[i] = l[i]\n    return list(unique(l))\nI guess the copy might be necessary, but I would expect the interpreter to generate code like the following:\nfor i in range(len(l)):\n        l[i] = l[i]\n        return l\n\nIt will if the compiler is smart enough to notice that l is a list, not a tuple. Python's implementation is not.\n\nThis seems like a good example of how its a good idea to use a language that has such optimizations. I wonder if there are other, less obvious examples like this that could be caught?\n\nI'm not sure that this is an example of how that's a good idea.\nThe only reason that this works in C++ is because it's a C++ list, and not a Python list, and the C++ compiler doesn't automatically assume that a list is a C++ array.\n\nYes, I'm not saying this is a good idea for python, just that it illustrates that fact.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\n         return sorted(l.items(), key=lambda x: x[-1] or x[0])\n\nEDIT: Changed to an external function instead of a class method.\n\nThanks a lot!\n\nJust a hint: if you want to reply to a comment, click the \"reply\" link under the comment.\nOtherwise the person you're replying to won't get an email notification that you replied to him.\n\nI always forget that and always wonder why people don't reply to me :)\n\nMy comment about the reply link wasn't meant to be critical, I just wanted to make sure you got the reply you wanted.\n\nI thought your reply was more than appropriate, not sure why anyone would have taken it as criticism.\n\nThere are a lot of good solutions in here, but what I use is:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\n    sorted(l, key=lambda x: x[1]), unique(l)\n    \"\"\"\n    def sorted(l: list):\n       \"\"\"Return the sorted list\n    >>> sorted([0, 3, 5, 2, 0, 1, 4, 2, 0, 0, 1, 1])\n       [0, 3, 5, 4, 2, 1]\n    \"\"\"\n\n    return l[0]\n    if not len(l) == 1:\n       return []\n    return sorted(l[1:])\n    \"\"\"\n    def unique(l: list):\n       \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n       [0, 2, 3, 5, 9, 123]\n    \"\"\"\n\n    sort(l, key=lambda x: x[1]), unique(l)\n\nWhich is only _", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.__setitem__(0), l.__setitem__(1))\nYou should probably give it a default case too.\n\nInteresting. I never realized that the sorted method had a default case that did nothing.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if l.size() == 1:\n        return l[0]\n    return l.sort()\nIs it just me or is there something fundamentally wrong with this function?\n\nCan you point out what's wrong with the code? It returns the last element of the list (if the list is empty), or a singleton if the list is not empty.\n\nthe code is fine. the article is not.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda a, b: isinstance(a, int) and not isinstance(b, int))\nI have just googled \"python code unique\" and this was the first result.\nIf you've never used Python before, what would make you think this code is correct? Or even looks right?\nThe sort call is the correct algorithm to use, but the comment is completely out of place.\nThe only \"correct\" algorithm is the one that is most appropriate for the task.\nYes, that's what I was trying to say. There is no single algorithm that is correct for all tasks. That's why I find the comment out of place.\nA more general comment would be better, of course, but a comment explaining what sorting is would be more appropriate than a comment that explains what the function does.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    l.sort()\n    return l.unique()", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    unique = sorted(unique(l))\n    return unique\nor:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda l: l.index(item))\n>>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[0, 2, 3, 5, 9, 123]\n\nAh yes, I knew there was some way to do that (though I was thinking of something that'd work for lists of dicts). Thanks for that.\n\nThis is called Quick Sort, and the author probably did it without realizing it.\n\nIt is actually a simple selection sort.\n\nQuick Sort and Selection Sort are the same thing.\n\nQuick sort is a variation of selection sort in which the selection is chosen by comparing the items to a pivot value.\n\nThis algorithm is called \"selection sort\".\n\nIt's selection sort with a selection that is chosen based on item value.\n\nSo, Quick Sort?\n\nYep.\n\nIt's in the FAQ:\n_How does this compare to the original QuickSort algorithm?_\n_The original QuickSort algorithm used a selection sort, which works by\nkeeping the smallest element in a separate \"pivot\" list and moving all\nremaining items to the left until", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    sorted = sorted(l)\n    if len(sorted) == 0:\n        return [None]\n    return sorted\nI think this is one of those weird situations where Python's built-in `unique()` function isn't being used the way it's intended.\nThe list sort is very weird too. Why not use a stack?\n\nI haven't coded in Python in a couple of years, but isn't `unique()` already implemented as a list? What's wrong with the built-in code, and what's wrong with the code that's there now?\n\nunique() is implemented as a built in function.\n>>> unique()\n[1, 2, 3]\nIt's not about the implementation though, it's about the fact that the built in function is being used incorrectly.\n\nAh, ok. I don't see any misuse, but I'll take your word for it that something is wrong.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    sorted = sorted(l.sort())\n    elements = sorted(l, key=lambda x: x[1])\n    return sorted(elements, key=lambda x: x[0])\n\nThe algorithm is simple, yet very efficient. Here is a small program to benchmark the sorting performance of uniq vs several other sorting algorithms.\n\nimport timeit", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted(l: list):\n    \"\"\"Return a sorted list\n    >>> sorted([4, 3, 2, 1])\n    [0, 1, 2, 3]\n    >>> sorted([1, 2, 3])\n    [1, 2, 3]\n    >>> sorted([5, 4, 3])\n    [5, 4, 3]\n    >>> sorted([4, 2, 1, 5])\n    [4, 2, 1, 5]\n    \"\"\"\n    def sorted_unique(l: list):\n    \"\"\"Return a sorted list of unique elements in a list\n    >>> sorted_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    def unique_in_list(e: element, l: list):\n    \"\"\"Return true if element is in list\n    >>> unique_in_list(0, [5, 3, 5", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for i in range(1, len(l) - 1):\n         if l[i]!= l[i + 1]:\n              # unique element\n               return l[i]\n    return l\nIs it just me or this function does not guarantee to return all unique elements?\n\nThe use of the negative index list is a little weird. If you're using the index as a function, there's no need to use the negative index.\n\nThat's because unique() operates on a range, not a list.\n\nI think this is a poor design for a function that's intended to work on a range. If you want a range and it has a finite upper bound, then you should be forced to use a negative index.\nI've seen far too many functions and methods that take a range and return a list (or other kind of sequence). It's a subtle bug that you only notice when you start doing numerical stuff with those values.\n\nI think you're wrong.\n\nHow can you tell?\n\nThis", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    sorted_unique_l = list(set([l[0]]))\n    unique_l = set(sorted_unique_l)\n\nAnd all the other ways are in the article you linked to.\n\nOr better yet:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n      return sorted(l.items(), key=lambda item: item.id())\n\nI'm not sure that I understand the point of this, since most programming languages have a way to do this in-language.\n\nPython's in-language implementation of a sorted unique list is exactly this:\nsorted(x.items(), key=lambda item: item.id())\nThe only difference is that it uses a lambda function, rather than a built-in function. This saves one function call and a little typing. I don't know what else you'd want from a built-in unique list implementation.\n\nI don't see how that's the same as the C++ implementation; in fact it looks like the built-in one:\nunique(list.items(), key=lambda i: i.id())\nexcept that Python's is more readable and more Pythonic.\n\nSorry, I missed that he was comparing C++ and Python. That's quite a bit more C++ than I'm comfortable with, and I'm not sure how to tell if a C++ implementation is more or less \"Pythonic\".\n\nI think that in this case the Python way is more pythonic than the", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n         # sort\n        return (\n              l.sort()\n             .key()\n             .unique()\n             .sort()\n            )\nNote that you should change it to accept the other sorting method as well (OrderedDict.items() is the method used internally by OrderedDict to get its elements, and OrderedDict doesn't provide its own sorting function, so you should use the method from the built-in sorted() function).\n\nThank you very much for the feedback!</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique(['a', 'b', 'c', 'd']).sort()\n    [0, 1, 2, 3, 4, 5]\n    >>> unique(['a', 'b', 'c', 'd', 'e']).sort()\n    [0, 1, 2, 3, 5, 6]\n    \"\"\"\n    for l in l:\n        # Remove duplicates in the list\n        unique(l.drop(0))\n    return list(unique(l))", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def uniq(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9]\n    \"\"\"\n    return sorted(l.keys(), reverse=True)[0]\nThe implementation of the first function is clearly much more efficient.\n(It's basically just counting the number of distinct items, and then sorting them.)\nThe implementation of the second function is just sort() and slice(), which are not cache-friendly in this case.\n\nUnless I'm missing something (possible, I'm not an expert on sorting algorithms), this implementation will also give you a list of (duplicated) elements.\n\nThe sorted() call _is_ an algorithm. It's a simple mergesort.\n\nI wouldn't say that \"sorted\" is an algorithm. It's a function that does something (sorts a list).\n\nBut in the case of Python, the function itself is an algorithm. It's a built-in, not some function you have to import", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\n    return list(unique(l))\n\nThe next line is probably the hardest to understand for someone who has never encountered functional programming:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted(l: list):\n    \"\"\"Sort list with respect to <\n    >>> sorted([1, 2, 3, 4, 5])\n    [5, 4, 3, 2, 1]\n    \"\"\"\n    def unique_with_replacement(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique_with_replacement([1, 2, 3, 4, 5])\n    [2, 3, 4, 5]\n    \"\"\"\n    for item in l:\n        if item in sorted(l):\n           return sorted(l)\n    else:\n            return sorted(l, item)\n\nUnfortunately the OP is asking for a function that returns a list of the first n unique items, which neither of these functions do.\n\nThanks!\n\nI'm not sure if you're using Python 2.7, but if you are you can just use:\nimport itertools\nlist =", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if l is None:\n        return []\n    else:\n        return list(l.pop)\nWhat's the purpose of `l.pop`? The function already returns a list, so you're not providing a more efficient implementation, and you're only saving one line.  And if you were to provide a more efficient implementation, you'd be changing the semantics, which might not be what you intended.\nThanks for the feedback. I am new to programming and am learning the different syntax and syntaxes. This code was taken from the first Google result for \"python unique list\". I will look into what you have said.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    sorted_unique = sorted(l)\n    unique = sorted(unique)\n\nThat's not going to be correct in all cases. For example, if I had a list of integers that wasn't sorted, and you sorted it, then tried to sort the results, it would be correct in the sense that you'd get the same results, but the output would be wrong.\n\nWhy are you running a Python script on a CSV file? Why not just use the native python CSV module?\n\nI'm not sure how relevant it is, but the line:\nimport csv\nsays that the script was written in Python 2.4, which supports csv, but not csv.reader.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def is_valid(l):\n        if len(l) == 1:\n           return True\n        elif len(l) == 2:\n           return False\n        else:\n           return True\n    return [l[0]]\nI've never been a fan of \"is_valid\" functions. I prefer to make a second function with the same name as the first, and then use the syntax:       unique(l)\nI find it a bit more clear what's going on.\n\nI've never been a fan of \"is_valid\" functions. I prefer to make a second function with the same name as the first, and then use the syntax:       unique(l)\nI find it a bit more clear what's going on.\nI prefer not to mess around with the names of built-in functions, since in some cases the name may be a concise explanation of what the function does.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    from collections import defaultdict\n    def sort_unique(l: list):\n    \"\"\"Sort a list, returning unique elements\n    >>> sort_unique(['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s', 't', 'u', 'v', 'w'])\n    [p, t, u, v, w]\n    \"\"\"\n    if len(l) < len(l[0]):\n        l = [l[0], l[1:] + [l[0]][:] + [l[0]][:] +...]\n        return sort_unique(l)\n    return defaultdict(list)\n\nThis is a great example of how non-trivial code is easily understood by anybody who has been programming for more than a few weeks.\nThis is a great example of how some people will find", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return [l[l.count()] for l in l]\nThe author shows the contents of the sorted list as well as the sorted list.\nI think that's what's confusing people.\nYes, it was exactly that.  I realized it after looking at it for a little longer.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\n    def __getitem__(self, index):\n    \"\"\"Return the unique element at an index\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])[3]\n    5\n    \"\"\"\n    if index < len(l):\n       return 0\n    else:\n       return (l[index].unique() < l[index+1])\n\nIn Python 3, the builtin function unique() is preferred to this, so you should either use a different name for your function, or change it to return a list.\n\nRight, I should have used unique() instead of the original version.\nThe returned list is not necessary, but I don't think it's bad practice.\n\nIf it's not necessary, then you are adding overhead to your function (which is in general a bad thing).\n\nAlso note that calling a function on a list (or any collection) will still require O(n) time to execute, unlike a builtin function.\n\nI'd like to see a comparison of various sorting methods using a", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\n    def sort_unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> sort_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [2, 3, 5, 9, 123]\n    \"\"\"\n\n    def uniq(l: list):\n    \"\"\"Return unique elements in a list\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [2, 3, 5, 9, 123]\n    \"\"\"\n\n    def uniq_reverse(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> uniq_reverse([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [3, 2, 5, 9, 123]\n    \"\"\"\n\n    def dups(l: list):\n    \"\"\"Return duplicate elements in a list\n    >>> dups([5, 3, 5, 2, 3,", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\n    return sorted(l.reverse(), key=lambda item: item[0])\n\nI don't know about all other languages, but in Python that would not be a legal return value for `unique()`.\n\nIt's Python 2.7\n\nPython 2.7 does not support unicode keys in `sorted`.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def invert(m, e, s):\n    \"\"\"\n    Return e, but in reverse.\n    >>> invert(5, -2, 2)\n    -2, 2, 5\n    \"\"\"\n    return m[s[1], s[2], s[3]]\n    def revolve(l):\n    \"\"\"\n    Return sorted elements in a list in a particular order.\n    >>> revolve([1, 4, 2, 3, 6, 1])\n    [4, 2, 3, 1, 6]\n    \"\"\"\n    return sorted(l.reverse(), key=lambda x: invert(x, e, s))\n\n[This is a selection of the e-mails that I have sent recently to the\nhackers@python.org mailing list, which you can join by sending an email to\nmailto:hackers-subscribe@python.org. I often get interesting responses that\nI post to the list. But, if you'd rather not receive these e-mails, let me\nknow", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    else:\n       return l[1:]\nI'd almost call that pretty code. It's certainly short. The only thing I'd note is that it's probably a bad idea to define a function with exactly one case.\n\nIt's worth noting that the recursive solution that was suggested isn't as efficient as the linear solution.\nIn fact, the recursive solution will be O(n^2) while the linear solution will be O(n).\n\nThe recursive solution is O(n) in the number of elements to sort. It doesn't sort every element, just the top level of recursion.\n\nAh, you're right. I've used python for so long that I've forgotten how to do a recursive solution properly.\n\nNow we just need to wait for someone to come up with the optimized algorithm.\n\nDoesn't python do tail recursion? Why wouldn't the recursive algorithm be the most efficient?\n\nBecause python is a dynamic language, it probably doesn't even have to generate code for the recursive call, which makes it even faster.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if l is not None:\n        l.sort()\n        return l[0]\n\nWell, it's not really a one-liner, but it's pretty much the same thing.\n\nI think it's a one-liner:\nimport uniq\n>>> uniq([\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\"], key=lambda x: x[0])\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nTrue.\n\nAha, I found a better one-liner.\n>>> uniq([]).sort()\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n\nOne problem with your method is that it will _never_ return a list of unique items.\n\nWell, it is sort of like comparing a number to 0.\n\nFor a one liner using Python 3.0:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def __new__(cls):\n    \"\"\"Constructor for a sorted unique list.\n    >>> unique(list(1, 2, 3, 4, 5))\n    [0, 1, 3, 5]\n    \"\"\"\n    def __cmp__(self, other):\n    \"\"\"Compare two sorted unique lists.\n    >>> unique([1, 2, 3, 4]) == unique([1, 2, 3])\n    True\n    >>> unique([1, 2, 3]) == unique([2, 1, 3])\n    False\n    >>> unique([1, 2, 3])!= unique([1])\n    False\n    \"\"\"\n    if other is None:\n       return False\n    elements = []\n    for e in other:\n       if not (e is None and e[-1] in self):\n         elements.append(e[:-1])\n    return elements\n\nThis is a very", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    unique_list = sorted(l.items(), key=lambda item: item[1].id)\n    return unique_list\n    def unsorted_list(l: list):\n    \"\"\"Return unsorted list with duplicates removed\n    >>> unsorted_list(['one', 'two', 'three', 'four', 'five','six','seven'])\n    ['one', 'two', 'three', 'four', 'five','six','seven']\n    \"\"\"\n    unsorted_list = sorted(l.items(), reverse=True)\n    return unsorted_list\n\nMight want to normalize the output to be a list.\n\nYou can just return list(unique(l)) instead of list(unique(l[1]), unique(l[2]),...)\n\nAh yes. I didn't think about that. Thanks.\n\nThat's a really helpful function, thanks! I have two uses for it:\n1) I have a ton of lists of URLs, and I want to remove all duplicates except the first one. So I can just", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def uniq(l):\n    \"\"\"Returns a list of unique elements in a list\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(unique(l))\nThis is a lot simpler than your version:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0]!= x[1])\n\nI'm not sure I get the benefit of this over built in sorted.\n\nMy understanding is that for most lists, it'll be an order of magnitude faster. The built-in sort is implemented using an algorithm that is good when the elements are in a balanced order and roughly equal. This algorithm is not nearly as good when the elements are not in a balanced order and not roughly equal.\n\nI've never heard of a list with 1-indexed elements that are roughly equal (or \"not exactly equal\" as you put it). Do you have an example of a list where you might be better off using this algorithm over sorting?\n\nMaybe I'm missing something obvious, but why do you need a custom sort function?\nIn Python, sorted() is a built-in function that can do that for you.\n\nIt's a recursive solution. The built in sort doesn't have any recursion.\n\nI see. That makes sense. Thanks!\n\nIt's a \"recursive\" solution in the sense that it uses a separate function to implement the recursion.\n\nI think that this is", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return set(l.sort(key=lambda l: l.__lt__(l)))", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    l = sorted(l)\n    for element in l:\n        if element in sorted(l):\n           return sorted(l, reverse=True)\n    return sorted(l, reverse=True)\n\nOr, you could do this:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\n    def sorted_unique(l):\n    \"\"\"Return sorted unique elements in a list\n    >>> sorted_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [9, 0, 2, 5, 3, 3, 5, 9, 123]\n    \"\"\"", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    a = []\n    for l in l:\n       if len(l) == 1:\n          return l\n       for k, v in enumerate(l):\n          if v not in a:\n             a.append(k)\n    return a\nThat doesn't sort, it just returns the first unique element of the list.\nThe way it's implemented, the result is sorted.\nIt isn't.  Sorting is based on comparing the elements of the list, and this function doesn't do that.  It only compares if the list is empty.\nIt is sort of sorted. It always returns the first element of the list that isn't in the list, sorted by that property.\nNo, it doesn't.  It returns the first element that isn't in the list, sorted by the number of elements in the list.  It's an inelegant implementation, and doesn't sort.\nHence the sort of sorted.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.sort(), key=l.get(0), reverse=False)\nThat looks like a bad idea.  If you have a list of millions of elements, you're going to start computing the sorted version of that list as it's being built.  I'm not even sure what your sorting algorithm is, but I'm pretty sure it's going to be significantly more expensive than just using a list comprehension.  The inefficiency of this is going to be your bottleneck.\nNah, this is fine, see my answer below.\nYou are right, I was assuming the sort was slower than list comprehensions, and that is not the case.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def get_unique(l):\n    \"\"\"Return sorted unique elements in a list\n    >>> get_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    if l.count(1)!= 2:\n       return l.pop(1)\n    result = []\n    for i, item in enumerate(l):\n       if item not in result:\n          result.append(item)\n    return result\n    if __name__ == \"__main__\":\n       unique = get_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n       print unique\n       print \"element 0\"\n       print unique[0]\n       print \"element 1\"\n       print unique[", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1])\nYou might want to use a quick sort here.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.sort()\nyou can also do this in a single line:\nlist.sort(unique)\n\nThe resulting code will be more concise and the logic is more obvious if the first parameter is optional. The only downside is that it is slightly more verbose to write if you want to specify the default value.\n\ntrue, but i'm not a python guru, but i've worked with it for a while and i thought it was a pretty concise snippet...\n\nThe OP is not wrong: \n\nI would consider a language to be \"highly flawed\" if it didn't have a means to order a list.\n\nI'd consider it to be flawed if it didn't have a builtin function to sort lists.\n\nYou mean like Python?\n\nNo, Python has the built-in function sorted()\n\nMy mistake, I was confusing sorted() with sort().\n\nI'm surprised that Python doesn't have a built-in sort() function. I suppose the whole point of Python is that you don't need to waste time worrying about whether your data is sorted, because it always is, as long as it's in Python.\n\nWhy is this a surprise? You can", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    l.sort()\n    return l.pop(0)\nWhere are the 2,3,5,9 in the sorted list?\n\nIn the unsorted list, of course. The algorithm assumes that the list to sort has been sorted already.\n\nBut the original post says:\n\"The algorithm is simple. The initial list is sorted\"\nSo in that case, the unsorted list isn't the one being sorted.\n\nPerhaps the author meant that the list was sorted and then passed as the input to the function.\n\nI see, it's the initial sorted list that is passed to the function. Makes sense.\n\nThe code in this post is broken. It does not return a sorted list of unique items. It returns a sorted list of all the elements in the list, plus all of the unique elements. For example, if you passed in [1, 2, 3, 4, 5, 6, 7, 8], you would get [1, 2, 3, 4, 5, 6, 7, 8, 9], even though the list only had 10 elements.\nAlso, if you tried to make the list unique, you would not be able to do so because", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1])\nThat's not unique, that's unsorted.  I'm not saying it's a good idea to use sorted here, but it is sorted.\nyou're right. i meant to write unsorted</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for i in range(len(l)):\n        if l[i] == l[i+1]:\n           return [i]\n    return [None]", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def is_unique(l):\n    return unique(l)\n    if l is list(range(10))) or l is list(range(100)) or l is list(range(1, 100000)) or l is list(range(1000000, 10)) or l is list(range(10, 1000000)) or l is list(range(1000000, 1000000)):\n        return True\n    else:\n        return False\n    def unique_at(l: list, n: int):\n    \"\"\"Return the unique elements in a list, starting at the given index\n    >>> unique_at(['a', 'b', 'c', 'd', 'e', 'f', 'g'], 10)\n    [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]\n    \"\"\"\n    def unique_in(l: list, i: int):\n    \"\"\"Return the unique elements in a list, starting at the given index\n    >>>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n         return sorted(list(unique(list(item))) for item in l)", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.reverse()\n\nNot a bad example, but it's certainly not idiomatic Python.\n\nThat's just a dictionary.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) < 1:\n        raise TypeError(\"list must be non-empty\")\n    else:\n        return sorted(l.pop(0), key=lambda x: x[0])\n        return l\n\nbeautiful. thanks.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted(l: list):\n    \"\"\"Return a sorted list of unique elements in a list\n    >>> sorted(unique([5, 3, 5, 2, 3, 3, 9, 0, 123]))[0, 2, 3, 5, 9, 123]\n    \"\"\"\n    sorted(unique(l))\n    \"\"\"\n    return sorted(unique(l))\nThis is great.  It's a simple, elegant solution.  It's not often that I see a solution that looks like this, but if it fits the problem, it's almost always the correct choice.\n\nI don't understand why people find this so surprising. This is actually one of the first solutions to come to my mind.\n\nBecause it's not very readable. There are a lot of one liners that are easy to get confused, especially when you're just starting out.\n\nI don't see how this is confusing: it is extremely easy to read and understand, it uses a standard Python function, and it is obviously designed to be understood.\n\nWe agree on that it's easy to read and understand. We disagree on whether it's", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda v: v.count(), reverse=True)\n\nOne thing to watch for is that the standard library only has sorted built in for immutable lists.\nSorted(l, key=lambda v: v.count()) is not the same as sorted(l, key=lambda v: v) so beware.\n\nI would prefer sorted(l, key=lambda v: v[0]) for this purpose.\n\nIt's pretty neat, but I think it would be better to write a few unit tests (if it was me).\n\nWhy? I'm curious.\n\nIt's good practice, it helps catch bugs early, and it encourages you to keep your code modular and testable.\n\nIt is not the first time i've seen this example, but i don't get it. The author tests the python function with a list of integers and says \"doesn't work\". What does he expect? The function does exactly what it is supposed to do.\n\nYou're right. The author doesn't fully understand what the function does. He might have meant \"doesn't work for my purposes\".\n\nTrue.\n\nThe article has a link to this", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.sort()\nNote that this is not the most efficient way to sort a list. Also, unique() returns a list of unique elements. A more efficient way to return all elements in a list in sorted order is sorted().</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return [None]\n    elif len(l) == 1:\n        return l[0]\n    else:\n        return l[l.index(i) for i in range(len(l) - 1)]\n\n\"top\" is the top element of the list. \"len\" is the length of the list.\nIt's just that Python doesn't have a built-in function to do this, so you\nhave to make it yourself.\n\nThis is a typical example of the fact that Python is not \"all objects are\nprimitives\" and \"don't do metaprogramming\" because \"it's dangerous\".\n\nIt's not dangerous at all, just a bit involved. If you can't figure it\nout after reading the explanation, you're going to have trouble with\nPython.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.sort(key=lambda x: x[0])\nYou forgot the standard warning about performance.\n\nIs this really a good solution? I've never used Python before, but I have written many thousands of lines of Matlab.\nI'm having trouble figuring out how this would work. Wouldn't you need some kind of list indexing (e.g. [5, 3, 5, 2, 3, 3, 9, 0, 123]) to determine the index of the first element?\n\nA list is more like a vector, where the elements are not ordered. In other words, you can iterate over a list like a vector.\nFor example:\nfor x in list:\nx[0] = x[1] = x[2] = x[3] =...\nPython even has a built-in function called index that will return an index if there is one, or an item if there is none.\n\nAh, I see. So it's just as if you were iterating over a 3-dimensional array in Matlab.\n\nYes. And when you have a list, you can do things like:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    unique = lambda x: x.lower().lower().lower()\n    unique = lambda x: x.lower().upper().lower()\n\nI'm curious about the reasoning behind having a function that returns a class. I mean, I can see the reason of having a class that contains two functions, but why not just a function that returns a list?\n\nPython is dynamically typed. You have no way of knowing at compile time whether the result of a function call will be a class or a function or anything else.\n\nI see, thanks for the explanation.\n\nI've taken this approach in the past and it's super useful, but some folks want to be able to add and remove values to the list without altering the result.\n\nIs that the \"minor surgery\" he's talking about?\n\nYes, this is how I read it, too. It's not clear from the article, but I think the author is also using it as a convenient name for the \"minor surgery\" that he's describing.\n\nI'm going to make a video soon to better show what this does and why it's useful.\n\nThis should be titled \"How to write a function with a", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted_unique(l):\n    \"\"\"Sort unique elements in a list\n    >>> sorted_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    sorted = sorted(l, key=lambda x: x)\n    return sorted\n    \"\"\"\nThe sorted method does not sort on l.  It sorts on the key of the element to be returned.\n\nThat's because you're calling it like this:\n>>> sorted_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[0, 2, 3, 5, 9, 123]\nYou're not passing it the list, you're passing it the key.\n\nPython has a tendency to pass by reference by default and mutable references by default. The way you called it is definitely not the norm.\n\nI'm not sure that's a good default behavior. It makes a lot of \"magic\" happen under the hood, which is not too hard to detect but still a bit of", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted(l):\n    \"\"\"Return sorted list\n    >>> sorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    def uniq(l):\n    \"\"\"Return sorted list of unique elements in a list\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [5, 3, 5]\n    \"\"\"\n    return sorted(l.sort(), key=lambda item: item[1])\n\nThis is the most interesting one IMO:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    \"\"\"\n    def __init__(self, target):\n    \"\"\"Constructor for unique()\n    >>> unique(range(5))\n    >>> unique([3, 1, 4, 5])\n    \"\"\"\n    for a in range(self.target):\n       self.target = a\n    return [a]\nThat's not really the point of this exercise.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if l.count(None) == 0:\n        return l\n    elif l.count(None) > 1:\n        return sorted(l, key=lambda x: x[0])\n    else:\n        return sorted(l, key=lambda x: x[1])\n\nIt is not in the standard library but it is in many programming language libraries.\nI find it weird how people use it as some kind of \"gotcha\". Like saying \"Python is not Turing-complete because it doesn't have it.\".\nIt's just a convenience method. It does not need to be there.\nI guess the same can be said about the built-in for loop, because it doesn't have to be there.\n\nThe for loop is a core language construct. It needs to be there. For loops are implemented in the runtime.\nUnique() is a convenience method. There are a number of ways you could implement it. The built-in one is not the only way to do it.\n\nI actually always hated it, because it allows for creating code that doesn", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n       return None\n    if l[0] == l[-1]:\n       return list(l[1:])\n    return sorted(l[:-1], key=lambdax: l[x])\n\nYeah, I found that a while ago. I just wanted to share my solution.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l):\n        return sorted(l.items())\n    elif len(l):\n        return sorted(set(l))\n    elif len(l) == 0:\n        return []\n    else:\n        return sorted(l.index(l.size()))\n> def unique(l: list):\n>    \"\"\"Return sorted unique elements in a list\n>    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n>    [0, 2, 3, 5, 9, 123]\n>    \"\"\"\n>    if len(l):\n>        return sorted(l.items())\n>    elif len(l):\n>        return sorted(set(l))\n>    elif len(l) == 0:\n>        return []\n>    else:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.sort()\nThis is a common idiom in Python: Instead of sorting the whole list, use a sorting method that only requires the first element. This is much faster than a general sort.\n\nIs this more than just an implementation detail?\nI'm new to python, but it seems to me that this is the same as \"if the function takes one argument and returns a sorted list, the arguments don't matter as long as the function is called with the correct argument.\"\n\nYes, that's what I meant.\n\nI'm not really a python expert, but this seems to be a pretty common idiom in python.\n\nI didn't know about it, and it's a pretty nice idiom.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    from collections import defaultdict\n    def unique_combine(sorted_list, start, end):\n        defaultdict = defaultdict(int)\n        return defaultdict(int)\n    return unique(sorted_list, start, end)\n  The reason we use a defaultdict here is because we don't know how many elements we're going to have in our sorted list.\n  In the case of the linked article, the sorting algorithm was deliberately broken so that it would not always sort the numbers, so we can't use a sorted list (and we don't know how many elements there will be in the list).\nSo what would you use instead of a defaultdict if you need to retain the order of the elements?\n\nWe use a defaultdict because the defaultdict is built on top of a hash table, so the order of the elements is retained. It's just the usual dict, but with an _insert_ method that takes a comparison function.\n\nBut the defaultdict is not ordered. It's a list of key-value tuples.\n\nIt's not ordered, but it's still", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    l = [x for x in l if not x in sorted(l)]\n    sorted(l)\n    return [x for x in l if x not in sorted(l) or x in l[0]]\nI'm not sure it's worth the trouble to use the list comprehension here, since a simple for loop would be much shorter.\nThe list comprehension is arguably clearer.\nBut this is python, so clear code is not a concern.\nYeah, let's just leave it as a shitty language, because it's not like there are people who actually like it or anything.\nI'm not sure you and I are using the same language.\nI've never heard of a language that lets you write code like Python.\nI'm not sure you understand the point of Python.\nI'm not sure you understand the point of code readability.\nI'm not sure you understand the point of Python.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for item in l:\n       if item not in sorted(l):\n          return sorted(l[item], reverse=True)\n       elif item == key:\n          return sorted(l[item:], reverse=True)\n\nSee also:\n\nIt's actually an interface, so it has to be implemented by all the container classes.\nI believe the OP is actually asking about a lot of the other methods that are present, not the sorted() one, though.\n\nI did not know this, thanks for the info.\n\nI think the built-in itertools.tee() does this. It's not exactly the same, but it might be a good starting point.\n\nI think the best way is to use collections.Counter, and create a custom iterator that contains the unique elements.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.index, key=lambda x: x[1])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    unique = sorted(l, key=lambda x: x[1] < x[0] for x in l)\n    return unique\n\n>>> sorted(l, key=lambda x: x[1] < x[0] for x in l)\n    [(0,2,3,5,9,123), (2,3,5,9,123)]\n\n>>> unique(sorted(l, key=lambda x: x[1] < x[0] for x in l))\n    [(0,2,3,5,9,123), (2,3,5,9,123)]\n\n>>> unique(l)\n    [(2,3,5,9,123)]\n\n>>> sorted(l, key=lambda x: x[1] < x[0] for x in l)\n    [(0,2,3,5,9,123), (2,3,5,9,123)]\n\n>>> unique(sorted(l, key=lambda x: x[1] < x[0] for x in l))\n    [(", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) > 1:\n        return [l[0] for l[0] in l]\nI don't know Python so this may be nonsense, but how can len(l) > 1?\n\n\"len\" returns the number of elements in the list. If the list is empty, it will return 0. In this case, len(l) will be 1 because it contains a single element, and therefore the function returns an empty list.\n\nI assume this is how it works in Python. However, in Java you'd use this:\nunique(l) {", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if l.has_key(0):\n        return sorted(l.items(), key=lambda x: x[0])\n    else:\n        return sorted(l.items(), key=lambda x: x[0])\n\nI don't get it.\n\nIt's a trick: The item 0 is unique, so the function will return the rest of the list sorted.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    l.sort()\n    return sorted(l, key=lambda item: item[0] + item[1])\n\nFrom the documentation of itertools.sorted:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    unique = lambda l: [i for i in l if i not in l]\n    unique(l)\n    def least(l: list):\n    \"\"\"Return lowest element in a list.\n    >>> least([9, 3, 2, 5, 3, 0, 5, 9])\n    3 \"\"\"\n    lowest = lambda l: [i for i in l if i not in l]\n    least(l)\nI don't really see the point of this example. It's easy to write a function to list the unique elements in a list, and just as easy to write a function to return the lowest value in a list. What is supposed to be so surprising here?\n\nWhat's surprising is that they look the same and accomplish the same thing, but are written differently.\n\nBut they don't accomplish the same thing.\nunique() returns an immutable list of all unique elements.\nleast() returns a single element.\nIt's like the difference between a vector of all the zeros, and a single zero.\n\nI think you missed the point. In the python version, the first argument is", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l))[-1]\nTo be more pedantic, you should probably consider this a bug in the library it's implemented in.\n\nAs far as I know, it's a bug in Python 3, not the library. The implementation in the library is correct.\n\nThe implementation in the library _is_ correct, but not for the same reason. The implementation in the library is correct because it explicitly ignores the fact that Python 3 uses `-1` as a parameter for `sort`.\n\nSorry, I was unclear in my comment. I was saying that the library's implementation is correct _because_ it ignores that Python 3 uses `-1` as a parameter for `sort`.\n\nIt is also correct because the library was written in Python 3 and not in Python 2.\n\nMaybe I missed it but I'm not seeing the bug. The fact that Python 3 uses `-1` for the last parameter of `sort` is an implementation detail of the library in question.\n\nThere is a line of code that starts:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return list.sort()\n    def length_of_unique(l: list):\n    \"\"\"Return number of unique elements in a list\n    >>> length_of_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    5\n    \"\"\"\n    return len(l)\n    def is_same(l1, l2: list):\n    \"\"\"Return True if l1 and l2 have the same elements.\n    >>> is_same([5, 3, 5, 2, 3, 3, 9, 0, 123], [5, 3, 5, 2, 3, 3, 9, 0, 123])\n    True\n    \"\"\"\n    return sorted(l1) == sorted(l2)\n\nThe above is \"hello world\" code for these operations, but in general, I find that many of the \"advanced\" functional programming libraries (like Functional Programming in Scala) and tools don't have a simple hello world example that demonstrates what they are good for.\n\nSince Python has native support for", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    unique_index = [0, 0, 0, 0, 0, 0, 0, 0, 0]\n    if l == []:\n        return [unique_index]\n    else:\n        return sorted(unique(l), key=lambda a,b: unique_index[a][b] if a else 0)\nBeautiful!</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return list(set(list(l))).keys()\nAwesome. I like your style.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def u1(l):\n    \"\"\"Return unique list with one element\n    >>> u1([])\n    [0]\n    \"\"\"\n    for item in l:\n      if item not in u1(l):\n         u1(l) = item\n    return u1(l)\nNo matter how good the code is, if it's not written in Python, it does not belong in /r/Python.\nWe don't want to encourage people to post code they have written in other languages just because they think it's \"interesting\".\nI'm sorry that I missed the \"only Python\" rule. I only wanted to share this neat way of doing something in a language that some readers might find interesting.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l), key=lambda x: x.__next__)", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    k = len(l)\n    for i in l:\n       if l[i] == l[k]:\n          return i\n    return None", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.pop(), key=lambda item: item[-1] < len(item) and len(item) == 1)\nEDIT: I meant sorting _by_ the keys, not sorting the keys.\n\nI think you have to change the key part of the signature.\n\nThanks. Fixed it.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted(l):\n    \"\"\"Return a list of sorted unique elements in a list\n    >>> sorted(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])[1])\n    [0, 2, 3, 5, 9, 123]\n    >>> sorted(unique([5, 3, 5, 2, 3, 3, 9, 0, 123])[-1])\n    [9, 0, 5, 3, 2, 123]\n    \"\"\"\n    return sorted(unique(l))\nOh, I see.\n\nA very poor example. In python you would do:\nb = [5, 3, 5, 2, 3, 3, 9, 0, 123]\nsorted(b)\n\nI'm not sure why you are being downvoted, because what you are saying is perfectly true. I think the point is that python programmers are familiar with using a function, but a lot of other programmers aren't.\n\nThis is a nice tool. I think I'll use it.\n\nwhy is it in a language that has a built", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return (sorted(l, key=lambda i: i[0]))", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\n    def uniq(l: list):\n    \"\"\"Return sorted elements in a list, excluding duplicates\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [2, 5, 3, 9, 0, 123]\n    \"\"\"\n\n    return sorted(l, key=lambda x: x[1] < key)\n\nSee also\n List of Python libraries\n List of Python modules\n\nReferences\n\nExternal links\n Python's built-in functions (1st Edition)\n Python's built-in functions (2nd Edition)</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda element: len(element) == 1)\nNote that sorted() is only available in Python 3.\n\nThis also works in Python 2.5:\nsorted(l, key=lambda element: (len(element) == 1 or element[1] in sorted(l, key=lambda element: element[0]))\n\nDefinitely an interesting solution, but it's not a pure Python solution.\n\nIf you need a pure Python solution that sort of works, you could use the built-in collections.Counter class.\n_\" The counter class provides an implementation of the <code>comparable</code>\nattribute. <code>comparable</code> is a class attribute that provides\ncompatibility with the built-in <code>len()</code> method, so that\ncomparable objects can be used in place of integers in certain situations.\"_\n\nYou can also use a dictionary. Simply generate a random list of the size you want, and then run through the list adding each element to the dictionary with a key of (x, y) where x is the index of the element in the list and y is the element's value", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda a, b: b[0] not in a)\n\nimport random\n\n    def sorted(l, key=lambda a, b: b[0] not in a):\n        return l[key(a, b) for a, b in zip(l, key(a, b)))\n\nIf you're interested in implementing a \"sorted\" function that uses a hash table and works correctly with duplicate keys, I've written one here:\n\nSorting a list with a unique constraint in Python is really easy to do with the built-in set (the built-in collection class):\n>>> sorted(set(x for x in list(1, 2, 3)))\n[1, 2, 3]\n>>>\n\nThis works perfectly fine, but the sorted function is just much easier to type.\n\nI wonder how long it will be before Python's own dictionary is implemented as a set.\n\nI'm not sure if this is what you mean, but the new defaultdict implementation in 3.3 is implemented as a hash table.\n\nYes, that's what I was referring to. I", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    sorted(l, key=lambda x: x[1] == x[2] - key)\nOne small problem: sorted() is not a stable sorting function.  If you need this to be an ordered list, replace sorted() with heapq().\nHeapq() does not do stable sorting either, but the problem of not having stable sorting is made up for by having an in-place implementation.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    \"\"\"Uniquely sorted list elements", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if l is None:\n       return []\n       l = list(l)\n       for j in range(len(l)):\n          if sorted(l[j], key=lambda k: k[0]):\n              return l[j]\n    return l\n\n>>> unique(range(10))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n>>> unique([4, 2, 1, 5, 3, 7, 4, 9, 6])\n[0, 2, 4, 5, 9, 6]\n\n>>> unique([5, 0, 3, 7, 1, 4, 8, 6, 2])\n[0, 1, 4, 5, 8, 6]\n\n>>> unique(range(10))[:2]\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n>>> unique(range(10))[0:2]\n[", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for (i, j) in enumerate(l):\n        if sorted(l[j], key=lambda x: x[i])[0] > sorted(l[j], key=lambda x: x[i])[1]:\n           return [l[j]]\n    return []\nIt is better to use `unique.sort(key=lambda x: x[i])` so that it can return multiple elements. This way you can also use `unique.keys()` to get the list of unique elements.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l\n    if len(l) > 1 and len(l[0]) > 1:\n       return [l[0], l[1:] if l[1:] is not None]\n    return [l[0] if l[0] not in l[1:] for l in l[1:] if l[1:] not in l[:] for l in l]\nNot sure if it's a bug or not, but I'm getting the result [1, 1, 2, 2, 2, 2, 2] for the above (assuming I've understood it correctly).\n\nI think it's a bug, but I don't think it's a bug that affects the behavior of the code.\n\nIt's not a bug, it's a feature.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\n    return sorted(l, key=lambda x: x.lower()).unique()\n\nHi,\nI don't understand what you're doing here. Do you want to return a\nlist of unique elements in the original list?\nAs it stands, you're returning a sorted list, then calling\nunique on that, which doesn't make any sense.\n\nIf you want to return a list of unique elements in the original list,\nthen you need to sort the list first, and then filter on the first\nkey.\n\ne.g.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l[l.count() - l.size() > 0 for l in l]", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n        return sorted(l, key=lambda a: a[l[a]])\nI'm going to guess that this is an assignment for a CS class.  If you don't understand what the Python code is doing, you need to start with the Python documentation for the sorted function and work your way from there.  If you don't understand the Python documentation, you should ask for help in the appropriate forum.       Please don't just copy and paste random code.  That's not how you learn to program.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    sorted(l)\n    unique()\nThis is the simplest and most idiomatic approach, IMO.\n\nYes, this is the fastest way. I'm sure you could also write some sort of recursive solution that used heapsort.\n\nVery nice. I like it.\nJust a question about the \"sorted\" function: is it documented somewhere? I didn't find anything by searching.\n\nNot sure, but it could be this: \n\nno. the \"sorted\" function is new.\n\nHow is the sorted function different than just sorting the list using the built in Python functions? I'm sure I'm missing something, as I'm very new to Python.\n\nPython lists are by default sorted. Sorting a list is almost always a bad idea. To sort an already sorted list is a crime against humanity.\n\nI just saw the title. I thought it was going to be about a list of people who are unique.\n\nme too!\n\nOh, I can't count. It's supposed to be a list of unique people.\n\nIt's OK. I like the people you chose.\n\nThis is not at all idiomatic. You", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda t: len(t) == 1, reverse=True)\nThis also has O(N) complexity, where N is the size of the list.\n\nIt's O(N) regardless of which implementation you use. The original is O(N log N) where N is the size of the list.\n\nThis was the original (unsorted) version, which is O(N) instead of O(N log N):", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(list, unique(lambda x: x[1]))\nWhat's the problem?\n\nIt doesn't preserve order.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set([l]))\nI've always wondered if Python's lists are always sorted, or if it's just [0, 2, 3, 5, 9, 123] that's sorted.\n\nYou can force a list to be sorted by telling it to be sorted:\n>>> a = [1, 2, 3] >>> a.sort() [1, 2, 3] >>> a.sort() [2, 1, 3] >>> a.sort() [1, 3, 2]\n\nI think the question is whether Python's built in functions are implemented to sort lists on their own or if it's just an implementation detail of the.sort() function.\n\nSorting is an implementation detail of the.sort() function. The built-in functions don't sort.\n\nYes, but which built-in function sorts?\n\nThis one:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    unique = lambda l: []  # an empty list\n    unique_in_list = lambda l: []  # an empty list\n    for elem in l:\n        if elem not in unique:\n           unique.append(elem)  # append it to the unique list\n           unique_in_list.append(elem)  # also append it to the unique in list list\n    return unique\n\nThe problem with this solution is that it is expensive. If you have a very large list, you should use Python's set data type.\n\ni wouldn't go so far as to call it \"expensive\", but it is certainly not the best approach. i think the solution is elegant, but i prefer your solution.\n\nI like the solution, but it's not so fast.\nI wonder if the hash-set of integers in the Python standard library is a better solution (not very pythonic though).\n\nWhat about", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def unique_in_range(l, start, end):\n    \"\"\"Return a sorted list of unique elements in a range\n    >>> unique_in_range(['a', 'b', 'c', 'd'], 0, 4)\n    ['a', 'b']\n    >>> unique_in_range(['a', 'b', 'c'], 0, 3)\n    ['b', 'c']\n    >>> unique_in_range(['a', 'b', 'c'], 0, 2)\n    [ 'c', 'b']\n    \"\"\"\n    if start <= end:\n       return []\n    start = start + 1\n    for l in range(start, end + 1):\n       if l not in l:\n          return l\n    return l\n\nRelated: https://github.com/quozl/unique\n\nOr the python standard library's itertools.tee.\n\nI love itertools", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\n    def unique(l: list, n: int):\n    \"\"\"Return the unique elements in a list.\n    >>> unique(l=[1, 2, 3, 4, 5, 6, 7, 8, 9], 3)\n    [7, 8, 9]\n    >>> unique(l=[1, 2, 3, 4, 5, 6, 7, 8, 9], 5)\n    [8, 9]\n    >>> unique(l=[1, 2, 3, 4, 5, 6, 7, 8, 9], 7)\n    Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    File \"list.py\", line 25, in unique\n    return sorted(lambda x, y: sorted(x[:n], y[:n]) for x in l and n in range(0, len(l))))\n    KeyError:'sorted'\n    \"\"\"\n\nDon't forget to test your code!\n\nHah, thanks. The more I work with", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\n    if len(l) == 1:\n        return l\n    return sorted(l, key=lambda x: x[0])\n\nNot only is this incredibly easy to implement (no idea why people use Python's built-in `sorted` when the built-in `unique` is orders of magnitude faster), but it's also blazingly fast. \n\nI made a similar thing a while ago:\n\nI like this - it's a bit more concise and flexible than the built-in (it's the first time I've ever said that about a Python function)\n\nIn Ruby:\n\n[1, 2, 3, 4, 5]", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    unique = lambda l: [x for x in l if len(x) > 1]\n    unique(l)\n    # [5, 3, 5, 2, 3, 3, 9, 0, 123]\n    unique([0, 2, 3, 5, 9, 123])\n    # [0, 2, 3, 5, 9, 123]\n    unique([1, 2, 3, 4, 5, 6, 7, 8])\n    # [1, 2, 3, 4, 5, 6, 7, 8]\n\nFor a list comprehension:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted(s: sorted):\n    \"\"\"Sort the list and return unique elements\"\"\"\n    if len(s) > 1:\n       return sorted(s[1:] + s[0])\n    else:\n       return sorted(s.reverse())\nThis code is technically correct and will sort the elements in the list.  I think it would be better to mention that it will do a linear pass (so it may take O(n) time), and also that it will not necessarily sort the list on its natural ordering.  I'm not sure if this was intentional or not, but it's an important distinction to make.\n\nMy goal wasn't to teach sorting algorithms, but to demonstrate that it's possible to write an elegant, expressive pure Python function.\n\nI wonder how well that would hold up in practice. Some problems have a surprising amount of data structure in them that might not be obvious from the get go.\n\nI imagine that's why the author mentioned the code was \"technically correct, but probably not the best solution.\"\n\nYeah, I wrote this for my blog a while ago.\nAt", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.index, key=lambda a, b: a < b)\nHey, this is cool! I'll add that to the list for sure.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\n    def unique_in_l(l):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique_in_l([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    for k in l:\n       if k!= list(l):\n           return True\n    return False\n\n    def uniq(l):\n    \"\"\"Return unique elements in a list\n    >>> uniq([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    l.sort()\n    for k, v in enumerate(l):\n       if k!= list(l):\n          return True\n    return False\n\nThis is the idiomatic Python way to sort lists:\nThis", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambdax:x[0])\n\nSo the idea is that you keep a sorted list and when you need an element, you take the last element in the list and recurse until you find one.\nSo if I understand it correctly, this would be O(n) where n is the length of the list and O(1) for lists of length one?</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l), reverse=True)", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1])\n\nIsn't this O(n log n)? How does it compare to bubble sort (O(n^2))?\n\nIt seems to be O(n) because it doesn't look at the whole list, only the first element.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return list(l)\nThat's... not so useful.  You'd want something like this, instead:      def unique(l):            return sorted(unique(l), reverse=True)</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.__cmp__()).get()\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    >>> unique(['a','b','c'])\n    [True, True, True, False, False, True]\n\nFrom the comments:\n\"This is not a very good way of computing uniqueness, since the element\nthat appears twice can win the sorting contest if it has a very low\n__cmp__.  The other case is the one we want to avoid, where the\nuniqueness function returns the same element twice.\"\nI think this is a good candidate for the \"Don't do that\" section of the Zen of Python.\n\nIf I had to guess, I would say that this is a special case for the author of the function. The thing about \"Zen of Python\" is that it's about making the language more consistent and readable, not more general.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l)), set(l)\nOh god I want to commit a war crime</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0])\nI hope that is not a serious question.\n\nYou might be surprised how many times I've seen that in real code.\n\nI know. Just look at the sort() function in Python standard library.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n       return l\n    else:\n       # use the len() function to get the length of the list\n       return sorted(l, key=lambda x: x[0])\n    class NumericSequence(object):\n    \"\"\"A sequence of numbers\n    >>> NumericSequence([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    {'5': 5, '3': 3, '5': 5, '2': 2, '3': 3, '3': 3, '9': 9, '0': 0, '123': 123}\n    \"\"\"\n    def __init__(self, *args, **kwargs):\n       self.i = 0\n       self.j = 0\n       self.k = 0\n       self.l = []\n       self.m = []", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l), key=lambda x: x[0])\nI know it's a joke, but I think the author should have defined unique() as it's defined in Python.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda item: isUnique(item))\nNote, this only works if the list is sorted in the first place. It does not work if it's not sorted. The author should have at least mentioned that.\n\nAnd it's O(n) if the list is already sorted. O(n log n) if the list isn't sorted.\n\nn log n is actually correct, assuming the sort is a stable sort.\n\nI would argue that stable sorting is an assumption that is rarely if ever met in real world code, and hence should be left out of the analysis.\n\nI would argue that stable sorting is an assumption that is rarely if ever met in real world code, and hence should be left out of the analysis.\n\nAnd I would argue that the trivial solution should be left out of the analysis.\n\nAnd I would argue that the trivial solution should be left out of the analysis.\n\nAnd I would argue that the trivial solution should be left out of the analysis.\n\nAnd I would argue that the trivial solution should be left out of the analysis.\n\nAnd I would argue that the trivial solution should be left out of the analysis.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return []\n    return unique(l)\nThe problem with this is that it doesn't preserve the ordering. If you need to preserve the ordering, you need to use:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    \"\"\"Uniquely sorts a list, producing a singleton list.\n    >>> unique(range(10))\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]\n    >>> unique([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n    \"\"\"\n    #: Return values\n    def __init__(self, base: list):\n    \"\"\"Initialize the state.\n    >>> unique(range(10))\n    [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]\n    \"\"\"\n    self._base = base\n    self._prev = []\n    self._next = []\n    self._count = 0\n    self._count_len = len(self._base)\n    self._is_empty = False\n    self._s", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for item in l:\n         if item == len(l):\n            return item\n         elif item not in l:\n            return list(item)\n         return [item]\nThe example you have shows how to do it in Python.\n\nI am surprised that you are not aware of that.\n\nI'll try to answer your question.\nThe answer to your question is:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(list(l))\n    def sorted(l):\n    \"\"\"Sort a list in ascending order\n    >>> sorted([1, 2, 3, 4, 5, 6, 7, 8, 9])\n    [1, 2, 3, 4, 5, 8, 9]\n    \"\"\"\n    if len(l) > 1:\n        l.reverse()\n        return sorted(l[0], l[1], l[2],..., l[len(l)-1], l[-1])\n\n`unique` is not particularly Pythonic.\nIf you use Python 2.7, then there's an even better way:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted(l: list):\n    \"\"\"Return sorted elements in a list\n    >>> sorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [5, 3, 2, 9, 0, 123]\n    \"\"\"\n    return sorted(l.pop())\nThis is a very popular idiom, but it's a bit slow.\nimport collections\nfor i in range(1, 100):\ncollections.sorted(set([i]) for set in sorted(set(range(1, 10)))\nThis is orders of magnitude faster than the naive solution.\n\nI don't know if it's \"orders of magnitude faster\", but it's certainly faster.\n\nPython has a sorting algorithm that is orders of magnitude faster than both. In the other thread, I see a comment that says it is the default in Python 2.7.\n\nYup, it's called Quicksort.\nPython 2.7 defaults to using it.\n\nBut that's O(n log n) worst-case, so it's not really a good solution for large arrays.\n\nMostly", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, reverse=True)\nThis is not very good, since it fails if the list is empty. Better would be to use the list index as the unique key and just return the first item.\n\nreturn sorted(l, reverse=True, key=l.index)\nWorks great for lists and sets.\n\nI was going to mention that as an alternative, but the OP wanted the index to be the unique key.\n\nI think this is a really bad way to implement it. You should have a list of unique values and check the first item in the list of values in the list. If the list is empty then return an empty list.\n\nI can think of a much simpler implementation that preserves insertion order and works with n-tuples.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if len(l):\n       return [l[0] for l in l]\n    return []", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for el in l:\n       if el in unique(el):\n         return el\nThis is a function that is easy to screw up, and this function is poorly documented.  So even if it's easy to fix, it might be hard to find the fix.  I would suggest using the built-in function `count()`.  It will work as you expect, and you don't have to worry about screwing up the implementation.\nAnother alternative is to use `sort()` instead of `unique()` and then do a standard `count()`.  This is less error-prone, but takes more time.  For me, this is often the better option, because I can use the time to think about how I want to fix the code, and the time to write tests that make sure it won't break in the future.\n\nThank you, I didn't know about count. I'll try to use that instead.\n\nYou're welcome!</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for elem in l:\n       if elem not in sorted(l):\n          return sorted(l[::-1], reverse=True)\n       else:\n          return elem", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    for item in l:\n       if item.isdigit():\n          return item\n       else:\n          if item[:-1] in l:\n            return item[:-1]\n    return []\nHow did you get this code? I can't find the source code anywhere...\n\nThere is a link in the lower-right corner of the page that says \"Github\".\n\nOh yeah, I see it. Weird.\n\nI'd prefer if the map function was used instead of dict, but otherwise a very nice intro.\n\nI did the same thing in Python. (Same author as the article.)\nIt's a nice intro, but some people don", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0])\nYou're missing an append to your list at the end of the loop, that's why your list is not updated.\nThanks! Makes sense, so the append would be just what I commented out?\nYes.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n          result = []\n         for x in l:\n            if x == l[0]:\n                   result.append(x)\n              else:\n                    if x in l:\n                        result.append(x)\n                     else:\n                       result.append(l[1])\n                  return result", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda item: item[0])\nI don't understand this at all. How does this work?\n\nThe equivalent python implementation:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    for item in l:\n       if not item in l:\n          return None\n       elif len(l) == 1:\n           return item\n       return sorted(set(l), key=unique)\n\nThat's one way to do it, but I think this is more common:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    if not (l.count().is_integer()):\n        return l\n    else:\n        return sorted(set(l), key=lambda l: l.count(ord('a')))\nThat is almost identical to the algorithm I used, except for the key parameter. How is that used?\nBecause sorted(set(l), key=lambda l: l.count(ord('a'))) will sort the list according to the number of a's in the list.  The key is then used to get the actual a's.  So if you called it for [5, 3, 5, 2, 3, 3, 9, 0, 123] it would return [0, 1, 2, 3, 4, 5, 6, 7, 9, 0, 123].</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(set(l), key=lambda k: k[0])\nMore readable:      sorted(set(l), key=lambda k: k[0])\n\nI think the first is more readable, for a person familiar with the python set API.\n\nI don't think so. \"lambda k: k[0]\" is probably the most common syntax for list slicing, and it's certainly more readable than \"return sorted(set(l), key=lambda k: k[0])\"\n\nI think you're right. I just wanted to point out that the list comprehension syntax is used by people not very familiar with the Python set API.\n\nI usually just use Python's built-in sorted function, but if you want to use this, you could always just put it in a function and pass it in. This function is over-engineered.\n\nI think it's interesting to see how people try to make a function more intuitive.\n\n\"The fastest way to sort a list is to use Python's built in sorted function\"\nThis is only correct if the list is sorted already.\n\nI use python's sorted function in a variety of different cases", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.sort()", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    x = len(l)\n    y = len(unique(l))\n    for x in xrange(0,l+1):\n        for y in xrange(0,unique(l):y):\n           if x == y:\n              break\n          else:\n              x, y = y, x\n    return [x, y]\n\nGood point! I'll add it in.\n\nJust a minor thing: you need to change the indexing to use the \"looping\"\nsyntax (as mentioned in the Python docs, eg. \"for x in xrange(0, l + 1):\")\ninstead of just \"for x in xrange(0, l):\".\n\nI put this in a while back. I just forgot to update it. Thanks for pointing that out!\n\nAlso, you're calling your list function (unique in the example) with a list\ninstead of a tuple", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    sorted = []\n    for x in l:\n       if len(x) > 1:\n          sorted.append(x)\n    return sorted\nThat's not really \"unique\".  It's \"sorted\".\nYou are right, it should be:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    \"\"\"\n    def is_empty(l: list):\n    \"\"\"Return True if list is empty\n    >>> is_empty([])\n    True\n    \"\"\"\n    if len(l) == 0:\n        return True\n    return l == [:]\n    def size(l: list):\n    \"\"\"Return number of elements in list\n    >>> size([1, 2, 3, 4, 5])\n    5\n    >>> size([1, 2, 3, 4, 5])\n    5\n    >>> size([1, 2, 3, 4, 5])\n    7\n    \"\"\"\n    return len(l)\n\nOutput:\n\n>>> unique([1, 2, 3, 4, 5])\n[1, 2, 3, 4, 5]\n>>> unique([])\nTrue\n\nJava\nIn the Java programming language, the methods java.util.Comparator and java.util.Arrays.sort are used to sort lists.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\nI'd be interested to hear the reasoning for this choice.\n\nUnique is a common word, and it was probably easier to come up with that name than something else.\nI agree that it's not the most intuitive choice, but there are much worse things in that list.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.unique(), key=lambda x: x.count() > 0)\n\nThat seems like a silly way to implement it.\n\nIt's essentially the same algorithm, just with extra code to make the case where the list is empty work out.\n\nAnd the problem is that it is extra code. It's additional (possibly redundant) complexity that is only there for one case.\nAlso, it doesn't even seem like it's _actually_ working out that case.\n\n_Also, it doesn't even seem like it's actually working out that case._\nWell, the `sorted` function is guaranteed to return the unique elements, and the `unique` function simply uses that.\n\nAnother way to do it is with a list comprehension:\n>>> unique = [x[x > 0]] + [x[x < 0]] + [x[x == 0]]\n>>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n[0, 2, 3, 5, 9, 123]\n\nI just used regular expressions.\n>>> unique = re.compile(r'[^0]+(0|[", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda element: element[0])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda i: len(i) < len(l))\n>>> unique([\"foo\", \"bar\", \"baz\"], key=lambda i: i[0])\n['baz']\n>>> unique([1, 2, 3, 4, 5, 6], key=lambda i: i[0])\n['1', '2', '3', '4', '5', '6']\n>>> unique([1, 2, 3, 4, 5, 6], key=lambda i: i[1])\n['5']\n>>> unique([1, 2, 3, 4, 5, 6], key=lambda i: i[2])\n['6']\n>>> unique([1, 2, 3, 4, 5, 6], key=lambda i: i[2])\n['5', '6']\n>>> unique([1, 2, 3, 4, 5, 6], key=lambda i: i[1])\n['2']\n>>> unique([1, 2, 3, 4, 5, 6], key=lambda i: i[2])\n['3']\n>>> unique([1, 2, 3, 4", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    l = list()\n    for i in l:\n       if i not in l:\n           return i\n       l.sort()\n    return unique(l)\nI actually thought that's what this would do the first time I read it.\n\nThe most basic way to do that is actually:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return l.sort(function(x, y) {\n       return x.indexOf(y) < 0;\n    });\n\nor:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1] < x[0])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    # Avoid division by zero errors\n    return list(set([i for i in l if i in unique(i)])\n               )\n    def unique_in_reversed(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique_in_reversed([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    # Avoid division by zero errors\n    return set(l.reverse())\nI don't know if python checks for negative elements when sorting lists.\n\nIt does, see for example \n\nIt's a good effort, but it's a pity the tutorial doesn't touch on the issue of \"what to do with the results\".\nOnce you've got your data sorted, how do you want to apply it? You can use it to produce a new list of sorted data for comparison, for instance.\n\nWell, it is an introductory tutorial.\n\nI see this link", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted_unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> sorted_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [5, 3, 9, 123]\n    \"\"\"\n    l = sorted(l)\n    return unique(l)\nHow would you sort something that is already sorted?\nThis method is actually called:      sorted_unique", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def sorted_unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> sorted_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(l.items(), key=lambda item: item.index() - 1)\n\nIf you are unfamiliar with this sort of thing, this is just a sorting function that you can use like:\nsorted_unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n\nIf you want more than a single argument, just create an array of them and pass that in. It will be sort of like a dict where you can access each item in the array with its index:\nsorted_unique(['5', '3', '5', '2', '3', '3', '9', '0', '123']).\n\nIf you have two lists that have to be sorted, you can just pass them both in:\nsorted_unique(['5', '3', '", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    unique = sorted(l, key=lambda item: item[0] == item[1])", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def __getitem__(self, idx):\n    \"\"\"Return the element of the list that has the idxth element of the list\n    >>> unique(['a', 'b', 'c', 'd', 'e', 'f'], 0)\n    [f]\n    \"\"\"\n    return sorted(set(l), key=lambda t: idx)\n\nWhat about testing? How do you know that the returned list is actually unique?</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def unique(l):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    if len(l)!= 1:\n        return []\n    else:\n        return l.sort(key=lambda x: x[0], reverse=True)\n\nThis implementation makes the assumption that keys are not equal. This implementation doesn't require that the keys be unique, only that they be non-equal.  The \"usual\" Python implementation of `unique` sorts the keys in ascending order.\n\nAlso note that this implementation of `unique` is not in-place, but has O(n) runtime, where `unique` has O(1) runtime.\n\nThis implementation is not stable, it changes the length of the list.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda item: int(item[0]))\nI'm sorry, but I don't understand how this is supposed to be better than `unique`.\n\nIt's not better, but I did not know about unique, which I will now be using instead.\n\nit's from the collections module, so it's an obvious candidate for being a \"shameful\" secret.\n\nWhat does this have to do with writing python code?\n\nI'm not sure I can add anything to that comment, but I certainly can't upvote it enough.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def unique(l):\n         return sorted(l.items(), key=lambda item: item[0] == item[1])\nThis will also fail if l has more than one item with the same key.\nUse [0, 1] for the key.\n\nFantastic! Thanks!\n\nIf you have a list of strings and want to find duplicates in a given range,\nthen the solution is easy:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return (i for i in l if i not in sorted(l))[1]\nThanks for the feedback. For some reason I was under the impression that the sorted function was a part of the collections package.\nOh, wait, I think I see.  OrderedDict and SortedDict are in the collections package.</s>", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n\n    unique = lambda l: sorted(unique(l))\n    print unique([1, 2, 3, 4])\n\n    print unique([1, 2, 3, 4], key=lambda l: l.pop(0))\n\nI am not sure I get it... I think I have to write something like:", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    return list(l.sort(key=lambda k: k))\nNo, that's incorrect:\nlist(l.sort(key=lambda k: k))\nsorts the list using key, but returns the sorted list in sorted order.\n\nIt looks like you can use `itertools.groupby` for the same result:\nl.groupby(lambda k: k)\n\nIf you're using Python 2, the result is wrong (and this is not an issue with the article).\nl.groupby(lambda k: k)\nWill raise a TypeError. Instead, use:\nl.groupby(lambda k: key(k))\nOr, if you prefer Python 3:\nl.groupby(key)\n\nThe list comprehension syntax was only changed in Python 3; in 2 it is still:\nl.groupby(lambda k: k)\n\nOops, you're right. For some reason I thought the syntax was changed for 2.7.\n\nI'm not familiar with Python, but it seems to be missing a lot of methods of the List type. I.e. the equivalents of map, filter, reduce, etc.", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    def reverse_sort(l: list):\n    \"\"\"Sort list l in reverse, i.e. a list of numbers will be sorted in reverse order.\n    >>> reverse_sort([1, 2, 3, 4, 5, 6])\n    [5, 2, 3, 4, 1, 6]\n    \"\"\"\n    return sorted(l, key=lambda x: x[0] if x else x[-1] + x[1:] - 1)\n\nWon't this blow up in practice when the list is not properly sorted?\n\nI think you're right that it will blow up. The article is probably\nmeant for lists of integers, where the first element is likely to be 1.\n\nAh, yes, it seems like it would work fine then.\n\nSorting on integers with negative indices. That's gonna be a fun bug to debug.\n\nNot that it matters much, but I think the original title is \"How to sort a list\"\n\nFor a more generic solution, try\nsorted(array, lambda x,y: x[0] - y[0], reverse", "def unique(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\" \"\"\"\n    a = len(l)\n    b = len(l) - 1\n    for i in range(a, b):\n        if not a[i] == b[i]:\n             return a[i]\n    return []\nCould you please elaborate on why the sorting is being performed in place?</s>"]]