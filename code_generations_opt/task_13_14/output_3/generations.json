[["def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    for i in range(2, a, b):\n       return a % b\n       print(greatest_common_divisor(3, 5)) # 1\n       print(greatest_common_divisor(25, 15)) # 5\nAh, but 3%5!= 1\n\nBecause it's not part of the Python standard library.\n\nHow do you know it's not?\n\nBecause it's not in the python standard library:\n\nAs I said, it's not part of the Python standard library.\n\nThis isn't a language feature. It's part of the Python standard library.\n\nIt isn't part of the standard library, that's why it's a PEP and not in the standard library.\n\nAccording to the author, he did it because he could not find any module that did this (or maybe no one was using it).\nHe just posted it on reddit: \n\nI'm pretty sure it's already available in standard Python as the divmod() function (and related divmod.modulo()).\n\nI'd have just used a library.", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nI don't know much about math, but I'm guessing this isn't a good way to find a greatest common divisor.\n\nI don't know much about Python, but I'm guessing this isn't a good way to find a greatest common divisor.\n\nIt's not, but the name is quite apropos.\n\nA better approach is to use a modulo operation:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return (a / b) ** b\nThe second greatest common divisor of 3 and 5 is actually 4.\nI'm not sure I understand what you are trying to accomplish with your question.", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    a = int(a)\n    b = int(b)\n    if a > b:\n       return 1\n    else:\n       return a/b", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a > b? 1 : b > a\n\nimport operator, any, num", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    # 1. We can use the fact that the greatest common divisor of two\n    # integers is equal to the greatest divisor of their divisors.\n    #\n    # 2. We can also use the fact that the greatest common divisor of\n    # two integers a and b is equal to the largest integer d such that\n    # a / d == b / d and a == b.\n    def gcd(a: int, b: int) -> int:\n    \"\"\" Return the greatest common divisor of two integers a and b\n    >>> gcd(3, 5)\n    1\n    >>> gcd(25, 15)\n    5\n    \"\"\"\n    # 3. We can use the fact that the greatest common divisor of two\n    # integers a and b is equal to the greatest integer d such that\n    # a / d == b / d and a == b.\n    def gcd(a: int, b: int) -> int:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nI'm a little unclear on what's wrong with this. Can someone explain?\n\nThe problem is that you don't need the greatest common divisor to be 1 or 5.\nImagine instead that your inputs were 1, 3 and 5, or 25, 15 and 15. In either case, the result would be 10.\n\nI don't think I'm understanding correctly. In my mind, if you were given an input that could be divided by both numbers (in this case 1,3,5,25,15,15,15) I think it would make sense to return the greatest common divisor of the two numbers.\nIf it were given 1,5,25,15,15,15, you wouldn't get any answer because they don't have a greatest common divisor.\n\nIf you were given two integers a and b, the greatest common divisor of a and b is a number which is divisible by both of them.\nIn this case, a and b are both 1, and so the greatest common divisor of a and b is 1.\nThis will be true even if a and b are both 15 and you are given their greatest common divisor.", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nIs it just me, or is that a really bad definition?\nWhat if I want a greatest common divisor of 3 and 5 that's not 1?\nWhat if I want a greatest common divisor of 3 and 5 that's not 5?\n\nIt's Python, not C. You can just write a function that takes a parameter for the desired greatest common divisor.\n\nThis is a terrible definition. I don't see why that's OK, but it's not OK to define, for example, Array.__add__(a, b, k) as the function that returns the sum of a and b divided by k.\n\nI think it's ok, and it's because Python is a dynamic language and not a static one.\n\nI am not sure I follow.\n\nI am a python newbie. But I understand this as:\nIf you want to find the greatest common divisor of 3 and 5 and you know what that number is, you can define it as:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return ((a - b) ** b) + 1\n\n(Python 2.7, 2010-02-20)\n\nIf I wanted to return the greatest common divisor of 3 and 5, this function would return 1. This is because 1 is the greatest common divisor of 3 and 5. If I wanted to return the greatest common divisor of 25 and 15, this function would return 5. This is because 5 is the greatest common divisor of 25 and 15.\n\nSee also\n Greatest common divisor\n Divisor (mathematics)\n Polynomial remainder theorem\n\nReferences</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return (a%b) == 1\nThis is so simple and straightforward. Just about the only thing you'd want to change is the fact that it doesn't take into account the values of `a` and `b`. For example, `(3,5)` and `(25,15)` yield the same result as `3/5` and `25/15`, and in fact `(3,5)` and `(25,15)` and `(3,5)*5/15` are all the same answer.\nI am curious, is there a simple way to get around this?\n\nGood question. It's a bit more complicated than that.\nA simple solution for the general case is to pick the largest common divisor that is smaller than the two integers. So for example, in your examples, you could have written:\n(3, 5) % 5 == 1\n(25, 15) % 15 == 5\n(3, 5) % (25, 15) == 1\nBut this is only useful if you already know which numbers you want to find the greatest common divisor for.\nIf you want to find the greatest common divisor", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a % b == 0\n\nOh wow. I'm not sure I've ever seen anything quite that blatantly wrong on Hacker News.\nThe article in question is a very old one, and I think it's great that someone has made a blog post about it. It's a great teaching tool for programmers and computer scientists.\n\nHow is that incorrect? I thought it was just a typo.\n\nWell, maybe I should have said \"wrong\". The correct version is:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return 0 if a!= b else a / b\n\nSee also\n\n List of numerical libraries\n\nReferences</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nTook me a while to get it :)\n\nPretty good stuff.\n\nThanks!</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == 0:\n       return 1\n    return a < b\nI'm not sure what the use case would be for this.  If you're doing division in Python it's usually for a specific reason.  Can you give an example of when this is useful?\n>    if a == 0:   >    return 1                                    >     return a < b                                     >", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    def gcd(a: int, b: int):\n    \"\"\"Return a greatest common divisor of two integers a and b\n    >>> gcd(3, 5)\n    1\n    >>> gcd(25, 15)\n    5\n    \"\"\"\n    return a == b\n    return b == a\nThis code is broken, because the return value of gcd is 1 if a or b are equal and 5 if a is not equal to b.\n\nAs per the rules of the test suite:\nIf you submit code with a bug in it, it will be marked wrong.\nIf you submit code that is not idiomatic Python, it will be marked wrong.\nIf you submit code that does not work, it will be marked wrong.\n\nUnless you post a \"TODO\" comment explaining why you did something strange.\n\nI did that for you.\n\nWell, yes, you did. That's why I posted that comment. :-)\n\nIt is not. The code is correct. The function's return value is defined as \"the greatest common divisor of the arguments", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a / b\nThis is somewhat easier to read and maintain than the other solutions.\n\nThis is trivial and requires little to no understanding of the problem being solved.\n\nWhat are you talking about? It's a simple solution that performs well and is easy to understand.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nI like to think this was written by some smart high-school kid who wants to go into programming.\n\nI like to think he's a smart high school kid who already is a programmer.\n\nI like to think he's a smart high school kid who's already working at Google, and he's just demonstrating how well he can code in his spare time.\n\nI like to think he's a smart high school kid who's already working at Google, and he's just demonstrating how well he can code in his spare time _while juggling_.\n\nI like to think he's a smart high school kid who's already working at Google, and he's just demonstrating how well he can code in his spare time _while juggling flaming chainsaws_.\n\nI like to think he's a smart high school kid who's already working at Google, and he's just demonstrating how well he can code in his spare time _while juggling flaming chainsaws while on fire_.\n\nI like to think he's a smart high school kid who's already working at Google, and he's just demonstrating how well he can code in his spare time _while juggling flaming chainsaws while on fire and speaking Klingon_.\n\nI like to think he's a", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a % b\n\n>>>\n\n>>> def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    return (b % a)\n\n>>>\n\n>>> def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    return a ** b\n\n>>>\n\n>>> def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if b == 0:\n       return 1\n    else:\n       if a < b:\n          return a\n       else:\n          return greatest_common_divisor(a - 1, b - 1)\n       print(greatest_common_divisor(25, 15))\nThis is still not the case with your implementation. If b == 0 then you return 1, if b == a then you return a.\nIf you want to handle b == 0, you need to return 1 in case b == 0, otherwise you should return a, as you do with a > b.\nYour implementation is correct for b < a or b > a, but not for all cases.\n\nOP is correct; it's a bug in Python's default implementation.\nThis is, as pointed out, not true:\n>>> greatest_common_divisor(25, 15)\n1\n>>> greatest_common_divisor(25, 15)\n5\n>>> greatest_common_div", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    n = int(b)\n    n_a = int(a)\n    n_b = int(b)\n    if n == n_b:\n        return n\n    else:\n        return n - n_a\n\nThis is the code of my app in python.", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return int(a + b).__div__(b, a)\nwhile (a: int, b: int) -> int:\n    if a > b:\n       return a - b\n    if b > a:\n       return b - a\nIt would be nice to see the code for this, since this is the only function in the whole file and the method is not explained.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return (a ** b) / (a ** b + b ** a)\nNote: this is guaranteed to be the correct answer for two integers, not\nfor rational numbers.\n\nPython has a built-in function for this called \"gcd\":\n>>> gcd(3, 5)\n1\n\nI think this one is more readable:\n>>> def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    return (a ** b) / (a ** b + b ** a)\nThe built-in python function is:\n>>> gcd(3, 5)\n1\n\nThat's the gcd function I was referring to.\n\nAh, my mistake. I misread your comment as saying \"Python has a built-in\nfunction for this called 'gcd'\".\n\nBoth these functions", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a > b\nI haven't looked at the code, so this may be a dumb question, but...  Isn't that literally the same as `sqrt(a - b)`?\nNot in Python 3\nOh, I was unaware that this was Python 3.  How do they differ?\nI haven't used python 3, but it was my understanding that a > b is the same as b <= a, which is different than a / b == b / a == 0, which is the case for Python 2. I'm probably wrong on one of the conditions, but something like that is what I've heard.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\n>>> a = 27\n>>> b = 34\n>>> c = greatest_common_divisor(a, b)\n\nTraceback (most recent call last):\nFile \"\", line 1, in?\nValueError: division by zero\n\nThe main thing I want to make clear is that this is not the same as the assignment operator.\n\nYou are correct. The assignment operator returns the new value of the left-hand expression and the right-hand side is evaluated. For example,\n5 = 7;\nreturns 7, not 5.\n\nIf you're curious, the reason for this is that the assignment operator returns the value on the left-hand side. The value on the right-hand side is only evaluated if the left-hand side is not a primitive type.\n\nthanks, that makes sense.\n\nAlso the operands of the assignment operator are evaluated in left-to-right order. If a and b are the same type, the expression a = b will be evaluated as follows:\na = b\na = a\na = b\n\nI'm not sure that's always true.\nIn Python 3.5 and earlier:\n>>> a = b\n>>>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == b:\n       return 0\n    else:\n       return a - b\n\nfor i in range(1,5):\n    print(i, greatest_common_divisor(i, 2))\n>>> i = 1\n>>> print(i, greatest_common_divisor(i, 2))\n1\n>>> print(i, greatest_common_divisor(i, 2))\n2\n>>> print(i, greatest_common_divisor(i, 2))\n3\n>>> print(i, greatest_common_divisor(i, 2))\n4\n\nIf you want to see the differences between what you wrote and what he wrote, consider:\na = b = 0\nwhile a!= b:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a == b? 1 : (b - a) % b\n\nGreatest common divisor, commonly called GCD is a function that can be used to calculate the greatest common divisor of two integers a and b. Python's built-in function is quite slow. A faster alternative that can be used in many situations is to use recursion to solve the problem.\n\nA Python GCD function can be created using three nested loops, where two loops calculate the largest number among the prime factors of the denominator and the largest number among the prime factors of the numerator, and then the largest common divisor is calculated.\n\nHowever, this can be slow because of the nested loops, and it can be difficult to reason about and maintain. A better approach is to use a divide and conquer strategy, also known as dynamic programming.\n\nThis Python GCD function uses dynamic programming to calculate the greatest common divisor. The function is implemented using a stack data structure to store the calculation.\n\nThe function works by first storing the result of the division of a number by its greatest common divisor in a stack. Then the function executes the recursion until the stack is empty. This is because", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    # Check divisibility\n    if b!= 0:\n        if a % b == 0:\n           return b\n        else:\n            return -b\n        # Check if it is the \"best\" divisor\n    if a == 0:\n        # For negative numbers the greatest common divisor is always 1, so\n            return 1\n        # For positive numbers, it depends on the smallest value of the\n             divisors\n         if b == 0:\n            return b\n        # If the numbers are positive, and a/b is a multiple of both, it's\n             the greatest common divisor", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a.int(a % b)\nAaargh! If you're going to use Python then why not just use the int() function?\nOr use Python's own greatest common divisor: gcd().      gcd(a, b)\nIsn't it faster?      timeit(gcd(3, 5), \"test\")      timeit(greatest_common_divisor(3, 5), \"test\")\n\nIt's a good point. I wasn't aware of the gcd built-in.\n\nWell, to be fair the built-in gcd will only work for two integers, where as this function will work for any number of integers.\n\nAlso, there's another minor difference: The built-in gcd will always return a positive number, while this function can return either a positive or a negative number.\n\nI would imagine that it's faster to use Python's built-in gcd(), since you're not having to do an extra function call.\n\nI don't think there's any way of knowing without benchmarking.\n\nAgreed. What I'd like to", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a % b", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nI would say it is not a good habit to have to write out the entire thing in comments. They should be used to explain things like algorithm complexity and what not, and not the actual implementation.\n\nOh, it's not the implementation itself that's commented, it's the variable names. You can see that in the third example, the line of code is commented, but the actual implementation is not.\n\nAh, I see. Thanks for pointing that out.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return (a div b) == 0\nI'm not sure what's wrong with this, but the result is not always correct.\n\nYour comment is too vague to be helpful. What is the result that you are expecting, and what is the actual result?\n\nI've been playing with the calculator[1], and, while it's probably just my misunderstanding, I've found that the result depends a lot on the number being divided.\nFor example, when calculating the greatest common divisor of 30 and 24, the output was 3, but when I tried the same for 50 and 48, the output was 5.\n\nIt's just your misunderstanding.\nThe greatest common divisor of 30 and 24 is not 3, it is 3. You tried to divide 30 by 3 and got 30/3 = 10.\nThe greatest common divisor of 50 and 48 is not 5, it is 5. You tried to divide 50 by 5 and got 50/5 = 10.\n\nYes, that's what I was saying, thank you for confirming that.\n\nThe Raku version appears to be correct for any number and any other number (in contrast to the Python code), so it should be the", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a > b:\n       return a\n    elif a < b:\n       return b\n    return -1\nI was expecting a joke.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a - b\nThere is a bug in that function. It will return 1 for an even number.\nThe correct answer is to just return 1.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nOne caveat about python is that you don't need the \"::\" to access non-member methods.\nThe only time you would need the \"::\" is for a class method.\nSo you could just do:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == 0:\n       return 1\n    elif a == b:\n       return b\n    else:\n       return -1\nThis doesn't implement the algorithm for common divisors!  It returns 1 for all inputs.\n\nAlso, how about a reverse function, so I can find the GCD of 2 numbers?", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    divisors = [a, b]\n    for i in range(len(divisors)):\n        if i % 2 == 0:\n           divisors[i, 2] = divisors[i, 1]\n           divisors[i + 1, 2] = divisors[i + 1, 1]\n    return divisors[0, 1]\nSo, the problem is that the \"range\" used in the loop is the one of the list elements, but the loop uses i (the index of the loop). This will cause a segfault if the list is empty.\n\nThanks, I'd missed that one.\n\n_Coding Challenge:_\nI would like to see the same challenge on Stack Overflow, where the same challenges are posed, but the answers are limited to 300 characters.\n\nJust use Python.\n\nYou can't use Python for Coding Challenges. I tried.\n\nWell, you can't use _just_ Python, anyway.\n\nI have yet to", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return abs(a - b) + a*b\nYou'd think it would be intuitively clear that the most intuitive way of calculating the greatest common divisor of two integers is to divide the two numbers by each other until the result is 0.\nI would've said:      def greatest_common_divisor(a: int, b: int):\n         if a <= b:\n             return a\n         else:\n             return b\nbut I don't think the python syntax would work on reddit.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    n = a + b\n    return n % b\n\na[i] * b[i] // b[i] * a[i]\n\nright?\n\nWhoops, yes. I made a typo in my submission.\n\nI really don't like this solution. This is a terrible way to read a string.", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a > b? a : b\n\n(contributed by Francis Damoulakis)", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a > b:\n       return b\n    return a\nThis function returns a greatest common divisor of two integers, a and b.", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a % b == 0\nSome bugs in there.\n\nI don't understand. Could you explain what the bugs are?\n\nThe first is obvious:\n>>> greatest_common_divisor(3, 5)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"<stdin>\", line 2, in greatest_common_divisor\nreturn a % b == 0\nValueError: division by zero\nSo it crashes if given a negative number.\n\nI'm not sure, but I suspect that was intentional. The function doesn't return a negative number, so why should it crash?\n\nIt should raise an exception, not crash.\n\nI've taken a liking to Python. It's not because I like the language, but because it makes it easier for people to write bug-free code.\n\nWhy do you think python makes it easier to write bug-free code?\n\nI think it's because python is interpreted. If you write buggy code, it will almost certainly run and probably print something to the screen. People often write a lot of buggy code, which is hard to tell from non-", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\n>>> greatest_common_divisor(5, 3)\n3\n>>> greatest_common_divisor(5, 25)\n5\n\n>>>\n\nAnd here's the disassembly:\n\n>>> dis.dis(greatest_common_divisor(5, 3))\n    [0]    0x4048D8:      MOVL", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == 0:\n       return 1\n    else:\n       return a // b\n\nReminds me of my first Perl job. The boss wrote this script for a project to create a list of all the prime numbers up to some limit:\n\nfor $n (1.. $limit) {\n    print \"Prime Number: $n\\n\";\n}\n\nObviously, it went through all the primes in the range 1 to $limit one at a time.\n\nI was told to \"make it go faster\". So I wrote a loop and a function to go through the numbers and calculate how many of them are in the given range. I then wrote another function to calculate how many of those are primes.\n\nI was pretty proud of myself for making such a simple script much more efficient. I was sure I was going to get a raise when the boss saw my work.\n\nHowever, the boss didn't like that I made the script \"less readable\". He wanted to be able to see at a glance how many numbers were in the range. The boss insisted I write another version that outputted the numbers as", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    \"\"\"\n    #if __name__ == \"__main__\":\n    \"\"\" This is a Python script to illustrate the use of greatest common divisor\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    import math\n    def gcd(x, y):\n    \"\"\" Return the greatest common divisor of x and y.\n    >>> gcd(5, 10)\n    50\n    >>> gcd(2, 3)\n    1\n    \"\"\"\n    return math.pow(x, y, 2)", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a == b? a : (a * b)\nIt's a bit silly that it requires a == b for the first part and a * b for the second.\n\n\"it's a bit silly that it requires a == b\"\nNot really. It returns the largest _integer_ common divisor (i.e., not including 0) of a and b.\n\nFor anyone else who was confused, the author has fixed the post to say:\n\nAt some point we're going to need a compiled language with an IDE, and an awesome debugger, that has a nice mix of Python's syntax and Ruby's/Lisp's/Perl's culture of \"You have a problem? Here's an easy way to solve it.\"\n\nThere already is one. You may have heard of it.\nIt's called Java.\n\nI see what you did there.\n\nMy personal favourite for these is the good old:\ngcd(a, b) = a mod b\n\ngcd(a, b) = a % b\n\nWhich is the same as what he wrote, but with the \"a mod b\" notation for less typing.\n\nSee also", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nI thought I could detect an opportunity for a joke here, but nope. I'm no better at this than I am at programming.\n\nWow. I'm a programmer, but I'd rather write code than to crack jokes.\n\nHey, I was going to comment on how terrible this code was. Nice to see someone beat me to it.\n\nI'm not a programmer. Why is this so bad?\n\nI haven't read the code in detail, but I assume the reason this is bad is because it's a simple task (divide two numbers to get the greatest common divisor), but it has a lot of bloat to it. So in addition to the 10 lines of code that actually perform the task, you also have a bunch of irrelevant code about what's being divided and what type of variables are being used.\n\nI think that \"bloat\" is more commonly called \"documentation\".\n\nIn this case, the documentation is unnecessary. I can write a function that returns the greatest common divisor of two numbers in less than 3 lines. The rest of the code is just a bad example of how to write well-organized code.\n\nIt's not \"unnecessary\" if", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nCan someone explain why this is useful? I don't really get it.\n\nSay you have three integers, a, b and c. You want to know which one is the greatest common divisor of a, b and c, and you only know that a, b and c are not equal.\ngreatest_common_divisor(a, b) will tell you which one is the greatest common divisor.\n\nIf you have a and b, you can compute c quite easily, so this seems pretty unnecessary.\n\nThe goal is to find the GCD in the case of _unknown_ a and b.\n\nWell, right. But I mean if you don't know a and b, how are you going to use it?\n\nWhen I first saw the GCD() function I thought it was useless and uselessly complicated. Then I realized it's a great way to find the divisors of a number you know is prime. It's faster than the naive method and it's easy to check.", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return 1 if a == b else a == b % b\nYou could do this in a fraction of the code.       >>> 2 / 3\n[1] 2\n\nHm, I always liked using the method in the link. I find that the rest of your solution is a lot more convoluted, and it's a good habit to get into.\n\nIt's a good habit to be lazy?\n\nI'm not trying to be lazy. I'm trying to write clear and concise code. And I think that if you're trying to be clear and concise, this is a good habit.\n\nI don't see how this is more clear or concise.\n\nThis will raise the exception \"OverflowError\" when the numbers are large enough.\n\nYou could also use the recursive solution:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return 1 if a == 0 else a % b\nIf you want to implement GCF in python you'll want to write a generator function which takes a starting value and an ending value and returns the gcd.  You can use the list comprehension feature for this.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nGreatest common divisor of 3 and 5 is 1\nGreatest common divisor of 25 and 15 is 5", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nThat's just a tip, you don't have to write everything as an external function.\nI find the readability of functions to be much more important than the performance hit.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nI know this is a pedantic nitpick, but it's `a` and `b`, not `a` and `b` (you have \"a and b\" inside the parentheses and outside the parentheses, when you should have \"a\" inside the parentheses and \"b\" outside the parentheses).\n\nOh my, I did not notice that. Thank you for the heads up!</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if b == 0:\n       return 0\n    return a * (a + b)\n\nI don't understand what this is doing.\n\nIt's a trick. It'll work for any two integers, but it's kind of ugly. The logic is that if the first number is 0, then they can't be divided. So just return 0. If not, then you return the first number * the second number (assuming they can be divided).\n\nThe trick is to make the first number zero by setting b to zero.\n\nIt's not clear to me if I should be upset by this: a.) a really bad algorithm, b.) a really good joke, or c.) a really bad joke.\n\nIt's not a joke. I don't think it's a bad algorithm, either. It's an O(1) algorithm that returns the right answer for any positive integer a and any positive integer b. It's no worse than the factorial method, which is what the standard library uses.\n\nI didn't mean to imply that it was a joke. But the function does exactly one thing, and the line-by-line explanation doesn't explain", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nI think you meant \"greatest common divisor of a and b\".\n\nOh yes, I did. Sorry. Fixed.\n\nI'm sorry, but I feel compelled to call you out on this.\n>>> 2.0 / 2.0\nTraceback (most recent call last):\nFile \"\", line 1, in <module>\nFile \"/home/kristian/docs/examples/karma/code/test_test_runner.py\", line 5, in test_test_runner\nassert_equal(greatest_common_divisor(2.0, 2.0), 1)\nAssertionError: 1!= 1\n\nSorry, but I feel compelled to call you out on this.\n>>> 2.0 / 2.0\nTraceback (most recent call last):\nFile \"\", line 1, in <module>\nFile \"/home/kristian/docs/examples/karma/code/test_test_runner.py\", line 5, in test_test_runner\nassert_equal(greatest_common_divisor(2.0, 2.0), 1)\nAssertionError", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return (b ** 2) / (b ** 2 + a ** 2)\n\nThis is the correct answer, and the only correct answer I can find here.\n\nIt would be a very fast way to calculate it, but the fact is it is not the only correct answer. A correct answer would be to first determine the greatest integer (greater than 1, not necessarily greater than the divisor) and then, using the exponentiation algorithm, multiply the divisor by that integer. (this gives you a remainder of 0 for any integer divisor less than the integer, and a remainder of 1 for any integer divisor greater than the integer.)\n\nYour answer is not correct, because it contains an implicit cast from int to int, which is a type error.\nThe correct answer is the one given by /u/jorgeyp\n\nIt's correct in the sense that you can use it in your code and it will work.\nNot in the sense that it is the best answer.\n\nI mean, in a real life scenario, you'd probably want to have a function that you can call that does the calculation, which gives the result. So, for example, if you want", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return b * a % b\nThis would be the result of running it:\n>>> greatest_common_divisor(3, 5)\n1\n>>> greatest_common_divisor(25, 15)\n5\n>>>\nThis solution will result in a divide-by-zero error if a and b are both 1 (or more generally, if the denominators are the same).  You should consider using something like the Lucas-Lehmer test for this.\n\nWouldn't you want to use a primitive function, like abs()?\n\nNo, abs() gives you the absolute value. So, if both arguments are 1, the result would be 1 (if abs(x) is greater than 0, it means that x is negative, and in this case abs(x) is 0).\n\nI think the idea is that you don't want to do the division. You only want to tell the caller whether or not it is a GCD.\nA more proper function, IMO, would be:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    result = a ** b\n    if result == 0:\n       return a\n    return result % b", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nThis might be a good example of the difference between Python and Ruby: the first one is easy to understand, but the second one is much more concise. Ruby's lambda syntax is great for that.\n\nPython's lambda syntax is fine too:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a % b == 0\nIt is in Python 3.\n\nI love Python but I wonder how many people would have trouble with the first one.\n\nIt's not really \"wrong\" it's just \"different\"\n\nI was expecting that. I know there are a lot of people who would think the first one is wrong, but I was hoping there were more who would think the second one is wrong.\n\npython 3:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return 1 if a == b else 0\n\nI like the fact that the author starts with a C example and implements it in Java, rather than the other way around.\n\nI've been writing Java for about 15 years, and I'm not sure how I would write that in C.\n\nI'm not sure either, but I'm sure it's something like:\nint gcd(int a, int b) {", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a.divide(b)\nThanks! Was that in the interpreter?\nYes.  I have always felt that the python interpreter was one of the best documented pieces of software ever written.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a % b == 0\nThere is no need for a return statement here.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    a, b = a, b\n    if a < b:\n        return a\n    else:\n        return b\nThis is better:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a < b:\n       return b\n    return a\nI'm not sure why this is being downvoted. If I understand correctly, this is the correct solution.\nIt's a shame, because the title of the post is a statement of fact, not a question.\nYou're right, and you're getting downvoted too... I guess no one else understands the problem statement.\nI suspect that the original downvoters didn't understand the problem statement, and all the people downvoting the comments explaining the problem statement don't understand that the problem statement has nothing to do with the title of the post.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nThere are faster ways.", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nIt's a minor point, but I'd argue this style is preferable because it is a much better example of how to use the method. It doesn't look like a fully-formed method at all, and the fact that it doesn't have any parameter declarations makes it clear that this is a code example.\n\nI think the beauty of Python is the use of both the Pythonic _and_ the C-like styles.\n\nAgreed. It's nice to have a language where you can decide whether you want to do something in a pythonic or C-like way.\n\nI don't think the author has really thought this through.\nThe point of a great example is that it's as short as possible. That means you need to boil the whole method down to a few lines, not just the parameters (which is what the author suggests).\nFor instance, here's a great example of the `max` function:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return min(a,b)\nThis is a good example of how to over-engineer.\nMin(a, b) will do the job, and it's even shorter and cleaner than your version.\nI don't think you get what I'm trying to say.  I'm trying to show that you can over-engineer, or do it better than the standard library.  Over-engineering is a bad thing, but sometimes, you can do it in a way that makes you appreciate the code.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return (a > b) or (a == b)\n\n>>> let p = (greatest_common_divisor(3, 5))\n>>> p\n<function 'greatest_common_divisor'>\n\n>>> p(3, 5)\n1\n\n>>> p(3, 5)\n5\n\n>>>\n\nBut in the second case it will return a positive number if b > a. Is that a bug? I think it should return 0.\n\nNo, it should return 5. The input is a list of integers (3, 5) and the function returns another integer (5).\n\nNo, it should return 0. 3 > 5\n\n>>> let p = (greatest_common_divisor(3, 5))\n>>> p\n<function 'greatest_common_divisor'>\n>>> p(3, 5)\n5\n\n>>>\n\nI meant", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nI'll say it again: Python's classes are useless because it's really easy to get away with things like this.\n\nEven in a language like C++, you'd have to write this:\ntemplate<class T, class U>\nT gcd(T a, T b)\n{\nreturn a == b? gcd(a, b - 1) : 0;\n}\nwhich is a bit better, but still pretty bad.\n\nA lot of languages use \" ===\" as a short-circuit boolean operator, so that wouldn't work.\n\nYou can still have a boolean expression as the return value, it just has to be falsey.\n\nWell, you can have a boolean expression as the return value. However, in C++, it's illegal to return a boolean expression that isn't truey.\n\nA lot of people are saying that this is an overreaction. I think it's a good thing that they don't leave the 1-1/2 in the code. I've seen people rely on these types of things before. I've even seen people use this in production code.\n\n... but not the GP. He's just pointing out that the code", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a.divide(b)\nThis is a great example of an implementation with fewer lines of code and less functionality.\nFor the author, I hope you don't mind my copying and pasting your implementation and replacing it in my codebase.\n\nThat's not a complete implementation.\nYou should also cover the case when a == b, since the title is \"Greatest Common Divisor\".\n\nYou're right, I'll edit it.\n\n(I think I prefer your version, by the way.)\n\nI agree, it's the only correct implementation. I had a brain fart and assumed the divisor must be an integer, which was the only way I could think to make it work for all numbers.\n\nI find the other solution more useful. Sometimes you need the greatest common divisor of an integer and a float, or an integer and a double, etc. I'm not aware of a single real world use case for calculating a greatest common divisor between two integers.\n\nYour code has the same problem, it can't handle floats and doubles.\nThe only way I see to make it work for all numbers is to factor the denominator into it's prime", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a > b:\n        return a\n    return b\nPretty useless if you ask me, unless it's a part of some other library, like Guido's.\n\nI find it interesting that Python's solution to this problem is to use lists of primes.\n\nThe other solution (using the Euclidean algorithm) is similarly quite slow and requires a call to another library.\n\nI think he may have been talking about the fact that the second solution would have been more natural, as Python does have the n^2 algorithm, so he was wondering why the less obvious solution was chosen.\n\nIt is interesting that the optimal solution uses only basic arithmetic operations.\n\nI'd be really curious to see how Python handles the case of multiple (prime) numbers that are less than the smaller number (prime or not).\n\nWhy would you ever care about that? The only way a pair of integers that satisfy that criteria could possibly be obtained is by division, which has been ruled out as a possibility by the function's design.\n\nHe's not talking about division, but about the values returned from the function.\n\nThat is what I was referring to,", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    def gcd(a, b):\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> gcd(3, 5)\n    3\n    >>> gcd(25, 15)\n    5\n    \"\"\"\n    if a < b:\n       return a\n    else:\n       return b\n    return gcd(a, b)\n\nThe site has some issues and the code is a bit odd (it returns the smaller of the two), but it's not really that bad.\n\nIt's not that bad, but it's also not that good. At least the author could have used the builtin integer division.\n\nI don't know if it's because I've spent the last year writing Java all day long, but that doesn't seem so bad. I'm more worried about the Python script I had to write to transform a Java test suite into a Makefile.\n\nI know, I know. I would have used built-in integer division and a little more self-documentation, but there's", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == 0:\n        return b\n    a1 = a\n    a2 = b\n    return abs(a1 - a2) < max(abs(a1), abs(a2))\nEdit: this is a horrible solution to your problem.\nI never said it was an optimal solution, I'm just pointing out that this isn't actually an *in*optimal solution, because the runtime is going to be exactly the same for either.\nA better answer would have been the explanation of why this isn't a good solution.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return (a % b == 0 and b % a == 0)\nThat would be much easier to read if you made `(a % b == 0 and b % a == 0)` an expression and not a statement.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a < b:\n        return 1\n    else:\n        return 0", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    result = 0\n    while b <= a:\n        if a > b:\n           result = result / b\n        else:\n           result = result / a\n        result /= b\n    return result\nAnd on the 8th day he said \"Let there be booleans\"\nIn which case, you can just write `return True`.\nIf the division is done modulo a power of 2, `return False`.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nAnother good way to handle this is to use binary search:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return (b ** a) - (a ** b)\n\nOh no. I was hoping the article would say something about BigInteger and how it solves this problem in a way that's \"more pythonic\" (in the sense that it's a more idiomatic use of the language and its libraries).\n\nI was thinking about that, but I figured that would be a whole different blog post.\n\nEven then I don't think BigInt would be the right solution for this. BigInt is designed for computations which will have a result which is only an integer.\n\nI think this is a nice solution, but it's a bit contrived. You don't really need the divide operation to do this, just two nested for loops.\n\nYeah, but then you'd have to maintain the state of the divisor in each iteration.\n\nThe simplest solution is to have an int * int array (divisor) and store the last dividend in the first element.\n\nI'm pretty sure that the better way of solving this would be to have a proper divide algorithm in the Python standard library.\n\nI think the idea of a standard library is good, but in Python it's often not", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a <= b:\n       return a\n    else:\n       return b\n\nCan anyone explain why this is correct?\nIt is true, it returns the greatest common divisor of 3 and 5, but it returns 5.\n\nThe way to fix it is to make sure that when b <= a, that the loop exits.\nIf you do that you will get 1 as the answer.\n\nOh yeah, duh.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == 0:\n        return b\n    if a == 1:\n        return a\n    if a == 2:\n        return a\n    if a == 3:\n        return b\n    if a == 4:\n        return b\n    if a == 5:\n        return b\n    if a == 6:\n        return b\n    if a == 7:\n        return b\n    if a == 8:\n        return b\n    if a == 9:\n        return b\n    return a", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nThat's a pretty great solution, and I've always wondered why it doesn't have a better name.\n\nBecause it's not the greatest common divisor; it's the greatest common divisor up to a given integer, since it doesn't handle the case of a=b.\n\nNo, it returns the greatest common divisor of a and b, whether or not b is also an integer. The output of the program in the comment you replied to proves that.\n\nAh, you're right. I've used the term \"greatest common divisor\" to mean the greatest common divisor up to a given integer, and \"greatest common divisor\" to mean the greatest common divisor of two integers, but this is the first time I've seen it used as a synonym for the former.\n\nThe way I first learned to think of it was that it is the greatest common divisor of the set of integers. This is of course not true if the integers in the set are not pairwise relatively prime, but it is still the case that the greatest common divisor of two integers is the greatest common divisor of the set of all the integers that are relatively", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return (a % b == 0)\nI'd use the definition from Knuth.  For example, let a = 3 and b = 5:\n>>> gcd(3, 5)\n1\n>>> gcd(3, 5, 4)\n1\n>>> gcd(3, 5, 4, 3)\n3\nYou can find the definition in \"The Art of Computer Programming\", Volume 1,\nsection 3.1.5.2.\nIt's in the first edition (TAOCP1E), section 3.1.5.2.\nAnd I _think_ it's in the first edition (TAOCP1E) in the section on the", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if b == 0:\n        return 0\n    else:\n        if a == 0:\n            return b\n        else:\n            return a / b\n\n(defun fizzbuzz(a: int, b: int) -> int:\n    \"\"\" Return a positive integer that is not 0 or 1.\n    >>> fizzbuzz(2, 3)\n    2\n    >>> fizzbuzz(3, 6)\n    5\n    \"\"\"\n    if a == 0:\n        return 0\n    else:\n        if b == 0:\n            return 1\n        else:\n            return fizzbuzz(a, b - 1) + fizzbuzz(a, b + 1)", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nYou should name your functions something that describes what they do.\nLike \"greatest_common_divisor\".\n\nThe name \"greatest common divisor\" is a terrible name for a function that takes two int arguments and returns an int. It's a great name for a function that takes two integers and returns a third integer.\n\nIt's about the least descriptive name possible. The function could have a million different implementations.\n\nMy first reaction to the title was \"I guess you've never heard of Google\"\n\nIt's the name of the function, not the program.\n\nOne could argue that his/her first reaction to the function name was also \"I guess you've never heard of Google\"\n\nWhy is that a bad thing?\n\nIt's not a bad thing, it's a good thing.\n\nThis is all very funny, but this is actually an example of a very good naming convention.\n\nIt is a good convention. It's just not very descriptive.\n\nIt's very descriptive if you read the documentation.\n\nI'm not sure what you're trying to say here.\n\nI'm not sure what he's trying to say, either, but I", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nWhy? Why would you do this? Is there some bizarre use case where you have a bunch of integers and you're trying to find the largest one, but you don't know what integers you have?\nYou know what? I don't care. The point is that it's not a one liner.\n\nYou obviously don't work with people who _absolutely must_ use the wrong tool for the job. I've had to do the equivalent of this with C and C++ as people insisted on using things like `std::string` for data that should have been arrays of integers (no, they weren't strings, they were just numbers), `std::vector` for data that should have been arrays of pointers to structs, etc.\n\nThe author's point is that you shouldn't use a string for this problem.\n\nIt is a good point, but not the only possible solution. We can use a tuple, right?", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nThis is a bad example, because it's broken in Python 3. The correct way to do this in Python 3 is:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nAssuming that the list comprehension \"a < b\" will always result in a number, could you express your recursive function as a generator?\n\nA generator is a function that yields an infinite sequence. In Python, generators are a syntactic construct, so you can't express a generator in terms of the Python language. But you can use generators to implement your own custom recursive function, and some of them are quite elegant.\n\nFor example, a generator can be written that, given any pair of integers, calculates the greatest common divisor of the integers.", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a%b\nThat would require me to do a ton of work with \"a\", \"b\" and \"x\" to get the answer. This way I just do \"gcd(a, b)\" and I'm done.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    def __iter__(self):\n       return iter(self.__next__)\n       def __next__(self, other):\n          if other == None:\n             return self\n            return other\n   \n\nI can't speak for the author of the article but my assumption is that\ngreatest common divisor was implemented this way because it is a simple\nexample that demonstrates the concept of the iterator protocol.\nThe author of the article is likely aware that an actual implementation\nof GCF would not use this method.\nI think that if you were to write a test case that required GCF to\nactually work it would be a more interesting exercise.\n\nI agree. The article is meant as an introduction, not as a tutorial. The goal is to give people a glimpse of what the code looks like, not to give them a production-ready algorithm.\n\nOkay, so perhaps a better question is how to test that a function implements the iterator protocol.\nI'm guessing one would", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nAh, ok. Yeah, the title confused me a bit. Thanks for clearing that up!\n\nI'm glad someone else was confused by that.\n\nMy favorite \"clever\" python is the following:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    def gcd(a, b):\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> gcd(3, 5)\n    3\n    >>> gcd(25, 15)\n    25\n    \"\"\"\n    return 0 if a == b else gcd(a, b)\nThis doesn't work in Python 3.  (In Python 3, \"return\" is not a function.  It is a keyword that you use to end a function definition.  It also doesn't take a single argument.)\nIt works in Python 2.x.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == 0:\n        return 0\n    if a == 1:\n        return 1\n    if a == 2:\n        return 2\n    return a</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == 0:\n       return 0\n    if a == b:\n       return 0\n    return a\nYou need to learn the type system.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a >= b:\n       return a\n    return b\nYou have to use a and b instead of x and y.  Otherwise, you're returning the wrong thing.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a == b? b : a\nWhat kind of messed up language does that?\nThat's Java for you.\nI know, I was being sarcastic.\nThe syntax isn't *that* bad. A bit verbose, but not bad.\nThe problem is that it is verbose, and *that* bad.\nI'd say the problem is with the interpreter and not the syntax.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a if a < b else b\nreturn True", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nI'm not a Python coder, but from the documentation, that's not how it's defined.\n\nPython's greatest common divisor is division, not arithmetic. You probably meant to say mod.\n\nGCD is the function name, and its defined in the builtin math module, so it's a function.\nIt's not a division function, it's a _common_ divisor function.\nIt's not mod. mod is a modulo operation, and the builtin math module also has a function called mod. GCD is not a modulo function.\n\nIt's a function that returns the common divisor of two integers.\n\nThis one isn't the greatest, but it's pretty good:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    def __init__(self, a, b: int):\n        self.a = a\n        self.b = b\n    def __eq__(self, other):\n        if isinstance(other, int):\n           return not self.a == other.b\n         return self.a == other.b\n    def __ne__(self, other):\n        return not self.a!= other.b\n    def __lt__(self, other):\n        return not self.a < other.b\n        return self.a <= other.b\n    def __ge__(self, other):\n        return not self.a > other.b\n        return self.a >= other.b\n    return __eq__\n\nI think this is a very concise way to show how to implement a recursive", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == 0 or b == 0:\n        return 0\n    return max(a, b)\nYou'd be better off using divmod() since you know the result is always a positive integer.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == 0:\n       return b\n    return 1\n\nThen just use \n\nI have to say, I really don't like python's \"syntactic sugar\" for functional programming. It's not obvious to someone who doesn't know the language that  is the same as  in a way that is not true of e.g. Haskell.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return (a - b) % b\nIt's not clear that this is the shortest solution.\n\nit's not a solution to the problem. it's an explanation of the problem\n\n\"It's not a solution to the problem. It's an explanation of the problem\"\nNot really, it's an explanation of one solution to the problem. I think if you read the question again, it's pretty clear they're asking for one solution.\n\nThe problem asked for a _shortest_ solution. I would expect the question to say \"a solution that uses as few characters as possible\" instead.\n\nThey asked for a solution with as few characters as possible, which this is.\n\nNo, it's not. It's the _longest_ of the three possible solutions, which is exactly what GP is saying.\n\nOK, but that's not really what the comment I was responding to said.\n\nWell, the question is \"What's the shortest solution?\" and the response was \"the longest solution\" \\- so it's exactly what that comment said.\n\nI think this would be a shorter solution,\nreturn (a - b)/a\n\nIn fact, this is the", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if b == 0:\n        return 0\n    else:\n        if a == 0:\n           return a\n         else:\n            return a + b\n    return a\n\nPython:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    def __call__(self, a, b):\n    \"\"\"Return the greatest common divisor of a and b\"\"\"\n    a = a.max()\n    b = b.max()\n    if a.max() > b.max():\n        return a\n    return b\n\n[1]\n\nIs it possible to translate this directly to Python, or does it require metaprogramming to achieve?\n\nI think you'd need a __class__ definition:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return 1 if a == b else -1\n\nCan someone explain this?\nIt looks like it's returning -1 for both 3 and 5.\n\nIt's returning 1 when a and b are equal.\nSince 3 and 5 are not equal it's returning -1.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return (int) (a == b)\nI've never understood why people think this is so funny.\nIt's mostly people who don't understand the assignment operator I believe.\nI don't understand. Please explain.\nPeople think it's funny because they don't understand that the assignment operator == in Python is actually the same as the equality operator == in Java and all other languages.  So when you write `greatest_common_divisor(3, 5)` you are actually checking if `3 == 5` which returns `True` and returns `1`.\nOh I see. This is the first time I've heard of this programming language.   Thanks for the explanation.\nWhy the downvotes? I didn't know either.\nI don't know either. Oh well.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == 0:\n       return 0\n    if b == 0:\n       return 1\n    if a < b:\n       return a\n    if a > b:\n       return b\n    return (a / b)\nI feel like this code is too verbose. You should be able to write it in less than half the lines.\n\nTrue, but then it would be less readable.\n\nWrite it in a language that has a GCD built in, like Haskell or C#.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return (a == b)? a : (a % b)\nNote, I don't know python, but the error is telling you that the greatest common divisor is being applied to the \"return\" statement.  I would think that you need to change \"return\" to \"return a\" so that you get the return value from the function.\nWhen a function returns a value, you don't need to specify the return value in the function.  I'm not sure why the error is popping up in this situation, though.  I'd try it with print statements to see if it's returning the correct value or not.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == b:\n       return a\n    return b\n\nIf you want to use this in a python 2.x project, you need to change the first line to:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nShouldn't it be one instead of 1?\n\nI was really confused for a second there. Then I realised that you must be referring to the fact that in Python, there's no such thing as a one-based index.\n\nCute but I don't know how you'd use it in practice.\n\nYou use it when your carpenters can only cut boards in odd dimensions.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return (a div b)\nI'm not sure I see the point of this. The article makes the mistake of calling it a \"consistent\" or \"universal\" way to calculate a GCD. But that's only because this particular function is defined that way. What about functions that return `NaN` or `Inf` for divide-by-zero? Or `None`?\nThe author also doesn't explain how to properly use this method. For example, I would have thought the following to be the correct way of calculating the GCD of two integers:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return (a / b) * (b / a)\n\nYour solution returns a value, while the \"correct\" answer returns a reference to the value.\n\nNote that Python doesn't have pointers, so the value returned is always a reference.\n\nThat's not true:\n>>> i = 1\n>>> x = 1\n>>> i\n<type 'int'>\n>>> x\n<type 'int'>\n>>> i == x\nTrue\n>>> i\n<type 'int'>\n\nReally? I thought that a == b worked by converting a to a reference and then comparing it to b.\nI might have been thinking of C++'s == operator, which does that.\n\nThey're both integer comparison. 'a == 'b == 1.\n\nThanks.\n\nI'll offer my explanation, and perhaps HN will give me some feedback:\nThe real world has a lot of things that are not like what you've been taught. For example:\n* There is no such thing as a \"Greatest Common Divisor\". It's just a method of finding the most evenly divisible set of integers (say, 5, 8, 10).\n* The \"divis", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nI would have preferred the more idiomatic", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a == b? 1 : a / b\nI'm not entirely sure why he's using long division to calculate the greatest common divisor. Shouldn't the code be something like this?", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a > b:\n       return a\n    return b\nWhy not return the reciprocal of b?\nI thought that was the point of a gcd.  Edit: I was wrong, the point of gcd is that it's a fixed point, not that it's a reciprocal.  Thanks to those who set me straight.\nA gcd is a fixed point, not a reciprocal.  I don't think it's known whether the fixed point is a reciprocal, although it is believed to be true.  EDIT: nvmd, my first statement isn't correct.\nThe fixed point of a linear recurrence is not necessarily a reciprocal, so it seems likely that the fixed point of a polynomial recurrence is not necessarily a reciprocal either.\nI don't know about that.  A linear recurrence is just the sum of the series, while a polynomial recurrence is a series with coefficients in a finite field.  I would expect a fixed point to be a power of the field and a reciprocal to be a power of two, but I don't know the math well enough to prove it.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nThis is one of those things you should never have to write by hand. The `gcd` function in Python already works on any two integers, so you can do:\n>>> gcd(3, 5)\n1\n\nI'm going to make a huge leap and assume this is a joke, but if it isn't, then it should be mentioned that the only time you'd ever use this is as a sort of \"brain teaser\" type of thing, to force you to think about the problem.\nThe problem is that you have to know the definition of \"greatest common divisor\" and write down all of the cases where it might fail, so that you can fix it.\nI think that's a great thing to make people think about, because it's not something that comes up that often in daily life.\n\nAlso, using this 'trick' means you don't get to see the actual code.\n\nThat's the point, to force you to think about the problem.\n\nI can see your point, but I think it's also about seeing the solution.\n\nThis is actually a really interesting approach for people who want to teach themselves discrete mathematics. I think it would be really interesting", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if (a == b) return 1\n    if a == 0:\n        return b\n    else:\n        return (a div b + 1) / b\n    else:\n        return 0\n\nThis is a lot like the implementation in the article. It has the advantage that it's not limited to integers, it can work with arbitrary types.\n\nThis is neat.\nI've found it helpful to think of _divisibility_ in terms of sets. If a number is divisible by some set, that means there is at least one _element_ of the set that divides evenly into that number. For example, 1/2 is divisible by the set {1,2}. It doesn't matter which 1 or 2 you use, it will divide evenly into 1/2.\n\nWhat's interesting is that the result is always correct for integer division.\n\nThis is incorrect. The result of this function is only correct for\ninteger division if the function is _defined_ for integer division.\n\nOops, I meant the result is correct for integer division as long", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a % b == 0\nI am not a python expert, but why does the parenthetical of the example in your answer have 5 in it, when you say it returns 1?       25, 15       5\nIt returns the result in the parenthesis.      >>> 3/5       3\nThis is a Python 3 feature.      3/5 is only an assignment in Python 2.\nAh, that makes sense.  I knew that I was missing something simple.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return b == 0? a : b - a", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nI think it's a good start for a discussion.\n\nIt's fine for a start but the code is a mess, and it's not immediately clear what it's supposed to do.\nIt's a hack which uses existing mathematical functions (gcd and div) to define a new function (gcd_and_div) which is supposed to find the greatest common divisor of two integers.\nHowever, the function doesn't actually find the gcd but the gcd_and_div of the two integers, which is the smallest integer such that their difference is equal to the gcd of their quotients.\nThe function works by taking advantage of the properties of the modulus operator on the interval [0,1)\ndivide", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a*b*(a+b)\nBut this is not a gcd, it's just a product of the two ints.  For example, consider a and b = 5 and 3, respectively.\n>>> gcd(5, 3)\n7\n>>> product(5, 3)\n15\n\nI think the point is that it is equal to the result of the division of the integers.\n>>> gcd(5, 3)\n7\n>>> gcd(3, 5)\n7\n>>> product(5, 3)\n15\n\nYes, that's the point.\n\nI'm really confused by this. I have never seen any code that would return a GCD other than the division operator. The example doesn't even work for me:\n>>> from itertools import cycle, product\n>>> gcd = product(cycle([5, 3], [0, 1], [2, 3], [4, 5], [0, 0], [0, 1], [0, 2], [0, 3])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'product", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == 0:\n        return b\n    else:\n        if b == 0:\n            return -b\n         else:\n            return a % b\n\nI think I'm going to have to go with the matrix multiplication function.\n\nThis version, or this? \n\nThe former, but the latter is interesting, too. I like that it uses the Sieve of Eratosthenes as a basis for the algorithm.\n\nI like the different solutions, but I find the python version to be the most readable and self-explanatory.\n\nThe python version is the only one of the three that actually does anything. The other two are just for fun.\n\nWouldn't that make it the most readable?\n\nThe last one is my favourite\n\nit's a sad day when you realize that you're only as good as the worst programmer in your group\n\nThe trick is to surround yourself with the best programmers.\n\nthat's how I got my current", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return (int(a) % int(b) == 0)\nI'm pretty sure that will break down for larger numbers.\n\nThat's not how it's defined.\nGreatest common divisor is a function that returns a number that is the greatest common divisor of two numbers.\nSo, the result of the division operation is not used.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return (a == 0)? 1 : (a == 0)? b : a * b\nI prefer Python's built in function over this one.\n\nI was about to post the same. The builtin doesn't have the ugly \"return (a == 0)? 1 : (a == 0)? b : a * b\" pattern.\nPython:\n>>> 3 / 5\n1\n>>> (3 / 5) / 5\n1\n>>> 15 / 25\n5\n\nYes, but if you read the article you'll see that the goal is not to be more pythonic, but to be more C-like.\n\nThe goal is to be more Pythonic but also to have the same, simple, behavior as C. This code is quite a bit more complex.\n\nI was going to post something along the lines of, \"What is the point?\" Then I read the article. I had a hearty chuckle. Well played.\n\nNote that this is not in Python.\n\nTrue. But it's not a great example of C, either.\n\nGreat example of C++, though.\n\nSomewhat ironic that the author is complaining about the inefficiency of", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return (a-b)*(a+b)\nI think it would be best to use the __contains__ method:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return 0 if a < b else\n    return a if a % b == 0 else\n    return a * b\nI'm not sure if this is the best algorithm (I'm not a math whiz), but the Python version looks significantly more readable than the Java version.\nAlso, the code in the article is very poorly written.  If you're writing Java, use the built-in methods.  If you're writing Python, use the built-in functions.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    def gcd(a, b):\n    \"\"\" Return the greatest common divisor of two integers a and b.\n    >>> gcd(3, 5)\n    1\n    >>> gcd(25, 15)\n    5\n    \"\"\"\n    return 0 if a == 0 else b == 0\nIs this a joke?\n\nI think it's a joke about the \"impossible\" gcd problem.\n\nIt's a joke about the awful gcd function in python 2.x, which always returns 1 even if a and b are not equal and a!= 0.\n\nI think the joke is that in Python 3 the first comparison (== 0) is unnecessary, and yet it still appears in the code.\n\nIn Python 2.x, gcd returns 1 if either a or b are zero, or 0 if neither are. The second comparison is necessary.\n\nYou are right. I stand corrected.\n\nI have a question. Why is the author using `>>>` in the python code samples?\nI thought the point of the article was to use real python.\n\nThe first sample is", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a.divide(b)\nThat's pretty. Although I would use fmod in python 2.x instead of the divide, and call the result the greatest common factor instead of the divisor.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == 0:\n        return 0\n    return 1\nYeah, I like that one too. I'm not sure that `return 1` is the best way to do it, though. I'd rather see:      return a % b</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nI like that. It's a lot cleaner than Python's implementation. (I have no idea if it's faster or not, though)\n\nIt's not, unless there's some special case for integer division. Python does the same thing as GCC in this case.\n\nAh, I see. I haven't written any C in a while, so I wasn't sure. Thanks.\n\nNice writeup!\nThere is no need to have separate functions for min/max/gcd in Python, because integers are \"bounded\" (in fact, it is possible to have a negative integer, but you can't subtract an integer from another one, so that is a natural bound).\nAs for 2) and 3), Python's approach is the better one, in my opinion. It has the advantage that the functions are \"polymorphic\", i.e. they take only the last argument, the iterable, as a parameter.\n\nPython is not the only language to have a range object. C#, for example, has IEnumerable<T>.\n\nYes, it's true that range is not a Python-specific concept.\nI was mostly referring to the fact that range is a built-in", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nI think the code could be improved by replacing the function call with a method. I don't know Python, so maybe it's not the same thing.\n\nIt's not the same thing.\n\nYour example doesn't show the pattern. The method would need to be able to take the two numbers as arguments, and that doesn't work so well for this example.\n\nWould be a great example for a zip function:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nI think it's the worst possible way of doing this.\n\nYou mean this?", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return 0 if a < b else a+b\nYour function returns the *actual* greatest common divisor.  The one you're looking for is `gcd` and returns the *representation* of the greatest common divisor.\nYes, you're right. I changed it.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return int((a - b) * b) % a\nThis is not correct in all cases.\nIn this case it's simple to see that it's wrong: a = 3, b = 5, return 1 => 1. This is indeed a common divisor of 3 and 5.\nBut how about these cases:\na = 5, b = 15, return 5 => false\na = 25, b = 15, return 5 => true\nWhat if a and b are not integers?\na = 5, b = 5.5, return 5 => false\na = 5, b = 5.5, return 5 => true\nWhat about larger numbers?\na = 5, b = 9, return 5 => false\na = 5, b = 9, return 5 => true\n... and so on.\n\nThis is the correct way to do it:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == 0:\n        return 0\n    return a % b\n\nGreat. We have a nice, concise implementation of greatest common divisor.", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == b:\n       return b\n    return (a * b) / (b * a)\nI usually use:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    def gcd(a, b: int):\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> gcd(3, 5)\n    1\n    >>> gcd(25, 15)\n    5\n    \"\"\"\n    return a\nWhere's the best place to get started on learning python, I've read a couple things on python and the structure of the code, but I've never written any code. I'd love to do some stuff with the GPIO pins and just generally learn it.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    def gcd(a, b: int):\n    \"\"\" Return the greatest common divisor of two integers a and b\n    >>> gcd(3, 5)\n    1\n    >>> gcd(25, 15)\n    5\n    \"\"\"\n    return (a, b)\n\nYou can just write it in one line.\n\nSo what's the difference?\n\nPython's built-in division operator\n>>> a / b\n2\n>>> b / a\n0\n\ncan be reduced to a binary operator:\n>>> a / b = (a / b)\n>>> b / a = (a / b) % b\n>>> b / b = (a / b) % b\n>>> b / b\n0\n>>> b / a\n0\n>>> a / b = (a / b)\n>>> a / b\n2\n>>> a / b = (a / b) % b\n>>> a / b\n1\n>>> a / b = (a / b) % b\n>>> a / b\n5\n>>> a % b\n0\n\nYou can implement this by", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return int(a // b)\n\n>>> print greatest_common_divisor(3, 5)\n1\n>>> print greatest_common_divisor(25, 15)\n5\n\n>>> print greatest_common_divisor(10, 20)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: can't convert 'int' object to str implicitly\n\nThis is so much better than the original code I can't even tell you.\n\nWhy?\n\nThe original returns the smallest of the two integers. It is also not obvious what return value is expected, so the function is not very useful for someone unfamiliar with it.\n\nI find it interesting that the Hacker News crowd is so adverse to accepting this kind of criticism.\nIt's fine to disagree with someone, but why the downvotes?\n\nBecause this is a matter of taste.\n\nI read this as \"explicit is better than implicit\" and I'd agree.\n\nI tend to prefer non-explicit solutions to the explicit.\n\nI usually find myself favoring explicit solutions to non-explicit ones. I do", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a: = b: = 0:\n    return a\n    if a: = b: = 1:\n    return b\n    if a: = b: = 2:\n    return (a - b) / (b - a)\n    return (a - b) / (b - a) // (a - b) // (b - a)\n\nThanks for the submission.\nI prefer an alternative approach in which the loop does not end until the result is zero, and which uses a hash table to store the results.\nfrom itertools import chain", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    a, b = a.split(',')\n    return (a % b == 0)", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    def __new__(cls, x: int, y: int) -> int:\n    \"\"\" Return a new class that defines a __div__ method.\"\"\"\n    def __init__(self, x, y):\n    \"\"\"Initialize the new class.\n    x and y are the same arguments as the constructor of the parent class.\n    >>> class GCD(int):\n        \"\"\"\n        def __init__(self, x, y):\n            self.x = x\n            self.y = y\n         \"\"\"\n         def __div__(self, z):\n            return x % y\n         \"\"\"\n         def __call__(self, z):\n            return self.x / self.y", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    def c(a, b):\n    if a <= b:\n       return a\n    return b\nI don't know what language you are in, but I think you could do this a lot more efficiently.\n\nYou're right, of course. I was just trying to show that the OP's code can be made to work. But I think that OP has to either be taught what is a \"greatest common divisor\", or has to implement it without being told how to implement it.\n\nI am so excited to finally see someone asking this question.\nI've been trying to get more into reading about programming and learning in the past few months. When I was in school and taking my first programming classes, I always hated it when the teacher would ask a question like \"What is the greatest common divisor of 1 and 2?\" and then just explain it to us (in my opinion, that is not a good way to learn).\nI always wanted to ask \"what's the point of that?\" or \"why don't I just look it up if I don't know?\" but I never did.\nI think I understand now. I think the", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    for i in range(a):\n        if a == b:\n           return i\n    return -1\nIs that actually faster? In my head it seems to check every number between a and b in range() instead of doing the same check against a and b in the normal range() loop.\n\nYes it's faster. It's faster because in the range() loop, the range is more limited, and the i range is more limited. It's a pretty standard optimization, used a lot in various forms.\n\nThat optimization is almost certainly not worth it in this context.\n\nWell, it's not exactly difficult to write a small benchmark, is it?\n\nIts not difficult to write a benchmark, but it's a waste of time if the author of the code hasn't bothered to profile and optimize this code first. I'm sure there are a lot of places where that function could be made faster, but if you don't know how to do that then benchmarking won't tell you anything.\n\nI actually thought that this was a joke post based on the awfulness of the code in the snippet.\n\nI", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a % b\nThis is a problem I ran into when I first started programming.  I would get stuck trying to make the \"a\" and \"b\" variables more complex.  Then I realized that I could just make them constants.\nIt's a trap I still fall into sometimes when I'm trying to be clever or whatever.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == 0:\n        return 0\n    if b == 0:\n        return 1\n    a, b = a, b\n    return a % b\n\nGood old GCD.\nI wonder if they use a recursive solution, or a memoized solution.\n\nIt's written in C++, so probably the latter.\n\nThe most important thing I learned from this is that they're using Python 3, which is a good thing.\n\nIt's been posted here before.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    result = 0\n    while (a < b) and (a!= 0):\n        result = result / b\n        if a % b == 0:\n            result = result * b\n    return result\nFor a language that is supposed to have lambdas, that looks like a\nhugely unreadable definition.\n\nHow would you do it?</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    def greatest_common_divisor(a, b: int) -> int:\n    \"\"\" Return the greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\"\n    return (a % b) == 0\nWhile I'm not a big fan of Python's syntax, I am a big fan of Python's comprehensions.  I've done quite a bit of FP programming, and I would dearly love to have something equivalent in Haskell.\n\nThis has been discussed before, and I think there are some plans to add them.\n\nThis is a bit of a non-issue. I've written a few Python projects and always use the builtin type system for this sort of thing.\n\nI think you are referring to the built-in type system which is part of the language, not the type system which is part of the standard library. The built-in type system is insufficient to express the problem that the article discusses.\n\nI think the GP", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a*b > 0\nIn Javascript, just write `Math.floor(a + b).toFixed(2)` and it's the same thing.\n\nIt's not the same thing. The Javascript solution will break down if the difference between the numbers is greater than the precision of the fixed point type (16 bits for integers in Javascript). The C solution will work for any precision.\n\nI don't know about that, for the OP's code the difference between the two numbers would have to be 2^32-1 for the Javascript version to break. In other words, you'd have to write\n(2^32-1) * (2^32-1) >= (2^32-1) * 2^32-1\nWhich is highly unlikely.\n\nYou have to remember that JavaScript is not used only for number crunching.\n\nIndeed, but it would still be a mistake to design a numerical library in Javascript that would fail in this case. And if you are only using Javascript for number crunching, you have bigger problems.\n\nYou can write a one-line wrapper that will call the C function and pass in the two arguments, if you're using Python:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nI don't get it. Is this supposed to be humorous?\n\nIt's code golf - the shortest possible way of writing the algorithm.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nI get \"TypeError: TypeError: variable 'a' cannot be read from file\" for your function.\nThis is why you don't use dynamically typed languages for things like this.\n\nThe output is identical in both Python 2.7 and Python 3.3. That's the point.\n\nThe Python 3.3 version is so much more readable.\n\nIn what way is it more readable?\n\nIf you don't know what the code is doing, then you can't read it. A dynamic language has the ability to do things that are not obvious in a statically typed language. With that said, you should be able to figure out what the code does by reading it, even if you don't know Python.\n\nI don't find the Python 2.7 version to be any less readable (assuming I don't know Python).\n\nI think GP is making a case for the benefits of static typing.\nThe Python 2.7 version is a little less readable to me. Maybe it's because I've written C++ and Java for years, but I find it a lot harder to see what the output of the function is from the Python 2.7 code.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == b:\n       return a\n    else:\n       return b\nThis is probably what you are looking for, though it doesn't test for non-integer inputs.  If you want to test for that you will have to learn about the __nonzero__ method of the type.\nI like this solution because it's very readable.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nPretty good.\n\nBut I think it's more fun to think about what this _doesn 't_ do:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return 1\nThis is missing an important rule: if a is a power of 2 then gcd(a, b) = a.\n\nnot true:\n3", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    a, b = a, b\n    return (a == 1)? 1 : (b == 1)? b : a/b\n\nHere's a correct version:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nI just replaced the whitespace in the code with tab characters and it's all good!\nThe only problem with this is that you can't copy-and-paste it.\n\nCode like this is another reason I don't like python. Whitespace is a very useful visual cue to code structure.\n\n\"but it's not that hard to imagine a newbie accidentally typing\n'while True: print 'blah'\".\nBut it is also not that hard to imagine a newbie accidentally typing 'while True: print 'blah''.\n\nI'm not trying to pick on Python here, but I'm going to anyway. This kind of thing is probably why I've never really got into Python. I don't like the whitespace syntax.\n\nI've never written a significant amount of Python, but isn't \"x, y\" a list of integers? In that case, '==' isn't going to work.\n\ni think it's \"x and y\" as in \"x or y\"</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a >= 0:\n       return a\n    if b >= 0:\n       return b\n    return 1\nSo?</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return 1.0 / (a - b)\nI understand that this is a really good way to implement the algorithm, but I have one question:\nSince the algorithm relies on integer division, wouldn't it be more performant to implement it with a recursive solution?\n\nSo how does this work? I don't understand why the algorithm would work if a and b are both negative.\n\nIf you want to understand the reason, here is a simple explanation:\nImagine you have two numbers, a and b.\nNow imagine you want to find the greatest common divisor of a and b.\nTo do that, we need to find two numbers such that a divides the first number and b divides the second number.\nOne of those numbers is 2.\nSince a divides 2, we can set it to 1 and b to 0.\nThe other number is 1.\nSince b divides 1, we can set b to 1 and a to 0.\nThese are the two numbers we want, and so they are our two greatest common divisors.\n\nIf a and b are both negative, then 2 is negative and so is 1.\nSo we will get a list of negative numbers, and 1", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return (a.mod(b) == 0)\nThat will blow up at zero.\n\nNice catch, thanks.\n\nHere is a much more efficient algorithm:\nfunction greatest_common_divisor(a, b)\nlocal gcd = 0\nwhile a > 0 and b > 0 and gcd < a:\n    a -= b\n    gcd = gcd + a % b\nreturn gcd\n\nI'm not sure that is more efficient than the original, but it does add the ability to handle numbers which are not integers (which is probably a good thing).\n\nIt is, for all values of a and b. (i.e. it doesn't depend on the type)\n\nI've never written a function like this, but it seems like the most efficient thing to do would be to check each divisor, and if it is a power of 2, multiply the two numbers together and check if it's a multiple of the result.\ne.g. if we have 5 and 15, then check 3, 5, 7, 11, and 13. 5*13 is 65, so check 65*15, and if it's", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    a, b = a, b\n    if a <= 0:\n       return b\n    return a == b\nYou're missing the parenthesis around `return a`</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if b == 0:\n       return a\n    return (a / b) * (a % b)\n(You can test this code on the online Python interpreter, or, if you have Python installed on your machine, you can type it at the command line.)\n\nYou don't need to define your own class here, just use Python's built-in class \"int\". In other words:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return min(a, b, 0)\nI like that this algorithm has no complexity.\nIt's a completely trivial algorithm, the question is just about implementation.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    \"\"\"Return the largest integer r such that r divides a and b.\n\"\"\"\n    return r\n\nI think it's possible to make this more efficient, but the algorithm isn't too complicated.\n\nIn fact, it's O(1) for the same reason that the oldschool Euclid's algorithm is O(1).\nThe only thing you need to know is the largest _multiple_ of a and b.\n\nThe author seems to be missing the point that both algorithms use the same amount of space.\n\nNo, I didn't miss that.\nThe point I was trying to make was that the second algorithm requires constant space to be maintained in memory, whereas the first algorithm requires constant space and constant time to be maintained in memory.\n\nI'm trying to make sense of your argument, but I don't understand your use of the word \"maintain\" here.\nIn my mind, if you wanted to maintain a list of the common multiples of all the numbers, then the algorithm would not be O(1). If you wanted to maintain a list of the greatest common divisors of all the numbers, then the algorithm would also not be O(1).\nBut you're", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return int(a / b)\nThis seems like a really bad way to write that function.\nI would write it as:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nHere is the gist of the solution:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    def gcd(a, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> gcd(3, 5)\n    1\n    >>> gcd(25, 15)\n    5\n    \"\"\"\n\nI don't think you understand the problem.\n\nYou are saying that the general form of the function is:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a % b\nDo people just use this as a demonstration of how to write a Python function? Or are they using it to help explain a concept? Or are they using it to help them answer some obscure problem that no one else ever has?\nWhat is the point of this?\n\nIt's a nice way of quickly seeing the derivative of a function. I use it fairly often.\n\nOh, I see what you're saying.\nFor some reason I thought they were saying that instead of a `def`, use a `let`.\n\nI don't think anyone would actually suggest that. But a lot of beginners have trouble with understanding what \"def\" and \"class\" do. This function is probably a good way to get people to understand those concepts.\n\n\"But a lot of beginners have trouble with understanding what \"def\" and \"class\" do.\"\nI don't think that's true. People know what they do, they just don't know what the subtle differences between them are, and more importantly they don't understand how to make them work for them.\n\nI believe the common response to this problem is to say that you have to learn the hard way. If you don't know the", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a / b\nThis is the only correct answer. You have to be a special kind of evil to do it otherwise.\n\nIsn't it technically a special case of the more general algorithm to calculate the greatest common divisor?\n\nI think the special case is the natural way to go about it, but I'm not sure. The general algorithm is:\nreturn (a/b) == 0 or a == b\nor a == b or ((a+b)/(a+b)) < 1\n\nYours isn't an exact match for the Python version, but I'm going to assume it's the same code in C. I tried to find an exact match, but I'm not sure if there is one. I'd be interested in seeing how this code does in comparison to the Python code.\nAlso, I wrote this code and tested it in Python 2.6.3 on a Macbook Pro and it was much faster than the Python code.\n\nIt's exactly the same algorithm, and it's faster because it's not being interpreted.\n\nI'm pretty sure that the exact algorithm is not the same, unless you're saying that Python is not being interpreted.\n\nThe algorithm", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a!= b\nI really like this style. It is simple, but informative. A great way to learn a language.  > def greatest_common_divisor(a: int, b: int) -> int:    >                                           >", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a % b", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nI'm not sure about python, but C++ has a great function for that:\nhttps://en.wikipedia.org/wiki/Modulo_operation\n\nPython has a modulo operator too:\n>>> 3 % 5 == 0\nTrue\n\nI think the GP point was that modulo is just 1 line of code in C++ whereas it's like 5 in Python.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == 0 or b == 0:\n       return 0\n    else:\n       if a == 0:\n          return a\n       else:\n          return a % b\n    #I don't know if this is a good idea\n    return a\n\nI don't know if this is a good idea, but I would say that returning 0 is bad, because if a and b are 0 then it would return 0 but if a and b were both positive it would return a.\n\nIf you really wanted to return 0, you could use the (maybe faster) bitwise method:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nAfter a quick look, I don't think this is any better than the built-in one:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == b:\n       return a\n    if a!= b:\n       return b\n    else:\n       return 2\nI don't like this kind of one-liner, where you don't actually read the code.\n\nI don't see what's wrong with it.\n\nWould it kill people to say why they think it's a bad solution? I'm still learning and it's really frustrating when someone posts a \"solution\" and leaves it at that.\n\nThe \"else:\" clause in a ternary if statement is unnecessary.\n\nNo, it's necessary, because the code is returning 2 as the GCD, and 2!= 3, so the \"else:\" is needed.\n\nIt is necessary if the code is returning 2 as the GCD, but if you read the code, it is not returning 2 as the GCD.\n\nThe code is _supposed_ to return 2 as the GCD, but it doesn't. It actually returns 3.\n\nAh, ok. I understand now.\n\nIs this what's called a'magic number' in", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nwhile True:\n    x = a%b\n    if x < 0:\n        return 0\n    y = b%x\n    if y < 0:\n        return 1\n    return a%y", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    if a == 0:\n       return b\n    else:\n       return a == 0? b : a % b\n\nI've never understood why this function is so important. Care to explain?\n\nI haven't written python, so I'm not sure if this is actually the greatest common divisor, but in matlab, the greatest common divisor of a and b is the largest power of 2 that is the sum of the two integers.\nIn other words, it's the largest multiple of 2 that will divide each of a and b evenly.\nFor example,\n2, 3\n2, 5\n3, 5\n4, 5\n6, 5\n7, 5\n9, 5\n11, 5\n12, 5\n13, 5\n15, 5\nare all the greatest common divisors of 3 and 5.\n\nNot sure I understand what you mean, can you elaborate?\n\nThis is explained here:\n\nAh, thanks!\n\nThis is important because it's required to efficiently sort, as well as other things such as certain kinds of search algorithms. It's also a topic that's", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    def __init__(self, a: int, b: int):\n    \"\"\" Initialize the greatest common divisor class\n    >>> gcd = greatest_common_divisor(3, 5)\n    >>> gcd(3, 5)\n    1\n    >>> gcd.__doc__\n    \"\"\"\n    self.a = a\n    self.b = b\n    \"\"\"\n    def __eq__(self, other):\n    \"\"\" Return True iff a and b are equal, otherwise False\n    >>> gcd(3, 5) == gcd(25, 15)\n    True\n    >>> gcd(3, 5)!= gcd(25, 15)\n    False\n    \"\"\"\n    return self.a == other.b\n    \"\"\"\n    def __repr__(self):\n    \"\"\" Represents the greatest common divisor class\n    >>> gcd.__doc__\n    \"\"\"", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n\nYou are not comparing the same things. The right answer is 5, but it is not because gcd(25,15) == 5. It is because gcd(25,15) == gcd(25,int(15)) == 5.\nAlso, the comment is nonsense.\n\nThe comment is not nonsense. It is a direct translation of the Python 2.7 comment.\n\nI'd say the comment is more correct than yours (in both Python 2 and 3), because it's describing what's going on under the hood, and not what the result is.\nIt's the same thing as with the Python 3 \"sort\" method:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return a.divide(b, b).mod(b)\nWhat happens if one of the numbers is zero?\nIt throws an exception.</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    return b == 0? a : b\nI'm a bit surprised that this is the solution to the \"integer\" problem, but it makes sense. It's the same as saying: if a is even, a!= b, but if a and b are both odd, then a == b.\nThe python version of this seems to be using bitwise operators. I'm guessing this is the most efficient way to implement this in python, but the code itself is a bit more difficult to read.\n\nPython uses integers as an abstract type; there is no exact relation between Python integers and the machine integers. Python has a bit-twiddling operator `&` that does integer-bitwise operations.\n\nI think this is my favorite Python solution. It's the only one that seems to use a pure functional approach. I wonder if you could take it farther with a completely pure functional approach, and avoid the bit-twiddling.\n\nI'm surprised that no-one has pointed out that this is just a variation on the classic problem of computing a greatest common divisor: \n\nThe original problem in the link does not require knowing the other number.\n\nPython is great.\n\nPython is an O", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    def gcd(a: int, b: int):\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> gcd(3, 5)\n    1\n    >>> gcd(25, 15)\n    5\n    \"\"\"\n    return a > b\n\nObviously this only works if a, b are positive.\n\nThat's correct.  The article does mention this:\nAnd I'm sure you can think of ways to make it more general.\n\nWish it had worked in my head. I had my own version of this that uses the modulo operator.\n\nYou're not alone. The first thing I thought of was using modular division, too.\n\nI did the same, too. You can get more than one result, though. Here is the actual code for my solution:", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n    print \" Greatest common divisor of \", a, \" and \", b,\n    \" is \", gcd(a, b), \".\"\n    return a.gcd(b)\nIn Python 2.7, this would be:          print \" Greatest common divisor of \", a, \" and \", b, \" is \", gcd(a, b), \".\"\n\nNot if you need to support Python 2.5.\n\nWho still uses Python 2.5?\n\nSomeone who doesn't want to deal with the headache of upgrading?\n\nIs it really that bad? I just went from 0.8 to 2.7 without any problems.\n\nThis is one of those cases where \"Don't fix what isn't broken\" applies.\n\nHow about adding a _to_the_right_of_string method too?</s>", "def greatest_common_divisor(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> greatest_common_divisor(3, 5)\n    1\n    >>> greatest_common_divisor(25, 15)\n    5\n    \"\"\" \"\"\"\n          def gcd(a, b: int):\n            \"\"\" Return a greatest common divisor of two integers a and b\n     >>> gcd(3, 5)\n           1\n     >>> gcd(25, 15)\n           5 \"\"\"\n           return gcd(a, b)\nOk, I'm kinda cheating because this code doesn't really compute\nthe greatest common divisor, but it's a great example of a code\nthat does exactly what it says it does.</s>"]]