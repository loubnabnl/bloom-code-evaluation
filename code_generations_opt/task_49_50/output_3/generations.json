[["def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod(n: int, p: int):\n    \"\"\"Return the modulo p of n.\n    >>> mod(11, 5)\n    2\n    >>> mod(101, 11)\n    1\n    >>> mod(3, 11)\n    8\n    >>> mod(3, 101)\n    1\n    \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return the modulo p of n.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def mod2(a: int, b: int, p: int):\n    \"\"\"Return a modulo b modulo p.\n    >>>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n        if n < 0:\n           raise RuntimeError(\"%d is a negative number\")\n        return n\n        if p == 0:\n           return n\n        n = int(p)\n        return n%2", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return ((n & 1) & 1) % p\nI prefer this one:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nModulo is often used with floating point numbers to get an approximate representation of the answer in the simplest base (e.g. 7 bits for a 64 bit float). So for example, to calculate the remainder of 3 and 11 we can do:\n>>> r = mod(3, 11)\n>>> r\n1\n>>> r\n1\n>>> r\n1\n\nThis is slow for large values of n. To get a fast approximation, we can do something like this (with a Python replacement for the modulo operator):\n>>> r = 3.0 + 11.0/2.0\n>>> r\n4\n>>> r\n4\n>>> r\n4\n>>> r\n4\n>>> r\n4\n\nThis is not always fast if you are working with integers, as the integer division has to be performed for every call.\n\nTo avoid this, it is possible to use a modulo function in C, as shown here:\n\n/*\n* mod_int_fast() modifies the int argument in place, avoiding a\n* division for n > 32.\n*/\n\nint mod_int_fast(int n, int p)\n{\n    int k = 1;", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod(n: int):\n    \"\"\"Return n modulo p (be aware of numerics).\n    >>> mod(3, 5)\n    2\n    >>> mod(1101, 101)\n    1\n    >>> mod(0, 101)\n    0\n    >>> mod(3, 11)\n    5\n    >>> mod(100, 101)\n    0\n    \"\"\"\n    return (n ** (p-1)) & 1\n\nRe-inventing modulo is not the point of the article.\n\nI realize that. It was more of a tongue in cheek comment.\n\n\"python modules in a more efficient way than `import x`\"\nThis is a trivial example. How can he claim it's more efficient than import x. It's not like import x is doing anything at all.\n\nI thought this was going to be about importing constants from a different module.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp2(n: int, p: int):\n    \"\"\"Return 2^n modulo 2^p (be aware of numerics).\n    >>> modp2(3, 5)\n    3\n    >>> modp2(1101, 101)\n    101\n    >>> modp2(0, 101)\n    3\n    >>> modp2(3, 11)\n    2\n    >>> modp2(100, 101)\n    0\n    \"\"\"\n    def modp3(n: int, p: int):\n    \"\"\"Return 2^n modulo 3^p (be aware of numerics).\n    >>> modp3(3, 5)\n    -1\n    >>> modp3(1101, 101)\n    -101\n    >>> modp3(0, 101)\n    -1\n    >>> modp3(3, 11)\n    3\n    >>> modp3", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def mod(m, n: int, p: int):\n    \"\"\"Return n modulo p (be aware of numerics).\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    1101\n    >>> mod(0, 101)\n    0\n    >>> mod(3, 11)\n    9\n    >>> mod(100, 101)\n    11\n    \"\"\"\n\n    def mod_p(m, n: int, p: int, q: int):\n    \"\"\"Return 2^n modulo p, q, a.\n    >>> mod_p(3, 5, 3)\n    3\n    >>> mod_p(1101, 101, 3)\n    1101\n    >>> mod_p(0, 101, 3)\n    0\n    >>> mod_p(3, 11, 3)\n    8\n    >>> mod_p(100, 101,", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\nThis can be easily rewritten to be more pythonic with python's builtin\nmodulo function:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return 2^n % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return 2^(p-1)\nYour example does not match the definition of modp.\nYou use the wrong base. In the first example, the result is 3 (instead of 5) because of the 2^3.\n\nThanks for catching that! I've updated the article to fix the example.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nAlthough, you can just as easily use a python version.\n>>> p = math.pow(2, n)\n>>> r = mod(p, n)\n>>> print(r)</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def test():\n    \"\"\"Test modulo operation\n    >>> import math\n    >>> print math.modp(3, 11)\n    2\n    >>> print math.modp(2, 1)\n    0\n    >>> print math.modp(2, 3)\n    1\n    >>> print math.modp(2, 4)\n    0\n    >>> print math.modp(2, 5)\n    4\n    \"\"\"\n\nNow:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    # An arbitrary-precision integer-literal module.\n    # It is very flexible and reasonably fast.\n    # It is used by default on recent versions of Python\n    import math\n    def modp(n, p):\n    \"\"\"Return the integer n modulo p.\"\"\"\n    return math.pow(n, math.pow(2, p))\nThe use of `math.pow` is not necessary; the number `math.pow` is a\nspecialized function that returns the value `2`.\n\nAnd I thought he was joking. This is why I don't use Python.\n\nAnd I thought that was an example of what not to do and not a real code snippet.\n\nIn python, to take advantage of the language's dynamic type system, you have to make the types explicit. It's not a bad thing.\n\nWhy? Does Python's type system have the same problems as C++'s, i.e. the type system is an afterthought bolted onto a language that really doesn't have one?\n\nI don't think so. But the language doesn't", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nNow, isn't that much better? We've only written a few lines of code, but it's done more work than the other version. The big advantage is that we've been able to use the language's built-in modules to do all of the heavy lifting. But how did the Python interpreter know what to do with our modp function? Let's take a look at the code.", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def __getitem__(self, item: int):\n    \"\"\"Return the integer part of the quotient.\n    >>> modp(3, 5)\n    3\n    >>> modp(3, 5)\n    3\n    >>> modp(3, 5)\n    3\n    >>> modp(3, 5)\n    3\n    >>> modp(3, 5)\n    3\n    >>> modp(3, 5)\n    3\n    >>> modp(3, 5)\n    3\n    >>> modp(3, 5)\n    3\n    >>> modp(3, 5)\n    3\n    >>> modp(3, 5)\n    3\n    >>> modp(3, 5)\n    3\n    >>> modp(3, 5)\n    3\n    >>> modp(3, 5)\n    3\n    >>>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nAlso available in the unix toolchain, under the name shl.\n\nAlso available in Python's math module, under the name \"mod\".\n\nI was just about to say this - while it's a good idea to know the python method for doing this, you don't need to know the name of the function - just do \"mod\" and it'll be obvious.\n\nI have to disagree: in the Python module, \"mod\" does integer division; to get the same thing as \"modp\", you have to do \"mod(p, n)\", which is a rather more awkward syntax.\n\nfor those who didn't know it - you can also use modulo (and remainder) with booleans.", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nIf you have Python 3.6+, you can use the functions from the standard library:\n>>> from __future__ import division, mod\n>>> mod(3, 5)\n3\n>>> mod(1101, 101)\n2\n>>> mod(0, 101)\n1\n>>> mod(3, 11)\n8\n>>> mod(100, 101)\n1\n>>> mod(3.6, 5.6)\n2\n>>> mod(0, 101)\n0\n\nWhy is the first part of the article not just \"Don't do this:\"?\n\nWell, it's not _wrong_ (well, if you know that it's going to be the result) but it's not very idiomatic either.\n\nIsn't it the same as modulo 2^N, with the advantage that you can use the same notation for the argument, the result and the shift?\n\nThis is correct. \"mod p\" is a shorthand for \"2^p mod p\".\n\nIt's a shorthand for _(p-1)^2_ mod p.\n\nI was taught this as \"modp\" too, but then again I was taught as an undergrad in the", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nAnd the other one I use frequently:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod(n: int):\n    \"\"\"Return n modulo p.\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    0\n    >>> mod(0, 101)\n    1\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    1\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp2(n: int):\n    \"\"\"Return 2^n modulo 2.\n    >>> modp2(3)\n    3\n    >>> modp2(1101)\n    2\n    >>> modp2(0)\n    1\n    \"\"\"\n\nimport operator", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nNot sure why you're being downvoted. This is a valid point. If you want to write code that is platform independent, using a standard library is a great way to go. When I read the OP, I was hoping to learn something about the standard library that I didn't know.\n\nI'm going to guess because this is a discussion about Python and someone mentions C and they don't like it.\nBut they're right: modp is a pretty basic function and if you're writing a C library for Python that depends on the standard library, you should know how to use it.\n\nI was hoping for a more detailed explanation of the difference between `mod` and `modp` and their use cases.\n\nmod(x, y) mod p = x % p\nmodp(x, y) mod p = x ** y % p\nModulo is useful for working with binary numbers.\nFor example, 2^7 = 1024 and 2^(7 - 1) = 512.\nBut, 2^(8 - 1) = 512 and 2^(9 - 1) = 1024.\nWhen you are working with binary numbers and modulo, you are often looking for a particular bit", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nIn Python 3, this is better written as:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def a(n: int):\n    \"\"\"Return (2^n - 1) modulo p (be aware of numerics).\n    >>> a(3)\n    4\n    >>> a(3)\n    -1\n    \"\"\"\n    def b(n: int):\n    \"\"\"Return p^2 modulo n.\n    >>> b(3)\n    9\n    >>> b(3)\n    11\n    >>> b(3)\n    22\n    \"\"\"\n\nThe second version is more readable, but slower. The first version is faster, but not as readable.  I wonder if the increased readability of the second version outweighs the performance of the first.\n\nReadability will always outweigh performance.\n\nExcept if your application is performance-critical.\n\nBut even there, readability is often an important part of performance.\n\nThe second version is not necessarily faster. The compiler could inline the modulo operation in the first function and remove the call to it. It's a matter of the compiler.", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI'm not sure why the last two lines are there. It's pretty clear what the function does.\n\nIt's interesting that the author is a lawyer. I've always thought that lawyers are some of the best programmers, but they just apply their skills to a different field. I think this post is evidence of that.\n\nSo in the case of the function, what exactly is the advantage of using modp instead of mod?\n\nIf the author is a lawyer, it's possible he has a similar interest to me in that I like to take well-known and commonly used functions and see if I can come up with an equivalent but more efficient version. That's what I assumed the author did with modp.\nFor me it's just a little game I like to play. It's a way to learn the language's features and come up with my own solutions.\n\nI think you may have just discovered why so many lawyers are successful in their chosen field.\n\n_edit_ : Oh, I guess you did say that!\n\nAnd, as I said in the comments, I am not a lawyer.\n\n\"Note that the modulo function has a different name in different languages. Modulo in C is", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return (n mod p)\nJust wanted to say I like this syntax better. It's much more explicit.\n\nIn case you missed it, this is the \"correct\" answer. The way I originally presented it was really just the first thing that came to mind.\n\nWhen I was first learning about modulo, I came to the conclusion that the best way to represent it would be as a binary number with all possible modulo values (a superset of 0 to n-1) as bits. The 0 would be the least significant bit, so if you want to check whether a number is even or odd, just check the last bit.\nHere's the wikipedia page: \n\nI actually think the wikipedia way is the easiest way to explain it to beginners.\n\nOh, I don't have any problem with the wikipedia way. I was just giving my own personal take.\n\nI also like the wiki syntax. I really don't like the syntax you presented, which may be due to my lack of exposure to it.\n\nI'm really getting sick of reading about these silly little (but \"clever\") \"gotchas\" that so many people keep thinking up in programming.", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI understand the need to comment, but why do people feel the need to make a comment that is entirely incorrect? Why not just write:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return floor(2^n)/p\nI'll be honest, I don't get it. What's the problem with the first two?\n\nthe first two are both 0 when n = p. I assume it should be 2^n % p\n\nI read the spec a while ago. The way it is written it looks like the first two are undefined.\n\nI agree. The first two are definitely undefined.\n\nThe first two are definitely not undefined.\nThe question is, are they actually zero or is the behavior of the division undefined?\n\nPython tries to evaluate modulo from left to right. In the first case, it evaluates 2 to zero before it evaluates p, so the result is zero. In the second case, it evaluates p to zero before it evaluates 2, so the result is zero. In the third case, it evaluates 2 to zero, and then p to one, so the result is one.\nI guess it's a bit like mathematical division:\na / b == b % a\na / b!= b % a\n\nYes, the behaviour of the division operation is undefined, the value of the expression is zero.\n\nWhat do you mean by \"undefined", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return (n ** 2) % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nIt seems like this would be quite a lot more useful if it took a modulus rather than a divisor.\n\nI think the point of this is that 2^n is not the only way to write n mod p.\n\nYup. This is a good example of why Python's syntax is better than Ruby's. Ruby would have to put \"divisor\" in the name, which makes the function less clear to non-programmers, because they don't know what a divisor is.\n\nI think there are a few better ways to do this. Using a dictionary is probably one of the worst ways to do it. If you are going to use a dictionary, it would be better to just store all the possible values of n mod p.\n\nI don't think this is a great example of Python syntax being better than Ruby syntax. I would have written that in Ruby as:\nmodp = (int(n) % int(p)) => n, modp = n % p;\nThat is, `modp` has an extra argument that's the divisor. That makes it a lot more obvious that this function returns a value modulo p.\nAnd now the author", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nx = ''.join(str(int(x)) for x in range(256))\nfor i in range(2, 256):\ny = int(x % i)\nfor j in range(2, 256):\ny += int(x % j)\nx = x % 256", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nRelated to that, the factorial function that returns 1 if n is even, and returns the non-zero integer equivalent of the factorial if n is odd:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThat's not right.\n\nHow so? I'd love to see your version, and please show your work!\n\nI think he means it should be written as", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThat's a really bad implementation. It's going to fail if p and n are both equal to 3, for instance.", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def modp_as_bytes(n: int, p: int):\n    \"\"\"Return 2^n modulo p in bytes, where the smallest multiple of p that\n    can be stored in a single byte is stored in the least significant byte\n    and the largest multiple of p that can be stored in a single byte is\n    stored in the most significant byte.\n    >>> modp_as_bytes(3, 5)\n    '2'\n    >>> modp_as_bytes(1101, 101)\n    '100'\n    >>> modp_as_bytes(0, 101)\n    '1'\n    >>> modp_as_bytes(3, 11)\n    '8'\n    >>> modp_as_bytes(100, 101)\n    '1'\n    \"\"\"\n\n    def modp_as_octet(n: int, p: int):\n    \"\"\"Return 2^n modulo p in octets, where the smallest multiple of p that", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nIf you look at the documentation you will see that the syntax\nis", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod(n: int, p: int):\n    \"\"\"Return n modulo p (be aware of numerics).\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    2\n    >>> mod(0, 101)\n    1\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    1\n    \"\"\"\n    def mod_sqr(n: int, p: int):\n    \"\"\"Return n^2 modulo p.\n    >>> mod_sqr(3, 5)\n    15\n    >>> mod_sqr(1101, 101)\n    33\n    >>> mod_sqr(0, 101)\n    5\n    >>> mod_sqr(3, 11)\n    9\n    >>> mod_sqr(100, 101)\n    1\n    \"\"\"\n    def mod", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def factorial(n: int):\n    \"\"\"Return n! (expect large numerics)\n    >>> factorial(100)\n    100\n    >>> factorial(1000)\n    1000\n    >>> factorial(10000)\n    90000\n    >>> factorial(100000)\n    9000000\n    \"\"\"\n    def factorial_p(p: int):\n    \"\"\"Return p! (expect large numerics)\n    >>> factorial_p(3)\n    27\n    >>> factorial_p(1101)\n    3621\n    >>> factorial_p(0)\n    1\n    >>> factorial_p(3, 11)\n    81\n    >>> factorial_p(100, 101)\n    1\n    \"\"\"\n    def divide(n: int, p: int):\n    \"\"\"Return n/p (expect large numerics)\n    >>>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nIt doesn't even work in Python 3.\n\nI think that's a problem with python 3, not the code.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    if n < 2:\n       raise ValueError(\n         \"Error in modulo operation\"\n         \"for non-positive integers\")\n    n = n / 2\n    return n % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def addp(n, p: int):\n    \"\"\"Return the sum of n modulo p.\n    >>> addp(1101, 101)\n    1111\n    >>> addp(0, 101)\n    100\n    >>> addp(3, 11)\n    33\n    >>> addp(100, 101)\n    100\n    \"\"\"\n\nNote that the behavior of `modp` and `addp` is undefined for negative values of `p`, and `modp` has an integer overflow bug.  The problem with `modp` is a function definition error, but the one with `addp` is a bug in the code in the article.  The code is incorrect.\n\nActually, the correct definition for `modp` would be:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod(m: int):\n    \"\"\"Return m modulo p (be aware of numerics).\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    2\n    >>> mod(0, 101)\n    1\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    1\n    \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def mod2(m: int, p: int):", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nAnd then they wrap it in a try-catch block, like a bunch of n00bs.\n\nTry-catch is great for debugging.\n\nI was using an old 2.6.x kernel and I needed to disable interrupts for the purpose of some debugging. The code was pretty simple, just a couple of lines in the kernel:\nint i = atoi(some_value);\ni = 0;\nAnd I had a bug. What I ended up having to do was add a try-catch block around the code I was debugging. The first time I reached the bug the kernel panicked and I had to reboot. After I added the try-catch the kernel did not panic, instead it printed some debugging information and the program continued.\nI'm not a C programmer but it seemed to me that the kernel should have just ignored the out of bounds value, like a sane person would do.\n\nThe out of bounds value is not in the program - it is in the system and therefore cannot be ignored.\n\nOk, but this should be an exception, the program shouldn't crash.\n\nThe value is not an invalid value that the program can just ignore. It is an \"out of bounds\" value which", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\nThis can't be right. I'd say it's wrong because it's just\nnot what the author intended. If it's not right, it's not\nright because the author didn't know what he was doing.\nBut that's just my opinion.\nBut the interesting thing about the author not knowing what\nhe was doing, is that he is the author of the standard and\nit's published in the standard. The standard is wrong, and\nit's wrong for exactly the reason it shouldn't be wrong.\nThe standard is wrong because it didn't specify the\nlanguage it was supposed to specify. In this case it's\nnot the compiler that's wrong, but the standard.\nThis is a classic case of the author (of the standard)\nknowing the problem, but not knowing the solution, and\nsolving the problem in the way he knows. This is really\nfunny, and really a classic case of something that most of\nus are doing all the time.\nBut now you know the solution to this problem and you can\nfix your compiler.\nI've got a book on the shelf that claims that this sort\nof thing is not possible. The book has a chapter on\n\"making programs", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    2\n    >>> mod(0, 101)\n    1\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    1\n    \"\"\"\nThe explicit type declaration seems redundant and inelegant. Why not:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modular(n: int, p: int):\n    \"\"\"Return 2^n / p.\n    >>> modular(3, 5)\n    3\n    >>> modular(1101, 101)\n    8\n    >>> modular(0, 101)\n    1\n    >>> modular(3, 11)\n    8\n    >>> modular(100, 101)\n    1\n    \"\"\"\n    def modp2(n: int, p: int):\n    \"\"\"Return 2^n modulo p2 (be aware of numerics).\n    >>> modp2(3, 5)\n    3\n    >>> modp2(1101, 101)\n    4\n    >>> modp2(0, 101)\n    2\n    >>> modp2(3, 11)\n    8\n    >>> modp2(100, 101)\n    1\n    \"\"\"\n    def modp3(n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis was already posted here a few months ago:\nhttps://news.ycombinator.com/item?id=11151085\n\nAh, yes. I must have missed it when searching, though the title was less informative: \"Numeric's modulo operator\".\n\nI once had a job doing code reviews of a large C project, and one of the things I did was enforce the use of this operator to remove a lot of potential bugs from the code.\nI also made some fixes to the code to make it so that when it was a constant number, it would not check for overflow, so that it would just do the modulus.\n\nI had the same problem with a C# project. Except in C#, we have an operator to do the modulus (`%`). But then someone was using that operator to do the % of a value and an int, and the result was always 0.\nYou have to be very careful when using operators for math. You have to understand how they work in the language, and how they're used.\n\nDo you mean the result was always 0 modulo 1?\n\nCorrect. That's what was so confusing. For example,", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def to_i(n: int, modp: modp):\n    \"\"\"Return n in integer notation.\n    >>> to_i(5, modp)\n    5\n    >>> to_i(1101, modp)\n    1111\n    \"\"\"\n\n    def modp2i(n: int, modp: modp):\n    \"\"\"Return n in integer notation modulo p.\n    >>> modp2i(3, modp)\n    8\n    >>> modp2i(1101, modp)\n    1111\n    \"\"\"\n\nreturn [n for n in xrange(n)]", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def fibonacci(n: int, p: int):\n    \"\"\"Return the fibonacci sequence with p digits.\n    >>> fibonacci(1000, 100)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610,...]\n    >>> fibonacci(3, 9)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610,...]\n    >>> fibonacci(101, 101)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610,...]\n    >>> fibonacci(3, 3)\n    [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610,...]\n    >>> fibonacci(3, 3)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def mod(p: int, n: int):\n    \"\"\"Return the remainder of p divided by n.\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    2\n    >>> mod(0, 101)\n    1\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    1\n    \"\"\"\n\n    def iszero(x: int):\n    \"\"\"Return True if x is 0, False otherwise.\n    >>> iszero(3)\n    True\n    >>> iszero(7)\n    False\n    >>> iszero(0)\n    False\n    >>> iszero(3.0)\n    True\n    >>> iszero(0.3)\n    True\n    >>> iszero(0.3.0)\n    False\n    >>> iszero(3.1)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def mod(a: int, b: int):\n    \"\"\"Return a % b.\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    1\n    >>> mod(3, 3)\n    1\n    >>> mod(0, 5)\n    1\n    >>> mod(0, 0)\n    0\n    \"\"\"\n\n    def factorial(n: int):\n    \"\"\"Return the factorial of n.\n    >>> factorial(3)\n    120\n    >>> factorial(100)\n    6,022\n    \"\"\"\n    return n*factorial(n-1)\n\n    def fib(n: int):\n    \"\"\"Return then'th fibonacci number.\n    >>> fib(3)\n    1\n    >>> fib(100)\n    36\n    \"\"\"\n    return n if n<2 else n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def gcd(a: int, b: int):\n    \"\"\"Return gcd of a and b (be aware of numerics).\n    >>> gcd(3, 5)\n    3\n    >>> gcd(1101, 101)\n    1\n    >>> gcd(0, 101)\n    1\n    >>> gcd(3, 11)\n    6\n    >>> gcd(100, 101)\n    1\n    \"\"\"\n\n    def gcd_prime(a: int, b: int):\n    \"\"\"Return true if a is prime.\n    >>> gcd_prime(3, 5)\n    True\n    >>> gcd_prime(1101, 101)\n    False\n    >>> gcd_prime(0, 101)\n    False\n    >>> gcd_prime(3, 11)\n    False\n    >>> gcd_prime(100, 101)\n    True", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def modp_2(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp_2(3, 5)\n    3\n    >>> modp_2(1101, 101)\n    2\n    >>> modp_2(0, 101)\n    1\n    >>> modp_2(3, 11)\n    8\n    >>> modp_2(100, 101)\n    1\n    \"\"\"\n\n    def modp_5(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp_5(3, 5)\n    3\n    >>> modp_5(1101, 101)\n    2\n    >>> modp_5(0, 101)\n    1\n    >>> modp_5(3, 11)\n    8\n    >>> modp_5(100, 101)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def divmod(a, b: int):\n    \"\"\"Return a modulo b.\n    >>> divmod(1101, 101)\n    11\n    >>> divmod(1101, 11)\n    100\n    >>> divmod(0, 101)\n    1\n    >>> divmod(1101, 1101)\n    11\n    \"\"\"\n    def modpow(n: int, p: int, q: int):\n    \"\"\"Return a^p modulo q (be aware of numerics).\n    >>> modpow(3, 101, 10)\n    30\n    >>> modpow(1101, 101, 10)\n    110\n    >>> modpow(0, 101, 10)\n    0\n    >>> modpow(1101, 101, 11)\n    111\n    >>> modpow(100, 101, 10)\n    10\n    \"\"\"\n    def divmod", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThe thing that confused me the most was that it's a method, not a function (and why it's named modp and not 2^n mod p).\nI'd like to see more examples of his code. I'm learning Python and I'd like to know what not to do in order to avoid code rot.\n\n_I 'd like to see more examples of his code._\nIn particular, I'd like to see a few of his _bad_ functions, as well as a few of his _good_ functions, so I can compare and contrast the two.\nI suspect that the \"good\" functions are simply syntactic sugar around some simple code that is already intuitive, while the \"bad\" functions are code that is hard to understand or not idiomatic in Python.\n\n_I suspect that the \"good\" functions are simply syntactic sugar around some simple code that is already intuitive, while the \"bad\" functions are code that is hard to understand or not idiomatic in Python._\nAs I said, I think you're way off.\nI think the \"good\" functions are intended to be examples of something. They are not intended to be run, and you are not meant to understand them. They", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod(n: int, p: int):\n    \"\"\"Return n modulo p (be aware of numerics).\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    11\n    >>> mod(0, 101)\n    1\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    1\n    \"\"\"\n    def mod(n: int, p: int, q: int):\n    \"\"\"Return n modulo p, q.\n    >>> mod(3, 5, 11)\n    3\n    >>> mod(3, 5, 11)\n    3\n    >>> mod(3, 5, 11)\n    3\n    \"\"\"\n    def mod(n: int, p: int, q: int, r: int):\n    \"\"\"Return n modulo p, q, r.\n    >>> mod(3,", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI can't believe I'm the only one that wrote a generator for this.", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is the code I've used for a few years now:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\nThis works in Python 2.7:\n>>> import math\n>>> modp = math.modp(3, 5)\n>>> print modp(3, 5)\n3\n>>> print modp(1101, 101)\n2\n>>> print modp(0, 101)\n1\n>>> print modp(3, 11)\n8\n>>> print modp(100, 101)\n1\n>>> print modp(4, 5)\n0\n>>> print modp(1, 101)\n-1\n>>> print modp(3, 5) * modp(4, 5)\n0\n>>> print modp(1, 101) * modp(3, 5)\n-1\n>>> print modp(1, 101) - modp(3, 5)\n2\n>>> print modp(1, 101) % modp(3, 5)\n2\n>>>\n\nI think that is a different function? The one you call modp() is defined in the standard library and is a builtin (2.7.5 on my computer) whereas the one that you call in the article is defined in the user's module so it's not available (", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThanks, but I'd prefer to ask for a definition that does not show the result of a computation.\n\nI think the point of the answer is that the definition can be inferred from the implementation of the function.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nSee also:\nrmod</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    2\n    >>> mod(0, 101)\n    1\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    1\n    \"\"\"\n\nI think it's easy to explain by counting the number of times you need to do the operation to get 2^n. So for modp: 3 * 2 * 2 * 2 = 8. For mod: 3 * 2 * 1 = 6.\n\nI'm pretty sure modp is going to be faster, because you don't have to loop through 2^n each time you do the operation.\n\nThe last bit, mod(3, 11), is even faster than modp because you only need to do the operation once.\n\nIt's also worth noting that the default mod operation in Python is an integer division, which is the same", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def mod(n: int, p: int):\n    \"\"\"Return 2^n % p.\n    >>> mod(3, 5)\n    0\n    >>> mod(1101, 101)\n    100\n    >>> mod(0, 101)\n    1\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    1\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def np(n: int, p: int):\n    \"\"\"Return p raised to n.\n    >>> np(3, 5)\n    15\n    >>> np(1101, 101)\n    899\n    >>> np(3, 11)\n    43\n    >>> np(100, 101)\n    100\n    \"\"\"\n    def powp(a, b: int):\n    \"\"\"Return a raised to b.\n    >>> powp(3, 11)\n    33\n    >>> powp(3, 3)\n    9\n    >>> powp(3, 0)\n    1\n    >>> powp(3, 0)\n    Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    NameError: name 'powp' is not defined\n    \"\"\"\n    def unPowP(a: int):\n    \"\"\"Return", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI think the wording is more clear if it reads \"return the remainder when 2^n is divided by p\".\n\nI like to think of modulo as \"un-normalizing\" a number.\n\nSome languages and compilers have a \"remainder\" operator to make this syntax even clearer.\n\nI'm not sure the last one is better. Since remainder is more commonly used than modulo.\n\nI think both are clear but prefer modulo as a programmer. I think it's a more terse way of saying the same thing.\n\nI prefer modulo because it's what everyone else seems to be using.\n\nAs a CS student, I prefer modulo, because it's what the language I'm using uses.\n\nAs a programmer, I prefer modulo, because I'm used to it.\n\nAs an ECE student, I prefer modulo, because it's the correct mathematical term.\n\nI prefer modulo because it's the one my compiler has.\n\nI prefer modulo, because I don't understand the other one.\n\nI prefer modulo, because that's what everyone else uses.\n\nI prefer modulo, because that's what the language", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nimport math", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nUsage:\n>>> modp(3, 5)\n3\n>>> modp(3, 5)\n2\n>>> modp(3, 5)\n1\n>>> modp(3, 5)\n8\n>>> modp(3, 11)\n8\n>>> modp(3, 11)\n8\n>>> modp(3, 11)\n8\n\nNow I've never used modp in python, but I'm going to guess it's significantly faster than this in most languages.\n\nI don't think this is a fair comparison, as the time it takes to execute the statements in the list is not the same as the time it takes to calculate the result.\n\nThe OP compares the time to execute the code, and the time it takes to calculate the result.\nThe time to execute the code is the number of instructions. The time to calculate the result is the number of multiplications.\n\nWhat I meant was that in the OP's example, the code has been modified to print each of the intermediate results, which would not normally be done when actually calculating the result.\n\nThe code in the article does not print intermediate results.\n\nOops, sorry, I got confused", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nModulo n should be returned, not 2^n.\n\nActually, the modulo is 1 mod n, and 2^n is the remainder.\n\nThe modulo n is 1, but the question is 2^n not 2^n%n.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nModulo division is not commutative, but they really ought to have just written p -= 1, and p += 1, rather than using a non-commutative function.\n\nWhile they should've used a more idiomatic way to express the requirement, I don't think they can make the function commutative without breaking the meaning of the function. (The \"meaning\" is the fact that if you iterate over the number, then modulo p yields the next number in the iteration.)\nIf you see a way to make the function commutative without breaking the meaning, please let me know! I'd love to hear.\n\nNot sure I have a good way to make it commutative, I just think it's worth pointing out that it's not commutative.\n\nI think I would have tried to implement this function by doing a little bit of arithmetic with a loop. Perhaps something like:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def modular(n: int, p: int):\n    \"\"\"Return n in p/2^(p-1).\n    >>> modular(3, 5)\n    3\n    >>> modular(1101, 101)\n    100\n    >>> modular(0, 101)\n    101\n    >>> modular(3, 11)\n    7\n    >>> modular(100, 101)\n    0\n    \"\"\"\n\n    def modular_remainder(n: int, p: int):\n    \"\"\"Return n in p/2^p.\n    >>> modular_remainder(1101, 101)\n    100\n    >>> modular_remainder(0, 101)\n    101\n    >>> modular_remainder(3, 11)\n    7\n    >>> modular_remainder(100, 101)\n    0\n    \"\"\"\n\n    def modular_remainder_p(n: int, p:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nAlso note that 2^(n-1) = n - 2^(n-1).", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nNote that the function returns 2^n modulo p.", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def modulo(p, n: int):\n    \"\"\"Return p / n.\n    >>> modulo(3, 5)\n    3\n    >>> modulo(1101, 101)\n    1101\n    >>> modulo(3, 11)\n    33\n    >>> modulo(100, 101)\n    10\n    \"\"\"\n\n    def inits(n: int):\n    \"\"\"Initialise a modulus.\n    >>> inits(3)\n    \"\"\"\n\n    def is_prime(n: int):\n    \"\"\"Is n prime?\n    >>> is_prime(3)\n    True\n    >>> is_prime(3, 5)\n    False\n    \"\"\"\n\nI'm not sure I understand the purpose of these.\n\nBecause I don't think that the author of the post was intending to\nactually write his own modulus.\n\nI figured that much.\n\nA modulus is one of those things that is too simple", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def modf(n: int, p: int):\n    \"\"\"Return the remainder of 2^n modulo p.\n    >>> modf(3, 5)\n    2\n    >>> modf(1101, 101)\n    1\n    >>> modf(0, 101)\n    5\n    >>> modf(3, 11)\n    4\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nphew! good thing you used parentheses, I thought you were returning the number modulo 11.\n\nNot sure if you're being sarcastic, but if you're not, it is very common to put parentheses around expressions like this. It's equivalent to \"mod p (2^n)\" in many programming languages (Python included).\n\nyeah, I was being sarcastic.\n\nI think this is one of the worst articles I've ever seen on HN.\n\nI am not sure it is an article. It looks more like an exercise for the readers.\n\nI think that's an unfair description. I have no idea if it's an exercise or an article. It's not an article because there's no information about it. It's not an exercise because there are no answers.\n\nI agree with the other commenter that this is likely a small part of an article.\nThat said, I think the fact that you can't tell whether it's an article or an exercise makes it a very bad article, and a very bad example of how to teach a concept. It doesn't teach you anything. It's just frustrating.\n\nIt's an exercise from the book _The Tao of Programming_. The rest of the", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return n % p\nThis is much faster in Python 3.0, because the % operator in Python 3.0 has a special return value type of a sequence of numbers (http://docs.python.org/3/library/functions.html#generator-functions).\n\nPython 3.0 introduced a function named floor that returns the largest integer that is not greater than its argument. In Python 2.7, I can use", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is Python 3.x?\n\nYes.\n\nProbably a good idea to specify that in the title, since that's a major difference from the 2.x series.\n\nPython 3.x is the default Python.\n\nIf you are saying that the default python is 3.x, that's false. The default python is 2.x.\n\nPython 3 is the default version.\n\nI have python 3.4.2 installed, and 2.7.13 is the default. This is on Ubuntu 14.04.\n\nThat's strange, on Linux Mint 17.2 it's the other way around.\n\nPython 2 is default on Ubuntu and Linux Mint.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis was a really cool discussion of Python's modulo operator. I'm glad I learned about it.\n\nThe main issue with modulo is that it is a circular algorithm.\nIt is also O(n^2) which makes it slow.\nIt also has no efficient implementation on some hardware, particularly fixed- width hardware.\nIt also has no efficient implementation in a functional language.\n\nWhat's \"fixed-width hardware\"? I've never heard of that before.\n\nYou can find lots of information about fixed-width hardware here:\nhttp://en.wikipedia.org/wiki/Fixed-width_integer\n\nFixed-width hardware is a pain, and can lead to security vulnerabilities. If you read the article I posted, you will see that in some cases, modulo can be O(n^3) and O(n^4). It is also usually slower than a division operation.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis module defines the modulo operator modp(n, p) as the following:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    def modp(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\nPersonally I think the first version is better", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n\t\treturn p * 2^(n-1)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    \"\"\"\n    def __init__(self, n: int, p: int):\n    \"\"\"Initialize a new modp.\n    >>> modp = modp(3, 5)\n    >>> modp()\n    >>> modp()\n    \"\"\"\n    self.n = n\n    self.p = p\n    print self.n, self.p\n    def __rmod__(self, a: int, b: int):\n    \"\"\"Return the remainder when 2^n modulo p is divided by a and b.\n    >>> modp(3, 5) % 5\n    7\n    >>> modp(1101, 101) % 2\n    1\n    \"\"\"\n    \"\"\"\n    return a * 2 + b", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    if n == 0:\n        return 2\n    return n*(2^(n-1))%p\n\nYou know, I just realised that the first implementation of the algorithm given in the OP is actually wrong.\nYou need to make the n^2 in the first loop be the same as the n in the second loop, and that can only be achieved with the version where you actually multiply the n^2 in the first loop by itself in the second loop.\n\nActually, the second loop is there to make the code more readable. There is no need to multiply by itself in the second loop.\n\nRight, it's been a while since I've done any math, and when I was reading it I thought it was weird, but my brain immediately translated it to the version that isn't actually correct, not the one that is.\n\nI'm not sure if this is the intended behavior, but in the first loop, when n is odd, the result is n times the number of iterations, not 2^n. The second loop is correct.\n\nThere is no second loop.\n\nI didn't think there was, but I was trying to", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def modp2(n: int):\n    \"\"\"Return 2^n modulo 2 (be aware of numerics).\n    >>> modp2(3)\n    3\n    >>> modp2(1101)\n    3\n    >>> modp2(0, 0)\n    1\n    >>> modp2(3, 11)\n    8\n    \"\"\"\n    def modp3(n: int):\n    \"\"\"Return 2^n modulo 3 (be aware of numerics).\n    >>> modp3(3)\n    6\n    >>> modp3(1101)\n    3\n    >>> modp3(0, 0)\n    1\n    >>> modp3(3, 11)\n    8\n    \"\"\"\n    def modp4(n: int):\n    \"\"\"Return 2^n modulo 4 (be aware of numerics).\n    >>> modp4(3)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp2(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp2(3, 5)\n    1\n    >>> modp2(1101, 101)\n    3\n    >>> modp2(0, 101)\n    1\n    >>> modp2(3, 11)\n    8\n    >>> modp2(100, 101)\n    2\n    \"\"\"\n    def modp3(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp3(3, 5)\n    6\n    >>> modp3(1101, 101)\n    7\n    >>> modp3(0, 101)\n    7\n    >>> modp3(3, 11)\n    8\n    >>> modp3(100, 101)\n    7\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return 0 if n == 0\n    return n * p - 1\nThis is really bad.\nIt's undefined behavior, for one.\n\nHeh, I was trying to think of a way to write it as a regular expression (the only kind of modulo I know of) but I was too lazy to actually do it.\nI'd be interested in seeing what people come up with.\n\nIt can be written in the regular expression's own notation.\n\nModulo as a regular expression would be quite tricky. It would probably require a quantifier of some kind.\n\nWell, I was thinking of something like:\n[0-9]\\d*\\d*\n\nThis would not be correct.\nIf you're looking for the decimal representation of a number modulo a power of 10, the regex you're proposing would be correct.\n\nIt would also be incorrect in this case since it will find every decimal representation of a number modulo any power of 10.\n\nI'm not sure I understand. Are you saying that it would incorrectly find every decimal representation of a number modulo a power of 10?\n\nYes.\nIt will correctly find the decimal representation of", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def mod(p: int):\n    \"\"\"Return the remainder of p divided by n (ex. mod(3, 5) = 1).\n    >>> mod(3, 5)\n    1\n    >>> mod(10, 3)\n    6\n    \"\"\"\n\n    def mod_sum(a: int, b: int):\n    \"\"\"Return sum(a + b mod p) (ex. mod_sum(10, 3) = 6).\n    >>> mod_sum(10, 3)\n    6\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nNote that in Python, like in every other number-crunching language, the modulo operator is by default defined in terms of _arithmetic_ modulo, not _modular_ modulo.\n\nI'm glad someone pointed this out. My first thought was \"what does it mean to take the _arithmetic_ modulo?\"\n\nIt's a well-known fact that the arithmetic modulo is an integer, as opposed to the modular, which is a whole number.\n\nIs that really a \"well-known fact\"? I've never heard that before.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return 2 ^ ((n << p) & 1)\nThis is how I would do it in Python.\n\nThat's pretty much the same as the C++ one. A few languages don't do exponentiation this way:\nC:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nIt's hard to believe there are still codebases written in Python 2.x.\n\nWhy?\n\nPeople who write code for a living should care about their users, and not writing Python 2 is a show of disrespect to their users, who are forced to use an old version of Python because of the stubbornness of developers.\n\nI'm curious what you think about all the people who don't upgrade their Python code to 3, but instead choose to use a different Python implementation instead (e.g. IronPython, Jython)?\n\nI don't have a problem with it, because those languages are not taking away any Python 2 users' ability to run their code.\n\nThis is like the exact opposite of \"pip install\".\n\nI guess you could say it's \"pip install pip\".\n\nWhy would you do that?\n\nIf you're running pip in Python 3, you can't use pip install pip because it doesn't exist. So you need to install it using pip.\n\nWait, I don't follow. Can't you use pip3 install pip, or pip3 install pip3?\n\nIt's only called pip, not pip3.\n\nPython 3 is the", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n   \n    def mod_sqrt(n: int, p: int):\n    \"\"\"Return the square root of 2^n modulo p.\n    >>> mod_sqrt(3, 5)\n    2\n    >>> mod_sqrt(1101, 101)\n    3\n    >>> mod_sqrt(0, 101)\n    3\n    >>> mod_sqrt(3, 11)\n    1.4141592653589793\n    >>> mod_sqrt(100, 101)\n    1.4141592653589793\n    \"\"\"\n   \n    def mod_to_int(n: int, p: int):\n    \"\"\"Return the given n as an int.\n    >>> mod_to_int(1101, 101)\n    1101\n    >>> mod_to_int(11, 101)\n    11\n    >>> mod_to_int(100, 101)\n    100", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nmodule modp", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is not so great. For example, modp(0, 101) returns 1, which is not what you'd expect.\nFor that reason, I'd be inclined to use this in a list comprehension,\nrather than as a function call.\nfrom itertools import cycle", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def modp2(n: int):\n    \"\"\"Return 2^n modulo p2.\n    >>> modp2(3)\n    3\n    >>> modp2(1101)\n    2\n    >>> modp2(0)\n    1\n    >>> modp2(3, 11)\n    8\n    >>> modp2(100, 101)\n    1\n    \"\"\"\n\n    def modp3(n: int):\n    \"\"\"Return 2^n modulo p3.\n    >>> modp3(3)\n    3\n    >>> modp3(1101)\n    2\n    >>> modp3(0)\n    1\n    >>> modp3(3, 11)\n    8\n    >>> modp3(100, 101)\n    1\n    \"\"\"\n\n    def modp4(n: int):\n    \"\"\"Return 2^n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThat's pretty cool.\n\nI just wish it had a way to return the exponent to the power of the modulus, not just the modulus itself.\n\nI wonder if it's possible to do this using the modulus operator, rather than the modulo operator? I don't see why it couldn't be done, but I'm not sure how to do it without getting really messy.\n\nYou could probably use the modulus operator for something like 1/2 ^ n, but not for something like 1/3 ^ n, since the exponent is variable.\n\nYou can use the modulus operator for any power. For example, mod(10, 2) is 2.\n\nNow I'm confused. I'm getting different answers depending on where I look.  gives a different answer from what you say.\n\nHis example is a little bit wrong. He should have written mod(2, 10).\n\nThis has been discussed before, see:\n\nBut this is way more straightforward, I think.\n\nThe modulus operator is also useful for negative values.\nFor example:\n>>> mod(0, 5) == -1\n>>> mod(5, -2) == -1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod(n: int, p: int):\n    \"\"\"Return n modulo p.\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    101\n    >>> mod(0, 101)\n    0\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    3\n    \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp(3, 5)\n    21\n    >>> modp(1101, 101)\n    10\n    >>> modp(0, 101)\n    0\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    3\n    \"\"\"\n    def mod2(n: int, p: int):\n    \"\"\"Return 2^", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n        def f(n: int):\n        \"\"\"Return 2^n.\n        >>> f(1101)\n        1202\n        >>> f(100)\n        100\n        >>> f(0)\n        0\n        >>> f(2)\n        4\n        >>> f(3)\n        6\n        \"\"\"\n        def modulo(n, p):\n        \"\"\"Return (2^n) modulo p.\n        >>> modulo(3, 5)\n        3\n        >>> modulo(1101, 101)\n        1\n        >>> modulo(0, 101)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def divmod(n: int, p: int):\n    \"\"\"Return the remainder after dividing n by p.\"\"\"\n    return (p % n) ** modp(n, p)\n\nThis is a little silly; I would just define a function modulo, and call it modp.\n\nYou can also use a memoized modulo function that doesn't rely on a lookup table, like this:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp2(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp2(3, 5)\n    9\n    >>> modp2(1101, 101)\n    15\n    >>> modp2(0, 101)\n    3\n    >>> modp2(3, 11)\n    0\n    \"\"\"\n\nI'm not sure what the point of this is. The first two are the same, the last two are the same, and none of them do anything with the modulo result.\n\nI'm guessing the author is new to programming and is trying to learn Python?\n\nI'm sure you're correct, but that doesn't make the post any less irritating.\n\nIt's a bit pedantic, but if there was an issue with the previous version, it's that it was not immediately obvious what they were doing.\nThis version is better, but I would still prefer to write it like this:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return mod(n, p - 1)\n> modp(0, 101)\n> Modulus of 0 is 1\n> Modulus of 101 is 1\n> Modulus of modp(101, 100) is 0\n> Modulus of modp(100, 101) is 1\n> Modulus of modp(100, 100) is 1\n> Modulus of modp(100, 101) is 0\n> Modulus of modp(101, 101) is 0\n> Modulus of modp(101, 100) is 1\n> Modulus of modp(101, 101) is 1\n> Modulus of modp(102, 101) is 0\n> Modulus of modp(102, 100) is 1\n> Modulus of modp(102, 101) is 1\n> Modulus of modp(103, 101) is 1\n> Modulus of modp(103, 100) is 1\n> Modulus of modp(103, 101) is 1\n> Modulus of modp(104, 101) is 1\n> Modulus of modp(104, 100) is 1\n> Modulus of modp(", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis should be clearer as", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThere's also the pow function which is arguably more pythonic.\n>>> pow(modp(3, 5), 2)\n6\n\nAll of that is true, but it's a good practice to choose the most appropriate tool for the job. And there is nothing wrong with using the C++ standard library for this.\n\nOn the other hand, choosing the most appropriate tool for the job is a good practice and that's why I wrote this post.\n\nThe fact that you have to explain what the modulus operator does is a good indicator that you're probably not in a language that's the most appropriate tool for the job.\n\nNot quite.\nI actually had to explain this to a colleague a couple of weeks ago, in a Python context.\nIt's not an uncommon thing to do, and since Python is so often used as a scripting language, it seems to have become the most appropriate tool for the job.\n\nThe article mentions that modulus is not the same as the % operator. The author states that, \"There's no reason to invent a new operator for this purpose. It's already there.\"\nHowever, I'm not sure why this is so. I think it's a valid case for", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def modp2(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp2(3, 5)\n    11\n    >>> modp2(1101, 101)\n    100\n    >>> modp2(0, 101)\n    1\n    >>> modp2(3, 11)\n    9\n    >>> modp2(100, 101)\n    0\n    \"\"\"\n\n    def modp3(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp3(3, 5)\n    1\n    >>> modp3(1101, 101)\n    1\n    >>> modp3(0, 101)\n    0\n    >>> modp3(3, 11)\n    7\n    >>> modp3(100, 101)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def dp(n: int, d: int):\n    \"\"\"Return n * d modulo p (be aware of numerics).\n    >>> dp(1, 3)\n    6\n    >>> dp(1, 0)\n    1\n    >>> dp(1, 3)\n    3\n    >>> dp(2, 3)\n    9\n    >>> dp(2, 0)\n    6\n    >>> dp(3, 3)\n    27\n    >>> dp(3, 0)\n    9\n    \"\"\"\n    def ad(n: int, d: int, p: int):\n    \"\"\"Return n * d * p modulo p (be aware of numerics).\n    >>> ad(1, 3, 5)\n    6\n    >>> ad(1, 0, 5)\n    1\n    >>> ad(1, 3, 11)\n    27", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThe same code in C:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    n = len(numbers)\n    modp_return = []\n    for i in range(n):\n        modp_return.append(modp(i, p))\n    return modp_return\n\nThis is not a good solution. It does not guarantee the result will\nbe a modulus of p. For example, what if there are two numbers (a\nnegative and a positive) that are larger than p, but their product\nis less than p?\n\nIf the OP wanted to maintain the original values, then he could use\nthe BigInteger class.", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nYou may wish to consider using the `exp` module instead, as it's already in the standard library, and is more commonly used.\n>>> modp(3, exp(5))\n8\n>>> modp(1101, exp(101))\n2\n>>> modp(0, exp(101))\n1\n>>> modp(3, exp(11))\n8\n>>> modp(100, exp(101))\n1\n>>> modp(10, exp(3))\n0\n>>> modp(13, exp(2))\n-1\n>>> modp(20, exp(3))\n13\n\nIf you're using Python 3, you should be able to use `x**n`.\n>>> modp(3, x**n)\n8\n>>> modp(1101, x**101)\n2\n>>> modp(0, x**101)\n1\n>>> modp(3, x**11)\n8\n>>> modp(100, x**101)\n1\n>>> modp(10, x**3)\n0\n>>> modp(13, x**2)\n-1\n>>> modp(20,", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return (2^n) % p\nWhat a way to not check for division by zero!\n\nThere's no reason to worry about the case where n == 0. If you do, you\nwon't be able to generate a real answer, because you will be subtracting\n0 from 2^0, so you won't get anything.\n\nYou can do the same thing by checking if the value of n is negative.\n\nNo, you can't. The number you get from subtracting 0 from 2^0 will be\nzero, not negative.\n\nThat is why he suggested doing it after the subtraction:\n>> No, you can't. The number you get from subtracting 0 from 2^0 will be\n> zero, not negative.\nYou're absolutely right. I didn't see the \"if\" clause.\n\nI don't see what's the point of this. You can't use it for a modulo operation.\nIt should return True when the modulo is less than or equal to zero.\n\nI don't understand this. It doesn't make sense to subtract 0 from 2^n to get the same number.\nIf the input is positive, it", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is a good example of the need for a code formatter.\n\nPlease don't.\nWe'll end up with pretty-printed code that can't be read, rather than code that's not pretty but can be read.\n\nWon't somebody please think of the _users_?!\n\nThe problem is that people don't _want_ to think of the users. They just want to have pretty code.\n\nYour comment would be more accurate if it said \"The problem is that people don't _want_ to think of the readers.\"\nNot all of them are going to be users.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp2(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp2(3, 5)\n    3\n    >>> modp2(1101, 101)\n    2\n    >>> modp2(0, 101)\n    1\n    >>> modp2(3, 11)\n    8\n    >>> modp2(100, 101)\n    1\n    \"\"\"\n\n>>> print(modp(3, 5))\n3\n>>> print(modp(1101, 101))\n2\n>>> print(modp(0, 101))\n1\n>>> print(modp(3, 11))\n8\n>>> print(modp(100, 101))\n1\n\nLooks good. For me, the language I use most often is Python, so I wrote a module for it:\nimport math", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI'm not familiar with Python, but I think this is actually a pretty neat feature. To be clear, the function above returns the quotient of 2^n divided by p. So, if you have modp(3, 5) and you multiply both sides by two, you get 6. Similarly, modp(11, 101) gives you 101/2 = 50.\n\nThis is not the same as \"modulo p\" which in the context of the post is probably meant to mean \"remainder of p/2\" or \"p divided by two\".\n\nOk, so mod(p,2) is the equivalent to the Python modp?\n\nNo, mod(p,2) is the equivalent to 2 * (p / 2). The Python function modp is equivalent to the Python function divmod(n, p).\n\nIn C, the usual way of doing this is to declare a function \"mod\" which takes n as its argument and returns 2^n - p.", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n>>> modp(3, 100)\n3\n>>> modp(1101, 100)\n2\n>>> modp(0, 100)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\nThis is a lot like a quicksort, but not in a good way. If you were to write a quicksort in Python, you could simply have written:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def modp_inline(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp_inline(3, 5)\n    3\n    >>> modp_inline(1101, 101)\n    2\n    >>> modp_inline(0, 101)\n    1\n    >>> modp_inline(3, 11)\n    8\n    >>> modp_inline(100, 101)\n    1\n    \"\"\"\n\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return n % p\nSurely that's the other way around, right?\n\nIt's correct the way it is. You can think of it as a counter, modulo p. If it was n % p, it would go up to n - p before going to zero.\n\nNice. I had a look at the source but it didn't make me any wiser.\n\nIt's pretty simple - it takes 2^n, and then modulo p. This is 2^n modulo p:\n2^(2^(2^(2^(2^2))) mod p)\nSee how it's going to be in the 2^2 range, and then 2^(2^(2^(2^2))) has a remainder of 1, which means it's in the 0-1 range.\n\nThat's exactly it! Thanks for the great explanation.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nIs there any particular reason why that name was chosen? It just seems very odd to call it `modp` instead of `mod_p` or something else.\n\nIt's the same naming as python's builtin `mod` function.\n\nThat's exactly the reason! It's a Python API.\n\nWell, then the documentation should reflect that. I didn't know it was a python api until I read through the comments here.\n\nIt's in the title.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nIs that for real? It can't be.\n\nIf you look at the source code of the Python interpreter, which is extremely readable, you'll find that there are a number of things like that. It's not one of the things that you'd expect from a language that prides itself on clarity.\nThe language designers have said that the actual answer to the question \"what is the least common multiple of two prime numbers\" is \"not 42\".\n\nPython is a language that was designed to be easy to learn for non-programmers.\n\nIt does look a lot like the majority of the code I saw when I was working for one of the biggest telecoms in Europe. And, boy, was that code bad.\n\nI work in a place where people get paid to write code. It's ugly.\n\nI see no problem with this.\n\nReally, you don't see any problems with this?\n\nNo.\n\nIt's OK if the code is ugly as long as it's functional, and it doesn't do anything wrong.\n\nThis code is neither of those things.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI'm not sure what the point of this is. The language already has the division operator, which takes a fractional argument and returns the remainder, and if the remainder is 0, the result is 1. So you can write this:\n\n>>> 2 ** 100\n2\n\nAs for floating point division, the language already has float division, and it works the same way:\n\n>>> 3.0 / 1.0\n0.3\n>>> 2.0 / 1.0\n0.2\n\nThere are more efficient ways of doing this using the \"mod\" function and the \"rem\" function, but I don't think Python needs a special \"modp\" function, which just duplicates the behavior of the division operator and the float division operator.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nAs a Python programmer, this does not appear to be a Pythonic solution.\n\nPython's built-in modulo operator works on strings, not integers. So this is just a wrapper around str(x) that does a little bit of additional work.\n\nYou can just use Python's modular exponentiation as well:\n>>> x = 3.0\n>>> x**3\n3\n>>> x**11\n33\n>>> x**12\n100\n\nThat's not the same as modp().\nThe modp function is an integer-only version of x**3 that does the modulus check in-place, so that you can use it with numbers that have a non-integer number of digits.\n\nI don't think Python's modulo operator is built-in; it's available in the standard library.\n\nI just realized that the problem was that the author assumed that the numbers had to be integers.\n\nmodp is not an integer only version of x**3.\nmodp is a function that takes an int and returns the integer portion of the number modulo p.\ne.g.\n>>> modp(3.0, 2)\n3\n>>> modp(", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is a really bad name for the function because it's usually the _reverse_ of what you're doing. It would be better named gmpy for \"Greatest Modulus Primes\" or something like that.\n\nWhat's wrong with the name? It's obviously a modulo operation, which it is. It returns a number that is the modulus of the number you pass in.\n\nThe function is called \"modp\" which I initially read as \"modulo p\". But it's really \"modulo 2^n\" which is not what I was expecting.\n\nI had the same initial read. And you're right that it's a bad name.\nThe good thing is that it's not even used in the documentation, it's only defined in the code.\n\nI like the code, but the problem with this is that it only works if you can guarantee that the source will have at most one prime.\n\nTrue, but it only needs to be guaranteed for the first prime, which can be done by a simple loop.\n\nA few people have suggested that a better name would be gmpy, which I agree with. However, I don't want to change the name now as", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI don't understand the criticism.\n\nI think it's because it's not immediately clear that the first example means \"modulo p of 3\". The first line looks like \"return 2^n\" and the second line looks like \"return 2^n modulo p\". The third line gives a hint, but the fourth line is necessary to clarify it.\n\nIt's a bit like how in math, you will sometimes see things like \"Let n = 0, and let f(x) = x^2.\"\nI can see how a new user of the language might be confused by that.\n\nIn Python, you will often see things like\nfrom random import randint\nrandint(1, 3)\nThis is probably the best way to do things, because it's a convention. Modulo is a useful concept, and it's a good idea to know how it works, so having it be named after its meaning makes sense.\n\nThe naming is really the only thing that makes sense in python.\nIn python, you would only want to do that if your dealing with a limited number of random numbers. Most of the time you'd want to do something like\nimport random\nrandom.seed(123", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThanks! I know how to use it. I just wanted to know if there was a more compact way of writing it.\n\ni think there's a bug in the comment section that turns everything into italics.\n\nI'm not sure why you are being downvoted, the comment section is definitely buggy.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nUseful. Is there a reason why it is on a.org domain and not.com or.net?\n\n.org is the new.com.\n\nIt's not a bad domain, but.org is a specific type of domain for non-profits, and in my opinion it does not fit a small web site which is essentially a collection of random code snippets.\nI'd have no problem if it was explained in the \"about\" page, but it isn't.\n\nI like it. It's one of the most useful ones I've found and I'll be using it.\n\nNeat.\nI'd recommend adding a docstring.\n\nCan someone explain the purpose of these?\n\nIf you want to make a utility function, you can just make a module and put it in a namespace, or you can put it in a module and put it in the standard library.\nThe choice of where to put it is really arbitrary.\n\nYou can also use it as a test for some type of error handling. If the function exits with an exception, then it was obviously called with the wrong parameters.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nWhile I appreciate the effort of the author, this code can be simplified considerably, and I'm surprised that no one has mentioned it yet.\n>>> modp_simplified = lambda n: n ** (2**n - 1) + 1\n>>> modp_simplified(1101)\n2\n\nThey didn't mention it because it's not more correct. modp_simplified just provides a shortcut for the code that the OP presented.\n\nWhile it's not more correct than the code the OP posted, it is more concise, which is an advantage.\n\nThis is the same as a simple trick:\n>>> n = int(input(\"Enter a number: \"))\n>>> modp = (n ** (2 ** n - 1)) + 1\n>>> modp(5)\n3\n>>> modp(11)\n2\n>>> modp(0)\n1\n>>> modp(3)\n8\n>>> modp(100)\n1\n>>> modp(3, 1)\n6\n\nYou can also do it in one line:\n>>> n = input(\"Enter a number: \")\n>>> modp = n ** (2 ** n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    n = 0\n    p = 10\n    while n <= p:\n        n += 1\n        n = modp(n, p)\n\nLines 2\u20135 and lines 7\u201313 are all constants, and do not represent a meaningful computation.\nThey are not even related to one another.\n\nIt's not a real-world example, but in the larger scheme of things, that's the essence of a _fibonacci_ number.\n\nWhat does this have to do with Fibonacci?\n\nhttp://en.wikipedia.org/wiki/Fibonacci_number\n\nI was expecting this:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod_int(n: int, p: int) -> int:\n    \"\"\"Return the integer portion of the result.\n    >>> mod_int(3, 5)\n    3\n    >>> mod_int(1101, 101)\n    2\n    >>> mod_int(0, 101)\n    1\n    >>> mod_int(3, 11)\n    8\n    >>> mod_int(100, 101)\n    1\n    \"\"\"\n    def mod_int(n: int, p: int) -> int:\n    \"\"\"Return 2^n modulo p.\n    >>> mod_int(3, 5)\n    3\n    >>> mod_int(1101, 101)\n    2\n    >>> mod_int(0, 101)\n    1\n    >>> mod_int(3, 11)\n    8\n    >>> mod_int(100, 101)\n    1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp_int(n: int, p: int):\n    \"\"\"Return modp(n, p).\"\"\"\n    if n > 0:\n       return modp(n, p)\n    return 0\nI would return 1 when n == 0, or 0 when n == 1.\n\nI would have named this as modp_intp, but then it would not have worked with integers.\n\nYou are correct, modp_int would return 1 for non-positive integer argument (0 == 1).\n\nI find it interesting that the author points out the similar use of modulo in finite fields. Although a bit of a tangent, this is interesting because it relates to another recent post on HN about using the discrete logarithm problem to factor integers in RSA.\n\nI love that HN's titles are not always the best. I spent about five minutes thinking about the modulus of an equation, only to come across this post which explains the concept without the use of equations. :)\n\nAnother way to see the usefulness of modulo is to apply it to the polynomial x^2 - x +", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is not quite true.\n>>> modp(3, 5)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"/home/adrian/Documents/python/modp.py\", line 3, in modp\nreturn 2 ** n % p\nTypeError: '%' object is not callable\n\nLooks like the % operator is not defined for float/double, and float/double are\nthe default types for matrices.\n\nIn that case, it should probably use an error message of the form \"can't\nmodulo two integers\", instead of \"can't modulo % int\".\n\nAlso, that module has a test (tuple_matrix_1.py) that fails on python 2.3 (but not on python 2.4).\n\nI like the way the test suite includes an example of the use of the module.\n\nI like the library, but I have a couple of suggestions:\n1) in the usage section, you should show how to use the first and last values of a matrix, not just the middle.\n2) I like that the library includes modulo in", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n>>> modp(3, 8)\n6\n\n>>> modp(1101, 8)\n6\n\n>>> modp(3, 11)\n6\n\n>>> modp(100, 8)\n6\n\n>>> modp(3, 11)\n6\n\n>>> modp(100, 8)\n6", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def pow(n: int, p: int, m: int):\n    \"\"\"Return n^p, where m is the result of raising n to the power of p.\n    >>> pow(3, 4, 5)\n    27\n    >>> pow(3, 4, 5, 6)\n    135\n    >>> pow(3, 4, 5, 6, 7)\n    855\n    >>> pow(3, 4, 5, 6, 7, 8)\n    2785\n    >>> pow(3, 4, 5, 6, 7, 8, 9)\n    56765\n    >>> pow(3, 4, 5, 6, 7, 8, 9, 10)\n    8556765\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def unmod(n: int, p: int):\n    \"\"\"Return n modulo p.\n    >>> unmod(3, 5)\n    1\n    >>> unmod(1101, 101)\n    0\n    >>> unmod(0, 101)\n    1\n    >>> unmod(3, 11)\n    11\n    >>> unmod(100, 101)\n    101\n    \"\"\"\n\nThis code appears to work as expected in Python 2.6.2 on Mac OS X.\nWhat version of Python are you using?\n\nI am using Python 2.7.3 on Mac OS X.\n\nAs others have mentioned, that's an important difference. The Python2.7 version is correct as written.\n\nIt's still odd that the Python 2.6 version behaves differently from 2.7.\nI think the 2.7 version should raise an error.\n\nI don't think so. The way I see it, 2.6's behavior is the correct one.\n\nYes, I agree. I don't see", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return (n % p) == 0", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nBut it's not very efficient, and I'm not sure if it's good form to use a one-liner in a production setting.\n\nThis was the one I was going to comment on as well.\nIn Python, if you need to perform modulo arithmetic, it's much more efficient to use the integer division operator:\n>>> div(3, 5)\n3\n>>> div(1101, 101)\n3\n\nIn PHP it's just 1 line\n$number = 2; // n\n$number = $number % 10; // p\n$return = floor($number % $p); // mod p\necho $return;\n\nI was just going to write that, but I saw you already did it!\nI often use this (from the PHP manual):\n<?php\n$n = 11;\n$p = 101;\necho floor($n % $p);\n?>\nIf you're going to write two lines anyway, then I think it's a good idea to write the two lines of code that do it in the most efficient way.\n\nIs there a reason why the 2 lines are better than the 1 line?\n\nIt's not just the space, but", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def pow(x: int, n: int):\n    \"\"\"Returns the power of x to n.\n    >>> pow(3, 5)\n    25\n    >>> pow(3, 6)\n    5\n    >>> pow(3, 12)\n    125\n    >>> pow(3, 15)\n    3\n    >>> pow(3, 16)\n    6\n    >>> pow(3, 17)\n    9\n    >>> pow(3, 18)\n    12\n    >>> pow(3, 19)\n    15\n    >>> pow(3, 20)\n    21\n    \"\"\"\n\n    def divmod(x: int, y: int):\n    \"\"\"Returns the divisor of x to y.\n    >>> divmod(3, 5)\n    3\n    >>> divmod(3, 11)\n    0\n    >>> divmod(3, 100)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def modp_int(n: int):\n    \"\"\"Return the integer part of 2^n modulo p.\n    >>> modp_int(3)\n    3\n    >>> modp_int(1101)\n    3\n    >>> modp_int(0)\n    1\n    >>> modp_int(3, 11)\n    8\n    >>> modp_int(100, 101)\n    1\n    \"\"\"\n\n    def rmodp(n: int):\n    \"\"\"Return 2^n modulo p.\n    >>> rmodp(3, 5)\n    3\n    >>> rmodp(1101, 101)\n    2\n    >>> rmodp(0, 101)\n    1\n    >>> rmodp(3, 11)\n    8\n    >>> rmodp(100, 101)\n    1\n    \"\"\"\n\n>>> modp_int(", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def __init__(self, p: int, n: int):\n    \"\"\"Init the modp function.\n    >>> modp = __init__(p=3, n=2)\n    >>> modp(5, 3)\n    3\n    >>> modp(9, 3)\n    5\n    >>> modp(3, 5)\n    2\n    >>> modp(1101, 101)\n    2\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return lambda n: n * 2 ^ p\n\nHere is a slightly nicer version of modp, using the fact that you can use a lambda in place of a callable:\n>>> modp = lambda x: x*2 ^ p\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(3, 11)\n8\n>>> modp(100, 101)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n\n    def modp_negative(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp_negative(3, 5)\n    -1\n    >>> modp_negative(1101, 101)\n    3\n    >>> modp_negative(0, 101)\n    1\n    >>> modp_negative(3, 11)\n    8\n    >>> modp_negative(100, 101)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def mmod(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> mmod(3, 5)\n    3\n    >>> mmod(1101, 101)\n    2\n    >>> mmod(0, 101)\n    1\n    >>> mmod(3, 11)\n    8\n    >>> mmod(100, 101)\n    1\n    \"\"\"\n\n    def mod2(n: int):\n    \"\"\"Return 2^n\n    >>> mod2(3)\n    6\n    >>> mod2(0)\n    1\n    \"\"\"\n    def get_mod(n: int, p: int):\n    \"\"\"Return n mod p (be aware of numerics).\n    >>> get_mod(3, 5)\n    3\n    >>> get_mod(1101, 101)\n    2\n    >>> get_mod(0", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nIt's not exactly'simple' - it's been moved out of the standard library now.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nBut it's not a modulo function, it's just the remainder of the division, so it's not even correct.\n\nIt is a modulo function. It's just not a _remainder_ function.\n\nWhat he is complaining about is that the function doesn't do what he expects for integer modulo. For example, it doesn't return 2 modulo 7 or 0 modulo 7.\n\nIf you're interested in doing integer division modulo a prime, this snippet does the job:\n>>> from collections import defaultdict\n>>> def mod(n: int, p: int):\n...       \"\"\"Return 2^n modulo p.\n...       >>> mod(3, 5)\n...       3\n...       >>> mod(1101, 101)\n...       2\n...       >>> mod(0, 101)\n...       1\n...       >>> mod(3, 11)\n...       8\n...       >>> mod(100, 101", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return (a ** (b * b)) % p\n\nThese are really nice!</s>"]]