[["def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> mod(1101, 101)\n    11\n    >>> mod(3, 5)\n    3\n    >>> mod(0, 101)\n    1\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    1\n    \"\"\"\n\nI'm not sure what you mean by \"the difference is that modp() takes a tuple of ints as the second argument\". What does that mean?\n\nI think he means that the tuple is passed to the mod function.\n\nYes, that's what I meant.\n\nI don't understand the point of the article.\n\nI was hoping for an explanation of why the difference between the two functions is useful, but instead I got a bunch of handwaving about how modp() is \"cool\" and \"awesome\".\n\nThe difference is that modp() takes a tuple of ints as the second argument. This is useful if you want to", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThat is a neat function. I'm not sure if it's a good idea to use it as a default though.\n\nI don't think it's a good default either, but I do think it's a good function to know about.\n\nIt's a good default, but only if you know that 2^n mod p is the same as n % p.\n\nNo, it's not. That's why it's a bad default.\n\nThe default should be the modulus operator.\n\nI disagree. I would expect the modulus operator to be in the language already.\n\nIt is in every language I know of.\n\nPython, Ruby, Javascript, C#, etc.\n\nI think it's a good default.\n\nIt's a horrible default.\n\nIt's not a good default.\n\nIt's a bad default.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return n % p\nI don't know why I never thought of that. I have to use modulo a lot.\n\nI'm not a big fan of the \"def\" style. I use it for functions I only want to use once, but if I use it more than once I make a function.\n\nI use it for functions that are trivial and unlikely to be used more than once.\n\nI use it for functions that are trivial and unlikely to be used more than once.\n\nI use it for functions that are trivial and unlikely to be used more than once.\n\nI use it for functions that are trivial and unlikely to be used more than once.\n\nI use it for functions that are trivial and unlikely to be used more than once.\n\nI use it for functions that are trivial and unlikely to be used more than once.\n\nI use it for functions that are trivial and unlikely to be used more than once.\n\nI use it for functions that are trivial and unlikely to be used more than once.\n\nI use it for functions that are trivial and unlikely to be used more than once.\n\nI use it for functions that are trivial and unlikely to be used more", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return 2 ** n % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def modp(n: int, p: int):", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def __init__(self, n: int, p: int):\n    self.n = n\n    self.p = p\n    def mod(self, n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    2\n    >>> mod(0, 101)\n    1\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    1\n    \"\"\"\n    return modp(self.n, self.p)\n\nThis is the kind of thing that I find a lot of people struggle with when they first start programming. It's also the kind of thing that's very useful to know how to do when you're doing scientific computing.\n\nI don't see how this is any different from the explanation in the post.\n\nHe's using the modulus operator on the right hand side, instead of", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is a good example of a good way to write code, but I can't see it being useful for anything. What would you use this for?\n\nYou can use this to get the remainder of a division. For example,\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n\nYou can also use this to get the remainder of a modulo operation. For example,\n>>> modp(2, 3)\n1\n>>> modp(11, 12)\n0\n>>> modp(101, 102)\n1\n\nAnd you can use it to get the remainder of a modulo operation of a modulo operation. For example,\n>>> modp(11, 12, modp(3, 5))\n1\n\nYou can also use it to get the remainder of a modulo operation of a modulo operation of a modulo operation. For example,\n>>> modp(11, 12, modp(3, 5, modp(11, 12, mod", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is a classic example of the \"right tool for the job\" problem.\nPython has a native modulo operator, but for some reason the author chose to use a completely different function.\n\nI actually don't know what the native modulo operator is. I only know of modp() because I've been reading C++ books. I guess it's a good thing I didn't use the native modulo operator because I would have been using a function I didn't know existed.\n\nPython has a native modulo operator, and it's the same as modp. You can use it in this case:\n>>> 3 % 5 == 3\nTrue\n>>> 3 % (5, 6) == 3\nTrue\n>>> 3 % (1101, 101) == 3\nTrue\n>>> 3 % (0, 101) == 3\nTrue\n>>> 3 % (3, 11) == 8\nTrue\n>>> 3 % (100, 101) == 1\nTrue\n>>> 3 % (3, 11) == 8\n\nThanks!\n\nIn python, the modulo operator is the same as the % operator.\n>>> 3 % 5 == 3\nTrue\n>>> 3 % (5, 6) == 3", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nFor those who don't know, modp is a faster way to get the remainder of a division. It is faster than the division operation because it is implemented in hardware.\n\nI'm not sure what the point of the first example is. If you're dividing by 3 and 5, you'll get 3 or 5 as the result.\n\nI guess it's just to show that it works for any number.\n\nI think the point is to show that you can use it to get the remainder of a division, since modp is often used in the context of division.\n\nI'm not sure what the point of the second example is. If you're dividing by 1101 and 101, you'll get 1101 or 101 as the result.\n\nI think it's to show that it works for any number.\n\nI think the point is to show that you can use it to get the remainder of a division, since modp is often used in the context of division.\n\nI'm not sure what the point of the third example is. If you're dividing by 3 and 11, you'll get 3 or 11 as the result.\n\nI think it's to show that it works for any number.", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI'm not sure why you would want to do this, but here is a function that does it:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI think the correct answer is not to use modp at all.\n\nThe answer is to use a modulo operator, which will be faster than modp.\n\nThis is a very good answer.\n\nI'm not sure if this is the best way to do this, but it is a good way.\n\nThe best way to do this is to not do it.\n\nThis is the best way.\n\nI'd use a library that already has the modulo operator implemented.\n\nI'd just use a language that has a built in modulo operator.\n\nI'd use a language that already has the modulo operator implemented and a library that already has the modulo operator implemented.\n\nI'd use a language that already has the modulo operator implemented, a library that already has the modulo operator implemented, and a framework that already has the modulo operator implemented.\n\nI'd use a framework that already has the modulo operator implemented, a language that already has the modulo operator implemented, a library that already has the modulo operator implemented, and a framework that already has the modulo operator implemented.\n\nI'd use a framework that already has the modulo operator implemented, a", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def divmod(n: int, p: int):\n    \"\"\"Return n/p (be aware of numerics).\n    >>> divmod(3, 5)\n    3\n    >>> divmod(1101, 101)\n    1101/101\n    >>> divmod(0, 101)\n    0/101\n    >>> divmod(3, 11)\n    3/11\n    >>> divmod(100, 101)\n    100/101\n    \"\"\"\n    def mod(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    1111\n    >>> mod(0, 101)\n    0\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    100\n    \"\"\"\n    def divmod(n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThe modulus operator is one of those things that is easy to get wrong. You can make it very hard to read code, and it can be very hard to debug.\n\nYou can do this in python with the __mod__ operator.", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def mod(n: int, p: int):\n    \"\"\"Return n modulo p.\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    11\n    >>> mod(0, 101)\n    0\n    >>> mod(3, 11)\n    11\n    >>> mod(100, 101)\n    1\n    \"\"\"\n\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    101\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    11\n    >>> modp(100, 101)\n    11\n    \"\"\"\n\n    def mod_p(n: int, p: int):\n    \"\"\"Return n", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def divp(n: int, p: int):\n    \"\"\"Return 2^n divided by p (be aware of numerics).\n    >>> divp(3, 5)\n    3\n    >>> divp(1101, 101)\n    3\n    >>> divp(0, 101)\n    1\n    >>> divp(3, 11)\n    8\n    >>> divp(100, 101)\n    1\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is a very common thing to do in cryptography. It's often called the \"modulus\" of a number.\n\nYes, but it is also a common thing to do in mathematics.\n\nThis is not a very useful function, as there are much better ways to calculate the modulus.\n\nI have no idea why this was downvoted. The modulus is calculated with\nn = floor(2^n - p)\nin every textbook I've ever seen.\n\nI think that's because the other method is a little more obscure.\n\nIt's also the method used by most programming languages.\n\nI'm not sure about that. The modulus operator in Python and Ruby, for example, is just the operator modulo a number.\n\nIn Ruby, mod is the same as floor, and floor is the same as mod.\n\nI'd like to see the implementation of this function in Ruby.\n\nThe Ruby interpreter is written in C, so you can see it there.\n\nI'm not sure what you're getting at.\n\nI think he's suggesting that the implementation of Ruby in C is a good way to see how the mod operator works in Ruby.", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI'm not sure what you are trying to say here, but modp is not the right function for what you are trying to do. modp is defined as:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI think this is a pretty good example of why you should use the \"C\" naming convention when naming your methods.\n\nI'm not sure I agree, I think it's a good example of why you should use the \"Python\" naming convention.\n\nI think it's a good example of why you should use the \"D\" naming convention.\n\nI think it's a good example of why you should use the \"Lisp\" naming convention.\n\nI think it's a good example of why you should use the \"Haskell\" naming convention.\n\nI think it's a good example of why you should use the \"C++\" naming convention.\n\nI think it's a good example of why you should use the \"C\" naming convention.\n\nI think it's a good example of why you should use the \"Perl\" naming convention.\n\nI think it's a good example of why you should use the \"Ruby\" naming convention.\n\nI think it's a good example of why you should use the \"Go\" naming convention.\n\nI think it's a good example of why you should use the \"Java\" naming convention.\n\nI think it's a good example", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI think this is a really bad idea. It's very confusing to have this method that returns a different result depending on how you call it.\n\nI don't think it's that bad. The original function returns the remainder of dividing by a number. The new function returns the remainder of dividing by a number _modulo another number_.\n\nYou are correct, but I still think it's a bad idea. It's very confusing to have this method that returns a different result depending on how you call it.\n\nI think that's a bit of a stretch. It's a bit of a stretch to call the original function \"mod\" in the first place.\n\nI don't think it's a stretch at all. It's very clear what the original function does. It's very clear what the new function does. It's not clear what the new function does if you look at the code and say \"What does it do?\"\n\nWell, I guess I just don't agree. I think the function name is a lot more important than you're giving it credit for.\n\nI don't think it's a stretch at all. It's very clear what the original function does. It's very clear what the new function", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI don't understand why you would do this.\n\nI don't understand why you would do this either, but it's a very simple implementation. The real question is: Why would you use this?\n\nIt's a very common interview question, and a nice simple way to show that you understand modulo.\n\nI don't see how it shows you understand modulo.\n\nIt's a simple way to show that you understand modulo, not that you understand modulo.\n\nI don't see how it shows that you understand modulo.\n\nIt's a simple way to show that you understand modulo, not that you understand modulo.\n\nI don't see how it shows that you understand modulo.\n\nIt's a simple way to show that you understand modulo, not that you understand modulo.\n\nI don't see how it shows that you understand modulo.\n\nIt's a simple way to show that you understand modulo, not that you understand modulo.\n\nI don't see how it shows that you understand modulo.\n\nIt's a simple way to show that you understand modulo, not that you understand modulo.\n\nI don't", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp_int(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp_int(3, 5)\n    3\n    >>> modp_int(1101, 101)\n    2\n    >>> modp_int(0, 101)\n    1\n    >>> modp_int(3, 11)\n    8\n    >>> modp_int(100, 101)\n    1\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return (n%p == 0)? n : n / p\n\nThis is a common pattern in the Python community. I like it.\n\nI'm not a Python programmer, but I'm curious if there are other languages that don't have this pattern.\n\nThere's probably something similar in C, but you'd have to write it yourself.\n\nThere is something similar in C, it's the modulo operator.\n\nI'm not a Python programmer, but I'm curious if there are other languages that don't have this pattern.\n\nThere's probably something similar in C, but you'd have to write it yourself.\n\nThere is something similar in C, it's the modulo operator.\n\nI'm not a Python programmer, but I'm curious if there are other languages that don't have this pattern.\n\nThere's probably something similar in C, but you'd have to write it yourself.\n\nThere is something similar in C, it's the modulo operator.\n\nI'm not a Python programmer, but I'm curious if there are other languages that don't have this pattern.\n\nThere's probably something similar in C, but you'd have to write it", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n>>> modp(3, 5)\n3\n\n>>> modp(1101, 101)\n2\n\n>>> modp(0, 101)\n1\n\n>>> modp(3, 11)\n8\n\n>>> modp(100, 101)\n1\n\n>>> modp(3, 5)\n3\n\n>>> modp(1101, 101)\n2\n\n>>> modp(0, 101)\n1\n\n>>> modp(3, 11)\n8\n\n>>> modp(100, 101)\n1\n\n>>> modp(3, 5)\n3\n\n>>> modp(1101, 101)\n2\n\n>>> modp(0, 101)\n1\n\n>>> modp(3, 11)\n8\n\n>>> modp(100, 101)\n1\n\n>>> modp(3, 5)\n3\n\n>>> modp(1101, 101)\n2\n\n>>> modp(0, 101)\n1\n\n>>> modp(3, 11)\n8\n\n>>> modp(100, 101)\n1\n\n>>> modp(3, 5)\n3", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nSo what?\n\nThe OP is not the author of the code. I think the point is that there's a lot of code out there, and some of it is... not good.\n\nI know it's not the author of the code, but what's the point of this? It's just a stupid implementation of modp.\n\nI think the point is that there's a lot of code out there, and some of it is... not good.\n\nI know it's not the author of the code, but what's the point of this? It's just a stupid implementation of modp.\n\nI think the point is that there's a lot of code out there, and some of it is... not good.\n\nI know it's not the author of the code, but what's the point of this? It's just a stupid implementation of modp.\n\nI think the point is that there's a lot of code out there, and some of it is... not good.\n\nI know it's not the author of the code, but what's the point of this? It's just a stupid implementation of modp.\n\nI think the point is that there's a lot of", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI think this is better:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is not a valid Python program. The first line is not valid Python syntax.\n\nThis is just the implementation. The first line is a comment.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def mod_p(n: int, p: int):\n    \"\"\"Return n modulo p.\n    >>> mod_p(3, 5)\n    3\n    >>> mod_p(1101, 101)\n    1101\n    >>> mod_p(0, 101)\n    1\n    >>> mod_p(3, 11)\n    8\n    >>> mod_p(100, 101)\n    1\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI didn't understand the need for this function, since I usually just use the builtin modulus operator, but I looked it up, and it turns out that modp() is faster than the modulus operator for large numbers.\n\nI'm surprised that the article doesn't mention the modulo operator, which is what I've always used.\n\nIt's just a different way of writing the same thing.\n\nThis is not the same thing.\n\nI've never understood why people don't use the modulo operator. It's so much easier to read and write.\n\nI don't see how the modulo operator is any easier to read than modp(). The latter is just a shorter way of writing the former.\n\nIt is a lot easier to read. You can immediately see what you're dealing with, and you don't have to calculate in your head.\n\nYou don't have to calculate in your head with the modulo operator either.\n\nYou have to calculate in your head whether it's zero or not.\n\nNo you don't. The modulo operator returns 0 if the result is zero.\n\nYou have to calculate in your head whether it's zero or not.", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod(m: int):\n    \"\"\"Return m modulo p (be aware of numerics).\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    2\n    >>> mod(0, 101)\n    1\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    1\n    \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def mod2(m: int):", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI'm not sure if I'm missing something but this function is just returning the integer 0 for any input.\n\nThe code is correct, the problem is the author's description.\nThe function is returning the remainder after dividing 2^n by p.\n\nI don't think that is the problem. The problem is the author's definition of modulo.\n\nThat's what I meant by \"the author's description\"\n\nI would also like to see the code for the rest of the functions on that page.\n\nI don't know if it's the code, or the fact that I'm hungover, but this is beautiful.\n\nThe code is beautiful, but the explanation is a little weak.\n\nThis is beautiful.\n\nI'm not sure if you are serious or not, but I love the design of this.\n\nWhy would I not be serious?\n\nJust for the record, I love the design of this.\n\nThat's not a function.\n\nThe code is beautiful, but the explanation is a little weak.\n\nThis is beautiful.\n\nI'm not sure if you are serious or not, but I love the design of this.\n\nWhy would I", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThat's exactly what I was looking for.\nThanks a lot, it's really useful.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI wonder if this was inspired by the Haskell library of the same name: https://hackage.haskell.org/package/modp\n\nI have a question about this:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp_prime(n: int):\n    \"\"\"Return 2^n modulo p if n is prime.\n    >>> modp_prime(3)\n    True\n    >>> modp_prime(1101)\n    False\n    >>> modp_prime(0)\n    False\n    >>> modp_prime(3)\n    False\n    >>> modp_prime(1101)\n    True\n    >>> modp_prime(3)\n    True\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def mod(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    2\n    >>> mod(0, 101)\n    1\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    1\n    \"\"\"\n\n    def modp(n: int, p: int, mod: int):\n    \"\"\"Return 2^n modulo p, mod p.\n    >>> modp(3, 5, mod)\n    3\n    >>> modp(1101, 101, mod)\n    2\n    >>> modp(0, 101, mod)\n    1\n    >>> modp(3, 11, mod)\n    8\n    >>> modp(100, 101, mod)\n    1\n    \"\"\"\n\nModulo operator", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod2p(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> mod2p(3, 5)\n    3\n    >>> mod2p(1101, 101)\n    2\n    >>> mod2p(0, 101)\n    1\n    >>> mod2p(3, 11)\n    8\n    >>> mod2p(100, 101)\n    1\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is not a very good example.\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n1\n>>> modp(0, 101)\n0\n\nThis is a much better example.\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n\nI don't think this is a good example.\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n\nI don't think this is a good example.\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n\nI don't think this is a good example.\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n\nI don't think this is a good example.\n>>> modp(3, 5)\n3\n>>> modp(1101,", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def __init__(self, n: int, p: int):\n    \"\"\"Initialize the module.\n    >>> modp = __init__(3, 5)\n    >>> modp(3, 5)\n    3\n    >>> modp(3, 11)\n    8\n    \"\"\"\n    def __radd__(self, r: int, d: int):\n    \"\"\"Return 2^(n+r) modulo p.\n    >>> modp(3, 5) + modp(3, 11)\n    >>> modp(3, 11)\n    8\n    >>> modp(3, 11) % modp(3, 11)\n    2\n    \"\"\"\n    def __rsub__(self, r: int, d: int):\n    \"\"\"Return 2^(n+r) modulo p.\n    >>> modp(3, 5) - modp(3, 11)\n    >>> modp(3, 11", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n         return ((2 ** n) - (2 ** p)) % p\n\nimport math", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI would've used a range, but it's not too bad.\n\nPython's range() and modulo() are both built-in functions, so you don't have to import anything.\n\nI like this example because it is short and sweet.\n\nThis is pretty cool, but it doesn't have any examples of the real power of python. I don't mean to sound snobby, but the examples are pretty boring.\n\nThat's not the point. The point is to demonstrate the _simplicity_ of python.\n\nI don't know about you, but I'm not a programmer because I like simplicity. I like to solve problems with code.\n\nSimplicity is the solution to many problems.\n\nI agree. But it's not the _only_ solution to many problems.\n\nThis is a good point.\n\nI was hoping for an example of using \"a\" as a variable.\n\nI like the way the Python docs have the examples in context.\n\nI like the way Python is simple.\n\nI'm not a Python programmer. But I like the way Python is simple.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def __init__(self, n: int, p: int):\n    \"\"\"Initialize the modulus to be a power of 2.\n    >>> modp = modp(3, 5)\n    >>> modp\n    <type 'int'>\n    >>> modp(0, 100)\n    <type 'int'>\n    >>> modp(3, 11)\n    <type 'int'>\n    \"\"\"\n    def __str__(self):\n    \"\"\"Return the string representation of the modulus.\n    >>> modp('3', 5)\n    '3'\n    >>> modp('1101', 101)\n    '1101'\n    >>> modp('3', 11)\n    '8'\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp2(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp2(3, 5)\n    3\n    >>> modp2(1101, 101)\n    2\n    >>> modp2(0, 101)\n    1\n    >>> modp2(3, 11)\n    8\n    >>> modp2(100, 101)\n    1\n    \"\"\"\n    def modp3(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp3(3, 5)\n    3\n    >>> modp3(1101, 101)\n    2\n    >>> modp3(0, 101)\n    1\n    >>> modp3(3, 11)\n    8\n    >>> modp3(100, 101)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return n modulo p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def mod(p: int, n: int):\n    \"\"\"Return p modulo n.\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    2\n    >>> mod(0, 101)\n    1\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    1\n    \"\"\"\n    def mod(p: int, n: int):\n    \"\"\"Return p modulo n.", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThere is a more efficient way of doing this.\n>>> mod(3, 5)\n3\n>>> mod(1101, 101)\n2\n>>> mod(0, 101)\n1\n>>> mod(3, 11)\n8\n>>> mod(100, 101)\n1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def modp(n: int, p: int, modp: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return 2 ** n % p\n\nI would have said:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp2(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp2(3, 5)\n    3\n    >>> modp2(1101, 101)\n    2\n    >>> modp2(0, 101)\n    1\n    >>> modp2(3, 11)\n    8\n    >>> modp2(100, 101)\n    1\n    \"\"\"\n    def modp3(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp3(3, 5)\n    3\n    >>> modp3(1101, 101)\n    2\n    >>> modp3(0, 101)\n    1\n    >>> modp3(3, 11)\n    8\n    >>> modp3(100, 101)\n    1\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod_p(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> mod_p(3, 5)\n    3\n    >>> mod_p(1101, 101)\n    2\n    >>> mod_p(0, 101)\n    1\n    >>> mod_p(3, 11)\n    8\n    >>> mod_p(100, 101)\n    1\n    \"\"\"\n\nA few years ago I wrote a similar function for a project. It was called mod_m (mod m) and worked for all integers.\n\nNice.\n\nI think it's pretty neat.\n\nThe code looks pretty good.\n\nI like it.\n\nIt's a good idea.\n\nI think it's a good idea.\n\nI think it's a good idea.\n\nIt's a good idea.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return n % p\nI don't understand why this is better than just using Python's built-in modulo.\nIt seems to be a minor optimization.\n\nIt's not. The built-in modulo is a better choice.\n\nThe built-in modulo is not a better choice. It has the same problem as the Pythonic method. If the argument is zero, the result is 1. If the argument is 1, the result is 0. If the argument is 2, the result is 1.\n\nHow is that a problem?\n\nIt's not a problem.\n\nThis is a pretty cool trick. I wonder how it compares to the built-in modulo operator?\n\nI'm not sure if it's faster than the built-in modulo, but it does have the advantage that it's a lot easier to read.\n\nIt's not faster. But it is easier to read.\n\nI'm not sure if it's easier to read.\n\nIt's not easier to read.\n\nIt's not.\n\nI'm not sure if it's.\n\nIt's not.\n\nI'm not sure if it's.\n\nIt's", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThe Python documentation has a very clear explanation of how this works:\n\nThat's not very clear at all.\nI was hoping for a better explanation.\n\nIt's very clear if you know what a modulo operation is. If you don't, you can look it up.\n\nThe linked article doesn't explain it at all.\n\nI don't understand what you want explained. It's a modulo operation. It's not a hard concept.\n\nThe problem is that I don't know what a modulo operation is.\n\nIt's pretty simple. You're given an integer n. The function modp(n, p) returns the remainder of the division of n by p.\n\nI don't know what a remainder is.\n\nIt's pretty simple. The remainder of the division of n by p is the number of times that n goes into p without a remainder.\n\nI don't know what \"goes into\" means.\n\nI don't know what a \"number\" is.\n\nI don't know what an \"integer\" is.\n\nI don't know what \"modulo\" is.\n\nI don't know what \"division\" is.", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return 2**n % p\nI'm not sure how this is a better solution than what was already there, which is:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return int(p % n)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nHow is this better than the built in _mod_ function?\n\n_mod_ is not portable.\n\nI'm not sure I see how it's not portable, it's part of the C standard library.\n\nI think he meant portable in the sense that it's available on many platforms.\n\nI'm not sure I see how it's not portable, it's part of the C standard library.\n\nI think he meant portable in the sense that it's available on many platforms.\n\nI'm not sure I see how it's not portable, it's part of the C standard library.\n\nI think he meant portable in the sense that it's available on many platforms.\n\nI'm not sure I see how it's not portable, it's part of the C standard library.\n\nI think he meant portable in the sense that it's available on many platforms.\n\nI'm not sure I see how it's not portable, it's part of the C standard library.\n\nI think he meant portable in the sense that it's available on many platforms.\n\nI'm not sure I see how it's not portable, it's part of the C standard library.\n\nI think", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return n % p\nI don't think this is the best example, because the modulus operator is one of the more difficult to understand.\nThe modulus operator is the inverse of the remainder operator. The remainder operator is the inverse of the division operator.\nSo if you know that, you can see that modulus is the inverse of division, which is just multiplying by the reciprocal.\n\nNot only is it a bad example, it's a bad example _of a bad example_.\nThe only reason to use modulus is if you're doing arithmetic modulo a prime number.\nIt's a pretty", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def __init__(self, n: int, p: int):\n        self.n = n\n        self.p = p\n    def mod(self, n: int, d: int):\n        if n == d:\n            return n\n        if n == p:\n            return p\n        return self.modp(n, d)\n\nNote that the function modp() is the only thing that mod() calls. The first version of mod() simply returns n. The second version calls modp() to compute the result.\n\nExample:\n>>> mod(3, 5)\n3\n>>> mod(3, 11)\n8\n>>> mod(3, 100)\n1\n>>> mod(3, 101)\n2\n>>> mod(3, 1101)\n2\n>>> mod(3, 10101)\n1\n>>> mod(3, 10001)\n2\n>>> mod(3", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThe author of the post wrote:\n\"I am not sure if this is a bug or not, but I thought I would bring it up to the community.\"\nIt's not a bug. The author just doesn't understand what modp does.\n\nIt is a bug.\nThe documentation for modp is:\n\"Return 2^n modulo p (be aware of numerics).\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n>>> modp(3, 1101)\n3\n>>> modp(100, 10101)\n0\n>>> modp(0, 10101)\n-1\n>>> modp(3, 110101)\n-3\n>>> modp(100, 1010101)\n-2\n>>> modp(0, 1010101)\n-1\n>>> modp(3, 11010101)\n-3\n>>> modp(100, 101010101)\n-2\n>>> modp(0,", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nIf you're going to do that, you might as well use the built-in function `mod`.\n\nI don't think that's fair. If you're going to do that, you might as well use the built-in function `sqrt`.\n\nI don't think that's fair. If you're going to do that, you might as well use the built-in function `sin`.\n\nI don't think that's fair. If you're going to do that, you might as well use the built-in function `cos`.\n\nI don't think that's fair. If you're going to do that, you might as well use the built-in function `sinh`.\n\nI don't think that's fair. If you're going to do that, you might as well use the built-in function `cos^2`.\n\nI don't think that's fair. If you're going to do that, you might as well use the built-in function `cos^3`.\n\nI don't think that's fair. If you're going to do that, you might as well use the built-in function `cos^4`.\n\nI don't think that's", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def modp_int(n: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp_int(3)\n    3\n    >>> modp_int(1101)\n    2\n    >>> modp_int(0)\n    1\n    \"\"\"\n\n    def modp_int_int(n: int, p: int):\n    \"\"\"Return 2^n modulo p for ints.\n    >>> modp_int_int(3, 5)\n    3\n    >>> modp_int_int(1101, 101)\n    2\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return the remainder when dividing n by p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def modp_prime(n: int, p: int):\n    \"\"\"Return the remainder when dividing n by p and", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nWhat is the point of this?\n\nThe point is that you can use it to find the remainder of a division.\n\nFor example:\n>>> modp(2, 5)\n3\n>>> modp(2, 11)\n1\n\nThe modulo operator in python returns the remainder of a division.\n\n>>> mod(3, 5)\n2\n>>> mod(2, 5)\n1\n\nThis is why modp is useful.\n\n>>> modp(2, 11)\n1\n\nThe modulo operator in python returns the remainder of a division.\n\n>>> mod(2, 11)\n1\n\nThis is why modp is useful.\n\n>>> modp(2, 11)\n1\n\nThe modulo operator in python returns the remainder of a division.\n\n>>> mod(2, 11)\n1\n\nThis is why modp is useful.\n\n>>> modp(2, 11)\n1\n\nThe modulo operator in python returns the remainder of a division.\n\n>>> mod(2, 11)\n1\n\nThis is why modp is useful.\n\n>>> modp(2, 11)\n1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI find it interesting that the implementation of modp in python is almost identical to the one in C.\n\nI'm not sure I understand how the implementation is similar to C.\nIn C, the modulo operator is an operator on integer types, and modp is a function on integer types.\nIn Python, the modulo operator is a function on integer types, and modp is a function on integer types.\nWhat's the similarity?\n\nThe modulo operator in C is implemented by calling a function named modp on int types.\n\nYou're right, and I'm wrong. I was thinking of the modulo operator on unsigned types, which does not call modp.\n\nI'm not sure this is a good example of python's readability. The code is pretty straightforward, but it's also pretty verbose.\n\nIt's verbose because it's a very simple algorithm. If you have a more complex algorithm, then it's probably less verbose.\n\nI think it's the other way around: the algorithm is simple because it's verbose.\n\nThe modulo operator in python is a function that calls the modp function.\n\nYes, I know that.\nI", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp2(n: int, p: int):\n    \"\"\"Return 2^n modulo p, but don't use floating point.\"\"\"\n    return n % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def __init__(self, n: int, p: int):\n    \"\"\"Create a new modp function.\n    >>> modp = __init__(3, 5)\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    \"\"\"\n    self.n = n\n    self.p = p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp2(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp2(3, 5)\n    3\n    >>> modp2(1101, 101)\n    2\n    >>> modp2(0, 101)\n    1\n    >>> modp2(3, 11)\n    8\n    >>> modp2(100, 101)\n    1\n    \"\"\"\n    def modp3(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp3(3, 5)\n    3\n    >>> modp3(1101, 101)\n    2\n    >>> modp3(0, 101)\n    1\n    >>> modp3(3, 11)\n    8\n    >>> modp3(100, 101)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThat's pretty cool! I've been looking for a way to do this in Python.\n\nIt's a great way to implement a fast and correct way of comparing two numbers.\nI use it all the time.\n\nThis is a very useful function, but it's not the only one.\n\nI don't know about you, but I find it very useful.\n\nI think the point is that there are other modulo functions, and some of them are more useful than modp.\n\nYes, that's what I meant.\n\nIt's a great function.\n\nI agree.\n\nI use it all the time.\n\nI use it all the time.\n\nIt's a great function.\n\nI agree.\n\nI use it all the time.\n\nI use it all the time.\n\nI use it all the time.\n\nIt's a great function.\n\nI agree.\n\nI use it all the time.\n\nI use it all the time.\n\nI use it all the time.\n\nI use it all the time.\n\nIt's a great function.\n\nI agree.\n\nI use it all the", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nPython's modulo is broken, you can't have a negative number of significant digits.\n\nThis is a common misconception. Python's modulo is not broken.\nPython's modulo is _exactly_ what you would expect modulo to be.\nThe problem is that people expect modulo to behave like division, and that's not what modulo is.\nIf you want to calculate the remainder of division, you need to use the modulus operator, not modulo.\n\nPython's modulo is broken for numbers with more than one digit. For example, it rounds down to the nearest integer for numbers with more than one digit.\nThis is not what you would expect modulo to be.\n\nI just did some testing.\n>>> mod(0, 10)\n0\n>>> mod(0, 10)\n1\n>>> mod(0, 10)\n2\n>>> mod(0, 10)\n3\n>>> mod(0, 10)\n4\n>>> mod(0, 10)\n5\n>>> mod(0, 10)\n6\n>>> mod(0, 10)\n7\n>>> mod(0, 10)\n8\n>>> mod(0, 10)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return (n % p) + 1\n\nWhat is the benefit of this over just using a library like libgmp?\n\nIt's faster and more readable.\n\nHow is it faster?\n\nIt's not. It's just a different algorithm.\n\nI'm not sure what's so \"readable\" about it.\n\nIt's a one-liner.\n\nHow is that more readable than:\ngmp.sqrt(3)\nor\ngmp.sqrt(3.0)\nor\ngmp.sqrt(3.0, 4)\nor\ngmp.sqrt(3.0, 4, -2)\n\nYou're right, it's not more readable than that. I guess I didn't understand what the GP meant by \"readable.\"\n\nI'm not sure what you mean by \"readable\" then.\n\nI guess I meant it in the sense that I'm able to read it.\n\nI think it's a good idea to expose the underlying implementation.\n\nThanks!\n\nIt's not really a \"one-liner\", though, since it requires you to import a module.\n\nI don't think", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is really cool!\nI can't believe it's been in Python for so long and I've never heard of it.\n\nIt's a pretty obscure feature. I've used it a few times, but mostly to make sure I was right about something.\n\nI used it in a project I wrote to calculate the modulo of a number given a list of numbers, e.g.\n>>> list(range(10))\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n>>> modp(list(range(10)), 8)\n3\n\nI think this was a very good post, as it showed the power of the language without going into too much detail.\n\nI've been using python for 10 years, and I had no idea you could do this.\n\nI've been using python for 15 years, and I had no idea you could do this.\n\nI've been using python for 25 years, and I had no idea you could do this.\n\nI've been using python for 35 years, and I had no idea you could do this.\n\nI've been using python for 45 years, and I had no idea you", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return 2**n % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return 2^n % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThe modp function returns the remainder of the division of n by p.", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod2(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> mod2(3, 5)\n    3\n    >>> mod2(1101, 101)\n    2\n    >>> mod2(0, 101)\n    1\n    >>> mod2(3, 11)\n    8\n    >>> mod2(100, 101)\n    1\n    \"\"\"\n    def mod3(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> mod3(3, 5)\n    3\n    >>> mod3(1101, 101)\n    2\n    >>> mod3(0, 101)\n    1\n    >>> mod3(3, 11)\n    8\n    >>> mod3(100, 101)\n    1\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return n % p\nThis is a classic case of \"implementation defined\" behavior.\n\nI don't think so. If you look at the code in the article, it's simply\nreturning the remainder of the division.\n\nI agree with you. I was just trying to make a joke. I'll leave now...\n\nI liked the joke.\n\nI think you mean modulo operator.\n\nIndeed, I do.\n\nI'm a little confused as to why they don't have this already.\n\nBecause the language designers have different opinions on what is\nimportant in the language.\n\nSo if it's not a matter of opinion, then what is it?\n\nI don't think it's a matter of opinion. It's a matter of design philosophy.\nFor example, the designers of Python (the language) have a different\nphilosophy than the designers of C++ (the language).\n\nI see. I think I was confused by the wording of the post I was replying to.\n\nI'm sure I'll get downvoted for this, but I can't help but feel that Python is turning into C++.\n\nI'm not sure", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is a bad way to write this function.\nIt would be better to use a library, like the C standard library function modf(), or even better, use the built-in modulo operator.\n>>> import mod\n>>> mod(3, 5)\n3\n>>> mod(1101, 101)\n2\n>>> mod(0, 101)\n1\n>>> mod(3, 11)\n8\n>>> mod(100, 101)\n1\n\nThere are also better ways to write this function, like using a lookup table.\n>>> from itertools import product\n>>> modp = product(2, (2 ** n) - 1, 2)\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n\nSo why is it bad? I mean it's not the most readable thing, but it's not bad.\n\nI think it's bad because it's not idiomatic. I would expect to find this in a codebase, but I would not expect to see", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp_fast(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp_fast(3, 5)\n    3\n    >>> modp_fast(1101, 101)\n    2\n    >>> modp_fast(0, 101)\n    1\n    >>> modp_fast(3, 11)\n    8\n    >>> modp_fast(100, 101)\n    1\n    \"\"\"\n    def modp_slow(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp_slow(3, 5)\n    3\n    >>> modp_slow(1101, 101)\n    2\n    >>> modp_slow(0, 101)\n    1\n    >>> modp_slow(3, 11)\n    8\n    >>> modp_slow(100, 101)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nPython's is operator is a bit odd, it doesn't do integer division, it does integer remainder.\n\n>>> 3 % 5\n3\n>>> 2 % 3\n0\n>>> 3 % (2, 3)\n1\n>>> 3 % (2, 2)\n2\n>>> 2 % (3, 2)\n1\n>>> 2 % (3, 3)\n2\n>>> 3 % (2, 3, 2)\n4\n>>> 2 % (2, 3, 2, 3)\n1\n>>> 2 % (2, 3, 2, 3, 2)\n2\n>>> 2 % (2, 3, 2, 3, 2, 3)\n3\n>>> 2 % (2, 3, 2, 3, 2, 3, 2)\n4\n>>> 2 % (2, 3, 2, 3, 2, 3, 2, 3)\n5\n>>> 2 % (2, 3, 2, 3, 2, 3, 2, 3, 2)\n6\n>>> 2 % (2, 3, 2, 3, 2, 3, 2, 3, 2, 3)\n7\n>>> 2 % (2, 3, 2, 3, 2", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI'm confused, isn't the above just:\n\n>>> mod(3, 5)\n3\n>>> mod(1101, 101)\n2\n>>> mod(0, 101)\n1\n>>> mod(3, 11)\n8\n>>> mod(100, 101)\n1\n\nYes, but it's one line and not 3.\n\nIt's the same number of characters.\n\nI'm not sure what you mean.\n\nI mean that it's the same number of characters whether you write it as three lines or one line.\n\nThere's a difference in clarity, though. I'm not sure what the point of your comment is.\n\nI'm not sure what the point of your original comment was.\n\nTo say that the code was shorter in one line than in three.\n\nIn what sense?\n\nIn the sense that it was easier to understand.\n\nIt was easier to understand because it was shorter?\n\nNo, it was easier to understand because it was more readable.\n\nBut it wasn't shorter.\n\nIt was shorter because it was more readable.\n\nIt was shorter because it was one line instead of three.\n\nNo,", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    if n == 0:\n        return 1\n    else:\n        return n % p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return (p % n) + 1\n\nLooks like a bug to me.\n\nIt's a bug that it returns 1 for 0 modulo 100?\n\nYes, it should be zero.\n\nIt should return zero for 0 modulo 100 if you are using the same convention as the C standard library.\nIn the Python standard library, the result of a modulo operation is the remainder.\n\nPython is not C.\n\nIt's a bug.\n\nIn what sense is it a bug?</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is the wrong solution to the problem. In the problem, you're supposed to find a number which when divided by 1101, will give you 0. The number you're looking for is 101. The solution to the problem is modp(101, 1101).\n\n>>> modp(101, 1101)\n0\n\n>>> modp(101, 1101)\n0\n>>> modp(101, 1101)\n0\n>>> modp(101, 1101)\n0\n>>> modp(101, 1101)\n0\n\nThe author of the question is probably asking you to use a modulus operation on the number you're looking for (101).</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp2(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp2(3, 5)\n    3\n    >>> modp2(1101, 101)\n    2\n    >>> modp2(0, 101)\n    1\n    >>> modp2(3, 11)\n    8\n    >>> modp2(100, 101)\n    1\n    \"\"\"\n    def modp3(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp3(3, 5)\n    3\n    >>> modp3(1101, 101)\n    2\n    >>> modp3(0, 101)\n    1\n    >>> modp3(3, 11)\n    8\n    >>> modp3(100, 101)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod2p(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> mod2p(3, 5)\n    3\n    >>> mod2p(1101, 101)\n    2\n    >>> mod2p(0, 101)\n    1\n    >>> mod2p(3, 11)\n    8\n    >>> mod2p(100, 101)\n    1\n    \"\"\"\n    def modp2(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp2(3, 5)\n    3\n    >>> modp2(1101, 101)\n    2\n    >>> modp2(0, 101)\n    1\n    >>> modp2(3, 11)\n    8\n    >>> modp2(100, 101)\n    1\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI'm not sure I understand the point of this.\n\nIt's a way to get a remainder when dividing by a power of two.\n\nI think he means, why do you need it? If you want a remainder when dividing by a power of two, why not just use the power of two?\n\nYou can't use the power of two for that, because you don't know whether you're dividing by a power of two. It's used to check whether an integer is a power of two.\n\nI know it's used for that, but I don't understand why you would need it.\n\nI don't know if this is the reason, but if you are working with large numbers (say, 100 digits or so) it can be faster to use modp than to calculate 2^100 and check if it's a power of two.\n\nIt's not faster, it's just more correct.\n\nI don't know, I've always been taught to use modp when working with large numbers because it's faster. I'm sure I could find a source if you want.\n\nI'm sure you could find a source that says that 2^100 is faster than modp.", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is a terrible implementation. It is just a different way to write the code\n3 * (2^5) % 5 == 3 * 5 % 2 == 3 * 1 == 1\nWhich is ugly and has no place in python, except maybe in a \"for fun\" module.\n\nIt's not the best way to implement modulo, but it's not a terrible implementation.\nIt's the fastest implementation I've found.\n\nIt is, at the very least, the slowest implementation of modulo I've ever seen.\n\nAnd what implementation is that?", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod(n: int):\n    \"\"\"Return n modulo p (be aware of numerics).\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    2\n    >>> mod(0, 101)\n    1\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    1\n    \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return p modulo n (be aware of numerics).\n    >>> modp(3, 5)\n    5\n    >>> modp(1101, 101)\n    101\n    >>> modp(0, 101)\n    3\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    3\n    \"\"\"\n    def mod_p(n: int, p: int):", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    def modp_n(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp_n(3, 5)\n    3\n    >>> modp_n(1101, 101)\n    2\n    >>> modp_n(0, 101)\n    1\n    >>> modp_n(3, 11)\n    8\n    >>> modp_n(100, 101)\n    1\n    \"\"\"\n\n    def modp_n_p(n: int, p: int, x: int):\n    \"\"\"Return 2^n modulo p, where x is the result of modp_n(n, p)\n    >>> modp_n_p(3, 5, 1101)\n    3\n    >>> modp_n_p(3, 5, 101)\n    3\n    >>> modp_n_p(3, 5, 11)\n    8", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nIt's not hard to make a mistake like this in Python, because the default integer type is a long.\n\nIt's not hard to make a mistake like this in Python, because the default integer type is a long.\n\nI know this is an old thread, but I just ran into the same problem and wanted to point out that this is not a Python bug, but a bug in the modp() function.\n\nThe modulo operator is defined as follows in the C standard:\n\n\"The result of a division operation on two integers, a and b, is the integer r such that b = a * r modulo p, where p is a prime number.\"\n\nThe modp() function in Python is defined as follows:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod_int(n: int):\n    \"\"\"Return the modulo of n by p.\n    >>> mod_int(3, 5)\n    3\n    >>> mod_int(1101, 101)\n    11\n    >>> mod_int(0, 101)\n    1\n    >>> mod_int(3, 11)\n    8\n    \"\"\"\n    def mod_int(n: int, p: int):\n    \"\"\"Return the modulo of n by p.\n    >>> mod_int(3, 5, 2)\n    3\n    >>> mod_int(1101, 101, 2)\n    11\n    >>> mod_int(0, 101, 2)\n    1\n    >>> mod_int(3, 11, 2)\n    8\n    \"\"\"\n    def mod_int(n: int, p: int, mod_int_mode: int):\n    \"\"\"Return the modulo", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    return mod(2^n, p)\nI'm not sure what you're trying to do here, but if you want to return the remainder when dividing n by p, you might want to consider:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def modp(n: int, p: int, q: int):\n    \"\"\"Return 2^n modulo p, q.\n    >>> modp(3, 5, 2)\n    3\n    >>> modp(1101, 101, 2)\n    2\n    >>> modp(0, 101, 2)\n    1\n    \"\"\"\n\nThe C version is a little more efficient:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp2(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp2(3, 5)\n    3\n    >>> modp2(1101, 101)\n    2\n    >>> modp2(0, 101)\n    1\n    >>> modp2(3, 11)\n    8\n    >>> modp2(100, 101)\n    1\n    \"\"\"\n    def modp3(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp3(3, 5)\n    3\n    >>> modp3(1101, 101)\n    2\n    >>> modp3(0, 101)\n    1\n    >>> modp3(3, 11)\n    8\n    >>> modp3(100, 101)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI think you mean modp(n, p)\n\nI think you're right. I was just trying to follow the naming convention of the other methods.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThe thing is, modp() is a built-in function in Python, and so it is available to any Python program.\n\nThe author of the post is using the Python shell, which is a REPL (Read-Eval-Print-Loop). The shell is not a program, but rather a way for a user to interact with the Python interpreter. The interpreter is the program that is running, and the shell is a way for a user to type commands and get results.\n\nSo, in this case, the author is typing the command \"modp(n, p)\", which is then interpreted by the interpreter, and the result is returned to the shell.\n\nThe shell, being a REPL, does not have access to the built-in functions, since the built-in functions are defined in the interpreter, and not in the shell.\n\nWhen a program is executed, it runs in the interpreter. When a user types commands into the shell, the interpreter is interpreting those commands.\n\nSo, in this case, the user is typing a command that is interpreted by the interpreter.\n\nIn order to use the built-in functions, the user must run the program as a program, and not as a command", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nWhy is it that when I use the default python math library, I get an error message?\n>>> import math\n>>> math.modp(3, 5)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nValueError: invalid literal for int() with base 10: '3'\n\nIt's probably because you have Python 2.x. You need Python 3.x for that.\n\nI've got python3.x. I'm not sure what the issue is.\n\nIt's a known bug:\n\nI've always been a big fan of Python's \"there's only one way to do it\" philosophy, but it's hard to see how this fits with that.\nI wonder how much time was spent on this feature.\n\nI don't think it's inconsistent.\nThere is one way to do it, and it's with a function.\nThe function is just a bit more general than it used to be.\n\nBut the \"one way to do it\" philosophy is about simplicity.\nI can't see how a function that does one thing is simpler than a built-in.\n\nThat's because you", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is a good example of the difference between C and Python. The C version uses a function with a single parameter, and that parameter is an integer. The Python version uses a function with two parameters, and the first parameter is an integer. The second parameter is an integer.\nThe C version is more efficient than the Python version, because it doesn't have to do any conversions.\n\nI think the reason for this is that Python is a dynamically typed language, and so the compiler has to assume that everything is an integer unless it is explicitly specified to be something else.\n\nI believe that in Python, integers and floats are the same type, so there is no conversion in the Python version.\n\nI think you are right.\n\nThe C version is more efficient because it is more specific.\n\nI think that's a bit of a stretch. I don't know about you, but I don't see the \"mod\" operation as being more specific than \"modulo\".\n\nI think he means that in C, mod is a built-in function, whereas in Python you have to import it from the math module.\n\nThis is a good example of the difference between C and Python. The C version uses a", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp_from_numerics(n: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp_from_numerics(3)\n    3\n    >>> modp_from_numerics(1101)\n    2\n    >>> modp_from_numerics(0)\n    1\n    \"\"\"\n\nThe 2^n modulo p is a special case of the modular exponentiation, and therefore it is not surprising that the algorithm is very similar to the one for the modular exponentiation.\n\nIn the first step, we get the greatest common divisor (GCD) of 2^n and p.\n\nIn the second step, we multiply the greatest common divisor (GCD) of 2^n and p with 2^n.\n\nIn the third step, we get the remainder of the division of 2^n by p.\n\nIn the fourth step, we multiply the remainder of the division of 2^n by p with p.\n\nIn the fifth step, we get the", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp2(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp2(3, 5)\n    3\n    >>> modp2(1101, 101)\n    11\n    >>> modp2(0, 101)\n    100\n    >>> modp2(3, 11)\n    8\n    >>> modp2(100, 101)\n    1\n    \"\"\"\n    def modp3(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp3(3, 5)\n    3\n    >>> modp3(1101, 101)\n    11\n    >>> modp3(0, 101)\n    100\n    >>> modp3(3, 11)\n    8\n    >>> modp3(100, 101)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod(n: int, p: int):\n    \"\"\"Return n modulo p (be aware of numerics).\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    2\n    >>> mod(0, 101)\n    1\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    1\n    \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def mod(n: int, p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThe more interesting question is, why are you using an int to store a modulo?\n\nI don't know. I just copied it from somewhere.\n\nI'm not sure if you're being serious, but the answer is that there is no reason to use an int to store a modulo.\n\nI'm being serious. I know it's a stupid question, but I've seen it done before.\n\nI don't see why this is a stupid question. I would say that it is a very good question.\nI would like to know the answer as well.\n\nI think it's a good question too, but I also think it's a stupid question. I don't know why someone would use an int to store a modulo.\n\nIt's a stupid question because it's a stupid thing to do.\n\nI think it's a good question because it's an interesting and insightful thing to do.\n\nI agree, but I think it's a stupid question because it's a stupid thing to do.\n\nIt's a stupid question because it's a stupid thing to do.\n\nIt's a stupid question because it's a stupid thing to do.\n\nIt's a stupid", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod_p(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> mod_p(3, 5)\n    3\n    >>> mod_p(1101, 101)\n    2\n    >>> mod_p(0, 101)\n    1\n    >>> mod_p(3, 11)\n    8\n    >>> mod_p(100, 101)\n    1\n    \"\"\"\n    def mod_p(n: int, p: int, mod: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> mod_p(3, 5, 2)\n    3\n    >>> mod_p(1101, 101, 2)\n    2\n    >>> mod_p(0, 101, 2)\n    1\n    >>> mod_p(3, 11, 2)\n    8", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is awesome.\n\nI wonder if there is a use case for this.\n\nI'm sure there is, but I can't think of it.\n\nI wonder what the performance implications are, since it's probably more expensive to do the modulo than to just use a loop.\n\nThe modulo is really fast on modern CPUs, but it's not as fast as a loop.\n\nI remember the first time I used modp, I was surprised at how fast it was.\n\nI'm not sure how to pronounce it.\n\nI say it like \"mod-p\"\n\nI say \"mod-p\" also, but I think it's just because I'm used to reading it that way.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    2\n    >>> mod(0, 101)\n    1\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    1\n    \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    return mod(n, p", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThe problem with this is that it is not the standard modulo operator, which is a binary operator. You're using a unary operator, which makes it not so obvious what it does.\n\nI don't think that's a problem. The Pythonic way to write the modulo operator would be `mod(x, y)`, but that's not a particularly Pythonic way to write it.\n\nI agree with you that it's not a problem for Python. However, if you're using it in C, it's a problem. It's a problem for any language that has a standard modulo operator, which is not Python.\n\nI'm not sure how to solve it. The only solution I can think of is to use a different operator.\n\nThis is one of those things that I'd rather have a function for.\n\nI agree. In my case, I'm writing a library, so I don't have that option.\n\nYou could always use a function from the library.\n\nI suppose so. I don't know why I didn't think of that.\n\nI have a better solution:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n>>> import modp\n>>> print modp(3, 5)\n3\n>>> print modp(1101, 101)\n2\n>>> print modp(0, 101)\n1\n>>> print modp(3, 11)\n8\n>>> print modp(100, 101)\n1\n>>> print modp(3, 1101)\n8\n>>> print modp(11, 1101)\n0\n\n>>> def modp2(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp2(3, 5)\n    3\n    >>> modp2(1101, 101)\n    2\n    >>> modp2(0, 101)\n    1\n    >>> modp2(3, 11)\n    8\n    >>> modp2(100, 101)\n    1\n    >>> modp2(3, 1101)\n    8\n    >>> modp2(11, 1101)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp2(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp2(3, 5)\n    8\n    >>> modp2(1101, 101)\n    7\n    >>> modp2(0, 101)\n    1\n    >>> modp2(3, 11)\n    2\n    >>> modp2(100, 101)\n    0\n    \"\"\"\n    def modp3(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp3(3, 5)\n    8\n    >>> modp3(1101, 101)\n    7\n    >>> modp3(0, 101)\n    1\n    >>> modp3(3, 11)\n    2\n    >>> modp3(100, 101)", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nIt's actually a bit more interesting than that. The second line\nshould be\n>>> modp(3, 5)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: unsupported operand type(s) for -: 'int' and 'int'\n\nI would say that a better solution is to use the built in modulus operator.\n>>> mod(3, 5)\n3\n\nI'd be curious to know how this compares with the built in modulus operator.\n\nThe built-in modulus operator has a different implementation for large integers:\n>>> mod(10**6, 10**6)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: unsupported operand type(s) for -: 'int' and 'int'\n>>> mod(10**6, 10**6**2)\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: unsupported operand type(s) for -: 'int' and 'int'\n>>> mod", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp_from_int(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> modp_from_int(3, 5)\n    3\n    >>> modp_from_int(1101, 101)\n    2\n    >>> modp_from_int(0, 101)\n    1\n    \"\"\"\n    return 2.0 * n % p\n\nThis is pretty cool. I was wondering what the modp function was for. I wrote a function that was very similar to yours.\n\nI have to ask, why not just use an integer division?\n\nI think I originally wrote the function to demonstrate that modulo is the inverse of exponentiation. It was a long time ago, so I can't remember exactly.\n\nI like the way you're using Python.\n\nIt's a good thing that the author added the comment explaining the modulo operator.\n\nThe author did a good job explaining the modulo operator.</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def modp_even(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp_even(3, 5)\n    2\n    >>> modp_even(1101, 101)\n    1\n    >>> modp_even(0, 101)\n    0\n    >>> modp_even(3, 11)\n    7\n    >>> modp_even(100, 101)\n    0\n    \"\"\"\n    def modp_odd(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp_odd(3, 5)\n    7\n    >>> modp_odd(1101, 101)\n    11\n    >>> modp_odd(0, 101)\n    3\n    >>> modp_odd(3, 11)\n    8", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n>>> modp(3, 5)\n3\n>>> modp(1101, 101)\n2\n>>> modp(0, 101)\n1\n>>> modp(3, 11)\n8\n>>> modp(100, 101)\n1\n>>> modp(3, 0)\n0\n>>> modp(3, 1)\n1\n>>> modp(3, 2)\n2\n>>> modp(3, 3)\n3\n>>> modp(3, 4)\n4\n>>> modp(3, 5)\n5\n>>> modp(3, 6)\n6\n>>> modp(3, 7)\n7\n>>> modp(3, 8)\n8\n>>> modp(3, 9)\n9\n>>> modp(3, 10)\n10\n>>> modp(3, 11)\n11\n>>> modp(3, 12)\n12\n>>> modp(3, 13)\n13\n>>> modp(3, 14)\n14\n>>> modp(3, 15)\n15\n>>> modp(3, 16)\n16\n>>> modp(3, 17)\n17", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n    def mod(n: int, p: int):\n    \"\"\"Return 2^n modulo p.\n    >>> mod(3, 5)\n    3\n    >>> mod(1101, 101)\n    2\n    >>> mod(0, 101)\n    1\n    >>> mod(3, 11)\n    8\n    >>> mod(100, 101)\n    1\n    \"\"\"\n    def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\"\n    def mod_p(n: int, p: int", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI just tested it and it works.\n\nI love Python.\n\nThe python version is actually less efficient than the C one.\n\nI don't know why you're getting downvoted, the Python version is more than twice as slow (and I'm not even counting the C version's use of the native int type).\n\nI don't know why you're getting upvoted, the Python version is almost twice as fast (and I'm not even counting the C version's use of the native int type).\n\nI just tested it and it works.\n\nI love Python.\n\nI love Python too, but this is just a bad joke.\n\nPython version is actually less efficient than the C one.\n\nI don't know why you're getting downvoted, the Python version is more than twice as slow (and I'm not even counting the C version's use of the native int type).\n\nI don't know why you're getting upvoted, the Python version is almost twice as fast (and I'm not even counting the C version's use of the native int type).\n\nI just tested it and it works.\n\nI love Python.\n\nI love", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI think it's more like:", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nIn the standard library there's also pow(n, p), which returns 2^(n-1) * p.\n\nI have a hard time thinking of a use for this. I know it's possible, but I can't think of a reason why I'd want to do it.\n\nI was just thinking about this last night. I wanted to find the remainder of a division of two integers.\n\nThere is also modf(n, p) which returns the nth root of 2^(n-1) * p.\n\nI don't see the point. If you want to find the remainder of a division, just subtract the dividend from the divisor.\n\nThis is useful if you want to find the remainder of a division without using any intermediate variables.\n\n>>> modp(3, 5)\n3\n>>> modp(3, 5)\n3\n\nThis is not as clear as the original version.\n\nI prefer:\n>>> modp(3, 5)\n3\n\nI'm not sure that's better. It's not immediately obvious what's going on there, whereas the first version is immediately obvious.\n\nTrue, but it's still more", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\n    return (2^n % p) & 1", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nAs a python programmer, this is a nice example of how to make a small, but useful function.\n\nI'm a Python programmer too, but I would have written that function differently.", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is not a \"simple function\", this is a _cryptographic primitive_.\n\nYou're right, of course.\nBut it's also a simple function.\n\nIt's not really simple. It's a weird function that doesn't have any real- world analogs. It's not even in the same category as, say, addition or multiplication.\n\nI find it a very simple function. It's simple to understand, simple to use, and simple to implement.\nIt's a simple function that just happens to be a cryptographically primitive.\n\nI think it's a simple function for a cryptographer. But it's not a simple function for a programmer.\n\nI think that's a matter of perspective.\nI've seen plenty of programmers who find it simple.\n\nI think it's a matter of experience.\nI've seen plenty of programmers who find it simple.\n\nIt's a simple function for a programmer who knows what a modular exponentiation is, and who knows how to use it.\nI've seen plenty of programmers who know what a modular exponentiation is, and who know how to use it.\n\nI've seen plenty of programmers who know what a modular exponentiation is,", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nThis is a very neat trick!\n\nHow does this work?\n\nIt's an identity.\n\nI'm not sure I understand. Is the code just using modulo to return the remainder of 2^n divided by p?\n\nYes.\n\nWhat is a modulo?\n\nThe modulo of two numbers is the number that results when you divide one by the other.\n\nWhy does it work?\n\nIt's an identity.\n\nI'm not sure I understand. Is the code just using modulo to return the remainder of 2^n divided by p?\n\nYes.\n\nWhy does it work?\n\nIt's an identity.\n\nI'm not sure I understand. Is the code just using modulo to return the remainder of 2^n divided by p?\n\nYes.\n\nWhy does it work?\n\nIt's an identity.\n\nI'm not sure I understand. Is the code just using modulo to return the remainder of 2^n divided by p?\n\nYes.\n\nWhy does it work?\n\nIt's an identity.\n\nI'm not sure I understand. Is the code just using modulo to return the remainder", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nHere is a link to the source:\n\nVery useful. Thanks for sharing!</s>", "def modp(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> modp(3, 5)\n    3\n    >>> modp(1101, 101)\n    2\n    >>> modp(0, 101)\n    1\n    >>> modp(3, 11)\n    8\n    >>> modp(100, 101)\n    1\n    \"\"\" \"\"\"\n\nI guess it's not a bad idea to write a function that does that, but I wouldn't name it modp.\n\nI'm not a python expert, but I'm pretty sure that's the standard name for this function in python.\n\nIt's not. The standard name is __mod__.\n\nThis is an excellent point. I was just trying to explain that it wasn't a bad idea to write a function like that in python.\n\nI've always been a big fan of the following python idiom:"]]