[["def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for i in arr[::-1]:\n        if i > 0:\n           sum = 0\n           sum += i\n        return sum / len(arr)", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(filter(not_negative, arr))\n\n>>> count_nums([-1, -1, -1, -1, -1, -1, -1])\n1\n>>> count_nums([-1, -1, -1, -1, -1, -1, -1])\n3\n>>> count_nums([1, 1, 1, 1, 1, 1, 1, 1])\n4\n\ncount_nums is a function that counts the number of elements in the array arr\nthat has a sum of digits > 0.\n\nExamples\n\n>>> count_nums([-1, -1, -1, -1, -1, -1, -1])\n1\n>>> count_nums([-1, -1, -1, -1, -1, -1, -1])\n3\n>>> count_nums([1, 1, 1, 1, 1, 1, 1, 1])\n4\n\nNote that the function count_nums ignores negative numbers.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    # We need to use the fact that the array contains only positive numbers\n    x = 0\n    for i in range(len(arr)):\n        y = 0\n        for j in range(len(arr)):\n           if sum(i*j) > 0:\n              x += y\n             y += 1\n             else:\n              x += 1\n             y += 1\n             return x\n\nThis is just a toy example. In real life, you can use a fast pre-computed hash or a bloom filter for the sum function, and then you would get a real performance boost over a naive iterative approach.\n\nI wrote this function as a template for the classic C++ \"count_if\" function.\nWhen", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def count_nums(arr):\n    for i in arr:\n       if i > 0:\n          return i\n    return 0\n    print count_nums([1, 2, 4, 3, -7])", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if n in arr:\n        return len(arr) - n + 1\n\nThe indentation is off by 4 spaces.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\n    # output:\n      0\n      1\n      2\n      3\n\nSolution:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return int(sum(int(x) for x in arr) for x in arr)\nThis is really bad code:\n1\\. It has an ambiguous assignment (can you tell me what the value of sum(int(x) is?);\n2\\. It is missing a closing bracket;\n3\\. There is no meaningful error message;\n4\\. It doesn't use a loop (ie. it's O(n^2) rather than O(n) )\n\nI wonder what the plan is for the follow-up course.\nI assume that this course assumes no prior knowledge of programming.\nIs that true?\n\nI like the video from the first class... The game looks like a lot of fun.\n\nIt's quite fun, but the course is using a modified version of the game which is significantly easier. In the original, the red team never loses.\n\nI think they should have an error condition for the score being less than 0.\n\nThe score isn't an error condition, it's a counter for how many red pieces you have left.\n\nNo, that's the score. Red wins if they have less pieces left than blue. That's the score.", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\nreturn sum(arr[:], 0)\n\n(I am a self taught programmer and still a student in college, so I am\nstill learning and need all the help I can get!)\n\nThanks,\n\nJoe\n\nOn Sat, Jun 16, 2012 at 7:40 AM, Tim Peters <> wrote:\n> On Jun 16, 4:44 am, \"Joe B. Sanders\" <>\n> wrote:\n>\n> > def count_nums(arr):\n> > \"\"\"\n> > Write a function count_nums which takes an array of integers and returns\n> > the number of elements which has a sum of digits > 0.\n> > If a number is negative, then its first signed digit will be negative:\n> > e.g. -123 has signed digits -1, 2, and 3.\n> > >>> count_nums([]) == 0\n> > >>> count_nums([-1, 11, -11]) == 1\n> > >>> count_nums([1, 1, 2]) == 3\n> > \"\"\"\n> > return sum(arr[:], 0)\n>\n> Try this.\n>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if arr[0] < 0:\n       return 0\n    for n in arr[1:]:\n       if n > 0:\n          if n[0] > 0:\n              return n\n          else:\n              return 0\n    return len(arr)\n\nThis is so simple and straightforward. Just about the only thing you could ask for is a more efficient algorithm, and that's just for fun.\n\nThere's a lot of suggestions here, so I will try to explain the problem and what I tried.\nI think it would be best to see what I have done so far, so this is the code that I've written so far:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    print \"this is a test\"\n    for i in range(len(arr)):\n        print \"this is i\"\n        sum = int(round(arr[i]*arr[i]*arr[i]))\n        if sum >= 0:\n           print i\n    return sum\n\nA simple Python test that fails.\n>>> from collections import namedtuple\n>>> import operator\n>>>\n>>> def count_nums_python(arr):\n>>> for i in range(len(arr)):\n>>>    if arr[i]*arr[i]*arr[i] == 0:\n>>>        return i\n>>> return 0\n>>>\n>>> namedtuple('count_nums_python', count_nums_python)\n>>> >>> count_nums_python([]) == 0\n>>> >>> count_nums_python([-1, 11, -11]) == 1\n>>> >>> count_nums_python([1, 1, 2])", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for num in arr:\n        if num > 0:\n           return num\n    return 0\n\nThis is a classic example of why it's not a good idea to give trivial examples to interviewers. The problem as stated is _much_ simpler than the solution given:\n>>> def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    for num in arr:\n        if num > 0:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\n    def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    if arr[0] == -1:\n        return len(arr)\n    else:\n        return (arr[1:]) == 0\n\nA good, simple challenge, but, ugh, Python.\n\nThe example was not to show off Python. The purpose was to have a language agnostic example.\n\nA good example of what? Of _a_ challenge, certainly.\n\nI think this", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    # [1]\n    def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    # [2]\n    return len(arr)\nThat's the joke.\n\nAaaah. I understand it now. Thanks. :)\n\nI'm not sure why we are upvoting this. It's a joke. See\n\nThis is a nice joke, but it doesn't really show python's strengths.\nIn java you would have to create an anonymous class and method to do this. In c++ you would have to", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for i in arr:\n       if (sum(i) > 0):\n          return i", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\n    def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    # Determine the digit sum for each element\n    # If the sum is > 0, then the number is considered positive.\n    # If the sum is < 0, then the number is considered negative.\n    for i in arr:\n        if sum(i) > 0:\n           return i\n    # Otherwise, check if the first digit is negative.", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return len(arr) == len(set(arr, x for x in xrange(0, len(arr) + 1)))\n       or:\n       return set(arr, x for x in xrange(0, len(arr) + 1) if x > 0)\n        # Or:\n        return set(arr, x for x in xrange(0, len(arr) + 1) if x > 0 and x not in set(arr))\nThis is probably the most concise and easiest to read.  If I'm not mistaken the problem asks for a recursive solution.  This solves the problem without having to worry about recursion.\nI like it as well. However, I don't see how this is a recursive solution. Am I missing something?  The fact that it does not use recursion is a point in its favor, IMO.\nOh, I didn't realize it was for a job interview.  I usually try to avoid recursive solutions in interviews because it makes it harder to see the problem, but in this case I think that's a good point.", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\n    return len(arr) - sum(count_nums(arr))\n\nThat's way too simple.\nOne way to fix it would be to use a suffix array, which can express negative numbers as well:\n>>> from collections import defaultdict\n>>> from itertools import product\n>>> def suffix_array(s, max_s):\n    \"\"\"\n    A suffix array for numbers.\n    s must be a sequence of integers, one per digit, and max_s is the maximum\n    allowed digit for the sequence.\n    The suffix array stores the last digit of the given number.\n    >>> s = [1, -1, -1, -1, -1]\n    >>> max_s = 4\n    >>> suffix_array(s, max_s)\n         array([1, -1, -1, -1, -1])\n    >>> suffix_array([1, -1, -1, -1, -1], max_s=6)\n         array([1, -", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    sum = 0\n    for i in arr:\n       if arr[i] > 0:\n          sum += arr[i]\n          if sum == 0:\n            return sum\n    return sum", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for i in arr:\n    if sum(i) >= 0:\n       return i\n    return 0\nI think you mean >= 1, but that would be an easy fix.\n\nThanks, I've corrected it.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if arr.startswith('-') and not isinstance(arr, int):\n        return 0\n    for i in arr:\n        if arr[i] > 0:\n           return i\n    return 0\n\nIt's not about the example, but I'm missing one thing: when counting 0 in the loop, the function returns 0 instead of 1. I guess I can simply add 1 in the return statement. I know there are more elegant ways to do this.\n\nYou should add a comment to the function about the zero sum case.\n\nThat's a good idea, I will.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(int(i) for i in arr) > 0\n\n>>> count_nums([1, 2, 3]) == 3\n\n>>> count_nums([1, 2, 3]) == 3\n\n>>> count_nums([1, 2, 3]) == 3\n\n>>> count_nums([1, 2, 3]) == 3\n\n>>> count_nums([1, 2, 3]) == 3\n\n>>> count_nums([1, 2, 3]) == 3\n\n>>> count_nums([1, 2, 3]) == 3\n\n>>> count_nums([1, 2, 3]) == 3\n\n>>> count_nums([1, 2, 3]) == 3\n\n>>> count_nums([1, 2, 3]) == 3\n\n>>> count_nums([1, 2, 3]) == 3\n\n>>> count_nums([1, 2, 3]) == 3\n\n>>> count_nums([1, 2, 3]) == 3\n\n>>> count_nums([1, 2, 3]) == 3\n\n>>> count_nums([1, 2, 3])", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def add_sign(num):\n    \"\"\"\n    Return a new number which has the same value as the input number,\n    but with the first digit of the output number as the sign.\n    >>> add_sign(0) == 0\n    >>> add_sign(1) == 1\n    >>> add_sign(-1) == -1\n    >>> add_sign(1.5) == -2\n    \"\"\"\n    return num * 0.1", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if n1!= n2:\n       return 0\n    return n1 == n2 and sum(digits(n1):digits(n2)) > 0\n\nIf I understand this correctly, it only counts elements of the form\n[11, 1, 2]\n[1, 11, 2]\n\nIt doesn't count elements of the form\n[11, 11, 11]\n[11, 1, 1]\n[1, 11, 1]\n\nRight?\n\nDid you intend this? If not, what's the bug?\n\nIf you want to count all numbers, then you can use:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and\n    returns the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be\n    negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    return len(arr) > 0\n\nThis is a fairly common interview question.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    # Start by clearing the sum and the count\n    sum = 0\n    count = 0\n    for i in arr:\n       sum += i\n       count += 1\n    return sum\nYour test data is invalid.  The sum is 0, so you must be using the index 0.  The array contains only one element, so the value of i is -1.  This is the first negative number.\nYou need to throw an exception here, not return the sum.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    print('count_nums()')\n    print(count_nums([]) == 0)\n    print(count_nums([-1, 11, -11]) == 1)\n    print(count_nums([1, 1, 2]) == 3)\n    return count_nums\n\nWhen I copy the code and run it, I get the following error:\n\nTraceback (most recent call last):\nFile \"C:\\Python27\\lib\\site-packages\\matplotlib\\backends\\numpydot.py\", line 113, in __call__\nreturn print(count_nums(arr))\nValueError: Invalid argument: -1\n\nWhich I think is pretty strange.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for i in range(len(arr)):\n       sum = 0\n       if arr[i][0] > 0:\n          sum += arr[i][0]\n          return sum", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    a = [0]*10 + 0\n    for x in arr:\n       if x!= a:\n          return x\n    return len(a)\n\nA somewhat more elegant solution using generators:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if arr[0] == 0:\n        return 0\n    for x in arr:\n        if x < 0:\n           x = abs(x) - 1\n           sum = sum + x\n           for i in range(len(arr)):\n             sum -= arr[i]\n            if sum > 0:\n                sum += (x == 0)", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    x = 0\n    for i in range(len(arr)):\n        if sum(digits(i)) > 0:\n            x += i\n    return x\nI'm not sure I understand why you want to include `i` into the loop.  You need to test for \"is it positive or negative\" and increment, so why not:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if arr[0] == -1:\n        return 0\n    else:\n        for i in range(len(arr)-1):\n           if arr[i] > 0:\n               return i\n          else:\n               return -1\n    return 0\nI've been a professional programmer for a while, but I'm not particularly good with algorithms. Is there a good resource for stuff like this?\n\nThere are a lot of resources for algorithms out there. I'm not sure if this is the kind of thing you're looking for, but I used this book to get me started.\n\nI was hoping for something a little more in depth than just a \"guide\". I'll take a look though, thanks.\n\nI think this might help you:\n\nNice. Thanks for that.\n\nThat was fun. I spent a couple hours on it and got it to work. I even added some", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if arr[0] < 0:\n        return 0\n    for i in range(len(arr)):\n        sum = sum * arr[i]\n        if sum > 0:\n           return sum\n    return 0", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def count_nums(arr):\n    for x in arr:\n       sum = sum(x)\n       if sum > 0:\n          return sum\n    return 0\n\nI think this is what you want:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(int(arr[0]) for _ in range(len(arr)-1))\nYou want to do int(arr[0]) in order to avoid the signs being stripped.\n\nThanks for the correction!\n\nyou can't leave out the second line of code.\n\nI think you're missing something, what's the bug?\n\nI think this is correct.\n\ncount_nums(arr) == sum(int(arr[0]) for _ in range(len(arr)-1))\nSo this is:\nsum(int(arr[0]) for _ in range(len(arr)-1)) == int(arr[0]) for _ in range(len(arr)-1)\nIs that a bug?\n\nsum(int(arr[0]) for _ in range(len(arr)-1)) == int(arr[0]) for _ in range(len(arr)-1)\nis true but useless.\n\nYes, but it's only useless if you don't need the answer. I thought the point was to count the number of numbers with at least one digit greater than zero.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for i in arr:\n        if i == 0:\n           return 0\n       else:\n           return sum(i) < 0\n\nisn't this missing a critical case, e.g.\ncount_nums([-1, -2, -1]) == 0\nbut is doesn't work\n\nthe problem is that you are trying to use sum(i) in the first case, and the < operator in the second. The first is an integer expression and the second is a boolean expression. They are not comparable.\n\nThe correct solution would be:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for i in range(len(arr)):\n       if abs(i) < 0:\n          continue\n         if sum(i) >= 0:\n           sum += i\n       return sum", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if type(arr)!= type(int):\n        return 0\n    for n, x in enumerate(arr):\n        if sum(n, x) > 0:\n           return n", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if arr.has_key('num'):\n        return arr.num\n    else:\n        return 0\n    if len(arr) > 0 and len(arr[0]) > 0 and len(arr[0]*arr[1]) > 0:\n        return len(arr[0])*len(arr[1])\n    else:\n        return 0\n\nMakes sense to me, if I understand Python.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def count_nums(arr):\n    if len(arr) == 0:\n        return 1\n    for element in arr:\n        if element >= 0 and element in [0, 2, 5, 8, 9]:\n           return count_nums(element)\n    return 0\n\nOutput:\n\n>>> count_nums([]) == 0\n>>> count_nums([-1, 11, -11]) == 1\n>>> count_nums([1, 1, 2]) == 3\n\n>>> count_nums([-1, 11, -11])\n<function object at 0x7f6c608c0>\n>>> count_nums([-1, 11, -11])\n<function object at 0x7f6c608c0>\n\n>>> count_nums([1, 1, 2])\n<function object at 0x7f6c608c0>\n>>> count_nums([-1, 11, -11])\n<function object at 0x7f6", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def count_digits(x):\n    \"\"\"\n    Write a function count_digits which takes an integer and returns the\n    number of digits.\n    If x is negative, then its first digit will be negative:\n    e.g. -123 has digit -1, 2, and 3.\n    >>> count_digits([-123]) == 1\n    >>> count_digits([-1, 11, -11]) == 2\n    \"\"\"\n    return len(x)\n    def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and\n    returns the number of elements which has a sum of digits > 0.\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([-2, 3, -6]) == 2\n    \"\"\"\n    return count_digits(sum(arr))\n\nSee also\n List of mathematical puzzles\n\nReferences\n\nExternal", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\nThe article is about the problems that arise when you try to follow the 'How to write code like a mathematician' advice to the letter.\nI think the count_nums function is a good example of one of the worst things you can do: over-specifying your inputs. In this case, the author wrote the function for an input array, but then uses negative values as if the function was written for an int array.\nI don't know what the author meant by \"an array of integers\", but I would guess that the author meant something like a two-dimensional array of ints. If so, then there is no reason to exclude negative values.\n\nGood point. I was thinking that if the input array contained negative numbers, then it would be useful to know that there is at least one positive number in it. But I guess you'd just have to check the length of the array.\n\nThis is not how mathematicians write code, or at least it's not how good ones do.\n\nThis is certainly how _some_ mathematicians write code. I've worked with several over the years.\nTheir programs are less reliable, harder to debug, and slower than my programs. I'm sorry, but I", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def count_sum(arr, n):\n    \"\"\"\n    Write a function count_sum which takes an array of integers and returns\n    the sum of the elements with a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_sum([]) == 0\n    >>> count_sum([-1, 11, -11]) == -11\n    >>> count_sum([1, 1, 2]) == 1\n    >>> count_sum([3, 4, 6]) == 8\"\"\"\n    for i, sum in enumerate(arr):\n        sum = sum + int(i)\n    return sum > 0\n\nOutput:\n\n>>> count_nums([]) == 0\n>>> count_nums([-1, 11, -11]) == 1\n>>> count_nums([1, 1, 2]) == 3\n>>> count_nums([3, 4,", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def int(num):\n    if num!= 0:\n       return -num\n    return int(num + 2)\n    if len(arr)!= 1:\n       return 0\n    for num in arr:\n       if int(num) >= 0:\n          return int(num + 2)\n    return int(len(arr) - num)\n\n_A_ first pass:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if len(arr) == 0:\n        raise ValueError('array must be non-empty')\n    for i in range(0, len(arr)):\n        sum = arr[i][0]\n        if sum > 0:\n           return sum\n        else:\n           return 0\n    return sum\n\nI think this problem is better solved with a generic list comprehension:\ncount_nums = [0]*10 + [1]*2 + [2]*1 + [3]*0 + [4]*-1\n\nThat's not a solution. Your solution counts the number of _integers_ that have a sum of digits > 0, whereas the exercise asks for the number of _digits_ with a sum of >0.\n\nI think it's more that they're looking for the number of elements with a sum of digits > 0. The OP's function would be considered a solution in that case, since it finds the", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def count_nums(arr):\n    count = 0\n    for n in arr:\n       if n > 0 and n % 10 == 0:\n          count = count + 1\n    return count\nI don't know what the assignment is asking you to do, but this would be my first thought, too.  The problem is that it's not a very interesting assignment.  So, I suspect, the assignment is probably asking you to do something a bit more complicated.\nHmm, it could be, but I don't think it is. I mean, the only alternative I can think of is to perform some modulo 10 operation on the array and return the remainder.  Unless it's something along those lines, I can't think of another way of doing it that isn't just as naive as what I've written.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    while arr[0][0] > 0:\n        arr[0][0] = 0\n        arr[0][1] = 0\n        arr[0][2] = 0\n        arr[0][3] = 0\n        arr[0][4] = 0\n        arr[1][0] = arr[0][1] + arr[1][1]\n        arr[1][1] = arr[0][2] + arr[1][2]\n        arr[1][2] = arr[0][3] + arr[1][3]\n        arr[1][3] = arr[0][4] + arr[1][4]\n        arr[1][4] = arr[0][5] + arr[1][5]\n        arr[2][0] = arr[0][1] +", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if len(arr) == 0:\n        raise TypeError('Array must contain integers')\n    return count_nums(arr[0])", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(int(float(arr[i]))) > 0", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\n    # If a number is negative then its first signed digit will be negative:\n    # e.g. -123 has signed digits -1, 2, and 3.\n    if num[0] < 0:\n         num[0] = -num[0]\n    return num[0] + num[1] + num[2] + num[3] > 0\n\n    #", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(int(i) for i in arr if int(i) > 0 else 0)</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if n < 0:\n        return -1\n    return sum(numerator(n) for numerator in nums(n))\n\nP.S. I don't know much about python, but I am interested in learning.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(arr[1:])>0\nI'm not sure about the Python grammar, but it looks like this program\nwould be more readable if the \"sum\" function were moved into the\nfunction being called:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if arr[0] > 0:\n        count = 0\n        for i in range(0, len(arr)-1):\n            if arr[i] > 0:\n                count += 1\n    return count\n\nI really like this one. I wouldn't have thought of it. It's really simple too.\n\nI came up with it while I was writing a function to find the number of non-negative numbers in an array.\n\n\"Write a function find_max which takes a list and a positive integer N and returns the largest item in the list.\"\nHere's a very fast solution in Python:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    count_nums = lambda arr:\n       return sum(int(arr[1:]) + int(arr[2:]) + int(arr[3:]) + int(arr[4:]) + int(arr[5:]) + int(arr[6:]) + int(arr[7:]) + int(arr[8:]) + int(arr[9:]) + int(arr[10:]) + int(arr[11:]) + int(arr[12:]) + int(arr[13:]) + int(arr[14:]) + int(arr[15:]) + int(arr[16:]) + int(arr[17:]) + int(arr[18:]) + int(arr[19:]) + int(arr[20:]) + int(arr[21:]) + int(arr[22:]) + int(arr[23:]) + int(arr[24:]) + int(arr[25:]) + int(arr[26:]) + int(arr[27:]) + int(arr[28:]) + int(arr[29:]) + int(", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(arr[::-1] + str(arr[::-1]), 0)\nWell, I don't think you can do it by using a list. I'd use a set, and see if you can find the minimum element.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for i in range(len(arr)):\n        sum = 0\n        for j in range(len(arr)-1):\n           if sum > 0 and arr[j] == 0:\n               sum = sum + arr[j]\n    return sum\nIt's not obvious what you mean by \"a sum of digits > 0\".  Do you mean that the sum of the digits is > 0?  Because I see no need to check that.  I'm not trying to be snarky.  I'm just not sure what you are trying to do.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(num) == 0\nI think this is the sort of problem that can be solved by a recursive function.\nIf you want to do it by hand, then consider using the power of modulus.\ne.g.\n(I'm not very familiar with python, so please ignore the lack of function definitions and other niceties.)", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if len(arr) == 0:\n        print(\"The array must have at least one element.\")\n    return 1\n    for x in arr:\n        if x[0]!= 0:\n           return count_nums(x[1:])\n\nThe above is not the correct solution. The correct solution is:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if arr.has_key(0):\n        return arr.get(0)\n    else:\n        return count_nums(arr.pop())", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    total = 0\n    for x in arr:\n       if sum(x) > 0:\n          total += sum(x)\n    return total\n\nSolution", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\n    def count_nums(arr):\n    if arr[0] < 0:\n        return 0\n    else:\n        sum = 0\n    for i in range(0, len(arr)):\n        sum += arr[i] ** 2\n        if sum > 0:\n           if arr[i] == 0:\n              return sum\n        else:\n             return sum + 1\n    return sum\n\nThis is all fine and dandy, except that if there is a positive number with a sign of zero, it will be counted as an invalid number. This is because if arr[i] == 0, it will be counted as arr[i]!= 0, i.e. arr[i] > 0, so sum > 0 will be returned.\n\nOn a sidenote, I also found that if arr[i]", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\n    i = 0\n    while i < len(arr) - 1:\n        i += 1\n    if sum(arr[i]) > 0:\n        i = i + 1\n    return i\n\nI don't understand what the goal is here. Is it that he wants the test to be independent of the actual values? If so, this is nonsense. All you've done is made a normal function that happens to return the number of positive numbers in the input array.\nIf, on the other hand, you're trying to make the test as deterministic as possible, you should use a loop that counts down from the length of the input array and a conditional statement with the same number of cases as the input array.\n\nYeah, I'm not quite sure what the point of the article was. I'm pretty sure he could have gotten the same result with less code by using a function like", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(abs(int(i) + int(j))) > 0\n\nYou should be able to do that in a single line:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def count_nums(arr):\n    \"\"\"\n    Calculate the number of elements with a sum of digits > 0.\n    >>> print(count_nums([1, 1, 2], 2))\n    3\n    \"\"\"\n    return len(arr)\nI think you need to tweak the len function a little.\n\nYou are right, this was a mistake. Fixing now.\n\nI like the end result, but I'm not sure that I like the algorithm. It seems pretty inefficient to me.\nYou could do the whole thing in one pass, by using the fact that the digits of a number are distinct. So for example, the number -2 has a sum of digits of -2. You could recursively call the algorithm on each number in the list, passing in the previous number as the recursion parameter, and keeping track of the sum of digits in a single list.\nThis seems to me like a better fit for the core python language than the built-in sum() function.\n\nYou are right, I could have done it in one pass. However, it is a lot easier to implement the", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(range(len(arr), 1), 0)\n    # (range is from numpy.ndarray import *)\n[](/spoiler)", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    total = 0\n    for x in arr:\n       if x > 0:\n          total += x\n    return total", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return len(arr) > 0\n\nI would accept this code as is if I were looking for programmers, but I would also take this opportunity to give the candidate a writing exercise:\n\nWrite a function count_nums which takes an array of integers and returns the number of elements which has a sum of digits > 0, but only if the first digit is positive.\n\nThis exercise is designed to test the candidate's ability to understand and implement the requirements. If I find a candidate who can write the first solution, it is a good indicator that they can also write the second solution with some effort.\n\nThere are many other ways to test a candidate's problem solving skills, but for me this one is simple, clear and unambiguous.\n\nOn the other hand, it is also a good test of the candidate's ability to write clear and unambiguous English.\n\nI would reject the candidate if I found out that their English was weak, but that's a separate issue.\n\nRegarding the original question, I would be surprised if I found out that someone rejected my solution without testing it first.\n\n<sarcasm>What's the point in hiring a programmer who can't write a good test case", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    N = len(arr)\n    for i in range(N):\n       if sum(i) > 0:\n          sum(i) = 0\n    return sum(N)\n\nThis is the most common implementation of this algorithm.", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    arr = [i for i in range(1,len(arr)-1)]\n    for i, sum in enumerate(arr):\n       if sum[0]>=0:\n          return sum[1:])\n    return 0", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\nfor number in arr:\n    if number[0] == 0:\n        number[1:] += 1\n    print(number[0:])\n\nSo does this mean I have to write a function that will call a function that takes two integers and returns one, just to do this?  Or is there a way to get the number of integers that have a sum of their digits > 0?\n\nAlso, I've been using Python for a little bit over a week.  If I posted this in the wrong place, I'm sorry!</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return 0 if arr == [] else len(arr) - 1\nThis is what I get when I run it. I'm a beginner so please don't think that I am just being lazy.  I don't know how to make it count the negative numbers that have a non zero sum of digits.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    # Check if the first digit is negative\n    if not arr[0] < 0:\n        return 0\n    # Check if the first digit is positive\n    if arr[0] >= 0:\n        return 1\n    # Check if the second digit is negative\n    if arr[1] < 0:\n        return 0\n    # Check if the second digit is positive\n    if arr[1] >= 0:\n        return 1\n    # Check if the third digit is negative\n    if arr[2] < 0:\n        return 0\n    # Check if the third digit is positive\n    if arr[2] >= 0:\n        return 1\n    # Check if the fourth digit is negative\n    if arr[3] < 0:\n        return 0\n    # Check if the fourth digit is positive\n    if", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if arr[::-1] >= 0:\n       return int(arr[::-1])\n\nreturn count_nums", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(arr[i for i in range(len(arr)) if i % 3 == 0])\nThe `range` in the `sum` function is not needed. That's what `len` is for.\nIf you want to remove the possibility of an infinite loop when you run\ninto an integer larger than the number of elements in `arr`, you might\nwant to use `sum(arr[i:i+len(arr)-1])`.\n\nThis looks like C. I'd go with what tptacek suggested and just use sum instead.\nIf the function is in python, you can add:\nreturn sum(arr[i:i+len(arr)-1])\nThat will take care of the out of range exception.\n\nThe count_nums function is definitely C.\n\nWhy not use a C loop and `sum(arr[i:i+len(arr)-1])`?\n\nIf I was writing in C, I would have done that. I am trying to write in Python.\n\nI see. I believe that one could use sum instead of count_nums in Python.\n\nI am not sure I follow.", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for num in arr:\n       if num < 0:\n          # Negative digits\n           # Get first digit\n            # If it is negative, then\n            # it is the digit which will be counted.\n            sign = int(num)\n           # Print out the number and sign\n           if sign == -1:\n              # A negative digit has been found.\n              # Print the number\n             print num\n             # Print the sign.\n            print \"-\" + sign\n            # Add it to the count", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return 0 if arr == [] else return len(arr) + sum(arr[0:], 0)\nThis is a good exercise, but I would like to see a more interesting one. E.g. can you create a function that can be used to verify if two strings are anagrams?</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(arr[:-1]) > 0\nI think this only works for positive integers, though.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    nums = 0\n    for _ in arr:\n        if (sum(digits) == 0) or (sum(digits) > 0):\n            nums += 1\n    return nums", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    # Count elements in array that have sum > 0\n    for i in range(len(arr)):\n       if arr[i] > 0:\n          # Count number of elements in range [i+1..i]\n           # where sum of digits > 0\n            # If element is negative then its first signed digit\n               # is negative\n               # If element is positive, then its first signed digit\n                 # is positive\n                # If number has no positive or negative signs,\n                 # then its first digit is 0\n                # e.g. 0, 1, 9, and -9", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for num in range(len(arr)):\n        sum += num\n    return sum > 0\n\nI think you need to add a case for the empty array (which has no sum).\n\nThanks! Added.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for n in arr:\n       if n == 0:\n         return 0\n       sum = sum + n\n       if n > 0 and sum + n >= 0:\n         return sum\n    return 0\n\nOutput:\n>>> count_nums([]) == 0\n>>> count_nums([-1, 11, -11]) == 1\n>>> count_nums([1, 1, 2]) == 3</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for i in range(0,len(arr)):\n        if sum(i) > 0:\n           return i", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    return len(arr) - 1\n\nThey're both overkill for something this simple and the one I like most is the second one.\n\nI think they're both overkill as well.\n>>> count_nums(['11', '1', '2', '3'])\n3\nIt's two lines of code to do that. (sum is a built-in function in Python)\n>>> count_nums = sum(arr)\n>>> count_nums([", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if n < 0:\n        print('negative integer')\n    else:\n        for i in range(0, len(arr) - 1):\n           if n % i == 0:\n                print('number has a sum of digits > 0')\n                i += 1\n    return n\n\n>>> count_nums([1, 2, 1, 1]) == 3\n\n>>> count_nums([1, 2, 1, 2]) == 3\n\n>>> count_nums([1, -3, 2]) == 1\n\n>>> count_nums([1, -3, 2, -2]) == 0\n\n>>> count_nums([-3, 2, -2, -3]) == 0\n\n>>> count_nums([-3, -2, 2, -3]) == 0\n\n>>> count_nums([-3, -2, 2]) == 0\n\n>>>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    nums = 0\n    while nums <= len(arr):\n        if sum(arr[nums], nums) > 0:\n            nums += 1\n    return nums\nThe code is not particularly elegant or fast.\n\npython", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    n = 0\n    for i in arr:\n        n = n + sum(arr[i] for i in range(0, n - 1) if arr[i] >= 0)\n    return n\n\nThe exact same thing can be written in OCaml, but with a much more concise syntax:\nlet rec count_nums (a : array int) =\n    let n = 0 in\n      for i in a do\n         if a[i] > 0 then\n            n = n + a[i] * a[i - 1] * a[i - 2]\n           else\n            n = n + 1\n    return n\n\nIn fact, every single one of the top 5 ranked solutions are either one-liners or 2-liners in OCaml.\nSo what's the point of this article? To promote Python? To complain about a language you don't know? To be a", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    result = 0\n    for i in arr:\n       if abs(i) > 0:\n          result += i\n    return result\n\nSee also\n Counting (programming)\n\nReferences</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(arr[::-1] > 0)\n\nPython's `sum` is more general than the math.sum() function and can handle an array of numbers as long as it can handle the Python float type.\n\nPython's math.sum() is a different function than the built-in sum.\n\nYes, but the built-in sum does what the Python sum does (and better in some ways):\n>>> import math\n>>> math.sum([1,2,3,4])\n6\n>>> sum(math.sump, [1,2,3,4])\n6\n>>> math.sump(1,2,3,4)\n6\n>>>\nThis is because the Python sum is a built-in function that works on ints and floats. The built-in sum works on numbers and numbers are built on two's complement ints.\n\nI'm not familiar with the language, but how is the count_nums function more idiomatic than sum? Is it more idiomatic in general, or just in the context of array sums?\n\nWell, sum(arr) is a single line of code. But count_nums(arr", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def func(arr):\n    sum = 0\n    for i in arr:\n       sum += float(i)\n    return sum > 0\n\n>>> len(arr)\n11\n>>> len(count_nums(arr))\n2\n>>> count_nums([1, -1, 2, 3])\n2\n\nReferences\n\n\"How to Write Programs\" http://www.shaffner.com/hwp/lesson12.html\n\n\"How to write a function in Python\" http://www.shaffner.com/hwp/lesson23.html\n\n\"How to use a function in Python\" http://www.shaffner.com/hwp/lesson25.html</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if arr[::-1] == 0:\n        return 0\n    for i in range(len(arr)):\n        if arr[i] == 0:\n           return i\n    return arr[::-1] == 0\n\nThis is a really neat problem, but I'm wondering if anyone else has an alternate way of approaching it.\n\nI do something like:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if a[0] == 0:\n        return 0\n    for j in a:\n        if sum(j) >= 0:\n           j += 1\n    return j\n\nSample run\n\n>>> count_nums([1, 2, 3]) == 3\n\nThe result is 3 because in the array 1, 2, and 3 there are three elements where sum of the elements is greater than 0.\n\n>>> count_nums([1, 2, 3, 4]) == 3\n\nThe result is 3 because in the array 1, 2, 3, and 4 there are three elements where sum of the elements is greater than 0.\n\n>>> count_nums([1, 2, 3, 4, 5]) == 2\n\nThe result is 2 because in the array 1, 2, 3, 4, and 5 there are two elements where sum of the elements is greater than 0.\n\n>>> count_nums([1, 2, 3, 4, 5, 6]) == 2\n\nThe result is 2 because in the array 1, 2", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def sub_nums(arr, x):\n    \"\"\"\n    Write a function sub_nums which takes an array of integers and returns\n    the sum of digits of the numbers in the array.\n    >>> sub_nums([-1, 11, -11]) == -22\n    >>> sub_nums([1, 1, 2]) == 3\n    \"\"\"\n    return sum(map(int, x))\n    return sum(map(sub_nums, arr))\n    return count_nums(arr)\n\n>>> count_nums([]) == 0\n>>> count_nums([-1, 11, -11]) == 1\n>>> count_nums([1, 1, 2]) == 3\n\nSee also\n Python list comprehensions\n\nReferences\n\nFurther reading\n Using Python's list comprehensions to code the Fibonacci sequence and Lucas numbers.\n Python's list comprehensions by example: an introduction to powerful and concise coding.\n\nExternal links\n\n List comprehensions on the Python wiki</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    result = []\n    for i in arr:\n       if i > 0:\n          result.append(sum(i))\n    return result\n    print count_nums(['a', 'b', 'c'])</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    sum = 0\n    for i in range(len(arr)):\n        sum += arr[i]\n    return sum\n> >>> count_nums([]) == 0\n> >>> count_nums([-1, 11, -11]) == 1\n> >>> count_nums([1, 1, 2]) == 3\n>\nThat's a bad example, because if you want to sum the digits of a negative number, then you can use the sum function instead of count_nums. It's more interesting when you have something like this:\n>>> count_nums([1, 2, 2, -2, -1, 1]) == 4\nIn fact, if you want to sum the digits of a number using count_nums, then you can do that in Python 2.4, because the sum function now accepts an optional limit, which is what you'd do if you wanted to sum the digits of a negative number. For example, this code:\n>>> count_nums(1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)\n... does not", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    print sum(nums)\n    return len(nums) > 0", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(int(x) for x in arr if x > 0)\n\ncount_nums()\n\nfor x in range(10):\n    print count_nums(x)</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return len(arr)\n    if arr[0] > 0:\n        arr[1:] = 0\n    else:\n        arr[1:] = 1\n    return arr[1:]\nAm I missing something? Why isn't this valid?\n\nIt's valid, but not a count_nums function.\nThe solution is just:\nfrom itertools import chain", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if len(arr) > 0:\n        return len(arr) - 2\n    else:\n        return 0\nI hate it when people do that.  Use a language if you want to do math in it.      return 2", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if not arr.count():\n        return 0\n    for x in arr:\n        if x > 0:\n           if x % 2!= 0:\n              return x\n             if x % 2 == 0:\n                return x+1\n              return 0\n    return arr.count()", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    # Take a list of integers\n    if len(arr) < 1:\n        raise ValueError(\"Need at least one integer\")\n    return sum(arr[0:len(arr)-1])\n    def count_nums_with_sum(arr):\n    \"\"\"\n    Write a function count_nums_with_sum which takes an array of integers\n    and returns the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums_with_sum([-1, 11, -11]) == 1\n    >>> count_nums_with_sum([1, 1, 2]) == 3\n    >>> count_nums_with_sum([0, 0, 2, 0]) == 0\n    \"\"\"\n    # Take a list of integers\n    if len(arr) < 1:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for x, sum_digits in enumerate(arr):\n       if sum_digits > 0:\n         return sum_digits\nelse:\n         return 0\n\nIn python 2.6, I get the following error:\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in?\nFile \"/usr/lib/python2.6/site-packages/setuptools/__init__.py\", line 11, in?\nimport setup\nImportError: No module named setuptools\nIn python 2.7, I get the following error:\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in?\nFile \"/usr/lib/python2.7/site-packages/setuptools/__init__.py\", line 11, in?\nimport setup\nImportError: No module named setuptools\nI'm using python 2.7 on a mac running OS X 10.6.8.\nI've tried deleting the file I created and re-running the code but it", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if arr[0] > 0:\n        return 0\n    return 1 + sum(int(arr[1:]) for i in range(len(arr)) if arr[i] > 0)\n\nNote that this function is not very useful in practice.\n\nFor more, see:\n\nThis is a typical example of the halting problem, in which it is impossible to write a program to \"prove\" that a given program will always eventually halt.\n\nIn fact, since all computable functions are represented as a finite series of steps (by a Turing machine), it's possible to show that no finite program can always halt.\n\nThat is, there are some inputs for which there will always be a next step. If your program runs forever on such inputs, the only thing you can say about it is that it will never halt on any input.\n\nThe halting problem, therefore, is a \"denial\" of the existence of a practical algorithm for making a computer prove the consistency of some arbitrary mathematical system.\n\nA consequence of the halting problem is that no computable function can be computed by a Turing machine in a finite number of steps.", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n        sum = 0\n        i = 0\n        for i in range(len(arr)):\n           sum += arr[i]\n           if sum > 0:\n              sum = sum - sum[0]\n             return sum\n\nSo this is a trivial example of a count_nums function for a list of\nintegers, but it is not obvious that this is a count_nums function at\nall. I would define it this way:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    n = 0\n    sum = 0\n    for i in arr:\n       if sum == 0:\n          n = sum + i\n       else:\n          n = sum * i\n    return sum", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\nI think this is the correct solution, but for some reason it's not doing what I'd like.\n\nMaybe there is a better way to solve this problem that I don't know about.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    a = np.arange(len(arr), 1, -1)\n    i = 0\n    while a[i] >= 0:\n        i = i + 1\n        sum = 0\n        for j in a:\n           sum += a[i] * a[j]\n           if sum >= 0:\n              return sum\n    return 0\n\nThis is a very simple problem, and a very simple solution. However, as with all simple solutions, it isn't very robust. For example, this will not detect numbers like -123 -123 0 1 -1 1 (where the numbers are presented as strings, and + and * are interpreted as concatenation).\n\nThe reason for this is that the function is not comparing the elements of the array.  The elements of the array are not being compared in any meaningful way, and thus the function can return a count which is incorrect.  This is also the case for", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    result = 0\n    for i in arr:\n        if arr[i] >= 0 and arr[i] <= 9:\n           result += arr[i]\n        else:\n           result += 0\n    return result", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return len(arr) > 0\n\nThis is a lot like the K&R version. It has the advantage that it's\nequivalent to the Python code, so it's a good example for the language.\nIt's also less typing. (That's really the only advantage in this case.)\n\nBut it's a lot slower. The C version performs about 13% better on my\nmachine.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    while len(arr) == 1:\n        sum = 0\n        for i in range(len(arr)):\n           sum += arr[i]\n           if sum > 0:\n              break\n    return sum\n\nNote that the function returns the number of elements with a sum of digits > 0, and not the total number of elements.\n\nSee also\n\n Longest common subsequence\n\nExternal links\n C++ example</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def count_nums_nums(arr):\n    \"\"\"\n    Write a function count_nums_nums which takes an array of integers and\n    returns the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums_nums([]) == 0\n    >>> count_nums_nums([-1, 11, -11]) == 1\n    >>> count_nums_nums([1, 1, 2]) == 3\n    \"\"\"\n    count_nums(arr)\n    count_nums_nums(arr)", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def sum_digits_greater_than(arr):\n    \"\"\"\n    Write a function sum_digits_greater_than which takes an array of integers\n    and returns the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> sum_digits_greater_than([]) == 0\n    >>> sum_digits_greater_than([-1, 11, -11]) == 1\n    >>> sum_digits_greater_than([1, 1, 2]) == 3\n    \"\"\"\n    print(\"{0}: {}\".format(arr, sum_digits_greater_than(arr)))\n\nRunning the program, the output is:\n$ python count_nums.py\n{0}: [[0, -1, -2, 1, 2, -3, -4, -5], [0, 1, 2, -3,", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    sum = 0\n\n    while sum < len(arr) and sum > 0:\n       sum += arr[sum%10].sum\n\n    return sum\n\nSee also\n Fibonacci sequence\n\nReferences\n\nExternal links\n A solution in Python</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if a:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\n    return len(arr) > 0 and sum(arr[0:len(arr)] for _ in range(len(arr) - 1)) > 0\n\n>>> s = 'abcdefgh'\n>>> count_nums(s)\n0\n>>> count_nums(s[1:2])\n2\n\ni think you have to define sum() first</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    n = 0\n    while n < len(arr):\n        if n+1 > len(arr):\n            n = n+1\n            n += sum(arr[i] for i in range(n))\n    return n", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(arr > 0)\n\nThis will give a count of the number of elements in the array that have a sum of digits > 0.\n\nIf a number is negative, then its first signed digit will be negative:\n\ne.g. -123 has signed digits -1, 2, and 3.\n>>> count_nums([]) == 0\n>>> count_nums([-1, 11, -11]) == 1\n>>> count_nums([1, 1, 2]) == 3\n\nIf you want to sum the digits of an arbitrary integer, then you can write a function to do that.", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    # returns the number of elements which has a sum of digits > 0\n    def count_nums(arr):\n    for i in range(0,len(arr)):\n        if sum(i)>0:\n            return i\n    return 0\nNote that `sum` in Python is a function, not a method.\n\nI'm not sure if you're serious, but it's pretty obvious that the code you posted is _not_ Python. If you are serious, and the code is indeed Python, I'm pretty sure it's a bug, since Python's string methods don't accept \"negative\" numbers.\n\nA bit confused here.\n1\\. I'm guessing the OP is referring to this:\n2\\. On the basis that if I have the Python interpreter in front of me then I can't be accused of thinking that the list method is a Python method (as opposed to a Python function).\n3\\. Python's string methods don't accept negative numbers but you can call functions on negative numbers.\n4\\. `sum` is a function which takes two numbers and gives", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\n    count_nums = lambda x:\n       if x:\n          return sum(x.sign() for x in x.split())\n       else:\n          return 1\n\n(I'm not sure about the parentheses, but I think they're needed to\ntell Python that `sum` is a function? I know this is necessary in\nC++.)\nThis function is guaranteed to have a correct answer for any\npositive integer.\nFor a negative integer, I don't think it's possible to have a\ncorrect answer. E.g. if the number is -1, then you don't know\nwhether the first signed digit is positive or negative.\n\nSome more (more complicated) code that does what I think you want:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if arr[0] == 0 or arr[0] > 0:\n        return arr.sum()\n    else:\n        return sum(arr[0:arr.size()])\n\nI've read somewhere that the Python community is quite opposed to function names that are just 1-3 words long (e.g. count_nums). The reason is that it's very hard to tell what they do just by reading the name, and if you have to look at the code to figure out what the function does, there's probably a better way to name it.\n\nGood point. I'll have to think of something more descriptive.\n\nI've also heard this said about single-letter variables. I'm not sure where I heard that though.\n\nHow many lines of code do you write a day?\n\nI'm working on a project for my startup that involves writing a large number of lines of code. I'm using Python because that's what I know best.\n\nDo you know lisp?</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    result = 0\n    for e in arr:\n        if sum(e) > 0:\n           result += 1\n    return result", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\n    return sum(arr[::-1] for index, i in enumerate(arr))", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    import numpy as np\n    def sum_digit(x):\n       return (x[0] + x[1]) % 2\n    def count_nums_sums(arr):\n       for i in arr:\n          if sum_digit(i) > 0:\n             return i\n       return 0\n    print count_nums_sums([1, 2, 3])\n    print count_nums_sums([1, 2, 4])\n    print count_nums_sums([1, 2, 3, 4])\n\nI'm not a Python expert, but I'd guess that you can achieve the same in a more succinct way:\nfor sum_digit in range(len(arr)):\n    if sum_digit > 0:\n       return sum_digit\n    return 0\n\nThis looks like a better solution.\n\nOf course, this relies on the assumption that", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for i in range(1, len(arr)):\n       if sum(arr[i], 0) > 0:\n          return count_nums(arr[i])\n    return 0", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if arr[0] > 0:\n       return count_nums(arr[1:])\n    else:\n       return 0\n\nWhy don't you just count the number of elements which are not zero?\n\nHe wants the number of elements with a positive signed digit.\n\nThen he should count the number of elements with a non-zero _signed_ digit, not the number of elements with a positive digit.\n\nIs this supposed to be an exercise?\n\nYes.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\n    for i, element in enumerate(arr):\n        if element[0] > 0:\n           return element[0]\n        else:\n           return 0\n\nI think it is possible to write a function in less than 50 lines. It is possible to write a function in less than 25 lines. I think it is possible to write a function in less than 20 lines.\n\nSee? I could keep writing that sentence forever.\n\n[edit]\n\nLet's try this:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    return len(arr) > 0\n\nPython has a builtin function named len(list), that returns the number of elements in the list.", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for num in arr:\n       if num >= 0:\n             if num[0] > 0:\n                    return num[0]\n               else:\n                    return -1\n    return -1\nThis is not correct in general. I think the author means that \"if num[0] is negative\", but if it were that way, then the following would never be true:\n>>> count_nums([-2, -3, -4, -5]) == 2\nIt's possible for an array with those numbers to be negative, but the count should not be 2.\nThe correct solution to this problem, which I wrote for the same assignment, is:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for x in arr:\n       if sum(x) > 0:\n          return x\n    return 0\n\nMore practically, you could also do something like this:\nfor x in [1, 1, 2, -1, -1, 1, -1, 0, 0, 1]:\nsum = sum(x)", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    print('Counting:')\n    for i in range(len(arr)):\n        print(i)\n        if arr[i] == 0:\n            return 0\n          if arr[i] == arr[i+1]:\n             return 1\n          if arr[i] == arr[i+2]:\n             return 2\n          return arr[i]\n\n[edit]\nI was trying to give the full example. I'm not sure why you think I'm \"posting a sample to demonstrate the error\". I think I've clearly stated what I think is a bug.\n\n> I'm not sure why you think I'm \"posting a sample to demonstrate the error\".\n\nBecause you post a sample that exhibits the behavior you are describing, as though it were an example of it, and your sample is shown to not exhibit", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if len(arr) == 0:\n        raise ValueError(\"There are no numbers.\")\n    for i in range(0, len(arr) - 1):\n        if sum(i) > 0:\n           if arr[i] < 0:\n               #We can exclude negative numbers\n                return i\n    return 0", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\n    if len(arr) <= 1:\n        return 0\n    else:\n        return sum(sum(arr[i] for i in range(len(arr))) for i in range(len(arr)))\n    return 0\n\ncount_nums([-1, -1, -1]) == 1</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def _sum(nums):\n    \"\"\"\n    Return the sum of digits of the numbers. The sum of digits is\n    calculated as the sum of the digits of each element of the numbers\n    divided by the number of elements.\n    >>> _sum([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    18\n    >>> _sum([1, 1, 2, -1, 5, -5, 9])\n    11\n    \"\"\"\n    return sum(nums[::-1]) / nums.size", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return len(arr) == 0 and sum(int(x) for x in arr if int(x) > 0) > 0\n\nNot a bad example, but I would have used the list comprehension notation:\ncount_nums = [sum(int(x) for x in xrange(len(arr) - 1) if int(x) > 0)]\n\nOnly if you had the foresight to make xrange a function. In most of the\nexamples I see in the wild, it's a method on a list.\n\nTrue. A little abstraction can save you a lot of typing.\n\nMy favorite one-liner:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if __name__ == '__main__':\n    N = range(10)  # N = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    result = []\n    for x in N:\n        sum = x.sum()  # sum = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n        result.append(sum)  # result = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)\n    print(result)  # print(result)\n\nI don't know if it's a coincidence, but you've just reinvented the \"sum\" function.\n\nSurely the output is more useful than that of sum().\n\nI've actually done something very similar (but with a different result type) as an interview question.\n\nThe \"counting\" function is a much more useful version of the \"sum\" function.\n\nNot really, the sum function is not restricted to positive numbers.", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(map(int, array)) > 0\n\nSo, here's the deal, I'm basically trying to look for a way to explain to a person unfamiliar with programming why Python code is so much better than typical code in C or Java.\n\nThe problem with the C approach is that it is overly complicated and not easily maintainable. The problem with the Java approach is that it is overly complicated and not easily maintainable. The problem with the Python approach is that it is a bit too simple.\n\nI think a good middle ground would be something like this:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    return sum(arr) >= 0\n\nAuthor here.\nYou can also write it as", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if not arr:\n        raise ValueError(\"Array needed.\")\n    else:\n        if len(arr) == 0:\n           return 0\n         else:\n           return len(arr) - 1\n\nI think it's a good exercise, because it doesn't have to be correct to teach the student something. I think it's more important to teach the student how to write a test that's useful than it is to teach the student a correct algorithm.\n\nI think it's a good exercise because it does have to be correct to teach the student something. I think it's more important to teach the student how to write a test that's useful than it is to teach the student a correct algorithm.\n\nI think it's a good exercise because it doesn't have to be correct to teach the student something. I think it's more important to teach the student how to write a test that's useful than it is to teach the student a correct algorithm.\n\nI think it's a good exercise because it does have", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if len(arr) == 0:\n       raise ValueError(\"Array must have at least one element.\")\n    return len(arr)\nI think you mean `return len(arr) / 2`\n\nYes, I will update the article.\nThanks for the comment!</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    count = 0\n    for i in arr:\n        if i >= 0:\n           count += i\n    return count</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    # Write a function to check whether a number is zero or not.\n    def is_zero(num):\n    if num == 0:\n        return True\n    else:\n        return False\n\n    # Test that the function is working properly.\n    num_check = [0, 1, 2, 3, 4, 5]\n    for i in range(num_check[0]):\n        print is_zero(num_check[i])\n    print \"First digit:\", num_check[0], \"Second digit:\", num_check[1], \"Third digit:\", num_check[2], \"Fourth digit:\", num_check[3], \"Fifth digit:\", num_check[4], \"Sum of digits:\", num_check[5], \"-------------------\"\n    print \"-------------------\", print '\\n'", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    # First, call the function iteratively on the empty array\n    for i in range(len(arr)):\n       arr[i] += 1\n    print \"Counting the array from the left: \",\n       print \"-> \",\n       print \"1 -> \",\n       print \"2 -> \",\n       print \"3 -> \",\n       print \"4 -> \",\n       print \"5 -> \",\n       print \"6 -> \",\n       print \"7 -> \",\n       print \"8 -> \",\n       print \"9 -> \",\n       print \"10 -> \",\n       print \"11 -> \",\n       print \"12 -> \",\n       print \"13 -> \",\n       print \"14 -> \",\n       print \"15 -> \",", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\n    return sum(arr[:], 2) > 0", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\n    return len(arr) == len(arr[0])\n\nThis is the best way to write the function.\n\n> This is the best way to write the function.\nNo, not at all. If you want to call it, you have to know that you\nneed the function _count_nums_ (I guess it was a typo for\n_count_nums_) and not the function count_nums. And what happens if\nyou want to write a function with the name _count_nums_? Or a\nfunction that just adds up the numbers, but doesn't call this\nfunction?\n\n> > This is the best way to write the function.\n> No, not at all. If you want to call it, you have to know that you\n> need the function _count_nums_ (I guess it was a typo for\n> _count_nums_) and not the function count_nums. And what happens if\n> you want to write a function with the name _count_nums_? Or a\n> function that just adds up the numbers, but doesn't call this\n> function?\nIt's always better", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    count_nums = lambda x:\n        if len(x) == 0:\n           return 0\n       else:\n            return len(x) / 3\n    count_nums([]) == 0\n    count_nums([-1, 11, -11]) == 1\n    count_nums([1, 1, 2]) == 3\nI think it's a bit confusing to have `return 0` as the first line of the function if it's not actually going to be used. Maybe it's better to have a `def count_nums(arr):` with an empty body?\n\nActually I think this is a fair criticism. I think the first line of the function should be `def count_nums(arr):` instead of `return 0`.\nHowever, I'm still not sure I agree with the rest of your post.\nI don't think it's a bit confusing. That's only true if you know what `count_nums` is supposed to do. If you", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if not arr.is_list:\n        return 0\n    for i in range(0, len(arr)):\n        count = 0\n        for j in range(0, len(arr)):\n            if arr[j] > 0:\n                count += arr[j]\n          else:\n                count += 1\n    return count</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for i in arr:\n        if (i!= -1):\n            if i!= 0:\n                return i\n    return 0\n\nOutput\n0\n0\n1\n1\n2\n\nThe bug\n\nIt is clear that the function is returning incorrect result. In my opinion, it is a bug.\n\nHowever, some of my friends argue that it is not a bug. I am confused.\n\nIs this a bug?\n\nI have discussed this with my friends and also with my professors. I am still in doubt.\n\nWhat do you think?\n\nPS: I am happy with positive or negative points. However, please leave a comment explaining the answer.\n\nEdit\n\nMy question is not about counting elements in an array. There are other comments in stackoverflow.", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and\n    returns the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be\n    negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    if len(arr) > 0:\n       if arr[0] is not None and arr[0] is not None and len(arr) == 0:\n          return count_nums(arr[0])\n    else:\n          return 0\n    return count_nums(arr)", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    # list of 0's and 1's\n    # zeros are not allowed\n    # only sum of positive digits > 0 is required\n    # i.e. count_nums([1, 2, 3, 4])\n    # counts 3 because 1+2+3 = 6\n    return sum(i+1 for i in range(len(arr)) if i[0] >= 0 else 0)\n\nAnd here's the output:\n>>> print count_nums([1, 2, 3, 4])\n3\n>>> print count_nums([1, 1, 2])\n1\n>>> print count_nums([-1, -2, -3])\n0\n>>> print count_nums([-1, -1, -1])\n1\n>>> print count_nums([-1, -1, 1])\n0</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\n    if len(arr) == 1:\n        return 1\n    return 0\n\nCan someone explain what's going on with this?\n\nThe test cases are bad, but the code is pretty clear.\nint count_nums(int[] arr)\n{", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return len(set([0, 0, 1]) for set in arr)\n\n>>> import string >>> count_nums([0, 0, 1]) == 1\n>>> count_nums([0, 0, 1, 2]) == 3\n>>> count_nums([0, 0, 1, 2, 2, 3]) == 5\n>>> count_nums([-1, -1, 0]) == -1\n>>> count_nums([-1, -1, 0, 1]) == -2\n>>> count_nums([-1, -1, 0, 1, 1]) == -3</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return 0 if arr == []:\n    for c in arr:\n       if sum(d) > 0:\n          return c\n    return 1\n\nOh, man, there's so much wrong with this.\n\nFirst, of course, is that it doesn't actually count the numbers.\nSecond, note that the test case for this function has to use negative numbers,\nbecause there is no way to count a positive number with the requirements given\nby the test case.\n\nThis is a _very_ common problem in testing, by the way. A lot of the time,\nwe want to make a test case for a program that can only use a particular\nset of values (e.g. positive integers). But this is problematic, because it\nis often the case that there are more than one way to implement a particular\nfunction that satisfies the requirements, and the set of values that satisfy\nthe requirements may not be a set that can be achieved by any of the ways to\nimplement the function.\n\nAs an example, let's look at the following test case:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for num in arr:\n         if num > 0 and num[1] > 0:\n             print(\"First digit is \"+str(num[1]) + \": \"+str(num))\n          return num\nI feel this is a bit more readable and I don't need to write any additional code.  I can easily extend the above to return the number of elements which do not fit in a certain range.\nThis would be a fun exercise to implement both and compare.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    import math\n    def nn(x):\n    \"\"\"\n    Return the nth digit of a number x.\n    e.g. nn(8) == 0.\n    >>> nn(8) == 0\n    >>> nn(8.0) == 0\n    >>> nn(-8.0) == 0\n    >>> nn(8.999999999999999) == 0\n    >>> nn(-8.999999999999999) == 0\n    >>> nn(8.3) == 1\n    \"\"\"\n    return x % 10**(x - 0.5)\n    def nsum(arr):\n    \"\"\"\n    Return the sum of the nth digit of the elements of arr.\n    e.g. nsum([1, 0, 2, 0]) == 3.\n    >>> nsum([1, 0, 2, 0]) == 3\n    >>> nsum([1, 0, 2, 1]) == 3\n    >>>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    counts = [0]*len(arr)\n    for i in range(len(arr)):\n        counts[i+1] += sum(arr[i] for i in range(0, len(arr)) if arr[i] > 0 else 0)\n    return len(counts)\n\nMy code:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if arr[0]!= 0:\n        return 0\n    sum_nums = 0\n    for i in range(len(arr)):\n        sum_nums += arr[i] % 10\n        return sum_nums\n\nFor the test data, see [1].\n[1] http://www.dcode.org/k/l/lis/\n\nreturn sum_nums.most_common(0)\n\nreturn sum_nums.most_common(0)", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    # Gather input\n    input_nums = [0, 1, 2, 3, 4, 5]\n    # Loop through the input\n    while input_nums:\n        # Loop through the first array element\n           i = input_nums[0]\n        # Loop through the input\n           # Check if the i th element has a sum of digits > 0\n           if sum(input_nums[i]) > 0:\n              count_sum = count_nums(i)\n              i += 1\n          # Loop through the input\n            # If the sum is negative, then the first signed digit is negative\n            if i!= input_nums.pop(0):", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for num in arr:\n        for num_sum in range(0, len(num) - 1):\n           if num_sum > 0:\n               return num_sum + 1\n    return 0\n\ncount_nums = lambda num:\n    return sum(num - num_sum) < 0", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    result = 0\n    for num in arr:\n        result += num\n    return result", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for x in arr:\n        if x > 0:\n            return x\n    return 0", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\n    def count_nums(arr):\n    for num in arr:\n       sum = sum(num)\n       num = num ** 0.5\n       if sum > 0:\n         return sum\n    return 0", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    n, digits = 0, 0\n    for i in arr:\n       n += i\n       if n > 0:\n          digits += int(n - (int)i)\n    return n\n\nAs an aside, this is also a good example of how to name functions to make them obvious what they're supposed to do. If it takes a list of numbers and returns the number of elements in the list that have a sum of digits > 0, then the name is very clear.\n\nThis is very similar to the method I used to solve this problem on my phone\n\nMy algorithm was similar. Just use an array of ints and loop through each digit. If it's positive, add it to the sum. If it's negative, flip the sign and add it.\n\nHey, this is a pretty nice solution, but I'd suggest the following change (the main thing is that it is faster):\nimport numpy as np", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(map(int, arr)) == 0\n\nMy python is a bit rusty, but I thought that returning a tuple would have been the most pythonic way to do this:\n>>> count_nums(array(1, -2, 3)) == 2\n>>> count_nums(array(1, 2, 3)) == 3\n\nThe technique used here is known as a \"fold\". It is more efficient in many cases than a for loop.\n\nGreat point.\nI think the biggest advantage to fold is that it is more pythonic than a for loop.\nFor loops are great for iterating over all of a list's elements, but for a function like count_nums, fold is more pythonic.\n\nA function that takes an array and returns a new array is inherently not very pythonic.\n\nI agree.\nI meant that using a for loop to iterate over the elements in an array is not very pythonic.\n\nI'm all for efficiency, but count_nums() is hardly the most pythonic way of doing this.\n\nA fold is the most pythonic way of doing this.\n\nI agree, but since when is", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum([i for i in range(1,len(arr)-1,0) if i % 2 == 0])\n    or -1\n\n>>> sum([1,1,2])\n3\n>>> sum([-1,-1,2])\n1\n>>> sum([-1,-1,2])\n0</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def count_nums_diff(arr, n):\n        if n == 0:\n           return 0\n        sum = 0\n        for i in arr:\n            sum += arr[i]\n           if sum > n:\n             return sum\n    return count_nums_diff(arr, n)\n    print count_nums(range(2,9))", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    nums = arr\n    for n in range(1, nums.shape[0]):\n        if n < 0:\n            return -1\n            return nums[n] < 0\n    return nums.sum() > 0\n\nThe text from the above code is repeated in the blog article. There are no comments.\n\nI would guess that the original author is pointing out that counting the number of elements in the array which have a sum of digits > 0 is a contrived example, and the contrived example is repeated in the blog post (hence the \"reposting\").\n\nI've updated the title to be more accurate, and added a comment in the blog post.\n\nI guess you could use this to show that in python you can re-use code and it's OK: https://github.com/jbaldwin/pyretro-blog/blob/master/python/code.py\n\nI made the same observation in the README.\n\nIn python, the \"extract the", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(int(sum(i) for i in range(len(arr)))))\n    def sum(i):\n    \"\"\"\n    Write a function sum which takes an integer argument and returns the\n    sum of all digits in the given integer.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> sum([-1, 11, -11]) == 1\n    >>> sum([-1, 11, -11]) == 1\n    >>> sum([1, 1, 2]) == 1\n    >>> sum([1, 1, 2]) == 1\n    \"\"\"\n    return sum(i**2)", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for n in arr:\n        sum = sum(n)\n        return sum > 0\n\nThat's not the same thing.\n\nA better approach would be to use sum() to compute a sum on all the numbers in the array, and then to check if the resulting sum is positive.\n\nAh, I knew I was missing something. Thanks.\n\nThe only real problem with this is that the sum() method is O(n), so if you have a large array, you'll be doing a lot of sum() calls. This could get expensive.\n\nIf you do a sum() call for every element in the array, you're right.\nIf you do a sum() call for every pair of consecutive elements in the array, it is O(n * log(n)).\n\nIt is also O(n) if the elements are in sorted order.\n\nYes, of course. But I think this is the easiest solution.\n\nThe easiest solution is probably summing the elements in sorted order, no?\n\nYeah, my bad, I didn't understand the problem.\n\nClever, I think. But I", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    count = 0\n    for element in arr:\n        if element[0] > 0:\n           count += element[1]\n    return count\n\nI like this one. It's simple and I could imagine it in a real life context.\nI'm not a huge fan of the whole \"any number can be negative\" thing though. I feel like it could be simplified to:\nreturn sum(element[1:]) >= 0\nor if you want to be a little more explicit:\nreturn sum(element[1:]) + element[1:]) >= 0\nThis is probably the only question I've seen on here where I'd actually answer with a Python solution. I don't know if I'd go so far as to use it in production, but I definitely have a use case for it in my head.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if arr[-1][0] > 0:\n         return arr[0][0]\n    else:\n         return 0\n\nUsing 0-indexing for the length of an array instead of 1-indexing is such a bad practice that it's surprising to see it in the Python tutorial. Using 0-indexing is very confusing to people who are used to other languages, and it's not even the way that the language itself thinks about arrays.\n\nWhile it may be confusing to people who are used to other languages, it's often times the natural way to write your code in Python.\nThe reason is because in Python, you have a lot of flexibility. For example, in a for loop, the iteration can be 1, 2, or a for loop index. It's not really clear what the best way to handle this is in other languages, so you generally have to use indices that are a powers of two.\n\nBut that flexibility is a feature, not a bug. It is certainly very confusing to beginners, though.\n\nI agree that it is a feature. However, I don't think it's very", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    # Split the input array and pass it as args\n    # Return the number of elements with sum > 0.\n    return sum([(sum(args[0]) + sum(args[1:])) > 0 for i in range(len(args))])\n\nfrom itertools import groupby, islice, cycle", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    for n in arr:\n        if n[0] > 0:\n           return n[0] + 1\n    else:\n           return 0", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    for i in range(len(arr)):\n       for j in range(0, len(arr)-1):\n          if sum(j) > 0:\n              return sum(j) + 1\n           else:\n              return 0\n    return sum(arr)\nI wonder if I should have posted this to /r/shittypython instead...\n\nWhat about the use of `sum`? Could this be changed to `len(arr)`?\n\nI used sum instead of len because sum is faster in Python than len.\n\nFaster than the constant factor (O(1)) for the sum function?\n\nThe problem is not in the sum function, but in the for loop. sum() is iterating over the entire array (and that is an O(n) operation), while len() is only iterating over the remaining elements (which can be done in O(1)).\n\nSome questions:\n\\- I think it's", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\n    def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\"\n    nums = []\n    for i in range(len(arr)):\n       for j in range(0, len(arr)-1):\n           if j + i == len(arr):\n               break\n               if sum(j) + sum(i) > 0:", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    def _sum_digits(nums):\n    return sum(nums[1:] - 1)\n    return _sum_digits(nums)\n    count_nums(arr)", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if arr[0] > 0:\n        return sum(arr[1:])\n    else:\n        return sum(arr[1:] - arr[0])\n    return 0", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if not arr[0] or arr[-1] or arr[-2] or arr[-3] or arr[-4] or arr[-5] or arr[-6] or arr[-7] or arr[-8] or arr[-9] or arr[-10]:\n         return 0\n    return sum([int(x) for x in arr if x[0]!= 0 or x[0] == -1] + 1)\n    / /", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if arr.any(x for x in reversed(int(x))):\n        if int(x) >= 0:\n            return int(x)\n        else:\n            return -1\n\nYou're missing a'return' at the end.\n\nI'm pretty sure it isn't a complete solution because the number of negative elements could be greater than zero.\n\nYes, that is the point of the exercise.\n\nI agree with \"let the language evolve and build good libraries\" but this is why I think the language really needs a more general, more powerful if/else statement.\n\nI disagree. If/else is a bad idea. The problem being solved is the lack of a general language construct that is better than if/else. This is a problem in any language with a similar construct.\n\nI think a great language should solve problems, not try to be the perfect language. Having a clean and well designed if/else statement with a bit more power than the current Python one would be a huge improvement.\n\nHow", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n\n    result = 0\n    for a in arr:\n        if (sum(a) > 0):\n           result += 1\n        result", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    if len(arr) == 0:\n        return 0\n    for i in range(0, len(arr) - 1):\n        if arr[i] >= 0:\n           return i\n    return count(arr)</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(map(str, array))\n\nWhat is the point of this exercise? Just curious. I have seen this multiple times recently.\n\nExercises are a popular part of a \"Learn Python the Hard Way\" curriculum.\n\nAh, thank you.</s>", "def count_nums(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums([]) == 0\n    >>> count_nums([-1, 11, -11]) == 1\n    >>> count_nums([1, 1, 2]) == 3\n    \"\"\" \"\"\"\n    return sum(int(int(i) for i in arr if i >= 0))\nDid you write this?  If so, this is what I hate about Python.  For a first language this is fine, but for me Python is just too easy to write this kind of non-idiomatic code.  Using sum() and int() on an array in a loop?  Really?\nI did write it.   This is an example of something that's very clear in Python, but is much more obscure in languages such as C/C++.</s>"]]