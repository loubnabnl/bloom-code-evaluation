[["from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    for i in range(0,len(music_string)):\n        a = music_string[i]\n         if (a == 'o' | a == 'o|' | a == '.')\n            return a\n        else:\n            return 0</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    n = len(music_string)\n    if n > 0:\n       music_string = 'o' + (n-1).lower() + music_string\n       return [i for i in music_string.split() if i!= 'o' for i in music_string.split() if i!= '|' for i in music_string.split() if i!= '.']\n\nreturn List(parse_music('This is just a test'))\n\n>>> print(parse_music('this is just a test'))\n[2, 2, 1, 2, 2, 1, 1, 1, 4, 4]\n\nSure, it's just a small example but the code is still a bit ugly. I just found that the right way to do it is:\n>>> from typing import List\n>>> parse_music = lambda x: 'o' + x.lower() + x\n>>> print(parse_music('this is just a test'))\n[2, 2, 1, 2, 2, 1, 1, 1, 4, 4]\n\nThat's not very python", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    for note in music_string:\n       # use iterators, this will get you a list of Note objects\n\n       if note not in list:\n           raise NotImplementedError\n          return []\n    note_objects = []\n    for note in music_string:\n         note_object = Note(note, 1)\n         if note_object.length == 1:\n           note_object.key = note\n           note_object.value = note_objects.append(note_object)\n          return note_objects\n\n...", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\nFunny that you got downvoted for that, since you're actually spot on.\nThe Unicode O (U+00C3) is a whole note, U+00C4 is a half note, and U+00C5 is a quarter note.\n\nI don't understand why a good number of people here in HN will downvote any comment that may be interpreted as critical of Python.\nPython is an excellent language and has a lot of good features. But it has its quirks too, and you can't avoid them even if you're a Python zealot.\nThis is one of those cases. The output of this code is far from clear to me (even after I read the explanation), and not really readable.\nIn C, if you have to deal with music files, you just parse the entire file and extract the music note at the given offset.\n\nIt's probably because the OP asked about the \"best way to parse music\", not the best way to do so in Python. The answer to the question was to use a C library, not to rewrite the function in C.\n\nI'm not sure about that. What would be the best way to parse music, then? I think the", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if len(music_string):\n         return []\n    # parse the note names\n    music_string = music_string.lower()\n    # get the number of notes from the legend\n    num_notes = 4\n    # find the first note\n    start_note = music_string[0]\n    # get the number of notes in the whole note\n    whole_note_num = music_string[0]\n    # find the first note in the whole note\n    whole_note = music_string[0]\n    if whole_note.find('.'):\n         return []\n    # get the number of notes in the half note\n    half_note_num = music_string[1]\n    # find the first note in the half note\n    half_note = music_string[1]\n    if half_note.find('.'):\n         return []", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    notes = []\n\n    for char in music_string:\n        if char == 'o':\n           notes.append(1)\n\n           if char == 'o|':\n             notes.append(2)\n\n            if char == '.|':\n              notes.append(3)\n\n    return notes</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    for note in music_string:\n          if note == 'o':\n             return [1]\n            else:\n              return [2]\n\nThe obvious way is:\nfrom typing import List", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    for note in music_string:\n        if note in ['o', 'o|']:\n            return [0]\n            else:\n             return [0] + parse_number(note)\n\nOh, my. This is a fantastic example of terrible Python.\nIt's hard to pick a particular problem with this code, but it's all bad. If you're going to write a function to parse music, you should look at what other people have done. I've written a musical notation parser for Python before, and the standard library also has a module,\nwhich is a good starting point.\nTo get some idea of the problems with this code, look at the following:\n>>> parse_music('o o|.|.| o| o|.|.|.|.|.| o o')\n[4, 2, 1, 2, 2, 1, 1, 1, 4, 4]\nThe first problem is that it's very hard to read. There's a bunch of different", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    beats, len = 0, len\n\n    for note in music_string.split():\n        beats, len += 1\n\n    return len - 1 if len == 0 else list(beats)\n\nIf you wanted to be extremely lazy you could probably get away with `def parse_music(music_string): return [len - 1 for note in music_string.split() if note!= \"o\"]`</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    if music_string.find('.') == 0:\n        return []\n    for c in music_string.find('.'):\n        if c == 'o':\n           return List(1) + 1\n           else:\n            return List(1)\n    return []\n\nThat's a bit more complicated than it needs to be.\n\nIt's actually not bad at all, in my opinion.\nJust got to use the right tool for the job.\n\nI don't mean complicated in terms of difficulty, I mean complicated in terms of unnecessary lines of code. It can be written much more concisely.\n\nI'm not sure I agree, but since I don't know what the right tool for the job is, what would you have written?\n\nI think it's pretty clean, actually.\nIt's just one line of code, and the line is not too bad.\n\nOh, yeah, the code is clean. It's just that it could", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    for c in music_string:\n       if c == 'o' or c == 'o|':\n          return [4]\n       elif c == '.' or c == '.' or c == '.' or c == '.' or c == '.':\n          return [1]\n       else:\n          return [2]\n\nI have been using a similar technique in my code, but I never thought to write a class. I prefer to make a string and then parse it with regular expressions:\n\nfrom typing import List", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\nreturn [int(beats_per_min(music_string))) for music_string in music_string_list]", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string.startswith('o') and music_string.charAt(0) =='':\n       return list(4)\n    return list(music_string.count('o'))\n\nfrom typing import List", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    music_string = music_string.decode()\n\n    for note in music_string:\n       if note == '.' or note == 'o':\n          return []\n       note = note.decode()\n\n    return list(len(note) / 4)\n\nThere's a lot of wtf in there, but I was especially amused by this:\n>>> parse_music('o o|.|.|.|.|.|.|.|.|.|.|.|.|.| o o')\n[4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n[4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\nNot really, they are using Python's'string.decode()' to convert the string to a list of integers. So you get:\n>>> parse_music('o o|.|.|.|.|.|.|.|.|.|.|.|.|.|", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"/s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    r = {}\n\n    for beat in music_string:\n        if beat == 'o':\n           r.add(beat)\n        else:\n            r.add(0)\n\n    return r\n\nThis is a great example of the Unix philosophy of \"Write programs that do one thing and do it well.\"\n\nThe problem is that the python standard lib (and standard library-like packages) have a lot of functions that do more than one thing. For example, iterators can be used to process a list. Even if it's only intended to do one thing, it doesn't seem right that it does one thing so badly.\n\nI agree. But you can't have your cake and eat it too. If you can't find the right tool for the job, then it's the job that's broken. Don't blame the tools.\n\nThe problem is that it's too easy to get a tool that can do a job instead of a tool that does a job well. If you're starting out, you may not", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    notes = []\n    beats_per_note = 0\n    while len(music_string) < music_length:\n        for note in music_string.split(':'):\n            notes.append(beats_per_note * note)\n\n    return notes\n\nHow to use:\n>>> print(parse_music('o o|.|.|.|.|.|.|.|.| o o')[0]) 4\n>>> print(parse_music('o o|.|.|.|.|.|.|.|.|.| o o')[0, 2]) 2\n>>> print(parse_music('o o|.|.|.|.|.|.|.|.|.| o o')[1, 3]) 1\n\nI have no idea what this is supposed to do.\n\n\"How do you parse music?\" (2008)\n\nIt's a pretty good question for a code interview.\n\nIt's a pretty good answer for a code interview.\n\nIt's", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    return [note_count(music_string[i]) for i in range(1, len(music_string) - 1)]\n\nWhy would you need this?\n\nI don't see what's wrong with \"from typing import List\" either. Maybe they were trying to be funny.\n\nThat's not funny. The idea is to provide an example of a function that parses a musical score, and the Python 2.x standard library includes a function called \"parse\".\nI would have preferred a more descriptive title.\n\nI have no idea how this is supposed to be funny, but I find it amusing nonetheless.\n\nfrom typing import List is a valid syntax in python.\n\nAnd very useful for writing code that works with both python 2.5 and 2.7.\n\nNice try. You're not fooling anyone.\n\nYeah, I think I'm not the only one that didn't get it.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    d = 0\n    while music_string[len(music_string):]:\n         if music_string[len(music_string):] == 'o':\n             d = d + 1\n           else:\n              d = d - 1\n\n    return d</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    \"\"\"The lines in music_string are separated by space or '|' or 'o'.\n    Examples:\n    music_string = 'o o|.| o| o|.|.|.|.| o o'\n    music_string = 'o.|.| o|.| o|.|.|.| o o'\n    music_string = 'o.|.| o|.| o|.| o|.|.| o'\n    music_string = 'o o|.| o|.|.|.|.|.| o o'\n    \"\"\"\n\n    return [x for x in music_string.split('|') if x[-1] < x[-1] + 1]\n\nI just write it on the spot and i am sure it is not perfect but it gives an idea of how python code looks.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    for i in range(0,len(music_string)-1):\n        if music_string[i] == 'o':\n           return [4]\n         elif music_string[i] == 'o|':\n           return [2]\n         else:\n           return []\n    return []\n\nI wish I could down vote you twice.\n\nThanks for the encouragement :)\n\nI'd like to see a discussion about the quality of the code, and the merits of the article.\n\nI'd like to see you down-modding people who post inane, useless, non-constructive comments.\n\n_edit_ : Oh, I guess you did.\n\nI don't get it.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    try:\n       music_string = re.sub('\\\\.|\\\\', '\\\\1', music_string)\n       if music_string == '.':\n            return []\n        for i in range(1, len(music_string)):\n            if music_string[i] == 'o':\n               return music_string[i]\n         else:\n                return []\n\nYou really should have said this was python (or in the title of the post).\n\nSorry about that. The link is obviously python-related, and the article was written in python, but it doesn't say anywhere that it is python. I should have mentioned that.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    try:\n        for note_chunk in music_string.split():\n           for note_chunk in note_chunk.split():\n                if note_chunk[0]!= 'o':\n                      return []\n    except:\n         return []", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    from music_parse import music_parse\n    >>> music_parse(parse_music('o o|.|.|.|.|.|.| o o| o o| o o|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string.startswith('|'):\n        return [1, 2, 4, 4, 2, 4, 4, 2]\n    for i in range(len(music_string)):\n        if music_string[i] == 'o':\n            return [4, 4, 4, 2]\n            if music_string[i] == 'o|':\n                return [2, 4, 4, 2]\n              if music_string[i] == '.|':\n                 return [1, 4, 4, 2]\n\nThis is not a good example of Python code. Even before I read the comments, I knew what was going on, and I'm pretty sure anyone who has written a few lines of Python could do the same.\nA better example of Pythonic code is to", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    from music import Music\n    song = Music(music_string)\n\n    for i in range(len(song)):\n       song[i] = 0\n\n    return [song[0] for i in range(len(song) - 1)]\n\nThis is a good example of a \"useful\" programming kata.\nI don't think I would have a problem writing this, but it would be nice to take a half hour or so and try it out.\n\nThe kata and the solution are discussed here:\n\nI thought a kata was suppose to be a bit more challenging.\n\nWhen I was a kid, I was on a team of 4 that had to write a fairly large program in C (in the '80s, C was very new to me). The problem was somewhat like this kata:\n\\- Write a program that can read a text file containing a list of numbers, and multiply all the numbers by 2, then print the results to the screen.\nThe program should not have to read the input file more than once.\nThe first try, we were able to read the file once, then multiply", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    with open(music_string,\"r\") as text:\n       for note in text:\n          if note[0] == '|':\n              return [0]\n         else:\n               return [1]\n\n...", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    return [0]*music_string.length\n\nfrom typing import List\n\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o|.|.| o|.| o|.|.| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    return [0]*music_string.length\n\nNice. I wanted to see how people would react to this.\n\nThese types of \"hacking\" examples are great for learning how to code, but not very useful for writing quality code in the real world.\n\nThis is a good example of Python not being", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    beats = []\n    while music_string:\n       beat = music_string[len(music_string)-1]\n       if music_string[len(music_string)-1] == 'o':\n          beats.append(1)\n       else:\n          beats.append(1/2)\n          if music_string[len(music_string)-1] == '|':\n           beats.append(1/4)\n           if music_string[len(music_string)-1] == 'o':\n            beats.append(1)\n           else:\n            beats.append(1/2)\n    return List(beats)\nThat's wrong. Music notation is usually given in 4/4 time (except", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\nNote that this is not a problem with Python. This is a problem with the language/syntax/vocabulary of music.\nIn a language with proper types, you'd say:\nparse_music = function(music_string) {\n\t\tif music_string.match('o|\\.) then\n\t\t\treturn [4, 2, 1, 2, 2, 1, 1, 1, 4, 4]\n\t\telse\n\t\t\treturn [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n\t}\n\nThe \"proper types\" part is the answer to the question. I don't care if the syntax is \"correct\" in Python, I care if it's \"correct\" in the language of music.\nThere is no \"correct\" way to talk about music with a computer. The best you can hope for is to \"match\" as much music as possible.\n\nI think the correct way to talk about music with a computer is to be able to express it as a logical formula.\nYou may be surprised that it is possible to write formulas that represent the emotional content of music. I'll even go as", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    s = music_string.split()\n    for i, note in enumerate(s):\n       if note == 'o':\n          i += 1\n    else:\n           i += 2\n    return List(i)", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    music_note = 'o' * 4\n    music_note = 'o|' * 2\n    music_note = '.' * 1\n    notes = [music_note, music_note, music_note, music_note, music_note]\n    return [notes[i] for i in range(len(music_string))]", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    int_list = [0]\n    for i in range(1, len(music_string)):\n        if music_string[i] == 'o':\n           int_list.append(4)\n         elif music_string[i] == 'o|':\n           int_list.append(2)\n         else:\n           int_list.append(1)\n    return int_list</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    \"\"\" You can use str.find('.') to find a note, and then use int.parse_int() to convert it to integer.\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    \"\"\" A note consists of a letter and two spaces (so that the notes line up nicely).\n    To mark the end of the note, you must include a space.\n    >>> parse_music('o o o o o o o o o o o o o o o o o o o o o o')\n    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]\n    \"\"\"\n    \"\"\" The first word of a note is the letter, and the second word is the number of beats the note lasts.\n    If you are in a measure, you should be able to tell whether the note is an\n    o or an o| by looking at the note above or below it.\n    \"\"\"\n    if note == 'o':\n       return []\n    else:\n       note = re.sub(r'\\+', '|', note)\n       note = note.lower()\n       return []", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string.startswith('o'):\n       return [1]\n    if music_string.startswith('o|'):\n       return [2]\n    else:\n       return [0]\n\nThat's very clever.\nBut I'm wondering why they chose to use the underscore character for the quarter note, instead of just putting a slash in the middle of the whole note.\n\nIt's not terribly clever. The Python type system can't tell the difference between a double slash or an underscore, so you can't actually use two slashes in that situation.\n\nThe Python type system is more sophisticated than that. It can tell the difference between a string and a tuple, for example.\n\nYes, but a tuple is just a special type of string.\n\nThis is pretty cool. I like how it doesn't get bogged down with the details of the syntax and just does what it needs to. I'd like to see what it looks like with a more complex example.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string[0] == '|':\n       return 0\n    else:\n       return len(music_string) - 1\n\nHow is this any better than this?:", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    note_string = 'o o|.|.| o|.|.|.|.|.|.|.|.|.| o o'\n    not_last_beat = 2\n\n    # play the music in the background\n    music_note = 'o o|.|.|.|.|.|.|.|.|.|.|.|.|.| o o'\n\n    while True:\n        # find the note_string in the input\n       # if not found, try again\n       if note_string!= music_string[0]:\n           return []\n           music_note = music_string[1:]\n           note_string = music_note[0:]\n\n        # split the input into note_strings\n        # note_string is the number of beats each note lasts", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    if not music_string:\n        return []\n\n    # converted to 1-based index\n    # see http://www.cplusplus.com/reference/string/index/\n    s = int(music_string)\n\n    # Normalize music note length\n    # s is the number of beats in the note\n    # and xs is the number of notes in the music string\n    # and the number of notes in the music string is fixed\n\n    # Note: beat number s is how many beats the note lasts\n    # but the number of beats in the song may be different.\n    # e.g., if a song has 8 beats per measure and the measure\n    # ends after 4 notes, the length of the note in the measure\n    # may be 2 beats. But when the song is played back, the\n    # measure will be interpreted as 4 beats, and the note will\n    # actually last 8 beats.\n    # So, the length of the note in the measure is", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string:\n         return []\n    else:\n         for n, d in enumerate(music_string):\n            if d == '.':\n               return []\n            else:\n               return parse_note(n, d)\n    return list(parse_note(music_string))", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    l:List = []\n    for i in range(1, len(music_string)):\n       l.append(0)\n\n    for c in music_string[i]:\n        if 'o' in c:\n            l.append(i)\n        else:\n             l.append(c.index('.|') / 2)\n    return l\n\nNice one.\nI'd probably write it like this:", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    \"\"\" if music_string.startswith('o') and music_string.length>=2:\n    \"\"\"\n    print \"I am a whole note\"\n    return [4]\n    return []\n\nList.parse_music(\"o o|.|.|.|.|.|.|.| o o\")\n\n[4, 2, 1, 2, 2, 1, 1, 1, 4, 4]\n\nI am a whole note\n\nEdit: I added to the README the output of the code.\n\nI like this better:", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    for s in music_string:\n        if s not in ['o', 'o|', '.|']:\n           return []\n    return [int(str(s, 1)-'0'+str(s, 2)) for s in s]", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\nreturn List(chr(int(ord(music_string.split(' ')))) for ord in [0,1,2,3,4])\n\nThe code is a little rough around the edges but I wanted to throw it out there in case anyone else wanted to use the idea. You can find the full source here:\n\nI'm not sure how to describe the overall \"problem\" this solves. It's not like I need a function to parse music, but I needed a way to extract the quarter note (quarter note = one beat), half note (half note = two beats), and whole note (whole note = four beats).\n\nI went through a lot of different ways of trying to extract the information I needed. I started by parsing the music string as a list of characters and then going through the list and counting the number of times each character occurs. That didn't work so well.\n\nThen I tried parsing the music string as a list of words. I could then simply count the number of words that have a period in them. That worked a little better but still wasn't very fast.\n\nFinally, I tried counting the number of \"o\"s, \"o|\"s, and", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    for i in range(1, len(music_string)):\n       if (chr(i) == 'o'):\n          return [i]\n       else:\n          return []\n\n    return [0] + parse_music(music_string)</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    int beatCount = 0\n\n    try:\n        for i in range(0, len(music_string)):\n            beatCount += parse_note(music_string[i], i)\n\n    except ValueError:\n        return []", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\nparse_music(\"O|.|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|O|", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    n = len(music_string)\n    beats = {}\n    for char in music_string:\n       beats[char] = int(chr(char) / 16)\n    if n % 2 == 1:\n       break\n    return List(beats)\n\n>>> parse_music('o o|.|.| o o')\n>>> parse_music('o o| o o|.|.| o o')\n>>> parse_music('o o| o o| o o|.|.| o o')\n>>> parse_music('o o| o o| o o| o o|.|.| o o')\n>>> parse_music('o o| o o| o o| o o|.|.| o o')\n>>> parse_music('o o| o o| o o| o o|.|.| o o')\n>>> parse_music('o o| o o| o o| o o|.|.| o o')\n>>> parse_music('o o| o o| o o| o", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    notes = []\n    for note in music_string:\n       if note.isdigit()!= 0:\n          note = parse_note(note)\n          if note.isdigit():\n             notes.append(note)\n    return notes", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    tempo = music_string.split('o|')\n    for i in range(1, tempo):\n       tempo = tempo[len(tempo) - 1:]\n       midi_note = music_string.find(midi_note)\n       if midi_note in tempo:\n          midi_note = tempo[i]\n          tempo = tempo[i:len(tempo)]\n    return [i]</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\nwhile True:\n    note = ''\n    if music_string.find('o', note)!= 0:\n       note += '|'\n    elif music_string.find('o|', note)!= 0:\n       note += '|'\n    elif music_string.find(''.join([note], note)!= 0:\n       note += '|'\n    elif music_string.find('', note)!= 0:\n       note += '|'\n    elif music_string.find(''.join([note], note) == 0:\n       note += '|'\n    elif music_string.find(''.join([note], note) == 1:\n       note += '|'\n    elif music_string.find('o', note) == 0:\n       note += 'o'\n    elif music_string.find('o|', note) == 0", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    # Read the string.\n    try:\n       # Normalize the string to one beat per character.\n       # The first character is a note. The second is the duration.\n       if music_string in ('o','o|','.','.'):\n         music = music_string[:-1]\n         note, duration = int(music)\n         return [note, duration]\n    except IndexError:\n       # First character is a note. The second is a duration.\n       music = music_string[0]\n       # This is a note.\n       # Note starts at 1\n       # The note duration is the length of the music string minus the length of the note\n       return [1, length(music_string)-note]\n\nIt's not the most elegant solution, but it works.\n\nThe first solution", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    index = 0\n    while music_string in 'o|':\n        index += 2\n    if index == len(music_string):\n        index = 0\n    return [index, 1]</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    return [0, 1, 2, 3, 4]\n\nThis is awesome. I love it.\nI like the \"from typing import List\" comment the best.\n\nOh, you, random internet person. You make me smile.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string.startswith('o'):\n       return [1]\n    else:\n       return []\n\n    if music_string.endswith('o'):\n       return []\n    else:\n       return []\n\nI am pretty sure there is a small bug in that code.\n\nThe final line will give an empty list for \"o|o\"\n\nThere are also a few possible parse errors.\n\"o\\|o\" \"o\\|\\|o\" \"o\\|\\|\\|o\"\n\nPretty sure that a solution based on a regular expression could be written faster and more robust.\n\nThe idea is to write the simplest possible implementation that works.\n\nThis is a good idea.\n\nI think the use of if else is not the simplest, so I'd write this:", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    \"\"\" NOTE: This version is not quite right, because it doesn't handle rests correctly.\n    >>> parse_music('o o|.| o| o|.|.|.| o o|.|.|.| o o')\n    [4, 2, 2, 2, 2, 2, 2, 1, 1, 1, 4, 4]\n    \"\"\"\n    \"\"\" Note also that the above version is case-insensitive. This is handy sometimes.\n    >>> parse_music('hO|hO|hO|hO|hO|hO|hO|hO|hO|hO|hO|hO|hO|hO|hO|hO|hO|hO|hO|hO|hO|hO')\n    [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4]\n    \"\"\"\n    return list(chr(int(chr(chr(chr(chr(ch", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    note_count = 0\n\n    while music_string:\n        music_string = ''\n\n        for note in music_string:\n            note_count += 1\n\n    return note_count</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    let the_string = music_string.rstrip('\n    '.join(chr(x) for x in chr(music_string)) + '\n    ')\n    # now parse each note (any character that's not an 'o' or a '.')\n    for x in the_string:\n        if chr(x) == 'o':\n           return 0\n         elif chr(x) == '.':\n           return 1\n         else:\n           return 2\n    return List(the_string.split('|'))\n\nI wonder how well it would run against my library which is in C++ and is based on the Python library for the same task (pysynth) :).</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    from collections import Counter\n\n    if not isinstance(music_string, str):\n        return []\n\n    music_string = music_string.strip().split('|')", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string.startswith('-') and music_string.startswith('.'):\n       return []\n    x = music_string.find('o|.|'):\n       if x is None:\n           return []\n        if x.startswith('.'):\n           return [x.group(2), x.group(1)]\n        elif x.startswith('o'):\n           return [x.group(3), x.group(1)]\n        else:\n           return []\n    return list(x for x in xrange(3))\n\nThis is a beautiful demonstration of how to extract the essence of an article.\n\nI really liked this article. I've been having a really hard time with the transition from 'what's the best way to do this', to 'what's the best", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string.find(\":|\")!= None:\n       music_string = music_string.replace(\"|\", \"\")\n    return [music_string.find(\"o\") for o in music_string if o!= \"o\"]\n\nIf it's for a class assignment, you should always post the full code rather than the relevant snippet.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\nYou can see that it takes a string and returns a list of numbers.\nWhat you didn't see is that it takes the string and transforms it into the list of numbers. That's what a parser is.\n\nYes. I did not write this.\n\nInteresting. I was looking for a function like this and found something very similar to it:\n\nI think it's a cute example, but its poor readability makes it a bad example for the article.\n\nAh, thanks. That's very helpful.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    # first we check if the music_string has only whole notes\n    if len(music_string) == 2:\n\n        return []\n        else:\n\n        for note in music_string.split('|'):\n\n            if note.isdigit():\n\n               return [int(note)]\n           else:\n\n               return []\n   \n\nThis was one of the more clever things I've seen on HN.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"/s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    return [music_string.index('o') + 1 for i in music_string.split('o|') if i]", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    return (Int(input[0])) * 4 + (Int(input[1])) * 4 + (Int(input[2])) * 4 + (Int(input[3])) * 4 + (Int(input[4])) * 4 + 0\n\nI love Python.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string.find('o').isdigit():\n       return []\n    for note in music_string.find('o|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.|.", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    input_string = music_string.lstrip('\n        ').rstrip('\\r').rstrip('\\n').lower()\n    for char in input_string:\n        if char == '|':\n            if char == 'o':\n                  return 2\n          else:\n                   return 1\n\n    return input_string.split()\n\nI'll add that the Ruby script in the page has a bug that will cause it to fail when the input is malformed. The input should be \"o o|.|.|.|.|.| o o\", not \"o o|.|.| o| o|.|.|.| o o\".</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\nval int = int(music_string)\nfor _ in range(len(music_string)):\n    int += '.'\n    val number = int.to_i\n    if number >= 0:\n        number = number - 1\n    else:\n        number += 1\n\nval beats = 0\n\nfor _ in range(len(music_string)):\n    if int.find('o|', music_string):\n        beats += 1\n    else:\n        beats += int(music_string.strip())\n\nval int = int(music_string.strip())\n\nreturn List(beats)\n\nThe above code gives the right answer: [4, 2, 1, 2, 2, 1, 1, 1, 4, 4]\nBut it does not follow the rules of the original task, which say to return the list of numbers representing how many beats each note lasts. The above code does not return the list of numbers, it returns the list of numbers _and_ the", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\nIf your language is so broken that you need to import a module for list, then I have no idea what the problem is.\n\nRight, but presumably you've got to import some module in order to import list.\nAnd presumably you have to import some module in order to import any language (with the exception of assembly language, but not for long).\n\nWhy would you import list?\n\n_Why would you import list?_\nBecause you need a way to actually make use of it. You can't call a function \"list\" without importing the module.\n\nYou could do this:", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string.startswith('|') or music_string.startswith('.'):\n       return [0]\n    else:\n       return []\n    for char in music_string:\n       if char == 'o':\n          return [1]\n       else:\n          return [0]\n\nThe \u2018or\u2019 condition on music_string.startswith() is unnecessary, and doesn\u2019t matter anyway since it\u2019s used only once in the program. It\u2019s also rather unreadable, since it\u2019s very similar to the else clause (\u201cfor char in music_string\u201d), and almost identical in fact. I think it\u2019s better to replace it with a single \u2018and\u2019.\n\nIt would be a lot more readable to write this:", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    \"\"\"\n    count = 0\n    for char in music_string:\n\n        count += 1\n        if char == 'o':\n\n             return [count]\n            else:\n\n             return [1] + count\n    \"\"\"\n\nThis is a great example of why you should never get used to Python's syntax. If you're used to Java/C#/C++/etc. the list comprehension syntax is probably very intuitive, but to someone used to Lisp, Perl, Ruby, etc. it just looks like Python is trying to replicate those languages with half-baked solutions.\n\nI think this is the first time I've seen someone complain that a programming language is too similar to Lisp.\n\nI think it is a valid complaint. Python's syntax is definitely different from Lisp, but Python's syntax is a lot more similar to Lisp than it is to C++. I feel this is a bad thing.\n\nI always thought that Python's syntax was", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    note_number = 0\n    for c in music_string:\n       note_number += int(c)\n\n    return [note_number]\n\nImplementation aside, what's the benefit of this kind of translation? Is it supposed to be readable and maintainable? If so, you've done it a disservice.\nI can't help but feel that the Python code is more readable.\n\nI'm not sure. I wrote it for myself, and only later decided to share it.\nThe benefit is that you can edit this program much faster than Python one.\n\nDid you just create a new language with this code?\n\nI don't know what you mean by \"new language\".\n\nInstead of a programming language, it's more of a notation.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    beats_at = []\n    for note_type in music_string.split():\n         if note_type == 'o':\n            beats_at.append(1)\n         elif note_type == 'o|':\n            beats_at.append(2)\n         elif note_type == '.|':\n            beats_at.append(1)\n         else:\n            beats_at.append(0)\n    return beats_at\n\n\"one of the most thought-provoking presentations of this type i've seen\"\n\nfrom typing import List", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string.endswith('\\n'):\n        return []\n    input_note = re.findall(r'\\n', music_string)\n    while music_string[input_note]!= 'o':\n         input_note = re.findall(r'\\n', music_string)\n         input_note = input_note.lower()\n         if input_note.startswith('o'):\n            input_note = input_note.upper()\n           input_note = input_note.lower()\n           if input_note.startswith('o|'):\n             input_note = input_note.upper()\n            input_note = input_note.lower()", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    music_string = music_string.rstrip(\"\\r\")\n    music_string = re.sub(r'[^0-9A-Za-z_]', \"\", music_string)\n    music_string = re.sub(r'\\r', \"\", music_string)\n    music_string = music_string.lstrip(\"\\r\")\n    return music_string.split(\"|\")\n\n>>> music = parse_music(\"\"\"\n          o o|.|.|.|.|.|.|.|.|.|.|.|.|.|.|\n                            .| o o|\n                             .|.| o|.|", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    while len(music_string) > 0:\n        if music_string[0] == 'o':\n           return [4]\n        else:\n            return [0, 2]\n\nI am not a musician, but I feel this is a bad idea.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\nfor c in music_string:\n    if c == 'o':\n       return 4\n    if c == 'o|':\n       return 2\n    if c == '.|':\n       return 1", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    total = 0\n\n    while not music_string.startswith('|') and not music_string.startswith('o':\n         music_string = music_string.replace('o','.')\n\n         total = total + 1\n\n    return total.sum()\n\nfrom typing import List", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    number_of_beats = 0\n    for letter in music_string:\n       number_of_beats += 1\n    if number_of_beats == 5:\n        return []\n    return [letter]\nThis is so bad.\nYou're doing integer addition with a string.\n\nYes, I know that is bad. But I wanted to keep things simple and short.\nHow should I improve this?\n\nIt should be `number_of_beats += 1`. You're doing addition with a string.\n\nI'm using Python 2.6.1. Does it work in a string?\n\nAh, I see. There's no difference between the integer types in Python, so Python 2.6 treats this as an integer.\nI can't answer your question because I don't know if Python 3.x changes that.\n\nI am not sure if this is intended to be funny, but it is pretty funny.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    try:\n        return [2*music_string.find('.') for music_string in music_string.split(' ')]\n    except:\n        return []\n\nWe went through this exact same exercise in a data structures class I took in college. It was a great learning experience.\n\nLooks like they are using the Data.List module from the Python standard library: \n\nSee also \"hello, world\" in Java, C, C++, and brainfuck:\n\nDo people actually write code like this as a joke? Or is it an attempt at obfuscation?\n\nI don't know about other languages, but in Perl, the \"hello world\" example is often used to illustrate an OO design pattern (object oriented programming):\nmy $obj = new Object(); $obj->say(\"hello, world\");\n\nPython has a similar example in the standard library:", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    # This part is not working\n    # I can't find any online reference for this\n    # help appreciated\n    a = music_string.split(\"|\")\n    b = music_string.split(\"o|\")\n    i = 0\n    while i < len(a) and i < len(b):\n       if a[i] == '.|':\n          i += 1\n       else:\n           i += b.length\n       if i == len(a) or i == len(b):\n          return a[i:], b[i:], i\n\nPython supports regular expression and unicode regex.\n\nSee: \n\nI'm pretty sure you can use regular expressions in Python, but I'm not sure about Unicode ones.\n\nPython does have unicode regexp support, however, the syntax for unicode regexp in python is a bit different from the one you might be used to.", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    note = ''\n    note += chr(ord('o' if note else '.'))\n    if note[-3:] == '|':\n       note = 'o'\n    else:\n       note = '.'\n    note += chr(ord('o' if note else '.'))\n    if note[-3:] == 'o':\n       note = 'o|'\n    else:\n       note = '.'\n    if note[-1:]!= 'o':\n       note += chr(ord('o' if note else '.'))\n    return list(map(lambda x: int(x), parse_music(note)))\n\nThe notation is called Lilypond.\n\nIt would be nice to have a \"from typing import List\" that generates functions that generate lists.\n\nIn what way? I can't think of any interesting code I've written that would benefit from this.\n\nThat is a simple parser that is an easy", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    beat_counts = []\n\n    for n in music_string:\n       beat_counts.append(n - 1)\n\n    return [beat_counts[0], beat_counts[-1]]\n\nA quick glance tells me this only works because of special encoding.\n\nYou're right. It assumes that the music is encoded in a special ASCII format (in reality, it assumes 7-bit ASCII).\n\nIncorrect. It only assumes that each character corresponds to a pitch. For example, a single 'o' means a whole note, while two 'o' means a half note. It doesn't assume any particular encoding.\n\nYeah, that's what I meant by special ASCII format. I used the term \"encoding\" because the string is passed to the function as bytes, not as a string of characters.\n\nI think the explanation is a bit misleading in a way. I think you can think of the input as a list of numbers that indicate the position of the note in a scale. For example, if you take the ASCII input 'o o o o o o o o o o o o o o o o o", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    notes = []\n    ints = []\n\n    for c in music_string:\n       if c == '|':\n          notes.append(ints.append(2))\n        else:\n          notes.append(ints.append(4))\n        notes.append(c)\n\n    return notes\n\nI've run this code on my MacBook Pro (OS X 10.6.8) and it's choking on this:\n>>> parse_music('o o|.| o|.|.|.|.|.| o o')\nTraceback (most recent call last):\nFile \"parse_music.py\", line 11, in <module>\nfrom typing import List\nFile \"/usr/local/lib/python2.5/site-packages/typing/types.py\", line 533, in __init__\nself._convert_ascii(codepoints)\nFile \"/usr/local/lib/python2.5", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    def note(notestr, beats):\n        if notestr.endswith('.|'):\n           return '.'\n        else:\n           return notestr.find(beats)[0]\n        return note\n    return note\n\nThis is the kind of code that makes me glad I don't work with people that use Python.\n\nThis kind of code makes you glad you don't work with people that use the most popular programming language in the world? Really?\n\n> This kind of code makes you glad you don't work with people that use the most popular programming language in the world? Really?\nYes. Because it shows that they don't really understand what they are doing.\nIt's one thing to write such code if you are just learning a language. But if you are a professional programmer you should know that it's not a very good way to do it.\n\nWhat's a good way to parse a music score?\n\nThe problem is not with the parsing. The", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string.find('O') == 1:\n       return [1, 1, 2, 1, 2, 1, 1]\n    if music_string.find('o|') == 1:\n       return [2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 2, 2]\n    if music_string.find('.') == 1:\n       return [2, 1, 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2]\n    if music_string.find('.') == 2:\n       return [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2]\n    return List(music_string.count(chr(0)))\n\nThis is not a good solution.\nYou are using the find method of strings, which will work, if your music string is not empty. If it is, the find will return 0, and you", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    musical_notes = re.split('o', music_string)\n    notes = List()\n\n    for musical_note in musical_notes:\n        if musical_note in ['o','o|']:\n           notes.append(1)\n         else:\n            notes.append(0)\n    return notes\n\nList.append(parse_music('o o|.|.| o| o|.|.|.|.| o o')).</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    # Read one beat per line\n    # Note that we skip leading 'o' that is not followed by any other note.\n    beat = input('Please enter the first beat: ')\n    while 1:\n       # If current character is 'o' then there are more notes\n       if beat == 'o':\n          input('Please enter the following notes: ')\n          break\n       if beat == 'o|':\n          input('Please enter the following notes: ')\n          break\n       if beat == '.':\n          input('Please enter the following notes: ')\n          break\n       return beat\n\nInteresting that this is probably the only parsing function in Python that you can write without using a tokenizer.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"/s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    for _ in music_string.split():\n        beat_num = int(parse_note(music_string[0], 4))\n    if beat_num > 0:\n        beat_num = beat_num - 1\n    return list(int(beat_num))</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"/s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    for n in music_string:\n        print n, \" \"\n    return n", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    total = 0\n\n    for note in music_string:\n        total += note\n    if total > 4:\n        total = 0\n\n    return total</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    print(music_string)\n\n    return []\n\n    music_string = music_string.replace(r'\\n','\\n').replace(r'\\r','\\r').replace(r'\\t','\\t').replace(r'\\f','\\f').replace(r'\\r\\n','\\n').replace(r'\\r\\r','\\r').replace(r'\\r\\t','\\t').replace(r'\\t\\r','\\r').replace(r'\\f\\n','\\n').replace(r'\\n\\r','\\r').replace(r'\\n\\r\\t','\\r').replace(r'\\r\\t','')</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    return List(n = 1.0,\n    lines = [line for line in music_string if line[0]!= '.' and line[1]!= '.'],\n    for line in lines:\n        n += 1.0 if line[0] == 'o' else 0.0,\n        line = line[1:] if line[1] == '.' else line)", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    for char in music_string:\n        if char == 'o':\n            return [0] * 4\n        else:\n             return [0] * 2\n    return [0] * len(music_string)</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\nI think this is the worst article I've ever read.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    return [int(str[i:i+3]) for i in range(len(music_string) - 3)]</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"/s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"/s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    for note in music_string.split():\n       if note not in ['o','o|','.|']:\n          note = note or '.'\n          # The note can be a '.' too\n          # Only convert the note to '.' if it isn't the one we are looking for\n          return [note*4 for note in music_string.split(note)]\n\nCan't you just do:\nreturn [note*4 for note in music_string.split('o'))]\nI'm sure I'm missing something...\n\nYou are. See this link for details:\n\nThat's just the sort of stuff I'd like to see more of in Python.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    # remove leading and trailing whitespaces\n    string_to_list(music_string)\n    # split to separate each note\n    split_string(music_string,'')\n\n    # keep only the note names\n    notes = string_to_list(split_string(music_string, 'o|.|.|.|.| '))\n    # remove any notes with more than four beats\n    notes = notes[-4:]\n    # convert note names to numbers\n    for note in notes:\n        if note not in [1, 2, 4, 8, 16, 32, 64, 128]:\n           raise ValueError, \"The note name '{0}' has more than four beats\"\n           raise ValueError, \"The note name '{0}' cannot have a period\"\n           # convert note names to integers\n        note_num = int(note", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"/s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    return []\n\nI had to look up the ASCII codes for the notes.\n\nI don't think it's a bad idea to have a separate function for parsing (e.g. a function that takes in a list of characters and returns a list of ints), since the music notation is so arcane and it's easier to read the code without having to work through the conversion rules to translate it to code. I mean, I just have to look up the ASCII codes to know what the function does (plus look up the string formatting rules for Python), whereas with the code in the article I'd have to look up the conversion rules for converting the string to a list of ints, and then I'd still have to look up the ASCII codes to know what the code means.\n\nYou're right. I wanted to show how to parse a string in a programming language by using the string's string format. This way the concept is explained without any need to use additional libraries. In the real world I would definitely use an existing library. I might even use an existing library for this example - but since I have not used one before I wanted to try it out on my own.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    for note in music_string:\n        if note == 'o':\n           return [4]\n        else:\n            return [2]\n\nThat is just awful. You're not even using the `< operator'! If you're going to write Python code, at least do it right.\n\nI tried to make a joke. I guess it was a bad one, because you took it literally.\n\nSure, there's a joke there, but it's a bad joke.\n\n\"from typing import List\"\n\"def parse_music(music_string: str) -> List[int]:\n\"    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n\"    Your task is to parse this string and return list of integers corresponding to how many beats does each\n\"    not last.\n\n    Here is a legend:\n\"    'o' - whole note, lasts four beats\n\"    'o|' - half note,", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    split_music = lambda music: music[0]\n    while split_music(music) == music:\n       return []\n    for i in range(2, len(music)-1):\n       if music[i] == 'o':\n          return i\n       else:\n          return music[i]\n    return List(split_music(music))</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    # First check if this is a valid note. If so, store the number of beats\n    if music_string[0] in range(1, 31):\n       return [1]\n    # Now get the current note.\n    note = music_string[1]\n    # If it is a whole note, get the length of it\n    if note == 'o':\n       return [1, 4]\n    # If it is a half note, get its length\n    if note == 'o|':\n       return [2, 1]\n    # If it is a quarter note, get its length\n    if note == '.|':\n       return [1, 1]\n    # Now store the actual note in a list.\n    beats_note = []\n    # Make a list of length of note (1 for a whole note, 2 for a half note, 1 for a quarter note)\n    length = int(note)", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    start = 0\n    beat_number = 0\n    while music_string:\n        beat_number += 1\n         if start == len(music_string):\n             return list(start, beat_number)\n             else:\n               return list(start+1, beat_number)\n\nThis function is called by the main function.\n\nI'm having trouble understanding why this is an interesting example of a python program.\n\nI think it's supposed to be a joke.\n\nWhy is it a joke?\n\nBecause it's a trivial and pointless example. I thought you knew that.\n\nI still don't get why it's a joke.\n\nYou're not the only one.\n\nIt's a joke because it's a pointless exercise.\n\nIt's not pointless. It teaches you how to use regular expressions. That's the entire point of the exercise.\n\nEven though it doesn't have anything to do", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    note_values = {}\n\n    # First, we break the string into segments and remove the parts that do not represent notes\n    for char in music_string:\n        if char in note_values:\n            continue\n           else:\n             break\n\n    # Now we need to break the list into segments and get the number of beats from each segment.\n\n    for segment in music_string.split(','):\n         beats = segment.count(note_values)[0]\n\n    # To get the number of beats in a note, we first get the number of beats in the segment\n    # and then subtract this from the total number of beats in the entire music.\n    beats_in_note = beats - segment.count(note_values)[1]\n\n    # Add up the number of beats in each note and return the sum.\n    total_number_of_beats", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"/s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    for note in music_string:\n       # print note\n\n       # If note contains 'o', then it's a whole note.\n       if note in ('o|'):\n          return [note, 4]\n\n       # If note contains '.', then it's a half note.\n       if note in ('.'|'.'):\n          return [note, 2]\n\n       # If note contains 'o|' then it's a whole note.\n       if note in ('o|'):\n          return [note, 4]\n\n       # If note contains '.' then it's a half note.\n       if note in ('.'|'.'):\n          return [note, 2]\n\n    return list(map(parse_music, music_string))\n\nit's an interesting concept,", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\nfalsedef parse_music(music_string: str) -> List[int]:", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    for beat_size in range(0, 4):\n        music_string = music_string.encode('ascii')\n        # if you need to use unicode, convert the string into bytes first:\n            music_string = music_string.encode('utf-8')\n         # The only difference between this function and other encode functions is that we use 'ascii' codec\n                 # instead of 'utf-8' codec\n         music_string = music_string.encode('ascii')\n        # we convert it to bytes\n        music_bytes = music_string.encode('ascii')\n        # now we can use it as a list of bytes\n        music_bytes = bytes(music_bytes)\n        # now we convert it", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    notes = []\n    beats = []\n    for note in music_string:\n        notes.append(note)\n        beats.append(beat_length(note))\n\nfrom typing import Union, Seq\n\n    def beat_length(note: str) -> int:\n    \"\"\" Given a note, return how many beats it lasts.\n    If the note is a whole note, return four.\n    If the note is a half note, return two.\n    If the note is a quater note, return one.\n    \"\"\"\n    return note == 'o'? 4 : note.lower() == 'o'? 2 : note.lower() == '.'? 1 : note.lower() == '.'? 0\n\nfrom typing import Divide\n\n    def play_beat(beats: List[int], music_string: str) -> int:\n    \"\"\" Given a list of integers and a musical string, return the number of beats between the current\n    time and the beginning of the", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    key, duration = music_string.split('|')\n    for n in range(len(key)):\n        if duration == 0:\n             key = key[1:]\n             print(\" \" + key[0])\n             else:\n              key = key[1:] + '.' + key[0]\n              print(\" \" + key[0])\n              duration = duration / 2\n    return key, duration</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    num_beats = 0\n\n    for i in range(num_beats):\n        # each beat\n        if music_string[i] == 'o' or music_string[i] == 'o|':\n           num_beats += 1\n\n    return [num_beats]</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    # Convert each note to a number\n    for i, note in enumerate(music_string):\n        note = note.lower()\n        for note_value in note:\n            if note_value in {'o': 4, 'o|': 2, ''.': 1, '.'': 0}:\n               return note_value", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"   \n    return List(int(round(notes[i] * 4) - int(notes[i] * 4)))", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    \"\"\" Left-most character is 'o'\n    \"\"\"\n    c = \"o\"\n    while c not in music_string:\n       if c == 'o':\n          return [0] + 1\n       else:\n          return [0]\n    c = next(music_string)\n\nYou can just use the list comprehension notation:", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    n = 1\n    for note in music_string:\n        if note == 'o':\n            n = n * 4\n          else:\n            n = n * 2\n    return n\n\nI'm impressed with how well this works:\n>>> parse_music(\"tum, tum, tum, tum, tum, tum, tum, tum, tum\")\n[1, 1, 1, 2, 2, 2, 2, 2, 3, 3, 4, 4]\n\nIt only works for the note values, not for the rhythms (which are even more useful).\n\nInteresting, but I think you could get the same effect by splitting it into a list of notes and a list of rests, then using Python's builtin list comprehension operator.\n\nThis is a nice example of how beautiful python is.\n\nThis is nice but I'm not sure how it is beautiful.\n\nIt is so beautiful that it is making me cry.\n\nBeautiful in the sense that it's", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string.startswith('o'):\n       return [1]\n    else:\n       return [0] + music_string.count(os.characters())\n    return [0] + music_string.count(os.characters())\n\nI did not realize that Python does not have a built-in function that is the equivalent of the C strtol function. That was the first thing I wrote. It looked like this:\nimport sys", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    return [int(chr(ord(music_string))) for ord, ord in enumerate(chr(music_string)))\n\nI'm not sure if it's just me, but I think this is the wrong way to go about this.\nI think the most sensible way to go about this is to first take your music and convert it into a list of integers. Then, if you need to parse it in some way, do it in a way that will allow you to do your entire project.\nYou don't want to spend a lot of time on a one-time solution that only gets you part of the way there.\n\nThis looks like a homework problem, and in that case you are probably allowed to use a library. If that's the case, there are a lot of libraries out there that will do this for you.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    return []", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    notes = []\n    for note in music_string:\n       if note == 'o':\n          notes.append(4)\n       if note == 'o|':\n          notes.append(2)\n       if note == '.|':\n          notes.append(1)\n    return notes</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\nr = \"o|\" + music_string\n\nr_len = len(r)\n\ncounts = []\n\nwhile r_len > 0:\n    if r[1]!= \"o\":\n        counts.append(1)\n    r_len -= 1\n    r = r_subs(r, r_len - 1)\n    r_subs = r\n    if r[0] == \"o\":\n        counts.append(2)\n    else:\n        counts.append(1)\n    return counts\n\n(based on )\n\nNot quite correct. You're reading it from the top to the bottom, so you need to read from the bottom to the top.\n\nAnd then you have to account for the (n-1) possible bars.\n\nAnd the fact that the bass clef is one \"space\" higher than the treble clef.\n\nAnd if there are sharps or flats, there are two bars.\n\nAnd the fact that there are different", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    if music_string == 'o':\n       return [4]\n    else:\n       return [1]\n\n>>> from typing import List\n>>> parse_music('o o|.| o| o|.|.|.|.| o o')\n[4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    int score = 0\n    for i in range(len(music_string)):\n       if not re.match(music_string, re.I):\n          score += 1\n       else:\n           score += 1\n    return score</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    try:\n       note = music_string[0]\n    except:\n       print \"You got a strange thing here, perhaps it's a mistake?\"\n    return []\n    while note:\n       beat_count = note + \" | \" + note + \" | \" + note + \" | \" + note + \" |\"\n       if note in ['o', 'o|']:\n          return note + \" | \" + note + \" | \" + note + \" |\"\n       else:\n          return note", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    for note in music_string:\n        if note == 'o':\n           return [4]\n        else if note in ('o|', '.'):\n            return [2, 1]\n        else:\n            return [1, 2]\n    return List(int(note))\n\nHN Guidelines:\n_Please submit the original source. If a blog post reports on something they found on another site, submit the latter._\n\nThis is the original source:\n\nI've never been a big Python user, and my exposure is limited to the Django framework, but one thing I really like about the language is that it has a very expressive, concise syntax.\n\nIt's also possible to write very verbose code in python.\n\nYes, but this code is not an example of that.\n\nThe syntax can be more concise in other languages. For example, the '|' operator can be written as '||' in C or C", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\nI think I should add that I've tried this:\n\ns = music_string.split('o o|.|.|.|.|.|.|.| o o')\n\nbut that doesn't work because I want to have the string represnting the notes I want and not the result of the split.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    note_lengths = {}\n\n    if music_string.strip()!= \"|\":\n        print(\"No, you just can't have whole note on top of each other. Please fix.\")\n    return List()\n\n    def map_notes(notes: List[int]) -> List[int]:\n        return list(map(lambda x: x, notes))\n\nThat's a python 2.x-ism.\nI remember when python 2.x came out, it was supposed to be backwards compatible with 1.x.\n\nI think this is a case of the right tool for the job.\nI use python at work for some quick and dirty scraping/data parsing/analysis, and some small scripts.\nI don't think I would use it for this, simply because the amount of times I would type \"import list\" is higher than the amount of times I would type \"import numpy\", and I'd end up spending more time typing, than I would spend finding the library.\n\npython 2.x doesn't have numpy.\n\nYes it does.\n\nSorry, I meant", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    # Read music string\n    # Note that '.' and '|' are special characters\n    music_string = music_string.lower()\n    # Split music string into two parts: beats and notes\n    beats = music_string.split('.')\n    notes = music_string.split('|')\n    # Reverse the list of beats\n    reversed_beats = [reversed(beats)]\n    # Reverse the list of notes\n    reversed_notes = [reversed(notes)]\n    # Loop over the beats, note that last beat has special meaning, it's note followed by note rest\n    for beat in reversed_beats:\n       # Note that. means note rest, so a beat like 'o|o|o|o' would be parsed as 3 notes\n       # Note that this is the first beat, so this one doesn't count\n       # We also save the note rest\n       note_rest = beat.rstrip().", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\nThat's the only correct answer. It also has the benefit of being the shortest and most easily read.\n\nYou forgot to factor in the efficiency of the code (more concise means more room for optimization)\n\nWhy factor in optimization? You wouldn't want to factor in size in a real test.\n\nYes you would. You would want to know how the code size impacts the execution time.\n\nInteresting. I've never seen such a \"what was your thought process\" question. I'd probably write my thought process on paper. But I suppose a good programmer should be able to think on paper.\n\nI guess the point of the question is to see how quickly you can work through a problem, and how well you can explain your approach.\n\nThat's a good point. I'd just like to see the test expanded to include more detail.\n\nI'd say the thought process is what you can't be sure of.\n\nI'd say it's what you can't be sure of (except for having thought it). The process part is all in the implementation of the solution.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    return list(map(lambda str: str.replace(\" '\",'\"\"), music_string))\n\nPretty good.\n\nThat's actually what I was going to type.\n\nDoes it work with python 2.7.5? It doesn't seem to for me.\n\nIt works for me. Are you sure that your python is not in some weird encoding?\n\npython 2.7.5 on linux -- even with the encoding set to UTF-8 it doesn't work.\n\nPython 2.7.5 on linux. Works here.\n\nIt works on OS X 10.6.4 too.\n\nThe more interesting question is: why use python?\n\nThis is a good question. Why not use perl or ruby?\n\nPerl would have been good too, but ruby is probably overkill.\n\nIt looks a lot like Haskell code.\n\nA programmer's version of \"How to Write Like Hemingway\".\n\nThis is really bad. I'm not sure if it was intentional, but you should never write code in such a manner.\n\nWhy not? It's terse, it's clear, and it's correct. What's not to like", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    rnd = int(input(music_string, \"ascii\"))\n\n    return [ int(chr(rnd[4] ^ rnd[2] ^ rnd[1] ^ rnd[0])) for chr in rnd[3:] ]\n\nThat's a bit silly, isn't it? The music string can be inputted from any encoding. Shouldn't it be able to handle \" any string \"?\n\nIt's not so silly when you consider that music notation is generally confined to ascii characters. I'd much rather have that type of flexibility than have to add a ton of additional rules to handle a \"general\" music string.\n\nIt's a coding contest.\n\nThen you should pick a problem more suited to your strengths.\n\nThis is just what I needed to learn Python. Thanks.\n\nYou might want to learn more about the problem domain before attempting to use python for it. The example code is somewhat broken.\n\nYou might want to learn more about the context of a programming contest before criticizing a submission.\n\nFor a good example of how to parse music in python, check out the Music.py package:", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    music_string = string.punctuation.strip()\n    for note in music_string.split('|'):\n        note_count = 0\n\n    return [note_count for note in music_string.split('o|')) if note!= 'o' else []\n\nTo make this work, we need to add a \"from typing import *\" and \"print(type(parse_music))\" at the top of your python file, and use \"parsed_music\" instead of \"parse_music\".\n\nAdditionally, I don't know how well this works for a large number of notes. I suppose you could change it to return a list of lists with the notes inside, and then pick a random note from the list.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"/s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    return List(parse_beat(music_string))\n\nThis is a great example of the power of Python's metaprogramming facilities.\n\nNow that I'm in Python-land, I'm tempted to write an \"ansible-like\" tool that uses this kind of metaprogramming to automatically generate a bunch of different kinds of PEPs.\n\nI guess I should have put a '?' after the \"great\", to indicate that I was being sarcastic. I guess I would have used \"terrible\" instead of \"great\".\n\nI'm not sure I understand. What's wrong with the above code? It's actually a pretty good example of metaprogramming.\n\nIt's not clear what \"parse_beat\" is doing or how it's being called. It's not clear what \"parse_music\" is supposed to return, and the fact that you call it with a string argument and then immediately return a list is confusing.\n\nSo how would you rewrite it?\n\nI'd rewrite it by writing a function that does what the \"parse_beat\" function does, and that returns a list of lists of integers. I'd write another function that takes an argument of", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    text = music_string.strip()\n    start_note = text.find(\"o\")\n    start_count = 0\n    end_note = text.find(\"|\")\n    end_count = 0\n    mid_note = text.find(\"o|\")\n    mid_count = start_count + end_count\n    mid_beat = int(mid_note.to_i / 2)\n    start_beat = start_note.to_i + mid_beat\n    end_beat = end_note.to_i + mid_beat\n    return [start_beat, end_beat]\n\nfrom typing import List, Ord\nfrom string import ascii\nfrom collections import defaultdict\nfrom itertools import cycle\nfrom math import floor", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    numbeats = 0\n\n    try:\n\n        number_beats = 0\n\n            while music_string:\n\n               number_beats += music_string[1:].decode('ascii').split(':')[0]\n\n               number_beats += music_string[2:].decode('ascii').split(':')[0]\n\n               number_beats += music_string[3:].decode('ascii').split(':')[0]\n\n               number_beats += music_string[4:].decode('ascii').split(':')[0]\n\n               number_beats += music_string[5:].decode('ascii').split(':')[0]", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    \"\"\" Number of beats per note.\n    \"\"\"\n    beats = 0\n\n    while music_string.isdigit():\n        beats += music_string[0]\n\n    return (beats, music_string)\n\nfrom typing import List", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    note_list = []\n\n    if music_string.startswith('o') and music_string.endswith('o|') and music_string.endswith('.'):\n        note_list.append(1)\n    else:\n        note_list.append(0)\n    return note_list", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    lines = music_string.splitlines()\n\n    print \"Parsing music string...\"\n\n    for line in lines:\n\n         if line.startswith(\"o\"):\n            return (line.split('.')[1])\n         else:\n            return 0\n\n    return []\n\nI used to have a little utility for importing things that did nothing but parse the list and print out what it parsed.\nIt makes you think really hard about the import interface you're using.\n\nIf you're interested in this kind of thing, you should check out the importlib package for Python. It implements a pretty nice DSL for specifying exactly this kind of behavior.\n\nI like this a lot. It's small, clear, and elegant. It's also a nice way to get a feel for the idioms and idiocies of the language.\n\nI like it! How do you write these? Are these just HTML pages with code in them? If so, how did you do the code in the", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string.startswith('o') == False:\n        return []\n    for i in range(1, music_string.len()):\n        if music_string.charAt(i) == 'o':\n           return i\n        else:\n            return 0\n\n    return [music_string.charAt(music_string.len() - 1), music_string.charAt(music_string.len() - 2)]</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    input_string = music_string.rstrip('\\r')\n    try:\n       if input_string.find('.') == -1:\n          return [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string == 'o':\n       return List(4)\n    if music_string == 'o|':\n       return List(2)\n    if music_string == '.':\n       return List(1)\n    elif music_string == '.':\n       return List(4)\n    elif music_string == '.':\n       return List(2)\n    else:\n       return List(1)\n\nThis is a great illustration of how to write a monad tutorial that is non-obvious without being obscure.\nIf someone were to write a library of these sort of functions and release it as a framework, I'd be really interested to see what kinds of things people would build with it.\n\nI had a quick look around for something similar, but couldn't find anything. The closest I came was this, which just generates Python code from music notation:\n\nI don't get it. Are we supposed to be impressed by this? I don", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    return sum(map(lambda x: x % 4, music_string))</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    beats = 0\n    for note in music_string:\n       beats += 1\n    return (beats, note)", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    N = len(music_string)\n\n    for i in range(N):\n        #loop over each beat\n        beat = 'o' if music_string[i] == 'o' else 'o|'\n\n        #loop over each note\n        note = music_string[i] if i == N else ''\n\n        #loop over each note, and add it to beat list if it's a half note\n        half_notes = []\n\n        for note in note_list:\n             if note == 'o' or note == 'o|':\n                  half_notes.append(beat)\n\n             if note == '.' or note == '.'|':\n                   half_notes.append(", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    return music_string[0].find(\"|\")[::-1].split('|')[1]\n\nI'm not sure how this qualifies as \"amazing.\" It's not even that good.\n\nI think it's a good idea, but it's not implemented very well. The first argument is missing, for instance, and the author never specifies that the input is a string (if the input is a list of integers, then the code will fail). Also, a beginner may find it confusing that the author uses a lambda as a function argument, but the code that uses it as such is on the next line.\nAnother way to make the same point would be:", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    return parse_musictext(music_string)\nAaaaaaand that's why you don't import types.\n\nI'm not sure what you mean. This example is correct, isn't it? It's not ideal, but it does work.\n\nI think the best way to explain my viewpoint is to compare to C#, a language that I've been using for the last five years. In C#, you don't import types, you _use_ types.\nThis is because C# is a strongly typed language, and when you _use_ a type, the type system helps you ensure that you're using it correctly.\nIf I have:\nList<int> myList;\nI know that the type of myList is _int_, and that I can use it to store _only_ integers. If I make a function that returns an _int_ type:\nint GetIntFromList(List<int> myList);\nI know that the function has to return _only_ _int_ values. If I make a function that takes an _int_ argument:\nint SubtractOneFromList(int a, List<int> myList);", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    return {i: 0, j: 0}\n    def foo(music: List[int]) -> None:\n    \"\"\"\n    Input to this function is a list of integers corresponding to how many beats does each note last.\n    Your task is to return None if the input is not valid, and otherwise print all notes on standard output.\n    \"\"\"\n    if music:\n        music = []\n        music.append(parse_music(music))\n        return music\n\nThis was in the first CS assignment in my intro to programming class. It was a much needed shock to my system.\n\nWow, this is hilarious.\n\nThe code I write on the side is the worst I've ever written. I just try things and throw them away. It's worse than the code I wrote before I learned anything about programming.\n\nI do this too! In fact, I have an entire folder of Python code that I will never use again.\nIt's actually a great way of getting rid of bad habits. I never got rid of my \"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    score = 0\n    while True:\n       score += List(int(parse_music(music_string)))\n\n    return score</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string:\n        return []\n    else:\n        return []", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\nThis is an incredibly useful function. I have a ton of midi files and I always find myself looking for a way to find out what type of note each note is. I tried writing a simple program but never got the time to finish it.\nI just did this in one line with no effort at all. Kudos.\n\nThis was posted on a mailing list I'm on last week, so I have no idea who the author is. I agree though that it's a handy function.\n\nI just learned something, and I'm surprised I haven't thought of this before.\nI have a lot of MIDI files that I want to sort by notes. That's not as easy as it sounds.\nIt's not hard, but I always end up with the wrong note, usually an octave higher or lower.\n\nThe first note is usually a sustained note, not a short note. That may be what you're missing.\n\nI use this on a daily basis. I have a habit of reusing my code and it's a nice base for all the little things you'd need to do for a text parsing/parsing framework.\n\nThis is a great example of the kind of function that shouldn't", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    return [str.find('|').split() for _ in range(4)]</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    # Don't read '|' at the end of the string\n    song = re.sub(r'\\|','', music_string)\n    beat_duration = song.find('|')\n    if beat_duration:\n        # Must be a '|', so it's the last note\n        return [].join([int(beat_duration[1]), int(beat_duration[0]), int(beat_duration[2])])\n    else:\n        # Could also be a 'o' or 'o|'\n        return [int(song[1]), int(song[0]), int(song[2])]\n\nI'd like to see a 'from turing import ai' version.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    l = 0\n    for i in music_string:\n       l += 2\n    return [l]</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string.startswith('|') and music_string.endswith('|'):\n        return []\n    # This is a special case of the input, so just return it\n    for note_string in music_string.split():\n        if note_string in ('o', 'o|', '.', '.'|'.', '.'.|'.', '.'.|'.'):\n           return note_string.count()\n   \n\nWhy not use the regular python string methods for parsing?\n\nI'm assuming this was a project for a CS course, and they probably wanted to keep it really basic.\n\nyes, it was for a programming assignment.\n\nI just made a song with this. I would've used Python instead of Haskell, but I don't know Python.\n\nThis isn't too far off from the way I have to describe my programming projects to my wife.\n\nDon't forget to import Music and Sound\n\nI'm sure this was meant to be a joke, but I", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    for char in music_string:\n       for note in char:\n          if char == 'O':\n                note += 2\n        else:\n                note += 1\n    return list(int(note))\n\nHere is a solution that does it in one line with a recursive approach (in python):", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string == '':\n        return []\n    else:\n        return [parse_beats(music_string) for parse_beats in ['o', 'o|', '.', '.', '.', '.', '.', '.', '.', '.'] if not music_string in parse_beats]\n\nThe point of the post is to show that the python type system is incomplete (you can't typecast on type constructors, and you can't statically assert that an object is of a certain type) and the article's author has found a clever way to work around it.\n\nyou can typecast on type constructors. the problem is that you can't do that in the middle of a function call. you have to pass the object as a parameter to the function in order to do that.\n\nJust to be clear, there are two different problems:\n\\- You can't do a typecast of a generic type constructor in the middle of a function call.\n\\- You can't do a typecast from an object of a generic type constructor to a specific type.", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string.find('.'):\n        return List(0)\n    else:\n        return List(0) + List(len(music_string))", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    return lambda x: len(x) == 4\n\nAnother way to solve this problem is to look at the following data structure, and then figure out how to do the list comprehension with it.", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    pos = ''\n    #get the first note\n    note = music_string[0]\n    while note!= 'o':\n        pos += 1\n    #check to see if we've hit a whole note, if so, increment the\n    #pos variable by 1\n    if note == 'o':\n        pos += 1\n    #check to see if we've hit a half note\n    if note == 'o|':\n        pos += 1\n    #check to see if we've hit a quarter note\n    if note == '.':\n        pos += 1\n    #now put the note value\n    note = int(note / 2)\n    pos += note * 4\n    #check if the note is done yet\n    if pos > len(music_string):\n        music_string[pos:pos + 2] =''\n    return pos", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\nDoesn't the answer depend on the rhythm of the music?\n\nyeah I thought that too.\n\nI got confused by the title for a second, because this is not the official Python mailing list. The official Python mailing list is at python.org.\n\nHaha I thought the same thing. I read the title and thought \"well this seems like a normal email. Why is it here?\"\n\nMaybe that's the goal of the email: to get people to go to that site!\n\nI expected a more interesting problem.\n\nYou can't parse music in Python.\n\nI did this in MATLAB in about a minute. It was pretty trivial, but this was still a cool little exercise. Thanks for sharing!\n\npython is not a functional language (it doesn't even have closures). it's a really nice language but it's not the tool for the job.\n\n\"python is not a functional language\"\nOh man, here we go. First off, Python has closures (or do you mean something else?). Secondly, why does a language have to be functional to solve this?\n\nClosures are not the same as higher order functions. The former is a misnomer, and", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    if music_string.find('.') == 0:\n        return []\n    else:\n        return []\n\nI think the better solution is to have a list of the possible beats, and then a function that given a note, returns how many beats are in that note.\nThen your parse_music function becomes a function that given a note and a length, returns the note.\n\nYeah I'd say that a list of possible beats would be a better representation.\n\nI think you can come up with a better name than \"parse_music\".\n\nThis is a valid solution. The problem is that the actual beat length for the same note can vary between different songs. It's much easier to have a list of note/beat lengths that can be adapted to different songs than to have a complex function that determines the actual beat length of a note.\n\nNo, that's not a valid solution.\nThe question asks for the _number_ of beats for a certain note. This solution returns a list. If the question had asked for the _beats_ for a certain note, then your solution would be valid.\n\n...", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    if music_string in ['o', 'o|']:\n        return [4]\n    return [0, 1]\n\nThis is pretty bad. The problem with this function is that it is _not_ giving you back a list of integers corresponding to how many beats does each note last. It's giving you back a list of integers corresponding to how many beats does each _not_ last.\nThe difference is subtle but important:\nWhen you have a list of ints, each integer corresponds to the number of times a certain symbol occurs.\nWhen you have a list of _nots_, each _not_ corresponds to the number of times a certain symbol does not occur.\nThis is a very common error. I've seen it many times, in many languages. But it's always a mistake.\n\nYou're right. I've updated the function.\n\nJust to clarify, the first version of the function was returning a list of ints. The new version is returning a list of _nots_.\n\nYeah, I've updated the function again.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    music_char = 'o' if music_string.startswith('o') else ''\n    music_chars = music_string.split()\n\n    for char in music_chars:\n        if char == 'o' or char == 'o|':\n            note = 0\n        else:\n            note = 1\n\n    if music_string.startswith('.') or music_string.startswith('-.'):\n             note = 1\n    else:\n             note = 0\n\n    return [int(note * 4)]\n\nThis is brilliant.\n\nIsn't it though? I have a feeling that the OP is going to be the next Guido van Rossum.\n\nI just don't get it. I see this is a programming language, but there is no code.\n\nThe code is in the `def parse_music", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    if music_string.startswith('O'):\n       return [1]\n    return [music_string.rfind(' '), music_string.rfind('.')]", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    note_num = 0\n    while music_string:\n        note_num = int(music_string.find('o|'))\n        if note_num == 0:\n           break\n         note_num += 1\n         music_string = music_string.strip('\n         .')\n    return List(note_num, music_string.find('o|'))", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    start = int(music_string)\n    for i in range(len(music_string)):\n        music_string = int(music_string[i])\n        if music_string[i] == 'o':\n            start += 4\n            if music_string[i] == 'o|':\n              start += 2\n             if music_string[i] == '.|':\n               start += 1\n    return [start + len(music_string) for i in range(len(music_string) if music_string[i]!= 'o' else start)]\n\nAwesome.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    # whole note\n    i = len(music_string) - 2\n    if music_string[i:i + 3] == 'o':\n       return [1]\n    else:\n       return [0]\n\nParsing would be a nightmare with a more sophisticated notation system like this.\n\nNot really, this is a very simple notation. I can imagine a more sophisticated notation which would be even easier to parse.\n\nOne of my professors told me that music notation is very simple. It is hard to read, but it is very simple.\n\nWould you say the same about programming languages?\n\nI would say that about programming languages, but I would never say that about music notation!\n\nIf this isn't a joke, it's the most bizarre example of a comment thread I've ever seen.\n\nCan you give some examples of some better examples?\n\nIt's not a joke, it's a reference to the immortal \"python vs ruby\" classic:\n\nI like how the list comprehension syntax looks like a regular expression.\n\nThere's a really nice paper on the subject of", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    beat_notes = []\n    # The first note is o, so it lasts 4 beats\n    note_lengths = [str.lower().lower() for str in music_string if 'o' in str.lower().lower()]\n    # The length of the note (duration) is the number of dots\n    # between 'o' and the next note\n    # o| is half of o, so it lasts two beats\n    # If there are no dots, it lasts 4 beats\n    note_lengths.append((str.lower().lower() for str in music_string if str.lower().lower() in note_lengths))\n    for note_length in note_lengths:\n        beat_notes.append(str.lower().lower() if note_length in note_lengths else 'o')\n\nI like the idea, but I am just not sure how well it works.</s>", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    input_string = music_string\n    while input_string:\n        note_num = input_string.split()[0]\n        if note_num == '|':\n            continue\n         else:\n              note_num += 1\n    return [note_num]", "from typing import List\n\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> parse_music('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"    with open('music.txt') as f:\n    for line in f:\n        if line.strip() == '\\n':\n           return []\n         else:\n           return parse_music(line)\n\nLet's see how many bugs are in this one:\n\\- It reads from stdin, but doesn't check if the input is a file.\n\\- It doesn't check for an empty line.\n\\- It doesn't check for the end of the file.\n\\- It doesn't check for the end of the data in the file.\n\\- It doesn't check if the data is not malformed.\n\\- It doesn't check for a single '|' line.\n\\- It doesn't check for a single '.' line.\n\\- It doesn't check for the presence of a '.' line before the first '|' line.\n\\- It doesn't check if the '.' line is before the first 'o' line.\n\\- It doesn't check if the '.' line is before the first 'o|"]]