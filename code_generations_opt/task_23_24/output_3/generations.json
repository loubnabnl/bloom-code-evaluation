[["def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str) -> None:\n    self.string = string\n    def __str__(self):\n       return self.string\nThis is an awfully long function name for something that could be called `strlen(string)`.\nYou could add a function `__str__()` but that's pretty much just telling you what the function does.\nOf course, if you have a reason for it to be long, go ahead, but it's probably best to follow the convention of keeping it short and descriptive.\n\nCoding standards are guidelines, not rules.\n\n\"Naming things is hard\"\n\nThat's true, but I have seen plenty of code that overuses abbreviations and symbols. I think this is a problem.\n\nAFAIK, all of these examples of \"bad\" python are valid python, just bad style.\n\nI like the point about using the standard library. But as for \"don't use a ton of abbreviations\", it is about the same as \"don't use a ton of symbols\".\nI prefer to use abbreviations when they are just as easy to read as", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI don't know much about this stuff, but I think this is a good way to get started.\n\nIt's a nice tutorial but it's not a real language. It's a toy with one main function and some builtin types.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    # We support str and unicode strings, and both of them are equal\n    if string is None:\n       return 0\n    elif string == '':\n       return 1\n    else:\n       return len(string)\nWhy does your return type not match your actual code?\n\nIt's not a _programming_ joke.\n\nI was hoping for a joke about how he has to search for a non-existing character in the string to return 0.\n\nThis has been my favourite joke for some time now. I would have loved to have been able to answer it at a technical interview.\n\nMy favorite programming joke:\nHow do you write a Fibonacci number in Fortran?\nIf you don't know, you should use a higher level language.\n\nNot only is it \"programming\", it's also a \"comedy\" joke.\n\nIt's a very common joke. And I don't really get it.\n\nIt's like \"How do you write a Fibonacci number in <insert any language here>?\"\nI think the joke is", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def stringify(string: str) -> string:\n    \"\"\" Return string representation of given string\n    >>> stringify('abc')\n    \"abc\"\n    \"\"\"\n\nInteresting that a strlen function is being called in the first function.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def len(string: str):\n    \"\"\" Return length of string\n    >>> len('abc')\n    3\n    \"\"\"\n    return strlen(string)\nNote: does not work on unicode strings.\n\nI'm sure you were joking, but this can work for strings of the same length in ASCII.\n\nMy implementation:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI had to look up what a strlen is.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nYou can't call `strlen` on strings containing only whitespace or comments:\n>>> import string\n>>> s = '\\x00\\x00\\x00'\n>>> s.length\n0\n>>>\n\nYou're right. I fixed it.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def gimme_length(string):\n       \"\"\" This function is called by strlen.\n       Return the length of the string\n    >>> gimme_length('abc')\n    3\n    \"\"\"\n\nI thought that the best way to determine the length of a string is to use length() from string module.\n\nNo, not when you're trying to determine the length of the string itself.\n\nIf strlen(string) returns the length of the string, then why does it need this function?\n\nThis is a bit confusing.\nThe explanation: \"This function is called by strlen.\"\nIf you want to know the length of a string, strlen() returns the length of the string.\nIf you want to know the length of the string itself, you need to subtract the length of the string's (empty) string representation.\n\nI've updated the explanation to make it clearer that this function is called by strlen.\n\nOK. So this is a function which returns the length of the string, and not the length of the string itself?\n\nIs it me, or is", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    print(\"strlen(\\\"some string\\\"):\", strlen(string))\n    def index(n: int) -> int:\n    \"\"\" Return position of index i, if it exists\n    >>> index(1)\n    0\n    >>> index(2)\n    1\n    \"\"\"\n    print(\"index(n):\", index(n))\n    def is_prime(n: int):\n    \"\"\" Return True if n is prime\n    >>> is_prime(5)\n    True\n    >>> is_prime(50000000000)\n    False\n    \"\"\"\n    if n == 1 or n == 2:\n       return True\n    return n % 2 == 0\n    print(\"is_prime(n):\", is_prime(n))\n\n>>> main()\n    print(\"length(\\\"some string\\\"):\", strlen(string))\n    print(\"index(1):\", index(1))\n    print(\"index", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __str__(self):\n    \"\"\" Return string representation of this object\n    >>> s = str('')\n    >>> s.__str__\n    str('')\n    >>> s = str('abc')\n    >>> s.__str__\n    str('abc')\n    \"\"\"\n    def __repr__(self):\n    \"\"\" Return string representation of this object as a repr\n    >>> repr(str(''))\n    str('')\n    >>> repr(str('abc'))\n    str('abc')\n    \"\"\"\n    return str(self.__class__.__name__) + str(self.__class__.__module__)\n\nNote that str('') is the same as str(), and that repr(str('')) is the same as repr(str()).\n\n__new__\nThis module is intended for use in classes that need to implement a string literal; see e.g. the examples below.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\n    def len(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> len('abc')\n    3\n    >>> len('abcdefghijklmnopqrstuvwxyz')\n    6\n    \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    #include <string>\n\nIn Python2, `strlen` is a function. It does not belong in `string.h`.\n\nIt's part of the standard library (a package).\n\nPython 2.7.13 includes `string.h` header. I guess it's a bug.\n\nAah, so it is. I wonder how long that's been there.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    if string.startswith('A'):\n       return string.count('A')\n    else:\n       return string.count('A' + 1)\nWhy is the latter better?\n\nIt's shorter.\n\nI think you got downvoted because it's not.\nstrlen('abc') is 6 characters, strlen('A') is 4.\n\nI think it was sarcasm.\n\nI think so too.\n\nI prefer using str.find('A'). The first element is always an 'A' and that's what I need to find.\n\nI prefer to write\nstr.find('A', -1)\nto get the last 'A'.\n\nThat would not work for some languages though.\n\nIn what language would it not work? It works in Python, Perl, Ruby, C, C++, JavaScript, Java, Objective-C, and other languages.\n\nI'm not sure it works in C.\n\nI think it does, but as I said above, this is better anyway because it's shorter.\n\nI like it. Any chance of an example", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __str__(self):\n    \"\"\" Return a string representation of this function.\n    >>> str(strlen('abc')).__str__\n    '3'\n    \"\"\"\n    return '<function strlen(str)>'\nThis is what I mean about the lack of style: the language does not\nprovide a short syntax for a function that returns a string. It's a\ncommon idiom to write a function that just returns a string to be\nconverted to a string representation (the one-line version in the\nexample is usually the first thing that comes to mind).\nBut instead of providing a short syntax for that, Python requires you\nto do this:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\nThis is actually a feature of Python. It's not a bug or anything.      The reason is that the return value is not an int. It is a `char` (a string of characters). So when you call it on a string like 'abc' it returns a `char`, and when you call it on ''' it returns a `char` too.\nSorry, I wasn't clear enough. It was working before, I just forgot to add the's to the end of the string.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\nYou didn't provide the type signature.\nI didn't write the article, but I'd say it's a \"str\" type for clarity and to avoid confusion.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\nThat's not how I would do it. I would use", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    length = len(string)\n    return len(string)\nIn Python this is a built-in function so it can be written as `str.length()`.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI don't see why this would be faster than the built-in function\nstr.length\n\nThe built-in functions are C extensions. In python 3 you cannot use C\nextensions.\n\nSo you're going to have to implement a str.length function in Python, right?\nIn that case you might as well use str.length.\n\nThe performance of str.length is poor.\n\n[citation needed]\n\nNot really.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    if string: isinstance(string: str, str):\n        return len(string:)\n    else:\n        return -1\n        def __len__(self):\n         return self.__len__()\n    def __eq__(self, other: str) -> bool:\n         if self.__len__(other) > 0:\n           return self.__len__(other) > 0\n          return self.__len__(other) == other.__len__(self)\n    def __str__(self):\n         return self.__str__()\n\nThe strlen() function is too long; you should refactor it into a separate function.\nThe __eq__() method is superfluous, you should just use the __len__() method.\nThe __str__() method is also unnecessary.\n\nhaha, I'll see", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\nreturn len(string)\n\nThat's not a Python answer, that's just a C answer with the type replaced.\n\nIs the problem with the answer or with the question?\n\nIt's a problem with the answer. Answering a question of one language in another language is not the spirit of the game.\n\nI am not sure what you mean. It does not have to be in Python, it is just an exercise. I thought it would be interesting to take a problem and use different languages to solve it.\n\nI think this is a good answer, but I think it'd be good if it were more pythonic and less pythonic, if that makes sense.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\n    def gzip_util(str: str, dest: str) -> str:\n    \"\"\"Gzip the given string and return it\n    >>> gzip_util('a', 'b')\n    >>> gzip_util('hello', 'world')\n    'a'\n    \"\"\"\n    def zip(strs: str, dest: str) -> str:\n    \"\"\"Zip the given strings and return them\n    >>> zip('hello', 'world')\n    'hello world'\n    \"\"\"\n\n    def is_equal(str: str, other: str) -> bool:\n    \"\"\"Return true if both strs are equal\n    >>> is_equal('ab', 'abc')\n    True\n    >>> is_equal('xyz', 'abc')\n    False\n    \"\"\"\n\n    def is_same(str: str, other: str) -> bool:\n    \"\"\"Return true if both strs are same\n    >>> is_same('ab', 'abc')", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nWhy does Python have a built in string length function?\n\nThe answer is not as obvious as it looks.\nThat string length function is for the built-in types.\nWhen you are writing your own types and want to have a length method, you use the strlen function.\n\nI actually didn't know that. I guess the obvious question is why the strlen function isn't just called len?\n\nI have no idea why it's called strlen either.\n\nIn my opinion, the less obvious question is why `len` is named as it is.\nIn C, strings are stored as arrays of characters, so the length of a string is the number of characters in it.\nIn Python, however, strings are objects, and so the length of a string is the length of the object in memory.\n\nI have a feeling that was a technical requirement, not a design choice.\nIn CPython strings are actually stored as arrays of integers. The length is the number of elements in the array, not the number of characters. This is why you can use substr to chop strings without copying them.\n\nI don't think it's a technical requirement. The type `str` is a hash table", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str):\n    \"\"\" Initialize.\n    >>> print strlen.__init__('abc')\n    0\n    \"\"\"\n    self.string = string\n    if string.startswith('A'):\n       self.string = 'a'\n    return len(self.string)\n    def eval(self, string: str) -> int:\n    \"\"\" Evaluate string.\n    >>> str = 'abc'\n    >>> print eval(str)\n    3\n    \"\"\"\n    if string.startswith('A'):\n       string = string.lower()\n    return str.lower()\nThis is horrible.\nI haven't looked at the other examples, but I can tell you this will\nnot get you hired. If you're going to interview for a programming\njob, you need to be able to answer the question: \"What is your\nfavorite language feature?\". And the correct answer is \"Generics.\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThat should be length(str), not strlen(str).\n\nGood catch, thanks.\n\nThe naming style seems to be the same as python, which is pretty good.\n\nYeah, I was thinking the same thing. I like the naming style as well.\n\n\"Note that the interpreter always returns one value for a single evaluation,\neven though the language allows multiple values. This is because the\ninterpreted language is always strict in terms of evaluation order.\"\nWhy is this? It seems like it would be a good idea to always return multiple values.\n\nI guess the idea is that your code will be easier to read when you write it out. With the multiple return style you will have to write an if to check if the list is empty before using it.\n\nYou can get the second return with a list comprehension.\n\nSo you would do a list comprehension like so:\nlists = [list(a, b, c) for a, b, c in enumerate(t)]\nThis feels like a hack to me.\n\nIt's a very convenient way to write the above. The alternative is:\nlists = [list(a, b, c) for a, b", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nWhat a god awful example...\n\nReally? I thought it was quite nice, simple, to the point, and illustrates a point quite well. What would you have used?\n\nSomething that actually has any effect.\n\nWouldn't that defeat the purpose?\n\nIt's a contrived example though. If you use something that actually has an effect, you're testing something else than the string API. I.e. \"a string with this kind of content is truncated to this length\", or \"this string is longer than this string\".\n\nI'm not following. The point of the example is that strlen is not a special case. It's not doing anything crazy. It's just a function that returns the length of a string. There's nothing to test except that it works.\n\nThe post is about the string API, and this example doesn't show it, because the string API does not affect the length of the string. That's the point of the comment.\n\nI would have used a string that is short, but not too short.\n\nI'm not sure what you mean. The string returned by strlen will be the length of the string you give it. The string given to str", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    for char in string:\n       return len(char)\n\nWhat if the string contains a few different chars, like \"abc\" and \"xabbb\"?\n\nThen it'll probably be some sort of \"int\".\n\nMore likely a \"str\".\n\nI am not sure I follow... What is the difference?\n\nint is a primitive type that cannot hold a character\nstr is a type that can hold a character and so has a length\nint(str) will be the same as int(str.chr)\n\nThat makes sense. Thanks.\n\nfor int in string:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nstrlen is an interpreter function, and I don't think it is exposed to C extensions.\nstr.__len__ will give the length of 'abc'.\n\nPython has no global interpreter lock, but that is a completely different issue.\n\nThe problem with this is that you don't have control over the extension API. If the API design is bad, you're stuck with it.\n\nWhy do I need to be able to call strlen on a string that I don't control?\n\nI don't know. You don't know either.\nYou're not the one who designed the API. If the API designer made a bad decision, it's now your problem.\n\nIt's only your problem if you can't fix it.\nIf you can't fix it, then you need to fix the API. And then you will have control over the extension API.\n\nIt's not always possible to fix the API. Sometimes it's a 3rd-party library that you cannot modify.\n\nI don't see why that should be a problem.\n\nWhat if the Python core developers decided that this was a good feature? Would you stop using Python?\n\nI'm not sure why you would ever", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\n    \"\"\"The strlen function returns the length of a string.\n    >>> strlen('xyz')\n    7\n    \"\"\"\n\n    def __init__(self):\n         self.in = []\n         self.out = []\n\n    def length(self):\n         self.in.append(self.out.pop(0))\n\n    def add(self, value: str):\n         if not value:\n             raise ValueError(\"string must be a valid string\")\n\n         self.in.append(value.encode('utf-8'))\n\n         self.in.append(str(value))\n\n         self.out.append(str(value))\n\n    def pop(self, index: int):\n         self.out.pop(index)\n\n    def", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI'd think that a good way to avoid errors and to avoid having to use \"return len(string)\" in every case would be to return a function that takes a string and returns its length.  But I don't know Python, so what do I know?\nNah. What you're thinking of would be like an `array.length` function for a string.  The \"def\" statement is just a way of creating a function. What you see there is the entirety of the function.\nSo does the `def` statement just create a function with a certain name?\nMore or less. It's more like the function is the variable, and the name is what you call the function.\nOh okay. That makes a lot more sense.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __iter__(self):\n    \"\"\"\n    Iteration over a string, yielding a tuple.\n    >>> print(strlen('abc')[0])\n    (1, 0)\n    >>> print(strlen('abc')[1])\n    (0, 3)\n    \"\"\"\n    return [str.rfind('\\0') for r in self]\n\nI don't know what python you are using, but in 3.x it's:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    if len(string) == 0:\n        return 0\n    return len(string)\nIf you\u2019re using python 2.7 or newer, that\u2019s completely useless.\n`str.__len__()` exists, and is equivalent to `len(string)`. So you only\nneed to check for `len(string) == 0`, and can get rid of the `return`\nstatement entirely.\nI think you\u2019re right, and I believe `str.__len__()` will also be\nequivalent to `str.len()` in Python 3.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nThat is a really bad way of doing things. It is hard to read and it is extremely easy to get wrong. It should be      def strlen(string: str):              return len(string)\nWon't Python not complain when you assign a string literal to a function parameter?\nYou can still set the value of a function parameter to a string, but you can't use the literal string for anything else. You can't call strlen() on it, for instance.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nOne caveat about python is that you don't need the \"::\" to access non-member methods.\nThe member function of a class is accessed by `className.functionName`, like `str`. The member functions in the global namespace are accessed by `object.functionName`, like `len`.  And the non-member functions are accessed by `functionName`.\n\nI like to use \"memberName\" for class member methods. (I used to use \"func\" but that has been mis-interpreted as meaning \"function\" and \"method\" by some)\n\nI've been doing C# for about a year and a half. I am still learning, but the one thing that has really struck me as \"wrong\" is the lack of good design patterns.\nThe language is great, but to do things right, you need to use libraries for every little thing.\nThe language itself doesn't have any kind of framework like MVC or MVP.\nI think C# is a great language, but it just doesn't have the kind of abstractions that I'm used to having in a language like Ruby or Python.\n\n>The language itself doesn't have any kind of framework like MVC or MVP.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return string.length", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def strlen_safe(string: str):\n    \"\"\" Safe version of strlen that throws on string overflow\n    >>> strlen('abc')\n    Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    TypeError: can't convert'str' to str\n    >>> from typing import strlen_safe\n    >>> strlen_safe('')\n    Traceback (most recent call last):\n    File \"<stdin>\", line 1, in <module>\n    TypeError: can't convert'str' to str\n    >>> strlen('abc')\n    3\n    \"\"\"\n    return len(string)\n\na constant-time comparison is not important for that type of application.\n\nIt's important if you ever, e.g., want to perform a search on a sorted list of strings.\n\nI'd much rather do a search on a list of strings sorted by length than by comparing their length.\n\nThat's not a fair comparison. The string's", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nWith Python 3.0, you can use _len instead.\n\nGood point. I'll go edit the post.\n\nstr.join('\\n')</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI don't like this because it's not clear that this is the right definition.  Python, Ruby, and Lua all implement strlen differently.  This is a shame, because a lot of C programmers will pick up a Python book and not realize that it's not a superset of C.\n> This is a shame, because a lot of C programmers will pick up a Python book and not realize that it's not a superset of C.  This is a shame, because a lot of Python programmers will pick up a C book and not realize that they need to have a plan for memory management.\n> they need to have a plan for memory management.\n\n That is exactly what the string module is.  It is a plan for memory management for strings.   It is a plan for using strings in C.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI don't understand the motivation here. I just copied the Python 2.7\nimplementation, line for line, except for the % operator and the extra\nwhitespace.\nDoes anybody have any reason to think this is a bad idea?\n\nI don't know about a bad idea, but it is kind of ugly. I haven't had the\nchance to look at python 3 in detail yet, but I suspect this is a\nminor issue compared to the other changes that needed to be made.\n\nI'm not sure why it's ugly. The reason for the % operator is to distinguish\nit from string.length, which is a function, and not a method.\n\nJust for fun, I modified the Python 3.0 implementation to work as follows:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n        return len(string)\nIn python, the str string type is immutable, so `len(string)` will always be the length of the string.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\n>>> import functools\n>>> f = lambda: strlen(string)\n>>> print(f(''))\n>>> print(f('abc'))\n\n>>> print(f(''))\n>>> print(f('abc'))\n\n\"abc\"\n3\n\n''\n0\n\n>>>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\n    pass\nfor i in range(0, len(string)):\n    return str[i]\nI know you were joking, but I had a fun little project once where I wrote a validator that would tell me if a function passed the code review filter (basically, whitespace, comments, and length).   I could have used this!</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return string.length\nYou can do better than that, can't you?", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI'm not sure the author really understands the difference between static and global scope in Python.\n\nThis is a joke, right?\n\nIt would appear to be a joke in the context of what the author of the article is complaining about in other languages.\nAs a Python dev, this was the only part of the article that made me cringe.\n\nThe joke was to show how Python doesn't do the things the author complains about.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    i = 0\n    while i < len(string):\n        i += 1\n    return i\n\nDoes the `return` really need to be there?\n\nYes, because the function is returning an integer, which needs to be returned from the function.\n\nI thought it would be the other way around.\nI thought the function is returning nothing. The `return` is optional and if it is there, it returns the integer value. If the `return` is not there, the function just runs its body and returns nothing.\n\nThe return is not optional. The return value is not optional. The return statement is not optional.\n\nOh, ok. I didn't know it. Thanks.\n\nThis is the equivalent of having a list called `references` and a method called `list_size` that returns the size of the list. The list would have an instance method called `references_size` that does the same thing.\nThere is nothing wrong with this, and this is a common way to organize things in python.\nI really like the article. It's a nice reminder that just because something is simple doesn't mean", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nBut that is a good question. I think the answer is that the length is a variable for a string and the string is a variable for a string. So there is no special case for a string when you are using a string as a variable.\n\n\"abc\" is an integer in the same way as \"14\" is, or \"foobar\" is. That is, the value of \"abc\" is an integer, and it is equal to 3. It's not special; if you change the type to float, it's still equal to 3. You can't say that 14 is a float because you happen to be holding it in a float variable, but \"abc\" is an integer because you're holding it in an integer variable.\n\nIf you want to say that \"abc\" is a string, you need to use a different type. For example, you could use a list:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\n    def __str__(self):\n    \"\"\" Return the string form of this value\n    >>> str(chr)\n    chr\n    >>> str(str)\n    str\n    >>> str(str.replace('abc', 'abc', 'x'))\n    str\n    \"\"\"\n    return self.str\n\nThis is the most common usage in the documentation.\nI think that was the whole point of the article, actually.\n\nDuh. I was thinking about this in terms of different types of objects. I didn't even stop to think that this was a string.\nI need to go to sleep...\n\nIt looks like it's actually a class.\n\nPython is a class-based language, so that's expected.\n\nYes, but it looks like a class that doesn't have any __init__ method.\n\nI see what you're saying. It's actually a class that has a single method. It's a class-method (which I hadn't known about before).\n\nIt would be interesting to see how many people actually follow this for their own code.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\n\n I call shenanigans.\nI agree.  If this is the case, I'd rather see      strlen(string)      return len(string)      which can be used with a normal string of any length.  But that probably doesn't have the same \"symmetry\" that the author was after.\nYeah, that would be a bit more natural. This is just mind boggling.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __str__(self):\n    return string.__str__()\n\nSo, you've got the function strlen which is really useful, but you also want a function which takes a string and returns its length.  What you could do is create a new function that calls strlen and returns its length.  What you're doing here is just taking the function strlen, and changing it so that it returns something other than an int, but it's still basically the same thing, just wrapped in a different function.  So, you could just do that, but you're not doing anything useful for yourself.  You could also create a new function, strlen2, which takes a string and returns its length, but it does not call strlen.  This would let you do things like:\n\n      strlen2('abc')\n           # 3\n           strlen2('abcdef')\n           # 5\n\nThis lets you do some new things, but now you have a new function, strlen2, which is pretty much just", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nDoes this work for unicode strings? I mean does strlen expect only ASCII?\nAlso, it's quite long for a function that does just that. Why not just      return strlen(string)\nYes, it does work for unicode strings. I didn't write it, I just copy-pasted it from a tutorial. I guess I'll just delete it when I have time.\n> I guess I'll just delete it when I have time.  That is probably for the best.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThat's the case in python 2.x, but in python 3.x it's different:\n>>> strlen('abc')\n3\n\nI only skimmed the article, but this caught my attention:\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'\n>>> print 'abc'", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return str.count(' ')\nFor those who are curious, the code will work, but will be a little slow. A string's length is stored in a `char` (a character) so to get the length of a string, you need to loop through every character and add them all together.\n\nIt will be slow and you won't get a perfect result: the length of 'abc' can be 3, 5, or 7 characters depending on how it is encoded.\n\nIt's 3 bytes, so it's always exactly 3 characters.\n\nIn case you don't know: UTF8 is not the only encoding used on the web.\n\nYeah, I was trying to be as general as possible. I'll try to amend my post, but I don't want to mislead people into believing that UTF8 is the only encoding on the web.\n\nIt's not just web, UTF8 is not supported by Windows and Mac OS X. I'm a bit puzzled why it is so widely used for data interchange. The only reason I can think of is that it's simple to implement in software.\n\nDon't forget that UTF-8 is a subset of ASCII, so it's a superset", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI've always wondered: why is `'abc'` 3 bytes, and `'abc'` 1?\n\nBecause the ASCII code is 0x41, which is 3 characters wide. The terminal only sends one byte, but the length is returned as a number of bytes.\n\nThis is somewhat similar to what I do to make a one-liner for my.bash_profile\nfunction f() {\necho $@\n}\n\nAh, good old strlen.\nNow, let's try to make it even shorter:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\n>>> print strlen('abc')\n\n3\n\n>>> print strlen('abcdefghijklmnopqrstuvwxyz')\n\n9\n\n>>>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    \"\"\"\n    def return_nothing(return_value: int):\n    \"\"\" Return nothing\n    >>> return_nothing()\n    0\n    >>> return_nothing('abc')\n    0\n    \"\"\"\n    \"\"\"\n    def return_empty_string(return_value: int, empty_string: str):\n    \"\"\" Return empty string\n    >>> return_empty_string('abc')\n    ''\n    >>> return_empty_string('abc')\n    ''\n    \"\"\"\n    \"\"\"\n    def return_empty_string(return_value: int, empty_string: str, empty_string_offset: int):\n    \"\"\" Return empty string, with the first byte of the string set to '\\0'\n    >>> return_empty_string('abc', 0)\n    '\\0abc'\n    >>> return_empty_string('abc', 1)\n    '\\0abc'\n    >>> return", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\nThis would fail as written if the string is empty.  It should probably be written as:      def strlen(str: str):\n\nThanks for the catch!\n\nThe code looks good, but I think the explanatory comments are a bit of a cop- out. Maybe its just me, but I don't think I would have much interest in learning how to use your library if I had to read some comments to figure out how it works.\n\nNot really a cop out, I think it's good practice to write comments when you are documenting your code.\n\nI agree, it's good to comment your code. I just think its poor practice to use comments to explain your algorithm.\n\nTo me it seems that you are saying \"when I have to look up an algorithm, I don't want to have to look at comments to figure it out.\" I think that's a fine stance, and for the most part I tend to agree. But I also think that it is perfectly appropriate to use comments to explain the algorithm when a) the algorithm is not immediately obvious and b) the code is being released to a public forum.\nThis is especially true when you are releasing a library, where the people who", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nIn Python, this is:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def is_empty(string: str) -> bool:\n    \"\"\" Return True if the given string is empty\n    >>> is_empty('abc')\n    True\n    >>> is_empty('a')\n    False\n    \"\"\"\n    \"\"\"\n    def print_number(number: int):\n    \"\"\" Print given integer as string\n    >>> print_number(6)\n    \"6\"\n    >>> print_number(42)\n    \"42\"\n    >>> print_number(0)\n    \"0\"\n    \"\"\"\n    \"\"\"\n    def print_str(string: str) -> str:\n    \"\"\" Print given string as string\n    >>> print_str('abc')\n    \"abc\"\n    >>> print_str('abcabc')\n    \"abcabc\"\n    \"\"\"\n    \"\"\"\n    def get_number(number: int) -> str:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nWhen the article was written, the correct name was probably _strchr_.\n\nor perhaps _strtol_, but it depends on the definition of length.\n\n_strtol_ is used for the _longest_ sequence of bits in a string. It is\nnot relevant here.\n\nstrtol(string, bit_length)\n\nYou're right. I'd gotten so used to people using it to check if a string was a palindrome I forgot its real purpose.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI'd like to see a version of this that uses `len(x)` if `x` is a string.  That is, `len(str)` if `str` is a string, and `len(x)` if `x` is an integer, regardless of whether `x` happens to look like a string.\nWhy would it be returning the length of the string if you don't provide a string?\nStrings can be lists too. But I'd go with the option of returning an error, because it's not obvious what it should return.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\nThis is the one I've seen far too often.\nI've seen it done like this by people who have no idea what a string is:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def str_to_int(str):\n    \"\"\" Convert string to an int.\n    >>> str_to_int('a')\n    1\n    >>> str_to_int('b')\n    0\n    >>> str_to_int('c')\n    3\n    \"\"\"\n    return int(str_to_int(str))\nI've never written Python, but this looks pretty much how I'd write it.  What's the Pythonic way?</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nreturn 0\n\nreturn 1\n\nAnd with an empty string:\n>>>\n>>> a = ''.join('a', 'b')\n>>>\n>>> print(str(a))\n'. '.join('a', 'b')\n>>>\n>>> print(strlen(a))\n0\n>>>\n>>> print(str(a).strip())\n'. '\n>>>\n>>> print(strlen(a).strip())\n1\n>>>\n>>> print(str(a).join(' '))\n'. '.join('a', 'b')\n>>>\n>>> print(strlen(a).join(' '))\n2\n>>>\n>>> print(str(a).join(' '))\n'. '.join('a', 'b')\n>>>\n>>> print(strlen(a).join(' '))\n3\n>>>\n>>> a = ''.join('', 'c')\n>>>\n>>> print(str(a))\n'. '.join('', 'c')\n>>>\n>>> print(strlen(a))\n0\n>>>\n>>> print(str(a).strip())\n'. '\n>>>\n>>> print(strlen(a).strip())\n1\n>>>\n>>>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nOh no. Don't use int. It has a default size, so you don't actually know how long your strings are! Use bytes.length.\n\nThere are no absolutes. I would tend to agree that bytes.length is more universal, but that would only be true if the language was always compiled on a platform that supported bytes. Otherwise, there's no guarantee that you'll have the same byte count on all platforms. For that reason, I'd lean toward using int.\nThe only real problem with this approach is that int returns a value that's only guaranteed to be 64-bit. If the language is compiled on a platform that supports long, that would be a better choice (assuming you don't need to support the PDP-11).\n\nTrue, but if the language is compiled on a platform that doesn't support long, it's still probably a safe bet that it supports some kind of unsigned type.\n\nOr if it doesn't, it's probably a safe bet that the input data is short enough that it won't be a problem.\n\nWhy not use unicode instead of string?\n\nBecause you still have to know how to convert from unicode to bytes.\n\nI'm not", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    result = 0\n    result = result + str.length\n    result = result / str.length\n    result = result / (str.length - 1)\n    return result\n\nI don't know why you're getting downvoted. The guy asked for a solution, and you provided a valid one.\nBecause it's not exactly the best solution.  It is equivalent to the one I posted, but strlen is O(n), while mine is O(1).</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    # http://docs.python.org/2.5/library/string.html#strlen\n\n    def if_not_found(c, key: str) -> str:\n    \"\"\" Return string for key if it exists, otherwise an empty string.\n    >>> if_not_found('bob')\n    'bob'\n    >>> if_not_found('bob', '')\n    'bob'\n    >>> if_not_found('bob', '')\n    'bob'\n    \"\"\"\n    c.upper() + '.' + key\n    if c:\n       return c\n    else:\n       return ''\n\nAnd I'm pretty sure that \"bob\" would be the first thing in the dictionary...\n\nI'm not sure I understand the point you're making. In any case, that's a string, and Python will sort it by Unicode code point and return \"b\" as the first element, not \"bob\".\n\nmy point is that", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThis one is the best yet!</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __len__(self):\n    return strlen(self)\nAnd now you can pass a string argument to it without having to use the funky'self' keyword.\n\nIn Python3, that's called \"normalizing\" (and it's also the default).\n\nIf the difference between __len__ and strlen is the fact that the former doesn't change the length of the argument string, then it's not really \"normalizing\" it, since the argument is already normalized.\n\nYou can use the == operator to check equality of two strings.\n'a' == 'a'\nBut not for two unicode strings.\nstr(16) == unicode('a')\nThe reason for that is that the unicode is not actually the same as a 16-bit string. Unicode has different encodings and is more general. You can't simply compare two unicode strings.\n\nI'm confused by this. As I understand it, str(16) == unicode('a') is true, because both strings are Unicode strings, and Unicode strings are ordered (according to UTS #15).\nAre you referring to the fact that the UTF-8 encoding of", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\n>>> 'abc'.strlen()\n3\n\nThis has always been my problem with strlen. It was always hard to remember how to call it with and without quotes and what to put at the end. I never really got it.\nI've found these two shortcuts to be very helpful.\n>>> 'abc'.length\n3\n>>> 'abc'[:-2].length\n3\n\n>>> 'abc'.padleft(3)\n'abc'.padleft(3)\n>>> 'abc' + ''.padleft(3)\n'abc'.padleft(3)\n\n>>> 'abc'.lower()\n'abc'.lower()\n>>> 'abc'.upper()\n'abc'.upper()\n>>> 'abc'.encode('ascii')\n'abc'.encode('ascii')\n>>> 'abc' + ''.encode('ascii')\n'abc'.encode('ascii')\n\n>>> 'abc'.join('', sep=' ')\n'abc'.join('', sep=' ')\n>>> 'abc'[:6].join('', sep=' ')\n'abc'.join('', sep=' ')\n\n>>> '", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def remove_empty_elements(string: str):\n    \"\"\" Remove empty strings from given string\n    >>> str = ''\n    >>> str = remove_empty_elements(str)\n    >>> str == ''\n    True\n    >>> str == 'abc'\n    True\n    >>> str == 'abc'\n    False\n    >>> str == ''\n    True\n    >>> str == ''\n    False\n    \"\"\"\n    return remove_empty_elements(string)\n\nI was pretty surprised to see this, and was curious about the meaning of the various code samples. I suppose it's possible to come up with a function strlen that returns the length of a string with leading and trailing empty elements, but that's still kind of odd for a built-in function.\n\nMy guess is that this is a typo of sorts, that they were testing the functionality of the code by running it on ''''.\n\nOr maybe it's a bug that allows you to remove empty elements.\n\nI've been looking at the Python", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nWTF. If I were to actually do this, I would do it like this:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    #", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nC# doesn't have `strlen`, so that's a good thing. And there is no `str` type in C#; you use `String` instead.\n\nstrlen is equivalent to the String.length function.\n\nThose who speak the truth are at times downvoted.\n\nI've been downvoted so many times for sharing the truth. It's just one of the reasons that I don't comment as much anymore.\n\nInteresting, what's the benefit of using a non-string?\n\nIt's a bit like the difference between the Array type in Java and the ArrayList class.\n\nI've never used the ArrayList in Java, what's the difference?\n\nArrayList has a lot of methods that are really useful for working with arrays (add(element, index), delete(element), sorted(array)) that you don't get with Array.\n\nYou can use an ArrayList inside an array too, which is where you might get most use out of it (i.e. when you need to iterate over a set of arrays).\n\nI think it is better to not have built in String class, because if you want to use the String class for", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    \"\"\"This is a really bad idea. The string \"abc\" could have a null terminator, a newline, or a tab, so the length of the string is not correct.\n\"\"\"\n\nIf you're going to be pedantic about it, you might want to write:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    if __name__ == '__main__':\n    \"\"\" This module demonstrates the difference between using the `str.__len__()` method and using `str.strlen()`. \"\"\"\n    \"\"\"\n    print('String 1:', 'hello')\n    print('String 2:', str.__len__())\n    print('String 3:', str.strlen())\n    \"\"\"\n    print('String 1:', 'hello')\n    print('String 2:', str.__len__())\n    print('String 3:', str.strlen())\n\nHere's the output:\nString 1: hello\nString 2: 8\nString 3: 6\nYou can see that `str.__len__()` returns the number of bytes in the string while `str.strlen()` returns the number of characters.\n\nIf you want to get the length of the string you can use string.len(), if you want to get the character count you can use str.chars().\n\nThe reason why is that the Python interpreter has an internal string object with an internal length and", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI get what you're trying to do, but the problem is that '''' is not a string, it's a string constant. So a better definition of that function would be:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def factorial(n: int) -> int:\n    \"\"\" Return factorial of n\n    >>> factorial(2)\n    3\n    >>> factorial(3)\n    36\n    \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\n    def charAt(i: int, n: int): int:\n    \"\"\" Return position of char at given index\n    >>> i = 0\n    >>> charAt(i, 1)\n    0\n    >>> charAt(i, 2)\n    1\n    >>> charAt(i, 3)\n    2\n    >>> charAt(i, 4)\n    3\n    >>> charAt(i, 5)\n    4\n    \"\"\"\n    return i\n    def print_hex(string: str, n: int):\n    \"\"\" Output a hex representation of the string\n    >>> print_hex('abc')\n    '\\x02'\n    >>> print_hex('a')\n    '\\x01'\n    >>> print_hex('c')\n    '\\x80'\n    \"\"\"\n    return string.rstrip()\n   .rstrip('", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def str_replace(string: str, replacement: str) -> str:\n    \"\"\" Replace a given string in a string with another one\n    >>> \"Hello\" == \"Hello\"\n    True\n    >>> \"Hello\" == \"Hello\" + \"world\"\n    False\n    >>> \"Hello\" == \"Hello\" + \"world\" + \"!\n    False\n    >>> str_replace('Hello', 'World', '!');\n    'Hello!World!'\n    \"\"\"\n    def first_non_blank(string: str) -> bool:\n    \"\"\" Return true if string starts with non-blank character\n    >>> 'Hello' == 'Hello'\n    False\n    >>> first_non_blank('')\n    True\n    >>> first_non_blank('Hello')\n    True\n    >>> first_non_blank('Hello!');\n    True\n    >>> first_non_blank('h!');\n    False", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def format(string: str, length: int):\n    \"\"\" Format and return a string from given string and optional length\n    >>> 'abc' + format(str, 3)\n    'abc' + 3\n    \"\"\"\n    return string + \", \" + str(length)\n    def __str__(self):\n    \"\"\" Return string representation of this class\n    >>> print(__str__(str))\n    'abc'\n    \"\"\"\n    return ''.join([str(i) for i in range(len(self.string)))])\n\nTranslation:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nString.length() is the Pythonic way of writing this function. strlen() is a function from the C language and is not part of the Python standard library. The use of strlen() means that the code has to be compatible with C.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nWhat's the benefit of this over string.length()?\nIt's syntactic sugar for an extremely common function.\nIt's syntactic sugar for an extremely common function that is *absolutely trivial* to implement.\nI don't think it's trivial to implement.\nYes it is, the benefit is the ability to type the string.length() and not have to define a class with a string member.\nAh, I see what you mean.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI wish I could upvote you more.  EDIT: I'm not trying to be mean, I just think it's a great point.\n\n>def x(a: int):\n>    \"\"\" Return a\n    >>> x(1)\n>    1\n>    >>> x(2)\n>    2\n>    >>> x(3)\n>    Traceback (most recent call last):\n>    File \"<stdin>\", line 1, in <module>\n>    x(3)\n>    File \"/usr/lib/python2.7/site-packages/module/__init__.py\", line 11, in <module>\n>    x.__call__(self, a)\n>    AttributeError:'module' object has no attribute '__call__'\n\nWait, what? I wrote that like three days ago.\n\nWhy?\n\nI think it's a very good example of why you don't just blindly copy paste stuff from the Internet, since it's broken in a very basic way.\n\nAlso", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def maketrans(c: char, count: int):\n    \"\"\" Return a character with count times its ASCII value.\n    >>> maketrans('c', 2)\n    'c'\n    >>> maketrans('c', 4)\n    'C'\n    \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\n    def concat(string: str, string2: str):\n    \"\"\" Concatenate two strings\n    >>> str1 = \"abcdef\"\n    >>> str2 = \"defgh\"\n    >>> str1+str2\n    \"abcdefgh\"\n    \"\"\"\n    def join(string: str, delimiter: str) -> str:\n    \"\"\" Join two strings using `delimiter` as a separator.\n    >>> str1 = \"abc\"\n    >>> str2 = \"def\"\n    >>> join(str1, \", \")\n    \"abcdef\"\n    \"\"\"\n\n    def strip(string: str) -> str:\n    \"\"\" Remove all white space from given string\n    >>> s = \"xyzzy\"\n    >>> s.strip()\n    \"xyzzy\"\n    \"\"\"\n\n    def transpose(list: List[str]) -> List[str]:\n    \"\"\" Transpose the elements of `list`.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __len__(self):\n    \"\"\" Return the length of this string.\n    >>> type(strlen(''))\n    str\n    >>> type(strlen(''))\n    <class'str'>\n    >>> type(strlen(''))\n    <class'str'>\n    >>> type(strlen('abc'))\n    <class'str'>\n    >>> type(strlen('abc'))\n    <class 'int'>\n    \"\"\"\n\nI'm not sure what to think of this. On one hand, it's always nice to see more tools in a language, especially in Python where the tooling is great. On the other hand, this function is super easy to write on your own.\n\nThe issue is that'string' and'str' are objects that can be of different types.\n\nYes. It's fine to add that to the docs of \"strlen\" (the built-in function), but I think that it's a bad idea to add a new built-in function that does the same thing.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def _strlen(string: str) -> int:\n    \"\"\" Return length of string\n    >>> _strlen('abc')\n    3\n    \"\"\"\n    return int(str.find(\",\") - 1)\nI was unaware of this. I was always just passing in the string as a string to the int function.\n\nI've been using the str.find(\",\") trick for years, and had no idea it had such an obvious pythonic analog.\n\nWhat is the benefit of doing this vs using a string builder?\n\nIt's a lot less code and you can easily make the function an inline function.\nString.find(\",\") is also just another string method like append, substr, etc.\n\nHow often do you have to call it?\nIt might be less code, but it's also less readable code. I'd rather have a little more code and have it be more readable.\n\nIf you don't use the function in other places, what does it matter?\n\nIn the case of strlen, if you want to call it elsewhere, you have to do strlen(s). I prefer", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThe title was an oversimplification. I really meant to say _This one line is a very small and simple example of Python's syntax and the style of thinking that Python is trying to teach us_.\nFor one thing, if the string contains a newline, strlen() will count that newline in the length of the string.\n\nIn Python 3 str.rstrip() removes the newline, and str.rstrip() is not a function.\n\nThe example is still correct and illustrates the point the OP was making.\n\nIn Python 2, it's not:\n>>> ''.join(s)\n'\\n'.join(s)\n\nAs a python novice, I did not know that. That's cool.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nYour code is broken in Python 2.x. strlen will fail on an empty string, and it won't be zero.\n\nI think the idea is that in Python 2.x (or even 3.x?), strlen is just a string, not a function, so it should return the length of the string \"strlen\", which is zero.\nEdit: Yeah, the snippet doesn't work.\n\nThis is a classic. There are a lot of comments to read through.\n\nI can't believe this is at the top of the front page. Is this really what HN is about?\n\nThe quality of HN has been going down since Google bought them.\n\nWhat? That's nonsense.\n\nI remember finding some very insightful articles here before, now it's mostly about programming, which is fine, but I used to get some very interesting insights on everything else. Now it seems to be more like Reddit.\n\nI don't want to be rude, but this is ridiculous.\n\nIt's always useful to remember how to do something you don't do much.\n\nIt's also useful to remember the reasons why something is done a certain way. For example, why strlen has", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nIsn't that a little like the following?", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\n    def next_char(char: char):\n    \"\"\" Return the next character of str.\n    >>> next_char('abc')\n    b\n    >>> next_char('abcdef')\n    b\n    >>> next_char('abcdefgh')\n    e\n    \"\"\"\n\n    return next_char(str[str.length - 1])\n\n    return 0\n\nThis was upvoted four times. HN is a bit strange today.\n\nIt's not about the code itself, it's about the core concept.\nIt's about the understanding that programming is not about writing code, but about finding simple solutions to simple problems.\n\nAnd that if you find yourself in a complicated situation it is very likely that you're solving a problem you don't really understand.\n\nI would have written it this way.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    if len(string):\n       return string.length\n    return 0\nAnd now you have a new problem.  You forgot the semicolons.  They're always important.\nI agree, it's a good point.  I think the reason that this isn't a problem in Python is that the interpreter is really smart, and will pick up where you left off.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    if string == '':\n       return 0\n    else:\n       return string.length\n> I thought it was common knowledge that the > standard library was riddled with these sorts of things?</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\n    # <Tuple2 instance at 0x105988ec0>\n\n    def __init__(self, count=0):\n\n        self.count = count\n\n        if __name__ == \"__main__\":\n\n            str = \"abcdefghijklmnopqrstuvwxyz\"\n\n            for i in range(0, len(str) - 1):\n                 print str[i:i + self.count]\n\n               return self.count", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __repr__(self):\n    \"\"\" Return a string representation of this object\n    >>> type(__repr__(strlen))\n    str\n    >>> repr(__repr__(strlen))\n    '%r'\n    >>> type(strlen)\n    str\n    >>> type(str)\n    str\n    >>> type(__repr__(str))\n    str\n    >>> type(str)\n    str\n    >>> type(__repr__(''))\n    str\n    >>> type(__repr__(''))\n    str\n    >>> type(str)\n    str\n    >>> type(__repr__('abc'))\n    str\n    >>> type(__repr__('abc'))\n    str\n    >>> type(str)\n    str\n    \"\"\"\n    return str(self) + str(0)\nYou", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def __init__(self, s: str) -> None:\n        self.s = s\n        self.size = 0\n    \"\"\"\n    return 0\n\nNote how he's using namedtuples to save on typing.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\n    def strcmp(string: str, string2: str) -> int:\n    \"\"\" Return the smallest of the two strings.\n    >>> strcmp('abc', 'def')\n    0\n    >>> strcmp('abc', 'ghi')\n    2\n    \"\"\"\n\n    return 0\n\n    # The next function was a surprise for me. The other answers I have\n    # seen do not compare strings but bytes.\n    def bytes_str(string: str):\n    \"\"\" Convert a string to a byte array.\n    >>> bytes_str('abc')\n    '\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09'\n    >>> bytes_str('abc')\n    '\\x01\\x02\\x03\\x04\\x05'\n    \"\"\"\n    if string == '\\x01\\x02\\x03\\x04\\x05\\x06\\x07\\x08\\x09':", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI think it should be len(str) instead.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\n\n Not sure if that's what you're looking for.\nI like the extra coder check, but you should use the length function from the built in string library instead.  >>> len('abc') 3\nThanks for the tip. I never use the built-in library so I don't know all of the functions.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nYou could also use len()</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI'm not too familiar with Python, but I'm a bit confused on how the string 'abc' is 3 bytes long.  Is that the length of the string literal, or the length of the string representation as a string object?  In the latter case, what is the string representation of 'abc'?</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI don't get it. Why would you even bother?\n\nThe context was why Python is using str instead of str_ and why they aren't using ctype. In my opinion they should just use ctype since it will make the code more readable, I don't see any benefit of using str at all.\n\nI'm not sure I understand what the context is. Do you have a link to that discussion?\n\nHere is the post .</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    if len(string) == 0:\n        return 0\n    return len(string)\n...You didn't change the name in the output.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n> def strlen(s: str) -> int:\n> \"\"\" Return length of given string\n> >>> strlen(\"abc\")\n> 3\n> \"\"\"\n>> def count_if_in_list(list: list[int]) -> int:\n> \"\"\" Return 1 if list[i] is in list\n> >>> list = [1, 2, 3]\n> >>> count_if_in_list(list)\n> 1\n> >>> list = [1, 2, 3, 4]\n> >>> count_if_in_list(list)\n> 0\n> \"\"\"\n> count_if_in_list(list)\n>\n> count_if_in_list(list)\n> 0\n>\nThis looks like a bug.\n\nThanks. It is fixed now.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nstrlen is a function that is defined in the C standard library,\nspecifically the C99 standard, which is why the example is in C99\nsyntax rather than Python syntax.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    # Maximum value of the string\n    if '\\0' in string:\n       return string.size()\n    else:\n       return string.find('\\0')\n    def __str__(self):\n    \"\"\"Return string representation of this object.\"\"\"\n    return self.__class__.__name__\n\nI'm not sure I get it, but wouldn't this just end up looping over the string in a futile search for the \\0?\n\nNo, because '\\0' is the first character of the string.\n\nI wouldn't even say that. I'd say that's a bug in Python.\n\nIt's a bit of an oddity of the language, but it's hardly a bug. There are a lot of people who prefer to have a special character at the end of their string to signify its end, and there are a lot of times when you _want_ that special character to be the last thing in a string, regardless of its position in the source text.\nIt's like the Java file.exists() vs. file.exists(", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    if string[0] == '\\0':\n       return 0\n    else:\n       return string.length()\nI've always wondered why `strlen('')` returns 0 and `strlen('abc')` returns 3.\n\n`strlen('')` returns 0 because it's the length of the string ''. The length of a string is always greater than or equal to 0, and `strlen('')` can't return a negative value.\n`strlen('abc')` returns 3 because it's the length of the string \"abc\". The length of a string is not always greater than or equal to its value.\n\nI understand why it returns 0 for \"\" and why it returns 3 for \"abc\", but I still wonder why it returns 0 for \"abc\" while it returns 3 for \"abc\".\n\nIt's a little strange that you would consider it strange that 'abc' has a length of 3, and 'ab' has a length of 4. A string is a sequence of characters, and some characters can appear more than once, which means that the length of a string is never just the number", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\ni know, i'll use the sizeof operator!", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return int(string.length)\nThis isn't a bad exercise, but there are far more concise ways to write this.\nI'd argue that it's a bit confusing to use \"int\" instead of \"int(string.length)\"\nfor the return value.\nBut yeah, that's a nice exercise.  It makes you think about the costs of such things.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\n    \"\"\"\n    def to_int(value: str) -> int:\n    \"\"\" Return int representation of given string\n    >>> to_int('abc')\n    3\n    >>> to_int('abcdefghijklmnopqrstuvwxyz')\n    5\n    \"\"\"\n    \"\"\"\n    def dec(s: str) -> str:\n    \"\"\" Decode a string to lowercase\n    >>> dec('abc')\n    'abc'\n    >>> dec('ABC')\n    'abc'\n    \"\"\"\n    \"\"\"\n    def reverse(s: str) -> str:\n    \"\"\" Reverse the string\n    >>> reverse('abc')\n    'bc'\n    >>> reverse('abcdefghijklmnopqrstuvwxyz')\n    'zdefghijklmnopqrstuvwxyz'\n    \"\"\"\n    \"\"\"\n    def to_lower(value:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string.decode('ascii'))\nI think the first question I would ask is why is string.decode('ascii') returning a string?  The second question I would ask is why are you using an ASCII string for a unit test?  What does it test for?  Do you use ASCII strings in your code?  I think I would be more interested in a test for the content of the string than the length of the string.\nI think the point of the exercise is to see the length of a string that has been encoded.  Otherwise you could write a test that returns a string that has a different length.       string = \"b\\0c\\0d\\0a\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l\\0l", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nWhat if the string is empty?  What if the string is null?\nIt says it returns the length of the string, so it's fine for an empty string and it's fine for a null string.\nDon't you think it's strange that it returns 0 for the empty string?</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n   \n    \"\"\"\n    class str:\n       \"\"\"\n            A string\n             \"\"\"\n         def __init__(self, chr1, chr2, chr3):\n              \"\"\"\n               Define character-count in char-str to be\n                number of characters in this string.\n               \"\"\"\n              self.chr1 = chr1\n             self.chr2 = chr2\n             self.chr3 = chr3\n             if not isinstance(chr3, str):", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\n    def __init__(self, value, lower, upper):\n        self.value = value\n\n        self.lower = lower\n\n        self.upper = upper\n\n    def str_find(self, index, char):\n        if index in self.lower:\n            return self.value[index]\n\n        if index in self.upper:\n            return -1\n        else:\n            return self.value[index]\n\n    return -1", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    pass\n\nI'm sure you have a point, but I can't tell what it is.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str) -> None:\n    \"\"\" Initialize the length of the string\n    >>> s = str.split()\n    >>> len(s)\n    0\n    >>> s[-2:] = 'x'\n    >>> len(s)\n    3\n    \"\"\"\n\nDefinitely doesn't need to be an anonymous class. A simple lambda would be more elegant.\n\nAhhh, I love it when I see something I've done in someone else's codebase.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nYou could have just called str.__len__(self).\n\nI prefer the function. It's more explicit.\n\nWe'll see about that when you have to maintain it.\n\nYou could write a unit test for it that automatically rewrites it if it changes.\n\nThis is an example of what I've been trying to convey with this article:\nUnit testing is not a panacea. You have to be careful not to fall into the\ntrap of just mindlessly applying it to everything you write.\n\nI know. I don't think unit testing is for everything.\nMy point was that one of the dangers of doing things like this is that it is easy to forget to do it.\n\nA better solution:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\n    def is_valid(name: str):\n    \"\"\" Test whether string is valid\n    >>> is_valid('asd')\n    True\n    >>> is_valid('abcdefg')\n    False\n    \"\"\"\n\n    return str.find(r'^\\s*$', None)", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI've never really understood why string.len() isn't called strlen().</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    if __name__ == '__main__':\n    s = 'abc'\n    print(strlen(s))</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nNote that the strlen function returns the length of the string and not the character count.\n\nThx!\nThought I should do some self-study today :)\n\nRight now I would definitely recommend the Introduction to Programming in Python by Al Sweigart.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nThe behavior of this function, if written in C, is undefined. I know you were just trying to be cute, but it makes the code much harder to read.\n\nThis is the correct way to do it in Python:\n>>> def strlen(s):\n...    return len(s)\n...\n>>> strlen('abc')\n3\n\nYou're correct. The issue is that the author has written a function called \"strlen\" but it doesn't have anything to do with string length. The best name would be \"length\" or \"size\".\n\nWhile I agree it would be better to call it length, the name strlen is correct. It takes a string, and returns the length. In that sense, it is correct to call it strlen.\n\nIf you have a function called \"strlen\", you shouldn't have to write \"len(string)\" as a callable object literal.\n\nOkay, let's see how good you are at naming things.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nNote that the strlen() in Python is different than the one you've copied.\n\nThere is a gotcha in this function. It doesn't handle the empty string case correctly:\n>>> str = '''\\'''\n>>> len(str)\n'\\0'\n>>> str[::-1]\n''\n>>> len(str[::-1])\n0\nIn Python, the empty string is represented by '\\0', which is why len() on the empty string returns '\\0'. str[::-1] is also the empty string, but len() on it returns 0.\nIf you want to do it correctly, you can use re.sub() instead of str.find(). For example:\n>>> from re import re\n>>> re.sub('', '', str)\n''\n>>> len(re.sub('', '', str))\n0\n>>> len(re.sub('', '', str[::-1]))\n0\n\nIt's _extremely_ likely that the author was aware of this, and made a conscious decision to ignore it in favor of the simpler version.\n\nYou would be surprised by the number of times I've seen beginner Python", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\n\nAh, so it is. I was just going off of the Python I know, which I'm pretty sure is different. Thanks for the correction!</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def get_length(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> get_length('abc')\n    3\n    >>> get_length('xyz')\n    9\n    \"\"\"\n    return strlen(string)\nIn this case the strlen function is almost useless - the get_length function already does what strlen is doing.\nIn general, I think it's better to have a function that does one thing than a function that does two things, because the one-function function can be optimized better.  I think you should pick one function and do away with the other.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\nIt would be more pythonic to use string.length.\n>>> strlen('abc')\n3\n>>> strlen('abc')\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: unsupported operand type(s) for +: 'int' and'str'\n\nI think it would be more pythonic to just use the builtin `len` instead of an extension.\n\nNice idea!\n\nFantastic!\n\nIt is good if you already know what you want to do with the string.\n\nI'm not sure what that means.\n\nIf you know how long the string is going to be, you don't need this.\nIf you don't know, then this is useful.\n\nThe problem is that you can't know in advance how long a string will be.\n\nI think you mean can't.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\n    return len(string.ascii_uppercase)\n\nThe funny thing is that I was just reading about that in Effective Python.\nThere are no funny things in Effective Python.  Only horror.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return string.length\nYou are going to have to explain why \"strlen(\"abc\")\" works. What does that say about what is contained in the brackets?\nIt's not magic. It's just a variable. The program contains a call to \"strlen\" that returns the length of the string \"abc\".  That's it.\nYou need to remember this: There is no such thing as a variable in Python. Everything is a special object.\nTIL. Thanks for the pointer.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nThis is not only shorter, but it's also more understandable.\nBut the string literal is not part of the string object. There's an obvious way to fix it, but I'm going to show it in a different way.\n\"\"\" Return length of given string\n    >>> str = 'abc'\n    >>> str.length\n    3\n    \"\"\"\n    return len(str)\nThat's also more understandable.\n\nThanks! My example was bad. I should have used str.\n\nI prefer explicit code, so I wouldn't make an operator for this.\nI'd rather write:\nstr.length\nstr.substring(1)\nstr.substring(2,4)\nstr.substring(2,3)\nstr.substring(3,4)\nYou can see there is an implicit assumption that the string is passed by reference, which is okay when the function you are calling is supposed to operate on the string.\nBut if the function is supposed to operate on a copy of the string (like a copy constructor) then you have to pass it explicitly.\n\nThat's the", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nyou're missing the's' at the end.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nDoesn't need to be a class method.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThis is incorrect. The string `'abc'` contains 3 characters. The\nstring `'abc'` contains 3 characters.\n\nPerhaps you meant", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nAnd that's why you should always use a long instead of an int for a loop counter!\nI don't get it.   strlen('') returns zero.   That's a value that is not null.\nNot sure why you are being downvoted. This is correct.\nBecause I said something true that contradicts the OP.   But yeah, I don't get it.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    if string.startswith(\"__\"):\n       return 0\n    return len(string)\n_Why?_\nBecause it's easier to read.\nThe alternative would be:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\n>>> print length('abc')\n3\n\nSo there is no need to pass str into len() at all.\n\nIf you pass 'abc' into len() it will return the length of the string 'abc' not 'abc' itself.\n\nIn your example of len('abc') you are passing a string.\n\nBut len() doesn't care if you pass a string or not, it will return the length of whatever string you pass it.\n\nBut the output of len('abc') is not the same as len('abc')", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\n         def __len__(self):\n           return len(self.__dict__)\nAnd then they complain about Python not being used at NASA.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\n\nThese are code guidelines. They're not style guidelines.\n\nFor any language.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThis is from the Python 2.x Standard Library, which I would not describe as \"the best of Python\".\nThe correct way to do it in Python 3.x is:\n>>> str.__len__()\n3\n\nAh, I knew there would be an even more concise way to do it with a language I don't know well.\n\nI would say it is a feature, not a bug, that the language doesn't force you to write \"the best of Python\" for a tutorial. You don't want beginners to have to look up the language reference to do simple things, because that will just be a source of confusion for the beginner.\n\nA lot of the best of Python is in the language reference.\nIn general, you want to force beginners to use the standard library.\n\nI believe it's the other way around. You want to _empower_ beginners to use the standard library. You don't want to _force_ them. You have to convince them first.\n\nYes, I think you're right. That's what I meant.\n\n\"The best of Python\" was Python 2.x, not Python 3.x.\n\nThis post was written in 2012.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI've seen that exact same function signature in real life. I shit you not.\n\nI once wrote code that was a textbook example of how to do something.\n\nI wrote code that was a textbook example of how not to do something. I called it \"bad_example.py\"\n\nI just had to find a way to write a function with one argument. The IDE would not let me write \"def one_arg_func(arg):\", so I wrote \"def one_arg_func(arg):\".\n\nI had an old co-worker who did that too, and he wasn't joking. It made me cry.\n\nI had to write something to analyze a sequence of real numbers, and I had no idea what to call it. I asked on IRC and someone suggested _sequence_ or _series_ or something like that, and I liked it.\n\nI wrote a function that was a textbook example of how not to write a function.\n\nThat would be an infinite loop, no?\n\nThe worst I've written so far was a function that I called is_negative_even_number(int x), where int x was a parameter.\nBut it wasn't a parameter", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    # This has a different implementation than str\n    def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('abc')\n    3\n    >>> strlen('abcdef')\n    3\n    \"\"\"\n    # On 2nd glance, it would seem that the str.__str__ method is doing\n    # the same thing, but returning a different type\n    def __str__(self):\n    \"\"\" Return a string representation of this object.\n    >>> 'abc'.__str__\n    'abc'\n    \"\"\"\n    return str(self.__class__.__name__, '__main__')\nDefinitely not Pythonic, but it's not a bad approximation.  The only problem is that 'abcdef' would be returned as 'abcdef'.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nUseless to override this unless you use a different algorithm.  Although the version you provide is also correct in python.\nIt's a good practice to provide a default implementation for things, just in case you forget to implement them, or do something in a really stupid way.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\nI haven't looked into it, but as a first reaction, I would say it looks wrong. I don't think you should define a function that doesn't work with all of the input types (though you can be smart and provide sensible defaults, if you want).\n\nThat's a fairly common Python idiom.\n\nThat idiom is much older than Python. It's just the same as the first line of the C strlen() function.\n\nThe first line of the C strlen() function is:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\n\nSo, the author basically has a look-up table to know how to convert from str to int?\n\nThat's nothing. The author has an implementation of a `number` type and a `str` type that are distinct and unrelated!\n\nSo, this is how a bunch of the older languages worked.\n\nIt's sad that people are still writing this type of code in 2016.\n\nCare to explain why?\n\nThe code is unreadable, so it is likely to be hard to maintain.\n\nThe code is _extremely_ readable. There's almost nothing to it. I can look at this code and understand exactly what it does and how it does it.\n\nI'm not sure we're looking at the same code.\n\nI think you're looking at the code and then trying to extrapolate the meaning without reading it.\nIf you read it line by line, it's extremely clear. It's pretty much just:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\n\n    def print_code(s: str) -> None:\n    \"\"\" Print the code of a string\n    >>> print_code('abc')\n    'abc'\n    \"\"\"\n    return s.code</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\nYou can also write", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nIf you're using python 2.6, you can use u'abc' instead of 'abc' and it will be interpreted as unicode.\n\nIn Python 3 you can use \"abc\" instead.\n\nThanks, I've updated my answer.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI don't think it's that bad. I mean, the string example is kinda obvious, but the \"abc\" example is nice.\n\nNote that the assignment is `strlen('abc') = 3`\n\nHa! I remember when I was a young fellow, and I would just write these kind of quick and dirty \"ghetto\" replacements for \"builtin\" functionality in Python.\nI think I stopped after I realized that not only is the builtin way much simpler and easier to understand, but is also the way the language is _actually designed_.\n\nAnd the builtin way is often much faster, because it's optimized for the particular type you're dealing with.\n\nThat's a good point.\nFor example, Python has a str.isdigit() method that returns True if the string represents a number. I have a little utility function in my project that provides a wrapper for that so I don't have to remember that it exists.\nHowever, the builtin function is built for numbers, and therefore has much less overhead than my function, which requires that the number is not an empty string, and is not negative.\n\nThat's a good point, but I think the article is getting at", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nWhat does that do?\nIt returns the number of characters in a string</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nWhat does the strlen of 'abc' have to do with '''? The length of a string is not the length of a string literal.\n\nAnd why does strlen not simply return the number of characters in the string? That's what I was expecting from the article.\n\nstrlen is a function defined in the string module, not the stdlib.\n\nI don't think it's right to say the answer is 42 either. The right answer is \"42\".</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThank you. I guess I am going to need to take a Python course to get a deeper understanding of what is happening.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nAn over-complicated version that makes a list of string slices, and calls strlen on each one.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def max_len(s: string) -> int:\n    \"\"\" Return maximum length of given string\n    >>> max_len('abc')\n    3\n    >>> max_len('abcdef')\n    6\n    >>> max_len('abcdefghi')\n    9\n    \"\"\"\n    return len(s) - len(str)\n\nThis just writes out the strings to a file and returns the length. Not very practical, but a good introduction to python.\n\nFor the curious: \n\nThe ones I wrote for a work project:\n\nOoh, I'm a big fan of the unexpected-return-of-null. Reminds me of C.\n\nNot as much fun as the entire file being replaced with single quotes:\n>>> print \"foo\" | python -c 'print \"\", end=\"\\n\"'\nfoo\n\nI'm sure this is already posted, but it's really fun:\n>>> import str\n>>> str.format('%d %s', 0, 0)\n'0' '0'\n>>> print str.format('", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nNo, it's not.\n\nIt is if you are writing Python and not C.\n\nThat's like saying C's strlen is not a function in C because you\nshouldn't be using it.\n\nThere's a difference between something being a function and something\nbeing idiomatic. I'm not saying you shouldn't use it, but the point was\nthat in Python, the idiomatic way to get the length of a string is\nstr.len.\n\nstr.len is idiomatic for string objects, not for strings. There are\nmany good reasons to want to know the length of a string, not just a\nstring object.\n\nIn Python, that's a string object, not a string.\n\nBut that doesn't make it the idiomatic way to get the length of a string.\n\nWhat's the idiomatic way?\n\nThe way that works on strings, not on string objects.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\nIt's not that weird, if you think of it as returning the length of a pointer to the string, rather than the length of the string itself.\n\nI would say that's more of an implementation detail than the actual definition of the function, though, and in any case, it is most definitely still weird that it's called \"strlen\".\n\nNo, strlen is a function that takes a string and a length, and returns the length. If you want to get the length of an arbitrary pointer to a string, that's called strrlen.\n\nstrlen is a function that takes a string and a length, and returns the length of that specific string. It's not a function that takes a string and a length, and returns the length of _any_ string.\n\nIt's a function that takes a string and a length, and returns the length of _that_ string. That string may be an int, a float, a slice of bytes, or anything else.\n\nIt's a function that takes a string and a length, and returns the length of that string.\n\nBut it's not a function that takes a string and a length, and returns the length of _any_ string.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI have no idea why the author of that would think that is a good example. In Python, if you pass in an empty string, the length will be 0.\n\nIn Python 2.7, if you pass in an empty string, the length will be 0.\n\nDoes anyone know if there's a reason Python 2.7 got rid of that behavior? It seems like something pretty useful.\n\nFrom  :\n\"The strlen() function in Python 3 returns a length that is one greater than that of the largest possible string that can be created with the characters passed in.\"\n\nAs a note, that doesn't mean it will return the number of bytes in the string, since in Python 2.x, the `str` type is essentially a pointer to a string.\nIt's also why the line `str[::-1]` will not work in Python 3, but works in Python 2.\n\nThat's what the argument type hinted.\n\nI'm not quite sure what you mean by this. I thought the point was to clarify what 'the length' actually is (i.e. the number of bytes in the string) and point out a common error people make when trying to use `", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    from __future__ import division\n\nYeah, but then they'll complain about the inconsistent use of'str' and'string' :(\n\nThis is better:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return string.length\n\nI think a better version would be:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __len__(self):\n    if self is string: return len(self)\n    if self is list: return len(self.__dict__)\n    return self.__len__()\n    def __add__(self, other):\n    \"\"\" Add a new value to the list\n    >>> a = [1, 2, 3]\n    >>> b = [4, 5, 6]\n    >>> a.append(b)\n    [1, 2, 3, 4, 5, 6]\n    \"\"\"\n    return self.__dict__.__add__(other)\nI'm a simple man; I see Python, I upvote.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI didn't want to include a comment when I first wrote this, but the `return` for the function is a bit redundant. I would have expected a comment saying that this returns the length.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return int(string.index(c) * string.length()) + 1\nThat's not Python-specific enough.  It should be:      return string.index(c) + string.length()</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    \"\"\"If the string is empty, return zero.\n    \"\"\"\n    return 0 if string.startswith(' ') and string.endswith(' '):\n    return string.count(letter) + 1\nPython.\nI think you meant \"return string.count('a') + 1\"  Right?\nThat's the first thing that came to mind but I'm not sure if the syntax is quite right.\nYou'd need to use the.get() method for this I believe.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def maxlength(string: str) -> int:\n    \"\"\" Return maximum length of given string\n    >>> maxlength('abc')\n    3\n    >>> maxlength('ABC')\n    5\n    \"\"\"\n    def minlength(string: str) -> int:\n    \"\"\" Return minimum length of given string\n    >>> minlength('abc')\n    0\n    >>> minlength('ABC')\n    1\n    \"\"\"\n    def count(string: str) -> int:\n    \"\"\" Return number of occurrences of given string\n    >>> count('abc')\n    1\n    >>> count('abcdef')\n    3\n    \"\"\"\n    def repeat(string: str) -> int:\n    \"\"\" Return number of times given string occurs\n    >>> repeat('abc')\n    1\n    >>> repeat('abc')\n    1\n    >>> repeat('abc')\n    1\n    \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string.split(' '))\nDoesn't this return the length of the string if it is empty?\nYes, it does. This is a case where the design of the language breaks the rules of good programming.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nIs that considered a bad practice? I find it quite useful to have easy and obvious ways to convert between string and numbers.\n\nIt's not a bad practice, but it's not the most efficient. str.upper() is probably faster if you have a variable-length string (which is very likely if you're working with strings).\n\nI wonder what the performance of str.upper would be with a really long string.\n\nProbably better than strlen, but still no where near as fast as an \"actual\" integer. It also doesn't work on strings that are all uppercase.\n\nWhy is that? Can't you just return the number of characters?\n\nYou can, but that's a lot of work for the compiler to do. There are plenty of solutions to this problem, but they all take a lot of work. str.upper() is the quickest, but not by much.\n\nI like to use the following idioms:\n1\\. String functions are overloaded on integers.\n2\\. String is UTF-8.\n3\\. Use str.upper() for length and indexing.\n\n4\\. Use unicode for strings that are not ASCII.\n\nThere's a lot of", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def find_beginning(string: str) -> int:\n    \"\"\" Return 1 if string is empty else find the first character in string.\n    >>> s = 'a'\n    >>> find_beginning(s)\n    1\n    >>> find_beginning('abc')\n    1 \"\"\"\n    return len(string) == 1\n\nTo be honest, I don't really understand why you'd make your own string type. I'd personally use a class like `StringIO` that makes working with strings much easier and safer.\n\nBecause he's showing how to write an interpreter in Python.\n\nYep, that is correct!\n\nSo the question is, why make a string type when using a stringIO type would be better?\n\nBecause it is a bit more difficult, and it is good practice to make it from scratch once in a while.\n\nI like the C version:\n\nI got confused and wondered what a \"strlen\" function would have to do with the \"strcat\" function.\n\nIt's like \"Bob's Your Uncle\" for programming.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nBut it's not a string, it's a list.\nAnd strlen doesn't take a list as an argument.\nit's not a list either. it's a tuple.\nA tuple is an ordered list.  And you're right, strlen doesn't take a tuple as an argument.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    if string is None:\n       return 0\n    return string.count('\\0')\nYou know, `str.count('\\0')` is the function that will return the number of characters in a string, not the length of it.   The length of a string is the number of bytes it takes.\nMy bad. I'll fix it</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return string.length\n    # Not sure why this is here\nYou don't need to put the string.length part in the function, that's why it doesn't work.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI'm not an expert, but this feels like a poor design for a library.  It doesn't explain what \"strlen\" is for, or why it's useful.  It doesn't even explain that it's an integer function.\nIt doesn't explain much at all. It's a terrible API.  The function name is also misleading, as it is not a length function but rather a length of a specific type function.  The entire thing is awful.  You can do so much better than this.  Please don't give us your own API without giving us a context to evaluate it.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\""]]