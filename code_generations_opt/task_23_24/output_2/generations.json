[["def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str) -> None:\n    \"\"\" Initialize a new instance of the string length function\n    >>> from sympy import strlen\n    >>> strlen('abc')\n    3\n    >>> from sympy import strlen\n    >>> strlen('abc')\n    1\n    \"\"\"\n    self.string = string\n    def __call__(self, string: str):\n    \"\"\" Return the length of string\n    >>> strlen('abc')\n    3\n    \"\"\"\n    return self.string.length", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI don't understand what's wrong with this?\n\nIt's not the \"strlen\" function that's bad, it's the fact that the string \"abc\" is stored in a variable named \"str\".\n\nAh. I'm so used to just using'str' to mean \"the string you're about to use\", that I didn't even notice.\n\nThe problem is not the name of the variable, it is the fact that it is not a function call, but a string literal.\n\nI think the real problem is that it's a function that only takes one parameter.\n\nI once found a C program that was doing this:\nint f(int n)\n{\nreturn n;\n}\n\nThat's not really the same thing. It's like declaring a function that returns an int, and then calling it with an int.\n\nNot the same thing, but in the same spirit.\n\nI don't think so. The return value of a function is a value, and it's reasonable to want to use that value in a context where you can't pass a value to the function.\n\nNo, it's not.\n\nIt is in the context of a function", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI've never seen that done before.  It's a good idea.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI find it easier to use the.length property of strings.\nWhat's the difference between the two?\nString.length is the number of characters in the string.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nThis is why I'm not a fan of python.\nWhy?\nBecause it's a language where you can write a function to calculate the length of a string.\nSo you're saying you prefer languages where you can't?\nNo, I'm saying that I prefer languages where you don't have to.\nYou don't have to, you just choose to.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    return len(string)", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    if string == '':\n        return 0\n    else:\n        return len(string)\n    \"\"\"\n\nI like it.\n\nI'm not sure if you're being sarcastic or not, but I'll take the compliment.\n\nI was being serious. It's a nice little snippet.\n\nI thought you were being sarcastic, because the OP is a little snippet.\n\nI don't know why but I like this.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.\n\nI like it.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI think it's a bit too much to expect people to know what strlen is, especially for people who don't use Python.\n\nThis is the sort of thing I'd expect to see in a Python tutorial, but not in a general programming tutorial.\n\nWhy do you think it is a Python specific function?\n\nIt's not Python specific, but I don't think it's something that people who don't know Python would ever need to know.\n\nI think it is useful to know if you are going to be doing any programming.\n\nI agree.\n\nI think you might want to add a note to the explanation that the format of the string is not important, so you could just as well use \"abc\" as \"a\\x0b\\x0c\".\n\nI think it would be a good idea to mention that strlen is case sensitive.\n\nstrlen is not case sensitive.\n\nstrlen is case sensitive.\n\nstrlen is not case sensitive.\n\nstrlen is case sensitive.\n\nstrlen is not case sensitive.\n\nstrlen is case sensitive.\n\nstrlen is not case sensitive.\n\nstrlen is not case sensitive.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThis is not a good example. The string is empty and it's length is 0.\n\nI agree, it's not a good example. The point is that you can write your own functions, and that is what I am looking for.\n\nThere are many reasons to use strlen, and I've never seen a case where it's \"not a good example\".\n\nI like the idea of having a list of the most useful functions.\n\nThis is a good idea, but it's not really \"functions\".\n\nThis is cool, but I'm not sure if it's for me. I have a very specific way of doing things, and I don't like to change it.\n\nI like it.\n\nI don't really understand the point.\n\nYou can write your own functions!</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    if len(string) == 0:\n        return 0\n    else:\n        return len(string)\nI'm not sure if this is a joke or not...\n\nWell, it's a joke on the \"str.split()\" function.\n\nI have never been more grateful for the lack of syntax highlighting on this site.\n\nI thought the joke was that the comments were just as long as the code.\n\nI'm not sure if this is a joke or not...\n\nWell, it's a joke on the \"str.split()\" function.\n\nI have never been more grateful for the lack of syntax highlighting on this site.\n\nI thought the joke was that the comments were just as long as the code.\n\nI'm not sure if this is a joke or not...\n\nWell, it's a joke on the \"str.split()\" function.\n\nI have never been more grateful for the lack of syntax highlighting on this site.\n\nI thought the joke was that the comments were just as long as the code.\n\nI'm not sure if this is a joke or", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    if string.startswith('_') or string.startswith('-') or string.startswith('-_') or string.startswith('_-'):\n        return 0\n    else:\n        return string.length\n    \"\"\"\n\nI've had a good laugh.\n\nThis is just one example of many. The string library is riddled with these kinds of things.\n\nI like to think of this as a feature, not a bug. It's the old \"you can do it, but you shouldn't\" thing. It's not a good idea to use the string library to perform tasks that it was never intended for.\n\nThe problem is that the documentation for the string library is terrible. It's hard to tell what the library is intended for.\n\nI think that's a fair point. The documentation is pretty sparse, and the examples are terrible.\n\nThe problem is that Python is a \"batteries included\" language. It has a lot of stuff in the standard library, and it's very easy to pick up and get started with. This means", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nThat's a good one!  I would add a comment saying \"If you are using Python 3, use len(string) instead.\"  Also, I would add a comment saying \"If you are using Python 2, use str.len() instead.\"</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI can't believe you're the only one who's mentioned this. It's the most obvious solution.\nIt's not obvious to someone who's never programmed before.\nI'm pretty sure it is, the concept of a string is pretty easy to understand.\nStrings are a pretty advanced concept for someone who has never programmed before.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    return len(string)\nI can't believe this is still a problem in Python.  I mean, it's not like this is some obscure feature.\nI can't believe people still use Python.  I mean, it's not like this is some obscure language.\nI can't believe people still use computers. I mean, it's not like this is some obscure piece of technology.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def is_empty(string: str):\n    \"\"\" Test if given string is empty\n    >>> is_empty('abc')\n    True\n    >>> is_empty('abc')\n    False\n    \"\"\"\n    def is_valid_char(string: str):\n    \"\"\" Test if given string is valid\n    >>> is_valid_char('abc')\n    True\n    >>> is_valid_char('ABC')\n    False\n    \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI thought the standard Python convention was to use lowercase for methods and camelCase for variables.\n\nIt is. I'm not sure why this was submitted to HN.\n\nI'm not sure why you would think this is not worth submitting to HN. I think it is.\n\nBecause it's a Python 3 article, and most people here are still on Python 2.\n\nI'm still on Python 2, but I'm interested in Python 3, so I read articles about it.\n\nSo, I was a bit too harsh. I'm sorry.\nI still think that this is not a very interesting article, but I can understand why you'd submit it.\n\nI'm going to be the one to say it:\nThe use of the word \"sucks\" is unnecessary.\n\nI can't think of a more fitting word for it, personally.\n\nWell, there are plenty of words that are less inflammatory, but I'm not going to argue with you about it.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThis is a bad example. The string you're returning is not the same as the string you're using as a parameter.\n\nI see. Thanks.\n\nI'm not sure I see the point. If you have a string, and you want to know how long it is, you can just type in the length of the string.\n\nYeah, but you can't do that when you're using a function that takes a string as a parameter.\n\nI think the point is that you should be using string.length() instead of strlen() in the first place.\n\nI think the point is that you shouldn't be using strlen() in the first place.\n\nI don't see why. I use strlen() all the time in C.\n\nAnd you should use string.length() instead.\n\nI don't see why. I use strlen() all the time in C.\n\nAnd you should use string.length() instead.\n\nI don't see why. I use strlen() all the time in C.\n\nAnd you should use string.length() instead.\n\nI don't see why. I use strlen() all the time in C.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return string.length\nI always like to use the `str` type for this.       def strlen(string: str):", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    if not string:\n        return 0\n    elif string[0] == '\\0':\n        return 1\n    else:\n        return string.length\n    \"\"\"\n    if __name__ == '__main__':\n         print(strlen(''))\n         print(strlen('abc'))\n         print(strlen('abcdef'))\n         print(strlen('abcdefgh'))\n\n>>> print(strlen('abcdefgh'))\n6\n\nI'm not sure how this is an \"improvement\" over the original.\n\nHow is it not an improvement? It's less code, it's more readable, it's more efficient.\n\nIt's not more efficient. It's just a different implementation.\n\nIt's more efficient because it's using the built-in str.length method. The other one is using the Python built-in", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nThis is the kind of shit that makes Python popular.\n\nI'd rather have a `strlen_s` function that takes a string and returns a `strlen` object that can be passed to `strlen` or `strlen_s` functions.\n\nI'd rather have a strlen_s that takes a string and returns the number of characters in it.\n\nI'd rather have a strlen_s that takes a string and returns a strlen object that can be passed to strlen or strlen_s functions.\n\nI'd rather have a strlen_s that takes a string and returns the number of characters in it.\n\nI'd rather have a strlen_s that takes a string and returns the number of characters in it.\n\nI'd rather have a strlen_s that takes a string and returns the number of characters in it.\n\nI'd rather have a strlen_s that takes a string and returns the number of characters in it.\n\nI'd rather have a strlen_s that takes a string and returns the number of characters in it.\n\nI'd rather have a strlen_s that", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nAck, I didn't think of that. I just used \"\".length.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI just came here to say the exact same thing.  I'm not sure why people do this.\nI know the reason.  Because they're too lazy to write a function that does nothing but return a string, and then pass that string to the function that does the actual work.      def strlen(string):          return string.length\nAnd then you get a bug report about it not working when the string is empty.\nThe function in the example above doesn't work when the string is empty either.\nI think it's a matter of habit.  I've seen people use strlen() in such a way that I'm fairly sure they don't know about len().  I know I didn't until I was shown.  So I'm guessing it's a matter of laziness and not knowing better.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThis is the wrong way to do it. It's trivial to write a \"stealer\" function that will make it fail:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThe above is a perfectly good implementation of strlen.  The \"obvious\" implementation is very bad, because it is not type safe.  The type system is there to help you, not to make you feel stupid.\n\nI've never seen a language where you can't use a variable that's not declared in the current scope.\n\nYou can, but it will be a variable of a type that is not declared in the current scope.\n\nI think you mean you can't use a variable that's not declared in the current scope.\n\nYou can use variables that aren't declared in the current scope, but you can't assign a value to them.\n\nI think you mean you can't assign a value to a variable that's not declared in the current scope.\n\nYou can assign a value to a variable that's not declared in the current scope, but you can't do anything with it.\n\nI think you mean you can't do anything with a variable that's not declared in the current scope.\n\nYou can do something with a variable that's not declared in the current scope, but you can't assign a value to it.\n\nI think you mean you can't assign a value", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI don't think this is the right answer.\nIf the string is empty, it's going to return 0.\nIf the string is \"abc\", it's going to return 3.\n\nIt's a good thing that this is a test and not a production codebase, then.\n\nThis is a test for a production codebase.\n\nThis is a test for a production codebase.\n\nThis is a test for a production codebase.\n\nThis is a test for a production codebase.\n\nThis is a test for a production codebase.\n\nThis is a test for a production codebase.\n\nThis is a test for a production codebase.\n\nThis is a test for a production codebase.\n\nThis is a test for a production codebase.\n\nThis is a test for a production codebase.\n\nThis is a test for a production codebase.\n\nThis is a test for a production codebase.\n\nThis is a test for a production codebase.\n\nThis is a test for a production codebase.\n\nThis is a test for a production codebase.\n\nThis is a test", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nThat's not a very good example of a \"bad\" function, since the function is actually doing what it claims to do.  It's a bit of a waste of time, but it's not misleading.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThe problem here is that this is a very bad function. It returns the length of a string, but there is no way to know whether it is the length of the string in memory or the length of the string in the buffer. This is a very bad thing.\n\nYou are right. I should have posted a corrected version of my original comment. This is the corrected version:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def _get_length(self):\n    \"\"\" Return length of string\n    >>> _get_length('abc')\n    3\n    >>> _get_length('abcdef')\n    3\n    \"\"\"\n    return len(self.string)\nI really don't get it. How is this better than        str.__len__()\n?\n\nIt's not.\nI'm guessing this is just a way to keep the code more pythonic.\n\nIt's a way to make it more readable. The example is not a good one, because there's no reason to use this instead of `__len__`.\n\nIt's a good example because it's a common mistake, and the _get_length_ function is a common way of avoiding it.\n\nI see. It's a common mistake because people are confused about how `__len__` works.\n\nI don't think so. It's a common mistake because people don't realize that `str.__len__()` is not the same as `len(str)`.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    if string == '':\n       return 0\n    else:\n       return len(string)\nI don't see why the empty string needs to be handled specially.\n\nBecause the empty string is not a valid Python string.\n\nI'm not sure I understand. What is the difference between a string and an empty string?\n\nThe empty string is a sequence of zero bytes.\n\nI see. So what is the difference between a valid Python string and an invalid one?\n\nA string is a sequence of characters. The empty string is not a valid sequence of characters.\n\nI see. So is this a special case? Or is it a rule that all strings must be sequences of characters?\n\nAll strings must be sequences of characters.\n\nI see. Thanks for answering my questions.\n\nI think you are missing the point.\nThe empty string is not a valid python string.\nThat is, a valid python string must be a sequence of characters.\nThe empty string is not a sequence of characters.\nIt is a sequence of zero bytes.\n\nI understand that. I was trying to understand the difference between a", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nthis is a very common mistake, but the \"correct\" version is actually not as easy to read as it seems.\nI have a hard time believing that the above version is _actually_ easier to read than the version with the function signature.\nThe \"correct\" version is even easier to read, if you know the convention of the \"return\" keyword.\nIt's even easier to read if you use a proper IDE.\nIt's even easier to read if you have some experience reading code.\nIt's even easier to read if you're a programmer.\nIt's even easier to read if you're a good programmer.\nIt's even easier to read if you're an excellent programmer.\nIt's even easier to read if you're a legendary programmer.\nIt's even easier to read if you're a programmer god.\nIt's even easier to read if you're a programmer god-emperor.\nIt's even easier to read if you're a programmer god-emperor of mankind.\nIt's even easier to read if you're a programmer god-emperor of mankind with the head of a space marine.\nIt's even easier to read if you're a programmer", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nSo, if you have a string that is not valid Python code, it will still work.\n\nFor the same reason, you can use str.replace(\"ab\",\"a\") to replace all 'a' characters with 'b'.\n\nI like the title of this article. It's not a joke. It's not clickbait. It's just a factual statement.\n\nYou can even do\nstr.replace('ab', 'a')\n\nI am still learning Python, but how is this different from:\nstr.replace('ab', 'a')\n\nThere's a very good reason for this.\n\nYes, but it's not a very good reason.\n\nHow is it not a very good reason?\n\nThe idea that \"replace\" is a keyword, which can only be used in a string context, and that the \"replace\" method on strings is a string method, not a string replacement method, is a very poor idea.\nPython's string API is a kludge. It's a mess. It's a major pain to use.\n\nPython has a lot of weird things about strings. For example, you can't add two strings together.\n\nYou can.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nThis is a really bad idea.\n\nI'm curious: why?\n\nBecause it's not obvious what the return value is.\nThe string literal `''` has the same length as the string literal `'abc'`.\nThe string literal `'abc'` has the same length as the string literal `\"abc\"`.\nThe string literal `\"abc\"` has the same length as the string literal `\"abc\"`.\nThe string literal `\"abc\"` has the same length as the string literal `'abc'`.\nThe string literal `'abc'` has the same length as the string literal `\"abc\"`.\nThe string literal `\"abc\"` has the same length as the string literal `\"abc\"`.\nThe string literal `\"abc\"` has the same length as the string literal `'abc'`.\nThe string literal `'abc'` has the same length as the string literal `\"abc\"`.\nThe string literal `\"abc\"` has the same length as the string literal `\"abc\"`.\nThe string literal `\"abc\"` has the same length as the string literal `'abc'`.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nThis is actually a terrible solution to the problem.  The length of a string is not defined to be the number of characters.  This is a common mistake people make when they are new to Python, but it's a mistake.  You need to use len(string) only when you know the string is a sequence of characters.  In this case, you should use str.count() instead.\nI am new to python.  Can you explain why this is a mistake?  I thought that the length of a string is the number of characters.  I've seen this in a few places, but I'm not sure if this is just a convention or if there's something about it that I'm not aware of.\nI think what /u/Turbofire is saying is that the length of a string is not the same as the number of characters in the string.  For example, the string 'abc' is 5 characters long, but the string 'abcdefghijklmnopqrstuvwxyz' is only 6 characters long.  len(string) is the number of characters in the string, but str.count(*) is the number of characters", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThis is not a function, it is a method. In Python, functions are first class objects and can be passed around, stored in variables, and returned. Methods are not first class objects, they are methods of the object that defined them.\nYou can define a function that returns a method:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThe string is always a string literal.\n\nThe problem is that you're trying to use a string literal as the parameter, but then you're using it as a string, which is what the call to strlen is expecting.\n\nThe reason it's not working is that you're passing a string literal to a function expecting a string.\n\nThe string is always a string literal.\n\nThe problem is that you're trying to use a string literal as the parameter, but then you're using it as a string, which is what the call to strlen is expecting.\n\nThe reason it's not working is that you're passing a string literal to a function expecting a string.\n\nThe string is always a string literal.\n\nThe problem is that you're trying to use a string literal as the parameter, but then you're using it as a string, which is what the call to strlen is expecting.\n\nThe reason it's not working is that you're passing a string literal to a function expecting a string.\n\nThe string is always a string literal.\n\nThe problem is that you're trying to use a string literal as the parameter, but then you're using it as a string, which is", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    if string.startswith('\\0'):\n        return 0\n    return len(string)\nPython 2.7.6 (default, Aug 29 2012, 15:29:48)\n[GCC 4.2.1 Compatible Apple LLVM 6.1.0 (clang-600.1.78)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI don't know if you can call len on a string literal.  I think you'd have to create a string and call len on that.\nThis is correct, but it is a bit of a pain.  If you want to be able to use it on strings you should be able to do this:      def strlen(string: str):", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __len__(self):\n    \"\"\" Return the length of this object\n    >>> str = strlen('abc')\n    >>> str.__len__()\n    3\n    \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThis is not a very good example.\nThe result of strlen('') is implementation-defined. In Python 2.6, it's 2, in 2.7 it's 1.\n\nPython 2.7:\n>>> 'abc'.__str__.__len__\n3\n>>> 'abc'.__str__.__str__.__len__\n4\n>>> 'abc'.__str__.__str__.__len__\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nFile \"\", line 1, in __str__\nFile \"\", line 1, in __str__\nFile \"\", line 1, in __str__\nFile \"\", line 1, in __str__\nFile \"\", line 1, in __str__\nFile \"\", line 1, in __str__\nFile \"\", line 1, in __str__\nFile \"\", line 1, in __str__\nFile \"\", line 1, in __str__\nFile \"\", line 1, in __str__\nFile \"\", line 1, in __str__\nFile \"\", line 1, in __str__\nFile \"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, len: int):\n        self.len = len\n    def __len__(self):\n        return len\n    def __str__(self):\n        return '%s' % self.__class__.__name__\n    def __repr__(self):\n        return '%s' % self.__class__.__name__", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI'm not sure if this is a joke or not.\n\nIt's not.\n\nThe main problem with this is that strlen is a builtin, and you can't just do that.\n\nstrlen is a builtin, but it's also a function. So you can do that.\n\nNo, you can't.\n\nI don't think you understand how Python works.\n\nI don't think you understand that the syntax of the language is defined by the language specification, and that there is no way to do what you're suggesting.\n\nYou are wrong.\n\nAnd you are wrong.\n\nI'm not.\n\nYou are.\n\nNo, I'm not.\n\nYou are.\n\nNo, I'm not.\n\nYou are.\n\nNo, I'm not.\n\nYou are.\n\nNo, I'm not.\n\nYou are.\n\nNo, I'm not.\n\nYou are.\n\nNo, I'm not.\n\nYou are.\n\nNo, I'm not.\n\nYou are.\n\nNo, I'm not.\n\nYou are.\n\nNo, I'm not.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str):\n    self.string = string\n\n    def __len__(self):\n    return self.string.__len__()\n    def to_int(self):\n    return self.string.to_int()\n    return strlen(self.string)\n\nIt's not a good idea to use strlen in the to_int() function. It's a lot\nmore readable to use a function like this:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI'm pretty sure that's a terrible idea.\n\nIt's a terrible idea for a _built-in_ function, yes.\n\nI think it's a terrible idea, period. It's just too much work to keep track of the language/platform's string types and how they behave.\n\nNot really. I think the majority of programmers would be able to understand the following:\nstr.length()", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nThis is an excellent example of why you shouldn't use strlen.\n\nThis is an excellent example of why you should use strlen.\n\nI agree with you, but I'm still trying to figure out why he uses strlen instead of len.\n\nBecause len is a function and strlen is a built-in function.\n\nBut why use the built-in instead of the function?\n\nBecause it's shorter.\n\nThat's a bad reason to use the built-in.\n\nAnd you're right, it is a bad reason to use the built-in.\n\nI'm not sure if I understand the point of the article. The author seems to be arguing that because he's a python programmer, he doesn't need to know about C.\n\nThat's not the point. The point is that most people who use Python don't know C, and therefore don't know what's going on under the hood. The author is arguing that this is good, because it means Python programmers can focus on the important parts of their programs, and not have to worry about the details.\n\nThat's the point. It's not that you shouldn't know C", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nWhat's the point of this?\nIt's a joke.  The function doesn't do anything.  It's a joke.  I don't know why I'm responding to this.\nI don't know why I'm responding to this.  I'm responding to this.  I'm responding to this.  I'm responding to this.  I'm responding to this.  I'm responding to this.  I'm responding to this.  I'm responding to this.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nSo, you're saying that it's not a function?\n\nIt's not a function in the sense that strlen() is not a function, but it is a function in the sense that it's a method.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __str__(self):\n    \"\"\" Return the string representation of this object.\n    >>> s = strlen('abc')\n    >>> s\n    'abc'\n    >>> s = strlen('abc')\n    >>> s\n    'abc'\n    >>> s = strlen('abc')\n    >>> s\n    'abc'\n    \"\"\"\n    return str(self.__class__.__name__)\nThe code is more concise, but less readable.  The name of the function is \"strlen\".  So, the name of the function should be used in the function definition.  The name of the function is \"__str__\".  So, the name of the function should be used in the function definition.  The name of the class is \"__class__\".  So, the name of the class should be used in the function definition.  The name of the name of the object is \"__name__\".  So, the name of the object should be used in the function definition.\nThe code is more concise, but less readable", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __str__(self):\n    \"\"\"Return the string representation of the object.\n    >>> str(str)\n    'abc'\n    >>>\n    >>> print(str.__str__())\n    'abc'\n    \"\"\"\n    return 'abc'\n\nBut it's not valid Python, and is not a valid solution to the task.\n\nPython 3.4.2 (default, Jan 20 2016, 16:33:53)\n[GCC 4.2.1 Compatible Apple LLVM 8.0.0 (clang-800.0.42.1)] on darwin\nType \"help\", \"copyright\", \"credits\" or \"license\" for more information.\n>>> print(str.__str__())\n<module '__main__' from '/Users/larry/Desktop/Python/python3/lib/python3.4/site-packages/__main__.py'>\n\nThat's what happens when you write a function that doesn't return anything.\n\nI think you mean it's what happens when you write a function that", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI'm not sure I understand the point of this.  I can't see any difference between this and:      return len(string)\nI think the point is that it's a joke.\nI'm not sure I understand the point of this.  I can't see any difference between this and:      return len(string)\nI think the point is that it's a joke.\nI'm not sure I understand the point of this.  I can't see any difference between this and:      return len(string)\nI think the point is that it's a joke.\nI'm not sure I understand the point of this.  I can't see any difference between this and:      return len(string)\nI think the point is that it's a joke.\nI'm not sure I understand the point of this.  I can't see any difference between this and:      return len(string)\nI think the point is that it's a joke.\nI'm not sure I understand the point of this.  I can't see any difference between this and", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nThis is actually a pretty common thing to do. It's a lot easier than writing your own length function, and is always going to be faster.\n\nI've seen this in a few places now and I have to ask, why do you need to do this?\n\nBecause it's easier than writing a length function, and is always going to be faster than that.\n\nI'm not sure it's always faster. For example, it's not faster than this:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def str_to_int(str):\n    \"\"\" Convert string to an int\n    >>> str_to_int('abc')\n    3\n    \"\"\"\n    return int(str_to_int(string))\nI think the point of the exercise is to write the shortest possible function.  I think this is the shortest.\n\nIt's not even a function.\n\nIt's not even a valid Python program.\n\nIt is, but it is not a function.\n\nIt's a valid Python program, but it's not a valid Python program.\n\nIt's a valid Python program, but it's not a valid Python program.\n\nIt's a valid Python program, but it's not a valid Python program.\n\nIt's a valid Python program, but it's not a valid Python program.\n\nIt's a valid Python program, but it's not a valid Python program.\n\nIt's a valid Python program, but it's not a valid Python program.\n\nIt's a valid Python program, but it's not a valid Python program.\n\nIt's a valid Python program, but it's not", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    return string.length\nI think this is more efficient.\n\nA more idiomatic Python way would be:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI'm not sure why it's supposed to be funny.\nBecause it's a joke about how a lot of code is written.\nIt's not a joke about how a lot of code is written. It's a joke about how a lot of code is written by people who have no idea how to write code.\nI'm not sure why you're being downvoted. I would say this is probably the truth.\nI'm being downvoted because I'm saying something that people don't want to hear.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThis is a great example of why you shouldn't use str.  It's a terrible idea to use a string as the length of another string.  Use a `size_t` instead.\n\nIt's also a good example of why you should use a string for a string.\n\nThis is a good example of why you should use a string for a string, because it will bite you.\n\nI'm not sure what you're getting at.\n\nI think the point is that the bug was caused by using str as a length of a string, and that using a string to represent the length of a string is a bad idea.\n\nI think you're both right. I was just trying to say that the bug was caused by using a string as a length of a string, and that using a string to represent the length of a string is a bad idea.\n\nThe Python version is more concise, and it doesn't use any magic numbers.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nThis is not a good example. strlen is not a function that has an obvious implementation in terms of len.\n\nI was using it as an example of a function that returns a type (int) that is defined elsewhere (len). I could have used the built-in len() function, but I wanted to use a built-in function that did not require me to import it.\n\nIn the first example, you can't use len(str) because it's not defined.\n\nYeah, that's my point. I could have used len() or strlen(), but I wanted to use a built-in function that did not require me to import it.\n\nI don't understand why you can't use len() or strlen().\n\nBecause I wanted to use a built-in function that did not require me to import it.\n\nI have to say I'm disappointed. I expected more than just \"This is not a good example.\"\n\nI don't understand what's wrong with the example. If you want to use a built-in function that does not require you to import it, then you can't use a function that is defined in a module that", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI see what you did there.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nWhat's the problem with that?\nThe problem is that it is a global variable.\nA global variable is not necessarily bad.   If you have a function that needs to access it, then you can't use a local variable, and so the only choice is to make it global.\nI know.   I was just explaining the \"problem\" to the person above.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThis is a terrible idea.\nYou should be using the built-in len() function instead.\n\nPlease explain why.\n\nBecause it's a terrible idea to write a function that is a thin wrapper around another function.\nThere is nothing wrong with writing a function that calls len() and returns the result.\n\nThat's a good idea. Thank you.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI don't get it. What's the joke?\n\nIt's a joke because the string is empty, so the length is 0, and the string is \"abc\", so the length is 3.\n\nI understand the joke, I just don't get why the example is funny.\n\nIt's funny because it's such a trivial thing to do, yet people still do it.\n\nI like this one.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThe string class is a bad example for this. The string class is not a basic type.\n\nIt's also a bad example because strlen is a function, not a method.\n\nThe string class is a bad example because it's a bad example.\n\nThere are lots of examples of bad examples in this thread.\n\nYou're right.\n\nI think the best example of a bad example is the OP's example.\n\nI think the best example of a bad example of a bad example is this comment.\n\nI think the best example of a bad example of a bad example of a bad example is this comment thread.\n\nI think the best example of a bad example of a bad example of a bad example is this comment thread of a bad example of a bad example.\n\nI think the best example of a bad example of a bad example of a bad example of a bad example is this comment thread of a bad example of a bad example of a bad example of a bad example.\n\nI think the best example of a bad example of a bad example of a bad example of a bad example is this comment thread of a bad example of a bad example of a bad example of a bad example.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nPython 3.x's str.length() will do this for you.\n\nPython 2.x's str.length() will do this for you, too.\n\nAnd in Python 1.5 it will return a string of the length of the string.\n\nI know. It was a joke.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nThis is wrong.  strlen() is a builtin function, not a function you wrote.\nYou can't pass it a string literal, you have to pass it a string object.       >>> str = \"abc\"      >>> strlen(str)      3\nI was just being silly.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __str__(self):\n        return str(self)\n   \n    def __add__(self, other):\n        if self._len > other._len:\n           raise ValueError(\"Lengths must be equal\")\n           return self._len + other._len\n   \n    def __len__(self):\n        return self._len\n\nSee also:\n\nstr.__len__()\nstr.__str__()</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThis is a common mistake.\nIt's not a mistake, it's an optimization. If you're not going to use the value you're storing, you don't need to store it.\nI'm not a Python expert, but I'm pretty sure that Python is a language where this optimization is unnecessary.\nI'm not a Python expert either, but I would have thought that if you're going to store something, you should store it.  If you're not going to use it, you don't need to store it.  If you're going to use it, you should store it.\nBut if you're going to use it, then you're going to use it.  If you're not going to use it, then you're not going to use it.  If you're going to use it, then you're going to use it.\nIf you're going to use it, then you're going to use it.  If you're going to use it, then you're going to use it.  If you're going to use it, then you're going to use it.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nIt's not just a function, it's an idiom.\n\nIt's an idiom in the same way that \"hello world\" is an idiom.\n\nI don't understand your comment.\n\nHe's saying that there's no point in using strlen() in the example, since it's not doing anything. It's just a demonstration of the syntax of a function call.\n\nThe point is that it's a demonstration of the syntax of a function call with a string argument.\n\nI'm not sure what the point is. I don't see how a demonstration of a syntax that is no longer used is helpful.\n\nThe point is that this is the Python way of calling a function with a string argument.\n\nI don't understand how this is useful.\n\nI think the OP is pointing out that the Python way is different from the C way.\n\nYes, but what's the point of that?\n\nI don't understand your question.\n\nI don't understand how this is useful.\n\nI don't understand how this is useful.\n\nI don't understand how this is useful.\n\nI don't understand how this", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nThis is the Python equivalent of `strlen(string)`, which is a function defined in the standard library.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nIn Python 3 this is now \"return string.len()\"</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return string.length\nI don't get it. Is it supposed to be funny?\nIt's a joke. Strings are immutable in Python, so if you try to modify them, you get an exception.\nAh, I see. I was thinking of some other language.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nDoesn't work in python 3.4. It's:      return len(string)\nAnd it's not strlen, it's len.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    return len(string)\n    \"\"\"\n    def main():\n    \"\"\" Main program\n    \"\"\"\n    \"\"\"\n    print('Enter a string: ')\n    string = raw_input()\n    print('Length of string: ', strlen(string))\n    print('Enter another string: ')\n    return 0\n    \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThis is a bad example because it's not idiomatic. If you want to get the length of a string, you should use str.length:\n>>> str.length('abc')\n3\n>>> 'abc'.decode('utf-8')[::-1]\n'abc'\n>>> str.decode('utf-8').length\n3\n>>> str.decode('utf-8').rjust(3)\n'abc'\n>>> 'abc'.rjust('abc')\n'abc'\n\nI would argue that the strlen example is a good example of the idiomatic style of python.\n\nI disagree. It's not idiomatic to use strlen in place of str.length. I've never seen it in the wild, and I've never seen it in the Python docs.\n\nI have seen it in the wild, and it's a useful example of why you should use str.length instead.\n\nThis article is really just a long list of common gotchas.\n\nNo, it's a list of common gotchas with code examples.\n\nThe only thing I'd add is that you should use the \"with\" statement when you're dealing with", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThis is a really bad example, because strlen is a C function, not a Python function.\n\nIt's a good example of how to use the C API from Python.\n\nNo, it's not. It's a bad example of how to use the C API from Python.\n\nWhy is it a bad example?\n\nThe first example is a C function. The second is a Python function.\n\nThat's the point. The first is a C function, the second is a Python function. The first is a good example of how to use the C API from Python. The second is a bad example of how to use the C API from Python.\n\nA function that returns the length of a string is not a C API.\n\nIt is a C API if the function is called strlen.\n\nIt's not a C API if it's called strlen.\n\nThe function is called strlen.\n\nIt's not a C API.\n\nIt's a C API.\n\nIt's not a C API.\n\nIt's a C API.\n\nIt's not a C API.\n\nIt's a C API.\n\nIt's not a C API", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI really hope this is a joke.\nWhat's wrong with it? It's a perfectly valid function.\nIt's a joke because strlen() is an built-in function in python, and he is just printing the length of a string.\nI don't think you understand how this works.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI'm not sure if this is a joke, but if it's not then I don't think it's a good idea to use Python's built-in functions for everything.\nI've seen people do this with the `string` module before.  I don't know if it's a joke.\nThe `string` module is a joke.\nI wish I could upvote you twice.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def is_string(string: str) -> bool:\n    \"\"\" Return whether the given string is a string\n    >>> is_string('abc')\n    True\n    >>> is_string('abcdefghijklmnopqrstuvwxyz')\n    False\n    \"\"\"\n    def is_empty(string: str) -> bool:\n    \"\"\" Return whether the given string is empty\n    >>> is_empty('abc')\n    True\n    >>> is_empty('abc')\n    False\n    \"\"\"\n    def is_one_of(string: str, pattern: str) -> bool:\n    \"\"\" Return whether the given string matches the given pattern\n    >>> is_one_of('abc', 'abc')\n    True\n    >>> is_one_of('abc', 'ab')\n    False\n    \"\"\"\n    def is_empty_string(string: str) -> bool:\n    \"\"\" Return", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI don't think this is a good example.\n\nI agree. I think the better example is:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def __str__(self):\n    \"\"\"Return the string representation of this object\"\"\"\n    return '%s: %s' % (self.__class__.__name__, self.__class__.__doc__)", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI'm not sure if you were being facetious or not, but this is actually a very good way to do it.\nWhy?\nI don't think it's a good idea to put \"return len(string)\" in the function's definition. It's more clear to do it in the function's body.\nI don't know why you're being downvoted.  This is the correct way to do it.  It's also the most common way to do it in C.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, s: str):\n    self.s = s\n    def length(self):\n    return len(self.s)\n    def __len__(self):\n    return self.length\n    return strlen", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI don't know about you but I'm pretty sure I'd use strlen on an empty string.\n\nI'm not sure about you but I'm pretty sure I wouldn't.\n\nI'm not sure about you but I'm pretty sure I don't care.\n\nI'm not sure about you but I'm pretty sure I'm not sure about you.\n\nI'm not sure about you but I'm pretty sure I'm not sure about me.\n\nI'm not sure about you but I'm pretty sure I'm not sure about you.\n\nI'm not sure about you but I'm pretty sure I'm not sure about me.\n\nI'm not sure about you but I'm pretty sure I'm not sure about you.\n\nI'm not sure about you but I'm pretty sure I'm not sure about me.\n\nI'm not sure about you but I'm pretty sure I'm not sure about you.\n\nI'm not sure about you but I'm pretty sure I'm not sure about me.\n\nI'm not sure about you but I'm pretty sure I'm not sure about you.\n\nI'm not sure about you but I'm pretty sure I'm not sure about", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __str__(self):\n    \"\"\" Return string representation of this function.\n    >>> str(strlen('abc'))\n   'strlen(abc)'\n    >>> __str__(strlen('abc'))\n   'strlen(abc)'\n    \"\"\"\n\nI like that the strlen function has no dependencies and is just a function.\n\nI like that it's not a function at all, and that the first argument is a string.\n\nWhat's the difference?\n\nA function is something that takes one or more inputs and returns one or more outputs.\nA method is something that takes one or more inputs and returns one or more outputs, and is defined in a class.\n\nIt's a function, but it's not a function.\n\nIt's not a function. It's a method.\n\nI'm not a Python programmer, but I thought that was the point of the \"with\" statement.\n\nIt is the point of the with statement. This is an example of the problem that the with statement is meant to solve.\n\nAh, ok. I've never used the with", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\n>I'm not sure what you're trying to do.\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>\n>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI find this very amusing.\nI'm not sure why.\nIt's the simplicity of it. It's like when you see a joke that is so simple it's funny.\nI find it amusing because it's so simple it's funny.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    if string == ''':\n       return 0\n    else:\n       return len(string)\nThis isn't the same as \"return len(string)\".\n\nI'd say it is.\n\nNo it isn't.\n>>> str.sub(0,1)\n'a'\n>>> len(str)\n1\n>>> str.sub(0,1)\n'b'\n>>> len(str)\n2\n\nI meant the _function_ is the same.\n\nThe function is the same, but the _behavior_ is different.\n\nI can't believe the author doesn't know that you can write a string as a hexadecimal number.\n>>> 'a'\n'0x61'\n>>> 'a'\n'0x61'\n>>> 'a'\n'0x61'\n\nWell, you can't.\n>>> 'a'\n'0x61'\n>>> 'a'\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError:'str' object is not iterable", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nThat's not a bad idea. But I think I would change it to:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nYou can also use \"isinstance(string, str)\" to determine whether the given string is a string or not.\n\nI don't like this one, because it's not the length of the string, but the length of the string's contents.\n\nThe length of the string's contents is the length of the string.\n\nIt's not really, though, is it? The string is a data structure. The contents of the string is a part of the string.\n\nI guess I don't understand what you're trying to say.\n\nThe string is a data structure. The contents of the string is data in the string. The length of the string is the number of bytes in the string. The length of the string's contents is the number of bytes in the string's contents.\n\nI think it's a bit of a stretch to say that the contents of the string are data in the string. The contents of the string are the characters that make up the string. The string itself is a data structure. It is not the same thing as the contents.\n\nThe string is a data structure. The contents of the string is data in the string. The length of the string is the number of bytes in", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI'm not sure why you would need to do this...       string.length() is the same as strlen(string).\nYes, but that's what I was taught.  I'm not sure if it's a good way to do it, but it is the way I was taught.\nIt's not.  It's a waste of time and it doesn't make your code any more readable.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI'm not sure what the point is.\n\nThe point is to compare the performance of string operations in different languages.\n\nThe point is to compare the performance of string operations in different languages.\n\n\"This is an extremely simple program, so there's not much to say about it.\"\nIs that the point?\n\nThe point is to compare the performance of string operations in different languages.\n\nThe point is to compare the performance of string operations in different languages.\n\nThe point is to compare the performance of string operations in different languages.\n\nThe point is to compare the performance of string operations in different languages.\n\nThe point is to compare the performance of string operations in different languages.\n\nThe point is to compare the performance of string operations in different languages.\n\nThe point is to compare the performance of string operations in different languages.\n\nThe point is to compare the performance of string operations in different languages.\n\nThe point is to compare the performance of string operations in different languages.\n\nThe point is to compare the performance of string operations in different languages.\n\nThe point is to compare the performance of string operations in different languages.\n\nThe", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nIt's a perfectly fine function, but it's not idiomatic Python.\nIn Python, you can just use string.length() to get the length of a string.\nIn Python 3, you can use the new str.count() function to get the length of a string.\n\nI've noticed that a lot of people who are new to Python (and who aren't familiar with the str.count() function) just do this:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nI'm not sure if you're serious, but that's actually the correct answer.\nNot really.  It's not \"strlen\" that's the problem, it's \"str\".\nYeah, but the question was about the shortest possible implementation of strlen.  The shortest possible implementation of strlen is the one that simply returns len(string) which is what I wrote.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThere's a lot more to it than that. \n\nThis is the best example of the difference between Python and C.\nIn C, strlen returns a value. In Python, strlen returns a function.\n\nIn C, strlen returns a value _and_ it's a function.\nIn Python, strlen returns a function _and_ it returns a value.\n\nYou're right. I was thinking of the value returned by strlen.\n\nI'm not sure if this is a joke or not, but I'll bite.\nIn C, strlen returns a value. In Python, strlen returns a function that returns a value.\n\nNo, in C, strlen returns a pointer to a function that returns a value.\n\nNo, in C, strlen returns a value and a pointer to a function that returns a value.\n\nNo, in C, strlen returns a value and a pointer to a function that returns a value and a pointer to a function that returns a value.\n\nNo, in C, strlen returns a value and a pointer to a function that returns a value and a pointer to a function that returns a value and a pointer to a function that", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nPython is a wonderful language.  It's the most readable language I've ever used.    The above is a perfect example of that.  It's a simple function that does a simple thing.    It's also very readable.    I can look at that and know exactly what it does.\nI am in no way a Python expert, but I think it is actually more readable than C++.  I have been working on a C++ project for a while now and it's a mess of complicated names and cryptic syntax.\nI think it's a lot more readable than C++.  And I don't think it's a matter of Python being better than C++, it's just that Python is a lot more readable than C++.  C++ is a very difficult language to read, and it's not that hard to write a language that's more readable than C++.\nI think C++ is a very difficult language to write, and it's not that hard to write a language that's more difficult to write than C++.\nI think C++ is a very difficult language to read, and it's not that hard to write a language that's", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nThis is why I love python. I can do stuff like this:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __repr__(self):\n    \"\"\" Return the string representation of this object.\n    >>> __repr__(strlen('abc'))\n    \"abc\"\n    \"\"\"\n    return \"%s(%d)\" % (self.__class__.__name__, self.__class__.__doc__.__str__)\n\nI don't understand why you need to use a tuple here?\n\nI don't get it either. I have never seen that before. I think that the author just made a mistake.\n\nI don't think so. It's a common idiom to use a tuple to express an anonymous function.\n\nIt's a common idiom to use a tuple to express a _function_, not an _anonymous_ function.\n\nTrue, but you can't really make a function that's not anonymous.\n\nYou can make a function that's not anonymous, and then call it anonymously.\n\nI don't know why you'd want to, though.\n\nIt's a nice way to group together a bunch of function calls for a common task.\n\nI'm not", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nThis is the correct answer. It's also the shortest.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    \"\"\"\n    def __str__(self):\n    \"\"\"Return a string representation of the object\"\"\"\n    return ''.join(str(self))\n    \"\"\"\n    \"\"\"\n    def __repr__(self):\n    \"\"\"Return a string representation of the object\"\"\"\n    return str(self)\n\nI don't know if it's a Python thing, but it's a little surprising that the \"def __str__\" and \"def __repr__\" are right next to each other. I was wondering why the \"def __str__\" was being called in the __repr__.\n\nI think it is a Python thing, and I don't really understand it.\nI've seen it before, but I don't know why it's done that way.\n\nIt's to make the output of the repr() function look nicer.\n\nI was expecting a joke about \"2.7.3\"\n\nThat's a good one! I'll have to remember that one.\n\nI like this kind of humour.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, s: str):\n        self.s = s\n    def __len__(self):\n        return self.s.length\n    def __str__(self):\n        return self.s\n   \nHow is this pythonic? I'm not asking to be snarky, I'm actually wondering.\nI think it's a bit weird that it's called `strlen` rather than `len`.\n\nI'm not a python expert, but I think it's a joke, and the post is a joke.\n\nI'm not a python expert either, but I don't think it's a joke. It's a real library that someone is using.\n\nThe link to the library is in the post.\n\nI can't find the link to the library.\n\nIt's a joke. It's not a real library.\n\nI thought so too, but the post is in a library's issue tracker.\n\nIn case you missed it, the library is a joke. It's not a real library.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\n\nI'm not a python programmer, but I'm pretty sure the second one is wrong.\n\nIt's not. Python has a built in function for that, so the second one is just an example of using it.\n\nIt's not that the first is wrong, it's that the second is the wrong way to do it.\n\nThe second one is actually correct.\nstrlen returns the number of characters in a string, not the number of bytes.\nThe first one is wrong because it's using the built in function str() which returns the string representation of a number (usually a unicode string) and not the number itself.\n\nI'm not sure if that was supposed to be a joke or not, but if it wasn't, it's wrong.\n\nIt's wrong, but it's a joke.\n\nI was hoping it was a joke, but I wasn't sure.\n\nI think it's a joke.\n\n\"The C++ standard library is a collection of well-tested, high-quality, free, portable, and efficient libraries, that can be used to develop modern C++ programs. The C++ standard library is the foundation of", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n\nI'm not sure if this is a troll, or if the author really doesn't understand Python's strlen function.\n\nI think he's making fun of the fact that in Python, string.length() is a function, whereas in C, it's a macro.\n\nI was, but I guess it was too subtle.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\n> def strlen(string):\n> return len(string)\n>\n>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\n>>>\nHow is this better than the built-in `str.length`?\nIt's not. It's a hack that's usually used to prevent name clashes between packages that define `str.length` and packages that define `str`.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    return len(string)\nThis is the correct answer.  I don't know why people are suggesting to use `int` instead of `str`.  The length of the string is `int` and the string is a `str`.  It is not a `str * int`.\n> I don't know why people are suggesting to use int instead of str.  Because it's a common beginner mistake.  I've seen a lot of people who think they're clever by using `int` to convert a `str` to an `int`.  It's a very bad habit to get into.  It's much better to use the correct type for the job.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def length_of_string(string: str):\n    \"\"\" Return length of given string\n    >>> length_of_string('abc')\n    3\n    >>> length_of_string('abcdefg')\n    6\n    \"\"\"\n    return len(string)\n    if __name__ == '__main__':\n    print(\"length_of_string:\")\n    print(\"strlen(''):\")\n    print(\"strlen('abc')\")\n    print(\"length_of_string('abcdefg')\")\n\nThis is one of my favorites.  I remember it from a C book I read in high school.\n\nstrlen('abc')\nThis is the one I use most often.\n\nThis one is a little different, but I find it useful in a lot of situations:", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __init__(self, string: str) -> None:\n    \"\"\" Create a new strlen() object\n    >>> strlen = strlen()\n    >>> strlen('abc')\n    3\n    \"\"\"\n    self.string = string\n    self.length = 0\n    def __len__(self):\n    \"\"\" Return the length of the given string\n    >>> strlen.__len__()\n    3\n    \"\"\"\n    return self.string.len()\n\nThis is a very bad code snippet.\n\nIn the original article, the author goes on to say:\n\"This is an example of a terrible practice, but it is not the fault of Python. In this case, the developer used the built-in strlen() function to calculate the length of a string. This is a very slow way to do it. The correct way to calculate the length of a string is to use the built-in len() function. The following code snippet shows how to do it:\n>>> strlen = len()\n>>> strlen('abc", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __str__(self):\n    \"\"\" Return the string representation of this object.\n    >>> str(strlen(str))\n    \"strlen(str)\"\n    \"\"\"\n    return str(self.__class__.__name__)\nI'm not sure why this is a good idea. The name of the class is strlen, not strlen(str).\n\nI can't help but think that this is a bad idea.\n\nI'm not sure why this is a bad idea.\n\nIt's a bad idea because the name of the class is strlen, not strlen(str).\n\nI'm not sure why this is a bad idea.\n\nIt's a bad idea because the name of the class is strlen, not strlen(str).\n\nI'm not sure why this is a bad idea.\n\nIt's a bad idea because the name of the class is strlen, not strlen(str).\n\nI'm not sure why this is a bad idea.\n\nIt's a bad idea because the name of the class is strlen, not strlen(str).", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def __getitem__(self, index: int):\n    \"\"\" Return the item at the given index\n    >>> str = ''\n    >>> str[0]\n    'a'\n    >>> str[1]\n    'b'\n    >>> str[2]\n    'c'\n    >>> str[3]\n    'd'\n    \"\"\"\n    return str[index]\n    def __len__(self):\n    \"\"\" Return length of string\n    >>> str = 'abc'\n    >>> str.__len__()\n    3\n    \"\"\"\n    return len(self)\n    def __str__(self):\n    \"\"\" Return string\n    >>> str = str.__str__()\n    >>> str\n    'abc'\n    >>> str.__str__()\n    'abc'\n    \"\"\"\n    return self\n\nThis is a very simple example of", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    if __name__ == '__main__':\n        print strlen('')\n        print strlen('abc')\n\nI'm not sure what you're trying to achieve here, but it looks like you're trying to do something that you shouldn't be doing in Python.\n\nI'm trying to make the program print the length of a string (without spaces) and the length of a string with spaces.\n\nYou can't print the length of a string with spaces.\n\nI think you might be able to do this if you use the pre-compiler, but I'm not sure.\n\nYou're not going to be able to do this without using the pre-compiler.\n\nThanks, I'll try that.</s>", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"\n    def len(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> len('abc')\n    3\n    >>> len('abcdefghijklmnopqrstuvwxyz')\n    6\n    \"\"\"\n    return strlen(string)\n\nI don't understand why the len() function returns an int.\n\nBecause it's a function, and functions are supposed to return values.\n\nWhy an int?\n\nBecause it's a function, and functions are supposed to return values.\n\nWhy an int and not a float or a list of chars?\n\nBecause it's a function, and functions are supposed to return values.\n\nWhy not a float and why not a list of chars?\n\nBecause it's a function, and functions are supposed to return values.\n\nWhy not a float and why not a list of chars?\n\nBecause it's a function, and functions are supposed to return values.\n\nWhy not a float and why not a list of chars?\n\nBecause it's a function, and functions are supposed to return values.", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\"", "def strlen(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> strlen('')\n    0\n    >>> strlen('abc')\n    3\n    \"\"\" \"\"\""]]