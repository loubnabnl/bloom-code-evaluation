[["def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n    def bracket(bracket: str):\n    \"\"\" returns a string with all matching brackets removed, e.g.\n    >>> correct_bracketing(\">(<\")\n    \"<(\"\n    \"\"\"\n    return bracket.match(\".<\").strip()\n    \"\"\"\n    if correct_bracketing(brackets):\n    return brackets.strip()\n    else:\n    return brackets.join(\",\")\n\nWhat about this one:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nBeautiful.\n\nI've been writing a lot of code lately that has recursive nested loops, and this is a beautiful little piece of code that I'm gonna be using.\n\nBetter alternative: \n\nEven better alternative:\n\nWhy does that second one return False?\n\nBecause there are no opening brackets.\n\nWhen I tried it, I got the following error:\nTypeError: __main__ is not a function\n\nI got it too.\n\nIt's not called correct_bracketing, so it isn't a correct function.\n\nYou should have named it correct_bracketing then.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    if not brackets.lower():\n        raise TypeError(\"bracketing must be a valid string\")\n    return True\n\nIt's hard to believe anyone who has ever written a programming language of any significant complexity could write code like that.\n\nThe true story of C:\nC is the C of programming languages.\n\nIt's not a bad article, but I don't understand the connection between Python and C here.\n\n\"There are only two hard things in Computer Science: cache invalidation, naming things, and off-by-one errors.\"\n\nPython has a \"correct_bracketing\" function.\n\n\"There are only two hard things in Computer Science: cache invalidation, naming things, and off-by-one errors.\"\n\nThis has been my desktop background for some time now.\n\nSame here!\n\nThe only truly accurate part of that is the last line.\n\nOh my. I'm still giggling.\n\nThis is beautiful, thank you.\n\nDoes anyone know who wrote this?\n\nIt's by Jeff Atwood, the co-founder of Stack Exchange. I don't think he did it", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n    def correct_bracketing_nested(brackets: str):\n    \"\"\"\n    brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket,\n    and every nested bracket has a corresponding nested bracket.\n    \"\"\"\n    return correct_bracketing(brackets) and correct_bracketing_nested(brackets)\n    I think this will do what you want.\nThanks for your help. I just tried it and it worked. I had to change       if every opening bracket has a corresponding closing bracket.        to       if every opening bracket has a corresponding closing bracket, and every nested bracket has a corresponding nested bracket.      But it is fine now. Thanks for your help.\nYes. I think this is more correct. I didn't know the difference between bracketing and nesting at the time I posted the code.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing_with_optional_underscore(brackets: str, optional_underscore: str):\n    \"\"\" This is similar to correct_bracketing, but it returns True if every opening\n    bracket has a corresponding opening bracket or an opening bracket followed by an\n    opening bracket with an optional underscore.\n    \"\"\"\n\n    # parse the brackets\n\n    # if the first bracket is not followed by an opening bracket or an opening\n    # bracket with an optional underscore, then it is the end of the string.\n    if not first_bracket in brackets and first_bracket!= '_' or first_bracket!= '<'\n         return False\n    # if the first bracket is an opening bracket with an optional underscore,\n    # then we want to remove the underscore.\n    if first_bracket in brackets and first_bracket == '_' or first_bracket == '<'\n         first_bracket = first_bracket.replace(first_", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_nonbracketing(nonbrackets: str):\n    \"\"\" nonbrackets is a string of \"(\" and \")\".\n    return True if every opening \"(\" has a corresponding \")\".\n    >>> correct_nonbracketing(\"(\")\n    True\n    >>> correct_nonbracketing(\"\")\n    True\n    >>> correct_nonbracketing(\"(\")\")\n    False\n    \"\"\"\n\nI'm sorry, this is just silly.\nAlso, his \"python\" code has a syntax error in it.\n\nThat may be, but I don't see how it's relevant. The problem is with the language's semantics, not with his coding style.\n\nIt's relevant if he's looking to make the case that python's string comparisons are \"broken\" because of his sloppy code.\n\nHe's not looking to make that case. He's looking to show how something as trivial as adding a couple of newlines can change a comparison from True to False.\n\nExcept that it doesn't. It only does that if you use a function that ignores whites", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nThis is fine.  Don't make fun of it.\nYou have an example of a legitimate use of it.\n\nThat's an interesting one. I'd never thought about using `correct_bracketing` in a larger context.\nI guess it's good to know it's there, but I don't really see a reason to use it, since you could just do:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing_with_indent(brackets, indent: int, start, end: str):\n    \"\"\" correct_bracketing(brackets, indent, start, end)\n    if start == end: return True\n    if not indent:\n        return True\n        else:\n        return (indent == 0)\n    \"\"\"\n\nA subtle error in the implementation of correct_bracketing:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nI'm fairly sure I've done this before, but I had to look it up to get the syntax correct.\n\nYep. I did this in python, but without the quotes:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n    \"\"\"\n\nCorrect, but using str.lower() would have been shorter and clearer:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nMost languages don't have this problem, they just have one single quote character, so they can't have the problem to begin with.\n\nThis reminds me of the contortions Java programmers are forced to perform when using c-style strings with single quotes.\n\nAs far as I know, the standard \"string literal\" in Java has always been an `String` object, not a `String` literal.\n\nThat's true, but you can still do:\n\"abc\"\"abc\"\"abc\"\"abc\"\"abc\"\"abc\"\"abc\"\"abc\"\"abc\"\nWhich is a string literal and not a String object.\n\nWould it have killed them to just call it \"bracket_match\"? It's very intuitive.\n\nit's the Pythonic way. In Python, you write more readable code than in other languages, with the (very minor) downside that it takes longer to write.\n\nIt's not just pythonic, it's also good design. You want your code to be intuitive and easy to read, and that's certainly not the case with this function.\n\nWhy is the English version \"correct bracketing\", and the Python version \"correct_bracketing\"?\n\nI don't know", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    if len(brackets)!= 2:\n        return False\n\nThis code is only correct for the following:\n<\n>\n\nIt's not correct for these:\n<\\<\n<\\<\\<\n<\\>\n\nYou could add more code to detect some of the other bracket types, but it\nwould be a little messy and the general technique is not very reliable.\n\nYou are right! This code is not perfect. I hope to improve it.\n\nI did not look at the code, but I guess it's very naive, and so will\nproduce false positives.\nSo you could come up with a solution that is correct for the most common\nbrackets, like these:\n<\n>\n(\n)\n\n(\n)\n\nand so on.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nThis should have been named bracket_correcting or something, because \"correcting\" is the wrong word here.\n\nWhat it is doing is just taking the first opening bracket and then looking for a closing bracket. If it doesn't find a closing bracket, it returns False. If it finds a closing bracket, it returns True.\n\nThat's called \"bracketing\" (and there's a method on the string class to do it, too). \"Correcting\" would be if it were actually correct.\n\nI think it's reasonable to call this \"correct\". If there is a closing bracket (or no opening bracket) it returns True.\nIf there is no opening bracket, it returns False.\n\nIn this case, \"correct\" should be used in a sarcastic sense.\n\nThis isn't correct either, because the closing bracket is optional in C. The correct implementation would be to check that the string is correct in a general sense and not specific to C.\n\nI don't think it's correct to say that it's not correct. It is \"correct\" in the sense that it returns True if the string is correct.\n\nI can call my method correct_bracketing that simply takes a", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nHow is that possible? Shouldn't it be False for the first one?\n\nThere's a closing bracket, it just happens to be outside of the string (there's also a closing bracket after the closing bracket in the second case).</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nThat's not how I would do it. I would use", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nI have never done python, but isn't that the whole point of the language to make the syntax as un-verbose as possible?\n\nPython's syntax is verbose in some places, but to be honest it's not any more verbose than most of the other major languages I've used.\nAnd this is only in one place anyway; the rest of the syntax is quite nice.\n\nThe Python syntax is quite verbose compared to something like Scheme, but it's also a lot more elegant and flexible.\n\nYeah, Scheme is nice because you can have a lot of power in a very few characters. It does get ugly when you start writing macros though...\n\nMacros are one of the best things about Scheme.\n\nI think it's a great feature, but it's a lot more verbose than writing a function in Python.\n\nYou're right, but it's not that much more verbose. The reason it gets ugly is that it's not built-in.\n\nI wrote this a while back, based on a previous version in Perl:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing_2(brackets: str):\n    \"\"\"\n    This is a shortcut for correct_bracketing that only checks the first pair of\n    opening and closing brackets.\n    >>> correct_bracketing_2(\"<>\"):\n    True\n    >>> correct_bracketing_2(\"<>\")\n    True\n    \"\"\"\n\n    def remove_bracketing(brackets: str):\n    \"\"\"\n    Removes all the brackets from the given string and returns the remaining\n    text.\n    >>> print(\"text\")\n    text\n    >>> remove_bracketing(\"<>\")\n    text\n    \"\"\"\n    def remove_bracketing_2(brackets: str):\n    \"\"\"\n    Removes all the brackets from the given string and returns the remaining\n    text.\n    >>> print(\"text\")\n    text\n    >>> remove_bracketing_2(\"<", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nHow is it that people still get code like this wrong when Python provides two different correct implementations?\n>>> correct_bracketing(\"<\")\nTrue\n>>> correct_bracketing(\"<>\")\nTrue\n>>> correct_bracketing(\"><<>\")\nFalse\n(Note that the last one is not the same as the second one.)\n\nThe testcases are not equivalent, and the second one is not the same as the first. It's the first one that is correct.\nThe first one will also catch the second one, since the second one does not have any brackets in the first position, but the third test case does.\n\nYes, I was about to say that. It is equivalent to this:\n>>> correct_bracketing(\"<\") and correct_bracketing(\"<>\")\nTrue\n\nActually, that should be\n>>> correct_bracketing(\"<\") and not correct_bracketing(\"<>\")\nFalse\nsince the actual correct_bracketing method will call the second one.\n\nI'm not sure what this is doing, but it's not correct-bracketing:\n>>> correct_bracketing(\"<<<>\")", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    return correct_bracketing(brackets)", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing_all(brackets: str):\n    \"\"\" correct_bracketing returns True if every opening bracket has a corresponding closing bracket.\n    This correct_bracketing_all finds all occurrences.\n    >>> correct_bracketing_all(\"<\")\n    0\n    >>> correct_bracketing_all(\"<>\")\n    1\n    >>> correct_bracketing_all(\"<<><>>\")\n    3\n    >>> correct_bracketing_all(\"><<>\")\n    2\n    \"\"\"\n\n    return lambda x: x.lower() == brackets.upper()\n\nThe function correct_bracketing is idempotent:\n\n    >>> correct_bracketing(correct_bracketing)\n    True\n    >>> correct_bracketing(correct_bracketing)\n    True\n    >>> correct_bracketing(correct_bracketing)\n    True\n    >>> correct_bracketing(correct", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n> def correct_bracketing(brackets: str) -> bool:\n    \"\"\" correct_bracketing is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n> \"\"\"\nThat's a cute trick. It reminds me of this: \nThe idea is that if you can write a program that will automatically\nwrite a correct program for you, then it will also automatically\nwrite a program that will automatically write a program that will\nautomatically write a program that will automatically write a program\nthat will automatically write a program that will automatically write\na program that will automatically write a program that will\nautomatically write a program that will automatically write a program\nthat will automatically write a program that will automatically write\na program that will automatically write a program that will\nautomatically write a program that will automatically write a program\nthat will automatically write a program that will automatically write\na program that will automatically write a program that will\nautomatically write a program that will automatically write a program\nthat will automatically write a program that will automatically write\na program that will automatically write a program that will\nautomatically write a program", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing(brackets: str, correct: bool = False):\n    \"\"\" if correct is True, then if there is an opening bracket that\n    doesn't have a closing bracket, then add a closing bracket.\n    return correct_bracketing(brackets, correct)\n    \"\"\"\n\n    try:\n        if len(brackets) == 0:\n           raise ValueError(\"must have at least one opening bracket\")\n        else:\n           for sublist in brackets:\n              if not correct:\n                  add_closing_bracket(sublist)\n            else:\n                  correct_bracketing(sublist)\n             finally:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nI would have used a list comprehension and named the list.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nThis is what I was looking for. It is simple, concise and is exactly what I need. Thank you so much!</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nAs I read this, correct_bracketing is a True function.\n\nTrue.\n\nNo, not really.\nWhat if the original string had an extra closing bracket?\nI can't find any way to test for this.\n\nYou could go back and forth on this forever. The point is that the author is trying to teach you how to approach the problem yourself.\n\nTo me it is a simple toy example. There are two ways to pass this test:\n1\\. don't make mistakes like the author did\n2\\. make an assert that the error case is also tested for\nThe author showed us option 1.\n\nIn this case, the error case is also tested for:\n>>> correct_bracketing(\"<\")\nFalse\n\nThat's not correct_bracketing, that's correct_bracket_free.\n\nIt's correct_bracket_free_or_empty, which is what the author was actually using.\n\nI have to say, I think it is unfair to test people on parsing. It is a separate skill that has no place in a programming test. It is almost never a real world problem.\nI don't expect to be good at parsing", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    \"\"\" This is a test case for correct_bracketing.\n    \"\"\"\n\n         print correct_bracketing(\"><\")", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nI don't get it. How is this a unix thing?\n\nIt's not, it's a Python thing. I suspect the OP made a mistake.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def count_blank(x):\n    \"\"\" count blank lines in the string, then return the number of blank lines.\n    \"\"\"\n    return x.find(' ').count()\n\n    def count_non_blank(x):\n    \"\"\" count non blank lines in the string, then return the number of non blank lines.\n    \"\"\"\n    return x.find(' ').count()\n\n    def main():\n    \"\"\" main function\n    \"\"\"\n    count_blank(' ')\n    count_non_blank(' ')\n\nOutput:\n    1      2      3      4\n\nIf you want to read more, there is a whole chapter on Python's string methods in the online book _Practical Python_ :\n\nMaybe I'm missing something, but I don't see how this is different from simply using the 'find' function.\n\nIt's \"correct bracketing\" not \"correct finding\".\n\nI see. Thanks for the clarification.\n\nI wrote a (perhaps", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n    def is_closed(brackets: str):\n    \"\"\" This returns True if all the opening brackets have a corresponding closing\n    bracket.\n    >>> is_closed(\"<\")\n    True\n    >>> is_closed(\"<<<\")\n    True\n    >>> is_closed(\"<>\")\n    True\n    >>> is_closed(\"<>>\")\n    True\n    >>> is_closed(\"<<<<<>>\")\n    False\n    >>> is_closed(\"<<<>\")\n    True\n    >>> is_closed(\"<<<<>>\")\n    True\n    \"\"\"\n    def is_open(brackets: str):\n    \"\"\" This returns True if at least one opening bracket is matched by a closing\n    bracket.\n    >>> is_open(\"<\")\n    True\n    >>> is_open(\"<<<\")\n    False\n    >>> is_open(\"<<<>>\")\n    True", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    # A simplification of the original algorithm.\n    # It's not guaranteed to work for all languages.\n    def correct_bracketing(brackets: str, match_if: str):\n    if match_if == \"<<\" and match_if == \">>\":\n        return True\n    if match_if == \"<<\" and match_if == \">>\":\n        return True\n    if match_if == \"<<\" and match_if == \">>>\":\n        return True\n    if match_if == \"<<\" and match_if == \">>\":\n        return True\n    if match_if == \"<<\" and match_if == \">>>\":\n        return True\n    if match_if == \"<<\" and match_if == \">>>\":\n        return True\n    if match_if == \"<<\" and match_if == \">>>\":", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing(brackets):\n    \"\"\" return True if there is a corresponding closing bracket for every opening\n    bracket.\n    \"\"\"\n    return brackets in reverse()\n\nSomething about Python not liking empty lists and making me sad</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nSo it appears that your definition is actually equivalent to what you're complaining about.\n\nI don't know why you're getting downvotes. You're completely correct.\n\nWhy is the original post using a string of opening and closing quotes rather than an actual open and close bracket?</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n> correct_bracketing(\"<\")\n> True\n> correct_bracketing(\"<>\" )\n> True\n> correct_bracketing(\"<>\")\n> True\n> correct_bracketing(\"<\")\n> False\n\n>>> correct_bracketing(\"<\")\nFalse\n>>> correct_bracketing(\">\")\nTrue\n\n>>> correct_bracketing(\">\")\nTrue\n\n>>> correct_bracketing(\"><<>\")\nFalse\n\n>>> correct_bracketing(\"><<>\")\nFalse\n\n>>> correct_bracketing(\">\")\nTrue\n\n>>> correct_bracketing(\">\")\nTrue</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n    def is_valid_bracketing(brackets: str):\n    \"\"\" Test if brackets is a valid bracketing string\n    >>> is_valid_bracketing(\"<\")\n    True\n    >>> is_valid_bracketing(\"<>\")\n    True\n    >>> is_valid_bracketing(\"<<><>>\")\n    True\n    >>> is_valid_bracketing(\"\"><<>\")\n    True\n    \"\"\"\n    if len(brackets) == 2:\n        return False\n    else:\n        return is_valid_bracketing(brackets)\n\nSo, it's a valid string of \"<\" and \">\" if it's either \"<\" or \">\" followed by a single \"<\" or a single \">\". It's a valid bracketing string if it's one of \"<\" or \">\" followed by a single \"<\" or a single \">\".\n\nNote that the \"if len(brackets) == 2\" is because \"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nI'm a little confused as to what this does. It appears that it returns True if the two brackets are the same, but False if they are different. I would've expected it to return True when there are no brackets. Is there some meaning to the string of brackets that I am missing?\n\n(I'm not very good at programming, but I am trying to learn.)\n\nCorrect_bracketing is an example of a function that returns the boolean complement of a given boolean. If you wanted to determine if every opening bracket has a corresponding closing bracket, you could use it like so:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    return True\n\nHmmm... So it fails to detect the empty ones, but it's an interesting way to do it.\n\nI was thinking to write something like this, but my problem was that the brackets can't be repeated, so I thought it would be hard to detect a bracket.\n\nyeah, that's a problem. If you read the source, it works by detecting brackets by finding the first '>' and the last '<' and then only comparing if there is a matching '>' or '<'\n\nI think a better way to do it is to find the pair of opening and closing brackets that have the maximum string length. Then if there is a shorter string, you have a non-bracket.\n\nfor (int i = 0; i < brackets.length; i++) {\n    if (brackets[i] > brackets[i - 1]) {\n        if (brackets[i - 1] <= '<') {\n           return True;\n    }\n        if (brackets[i - 1] > '>')", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    import sys\n\n    def check_bracketing(str: str):\n    \"\"\" check_bracketing takes a string as argument.\n    It returns True if there are no opening brackets without a matching closing bracket.\n    >>> check_bracketing(\"<\")\n    False\n    >>> check_bracketing(\"<>\")\n    True\n    >>> check_bracketing(\"<<><>>\")\n    True\n    >>> check_bracketing(\"\"><<>\")\n    True\n    \"\"\"\n\n    return [str.match(r\"<\\s*([^>]+)<\\s*(?<!>\\s*)*\\s*>>\")]\n\nSo your point is what? That a single Python programmer can't read and implement a small recursive function that is used all over the language?\n\nI'm glad you like it, but you don't need to be a condescending dick about it.\nI know you're proud of your little recursive function, but it doesn't do what it says it does.\n\nLooks", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing_with_dashes(brackets: str):\n    \"\"\" brackets is a string of < and >.\n    if every opening bracket has a corresponding closing bracket and the\n    matching brackets are separated by 2 or more dashes, return True\n    if the matching brackets are separated by only one dash, return True\n    otherwise return False\n    \"\"\"\n\n    def correct_bracketing_with_dashes_longer_than_one_character(brackets: str):\n    \"\"\" brackets is a string of < and >.\n    if every opening bracket has a corresponding closing bracket and the\n    matching brackets are separated by 2 or more dashes and the matching\n    brackets are separated by 2 or more dashes and the matching brackets\n    are separated by 2 or more dashes and the matching brackets are separated\n    by 2 or more dashes and the matching brackets are separated by 2 or more\n    dashes and the matching brackets are separated by 2 or more dashes and\n    the matching brackets are separated by", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def first(s: str):\n    \"\"\" return the first substring of s\n    return s[:len(s)]\n    >>> first(\"dear\")\n    \"d\"\n    >>> first(\"dear\")\n    \"dear\"\n    >>> first(\"dear\")\n    \"dear\"\n    \"\"\"\n\n    def second(s: str):\n    \"\"\" return the second substring of s\n    return s[1:]\n    >>> second(\"dear\")\n    \"e\"\n    >>> second(\"dear\")\n    \"d\"\n    >>> second(\"dear\")\n    \"dear\"\n    \"\"\"\n\n    def third(s: str):\n    \"\"\" return the third substring of s\n    return s[2:]\n    >>> third(\"dear\")\n    \"e\"\n    >>> third(\"dear\")\n    \"d\"\n    >>> third(\"d", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nIf this doesn't work for you, you are probably using python 3.0 and should upgrade to 3.1</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nDefinitely not pythonic, but it's a nice hack.\n\nHey, there's nothing wrong with that. It's a pretty good way to test if a\nlist of brackets are balanced.\n\nExcept it's not. It doesn't take into account parentheses, so it's only\nhalf as good as it could be.\n\nHow can a list of brackets be balanced if it doesn't have parentheses?\n\nIn terms of the grammar, it is possible to construct balanced expressions\nusing unbalanced parens. For example, consider this expression:\n(x+y)(+z)\nI don't think it's possible to create a balanced expression using unbalanced\nbrackets.\n\nThis is an interesting hack, but isn't a very good solution. For example,\nit doesn't handle parentheses, so the expression\n(x + y)(+ z)\nis considered balanced.\n\nIt would be nice to have a built-in test for this, but it's too simple to\njust use a for loop.\n\nIt's not too simple. I think it's a perfect candidate for built-in\nsupport.\n\nI think it's a little overkill for Python to have a", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nIs there any reason you're not using a counter to figure out if there's a match or not?\n\nThere's probably a shorter way, but here's an alternate (which I posted in a similar thread a while back):\n\nfrom string import substring", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nGood catch!\n\nI think the problem is that he's using'return True if' instead of'return True if and only if'.\n\nIt's not a problem. He's using a heuristic to make sure that the two bracketed conditions are the same. If they are, the heuristic will return True. But it will also return True if you have a mismatched opening and closing bracket.\n\nI think he's getting at the problem that \"if every opening bracket has a corresponding closing bracket\" is not the same as \"if every opening bracket has a corresponding closing bracket _and_ the two conditions match\".\n\nThat is what the heuristic is for: to check if the two bracketed conditions are the same.\n\nYeah, I'm just saying that your statement that \"he's using'return True if' instead of'return True if and only if'\" is a little bit misleading, because the latter is not a problem, and it's not what the parent comment is pointing out.\n\nA better solution would be to use a dictionary of pre-defined strings, and then you could more easily extend the number of brackets supported.\n\nThat is exactly what the author has done. The dictionary is the", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nI don't understand why \"<<>\" isn't a valid string, but \"<<<\" is.\nI also think that the function should return True if every opening bracket is followed by a corresponding closing bracket. I mean, it's not that surprising that a < and a > have a matching closing bracket. But what about other combinations?\nI'm still very confused.\n\nThis is a good example of how the Python community has forgotten the importance of naming.\n\nNo, it's just a bad example of naming. It is incredibly rare for functions in Python to have _exactly_ the same name as the function they are implementing. I could do it, but I would be violating PEP8.\n\nAnd it's also incredibly rare that I write Python code that uses the bracketing operator.\n\nYou do realize that it's in the standard library, right? So it's not \"incredibly rare\" to use it. It's not like I'm going out of my way to use a function called \"correct_bracketing\".\n\nPerhaps my use of \"rare\" is wrong. In my experience, it is rare that I'm forced to write code that has to use the bracketing operator.", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n    if len(brackets) == 0:\n       return False\n    for bracket in brackets:\n       if bracket not in ['<']:\n          return False\n    return True\n\nYou can save yourself a lot of if statements by switching to using the regular expression module, which is included in python. Here's an example:\nfrom re import re\nfor line in open(\"input.txt\"):", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def open_bracket(s: str):\n    \"\"\" return True if s is an opening bracket.\n    \"\"\"\n\n    def close_bracket(s: str):\n    \"\"\" return True if s is a closing bracket.\n    \"\"\"\n\nAnd here's a simple function for string comparison.", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n    def is_closed(s):\n    if s.find(\",\"):\n       return False\n    return s.find(\")\").find(\",\") == 0\nI find the second version hard to read. I prefer the first version.\n\nThis is an implementation of a trivial algorithm. It's so trivial that", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nI like how they're using the ternary operator to check for the existence of a closing bracket.  I've never been a fan of doing this.\n\nPython has a handy built in function for this.\n\nPython has _so_ many handy built-in functions for things like this. If only the syntax was more Pythonic...\n\nI think the syntax is pretty pythonic.\n\nI don't like the way the ternary operator looks - it always feels like I am programming in a low level language.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n    def correct_bracketing_ok(brackets: str):\n    \"\"\"brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_ok(\"<\")\n    True\n    >>> correct_bracketing_ok(\"<>\")\n    True\n    >>> correct_bracketing_ok(\"<<><>>\")\n    True\n    >>> correct_bracketing_ok(\"><<>\")\n    True\n    \"\"\"\n    def correct_bracketing_ok_no_break(brackets: str):\n    \"\"\"brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n    >>> correct_bracketing_ok_no_break(\"<\")\n    True\n    >>> correct_bracketing_ok_no_break(\"<>\")\n    True\n    >>> correct_bracketing_", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_brace_opening(brace: char):\n    \"\"\" brace is a single character.\n    return True if it is a valid opening brace.\n    >>> correct_brace_opening(\"{\")\n    True\n    >>> correct_brace_opening(\"<\")\n    False\n    >>> correct_brace_opening(\"<>\")\n    True\n    >>> correct_brace_opening(\">>>\")\n    False\n    \"\"\"\n\n    def correct_brace_ending(brace: char):\n    \"\"\" brace is a single character.\n    return True if it is a valid closing brace.\n    >>> correct_brace_ending(\"{\")\n    True\n    >>> correct_brace_ending(\"<\")\n    False\n    >>> correct_brace_ending(\"<>\")\n    True\n    >>> correct_brace_ending(\">>>\")\n    False\n    \"\"\"\n\n    def correct_if_in_pair(brackets, brace: char):", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def left_right_bracket(brackets: str):\n    \"\"\" return True if every opening bracket has a corresponding closing bracket,\n    otherwise False\n    \"\"\"\n    for c in brackets:\n       if c == \"<<\" and c == \">\" and c!= \"</\":\n          return False\n    else:\n          return c == \">>\" or c == \"<<\"\n    return False\n\n    def bracket_min_length(brackets: str):\n    \"\"\" return len(brackets) == 3\n    \"\"\"\n\n    def bracket_max_length(brackets: str):\n    \"\"\" return len(brackets) > 3\n    \"\"\"\n\n    def is_bracketing(brackets: str):\n    \"\"\" return True if every opening bracket has a corresponding closing bracket.\n    \"\"\"\n    if len(brackets) == 0:\n       return False", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def bracket(s: str):\n    \"\"\"\n    For each \">\" in brackets, return the first character of the string between them.\n    >>> bracket(\">>\")\n    \">>\"\n    >>> bracket(\">>>\"\")\n    \">>>\"\n    >>> bracket(\"\">\")\n    \"> \"\n    >>> bracket(\"\">\">\")\n    \">>>\"\n    >>> bracket(\"\">\">\">\")\n    \"> > >\"\n    \"\"\"\n\n    return s[0]\n\nThe bracket function could be written as", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n...you win the internets.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nYeah, I've seen that trick before, but it's a good one.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nI've always been partial to:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nI believe that this would be the correct solution:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nDoes it return True or False for this:\n>>> correct_bracketing(\"<\"\"\"+\"\"<\"\"<\"\"\"+\"\">\")\n>>> correct_bracketing(\"<\"\"\"+\"\"<\"\"<\"\"\"+\"\">\")\n\nIt returns True for the first one and False for the second one, since the first one is a valid open-brace-followed-by-an-open-brace, but the second one is an invalid open-brace-followed-by-a-close-brace.\n\nVery neat! Thank you for that!\n\nThis is a \"code smell\". You're trying to abstract something that is not inherently abstract, and the result is not very clear. The original code is very clear, it's just short.\n\nThere's nothing wrong with abstracting things that are not inherently abstract. That's the whole point of abstraction.\n\nI did not mean to imply there was anything wrong with it. I'm saying that sometimes the abstraction can be difficult to understand and you should be cautious about doing it.\n\nI don't like the whole 'code smell' meme, but the fact that your function is non- deterministic can be a problem when you need to debug.", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing_by_scanner(brackets, scanner: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    \"\"\"\n    with open(brackets) as f:\n       for br in f:\n          scanner = br.rstrip(\"<\")\n          try:\n              correct_bracketing(br.rstrip(\"<\"))\n            except IndexError:\n              break\n              br.close()\n   \n\nIt is a good exercise to make your own version of it. Try to break it, fix it and make it better.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    # no need to remove leading or trailing quotes\n\n    # we don't need to be case-sensitive, so we can get away with ignoring\n    # case\n\n    return string.match(brackets, '<') and string.match(brackets, '>')", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing_wrong_way(brackets: str, wrong_way: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_wrong_way(\"<\")\n    False\n    >>> correct_bracketing_wrong_way(\"<>\")\n    True\n    >>> correct_bracketing_wrong_way(\"<<><>>\")\n    False\n    >>> correct_bracketing_wrong_way(\"><<>\")\n    False\n    \"\"\"\n\n    def correct_bracketing_wrong_way_wrong(brackets: str, wrong_way: str,\n    wrong_way_wrong: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing_wrong_way_wrong(\"<\")\n    False", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nYou might be interested in this as well: https://github.com/huyinh/python-bracketed</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nThat's ugly as hell. How about this:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nI'd make a few suggestions, since I'm reading this as:\n1\\. if any opening bracket has a corresponding closing bracket, return True\n2\\. if all the brackets have a matching closing bracket, return True\n3\\. if none of the brackets have a matching closing bracket, return False\nIf you get past that, it's a very neat solution.\n\nMy first thought was to use the length of the string to figure out if there were any matches, but I'm not sure if that's the most efficient way.\n\nIf the opening and closing brackets aren't balanced, it won't work.\n\nThis doesn't test for balanced brackets.\n\nI'm curious about how this works. Does it look for the closing bracket and check if it's the only one closing out a set of opening brackets? Or does it look for opening brackets and check if it's the only one opening out a set of closing brackets?\n\nHe's looking for the matching opening and closing bracket.\n\nAnd if there is a matching open/close pair, then the set of brackets are balanced.\n\nThis does not test for balanced brackets.\n\nThis is pretty nifty. Good work.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n    def bordered(brackets: str):\n    \"\"\" bordered is a string of \"<\" and \">\" followed by a \"!\" for the closing\n    bracket.\n    return True if every opening bracket has a corresponding closing bracket.\n    >>> bordered(\"<\")\n    False\n    >>> bordered(\"<!\")\n    True\n    >>> bordered(\">>>\"\")\n    True\n    >>> bordered(\"<<<\"+\"<\"))\n    False\n    \"\"\"\n\nAh, it's Python. The 'correct_bracketing' function is probably a decorator.\nIt's a very common idiom to wrap another function call with a decorator that does some checking to see if the argument is valid (if it's a string, if it's numeric, etc). I guess the other thing that's going on is that the 'correct_bracketing' function is being defined in a module that isn't imported by the file that's including it, and the module system is complaining that it's not able to find the 'correct_bracketing' function", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nThe reason is that it's not checking the contents of the brackets, but rather whether the opening bracket is balanced by its corresponding closing bracket. The first example (with \"<\") fails because the opening bracket doesn't have a corresponding closing bracket. The second example succeeds because both opening and closing brackets have \">\" as their contents. The third example fails because the opening bracket has two closing brackets and the closing bracket has only one opening bracket.\n\nYes, this is correct.\nThe check is whether the opening bracket has a matching closing bracket.\n\nThe OP states that he is having trouble understanding the solution because the solution is not \"trivial\". However, I see nothing about it that is not trivial. The solution is perfectly simple and readable. The only way I can imagine anyone not understanding it is if they don't understand the problem.\n\nI have to disagree. The actual solution in the article is not the shortest, and it doesn't check the example I posted, which is what I think the OP is trying to understand.\n\nHow is that not trivial? The problem is trivial, the solution is trivial, it is perfectly readable.\nThe only way I can imagine anyone not understanding the solution is if they don't understand the problem", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n    return len(brackets) > 2\n\nThat's a nice one. It's a bit embarrassing to have this code on the first hit in Google, though, because this was solved in the mid-1980s, as this list of links shows.\n\nThis is a classic. It is used a lot in old school C/C++ coding when you need to do some basic stuff with strings.\nI have to admit that it took me a while to figure out how it was doing this (see below for explanation).\n\nReally? I'm not a C/C++ expert, but this seems too fiddly to be a classic.\n\nIf you consider the average complexity of what is considered a \"classic\" in C/C++, this is definitely one.\n\nI've tried using this before, but never knew how it worked. I assumed it was just a \"faster\" alternative to some kind of regular expression matching.\n\nIt's not. It matches the first opening bracket to the last closing bracket. The problem with regular expressions is that they don't support nested brackets.\n\nThis is a great way to check if parentheses are balanced correctly.\n\nIt is also a great way to", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> bracketing(\"<\")\n    False\n    >>> bracketing(\"<>\")\n    True\n    >>> bracketing(\"<<><>>\")\n    True\n    >>> bracketing(\"\"><<>\")\n    False\n    \"\"\"\n\n    def bracketed(text: str, brackets: str):\n    \"\"\" text is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n    >>> bracketed(\"<\")\n    False\n    >>> bracketed(\"<>\")\n    True\n    >>> bracketed(\"<<><>>\")\n    True\n    >>> bracketed(\"\"><<>\")\n    False\n    \"\"\"\n\n    def strip_brackets(text: str, brackets: str):\n    \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nI don't think it is a bug, just a bit confusing.\n\nThanks, fixed.\n\nNote that this is incorrect for C++:</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nbrackets = \"<\" + \">\";\n\nfor bracket in brackets:\n    if (correct_bracketing(bracket) == True):\n        print \"correctly bracketed!\";\n        break;\n\nFor those that don't get it, it's a whitespace regex.\n\nThe actual title of the article is \"A Regex to Avoid Your Editor\".</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nIf the author is reading this: I would suggest using a unicode version of < instead of one that does ASCII semantics. The unicode version is actually a non-breaking space.\n>>> correct_bracketing(\"\\n\")\nTrue\n\nI just noticed this is an example for \"learning python the hard way\". I'm not sure how this example would teach anybody anything, though.\n\nWhat does it mean? That you shouldn't try to write functions that do two completely different things? That you shouldn't use the same name for different things? That you shouldn't use the same name twice? That you shouldn't use named arguments? That you shouldn't use the same name for different things in different contexts?\n\nIt means that you shouldn't use the same name for different things in the same context.\n\nWhat if your program has two contexts, and they happen to share the same name?\n\nThen you are in trouble. There are a few ways to handle this:\n\\- have the two contexts in different files\n\\- have the two contexts in different classes, but the classes have the same name\n\\- use different names\n\nThe last one seems to be the correct way, but I think it's a good", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    for i in brackets:\n         if i == \">\":\n            return False\n    else:\n             return True\n\nYou know, this is just one of those things that make me wish there was a good way to implement a meta-language.\n\nIndeed. It would be nice to be able to write a language that has a syntax that is itself a Lisp-like language. (Lisp is one of the few languages that's itself Turing-complete, and is itself a meta-language, but I'm sure there are others.)\n\n(I think there's a few languages that are themselves a meta-language. Maybe any sufficiently powerful language?)\n\nTrue, but I mean more than one meta-language. But, if you accept, say, C, and call C a meta-language, then you can use C to define the grammar of a new language that uses C's syntax, and this new language is a meta-language too.\n\nI think C is a special case. It's not a meta-language in the usual sense, because", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nI get what he's trying to do, but the problem is that '>\"' is not a bracket.\n\nAuthor here:\nNot a Python expert by any stretch, and I'm sure there are better ways to do this, but it works, so I'm not going to worry about it.\n\nI would rather take a look at your code than the proper way to do it. You're doing it correctly.\n\nthanks for the kind words!\n\nThis is a duplicate of</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nI guess I don't understand. I've used python for a while now but I'm no expert.\nIf the code is correct how does the program not return True for the example given?\n\nBecause the example given is not a bracketing problem.\n\nAh, gotcha, thanks!\n\nThe title is misleading. Should be \"Don't Use Python's Correct Bracketing\".\nThe correct title should be \"Don't Use Python's Correct Bracketing, Unless You Understand What It Does\".\n\nIs the title in the article misleading? The article does not claim that it is not correct, it claims that it is not useful in Python.\n\nI don't see the author explaining what Python's correct bracketing actually does, except to say that it is wrong.\n\nI'm not sure I understand the distinction between 'correct' and 'useful', but I think it's safe to say that Python's 'correct' bracketing is not useful.\n\nI agree, but I have the suspicion that \"correct\" bracketing is useful in languages where you can't just easily add an extra statement to fix your \"mistake\".\n\nYou can easily add extra statements to fix your \"mistake\" in", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nIt's not really correct, it should return True for \">>>\" and \"<<<\".\n\nBrackets in Python are funny. You could use parens as well:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n> I'm not sure the code works as intended.\n> If I give it \"\", it returns True.\n> (I'm using Python 3.2.2 on OS X Snow Leopard)\n>\n>\n> def correct_bracketing(brackets: str) -> bool:\n> \"\"\" brackets is a string of \"<\" and \">\".\n> return True if every opening bracket has a corresponding closing bracket.\n> \"\"\"\n> if not brackets:\n> return False\n> else:\n> return brackets.find( lambda c: c.endswith(',' ) )\n>\n>\n>\n\nI don't have a snow leopard install, but I do have python 3.3 on my Linux box and the code behaves as expected. It's simply a matter of having a function to do this, rather than some hacky regular expression.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n    if len(brackets) == 1:\n        return True\n    else:\n        return len(brackets) == 2\n\n_WTF_</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n    return True", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nI have to ask. How do you manage to solve that problem? Do you see the problem? I have been staring at this for a while, but I can't figure out the problem.\n\nI saw the problem immediately. It took me a while to figure out how it is solved, but after that it was a simple matter of replacing each opening bracket with its closing bracket, in the same order.\n\nBut what is the problem? What kind of conditionals is that?\n\nIt's the same as a regular for loop. The condition is that the first < is followed by the second >.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n    def is_bracket_opening(text):\n    \"\"\" returns True if this is a valid opening bracket. \"\"\"\n    return text.strip().startswith('<' or '>')\n    def is_bracket_closing(text):\n    \"\"\" returns True if this is a valid closing bracket. \"\"\"\n    return text.strip().startswith('>' or '<')\n\nThis seems to be the most direct way of solving the problem, although it would be nice to have a name for the operation that the code is performing (ie, the \"correct\" bracketing) and not have to rely on \"is_bracket_opening\" and \"is_bracket_closing\".\n\nYour question can be re-stated in terms of the is_bracket_closing function.  If you accept that is_bracket_closing is True when there is a matching bracket for every opening bracket, then your question boils down to this: \"Is there a way to use the fact that is_bracket_closing is True to determine whether the given string of brackets is actually correct?\"\n\nUnfortunately, this", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n        def match_bracket(brackets: str, pos: int, expected: str):\n           \"\"\" match_bracket is a function that returns True if the given string\n              is a valid bracketing string.\n               return True if every opening bracket has a corresponding closing\n              bracket and the expected string is between the matched brackets.\n             \"\"\"\n\n         if pos == 0:\n            return len(brackets)-1 < len(expected)\n         else:\n            match_bracket = match_bracket_in_string(brackets, pos)\n            return match_bracket(brackets, pos, expected)\n\nI'm not sure if that will make a difference,", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing_reversed(brackets: str):\n    \"\"\" same as correct_bracketing except that it reverses the\n    brackets \"\"\"\n\n    def fix_bracketing(brackets: str):\n    \"\"\" fix broken bracketing \"\"\"\n\n    for i in range(len(brackets)):\n        if brackets[i]!= brackets[i+1]:\n            brackets[i] = brackets[i+1]\n    return True\n\n    def fix_bracketing_reversed(brackets: str):\n    \"\"\" fix broken bracketing in reverse order \"\"\"\n\n    for i in range(len(brackets)):\n        if brackets[i]!= brackets[i+1]:\n            brackets[i] = brackets[i+1]\n    return True\n\nI think the last two lines would be more correctly written as:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n    if len(brackets) > 1:\n       return len(brackets) == 1\n    else:\n       return len(brackets)\n\nAh, ok. So it doesn't account for a string like \"==\" that can appear on its own?\n\nI think it's a typo in the docstring.\n\nYes.\n\nCorrect_bracketing is broken in Ruby 1.9.3 (and maybe in Ruby 1.8.7 as well)\ne.g., correct_bracketing(\"(\") == False\nCorrect_bracketing is not broken in Ruby 1.8.6\n\nIt's broken in Ruby 1.9.3 and 1.8.6.\n\nwhy is this the case?\n\nRuby 1.9.3 doesn't have the same behavior as 1.8.7.\n\nit seems like the difference in behavior is that in ruby 1.9.3 \"(\" is considered to be a statement and in 1.8.6 it is considered to be an opening bracket.\n\nNo, Ruby 1.9.3 and 1.8.6 behave", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    return True if every opening bracket has a corresponding closing bracket.", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing_and_end_with(brackets: str):\n    \"\"\" Returns True if there is an ending bracket.\n    return True if there is an ending bracket and the string brackets is\n    a valid opening/closing bracket combination.\n    \"\"\"\n\n    def correct_bracketing_and_end_with_valid_combo(brackets: str):\n    \"\"\" Returns True if the string brackets is a valid opening/closing\n    bracket combination and the string brackets is a valid string.\n    \"\"\"\n\n    def correct_bracketing_with_final_closing_bracket(brackets: str):\n    \"\"\" Returns True if there is a closing bracket, and that bracket is the\n    last one in the string.\n    \"\"\"\n\n    def correct_bracketing_with_final_closing_bracket_and_is_valid(brackets: str):\n    \"\"\" Returns True if there is a closing bracket, and that bracket is the\n    last one in the string", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n\"I think we should call it 'correct_bracketing_fixup()' instead.\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nI don't think it's supposed to work with empty strings, for example \"\"><<<\".\nIt's not a bug, it's a feature!\n\nYes, but it should return False.\n\nThe example is funny and all, but it's also a good example of how you can teach by example, and how you can use code to tell a story.\n\nNot sure if I should be sad or laugh.\n\nYou should be sad. It's a good example of how we need to write more code in Python.\n\nI have nothing against Python, but I don't see how the code is an example of anything. The only thing we know about it is that it has a bug.\n\nIt's just a Python script that returns True if given a string of brackets. A few people seemed to think it was funny that it didn't work with empty strings, and I posted my response.\nI'm not sure what the problem is with my comment. Did you even read it?\n\nMy objection is that it's not a good example of teaching by example or of telling a story. The only thing we know about it is that it has a bug. I'm not saying there's anything wrong with", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n    if len(brackets) == 1:\n       return True\n    else:\n       if not string.find(brackets, \"</\") or not string.find(brackets, \">\") or not string.find(brackets, \"</\") or not string.find(brackets, \">\"):\n          return False\n   \n    return True\n\nWhere are these lines coming from?\n\nYeah, my immediate reaction to seeing something like that was:\nThis is not a good way to do this.\n\nYou should be embarrassed to publish something like that.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    if len(brackets) == 0:\n       return False\n    if brackets[0] == \">\":\n       return True\n    if brackets[0] == \"<<\":\n       return True\n    if brackets[1] == \">\" and brackets[1] == \"<<\":\n       return True\n    return False\n\nI feel like this doesn't count because this is literally what the function does, so of course it's correct.\n\nThe sad part is that I wasn't even surprised to see it pass all of the tests.\n\nThe title of the post is a lie. It doesn't test Python. It tests python-mode.el.\n\nI'm not sure I follow, given that \"python\" is in the title and \"python-mode.el\" is nowhere in the body of the post. If you're saying it tests the ability of python-mode.el to test python, I think that's just a tautology.\n\nIt's in the HN headline, which is what the title of the blog post is", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nNote that the version without the comment is better because it is more explicit.\n\nWow, this is even more hilarious if you consider that it comes from the \"JavaScript Best Practices Guide\"\n\nIt's not meant to be taken seriously.\n\nIf you're doing something trivial like this, there's no reason to use a library like this.\n\nOr you could just use parens.\n\nThis looks useful. I was looking for a solution to the same problem a while back. I found a solution, but it's not very clean. It's worth checking out if you're interested:\n\nHow about just:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nWhat's your point? You wouldn't be able to do this in C, for example.\n\n_What's your point? You wouldn't be able to do this in C, for example._\nOr in many other languages. The point is that the poster is suggesting that the code is \"correct\", which it most certainly is not, while at the same time trying to do a sort of grandstanding by touting the awesomeness of Python.\n\nWhat makes you think I was trying to be \"grandstanding\" or something? I don't think it's perfect, and I'm sure that I could have done it better. I'm just saying that Python gives me the power to do it.\n\nGood job! (I am not a Python programmer.)\n\nThanks.\n\nYou're welcome.\nI've implemented this in Python:\n\nWell, you can use it as a regular expression.\n\nBut then it would look like \n\nThat's not a regular expression, it's an awk-like construct.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nreturn True\n\nThat isn't what it does at all.\n\nThe second argument is a sequence of strings, each < character must have a > character and vice versa, so yes, it is.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n            def correct_bracketing_no_match(brackets: str) -> bool:\n               \"\"\"\n                return len(brackets) > 0\n                \"\"\"\n\n             def correct_bracketing_no_match_no_empty(brackets: str) -> bool:\n               \"\"\"\n                return len(brackets) == 0\n\n             def correct_bracketing_no_empty_no_match(brackets: str) -> bool:\n               \"\"\"\n                return len(brackets) > 0 and len(brackets) == 0", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nYou are welcome.\n\nIn my experience, most of the time, the people who post these code samples are not the original authors.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nisn't that what you want?\n\nI think the OP's problem is that the correct_bracketing method is called every time the regex is evaluated, not just the first time the \">\" is seen.\n\nCorrect.\n\nIs the code shown above the only code you have for this? If so, you can just write a method that takes a regular expression as a parameter. Then you can call that method repeatedly as needed.\n\nWell, I am trying to make the code that actually runs the queries more independent from the rest of the app. The queries are being added to the app as \"add-ons\" (if you will). So, I am going to have to use the regex engine to perform a search on the database for the app to run the query.\n\nThe problem with that is, for example, if the app is querying for the first name, last name, and city, of everyone in a certain state. Then that app will have to have a regex engine that will run on the database, and the regex engine will need to be able to query the database for the users based on the state they are in, first name, last name, and city.\n\nSo, how would", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nThe 'correct_bracketing' function doesn't work correctly. Consider the following example:\n\n>>> correct_bracketing(\"<(\")\nFalse\n>>> correct_bracketing(\"<(\")\nTrue\n\nThe 'correct_bracketing' function should be returning True in the second example. The problem is that there is no corresponding closing bracket in the string \"<(\".\n\nThe 'correct_bracketing' function doesn't work correctly. Consider the following example:\n>>> correct_bracketing(\"<(\")\nFalse\n>>> correct_bracketing(\"<(\")\nTrue\nThe 'correct_bracketing' function should be returning True in the second example. The problem is that there is no corresponding closing bracket in the string \"<(\".\n\nI see no problem with it. It works as written. It's not saying \"if every opening bracket has a corresponding closing bracket\", it's saying \"if every opening bracket is closed with a corresponding closing bracket\".\n\nI see no problem with it. It works as written. It's not saying \"if every opening bracket has a corresponding closing bracket\", it's saying \"if every opening bracket is closed with a corresponding closing", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n    \"\"\" from __future__ import print_function\n\n    \"\"\" from datetime import datetime\n    \"\"\"\n\n    def __repr__(self):\n    \"\"\"Return a string repr of the object, using the str repr function.\"\"\"\n\n    if self.isinstance(self, StringType):\n        return self.__repr__(self)\n    elif self.isinstance(self, unicode_type):\n        return '<%s: %s' % (self.__class__.__name__, self.__repr__(self))\n    else:\n        return self.__class__.__name__", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n           def test_no_bracketing(s):\n            if s == \"\":\n               return False\n            else:\n                return correct_bracketing(s)\n\nI'm pretty sure it's valid python.\n\nSeems to be valid python, but it's not an \"I'm pretty sure\" test. It's a test where you know the outcome, so there's no uncertainty.\n\nIt's still a test - it tests for incorrect bracketing.\n\nI know it's a test. It's a poor test because the author is testing for something he knows will fail.\n\nNot at all. It tests for a common problem, and the purpose is not to discover if the test itself is correct.\n\nThat's my point. The author knew it would fail. That's why he wrote the test. He wanted to see if he got it right.\n\nAs someone who loves Perl, and is used to", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    return False\n\nHey, this is how I test my Python code as well.\n\nI was just going to write \"def correct_bracketing(brackets):\"\n\nThis isn't a problem with Python's type system. It's a problem with the fact that he has an \"or\" operator with no \"and\" or \"and not\" operator.\n\nHow is that a problem? What's wrong with false?\n\nIn this case it's fine, but if you're programming in Python and \"return True\" or \"return False\" is a common way of handling exceptional situations you'll end up with a lot of code where you have to check whether or not it's a \"good\" value before you can do anything with it.\n\nIn my limited experience, you'll end up with a lot of code that depends on _returning_ a value that you can do something with, rather than on checking whether or not a particular value is \"good\".\n\nTrue, but if you're writing code in Python, your most common error is probably not _returning_ a value.\n\nThis is actually a perfect example of the OO philosophy. You have a", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing_bmp(brackets: str, width: int):\n    \"\"\" correct_bracketing but for the BMP format\n    \"\"\"\n\n    img = Image.new(brackets)\n    img.save()\n\n    if not img.save():\n       return False\n    for row in img.get_bmp_row(width, 0, width-1):\n       for col in img.get_bmp_col(0, row+1):\n         if (col.has_xor(col.xor(col.xor(col.xor(col.xor(col.xor(col.xor(col.xor(col.xor(col.xor(col.xor(col.xor(col.xor(col.xor(col.xor(col.xor(col.xor(col.xor(col.xor(col.xor(col.xor(col.xor(", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n    def bracketing(bracket: str):\n    \"\"\" returns True if the given string is bracketed\n    >>> bracketing(\"<\")\n    True\n    >>> bracketing(\"<>\")\n    False\n    >>> bracketing(\"<<><>>\")\n    True\n    \"\"\"\n    return bracketing(brackets)\n\nYou have to pass the string itself, not the string of brackets.\n\nI don't think that's correct.\n\nYou're right, that was silly of me, I was missing the brackets in the test string.\n\nOr you could use _ instead of > and <\n\nPython supports the _ operator as an alias for the > operator, but not the < operator. I think it's a better idea to use the real operators anyway, since their meaning is not obscure.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing_or_else(brackets: str):\n    \"\"\" returns true if every opening bracket has a corresponding closing bracket.\n    return correct_bracketing(brackets) or else False.\n    \"\"\"\n\n    def correct_bracketing_and_else(brackets: str):\n    \"\"\" returns true if every opening bracket has a corresponding closing bracket.\n    if there is a mismatch, the first unmatched opening bracket is returned\n    return correct_bracketing(brackets) and else False.\n    \"\"\"\n\n    correct_bracketing_or_else = correct_bracketing_or_else\n    correct_bracketing_and_else = correct_bracketing_and_else\n\n    if len(brackets)!= 2:\n        print \"Invalid argument given: \"+ str(brackets)\n    print\n        raise NameError(\"\"\"Invalid brackets: \"+str(brackets))\n\nBeautiful.\n\nThe entire _point_ of", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nThat's not very difficult to read, really.\n\nThe error is not so much in the description of the function as it is in the use of the function name.\n\nWhen I need to read through code quickly, I don't need a function to test if the given string has the correct opening and closing characters.\n\nActually I'm sure I could come up with a few uses for such a function, but still, that is not the point.\n\nThe point is that I don't know what the function does without reading the code. It is just some random word put together with the opening and closing symbols.\n\nSo when I go back to the code to figure out what the function does, it takes me twice as long as it should have.\n\nIf the function was called <>_correct, I would know immediately what the function does, and I could just go ahead and read the function without having to figure out what it does.\n\nIf it is not a complicated function, and the name isn't all that important, then there is no problem. But this is a simple function, and the name does matter.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def is_bracket(s: str, b: bool):\n    \"\"\" return True if s is a bracket\n    >>> is_bracket(\"<\")\n    True\n    >>> is_bracket(\"<>\")\n    True\n    >>> is_bracket(\"<<>>\")\n    True\n    >>> is_bracket(\"<<<>>\")\n    False\n    \"\"\"\n\n    def is_bracket_opener(s: str, b: bool):\n    \"\"\" return True if s is a bracket opener\n    >>> is_bracket_opener(\"<\")\n    True\n    >>> is_bracket_opener(\"<>\")\n    True\n    >>> is_bracket_opener(\"<<<\")\n    True\n    >>> is_bracket_opener(\"<<<<\")\n    False\n    \"\"\"\n\n    def is_bracket_closer(s: str, b: bool):\n    \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nI wouldn't call this a hack. It's a fully tested and useful example of duck typing.\n\nNot really. It's a hack. The author is doing something they know is not possible using the intended method, and using a more flexible approach to make it work.\n\nI've read a lot of \"X is not a hack\" responses in this thread, and I'm convinced that the definition of \"hack\" is subjective. That's the beauty of the word. To some, it can mean \"a clever solution to a problem\", and to others, it can mean \"something that violates the rules\".\n\nHm, what is this supposed to do? I've tried several examples, all of which give me \"True\".\n\nLooks like it should be returning True if every opening bracket has a corresponding closing bracket.\n\nAnd it does, but in the examples that /u/isthetriangle was trying, it was returning True even though it shouldn't have.\n\nI also believe it should return False for:\n> correct_bracketing(\">\")\nBut it returns True.\n\nI always thought of a hack as something that you are not supposed to do. For example, using a regex", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracket_opening(brackets: str):\n    \"\"\" return True if every opening bracket has a corresponding closing bracket.\n    >>> correct_bracket_opening(\"<\")\n    True\n    >>> correct_bracket_opening(\"<>\")\n    True\n    >>> correct_bracket_opening(\"<<><>>\")\n    False\n    >>> correct_bracket_opening(\"\"><<>\")\n    True\n    \"\"\"\n\n    return correct_bracketing(brackets)\n\n    def correct_bracket_closing(brackets: str):\n    \"\"\" return True if every opening bracket has a corresponding closing bracket.\n    >>> correct_bracket_closing(\"<\")\n    True\n    >>> correct_bracket_closing(\"<>\")\n    True\n    >>> correct_bracket_closing(\"<<><>>\")\n    False\n    >>> correct_bracket_closing(\"\"><<>\")\n    True", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nI have used this function on more than one occasion.  Thank you, guy who made this.\nIt is quite a useful function.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def bracket_regex(pattern: str):\n    \"\"\" Return the regex for a string that matches the given pattern.\n    Parameters:\n    pattern - A pattern to match.\n    Return:\n    A regular expression. \"\"\"\n\n    return re.compile(pattern).match(re.DOTALL)\n\n    def extract_brackets(string: str):\n    \"\"\" Returns a string of all < and > in a string.\n    Parameters:\n    string - A string to extract brackets from.\n    Return:\n    A string with all the brackets.\n    \"\"\"\n\n    return re.sub(r'<', '', string)\n\nAs a Rubyist, I find this disappointing. Ruby's regular expression engine is fast. This code is not fast.\n\nIt's not meant to be fast, it's meant to be correct.\n\nIt's not really meant to be fast, it's meant to be slightly faster than the Ruby equivalent.\n\nI've written something similar to this in Perl 5. The fastest way I found", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def wrong_bracketing(brackets: str):\n    \"\"\" wrong_bracketing is the same as correct_bracketing, but with\n    reversed opening and closing brackets.\n    \"\"\"\n\n    return wrong_bracketing(correct_bracketing(brackets))\n\nYou can find the code here:\n\nfor example, in Python 2.2, this will give you:\n\n>>> def wrong_bracketing(brackets: str):\n    \"\"\" wrong_bracketing is the same as correct_bracketing, but with\n    reversed opening and closing brackets.\n    \"\"\"\n    return wrong_bracketing(correct_bracketing(brackets))\n>>> wrong_bracketing(\"<>\")\nFalse\n>>> wrong_bracketing(\"<>\")\nTrue\n>>> wrong_bracketing(\"<<><>>\")\nTrue\n>>> wrong_bracketing(\"\"><<>\")\nFalse\n>>> wrong_bracketing(\"\"><<>\")\nTrue\n\nP.S.\nI wanted to write about a much more interesting subject (", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nThat's just a small piece of the code. Heres the code for the logic behind it:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nI actually have to call this myself all the time.\n\nYou don't really need to call it, you can just do this:\n>>> brackets = \"<\" * 1\n>>> correct_bracketing(brackets)\nTrue\n\nAh, but what if you want to call it from inside a function?\n\nCorrect me if I'm wrong, but wouldn't you just pass it as a parameter?\n\nI was going for a programming humor joke.\n\nThis is not really a programming humor site. And, even if it was, you missed the mark.\n\nI don't think he was _trying_ to be funny.\n\nI see. I thought he was trying to make some sort of joke by calling the function and passing in brackets. Maybe that wasn't his intention.\n\nIt seems that there are a lot of programmers on HN. You guys should create a site for you programmers to show off your humor skills and creativity.\n\nI agree, but I think it would be best as a site that is not called HN, otherwise it would start to be too similar to this site.\n\nOr maybe, just maybe, HN is a site that is not called H", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nCorrect_bracketing() is a function that takes a string with brackets in it, and\nreturns True if every opening bracket has a corresponding closing bracket.", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def _itertools.tee(iterable: Iterable[Iterable[str]], value: str):\n    \"\"\" Arrange the items of iterable so that the last item is followed by a\n    copy of value.\n    \"\"\"\n    for i, item in enumerate(iterable):\n        yield item\n    value = value.copy()\n    if i == len(iterable):\n        yield i.copy()\n    return value\n\nThe best you can say for this code is that it's easy to read. It doesn't help that it's broken.\n\nThe key problem here is that the author has seen the word \"itertools\" and wants to use it. But what is the thing that \"itertools\" does? It does \"tee\". In fact, it does it in many different ways, but that's not important. What is important is that the author had a vague idea of what \"itertools\" does, saw that \"itertools\" did something related to his problem, and used it.", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_brackets(lines: str):\n    \"\"\" correct_brackets takes a string of \"<\" and \">\"s as its argument and\n    returns a list of strings, where the first string is the first\n    line, and the second string is the second line.\n    >>> correct_brackets(r'<><')\n    [(<a>,<b>)],\n    [(<a>,<c>)],\n    [(<b>,<a>)],\n    [(<b>,<b>)],\n    [(<c>,<a>)],\n    [(<c>,<b>)],\n    [(<a>,<c>)],\n    [(<c>,<b>)],\n    [(<a>,<b>)],\n    [(<a>,<a>)],\n    [(<b>,<a>)],\n    [(<b>,<b>)],\n    [(<c>,<b>)],\n    [(<c>,<c>)],", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nLooks like this is what you want:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nI got this one right, but the question is a bit too trivial for my taste.\n\nI got that one right too. I didn't like the question.\n\nYeah I did, too.\nThe next question was a bit more interesting to me:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nGood!</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nOK, so I'm going to be \"that guy\" and call attention to the (admittedly amusing) oversight in the code for \"correct_bracketing\" in the story: it's comparing the opening and closing brackets for all the strings, not just the first bracket in the string.\nThis is a really simple test to get right: just loop over the input string and compare the first pair of brackets in the string to the closing pair of brackets in the string.\n\nI'm not a Python expert, but it seems to me that it's actually checking whether the first character is a '<' and the second is a '>'. I.e., it will return True if the first character is a '<' or the second is a '>'.\nNot perfect, but a lot better than checking the first and last characters.\n\nThe last line (return True if every opening bracket has a corresponding closing bracket) says otherwise.\n\nI see what you mean. That code is presumably a mistake.\n\nThe example code for the non-strict version is wrong:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nHere's some code I used to convert the Java regex engine into a\npseudo-regular expression engine.", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nThis may be an unpopular opinion, but I don't think that's what \"correct_bracketing\" should be doing. I would think it's more likely that \"correct_bracketing\" would return True if all the \">=\" were between the \"<<<\" and \">>>\" and the \"<\" and \">\"> were between the \"<\" and \">\" and not just if the brackets were in order.\nI think the author should look into the types of \"brackets\" and not just \"string\".\n\nFor me the problem with all these \"correct\" things is that they are designed to catch people who are doing something wrong. So they are all designed to be hard to do \"right\".\nBut if you do it \"wrong\" then the \"correct\" thing doesn't help you anyway.\nIf you are doing something \"wrong\" in Python you are in trouble and you should be stopped. If you are doing something \"wrong\" in Javascript you might just be fine.\n\nI've read a lot of these types of posts recently. I'm not sure if it's the influx of new programmers or something else, but the way I see it, there are a few reasons to use functions like this one.", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nThis is a terrible example of \"correctness\".  E.g., what happens if I want to create a list of only the brackets in the correct_bracketing function?\n\nIt's probably meant to be \"correct\" in the sense that it produces the same results as Python's bracket.\n\nYep, that's exactly what I was going for :)</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing2(brackets: str):\n    \"\"\" correct_bracketing2 is a more general version of correct_bracketing.\n    It will return True if every opening bracket has a corresponding closing\n    bracket and all open brackets are followed by a corresponding closing\n    bracket.\n    >>> correct_bracketing2(\"<\")\n    True\n    >>> correct_bracketing2(\"<>\")\n    True\n    >>> correct_bracketing2(\"<<><>>\")\n    True\n    >>> correct_bracketing2(\"\"><<>\")\n    True\n    \"\"\"\n\n    def is_bracketed(s: str):\n    \"\"\" is_bracketed is a function that determines if an entire\n    string is bracketed or not. It uses the Python regular expression\n    functionality to compare the text to a set of regular expressions.\n    \"\"\"\n\n    return re.match(s, '[[, ]]*') is not None", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nThe code is correct (that is, it will be correct in Python 3, which is what OP is using).\nYou're being downvoted because the post asked a question that's easily answered by reading the docs. You're also being downvoted because the correct answer to the question is the first result on Google, and that answer has been around for at least a decade.\n\nI did see that. I just thought the \"explanation\" was quite funny.\n\nThe explanation is that this is correct.\n\nThe funny part was \"def correct_bracketing(brackets: str):\".\n\nPython is case-sensitive, so he needed to put brackets in quotes.\n\nThe real answer is that python will interpret `<` and `>` as the characters, not the strings. You can't use a character as the last character of a string, so you need to use `'` or `'\\''`.\nTo make it a little clearer, here's a python function that correctly interprets opening and closing brackets.", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n`brackets` is a list of < and >.\nThe string representation of a list of symbols is the concatenation of the\nsymbols themselves.\nSo the above implementation does not do what you intend.\n\nWow, that's horrible. I get the feeling Python doesn't care much for correct syntax.\n\nIt's pretty trivial to fix using Python's regular expression parser:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    \"\"\"\n    def correct_bracket(brackets: str):\n    \"\"\" This returns True if every opening bracket has a corresponding closing bracket.\n    return correct_bracketing(brackets).\n    \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n       def bracket_match(brackets: str):\n         \"\"\"matches every bracket \"\"\"\n\n           return string.find(brackets).count(1) == 1\n\n           # return \"\", if the string is empty\n\n           # return 0 if the string is not empty, but has no brackets\n\n           return 0\n\n           def correct_bracketing_match(brackets: str):\n           \"\"\"matches the correct brackets\"\"\"\n\n           return string.find(brackets).count(1) == 2\n\nWait, you want it to return true on\n\"<\"<>\nbut false on\n\"<\"<>\n? Or do you mean\n\"<\"<>\n?\n\nThe first one. The second one is correct, the first is not.\n\nI've been using the following for a while:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nSorry for the late reply.\n1. I wanted to use just one function for all of the tests.\n2. I needed to use some special casing for the '<' and '>' operators.\n\nYou should learn the difference between a programming language and a scripting language.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nWhat do you mean by \"opening bracket\"?  It looks like the second example returns true but the first doesn't.\n\nI think it's a joke, for the OP's bracket-sans-bracket.py.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nThe comment says that it's \"not intuitive\", but I'd argue that this\nis a good example of how to use the English language to name things.\nIn this case, it's \"correct\" in the sense of \"correctness\" (vs.\n\"correctness\") and \"bracketing\" in the sense of \"bracket\" (vs.\n\"bracket\").\n\nIf you use English words in the language you are programming, there is a\nhigh chance that the names you choose will be understandable to your\ncolleagues.\n\nReally? I'd argue that's the _wrong_ way to do it.\n\nAgreed. I think it's better to give more precise names to things. It helps for clarity and in the long run it helps make the code more maintainable.\n\nI can't believe that's not intuitive. If you see two opening brackets, you think the matching closing bracket should be with them. And if you see one or more closing brackets, you think the opening bracket should be next to them.\n\nI'm not sure how I feel about this, because I've seen many cases where I've been completely confused by the way people in an organization or team have named", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nShouldn't the string be of the form \"<>\"?\n\nYou're right. I'll fix it.\n\nYou forgot to fix it.\n\nI'm going to take a stab at this one and say \"yes\".</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nSo what is the point of this code?\n\nI think the answer is that this code is an example of a simple but correct Python program.\nThat is, it's something you could write to illustrate the basic structure of a Python program.\nBut, I don't think the OP has a problem that this code solves.\n\nIt's simple to understand, yet it's not that easy to write.\n\nSure, I can see that it's not that easy to write.\nBut, I'm not sure it's not that easy to understand.\n\nSure, it's not that hard to understand, but it's not something you can easily explain in one sentence.\n\nI don't understand your last sentence.\nI don't think you can explain any program in one sentence.\n\nIt's not just a program.\nIt's a small code example that is easy to understand, but not that easy to write.\n\nIn that case, I think you're right.\n\nThis is a terrible example of something that is easy to understand but hard to write.\n\nI think this is a good example of the first part, but the second part is a stretch.\n\nCorrectly bracketing a string", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nThis code appears to work as expected in Python 2.6.2 on Mac OS X.\nWhat version of Python are you using?\n\nI suspect he is using the version that is shipped with his OS and has not\nupdated the version.\nI'm sure that the version that comes with Vista is 2.5.\n\nMaybe I'm missing something, but it looks to me like his sample code passes.\nWhat does \"correct_bracketing('<<><>>')\" evaluate to?\n\nTrue</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    # note that this will catch single and double quotes, which\n    # are not valid in brackets.\n    return re.sub(r'[^\\w]*', '', brackets)", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nThanks!</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n    if len(brackets) == 0:\n        return False\n    for opening_bracket in brackets:\n        if closing_bracket not in brackets:\n          return False\n            if opening_bracket!= closing_bracket:\n              return False\n         return True\n\nI just replaced str.lower() with str.strip() and it seems to do the trick.\n\nYeah, it's more \"correct\" (as in, strips leading and trailing whitespace), but it's also _slower_. It's like replacing a set of if-elses with a switch statement, but it's not that clear that it's the right thing to do.\n\nOh, I just noticed that the code I used didn't strip leading whitespace! I'll fix that.\n\nA better alternative would be:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nThis is a duplicate of the original question:\nhttps://news.ycombinator.com/item?id=6090333</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nI could be wrong, but isn't that the wrong way round? Shouldn't it be:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nfrom collections import namedtuple\nfrom itertools import chain", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nalso", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def _is_bracketed(bracketed_open: str, bracketed_close: str):\n    \"\"\" is bracketed_open bracketed_close?\n    \"\"\"\n\n    return bracketed_open == bracketed_close\n\n    def correct_bracketing(brackets: str):\n    \"\"\" correct_bracketing (from the original article):\n    \"\"\"\n\n    for a in brackets:\n       if a == bracketed_open:\n         return False\n        else:\n          return _is_bracketed(a, a)\n    \"\"\"\n\n    return correct_bracketing(brackets)\n\nWhat exactly is the point of this? The \"original article\" is just a single line of code. How much clearer can you make it?\n\nMy first thought was \"What is the point of this?\" I'd say it's a way to practice logic with Python.\n\nThe better one is Python's built in \"correct_br", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    return brackets == \"\"\n\nI wrote this in Python, but since Python is now a mainstream language, it's no longer acceptable to use it to solve problems.\n\nI like it better. Python is so mainstream that it's retro.\n\nI really liked this one:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nMy function is better:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing_impl(brackets: str) -> bool:\n    \"\"\" correct_bracketing_impl is a recursive implementation of\n    correct_bracketing.\n    >>> correct_bracketing_impl(\"<\")\n    True\n    >>> correct_bracketing_impl(\"<>\")\n    True\n    >>> correct_bracketing_impl(\"<<><>>\")\n    True\n    >>> correct_bracketing_impl(\"\"><<>\")\n    True\n    \"\"\"\n\n    if brackets:\n        raise ValueError(\"correct_bracketing expects a string.\")\n    else:\n        return len(brackets) == 1\n        # we know that brackets is a string.\n        # now we check if it is correct\n        # first, we check if the last bracket has a corresponding first\n        # bracket.", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing_all(brackets: str):\n    \"\"\" return True if every opening bracket has a corresponding closing bracket.\n    >>> correct_bracketing_all(\"<\")\n    True\n    >>> correct_bracketing_all(\"<>\")\n    True\n    >>> correct_bracketing_all(\"<<><>>\")\n    True\n    >>> correct_bracketing_all(\"><<>\")\n    True\n    \"\"\"\n\n    def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    if every opening bracket has a corresponding closing bracket:\n       return True\n    \"\"\"\n\n    return not correct_bracketing_all(brackets)\n\nI would think this would be an easy thing to make in Python.\n\nThe algorithm isn't hard, but the problem is in the parsing. This solution will only work for very specific strings. For instance, \"<(\")\" will fail, but \"<", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing_with_parenthesis(brackets: str):\n    \"\"\" A more complex solution.\n    pass the current bracket to the parenthesis function.\n    pass the current bracket to the parenthesis function\n    return True if every opening bracket has a corresponding closing parenthesis.\n    \"\"\"\n\n    def correct_bracketing_with_parenthesis(brackets: str):\n    \"\"\" This uses a heuristic for determining the correct opening and closing parenthesis.\n    pass the current bracket to the parenthesis function.\n    pass the current bracket to the parenthesis function\n    try to find the end of the string, then return the parenthesis that the brackets are part of\n    return True if every opening bracket has a corresponding closing parenthesis\n    \"\"\"\n\n    def find_first_parenthesis(string: str):\n    \"\"\" This function is used in the correct_bracketing_with_parenthesis function\n    It finds the first parenthesis in the given string.\n    \"\"\"\n\n    def", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nDon't know what language this is, but I assume it's python?</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nThis is a really neat solution. It makes me wonder if there is a more general version. If so, it could be easily made into a nice Python package.\n\nI think you could do it for Python-style brackets, using a list comprehension and regular expressions:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    return 0", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nI would like to see a function like this for python.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nYour code is not correct, though. It's wrong for the following:\ncorrect_bracketing(\"<><\")\n\nIt would be much better to use Regex.match() instead, like this:", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\ntry:\n    return len(brackets) == 1\n\nexcept AttributeError:\n    return False", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def my_bracketing_corrector(brackets: str):\n    \"\"\" return True if every opening bracket has a corresponding closing bracket.\n    >>> my_bracketing_corrector(\"<\")\n    True\n    >>> my_bracketing_corrector(\"<>\")\n    True\n    >>> my_bracketing_corrector(\"<<><>>\")\n    True\n    >>> my_bracketing_corrector(\"><<>\")\n    True\n    \"\"\"\n\n    return correct_bracketing\n\nI really like the second one.\n\nI got confused and wondered what a \"bracketing\" operation was, then remembered it was Python. :)\n\nActually it's correct in both languages - the \"bracketing\" operation is the conditional branch operation, or the \"if\" statement.\n\nThe \"if\" statement is just the application of the test, not the test itself.\n\nI'm not sure I understand your point. I was just saying that the meaning of bracketing (bracketing condition) is still correct in Python,", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    return len(brackets)!= 1\n\nIf you use list comprehension correctly, that shouldn't happen.  I just did this:\n>>> correct_bracketing(\"<\")\nTrue\n>>> correct_bracketing(\"<>\")\nFalse\n>>> correct_bracketing(\"<<><>>\")\nFalse\n>>> correct_bracketing(\"\"><<>\")\nTrue\n\nMy guess is that you did not close the parenthesis after the first opening parenthesis in correct_bracketing('<') and correct_bracketing('<>') and that those are the ones that didn't work.\n\nNot true. I wrote a program to check, and if I get it right I get the True result.\nI think you are right, this code is from the python 2.3 test suite.\n\nI love list comprehensions and wish I could use them in c++ and java!\n\nUse list comprehensions in Java! \n\nThere's a follow-up article that shows how to handle a slightly different case:\n\nI think it would be more readable to use \"if\" and \"while\" rather than \"for\" and \"if else if\", but it", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nDon't think this works like you think it does.\n>>> correct_bracketing(\"<\")\nTrue\n>\nOr maybe I'm misunderstanding the problem?\n\nAh, I see what you mean. It would be better to do this:\n>>> correct_bracketing(str.strip('<'))\nTrue\n\nNote that this code is not exactly right. It will return True for strings like \"a>b\" and \"a<b\". It will also return True for strings like \"a>b\" and \"a<b\".\n\nI was hoping to see a solution that corrected cases of > vs >=.\n\nA solution that does this would be more complicated, but would be very cool.\n\nWhy? You'd just need to use str.isdigit() and apply the same logic.\n\nReally? Can you explain a little?\n\nSure.\n>>> a = '11>5'\n>>> a.isdigit()\nFalse\n>>> a.isdigit() == 1\nTrue\n>>> a.isdigit() == 2\nTrue\n>>> a.isdigit() == 0\nTrue\n>>> a.isdigit() == 5", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nInteresting, this code is actually correct, though it doesn't match what the OP is asking for.\n\nWell, it doesn't check to see if every opening has a corresponding closing.\nI am trying to write a function that takes a string like \"foo<bar>\" and makes it into \"<foo><bar>\"\n\nAh, I see. I misread your code, which I think is what the others were getting at.\n\nThis is not really a topic on its own. You could ask for help in this regard on StackOverflow or any other website with a Python tag.\n\nYou are correct. I was just going through and finding some topics to post questions about. I was about to delete it.\n\nYou might want to look at the answers to some of the other questions that have been asked on this site. You might get some inspiration.\n\nSure, but I have a bunch of questions that I was going to ask, so I was just trying to get a few up.\n\nOn a side note, there is a typo in your questions: \"what the best way to store a string with a space in it?\"\nI have no idea what you mean by \"store a string with a", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n>\n> This is interesting. Would it be possible to use this as a linter for C\n> code?\nYes, you could use this to find syntax errors in C code, but it wouldn't\nhelp you find logic errors.</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    if len(brackets) > 2:\n        return False\n    for x in brackets:\n        if '<' in x:\n           return True\n    return False\n\nYou might want to check the case for quotes: \" and '\n\nthanks, fixed</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nWhen I read the title I thought that this was going to be a discussion about the different syntaxes (like C/C++, Perl, and Python).</s>", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nI bet you had some trouble with this one:\n> correct_bracketing(\"<<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing(brackets, close_bracket: bool):\n    \"\"\" The difference from \"correct_bracketing\" is that close_bracket can be\n    specified and if the correct bracketing is not possible, it returns False\n    \"\"\"\n\n    for bracket_name in brackets:\n        if not close_bracket:\n           return False\n       else:\n           close_bracket = True\n        if correct_bracketing(bracket_name):\n            return True\n        else:\n            close_bracket = False\n    return False", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nHowever, he is correct in that the code I've given is not equivalent to the", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\nI don't see the point.  Surely a regular expression can be more efficient?\n\nRegular expressions are not more efficient than string concatenation in Python. Python interprets them as a function call and calls the function repeatedly for each character in the string.", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n    def correct_bracketing(brackets: str):\n    \"\"\"\n    brackets is a string of \"<\" and \">\".\n    if a bracket is followed by a space and an opening bracket, it is\n    considered to be closed, otherwise it is considered to be open.\n    return True if all brackets in brackets are closed.\n    >>> correct_bracketing(\"<\")\n    True\n    >>> correct_bracketing(\"<>\")\n    False\n    >>> correct_bracketing(\"<><<>\")\n    True\n    >>> correct_bracketing(\"<><>\")\n    True\n    >>> correct_bracketing(\"<<<>\")\n    False\n    \"\"\"\n\n    def check_brackets(brackets: str):\n    \"\"\" given a string of opening and closing brackets, return True if\n    the first opening bracket is followed by a corresponding closing\n    bracket\n    >>> check_brackets(\"<>\")", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\n        return not string.contains(brackets)\n\nPython", "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\" \"\"\"\n\nI can't imagine why you would think that.\n\nHere's what the author actually wrote:"]]