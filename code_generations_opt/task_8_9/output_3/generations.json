[["from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in numbers:\n       sum_product(i) + sum_product(i+1)\n    return tuple(sum_product(numbers.pop()), sum_product(numbers.pop()))\n\nfrom typing import Type\n\n    class AddTuple(Tuple):\n         def __init__(self, a, b):", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for n in numbers:\n        if n == 0:\n           return (0, 1)\n        else:\n           return sum_product(numbers[n]) * sum_product(numbers[n - 1])\n    return tuple(sum_product(numbers))\n\nThis is very similar to Python's list comprehension, but I prefer the explicitness of sum_product. I just think it looks cleaner. Is there any reason why I shouldn't use sum_product in favor of list comprehension?\n\nI wouldn't say there is anything wrong with sum_product, but if you have a list comprehension already, there's no harm in using that.\n\nI thought list comprehensions were just a way to write a for loop without using a for loop? If so, isn't this more like a list comprehension than a for loop? I don't know, maybe I'm just missing something.\n\nIt is a way to write a for loop without using a for loop, and it is more like a list comprehension than a for loop.", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in numbers:\n        sum = 0\n        product = 0\n        for j in range(numbers.size):\n            if j in numbers:\n                sum += j\n                product += j*j\n    return sum, product\n\nThis is the exact algorithm I would have used to do that. I can't think of any other ways to write it.\n\nYeah, if this were \"pythonic\" it would look something like this:\nsum = 0\nproduct = 0\nfor i in range(len(numbers)):\nsum += numbers[i]\nproduct += numbers[i]*numbers[i]\nreturn sum, product\n\nThat's a great algorithm, and the one I'd use when the type system (or the compiler) would prevent me from writing the above.\nBut if I'm writing a small program for fun, I usually don't care about elegance, and", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for number in numbers:\n       if number >= 0:\n           return sum(number)\n       else:\n           return tuple(number, 1)\n\nYou can also write it like this:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum_product = (0, 1)\n\n    for number in numbers:\n          sum_product += number\n          product_sum = sum_product.get(0)\n          product_product = sum_product.get(1)\n    return (sum_product, product_product)\n\nI don't think the author understands the purpose of a sum_product function.\nThis will return a tuple which only exists for a single list and for the result of a single call to sum_product.\nIt's not a generic function at all.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (0, 1, 0, 0, 1, 1, 2, 4)\n\nWhat's the point?\n\nThe point is that the Python standard library is written in Python.\n\nYou could write a very similar function in about ten lines of Ruby.\n\nYes, of course. And you could write a much shorter, more succinct version in Python too. But this doesn't seem to be the point; the point is, Python has a standard library.\n\n1 - Readability > Simple function\n2 - Python has standard library\n3 - Python is a beautiful language\n\nAnd this is where Ruby would shine.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (sum(numbers), product(numbers))\n\nHeh, I like it.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (sum_of(numbers), sum_of_product(numbers))</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    a = numbers.sum()\n    b = numbers.product()\n    return [a, b]", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum = Tuple()\n    product = Tuple()\n    for i in numbers:\n        sum.append(i)\n        product.append(sum.get(0), sum.get(1))\n    return sum, product", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum = 0\n    for i, n in enumerate(numbers):\n       sum += n\n       product = 0\n    return sum, product\n\nNice one. One additional note - the ::: in Python is a context manager, so you can use it to assign the result to a variable:\nsum_product = [1,2,3,4] * sum(numbers)\n\nI like the idea of a \"one-liner\" as an example, but I think it should be a one-liner in the language it is meant to illustrate.\n\nIt's a fine line to draw, and I agree that the Python line is a little blurry, but the other examples were excellent.\nI am curious, however, what the OP's criteria was for \"one-liner\" in the title of the article. I had assumed that it meant a short program that can be expressed in one line of code.\n\nI was trying to highlight the concept of using a dictionary in Python for a one-liner, instead of just using an integer for each value. I agree that it's blurry; I had considered using a sum", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in range(len(numbers)):\n       if numbers[i] == 0:\n          return (sum_product(numbers[i - 1], numbers[i]))\n        else:\n          return (sum_product(numbers[i], numbers[i + 1]))\n    return tuple(sum, product)</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    s, p = numbers\n    if len(s) > 0:\n        for i in range(s.len(0)):\n            p[i] += sum(s[i:])\n        return Tuple(s.sum(), p.product())", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    l = numbers.pop()\n    if len(l)!= 1:\n        return (sum, product)\n    l.sum += l.product\n\n I thought the sum and product should be of same type.\n\nThey should be. It's just that the example they chose is slightly broken.\nThe example is supposed to be equivalent to:\nsum_product([1,2,3,4])\nexcept that that would have to be written as:\nsum_product(0, 1, 2, 3, 4)\nwhere the type of the tuple is int, int, int, int, int.\nWhich, indeed, it should be.\n\nThis is like a javadoc that I'd put on an API method to be pedantic about the types.\nI can understand the point about not repeating the type name in every line if you're going to be using it a lot. But using 'from typing import List, Tuple' for a simple example like this seems a little overkill to me.\n\nYou must not have the 3rd edition of Effective Java.\nThis is a good example of a style that is", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (sum(numbers) for numbers in numbers) * (product(numbers) for numbers in numbers)\n\nI think a better solution would be to simply allow tuples to be stored in an array and not have to define a new data type.\n\nThere's been a good discussion on the python-ideas mailing list about this:</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    if numbers == [] or numbers == []:\n        return (0, 1)\n    for i in numbers:\n        sum = numbers[i]\n        product = numbers[i + 1]\n    return (sum, product)\n\nThis isn't quite the same thing, but it's close:\nimport itertools", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for number in numbers:\n       sum = number\n       product = number * number\n    return Tuple(sum, product)\n\nThis is a very clear example of how to write idiomatic Python. When I see code like this, I know the author understands the language's strengths and weaknesses, and has developed a style that fits the problem he's solving.\n\nI agree. But just because I understand the language doesn't mean I want to use it.\nThis is a good example of why functional programming has never taken off in Python. The language is not designed for it, and there are no idiomatic ways to do things like reduce.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n\nnumbers.sum()\nnumbers.product()\nreturn (numbers.sum(), numbers.product())\n\nNot Python, but I had to add this:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    n = 0\n    l = numbers\n    for i, x in enumerate(l):\n       if x == n:\n          return Tuple(n, 0)\n       if x % n == 0:\n          return Tuple(n, x * n)\n\nThis is a great example of how to create a DSL in Python.\n\nYou could also have written it as a single function. I think that's less of a DSL and more of a pattern.\n\nThis is a _great_ example of how to create a DSL in Python.\nIt's also a great example of how to write a _bad_ example of a DSL in Python.\n\nIf you had written it with multiple functions, it would have been a great example of how to create a DSL in Python.\n\nI don't think it's a _great_ example of how to create a DSL in Python, because it's so full of extraneous and unhelpful function-local variables, but it's certainly a great example of how to create a DSL in Python", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    lst = numbers\n    results = lst.sum(0)\n    results = lst.product(results)\n\n...\n\nfrom typing import TypeError\n\n    def sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    >>> sum_product([1, 2, 3, 4], [])\n    (10, 24)\n       TypeError: unsupported operand type(s) for +: 'Tuple[int, int]' and 'int'\n    \"\"\"\n    lst = numbers\n    results = 0\n    results = lst.sum(0)", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    if len(numbers) == 0:\n        return tuple(1, 1)\n    for i in numbers:\n         sum = sum(numbers[i])\n         product = product(numbers[i])\n    return (sum, product)", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    a, b = sum_product([])\n    for i in numbers:\n        sum_product(i, a, b)\n    return (a, b)</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for n, _ in enumerate(numbers):\n        sum_product = sum_product(n + 1)\n        product = product(n * n + 1)\n    return sum_product, product\n\n>>> sum_product([1, 2, 3, 4])\n(10, 24)\n>>> sum_product([1, 2, 3])\n(1, 4)\n\nThe code above can be easily understood. It is a fact that any decent IDE for Python will show you the type of code you are writing at the bottom.\nI don't think that anyone would argue that Python does not have a type system.\n\nThe comparison to C++ is probably more in terms of the stdlib. For instance, in Python, you'd have to write your own sum_product function.\n\nThat's completely incorrect.\n\nI'm referring to the last two paragraphs of the article, where it's clearly in terms of the stdlib.\n\nSo?\n\n_C++ has a type system, but it is so weakly enforced that people ignore it, or worse, code against its constraints._", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for number in numbers:\n        return tuple(sum(number) + product(number, number + 1))\nI'd replace the comma-separated list of integers with a list comprehension and let the compiler do the type checking for me.  The code becomes much more readable.\n\nI find list comprehensions and \"from x import *\" to be the best of both worlds.\n\nAs someone who uses TCL heavily, I always write my functions like this:\nfunction func(arg)\narg = arg or { error \"Please provide a value\" }\nend\nIt works for all my basic needs, and I've only had to write a couple of wrapper functions to pass around arrays/lists.\n\nSame with R.\n\nI love typing the first few lines of a new language, and seeing if I can figure out what it's doing.\n\nWhat does \"it's\" refer to?\n\nThe language, presumably.\n\nI'd say that's a pretty good sign, then.\n\nIt's not about the types, but the value of using a language which forces you to think more about the type of data you're passing around.\nPython", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    result = Tuple.fromlist(numbers)\n    result.sum += numbers[0]\n    result.product += numbers[1]", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return numbers.zip(*map(lambda x: x * x, numbers))\n\nIn a language without first-class functions (C++, Java) this is a perfectly valid, and probably useful, solution.\n\nI'm actually not sure this is a good idea in Java. It's just one method call away from a call to += and ++.\n\nNot that I'd ever want to write it, but I don't see anything in the Java language preventing such a thing.\n\nI don't see why not either, but then again I've seen some pretty insane things in Java that work so I wouldn't really put it past Java to have something that makes this valid.\n\nThis seems to be a good example of why Python is a great language for beginners. It allows you to express things in a very direct way, and sometimes you don't realize how ugly or inefficient your solution is until you've gained more experience.\n\nThis is also a good example of why Python should be used for small, highly-focused projects. It's a beautiful language, but it's very easy to write something in it that'll be horrible to maintain, and very difficult for another developer to wrap their head around.", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return sum_product(numbers)\n\nsum_product(numbers)\n\n>>> sum_product(numbers)\n(0, 1)\n\n>>>\n\n>>> sum_product([1, 2, 3, 4])\n(10, 24)\n\n>>>\n\n>>> sum_product([1, 2, 3, 4])\n(10, 24)\n\n>>>\n\n>>> sum_product([1, 2, 3, 4])\n(10, 24)</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in numbers:\n       sum = 0\n       product = 0\n    return sum + product\n\nI've seen this approach used several times on here, and it's probably fine for the particular task being discussed, but I don't really like it.\nIf you have a list of integers, you shouldn't need to import a module to get a list of integers, or a list of tuples. You should just be able to do:\nsum_product = [0, 1]\nAnd it should work without any imports, like:\nsum_product([0, 1])\n\nYou don't have to import it, you just import it for the sake of short-hand. It's a personal preference.\nI do agree with you that you shouldn't need to import anything for this.\n\nOh, I think that if you're using this style, it's for the sake of consistency. I just don't think it's actually that useful.\n\nWhat I like about the Django way is that you can import the functions _without_ having to import the module. You can even use some_func, without having imported any module,", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    a = 0\n    b = 0\n    c = 0\n    for _ in numbers:\n        a += numbers[i]\n        b += numbers[i] * c\n    return (a, b)\n\nfor i in range(100):\n    print(sum_product(range(0, 100)))\n\n?\\$\\begingroup\\$I don't see how this is Pythonic. This implementation is far from what Python's built-in list functions do. You are reimplementing them, but doing it in a way that's not even more concise or consistent than what Python already has.\\$\\endgroup\\$\n\u2013 Leonid ShifrinMay 19 '16 at 20:04", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum = 0\n    product = 1\n    while numbers:\n        sum += numbers[0]\n        product *= numbers[1]\n    return (sum, product)", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return Tuple(0, sum_product(numbers))\n\nThis is a good example of \"why not just do it in the interpreter\" for me. The article goes on to explain that the reason is performance.\n\nI think you are missing the point. The purpose is to illustrate how a functional language can be used to solve an iterative problem.\n\nI'm not sure that's a good way to introduce someone to a language. It's a good way to get someone to immediately dismiss it.\n\nI agree. But I think it's a good way to illustrate how functional languages can be used to solve iterative problems.\n\nTrue, but I think the point is that you can get to the same place without the overhead of a compiler.\n\nThat's a pretty sweet way to get to a recursion without the nasty overhead of a function call.\n\nI'm sorry, but I don't get it. Can anyone help me?\n\nFirst, note that in Python lists are mutable. To preserve a list's identity, you need to assign the list to something else:\n>>> a = []\n>>> a = [1, 2, 3]\n>>> a = [4,", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return sum(numbers.pop) * products(numbers.pop)\n\nThis is fine for a toy example, but it would be terrible for a real program. Here are a few problems with it:\n* There's no type error checking. The tuple of type \"Tuple[int, int]\" is returned, and if there's a type error in one of those arguments, the whole thing will blow up.\n* It's slow. Python is a fast language. Don't waste it.\n* It's not a \"type safe\" algorithm. Python allows you to specify the return type of functions, and for good reason. Your code should do the same.\n\n_It's not a \"type safe\" algorithm. Python allows you to specify the return type of functions, and for good reason. Your code should do the same._\nThe function has a type error check. As for speed, I don't see any problems if the list is short enough (by which I mean the algorithm is not used on large lists).\n_Python is a fast language. Don't waste it._\nIt's Python, not C. I don't think anyone cares about wasting a few extra bytes.\n\nI", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in range(1, len(numbers)):\n       numbers[i] + numbers[i+1]\n    return tuple(0, sum(numbers), product(numbers))\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    n = 0\n    for number in numbers:\n        if number < n:\n           n += number\n           sum_product(numbers[number:]) = n * number\n    return sum_product(numbers)\n\nI see this is from the 'official' docs, but it's such an incredibly simple example that the title seems ridiculous.\n\nI still don't understand why Python is so popular. It's very simple to learn, but the only things that it's simpler than are even simpler languages like Ruby. On top of that, it doesn't offer anything that other languages don't.\n\nYou answered your own question in your first paragraph. I use Python because of the simplicity. I don't want a language that is a \"one size fits all\", I want a language that I can fit into.\n\nThis would be a better argument if Python didn't have the same sort of simplicity, and Ruby didn't have the same sort of complexity.\nI just don't understand why people would choose the language that's only different in that it's _not", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    a = [0] * n\n    b = [1] * n\n    return (a, b)\n\nThis is a classic of the genre. It looks like a clever trick, until you realize that it's an abomination.\nThe author has invented a data type that is very much like a tuple (it is a tuple). But instead of providing a means to access elements with named tuple-like elements like \"x\" and \"y\", this data type provides access to elements with unnamed indices like \"a\" and \"b\". But the code using the data type is written as if the data type were a tuple.\nIt's a poor man's tuple.\n\nI like it. It's not a tuple, but it does the job (at least in this case) and has a clear structure. If I need to do something with a collection of numbers (like, say, sum them), I'll use a List, and if I need to do something with a collection of things of the same type (like, say, sum them), I'll use a Tuple. But I'll usually leave those to the built-in constructs.\n\nI think it is a good example", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    products = 0\n    for i in numbers:\n       products += i\n       sum = 0\n       for i in numbers:\n          if i * i > 1:\n              sum += (i * i)\n             sum /= 2\n           else:\n             sum += i\n    return sum_product(numbers)\nI would normally have used the functional style with lambda (List(numbers).sum()), but I wanted to keep the formatting of the post identical to the official Python reference.\n\nI'm not a python programmer, but I believe this is the same as python's sum() method, which returns a tuple:\n>>> sum([1,2,3,4])\n(10, 24)\n\nIndeed it is. But I wanted to demonstrate the sum_product method in the same way it was used in the official Python tutorial.", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    # Our numbers is a list of integers\n    numbers_sum, numbers_product = []\n\n    for i in numbers:\n         numbers_sum.append(i)\n\n    for i in numbers:\n         numbers_product.append(sum_product(numbers_sum))\n\nI think you meant:\nnumbers_sum = [0]\nnumbers_product = [0, 1]\n\nDoh!\n\nYes, good catch.\n\nI don't understand the purpose of this code.\n\nI think it's supposed to be an illustration of two fundamental operations on sequences:\nsumming and producting.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    a, b = 0, 1\n\n    for item in numbers:\n        if item in a:\n            a += item\n            b += item * b\n        else:\n             a = b = 0\n\n    return a, b</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in numbers:\n         sum = 0\n         product = 0\n    return sum + product</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum = 0\n    products = []\n    for i in numbers:\n        sum += i\n        products.append(sum * i)\n    return Tuple(0, sum, products)\n\nYou've missed the point of the article. The point isn't to show how to write a function, it's to show how to write a function that uses the standard library. You should write the sum_product function on your own, and then you can add it to the article.\n\nI don't think that's what the author meant. As you see in the article, he's showing you how to reuse the sum and product functions from the standard library.\n\nThe author of the article misses the point of the standard library.\nThe standard library is there so that you don't have to re- invent the wheel every time you want to implement a \"sum\" or \"product\".\nThis kind of code:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in range(1, len(numbers)):\n        sum = numbers[i] * numbers[i]\n        product = sum + numbers[i]\n    return tuple(0, product)\n\nWhat if the first number in the list was 0 or negative?\n\nHrm. Actually, it doesn't matter since you're using tuples. Shouldn't the\ncontents of the tuple be a tuple of [1,0] and [0,1] respectively?\n\nYou're right, and you can get even more efficient if you make the two tuples have the same length by doing:\nnumbers = [1,2,3,4,5]\nsum_product = [(1, 0), (0, 1), (1, 0), (0, 1), (1, 0), (0, 1), (1, 0), (0, 1)]\nThat way, instead of having to set up a new list for the right side of the product, you just pass in the original list. This saves one list-insertion and two list-lookups, which, if", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (sum(numbers), product(numbers))\n\nThat is a really bad way to write sum_product.\nThe problem is that you end up with a tuple like [(10, 24)] in the body of sum_product, but the outer function expects a tuple like [(1, 2, 3, 4), (10, 24)] (and even then it is not optimal).\n\nI think the point is that sum_product is the interface to sum and product, and lists of integers are simply an implementation detail.\n\nEven so, in Python the standard List interface is a lot more powerful and flexible than tuples, so you should use it for lists.\n\nYou're assuming that he's trying to write generic code. What if he's just trying to express his problem in a way that makes sense to him?\n\nThe problem is that it's not very readable.\n\nRight. I was thinking about the reverse-engineering aspect.\n\nThis is like saying from reading import List.\n\nactually, it's more like saying from typing import List, Tuple.\n\nI'm not a python guru, but what if the above code needed to be in a list comprehension?", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for number in numbers:\n        sum += number\n        product = number * number\n    return (sum, product)\n\nThis is so stupid. You can do this in Python:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    k, v = 0, 1\n    for num in numbers:\n       if num < k:\n          k = num\n        else:\n          v = sum(numbers[k:])\n    k, v += v, k * v\n    return k, v</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum, product = 0, 1\n    for i in numbers:\n        sum += i\n        product *= i\n    return sum, product\n\n>>> sum_product([1, 2, 3, 4])\n(10, 24)\n\n>>> sum_product([2, 4, 6, 8])\n(30, 36)\n\n>>> sum_product([3, 4, 5, 6])\n(30, 36)\n\n>>> sum_product([4, 5, 6, 7])\n(34, 40)\n\n>>> sum_product([5, 6, 7, 8])\n(40, 44)</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for num in numbers:\n        sum_sum = sum_sum + num\n        sum_product = sum_product + num\n    return (sum_sum, sum_product)", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return Tuple(sum_product(numbers), sum_product(numbers))\n\nThe last line in the code is _not_ the definition of sum_product. That is just how you _call_ sum_product.\n(There is a language construct called the \"lambda\" or \"closure\".)\n\nDoes anyone know what language/library that is? I'm fairly new to Python and didn't know about tuples and sum_product (but I'm sure I'll have to use it at some point).\n\nThe article's author says this is JavaScript (he links to a list of examples in JavaScript).\n\nI know it's javascript, but I was looking for the name of the language library that he used to define sum_product.\n\nWhat language?\n\ntuple, sum_product\n\nah\n\nWhoa, this is terrible.\n\nSo is your comment.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return [sum(numbers[i] for i in numbers), product(numbers[i] for i in numbers)]\n\nYeah, except this is neither readable nor clear.\n\nI'm not sure if that's supposed to be a jab at Python, or a comment on the bad naming and function declaration.\n\nIt's a jab at the fact that the parent post is a variation of a well-known Python meme.\n\nAh, gotcha. I didn't realize that.\n\nI am new to python, but from what I read from experienced programmers python is one of the most readable and easy to understand languages in existence.\n\nThe same can be said for other languages.\n\nI think most languages are more readable than C.\n\nPython code is pretty readable.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    from itertools import reduce\n\n    def reduce(f, xs):\n         return (x, f(x))\n\n    for number in numbers:\n         if number == 0:\n            return (0, 0)\n          else:\n              reduce(sum_product, number)\n\n    return (sum, product)\n\nfrom typing import Tuple, Enum, Function, Type, TypeError\n\n def sum_product(numbers: List[int]) -> Enum[Tuple[int, int], int]:\n    \"\"\" For a given list of integers, return an enum consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    def sum_product_first(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product_first([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    if len(numbers) == 1:\n       return sum_product(numbers)\n    else:\n       return sum_product_first(numbers)\n\nIsn't this a classic case of overuse of inheritance?\n\nPersonally, I would rather implement this in terms of a functional interface:\nimport sum_product\nsum_product(numbers: List[int]) -> (sum, product)\nsum_product_first(numbers: List[int]) -> (sum, product)\n\nI think this is a clear-cut case of the ternary operator being used to implement a special", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    result = tuple(sum(numbers), product(numbers))\n    if sum.is_empty:\n        result = result[0] + result[1]\n    elif product.is_empty:\n        result = result[0] * result[1]\n    return result", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in numbers:\n       total = 0\n       products = []\n       sum = 0\n       for j in range(numbers.size):\n          total += numbers[i]\n          if numbers[i] % 2 == 0:\n              sum += 1\n             products.append(sum * numbers[i])\n             sum /= 2\n             if products:\n               products.append(total / numbers[i])\n              products.append(products[0].total / numbers[i])\n    return sum, products\n\nSo it seems like the author of this solution has never used tuples before, and has decided to invent his own weird format.", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in numbers:\n        if i == 0 or i == 1:\n            return Tuple(0, 1)\n        else:\n            return sum_product(i - 1, numbers[i - 1])\n\nfrom typing import List, Tuple, Any", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n\nI've seen that pattern before. I don't like it.\n\nWhile I agree with you, it's a good example to demonstrate this idiom, as it's pretty standard.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    result = []\n    for i in range(numbers.count()):\n       result.append(numbers[i])\n    return sum(result) + product(result)\n\nFrom the article:\n\" _Given the fact that the most widely used version of Python (2.7) doesn\u2019t have a built-in function that returns the sum of a list of integers, the above code is necessary._ \"\nUmm... What?\nPython 2.7 doesn't have sum() or any other built-in function that returns the sum of a list of integers? That's so weird.\nPython 2.7:\n>>> sum([1, 2, 3, 4])\n10\nThe article was written in July 2011, so I wonder what version of Python was used.\n\nI believe it's referring to the fact that sum is a built-in function in Python 2.7, but is not in Python 3.\n\nAh, I see. I hadn't heard of Python 3 before.\n\nI like that the author has a comment at the bottom of the article, explaining that some of the code he shows is \"g", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return sum(numbers) + products(numbers)\n\nNice! :)\n\nYep. And from my experience, this is the approach that is the most comprehensible and easiest to learn.\n\nI'm not sure I understand the benefit of this over using the more familiar sum() and products() functions.\n\nPython has sum() and products() as standard functions. I don't know about Ruby.\nHowever, this is a simple demonstration of how to define a function that returns another function.\nI do a lot of functional programming (specifically Haskell) and it's very useful to have a general-purpose solution like this.\n\nAh, I understand now.\n\nSo basically the same thing as sum() and products() in Python. This is not actually a useful thing to know, or a benefit over sum() and products().</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return Tuple((0, 1), (1, 2, 3, 4))", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum_product = lambda x, y: x + y\n    def add(l: List[int], x: int) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> add([1, 2, 3, 4], 1)\n    (2, 3)\n    >>> add([1, 2, 3, 4], 2)\n    (3, 4)\n    \"\"\"\n    add = lambda l, x: l + x", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in numbers:\n       sum = 0\n       product = 0\n       for j in numbers:\n          sum += i\n          product += j\n    return (sum, product)\n\nOK, that was the easy part. Here's the tricky part:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum = 0\n    product = 0\n    while len(numbers) > 0:\n        product = sum * numbers[-1]\n        sum += products[-1]\n    return (product, sum)\n>>> sum_product([1, 2, 3, 4])\n(10, 24)\n\nAs opposed to the original post, this version is understandable and looks reasonable.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum = 0\n    for i in numbers:\n       sum += i\n    product = 1\n    for i in numbers:\n       product *= i\n    return sum, product\n\nThis is essentially just a type-hinted version of map(), and a very Pythonic one, at that.\nI've never had a problem with map(), but I'm tempted to steal this code to replace it.\n\nI love type hinting. I often find myself writing quick code without types (not that Python is a strongly typed language), but once I run into a bug I know it's either a bug in my logic or a bug in my implementation. Once I have types I know immediately where the problem is.\n\n_I often find myself writing quick code without types_\nIt's all fun and games until you get a cyclic reference.\n\nI use python because I don't need to think about types and can just write the code. I could care less about what I'm writing.\n\nI prefer to think about types. If you do something wrong, the compiler or IDE should yell at you, not", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    a = 0\n\n    for i in numbers:\n        if i == 0:\n            a += numbers[i - 1]\n            return (a, a * a)\n\nNice.\nThe same can be done using a generator expression:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    result = 0\n    for number in numbers:\n         if number is not None and number % 2 == 0:\n             result += number\n          if number is not None and number % 2 == 0:\n              result *= number\n          return (result, result)\n\nNow let's write sum_product_with_delayed_output:\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return sum(numbers) + product(numbers[0], numbers[1:])\n\nNo, it's not. It's a self-contained and easily understood solution, but that's not a definition.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n\ni think the correct syntax for tuples is\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n\nI'm sure there's something I'm missing, but why can't this just be a sum and a product? What does the tuple business do?\n\nIt looks like the sum_product() method is a class method, that would make it part of the sum_product class. You cannot have a method return a list of methods (tuple), but you can return a class object.\n\nWell, you can if you write a class that has a method of that name (or a method with the same name that returns a list of methods)\n\nI was going to say, you could always write a class and just use the class.\n\nI was hoping someone would address the question of why it's useful to have a sum_product() method on a list instead of just the sum and product methods. Is it just to demonstrate the syntax for defining methods?\n\nYup, it's just a way of writing functions that return other functions.\nIn Python, a function that takes no arguments is a method of the object that defines it, so this is basically just a way of defining a function that returns another function, which you can do in Python by just writing a function that takes no arguments. It's a little easier", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n\ni see nothing wrong with it. it's a fine way of expressing the idea.\n\nIt's not an idiom, it's a good code practice. In other words, the language can't change to encourage it, people have to learn to write idioms.\n\ni like it when the language helps me express the idiom, though.\n\nOK, but \"from typing import List, Tuple\" would only help if you were using an interpreted language, because in an interpreted language, you would be able to see the Python interpreter in action. In other words, you wouldn't have to have been familiar with the syntax of Python to see that the code you were writing was syntactically correct.\n\nthe language wouldn't have to help me express the idiom. it would just have to help me identify it.\n\nOK, so then in your opinion, what was the point of this submission?\n\nto be a link to a discussion about good code practices in python, and how to learn to recognize them, and perhaps to look at how other people have expressed idioms.\n\nWhat do you mean by \"learn to recognize them\"? The concept of an idiom is not something that you can learn to recognize", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    i = 0\n    for i in numbers:\n       sum += i\n       product = product + sum\n    return (sum, product)</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    numbers.sort()\n    i = 0\n    while len(numbers) > 0:\n       total = 0\n       for i in numbers:\n          total += numbers[i]\n          numbers[i] *= numbers[i]\n          i += 1\n    return tuple(sum=total, product=numbers.index(i), i=i+1)\n\nI don't know why, but the 'numbers' parameter of sum_product is really distracting.\nIs there a reason you didn't just use:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (sum(numbers), product(numbers))\nI have no idea how this could be written in only 7 lines.\nFor the curious:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    n = len(numbers)\n    return (sum = 0, product = 1)\n\nI am not sure what the point of this is.\n\nI can only assume that he wants to learn about python's functional features.\n\nI think the point was to show how a very simple function that is normally not the kind of thing you'd write in Python can be written in a concise and clear manner using the language's new functional features.\nI think it's a good example of functional programming being _simple_. If you wanted to write the same function in Java, you'd have to learn about lambda expressions and anonymous classes, and write some boilerplate code. With Python, you just write a function.\n\nExcept that the example doesn't show how to use the new Python functional features. The new features let you write sum_product as \"sum, product = lambda x: sum(x) * product(x)\", but this example uses a special syntax for defining sum and product.\n\n>sum = 0\n>product = 1\nThere, now you can write your own sum_product.\n\nHow does that help?\n\nThe point is that you can write it without using the new", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    n = 0\n    for n in numbers:\n        sum_n = n\n        product = n * n\n        return (sum_n, product)", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    numbers_sum = numbers.sum()\n    numbers_product = numbers.product()\n    numbers_sum_product = sum_product(numbers_sum, numbers_product)\n\nWhile this is certainly a nice trick, it's not as easy to read and understand as the original code. It's also not so nice to write when you're used to python. I know, it's a joke, but still, it's not that funny.\n\nFrom my perspective, it's not a joke at all. I'm using Python for a long time and I think, this syntax is much more readable than what I'm used to.\n\nNot sure if this is good or bad, but I've had this syntax burned into my head from some of my early forays into C programming.\n\nI think I would have tried to implement this in Python and then get frustrated with some of the idioms in Python. It was nice to see a reasonably idiomatic solution in another language, even if I could not easily follow it.\n\nIt's nice to see a 'tuple' that doesn't use parentheses, but that's really the only thing I see that would make this more readable", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    def sum(x: int):\n        return x\n    def product(x: int):\n        return x*x\n    def sum_product(numbers: List[int]) -> Tuple[int, int]:\n        if len(numbers) == 0:\n           return (0, 1)\n          if len(numbers) == 1:\n            return (1, 1)\n          for x in numbers:\n             if x == 0:\n                   return sum(x)\n                   if x == 1:\n                     return product(x)\n    return sum_product(n", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum = 0\n    prod = 1\n\n    for i in numbers:\n        sum += i\n        prod *= i\n    return sum, prod\n\nval it = sum_product(range(10))", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for n in numbers:\n       if n == 0:\n          return [0]\n       sum = 0\n       product = 1\n    else:\n       sum + = n\n       product * = n\n    return sum_product(numbers)</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum = Tuple[int]()\n    product = Tuple[int]()\n    for i in numbers:\n        sum += i\n        product = product * sum\n    return sum, product", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n\nimports\n`numbers`\n`sum_product`\nnumbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\nsum_product(numbers)\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for number in numbers:\n       sum = 0\n       product = 0\n       if number not in (0, 1):\n          sum += number\n          product += number\n       if sum == 0 and product == 1:\n           return sum_product(numbers[:-1])\n    return sum_product(numbers[:-1])\n\nI have to say, I don't find this particularly elegant.\n\nWhat would you use instead?\n\nI'd just write it like any other function, except with a tuple to return.", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for number in numbers:\n        sum = sum + number\n        product = product * number\n    return tuple(sum, product)</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    def sum_product(numbers: List[int]):\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    if numbers.size() == 0:\n       raise Exception(\"This function can't be used with empty list\")\n    return [0, 1]\nelse:\n    sum_product(numbers)\n\nI think that sums and products are too orthogonal to be in the same class.\n\nYeah, I just wanted to add that you can use tuples as if they were lists without explicitly mentioning that.\n\nTuple is a list in Python, so that's not really news.\n\nI was hoping to make it a bit more explicit.\n\nWhy not just use the sum method on lists? \n\nNah, it's more like a sum and a product", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    def sum(i: int): int = 0\n    def product(i: int, j: int): int = i + j\n    def output(): Tuple[int, int] =\n       def sum_product(numbers: List[int]) -> Tuple[int, int]:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return [numbers[0] + numbers[1], numbers[2] * numbers[3], numbers[4] * numbers[5]]\n\nI was expecting the code to do something else with the empty tuple and get confused.\n\nNeat.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    def sum(i: int) -> int:\n    \"\"\" Return the sum of all the integers from the list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum([1, 2, 3])\n    (3)\n    >>> sum([1, 2, 3, 4])\n    (9)\n    >>> sum([1, 2, 3, 4])\n    (3, 9)\n    \"\"\"\n    return sum([1, 2, 3], i)\n    def product(i: int, j: int) -> int:\n    \"\"\" Return the product of all the integers from the list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> product([1, 2, 3, 4])\n    (4, 9)\n    >>> product([1, 2, 3, 4])\n    (9, 24)\n    \"\"\"\n    return product([1, 2, 3],", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    nums = numbers.reverse()\n    for i in range(0, len(nums)):\n        for j in range(0, len(nums)):\n              sum = sum_product(nums[i], nums[j])\n              product = sum_product(nums[i+1], nums[j+1])\n              return (sum, product)\n\nI am unfamiliar with Python, but I would imagine it is possible to write a wrapper for sum_product that would be just as readable. I would also imagine that it would be more readable.\n\nYes, but that would be a violation of the \"three laws\" (of Python) of \"Don't Repeat Yourself\", \"Explicit Is Better Than Implicit\", and \"Names Should Be Spaced Consistently\".\nThat is, if you want to write your own sum_product, then you are _forbidden_ to call it sum_product, because that name is already defined", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum = 1\n    product = 0\n    result = sum + product\n    result_count = 0\n    for i in numbers:\n        if i % 2!= 0:\n            result_count = result + i\n           sum += i\n           product += i\n         else:\n            result_count = 0\n           product += i\n           sum += i\n    return result_count, sum, product\nThis is my preferred way to do it as well.\n\nFor those wondering, sum_product is a trivial implementation of the foldr/reduce functions from functional languages, most prominently Haskell.\n\nNote that the sum_product function is completely unnecessary. I could write the same function without the class declaration. I like that it's a class because it makes it slightly easier to read, and it makes it", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    result = []\n    for number in numbers:\n        result.append(sum(number))\n        result.append(product(number, number))\n\nI am not a Python expert, but I am fairly certain that this is a bad idea.\nWhen I think of a \"List\", I think of something that is immutable, which means that I don't think that I would want to \"append\" something to it.\n\nYou can actually add to lists in Python:\nTuple(1,2,3) += 4\nThe += operator is just a method of tuples. But you can't add to lists. Lists are immutable.\n\nI'd be surprised if tuples weren't mutable.\n\nI think the point is that tuples and lists are related, but not the same.\n\nThis is definitely bad style.\nWhy are these abstract classes and not just normal ones? Because the programmer probably doesn't know any better. (I certainly didn't when I first wrote Python)\nWhy are the classes so close together? Because the programmer doesn't understand scope.\nThe import list is wrong, too. T", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum_product = lambda x, y: x + y\n    return sum_product(numbers)\n\nI hate when people do this. It's not very hard to make a type signature that describes the _behavior_ of your function, as opposed to the types of its parameters, which are almost always obvious from the context.\n\nWhat's the problem with this? It's clear what the function does by reading the type signature, and it's obvious that it requires a list of ints and returns a tuple.\nI guess the problem is that the declaration is longer than necessary, but I've never felt that verbosity was a problem in python.\n\n_but I've never felt that verbosity was a problem in python._\nThat's because you don't have to write Python code that is very long, and it's not a problem when you're looking at the code.\nI wrote a module in Python that I later had to maintain, and the import-statement was taking more and more space as more and more modules were being used.\nIt was a very simple module (for testing), and all it was doing was importing modules and calling their functions, but still the import statement had gotten longer", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in range(numbers.size):\n          s = sum(numbers.get(i))\n          p = products([numbers.get(i), numbers.get(i+1), numbers.get(i+2)])\n          return (s, p)", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (sum(numbers), product(numbers))\n\nI usually go with\ntype(s) = {\nsum: int,\nproduct: int\n}\nand then define sum(s) = sum(s.product) and product(s) = product(s.sum)\nIt's a bit more verbose, but I like the explicitness.\n\nMyself, I define a sum and product type as:\ntype s =\n| Sum of x | Product of x * y\nand the toString method:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n\nI just typed this in like 30 seconds and I know it's not pythonic, but that doesn't mean it's not clear or that I can't follow it.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return Tuple(sum=0, product=1)\n\nThe other day I implemented this in python and in C++ (first time for both languages).\nIn the case of python I had to generate a wrapper class (as tuples were not available in python 2.7).\nIn the case of C++ I used the tuple template and the lambda function.\nThe C++ version ended up being around half the size.\n\nIn addition to this, the C++ version can be used for any type, not just integers.\n\nAlthough it is true that the C++ version can be used with any type, the python version can also be used with any type, since tuples are classes and not just objects.\n\nIs that actually the case in Python? I thought tuples were just objects and the \"Tuple\" class was just an implementation detail.\n\nYes, a tuple is an implementation detail. You can use a tuple just as easily with integer lists as with strings.\n\nThis one looks more readable:\nimport sum, product", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum = 0\n    product = 1\n    for i in numbers:\n        sum += i\n        product += i * i\n    return [sum, product]\n\nThis is what I was looking for, thank you.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum, product = 0, 1\n    for number in numbers:\n        sum += number\n        product = sum * number\n    return (sum, product)", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (sum(numbers), product(numbers))", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    if len(numbers) == 0:\n        return 0, 1\n    if len(numbers) == 1:\n        return 1, 2\n    for x in numbers:\n        sum = 0\n        product = 0\n    if x == 0:\n        sum += x\n        product += 2\n    else:\n        sum *= x\n        product *= 2\n    return sum, product\n\nA list comprehension is a good way to write the above.\n\nThe numbers() function in Python 2.5.3 is the most verbose way of writing the above.", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in numbers:\n         sum = sum + i\n         product = product * i\n    return tuple(sum, product)\n\nfrom typing import *", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n\nIf you are using Python 2.7 or later, you can just use this:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (0, 1)\n\n>>> sum_product([1, 2, 3, 4])\nTraceback (most recent call last):\nFile \"<stdin>\", line 1, in <module>\nTypeError: 'Tuple' object does not support item assignment\n\nIs this a joke? I don't know Python so I have no idea.\n\nIt's probably a joke, but no one knows Python that much.\n\nThis is one of the most useful comments I've read in a long time.\n\nSomebody does.\n\nand his name is [Christopher] Walken</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n\nOne more:\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    numbers.sort()\n    return sum_product((x, y) for x in numbers if x * y < n)\n\nThis code is so verbose I want to cry. How can you write code like this and not realize how bad it is? I'm serious.\nThe code should be:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    product = product(*numbers)\n    sum = 0\n    for i in numbers:\n        product += i\n        sum += product\n    return (sum, product)", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    def f(nums: List[int]) -> int:\n    \"\"\" The sum of a list of integers is equal to the product of all integers in a list.\n    The product of all integers in a list is equal to a sum of the product of all integers in a list.\n    \"\"\"\n    return 1\n    for num in numbers:\n       return f(nums.pop(0)) + f(nums.pop(1))\n    return Tuple(0, 1)\n\nWhat the heck is a List[int]?\n\nIt's a list of ints. I mean, it's not hard to figure out...\n\nI wasn't complaining about the syntax. I was complaining about the fact that he wasn't using an explicit type.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    a = 0\n    b = 0\n    for i in numbers:\n        a += i\n        b = product(a, i)\n    return Tuple(a, b)\n\nI wrote something similar yesterday to find the sum of all integers in a list:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n      sum = 0\n\n      for i in numbers:\n         if sum == 0:\n             sum += i\n\n             product = 0\n\n             if product == 0:\n               product += sum\n               product = sum * i\n             return product, sum\n\nI really like this.\nI'm not sure how common tuple's are in Python, but I've found a few use cases for them, especially if you have to repeatedly apply a function to a list of objects.\n\nTuple is the new list.\n\nThis is why Python is one of my favorite languages.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return\n    list(numbers).sum()\n    *\n    list(numbers).product(sum_product)\nWhy is the second argument to * a tuple?\n\nlist(numbers).product(sum_product)\nis a tuple.\n\nIt's a tuple, but it's not a tuple of ints.\nsum_product.apply(numbers).\n\nYou're right. I haven't done much with Python lately.\n\nType annotations in Python: The good, the bad, and the ugly\n\nthis is nice and all, but i really wish pythongod would quit it with the dumb little one-off languages. if you want to make a new language, make a new language. don't just make a half-assed new language that serves as a stopgap for something that doesn't yet exist in python.\n\nIt's not a new language, it's just an annotation to existing Python code.", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum = 0\n    for i in numbers:\n        sum += i\n        products = [sum * i for i in numbers]\n    return (sum, products)\n\nfrom typing import List, Tuple\n\n\tdef sum_product(numbers: List[int]) -> Tuple[int, int]:\n\t\t       sum = 0\n\t\t       products = [sum * i for i in numbers]\n\t\t       return (sum, products)\n\nHow is this better than the original?\n\nIt's more pythonic.\n\nI don't see how. The original doesn't use a single global.\n\nNeither does the second one.\n\nI have seen a few people recently advocate against using global variables. As I can't imagine why this is a bad thing, I am wondering if someone could explain to me why this is a bad thing to do.\n\nIt makes your code less readable, because you are depending on the order of your imports.\nIt also makes your code less maintainable, because it introduces dependencies", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    n = len(numbers)\n    return tuple(sum(numbers[0]), sum(numbers[1] * numbers[2] * numbers[3] * numbers[4] * numbers[5] * numbers[6] * numbers[7] * numbers[8] * numbers[9] * numbers[10] * numbers[11] * numbers[12] * numbers[13] * numbers[14] * numbers[15] * numbers[16] * numbers[17] * numbers[18] * numbers[19] * numbers[20] * numbers[21] * numbers[22] * numbers[23] * numbers[24] * numbers[25] * numbers[26] * numbers[27] * numbers[28] * numbers[29] * numbers[30] * numbers[31] * numbers[32] * numbers[33] * numbers[34] * numbers[35] * numbers[36] * numbers[37] * numbers[38] * numbers[39] * numbers[40] * numbers[41] * numbers[42] * numbers[43] * numbers[44] * numbers[45] * numbers[46", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    if len(numbers) == 0:\n       return (0, 1)\n    values = map(sum_product, numbers)\n\n    return tuple(\n       sum_product(0),\n       sum_product(values[0]),\n       sum_product(values[1])\n\nThis is quite a nice implementation of the sum-product algorithm, but it is not an improvement over the standard library implementation:\nsum_product(x)", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in numbers:\n         sum = 0\n         prod = 0\n         for j in numbers:\n             sum += i * j\n             prod += i\n    return sum, prod\nThis is very poor code. It's messy and difficult to read. Here's a better way:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    s, p = numbers\n    if len(s)!= 1:\n       raise ValueError(\"product and sum must be 1 or 2\")\n    else:\n       sum = sum(s)\n       p = sum_product(s)\n    return (s, p)", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    list_of_numbers = [None, None, None, None, None, None, None, None, None, None]\n    return (sum_numbers, product_numbers)", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (sum(numbers)) + (product(numbers))", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return sum_product(numbers)\n\n>>> (sum_product([1, 2, 3, 4]))(1, 2, 3, 4)\n(10, 24)\n>>>\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return numbers.sum(numbers.map(sum), numbers.map(product))\n\nwhat's wrong with that? it's just a list comprehension.\n\nI think the \"obvious\" part is that you're using the \"::\" operator to create an anonymous inner function. This is especially surprising, since most people don't know that you can use this syntax for anonymous inner functions, or that you can use it for anything but operator overloading.\n\nNot really, you can do it with list comprehension as well.\n\nSo, this is about Python's sum() and product() functions and how to write a sum-of-products function?\n\nYes, I don't think there's anything particularly wrong with the code, but it is an example of the type of code that I would not expect to see in a large project with many developers. It's a prime example of the anti-pattern I refer to in the article, and that I discussed in more detail on my blog: \n\nI disagree that the code in the OP is an example of a bad thing. You might not see it in a large project, but I use this pattern all the time. It's pretty much the same as", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum = 0\n    product = 1\n    for i in numbers:\n       sum += i\n       product *= sum\n    return (sum, product)\n\nThanks for the post, but I'm curious why you chose tuples over lists for this.\n\nI'm no expert, but my guess is that the only time you would choose tuples over lists would be when the only way to access a value in a tuple would be to call another function that needed to have access to all the values in the tuple.\n\nWhich is why it should have been\nfrom typing import List, Tuple, Any, A", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n       sum = 0\n       for i in numbers:\n          sum += i\n          sum += sum\n          product = sum / sum\n          sum_product(numbers[i:])\n    return [product, sum]</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in range(0, n):\n       for j in range(0, n+1):\n          sum = 0\n          product = 0\n          if numbers:\n              sum += numbers[i]\n             product += numbers[j]\n             return sum, product", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    def sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    for i in numbers:\n        yield sum_product(i)\n    return (sum_product(numbers), sum_product(numbers))</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    a, b = 0, 1\n\n    return List(a, Tuple(b, Tuple(numbers.get(i)), (numbers.get(i + 1), i)))\n\nso, what's the point? this is just a function that does one step of the above code\nsum_product = lambda x: lambda y: lambda z: lambda numbers: lambda i: lambda j: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum: lambda product: lambda sum", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for number in numbers:\n        sum += number\n        product = sum / number\n    return (sum, product)\n\nThis can be written more succinctly, if you are using Python 3:\n\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    if numbers:\n        return (0, 1)\n    a, b = 0, 1\n    for i in range(numbers.size):\n        for j in range(numbers.size):\n             a, b = a + numbers[i][j], b * numbers[i][j]\n         return (a, b)\n\nPEP 8:\n\"Be liberal in what you accept, and conservative in what you emit.\"\n\nIf you want to be conservative, don't call it sum_product, but sum_and_product (or sum_product_1 and sum_product_2).\n\nThis is similar to python 3.3.2:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    # Make a new tuple of size (sum, product)\n    numbers_to_sum = []\n    numbers_to_product = []\n    # Check if any numbers are missing from the list\n    if len(numbers) == 0:\n        raise Exception(\"You must have at least one number in the list to sum and product it.\")\n    # Set sum and product to 0\n    sum = 0\n    product = 0\n    # Initialize sum_product tuple to be empty\n    sum_product = []\n\n    # Loop through each number in numbers\n    for i in range(0, len(numbers)):\n        # Make a new sum_product tuple\n        sum_product.append(sum(numbers[i]))\n        product_sum = sum_product.sum\n        product = product_sum.product\n        # Increment sum and product", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    if len(numbers) == 0:\n        return (0, 1)\n    for i, number in enumerate(numbers):\n        if i == len(numbers):\n             return (sum_product(numbers[i], numbers[i+1]))\n             else:\n              return (sum_product(numbers[i], numbers[i+1]) + products[i])\n\nThis was posted on reddit before. I think it was on /r/python.\n\nYes, I saw it there a while ago, and have been using it.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (sum(numbers), product(numbers))</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    numbers.map(int)\n    sum = 0\n    product = 1\n    for i in numbers:\n        if i % 2 == 0:\n           sum += i\n        product = product * (i + 1)\n    return sum, product\n\nI have a question. Why would you use python over say, java?\n\nJava doesn't let you declare functions with variable numbers of arguments.\n\nYou can't just create a sum and a product?\n\nPython doesn't let you declare a function with variable numbers of arguments.\n\nThe comment I was responding to was talking about variable number of arguments.\n\nPython does not let you write a function with variable numbers of arguments.\n\nI know. I was responding to the comment which said you couldn't do this in Java.\n\nI'm not sure I understand what you're trying to say.\n\nI'm just not sure why you're so obsessed with this.\n\nI don't think I'm being obssessive about anything. I'm not trying to pick a fight.", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (sum_product(numbers) for numbers in numbers)\n\nNote that Python does not need tuples as there is no way to create a tuple in Python. This is simply a language that has the feature and can be used for example as a template to create tuples in any language.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return [\n         sum = 0,\n         product = 1\n    for x in numbers:\n         sum += x\n         product *= x\n    ]\n\nHmm, I was kind of hoping for something similar to:\n\n(x:xs)(y:ys) = x.sum(y.product(x))\n\nYou can achieve that with tuples and partial application of function arguments:\nsum_product = (x:xs)(y:ys)(x.sum(y.product(x)))\nsum_product([1, 2, 3, 4])\n(10, 24)\n\nYes, I realized that too when I went to post my comment. I just hate that it requires a parenthesized tuple and you can't write it as a one line expression.\n\nBut once you have a language that lets you pass functions around like this, you can write the definition as a one-liner.\n(x:xs)(y:ys)(sum_product)\n(10, 24)\n\nI'm", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum = 0\n    for i in numbers:\n       sum += i\n    product = sum * (i + 1)\n    return (sum, product)\n\nThere's a variant which works well for matrices, because the inner list can be replaced by a matrix:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return numbers.sum(numbers.map(numbers.product))\n\nFrom looking at the implementation of sum_product, it looks like this code:\nsum_product(list_of_integers)\n{\n    return list_of_integers.sum().product()\n}\ncould be rewritten as:\nsum_product(list_of_integers)\n{\n    return list_of_integers.sum(list_of_integers.product())\n}\nIn both cases, we are operating on the integers in the list. The only difference is that in the second version, we are using list.sum() and list.product() instead of list.sum(...) and list.product(...). That is, the code in the first example is not tail recursive, and the code in the second example is tail recursive.\n\nFor the first example, this is a bad implementation because it doesn't generalize well. If we wanted to sum a list of tuples, we would have to change the implementation of sum_product to accommodate this.\nThe second example is a good implementation because it is generic. I don't know much about functional", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for number in numbers:\n        sum = 0\n        product = 0\n\n    sum += number\n    product += number\n    return tuple(sum, product)\n\nPython has sum() and product() built-ins, but I never learned how to use them.\n\nThey are iterators, and one would do it by looping over the numbers, then using sum() and product() to get the sum and product of each number:\nsum_product([1, 2, 3]) = sum([1], product([2, 3])).\nsum_product([1, 2, 3, 4]) = sum([1], product([1, 2], product([3, 4]))).</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    tuple = tuple()\n    for i in numbers:\n        i_sum = tuple[i]\n        i_product = i_sum * i\n    tuple[i] = tuple[i_sum] + i_product\n\ncan be simplified to:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    if len(numbers) == 1:\n       return (1, 1)\n    else:\n       return (sum(numbers), product(numbers))\n\nNo, it's not \"idiomatic\" and there are better ways of doing it.\n\nCan you provide examples? I would be interested to see them.\n\nI used this technique in the old days of Java, but would've done it differently now:\ninterface SumProduct {", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in numbers:\n       if i!= 0:\n          if i == 1:\n             return sum(i)\n          else:\n             return product(i, i + 1)", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (sum(numbers), product(numbers))", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    n, sum, prod = numbers.flatmap(lambda n: sum + prod)\n\n    return sum + product\n\nThe sum_product function is more idiomatic than the sum function.\n\nOne could even remove the flatmap and use list comprehension:\n[(n, sum(n)) for n in numbers]\n[(n, sum(n), prod(n)) for n, sum, prod in zip(numbers, (n, sum(n)) for n in numbers)]</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (sum(numbers) for n in numbers)\n\nSo there's no way to pass in a lambda as the first argument?\n\nNo, there is. But sum_product is not the right place for that.\nWhat's the point?\n\nIn languages like Ruby, you can do things like this\n(list1.inject(lambda { list2 })\n.map { |x| x * 2 }\n.collect { |y, z| y + z })\nto map and reduce without having to write each step explicitly.\n\nThis is one of the reasons I prefer Python. What's the point of making it look like ruby?\n\nI prefer Python too, but I don't see anything wrong with making it look like Ruby. I guess it's because I prefer Ruby.\nIt's not like it's a real feature of Ruby, it's a hack that allows you to write cleaner code.\n\nI'm not sure I'd consider it a hack. It's more of a DSL.\n\nIt's a hack because it's not the way Ruby is designed to be used. It's not an intentional feature that was added to the language to make it more usable.", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (sum(numbers) + product(numbers))", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    numbers.sort()\n    for x in numbers:\n       return (x+1) * (x+2)\n\nThis isn't \"from typing import List, Tuple\". This is \"from typing import sum_product\".\nThat is, sum_product doesn't make any use of the List and Tuple typeclasses.\n\nIt's interesting that this uses sorting to order the numbers, but you can't sort tuples (or, at least, I don't think you can - I've always used a list of tuples as a workaround.)\n\nYou could make a sorted tuple, but you'd have to implement the Comparable protocol yourself.\n\nYes, I've done that before. (We use tuples heavily in Python for game AI, so this was a common use-case.) I think the logic is something like this:\n(Not in Python, but...)", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    a, b = Tuple()\n\n    return (sum(numbers), a*b for numbers in numbers)</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    numbers = numbers.reverse()\n    i = 0\n    for i in numbers:\n        sum = sum_product(i)\n        product = sum_product(i + 1)\n    return tuple(sum, product)\n\nThis is incorrect. An empty tuple is [0,0] in Python, and the sum of [0,0] + [0,1] is also [0,0], not 1. You can get around it by assigning 1 to the sum and 0 to the product.\n\nYou're right, I just fixed it. Thanks for pointing it out.\n\nI don't think it's a good idea to use \"from\" at the top of a file. It would be better to import the module later on in the file, so that the imports from other modules are taken into account when compiling the file.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    if numbers:\n        return (0, 1)\n    # if all the numbers in the list are of the same type, just return the sum and the product\n    # we don't need to perform any more calculation\n    for i in numbers:\n         if i == 0:\n            return (sum(i), product(i))\n    # else if all the numbers in the list are of the same type, we need to add more stuff to the tuple\n    # we need to add a leading 0 to the sum, and a trailing 0 to the product\n    # and also for the elements that have a leading 0, we need to add a trailing 0 too\n    else:\n         return (0, sum(i), product(i)) +", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in numbers:\n       sum = sum(numbers[i])\n       product = product(numbers[i])\n    return sum + product\n\nThe sum and product methods are interesting examples, as they are examples of the \"duck typing\" approach to type declaration.\nIn this case, the List and Tuple types are _only_ used to define the sum_product function, and the function itself has no knowledge of them.\n\nThis would be clearer if the function signature looked like this:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return sum(numbers) + products(numbers)\n\nI like it. I'd like to see some other module for it, though.\n\nThe author should post the python code, even if it's not as elegant.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    tuple = Tuple(sum=0, product=1)\n    for number in numbers:\n        sum += number\n        product += number\n    return tuple\n\nNo real point in this submission. I just thought it was a nice example of how to use a built-in datatype in Python.\n\nWhat about the more pythonic way of doing this?\nsum_product = lambda x: sum + x\nsum_product([1, 2, 3]) # (3, 6, 9)\nsum_product([1, 2, 3]) # (0, 1, 2)</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n\nInteresting. I wrote something similar to this a few years back, and now I am using the same thing in Go for a queue implementation.\n\nIt seems that it's good at type inference.\n\nIt's a list. You can probably infer the type of the thing being iterated over.\n\nI don't think you can do that in most dynamic languages.\n\nThe more interesting question is, what other useful type definitions can you make up?", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum = 0\n    product = 0\n    for i in numbers:\n         sum += i\n         product += sum * i\n    return sum, product</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return sum_product(numbers)\n\nThe function returns a tuple of integers (sum and product) for each number in the list.\n\nThe function looks like\n     sum_product(\n        list_of_numbers,\n        [\n              0,\n               1\n        ]\n)\nIf you were to use tuples instead, you'd need to make an explicit tuple of the (0,1) tuple, which is (0,1)\n\nTuple returns a tuple of (0,1)\n\nI would have named this as:\n\"from typing import tuple\"\n\nI'm not sure what you're getting at here.\n\nOne thing you can do is to define the function in terms of tuples, using tuples instead of lists.\n\nI don't think the author was suggesting you use tuples instead of lists. I think he was suggesting you use tuples instead of sum_product.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    lst = numbers.get(0).split()\n    x = 0\n    product, sum = sum_product(lst[0], lst[1:])\n    return (product, sum)\n\nI don't know why but I always have a hard time reading code with long lines like this. I tried to wrap it in \"gist\" form for readability, but it ended up breaking it.\n\nIt's not great, but if you learn the python way of doing things, it's not so bad. I do agree with you, but once you know python, the formatting is almost like a new language itself, so it's not so bad.\n\nI have to disagree with this. The Python community is not unlike the Ruby community in that the vast majority of the people who use it are not willing to learn the \"Python way.\" They just keep doing what they were doing in Ruby (or Java or C or whatever), and Python's lack of enforced syntax helps them continue this.\n\nI don't know about the Ruby community, but the Python community is very much about the \"Python way\".\nOne could easily say that the Python way _is", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum = 0\n    products = []\n    for i in numbers:\n       sum += i\n       products.append(sum)\n    return sum, products\n\nfrom typing import List, Tuple, Opaque", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in numbers:\n        sum_product(i)\n    return sum_product(numbers)\n\nI like this style. It's a very concise way of writing a function that does a few things.\nIt does also get a bit ugly though, and a lot of the time you can reduce it to the same amount of lines but with less repetition.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n\nCan you do that? \n\nNope. Because \"type\" is not the same as \"class\".\n\nI think the general point was that the syntactic sugar in Python 3.0 will be too much, and we're going to have to look at what's going on a lot more.\nI'm starting to feel the same way.\n\nI'm not sure that I like this change - it seems like too much syntactic sugar.\nI guess we'll see how it works out when it's released.\n\nMore syntactic sugar makes it easier to write code that looks like the way we think about it. I'm not sure how that can be a bad thing.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return numbers.sum() + numbers.product()\n\nYes, I get that. I'm asking how to add this to my python installation so that I can use sum_product in my programs.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    a, b = [], []\n    for x in numbers:\n       a.append(x)\n       b.append(sum_product(x))\n    return (a, b)\n\nI like this, but it's really the same as:\nnumbers = [1, 2, 3, 4]\nsum_product = [1, sum(numbers), sum(numbers) for i in numbers]", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for num in numbers:\n        sum = sum + num\n        product = product * num\n    return (sum, product)", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    if n:len(numbers) == 0:\n        return [[0]]\n    else:\n        return sum_product(numbers[0:n]) + sum_product(numbers[n+1:])\n    if __name__ == '__main__':\n        numbers = [5, 8, 9, 12, 17]\n        sum_product(numbers)\n\nThat's not the sum product you think it is.\n\nlol i found it on stackoverflow.com from that link \n\nI've written a little more extensive version here: \n\nThat's a cool trick, but it's not quite what the OP was talking about.\nI think the OP was talking about summing a list of integers and then\nmultiplying the sum by the length of the list.\n\nI was! Thanks for clearing that up, I didn't even see that link.\n\nI don't see why this is interesting. Surely any list comprehension has this capability?\n\nit's interesting to me b/c it", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    n = 0\n    for i in range(n):\n       sum = 0\n       for j in range(n):\n          sum += numbers[i][j]\n          numbers[i][j] *= numbers[i][j]\n          n += sum\n    return Tuple[n, sum, products[n]]\n\nNice.\n\nBut I don't get it, what's the use case for this?\n\nIt's a one liner that sums up an array of numbers.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    def sum(i: Int, j: Int): Int = numbers.get(i).sum(j)\n\n    def product(i: Int, j: Int): Int = numbers.get(i).product(j)\n\n    def sum_product(numbers: List[int]) -> Tuple[int, int]:\n        sum = sum_product(numbers)\n\n        product = product_of(sum, numbers)\n    return (sum, product)\n\nThis reminds me of \"Bible Code\" (\n).\n\nIndeed! That's how I imagine the old coders would code. I find it much more elegant than most modern programming languages.\n\nI know this sounds hipster, but I'm a Python programmer, and I'm not sure if I could make this look any more pythonic.\n\nI'm not sure if I could make this look any more unreadable.\n\nI wasn't going for readability. I was going for brevity. I was trying to make it look more like a one-liner from a shell script.\n\nI would prefer pythonic", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for number in numbers:\n       if number % 2 == 0:\n          return sum(number)\n       else:\n          return sum_product(number, numbers)\n\nCan someone explain to me what this does? I'm a C++ programmer, not Python.\n\nThe article is about Python tuples and how to implement them in C. It has a function called sum_product that returns a tuple. It takes a list of integers and returns a tuple of their sum and product.\n\nThe code looks like this", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    result = 0\n    for num in numbers:\n        if num == 1 or num == 0:\n           result += num\n           result.product = num\n    return result\nI'm a bit confused. What does this solve that using tuples for values and sums and products and stuff doesn't?\n\nThat's precisely what this is meant to solve.\n\nWe can also use tuples to generate tuples.\nfrom typing import (Type, Typeable, TypeableFunc)", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (sum(numbers), product(numbers))\n\nreturn sum_product([1, 2, 3, 4])</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    if n > 0:\n        sum = numbers.sum()\n        product = numbers.product()\n    return (sum, product)\n\nI like Python's approach to types better than C++'s or Java's. In Python, it's just a matter of convention.\nThe problem I have with this code is that it forces the user to make a decision that is really none of the user's business. I think Python would be better off not exposing the types to the user.\n\nI don't understand why people try to create languages which will always be inferior to Python, one of the best designed languages there is.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in numbers:\n         return i + sum_product([i], numbers) + product([i, i])\n\nYou don't need to have the List.append at the end of the loop - you could just do\nreturn sum_product([i], numbers) + product([i, i])\n\nAh yeah, I just put that there as a way to get to the end of the list. I didn't notice it would append it.\n\nAnd it doesn't even need to be an append, you can just use the following:\nreturn sum_product([i], numbers) + product([i, i])\n\nWhat is the point of this?\n\nI don't really know, but it makes me want to write a version that computes _factorial_ in O(1) by using the same trick.\nEdit: not quite O(1), see below.\n\nYay! I learned something new today.\n\nYay! A new way to express (and thus remember) how to do something I never really used much in the first place.\n\nI think it's a lot easier to remember how to do something when", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    # Return tuple with sum and product of all numbers.\n    return tuple(sum(numbers), product(numbers))\n\nYou can use the tuple module instead, which is part of the standard library.\n\nYes, or use itertools.tee().</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    numbers.sort()\n    numbers.reduce(0, sum_product)\n    numbers.reduce(1, product)\n\nI don't know enough about Python to know what's going on here, but if I had to guess, this is what's going on:\n1\\. It imports the module \"typing\" which provides two types List and Tuple.\n2\\. It defines a function \"sum_product\" that takes a list of integers and returns a tuple that has a sum and a product.\n3\\. \"sum_product\" calls the built-in function \"reduce\" which has two functions that take lists and return tuples. The first function \"0\" returns a tuple that has the number 0 and a tuple that has the sum of the numbers. The second function \"1\" returns a tuple that has the number 1 and a tuple that has the product of the numbers.\n\nThat's correct.\n\nI don't like this example.\nThe function \"sum_product\" is not clear enough, and is too long.\nHere is the _correct_ way to write this:\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return tuple(0, sum_product(numbers))\n\nWow, that's just great.\nI like the clarity of this code.\n\nI don't. Why does this need to be a function? Why isn't it part of the language? Why isn't the compiler smart enough to figure out that sum_product() returns a tuple, so it can optimise the code for you?\n\nBecause it's a library, and it's not meant to be part of the language.\nWhy doesn't the language just automatically make a function for everything? Why isn't it smart enough to figure out that sum_product() returns a tuple, so it can optimise the code for you?\nBecause it's a library, and it's not meant to be part of the language.\n\nThis is a good example of how Python is a really poor language. The poor people who work at Google and can't afford anything better will defend it to the end, but it's really quite a poor language.\n\nIt's not a language, it's a programming environment, and you can make it do whatever you want. That's the beauty of it.\n\nThere's a difference between \"the language is not", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum, product = 0, 1\n\n    for i in range(numbers.length):\n        sum += numbers[i]\n        product += numbers[i]\n        sum_product(numbers[i:])\n\nI thought the code was pretty clear. But then I'm coming from Python.\n\nSame here. And I didn't understand what the OP was trying to say until I read the comments.\n\nSaw this on reddit as well, the first comment on the reddit post is pretty funny and still accurate:\n\"Is that python?\"\n\"Yes, and it's not even the most horrible thing I've seen today.\"\n\nFor a list of integers, why not just use a list comprehension?\n[x + y for x in range(numbers.length) for y in numbers if x % y == 0]\nYou can even check for an empty sum and product with the empty() methods of Lists.\n\nBecause that would not be a Tuple, it would be a list. I'm guessing they're trying to practice tuples.\n\nI have a feeling the", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    if n is None:\n       n = int(input(\"Enter number of integers: \"))\n        return tuple(sum(numbers)) + tuple(product(numbers))\n\n>>> sum_product([1,2,3,4])\n(10, 24)\n>>> sum_product([])\n(0, 1)\n>>> sum_product([1,2,3,4,5])\n(10, 24, 120, 360, 2880)\n\nI had to look twice to make sure this was Python and not Haskell.\n\nI agree - that's one of the nicer Python code snippets I've ever seen.\n\nGreat post. I love all the comments, it's a nice reminder of how the community is so far ahead of the language itself.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return sum(numbers.map(x => x * x), 0)\n\nWhere is the type error? The returned tuple does not have the correct type - a Tuple[int, int] is not an integer.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return sum(numbers), product(numbers)\n\nThat's beautiful.\n\nI love how it doesn't \"require\" a type annotation like you'd expect.\n\nI didn't notice that! It's like an implicit type annotation.\n\nIn python3:\nfrom typing import List, Tuple, TypeError, NamedTuple\nfrom collections import defaultdict", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    numbers.map(lambda x: sum_product(x)).reduce(lambda x, y: x + y)\n\nI don't like it. It's a nice idea to use list comprehension for a map/reduce function, but I think it should be more general than that. I think you should be able to use list comprehension to define a new function.\n\nYou can define a new function with list comprehension as well:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return [0]*numbers.sum() + [1]*numbers.product()\n\nI'm not sure why this is interesting. It's just a function that returns a tuple whose first element is a sum and second element is a product of all the elements in the list. Nothing surprising here.\n\nI think the point is that it is _not_ surprising. The fact that it is a tuple is somewhat surprising.\n\nWhat is the point of using tuples instead of lists in this case? Is it just for the two-argument form of sum_product, or is there something more subtle about the design?\n\nThe tuple form makes it more obvious that the sum and product are independent, and that they can be used in different ways.\nIf you think of a tuple as an ordered pair, then it is easier to see that sum(0, 1) = 0 and sum(1, 2, 3, 4) = 10.\n\nI agree that sum_product in tuple form is more obvious, but I don't think that's a big deal. List comprehensions and map and filter in Python are much more powerful than sum_product, but you still see a lot of explicit loop", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in numbers:\n        sum = 0\n        product = 0\n\n    if sum == 0:\n        sum += i\n        return sum, product\nI'm not sure why sum_product is a function, but it is trivial to implement it as a generator:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (sum(numbers), product(numbers))\n\nfrom typing import List, Tuple, Any, Num, Zero, True, False, Ordered", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in numbers:\n        sum = 0\n        product = 0\n    return sum + product\nThis is not type safe. You should at least type cast the result back to tuple.\n\nThis is actually one of my favorite features of Python. I don't want to have to type cast anything. It is nice to know that it is there as a safety net, though.\n\nIf the type system is expressive enough, then I don't have to think about any casts at all. I know that if I do, then I'm doing something wrong.\n\nI like the way that Haskell does this (from typing import List, Tuple, Show):\nsum_product :: Int -> [Int] -> [Int] sum_product n l = sum $ n * product l\n\nI like how the author said sum and product, not sum and product* or sum*product.\nIt's an important distinction, especially since sum and product are two different operators on lists in Python.\n\nI just discovered this when I was trying to think of a name for a method on a class. The class had an \"add\" method that", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    product = 0\n    sum = 0\n    while True:\n        sum += numbers\n        product += numbers\n        return sum, product\n\ndude..\n\nand..\n\n-     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -     -\n-", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return sum(numbers) ** product(numbers[::-1])\n\nThis is the same as the sum_product function in Python.\n\nOne thing I would like to see is the number of function calls for this sort of thing. That's not to say that this isn't a great example of the power of Python, but I always like to hear the numbers.\n\nIt looks like this one is about 10x faster than sum().\nsum() = 0.32393775\nsum_product() = 0.33236875\n\nNo, that's not what I mean. I mean it would be nice to see how the code compares to the \"C-style\" version of this:\nsum = 0\nproduct = 1\nfor element in numbers:\nsum += element\nproduct += sum", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return Tuple(\n       sum=sum_product(numbers),\n       product=sum_product(numbers),\n    )\n\nlist(sum_product([1, 2, 3, 4])).sum()\n\nNote that this doesn't work for some list types. For example, list(sum_product([1, 2, 3, 4], [5, 6, 7, 8])) == [10, 24] but list(sum_product(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list(list", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return numbers.sum() + numbers.product()\n\nOr the python way:\nsum_product = lambda x: x.sum() + x.product()\n\nThe python way doesn't work if you have a tuple of tuples as it doesn't support multiple levels of recursion. I think what the author did is the best pythonic solution.\n\nI'm not sure I follow. The `sum` and `product` functions are called from a single level of recursion, with the `lambda` passed in being of a single-level of recursion. `sum` and `product` are not recursive functions, and the `lambda` passed in is not a recursive function either.\nYour python example is equivalent to:\nsum_product = lambda x: x.sum() + x.product()\nsum_product = lambda x: x.sum() + x.product()\nsum_product = lambda x: x.sum() + x.product()\nsum_product = lambda x: x.sum() + x.product()\nwhich all work.\n\nThe difference is in how the lambda is passed in to the function. In your example, you are explicitly passing in the", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return [n.sum() for n in numbers if n.product() is not None]\n\nI'm not a fan of the type system, but this is a perfect example of why it's useful.\n\nI'm sure this is an example of why the type system is useful, but it isn't an example of why python's type system is useful.\n\nYea, python's type system is pretty weak and I find I don't use it very often. I do a lot of c# development at work and I love the strong type system.\n\nYou might want to consider a look at:\n\\- \n\\- \n\\-\n\nThanks, I'll check it out.\n\nBe warned that Python's type system is weaker than Java's. It is more of a type hinting system.\n\nThis is a very common example of why _strong_ type systems are beneficial.\n\nNo, I'm pretty sure it is a perfect example of why _weak_ type systems are beneficial.\nIf it were a perfect example of why _strong_ type systems are beneficial then it would be much more verbose to type.\n\nAgreed. Weak type systems are beneficial, because they make", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    val sum = 0\n    val product = 1\n    for number in numbers:\n       if sum == 0:\n          product += number\n       else:\n           sum += number\n    return sum, product\n\n> sum_product([1, 2, 3, 4])\n(10, 24)\n\nWhat's the point of this?\n\nIt's a simple way to demonstrate the comprehension syntax of Python, and to test some of the language features for the first time.\n\nHe's trying to ask \"What's the point of sum_product()?\"\nI assume the answer is \"There isn't a point\".\n\nI think he was trying to express that the function had no visible point, since it had no parameters.\n\nPython is a language for cowards.\n\nOr people who don't want to be stuck with outdated C++ when they need to solve problems quickly.\n\nTrying to solve problems quickly with C++ is like trying to solve problems quickly with an Uzi.\n\nI think the parent was", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    total = 0\n    for number in numbers:\n        total += number\n        new_sum = sum_product(numbers[number:])\n        new_product = sum_product(numbers[1:])\n    return tuple(new_sum, new_product)\n\nThis is similar to a different, older Haskell snippet:\nsum_product :: (Int -> Int -> Int) -> [Int] -> (Int, Int)\nsum_product = foldl' (\\x y -> x + y) []\nThere's also a similar function from the containers package.\n\nIsn't this more commonly written as `sum_product xs`?\n\nYeah, but that's a different function. It's a recursive function.\nsum_product is a foldr-alike, which is useful if you want to take advantage of the monad for doing something in parallel (which is what this code seems to be doing).\n\nI guess so, although I'd argue that sum_product is more commonly used.\n\nNo, I'd say you are both right", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (sum(numbers) for numbers in numbers) + sum(numbers.product())\n\nOh, this is awesome. The only thing missing is the ability to pass the sum and product as parameters and have the function return a tuple of the results.\n\nYou can't do that.\n\nWhy not? (Honest question)\n\nBecause of the parameter definition syntax:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    total = 0\n    for i in numbers:\n        total = total + sum_product(numbers[i])\n        return tuple(total, 0)\nI don't know python, but a guess is this:\nsum_product is a function, not a variable. You pass it the list.\nsum_product has a default return value. It's either 0 or 1.\nThe line for i in numbers: is unnecessary. python supports looping over lists.\nThe return value is a tuple, which can be treated as a single value. So when you print the tuple, it will print the value.\n\nI like this answer, but it's missing one detail: the sum_product method is defined on a class, not a function. Python classes can define methods and functions. Classes are a way of bundling up data, and methods and functions are ways of operating on that data. So, for example, the sum_product method is a function, but it's a method defined on a class, not a function defined on the sum_product class.\nYou can define a method on a class like this:", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n\nYou can do it in one line if you want to:\nfrom typing import List, Tuple", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    def product(lst: List[int]):\n    \"\"\" For a given list of integers, return a tuple consisting of the products of all the integers in a list.\n    Empty product should be equal to 0 and empty sum should be equal to 1.\n    >>> product([1, 2, 3, 4])\n    (10, 24)\n    >>> product([])\n    (0, 1)\n    \"\"\"\n    product = lambda lst: list(lst) * list(lst)\n    sum = lambda lst: sum_product(lst)\n    return product + sum", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    products = [x * y for x, y in zip(numbers)]\n    if len(products) > 0:\n        sum = products[0]\n        return sum, products[len(products) - 1]\n\nI don't get it. How do you get the tuple to have an empty sum and empty product?\n\nBy having an empty sum and product in the first element of the tuple.</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    if numbers:\n       return (0, 1)\n    sum = 0\n    prod = 1\n    for i in numbers:\n       sum += i\n       prod *= i\n    return (sum, prod)", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    if not numbers:\n        return (0, 1)\n    for i in numbers:\n        product = 1\n        sum = i\n        if product and sum:\n            sum_product(i+1)\n            sum = sum - product\n    return sum_product(numbers.append(i))\n\nfor_each (sum_product, numbers)</s>", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    for i in numbers:\n        sum = 0\n        product = 0\n        for j in numbers:\n            sum += i\n            product += j\n    return (sum, product)\n\nI would suggest using xrange or xrange_more in the loop, since they let you iterate over a list while maintaining the order of the elements.\n\nHow does xrange_more work? Is it like `for x in yrange(n):` but with `yrange(n)` replaced with `xrange_more(n)`?\n\nNot exactly. xrange_more is a single function that returns an iterator that has a next() method.\nfor x in xrange_more(n):", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    if numbers.count() == 0:\n       return (sum, product)\n    for i in range(1, numbers.size() - 1):\n       sum += numbers[i]\n       product += (sum * numbers[i])\n    return (sum, product)", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    product, sum = 0, 0\n    for number in numbers:\n        if number is None:\n           continue\n          product, sum += number\n    return sum, product", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n\ni don't get it - did he add anything more than a type annotation?", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return (sum, product)\n\nTo me this looks like a bad idea. If sum_product(1, 2, 3, 4) is 7, should sum_product(1, 2, 3, 4, 5) be 7 or 4?\nAlso, what if I want to do sum_product(1, 2, 3, 4, 5, 6)? I'm not sure which one of sum_product(1, 2, 3, 4, 5, 6) or sum_product(1, 2, 3, 4, 5, 6) is better.\n\nIndeed. If you do it this way, sum_product(1, 2, 3, 4, 5, 6) is both 7 and 4.\nIt makes sense, though, if you think of it in terms of lists of integers. It's just a function that applies a map (or a filter) to a list, and then combines the results.\nIn Python, I'd write it like this (perhaps not the most idiomatic way to do it):", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    if len(numbers) == 0:\n       return tuple([], 1)\n    else:\n       return sum_product(numbers)", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    sum = 0\n    for i in numbers:\n       sum += i\n       sum_product(numbers[i:])\n\nLooks like a perfect example of a problem that could be solved by functional programming.\n\nThe only problem is that the average Python programmer doesn't know functional programming.\n\nIt's not a problem if you think about it.\nIf you have some knowledge of functional programming, you should be able to read the code and know what it does, without having to resort to a tutorial.\nIf you don't, then you need a tutorial to understand it. And it's much better to have it as an example than a contrived problem that uses anonymous functions.\n\nThe problem is that you have to do a tutorial to know how to do the tutorial.\nAnd how do you know that you are reading code that is functional programming?\n\nThe problem isn't that you have to do a tutorial to know how to do the tutorial. The problem is that you have to do a tutorial to understand the code.\n\nIf it were a tutorial on how to do the tutorial, then the tutorial would be about how to do a tutorial", "from typing import List, Tuple\n\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\" \"\"\"\n    return sum(numbers.map(lambda x: x * x))\n\nThe `sum_product` function returns a tuple of `int, int`, where the product is the sum of the items in the list multiplied together.\nWhat's the equivalent in Ruby?\n\nI'd say:\nsum_product(numbers) do\nsum, product = numbers.map { |x| x * x }\nreturn (sum, product)\n\nor just:\nsum_product = lambda list:\nsum, product = map { |x| x * x } list\nsum_product([1, 2, 3])   #=> (10, 24)\n\nBut what if you want a tuple of (sum, product) instead of (sum,product)?\n(I'm not saying your suggestion doesn't work; I just want to point out that the function name is not exactly accurate.)\n\nI'm not sure if it's possible in ruby, but it would probably look something like:\nsum_product = lambda list:\nsum, product = map { |x| x * x } list\nsum_product([1, 2, 3])    #=> ("]]