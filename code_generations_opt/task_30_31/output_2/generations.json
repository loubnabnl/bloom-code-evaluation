[["def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i in range(0, len(l)):\n       if i in l:\n          return True\n    return False", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return filter(l, lambda x: x >= 0)\n\nI thought the first example was going to be a joke about how you can't have negative numbers in a list. I was a little disappointed.\n\nHow do you know it's not?\n\nBecause it's not funny.\n\nIt's funny because it's true.\n\nMaybe it's funny because it's true, but it's not true because it's funny.\n\nHow do you know it's not?\n\nI don't, but that doesn't mean I can't say it's not.\n\nI know that you don't, but that doesn't mean you can't say it's not.\n\nI don't know that you know that I don't, but that doesn't mean you can't say I can't say it's not.\n\nI don't know that you know that I know that you don't, but that doesn't mean you can't say I can't say it's not.\n\nI don't know that you know that I know that you know that I don't, but that doesn't mean you can't say I can't say it's not.\n\nI don't know that", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l.pop(), key=lambda x: x[0])\n\nThe list comprehension is a bit cleaner, IMO:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1] > 0)\nThis is a terrible idea. What if the list contains the number 3, which is neither positive nor negative?\n\nI'm pretty sure it's meant to be a joke.\n\nNo, it's a joke.\n\nI'm not sure I understand.\n\nI believe that's a joke.\n\nThis is a joke.\n\nI thought it was a joke.\n\nThis is a joke.\n\nI'm not sure I understand.\n\nIt's a joke.\n\nWhat's a joke?\n\nThis is a joke.\n\nI'm not sure I understand.\n\nI believe that's a joke.\n\nI'm not sure I understand.\n\nI believe that's a joke.\n\nI'm not sure I understand.\n\nIt's a joke.\n\nI'm not sure I understand.\n\nI believe that's a joke.\n\nI'm not sure I understand.\n\nI believe that's a joke.\n\nI'm not sure I understand.\n\nI believe that's a joke.\n\nI'm not sure I understand.\n\nI", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.filter(lambda x: x > 0).sum()", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l[0] == -1:\n       return [1]\n    else:\n       return [l[1] for l in l]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] if l[0] > 0 else [] for l in l]\nI like this one.\n\nMy favorite is:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for item in l:\n       if item > 0:\n          return item\n    return []\nI prefer to use list comprehensions when I can, but that's just a matter of preference.\n\nThere's a lot to be said for list comprehensions. I've found them to be a lot easier to read, and more concise.\n\nI like list comprehensions, but I'm not sure they are more concise. They are certainly easier to read.\n\nThey are more concise. You can't express the above as a list comprehension.\n\nYou can:\n[x for x in l if x > 0]\n\nThat's not a list comprehension. That's a for loop.\n\nI don't think the author has ever read the Python documentation.\n\n\"I'm not going to write about the difference between a list and a tuple.\"\nI'm not sure I understand this. How can you write about list comprehensions without mentioning tuples?\n\nI'm not sure I understand this. How can you write about list comprehensions without mentioning tuples?\nYou can't, but you can write about list comprehens", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l[0] < 0:\n        return []\n    return l", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[0]\nI don't think that's a good idea.\n\nWell, it's not that bad. It's an extremely common operation and I think it's a good way to learn how to write functions.\n\nIt's not a good way to learn how to write functions. It's a good way to learn how to write _implementations_ of functions.\nIt's a bad idea because it's very, very easy to get it wrong, and because the error is subtle.\n\nThis is exactly how I learned to write functions. You learn to write functions by implementing them.\n\nAnd this is exactly how I learned to write bad functions.\n\nI think it's good. You learn to write functions by implementing them. If you don't like it, don't use it.\n\nI don't think you understand my point. I'm not saying that this is a bad way to learn to write functions. I'm saying that it's a bad way to learn to write _good_ functions.\n\nI think it's a good way to learn to write _good_ functions.\n\nThen you don't understand my point.\n\nI think it's a good way to", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l.index(0) >= 0)\nI'm not sure if you're aware of this, but there is a convention of putting the number of lines of code in a comment at the top of the file.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0] > 0]\nI think you mean:\nreturn [l[0] for l in l if l[0] > 0]\n\nthanks, updated\n\nI've found that for loops are a good way to get a quick start with a new language. They give you a way to write code that can be easily read and understood, which is important for a new language.\nThis is a good example of a for loop:\nfor x in range(10):", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0] > 0]\nI like this one, it's simple and elegant.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n       return []\n    return [i for i in l if i > 0]\nI don't understand the purpose of the len(l) check. It's not going to be zero, and if it is zero, the function will return an empty list.\n\nIt's a bug. I meant to return the number of non-zero items, not the number of items.\n\nThat makes much more sense.\n\nI think it would be more useful if the function returned a tuple of the index and the number of non-zero items.\n\nI think it would be more useful if the function returned the number of non-zero items.\n\nYou can use the.size() method on lists to get the number of non-zero items.\n\nIs it just me or does this feel like it's the wrong way round?", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop(0)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) > 0:\n        for x in l:\n           if x > 0:\n              return x\n    return []", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop()\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([-1, 2, -4, 5, 6])\n    [6, 2, -4, -1]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [9, 0, -3, -5, 2, 3, 3, 123, 1, -10]\n    \"\"\"\n    return l.pop()", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[1] for l in l if l[1] > 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i, x in enumerate(l):\n       if x > 0:\n          return x\n    return None", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1] > 0)\nThis is a good example of the power of list comprehensions.  It is also a good example of the power of Python's built-in sorting function.  This is a lot more elegant than the sort() function in most other languages.  I think this is because Python's built-in sort() function is designed to be \"just enough\" for the task at hand.\n\nThat's also a good example of the power of Python's built-in sort() function: it's not a built-in sort() function at all, it's the built-in sort() function.\n\nI think the difference is that it's built in to the language and not just the interpreter.\n\nIt's a builtin function in the language, but it's not built in to the interpreter.\n\nThis is a good example of the power of Python's built-in list comprehension. It is also a good example of the power of Python's built-in sort() function.\n\nThis is a good example of the power of Python's built-in list comprehension. It is also a good example of the power of Python's built", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i in range(len(l)):\n       if i < 0:\n          return False\n        elif i > len(l):\n          return False\n    return True\nThis is my favorite.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return []\n    else:\n        return get_positive(l[0])", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l: isinstance(l, list) and not len(l) == 0:\n        return list(l)\n    return l\nI think the only change I'd make is to return l.filter(lambda x: x > 0)</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l.count() < 1:\n        return None\n    return l.pop(0)\nThat's a good point.  I think I may have been confused by the fact that the other list functions (filter, remove, etc.) all take an iterable as a parameter and return a new iterable.  But it's true that it's pretty clear that get_positive doesn't return a new iterable, and so it's not a good fit for the list protocol.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n       return []\n    if len(l) == 1:\n       return l[0]\n    return get_positive(l)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in list if l[0] > 0]\nI'm not sure what your point is, but that's not the same as the linked code.\n\nI don't see why not.\n\nThis is not the same as the linked code.\nThe linked code doesn't return a list of numbers; it returns a list of numbers and their positive/negative status.\nThe code you posted returns a list of numbers.\n\nI see your point. It's not the same.\nI still think it's a good solution to the problem.\n\nWell, the linked code is not the same as the problem.\nThe linked code is a solution to the problem.\n\nIf you're trying to get a list of positive numbers, this is not a good solution.\n\nI don't understand why not.\n\nBecause it's not the same as the linked code.\n\nI don't understand why that matters.\n\nI don't understand why you don't understand.\n\nI don't understand why you don't understand why I don't understand.\n\nThe problem is to get a list of positive numbers.\nThe linked code is a solution to the", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0]!= -1]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i in range(len(l)):\n        if i not in [1,2,3,4]:\n           return None\n    return l[i]\nI'm not sure why you're using a list here.  If you want a list of positive numbers, you can just use a list comprehension:       [i for i in range(len(l)) if i not in [1,2,3,4]]  This will be more efficient.  If you want to return a list of just the positive numbers, you can use a generator expression:       [i for i in range(len(l)) if i not in [1,2,3,4] if i % 2 == 0]  And you can even make it more readable with a lambda expression:       [i for i in range(len(l)) if i not in [1,2,3,4] if i % 2 == 0]       return lambda i: i\n\nI prefer the list comprehension. The generator expression", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[i] for i in l if i > 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return len(l) > 0\nI don't think that's what he was looking for.\n\nWell, it's not a very good exercise if you can't figure out the answer.\n\nI was trying to figure out the answer. I was just trying to be helpful and point out that it didn't work as intended.\n\nIt's been a while since I've used Python, but isn't there a built-in function that does this?\n\nIf you're asking if there's a built-in function that returns the n-th element of a list, then no. You can use the built-in function len to find the length of the list, and then use the built-in function index to get the n-th element.\n\nI think he means something like:\n>>> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n>>> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] - [1]\n[2, 3, 4, 5, 6, 7,", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    def positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    >>> positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    \"\"\"\n    return l.filter(x: x > 0)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in list if l[0]!= -1]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[:-1]\nI'd go with something like this, but I'd add a way to get the negative numbers as well.  That way I can do something like:       def get_all_numbers(l):          return l[:-1]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return l\n    elif len(l) > 0 and len(l) > 1:\n        return l[0]\n    else:\n        return []\nI'm not sure if this is the best solution, but I would just use itertools.count().\n\nThanks, I'll have to look into itertools.count() more.\n\nThere's a Python Cookbook chapter on list functions:\n\nThanks, I'll take a look at it.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    elif len(l) == 2:\n       return l[1]\n    else:\n       return []", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l.count() > 0)\nI don't see how this is a better solution than the built in `any` function.\n\nI don't see how this is a better solution than the built in `any` function.\nThe built-in `any` function only works on lists of integers. It's useless for any other type of list.\n\nThanks for the clarification. I had no idea that `any` was limited to integers.\n\nIt's a common mistake. I think it's because the docs for `any` say that it can be used for any type of list, but it's really just for lists of integers.\n\nVery nice, it's a little unfortunate that it's not in the standard library, but I guess it's better that it's in a separate package.\n\nI agree, but I'm not sure how I would implement it in a way that would be useful in the standard library. I guess I could add a method to `list` that returns a list of positive numbers.\n\nIf you had a way to do that, it would be a very useful feature in the standard library.\n\nI think this would be useful to add to the standard", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0] > 0]\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return [l[0] for l in l if l[0] < 0]\n    def get_odd(l: list):\n    \"\"\"Return only odd numbers in the list.\n    >>> get_odd([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_odd([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return list(filter(lambda x: x >= 0, l))", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[0]\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return l[1]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l[0] == -1:\n       return [l[0] for l in list if l[0] > 0]\n    else:\n       return [l[0] for l in list if l[0] > -1]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l[0] < 0:\n       return []\n    return get_positive(l[1:])", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    # get the list\n    l = [2, -1, 2, 5, -4, 6, 2, -3, 3, 9, 0, 123, 1, -10]\n    # remove the negative numbers\n    # [2, 5, 6, 2, 3, 9, 123, 1, -10]\n    return l.filter(lambda x: x > -5)\nI would have called it get_positive_only.\n\nThe article is not about the \"best\" way to do it, it's about the \"pythonic\" way. The pythonic way is to use the built-in `filter` function.\n\nI think the point is that it's \"pythonic\" to use the built-in filter function in the way that makes the most sense.\n\nI think the point is that it's \"pythonic\" to use the built-in filter function in the way that makes the most sense to the author of the article.\n\nI think the point is that it's \"pythonic\" to use the built-in filter function in the way that makes the most sense to the author of the article", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n       return []\n    else:\n       for x in l:\n         if x == -1:\n            return []\n         else:\n            return get_positive(x)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l.pop(), key=lambda x: x.abs(x))\nThat's not right. It doesn't return the first element if the list is sorted.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [x for x in l if x > 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.filter(lambdax: x > 0)\nSo, I'm assuming that this is a joke? I mean, it's just a recursive version of the filter function, right?\n\nI think the joke is that it's the same code as the original, except with \"filter\" replaced with \"get_positive\"\n\nI think the joke is that it's a joke.\n\nI think the joke is that it's a recursive joke.\n\nI think the joke is that it's a recursive joke about recursion.\n\nI think the joke is that it's a recursive joke about recursion about recursion.\n\nI think the joke is that it's a recursive joke about recursion about recursion about recursion.\n\nI think the joke is that it's a recursive joke about recursion about recursion about recursion about recursion.\n\nI think the joke is that it's a recursive joke about recursion about recursion about recursion about recursion about recursion.\n\nI think the joke is that it's a recursive joke about recursion about recursion about recursion about recursion about recursion.\n\nI think the joke is that it's a", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l[0]!= -1:\n       return [l[1], l[2]]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) < 2:\n        return []\n    if len(l) > 0:\n        return [l[0], l[1]]\n\nI'm not a Python expert, but I don't think this is correct.\n\nWhy not?\n\nI'm not sure about Python, but in C, an empty list is an object of type int, so the if statement will never evaluate to true.\n\nIn Python, an empty list is an object of type list.\n\nThis is a pretty good answer.\n\nI don't see why you would want to do this. I think you'd be better off using a list comprehension.\n\nI agree. List comprehensions are really the best way to do this.\n\nThis is a perfectly fine answer.\n\nWhy not?\n\nI don't know about Python, but in C, an empty list is an object of type int, so the if statement will never evaluate to true.\n\nIn Python, an empty list is an object of type list.\n\nThis is a pretty good answer.\n\nI don't see why you would want", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n       return []\n    else:\n       return l.pop(0)\nYou can get the length of a list with len(l)\n\nThanks, I was aware of that, but I like the way I have it now.\n\nI like the way you have it now too. It's a good example of how to use pop() in a way that is easy to read.\n\nWhat's wrong with:\nreturn [0 for _ in l if l[0] > 0]\n\nNothing. I like my way because it is more explicit and easier to read.\n\nIt's not easier to read. It's the same number of characters, but it's harder to read because it's not clear what the \"for\" does.\n\nI like it. I think it's more clear than your example.\n\nIt's not. It's not clear what the \"for\" does.\n\nI like it, too. I think it's more clear than your example.\n\nIt's not. It's not clear what the \"for\" does.\n\nI think it", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    # we need to check the length of the list to avoid overflow\n    # if the list is empty we return -1\n    if len(l) == 0:\n        return -1\n    # otherwise, we need to check if the number is positive\n    if abs(l[0]) == 0:\n        return -1\n    # otherwise, we need to check if the number is negative\n    if abs(l[1]) == -1:\n        return -1\n    return l", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return []\n    for i in range(0, len(l)):\n        if l[i] > 0:\n            return l[i]\n\nIt's not very idiomatic Python.\n\nIt's not idiomatic Python, but it's still very readable.\n\nIt's not idiomatic Python, but it's still very readable.\n\nIt's not idiomatic Python, but it's still very readable.\n\nIt's not idiomatic Python, but it's still very readable.\n\nIt's not idiomatic Python, but it's still very readable.\n\nIt's not idiomatic Python, but it's still very readable.\n\nIt's not idiomatic Python, but it's still very readable.\n\nIt's not idiomatic Python, but it's still very readable.\n\nIt's not idiomatic Python, but it's still very readable.\n\nIt's not idiomatic Python, but it's still very readable.\n\nIt's not idiomatic Python, but it's still very readable", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[::-1]\nI don't understand the use of [::-1]. I thought the first element of the list was always the first element. So why does it need to be used?\n\nIt is the first element of the list, but it's not the first element of the list of numbers. [0,1,2,3,4,5,6] is a list of numbers, [1,2,3,4,5,6] is also a list of numbers, [0,1,2,3,4,5] is also a list of numbers, but [1,2,3,4,5] is not.\n\nI think this is a really great article. I like that it doesn't just tell you what to do, but it tells you why and how to do it.\n\nI wonder if there is a way to generalize this to work with sets, or if it is possible to do it with sets already.\n\nIt is possible, but it is a lot more complex than the article makes it look.\n\nI like that they used a real world example.\n\nThe real world example is a great way to get", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop()", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return l.pop(0)\n\nYou could use a list comprehension, but it's not really any more readable than the equivalent code using a for loop.\n\nI think the problem is that the OP is looking for a list comprehension that is more readable than the equivalent for loop.\nI think the issue is that you can't write a list comprehension that is more readable than the equivalent for loop.\n\nYou can, but it's not very common.\nThe most common is probably something like this:\n[for i in range(len(a))", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[::-1]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop(0)\nThis is a great example of a good use of Python's built-in functions.\n\nAnd it's a bad example of the use of list comprehensions.\n\nWhy is it a bad example?\n\nIt's the same as:\n[x for x in range(len(x) - 1)]\n\nI don't think it's the same.\nrange() is a built-in function, but it's not an iterator. It doesn't do anything with the items in the list.\nThe other method is a list comprehension. It's not a built-in function, but it is an iterator. It iterates over the list, and returns the first non-negative number.\n\nI think this is a good example of when list comprehensions are useful.\n\nThis is a good example of when list comprehensions are useful.\n\nIt's a good example of when list comprehensions are useful.\n\nI don't think it's a good example of when list comprehensions are useful.\n\nThe other method is a list comprehension. It's not a built-in function, but it is an iterator. It iterates over the list, and", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l.pop() for l in l) if l.pop() == 0 else l.pop()\nThis is what I would do.  It's not a particularly good solution, but it's what I would do.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l[0] < l[1])\nThis is a better version of the original.\n\nI think this is actually a bad version of the original, because it's not as obvious that it's a strict function.\n\nI have a lot of trouble with the \"strange\" (to me) syntax of python.\nI've read a lot about it, but I still can't see it as a \"beautiful\" language.\nI'll admit that I don't have a lot of experience with it, but I don't see the appeal.\n\nI feel the same way. I've been writing python for a few years now and I've grown to like it, but I've never found it beautiful.\n\nI don't think it's meant to be beautiful. It's meant to be practical.\n\nAnd it is beautiful in its practicality.\n\nI think this is a better way of writing the original.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[0]\nI like it.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l[0] > -1) and (l[1] < 0)\nI don't see how this is an improvement.\n\nI think the point is that it's a functional solution.\n\nI think the point is that it's a _bad_ functional solution.\n\nIt's a bad solution, period.\n\nIt's a bad solution, but it's a functional solution.\n\nIt's a solution, but it's not functional.\n\nIt's not a solution, but it's functional.\n\nIt's a solution, but it's not functional.\n\nIt's not a solution, and it's not functional.\n\nIt's not a solution, and it's not functional.\n\nIt's not a solution, and it's not functional.\n\nIt's not a solution, and it's not functional.\n\nIt's not a solution, and it's not functional.\n\nIt's not a solution, and it's not functional.\n\nIt's not a solution, and it's not functional.\n\nIt's not a solution, and it's not functional.\n\nIt's not a solution, and it's not functional.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l.pop(), key=lambda x: x[0] < x[1])\nThis is a better version of the pop() method, but it's still not quite right.  The reason is that it doesn't handle the case where the list is empty.  If you want to do this correctly, you need to modify the pop() method to return a list of all the items in the list, and then use that to get the sorted list.  The following code does that:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0] > 0)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return []\n    else:\n        return [l[0] for l in l]\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    if len(l) == 0:\n        return []\n    else:\n        return [l[0] for l in l]\n\nPython", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x>0)\nI'm not sure if you're trolling or not, but this is not the same thing.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0] if x[0] > 0 else x[0] if x[0] < 0 else x[0] if x[0] == 0 else x[0] if x[0] == 1 else x[0] if x[0] == 2 else x[0] if x[0] == 3 else x[0] if x[0] == 4 else x[0] if x[0] == 5 else x[0] if x[0] == 6 else x[0] if x[0] == 7 else x[0] if x[0] == 8 else x[0] if x[0] == 9 else x[0] if x[0] == 10 else x[0] if x[0] == 11 else x[0] if x[0] == 12 else x[0] if x[0] == 13 else x[0] if x[0] == 14 else x[0] if x[0] == 15 else x[0] if x[0] == 16 else x[0] if x[0] == 17 else x[", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i in range(1,len(l)):\n        return l[i]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l[0] < 0:\n       return []\n    else:\n       return l[1:]\nThanks for your answer!\nI will take a look at the docs.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1])\n\nI'm not sure I understand the use case for this, but I like it.\n\nThe use case is that I'm writing a list comprehension that uses this function to remove the negative numbers from a list of numbers, and I don't want the negative numbers in the result.\n\nYou could use a regular expression to remove the negative numbers.\n\nOr use a list comprehension.\n\nOr use a regular expression.\n\nOr use a list comprehension.\n\nOr use a regular expression.\n\nOr use a list comprehension.\n\nOr use a regular expression.\n\nOr use a list comprehension.\n\nOr use a regular expression.\n\nOr use a list comprehension.\n\nOr use a regular expression.\n\nOr use a list comprehension.\n\nOr use a regular expression.\n\nOr use a list comprehension.\n\nOr use a regular expression.\n\nOr use a list comprehension.\n\nOr use a regular expression.\n\nOr use a list comprehension.\n\nOr use a regular expression.\n\nOr use a list comprehension.\n\nOr use a regular expression.\n\nOr use a", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i in range(len(l)):\n        if l[i] < 0:\n            return None\n    return l[i]\nThis is a bit of a premature optimization.  When you get to the point where you're optimizing this sort of thing, you've already wasted a lot of time and effort.\n\nI've been working on a project where this is a bottleneck.\n\nThat's the point.  Optimizing this sort of thing will only help you if you're already so far down the rabbit hole that you're wasting time and effort.  Optimizing this sort of thing will not help you solve the problem you're actually trying to solve.\n\nA bit of a tangent, but I love Python's (and Ruby's) `list(l)` syntax.\n\nOne of my favorite things about Python is the fact that you can do this and get a list of tuples (arrays of key/value pairs):\n>>> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [x for x in l if x > 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i in l:\n       if i < 0:\n          return None\n       else:\n          return i", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l:\n        return l.pop()\n    else:\n        return None", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[::-1]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0]>0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[0] > 0", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[:2] == 1", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return list(l.pop() if l.pop() else 0)\nThis is not the right way to do it.\nreturn list(l.pop() if l.pop() else -1)</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.filter(x => x % 2 == 0)\nI'm not sure how this is a \"functional\" solution.\n\nIt's not. The title is wrong.\n\nIt's not even a solution.\n\nIt's not a solution, but it's a nice little function.\n\nI agree, it's a nice function. But it's not a solution to the problem.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[0] > 0\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return l[0] < 0", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[0]\nThis code is likely to break for lists with very long elements, such as lists of strings or lists of long integers.\nIf you're using Python 2, you can use `zip` instead of `lzip`.\n\nI don't think it will break for lists of strings.\n\nIt will, if the strings contain negative numbers.\n\nI think the post above is referring to the fact that strings in Python are actually Unicode objects, so the length of a string is actually a length in bytes, not characters.\n\nI'm surprised to see no mention of \"itertools.permutations\" in this thread. I'm also surprised to see no mention of \"itertools.combinations\" either.\nItertools is one of my favorite Python libraries.\n\nI'm not surprised to see no mention of itertools.permutations, because it's a total waste of time to write that yourself when it's already implemented in the standard library. It's also a waste of time to write itertools.combinations yourself when it's already implemented in the standard library.\nI'm not saying itertools.permutations and itertools.combinations are bad", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l.index(0) == 1)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0] > 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for number in range(1, len(l)):\n        if number < 0:\n           return False\n        else:\n           return True", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop(0)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    def positive(n):\n    \"\"\"Return true if n is positive.\n    >>> positive(1)\n    True\n    >>> positive(-2)\n    False\n    >>> positive(5)\n    True\n    >>> positive(-5)\n    False\n    \"\"\"\n    if n > 0:\n       return n > 0\n    return False", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i in range(len(l)):\n       if i % 2 == 0:\n          return l[i]\n    return []\nIt's probably more efficient to use a list comprehension:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return list(l[0] if l[0] > 0 else -l[0])\nThis is a rather strange way to do it. It's equivalent to:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[1]>=0)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0] > 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l.pop() & 1)\nThis is a great example of why Python is so great. It's so much more readable than the equivalent in C.\n\nI'm not sure how this is more readable.\n\nPython:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if not l: isinstance(l, int) or not l: isinstance(l, float):\n        raise ValueError(\"Only integers and floats allowed\")\n    return l: zip(*l: zip(*l: filter(None, lambda x: x > 0, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop(0)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return len(l) > 0", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return []\n    if len(l) == 1:\n        return l[0]\n    for x in l:\n        if x > 0:\n           return x\n    return []\nThanks for the code.  It's pretty cool.  I have a question, though.  Why are you using the list comprehension instead of just a for loop?\nThe list comprehension is a bit more readable, and it's easier to see what it does at a glance.  It also makes it possible to use a list comprehension to define a function that returns a list comprehension, which is useful if you want to do something like this:      def foo(l):\n        return get_positive(l)\nThat's all I can think of.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop()", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l.count(1) == 0:\n        return l\n    else:\n        return []\nI am not sure why this is on the front page.\n\nI guess people are voting it up because they like the idea of the function.\n\nIs that a good reason for a submission?\n\nI'm not sure. I upvoted because I like the idea of the function, but I'm not sure if that's a good reason for a submission.\n\nIf I'm reading the code right, the only difference between this and a simple \"return l[0] if l[0] > 0 else l[0]\" is that it does the same thing to the whole list.\n\nIt's not exactly the same thing, because you can use it on a list of any length.\n\nBut it doesn't really return a list, it returns a tuple.\n\nSo, it returns a list of tuples.\n\nI think it's a nice hack, but I don't really see a use for it.\n\nThere are a lot of things in programming that don't have a use.\n\nI", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    def is_positive(x):\n    return x >= 0\n    return get_positive(l)\nI'd argue that the second one is more readable, and the first one is more concise.\n\nI agree, and would argue that it's more idiomatic to use the first one.\nThe Python language guide specifically recommends this style of coding:\n\"The following is a more idiomatic way to write this function:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in list if l[0] < 0]\nI'm not sure why you're using the `if` statement instead of `return`.  Also, you might want to add `return` to the end of the function to make it easier to read.\nThank you, I changed it. I am not very experienced in Python so I appreciate the help!</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return []\n    return [l[0] for l in l if l[0] > 0 else None]\nI think that's the most pythonic version.\n\nThat's a good one. I'm going to steal it.\n\nI think I'll use this one.\n\nI prefer the following:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop()\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return l.pop()\n    def get_square_roots(l: list):\n    \"\"\"Return the square roots of all the numbers in the list.\n    >>> get_square_roots([2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])\n    [1, 1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n    >>> get_square_roots([-1, -1, -1, -1", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return len(l) == 1", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    l.pop(0)\n    return l.pop(0).pop(0)\n\nI think that's a bad example because it's easy to come up with a counter-example.\n>>> get_positive([-1, 2, -4, 5, 6])\n[-1, 2, 5, 6]\n\nThe example is not meant to be a counter-example, it's meant to show how you can easily change the list to return different things.\n\nIt's a bad example because it's easy to change the list to return different things.\n\nI think the example is a great example because it shows how you can easily change the list to return different things.\n\nI think the example is a great example because it shows how you can easily change the list to return different things.\n\nI think the example is a great example because it shows how you can easily change the list to return different things.\n\nI think the example is a great example because it shows how you can easily change the list to return different things.\n\nI think the example is a great example because it shows how you can easily change the list to return different things.\n\nI think", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[0]\nI'm pretty sure that's not Python.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [x for x in l if x>0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop()\n    if l[0] < 0:\n       return []\n    return l[1:]\nI'm not sure if you're trolling or not.\n\nWell, it's a good thing you don't have to use it.\n\nI agree with the point that many of these are syntactic sugar.\nBut I also think that they are not always \"bad\".\nI find it easier to read and write code like this:\n>>> def sum(lst):\n    \"\"\"Return the sum of the numbers in the list.\n    >>> sum([1, 2, 3, 4])\n    10\n    >>> sum([1, 2, 3, 4, 5])\n    15\n    >>> sum([1, 2, 3, 4, 5, 6])\n    20\n    \"\"\"\n    return sum(lst)\n>>> sum([1, 2, 3, 4, 5])\n15\n>>> sum([1, 2, 3, 4, 5, 6])\n20\n>>> sum([1, 2,", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l.count() > 0)\nThere's a whole lot of code there that I'm not going to read, but I'm pretty sure that this code will only return the first element of the list.\n\nIt's a little more complicated than that. The get_positive function is actually a decorator that you can apply to any list comprehension. So, you could write it like this:\n>>> def get_positive_list(l):\n...           return (l.count() > 0)\n...\n>>> get_positive_list([1, 2, 3, 4, 5])\n[1, 2, 3, 4]\n>>> get_positive_list([1, 2, 3, 4, 5, 6])\n[1, 2, 3, 4, 5, 6]\n>>> get_positive_list([1, 2, 3, 4, 5, 6, 7, 8])\n[1, 2, 3, 4, 5, 6, 7, 8]\n>>> get_positive_list([1, 2, 3, 4, 5, 6, 7, 8, 9])\n[1, 2", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[1] for l in l if l[1] > 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[i] for i in range(len(l) - 1)]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return []\n    for i in range(len(l)):\n        if l[i] < 0:\n           return []\n        else:\n           return l[i]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    l.sort()\n    return l.pop(0)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[0] > 0\n\nI don't think this is the best way to do it. The problem is that the list is assumed to be sorted. This means that, for example, -3 is not a positive number, but in this case it is returned.\nI think it would be better to use an iterative approach:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l: list is not None:\n       return l[0]\n    else:\n       return None\nI would expect this to return the list of positives.\n\nIt's not a list of positives. It's a list of numbers that are positive. It's a list of all numbers that are greater than 0.\n\nThat's not what the code does. It returns the first number in the list.\n\nThe code does what the code does. The code does not return a list of positives. It returns a list of numbers that are positive.\n\nI'm not sure if you're trolling me, but I think you're trolling me.\n\nI'm not trolling you. The code does not return a list of positives. It returns a list of numbers that are positive.\n\nNo, it returns the first number in the list.\n\nI think you're trolling me.\n\nNo, you're trolling me.\n\nI'm not trolling you. The code does not return a list of positives. It returns a list of numbers that are positive.\n\nNo, you're trolling me.\n\nI'm not trolling you", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[l.startswith('1')]\nIn Python 2.x, there is a built-in function called filter() that can do this.  It's pretty easy to use and has a few other nifty features.\n\nI think the point of the exercise was to show that you can't do this in Python 3.x\n\nI was just trying to help out.\n\nI know. I wasn't trying to be rude. Sorry if it came off that way.\n\nAh, I see. No worries.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return len(l) > 0", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n       return []\n    for i in range(0, len(l)):\n       if l[i] < 0:\n          return l[i]\n    return l", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0] < x[1] for x in l)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] if l[0] > 0 else None for l in l]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop()", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[0] > 0)\nI can't believe I forgot about sorted. Thanks.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    # start with a list of numbers\n    return [l[0] for l in l]\nI can't figure out what that's supposed to do.  I'm assuming that's Python, but I'm not familiar with it.  How does it return only the positive numbers?\nIt returns only the numbers that are positive.  The list is a list of numbers.  It returns the first element of the list, which is the first number in the list.  It then returns the second element of the list, which is the second number in the list.  It then returns the third element of the list, which is the third number in the list.  It then returns the fourth element of the list, which is the fourth number in the list.  It then returns the fifth element of the list, which is the fifth number in the list.  It then returns the sixth element of the list, which is the sixth number in the list.\nI see.  I would have expected it to return the first element of the list, then the second element of the list, etc.  It does what I expected, but it took me a while to figure out what it was doing.\nThat's", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sum(l) > 0\nI'd be interested to see how many people would actually get this.\n\nI'd be interested to see how many people would actually get this.\nI'd be interested to see how many people would actually get this.\nI'd be interested to see how many people would actually get this.\nI'd be interested to see how many people would actually get this.\nI'd be interested to see how many people would actually get this.\nI'd be interested to see how many people would actually get this.\nI'd be interested to see how many people would actually get this.\nI'd be interested to see how many people would actually get this.\nI'd be interested to see how many people would actually get this.\nI'd be interested to see how many people would actually get this.\nI'd be interested to see how many people would actually get this.\nI'd be interested to see how many people would actually get this.\nI'd be interested to see how many people would actually get this.\nI'd be interested to see how many people would actually get this.\nI'd be interested to see how many people would actually get this.\nI'd be", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sum(l) == 0\nThat's not what that function does.\n\nI'd say it's close enough. It returns the list of non-negative numbers.\n\nIt returns the list of non-negative numbers _in the original list_.\n\nI don't think it's that big of a deal.\n\nIt's not a big deal, it's just wrong.\n\nHow is it wrong?\n\nBecause the function isn't called \"get_non_negative_numbers\". It's called \"get_positive\".\n\nIt's called get_positive because it returns the positive numbers.\n\nIt returns the non-negative numbers in the original list.\n\nIt's called get_positive because it returns the positive numbers.\n\nIt returns the non-negative numbers in the original list.\n\nIt's called get_positive because it returns the positive numbers.\n\nIt returns the non-negative numbers in the original list.\n\nIt's called get_positive because it returns the positive numbers.\n\nIt returns the non-negative numbers in the original list.\n\nIt's called get_positive because it returns the positive numbers.\n\nIt returns the non-", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n       return []\n    else:\n       for x in l:\n          if x >= 0:\n             return [x]\n    return []\nThis is an interesting snippet, but you should add some docstrings.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0] > 0]\nThis doesn't work with lists of negative numbers.\n\nThat's a good point, but in the example you give it would be better to use l[0] instead of l[1] since l[0] will always be greater than 0.\n\nI can't tell if this is a joke or not.\n\nI'm not sure what you mean by that. I was just trying to make a suggestion for a better way to write the function.\n\nThat's not a better way, it's a different way.\n\nAh, I see what you're saying. It's not a joke, it's just a different way to do it.\n\nThe problem with this approach is that it doesn't work with negative numbers.\n\nI'm not sure what you mean. It does work with negative numbers.\n\nI think he means that it only returns positive numbers, and not negative numbers.\n\nThe code doesn't return anything. It just takes a list of numbers and returns a list of positive numbers.\n\nI think he meant to say that it doesn't work with negative numbers.\n\nThat", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    # Get all the positive numbers in the list.\n    for x in l:\n        if x > 0:\n           return x\n\nI've been using this for years:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x > 0)\n\nYou may want to note that the function will not work for all lists, since it will return None for any list that contains a negative number.\n\nI'm not sure what you mean by \"it will return None for any list that contains a negative number\"\n\nIt will return None for any list that contains a negative number.\n\nYou may want to note that the function will not work for all lists, since it will return None for any list that contains a negative number.\n\nI'm not sure what you mean by \"it will return None for any list that contains a negative number\"\n\nIt will return None for any list that contains a negative number.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l, key=lambda x: x[0] > 0)\nI'm pretty sure this is not what the author had in mind.\n\nIt's not a bad suggestion, though. It's not as efficient as the author's solution, but it's a lot simpler.\n\nIt's not a bad solution, but it's not what the author had in mind.\n\nThis is a fun problem. I came up with a solution that uses a simple dynamic programming algorithm. It's not as fast as the author's solution, but it's pretty quick.\nimport itertools", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l[0] == -1:\n       return l", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l[0] < 0:\n       return []\n    for i in range(len(l)):\n       if l[i] > 0:\n          return l[i]\n    return []\nFor the first one, I'd recommend something like:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) > 0:\n        return l[0]\n    else:\n        return []\nThat's not the way Python works.  The way Python works is that you have a list of integers, and you want to find all the non-negative integers.  So you use `filter`.  If you want to find all the positive integers, you can use `filter(lambda x: x > 0, l)`.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[0] > 0)\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return sorted(l.items(), key=lambda x: x[0] < 0)\n\nThis is a very naive implementation. I'm sure there are better ways to do this, but I'm not sure how to implement them.\n\nI think this is a good idea for a post, but I'm not sure it's a good idea to use this particular example. I think it's much more interesting to see how to solve the problem in a way that makes sense, not just in a way that works.\n\nI would like to", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i in l:\n        if i not in [0,1,2,3,4,5,6,7,8,9,10,11]:\n           return False\n    return True\nThis is a nice example of how to use a list comprehension to do something that could be done with a single line of code.\n\nThe author is correct in saying that the list comprehension is not idiomatic. It's not idiomatic because Python's list comprehensions are not idiomatic, they're a clever hack.\n\nThe author is correct in saying that the list comprehension is not idiomatic. It's not idiomatic because Python's list comprehensions are not idiomatic, they're a clever hack.\n\nThe author is correct in saying that the list comprehension is not idiomatic. It's not idiomatic because Python's list comprehensions are not idiomatic, they're a clever hack.\n\nThe author is correct in saying that the list comprehension is not idiomatic. It's not idiomatic because Python's list comprehensions are not idiomatic, they're a clever hack.\n\nThe author is correct in saying", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[::-1]\n\nI'm not sure I get it. I know that the code works, but I don't understand why it does.\n\nThis returns all of the positive numbers in a list (starting at index 0).\n>>> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n>>> [::-1]\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n\nI'm not sure I see why this is better than just using the built-in method:\n>>> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n>>> len(set(range(0, len(list))))\n15\n>>> [::-1]\n[1, 2, 3, 4, 5, 6, 7, 8, 9, 10,", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return list(filter(lambda x: x >= 0, l))\nAh, thanks! I knew it was something simple.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) < 2:\n       return l\n    return [l[0] for l in l if l[0] > 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[i] for i in range(len(l)) if i > 0]\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([-1, 2, -4, 5, 6])\n    [5, 6]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [3, 9, 1, -10]\n    \"\"\"\n    return [l[i] for i in range(len(l)) if i < 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.index(0) < 0\n\n>>> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n>>> get_positive([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n[2, 5, 6]\n\n>>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\n[5, 3, 2, 3, 9, 123, 1]\n\n>>> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\n>>> get_positive([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n\n[2, 5, 6]\n\n>>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n\n[5, 3, 2, 3, 9, 123, 1]\n\n>>> [0, 1, 2, 3, 4, 5, 6", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return []\n    else:\n        return [i for i in l if i % 2 == 1]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[0] < l[1]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sum(map(lambda x: x ** 2, l))", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return len(l) > 0\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return len(l) < 0\n\nThis is a nice, simple solution. I would just add that you should use list comprehension for the first example.\n\nI think this is a very nice answer. I would like to add that the first example should be done with list comprehension.\n\nI would like to add that the first example should be done with list comprehension.\n\nI would like to add that the first example should be done with list comprehension.\n\nI would like to add that the first example should be done with list comprehension.\n\nI would like to add that the first example should", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n       return []\n    else:\n       return get_positive(l.pop(0))\nThis is a good start, but it needs some optimization.  Let's look at the following input:\n>>> get_positive([-1, 2, -4, 5, 6])\n[2, 5, 6]\n>>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n[5, 3, 2, 3, 9, 123, 1]\n>>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n[5, 3, 2, 3, 9, 123, 1]\n>>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n[5, 3, 2, 3, 9, 123, 1]\n>>> get_positive([5, 3, -5, 2, -3, 3, 9,", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return list(filter(lambda x: x >= 0, l))\n\nI don't think that's correct.\n\nYou're right, it's not.\n\nAh, I see. I thought that the OP was using the Python list interface, not the Python builtin function interface.\n\nI am using the Python list interface.\n\nI don't get the point of this. The only thing it seems to do is make it more difficult to understand the code.\n\nYes, that's the point of it.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [x for x in l if x > 0]\n\nI think this is the most interesting answer. It's a simple, elegant solution that is more or less self-documenting.\n\nIt's also not very fast.\n\nThat's a good point, but it's not the most important thing in this case.\n\nI disagree.\n\nI don't think there's a wrong answer here. I would probably go with the first solution, but the second is just as good.\n\nI would argue the second is better. It's more concise, and more readable.\n\nI agree, but the first is also good.\n\nI would go with the first one.\n\nThe second one is better\n\nI like the second one too.\n\nI like the first one.\n\nI would go with the second one.\n\nThe second one is more readable.\n\nI like the second one.\n\nI like the first one.\n\nI would go with the second one.\n\nI like the second one.\n\nI like the second one.\n\nI would go with the second one.\n\nI like the first one.\n\nI would", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x%2)\nThis is a bit better than the other one posted, but still not great.\nIn particular, it's still linear time in the length of the list.  If you have a list of length N, this function will take O(N) time.  You should be able to do better.\nI'm not really sure how to do better.  It's already sorted, so you can't use a binary search.  You can't use a radix sort either, because the range of the numbers is unknown.  A quicksort is too slow.  I'm not sure what other option you have.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n        return l[0]\n    else:\n        return get_positive(l[0])\n\nI'm not sure I understand your question. The output is exactly what I would expect.\n\nI was expecting the output to be [2, 5, 6] since it's the first element of the list.\n\nAh, I see. You want the first element of the list to be returned.\n\nThis is a bit confusing. I would have expected the first element of the list.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0] >= 0]\n\nThis is not a particularly good implementation of get_positive.\nThere's a lot of extra overhead, because you're iterating over the list twice.\n\nIt's a good implementation of get_positive if you're not sure whether the list contains any negative numbers.\n\nI think that's what he meant by \"extra overhead\".\n\nIt's not extra overhead, because it's not extra. It's exactly what you'd want.\n\nIt's extra overhead because you have to iterate over the list twice.\n\n_It's extra overhead because you have to iterate over the list twice._\nIf you're iterating over the list twice, then you're doing it wrong.\n\nI can't believe this is on the front page.\n\nI can't believe you're on the front page.\n\nI can't believe we're all on the front page.\n\nI can't believe this is on the front page.\n\nI can't believe you're on the front page.\n\nI can't believe we're all on the front page.\n\nI can't believe this is", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i in range(len(l)):\n        if l[i] < 0:\n            return None\n    return l[i]\nIt doesn't have to be a list, though. It could be any iterable.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[::-1]\nThis is a very common pattern in functional programming, and is pretty much the same as the usual \"filter\" method in Python.\n\nI would say that this is a very common pattern in mathematics.\n\nI've written a few of these in various languages over the years.\nI'm curious what the rationale is for making it a list comprehension instead of a function, though.\n\nThe rationale is that list comprehension is a more concise way of writing it.\n\nI don't think so. The syntax for list comprehensions is more complex and verbose than a simple function call.\n\nI don't think so. The syntax for list comprehensions is more complex and verbose than a simple function call.\nThe syntax for list comprehension is:\n[<expr> for <expr in <list> if <expr>]\nThat's the same as:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[1] for l in l if l[1] > 0]\nThis is a terrible example.\nIt's a terrible example because the author doesn't understand the difference between \"list\" and \"list[1:]\".\nThe example is also terrible because it's a terrible example.\n\nI didn't get it at first either, but I think he's trying to show that the code is not tail-recursive.\n\nYes, that's what I was trying to do. The idea of the post was to show that the function was not tail recursive, but I got carried away and started showing off how I could use the list comprehension to make the function look nicer.\n\n\"I got carried away and started showing off how I could use the list comprehension to make the function look nicer.\"\nThat's what I suspected, but the title and the first sentence made it seem like you were trying to show something else.\n\nThe code doesn't seem to be tail-recursive.\n\nIt is, see the source code.\n\nHow is this better than a list comprehension?\n\nIt's not.\n\nI'm not a big fan of the syntax.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return []\n    return l[::-1]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda x: x[1] > 0)\nI just recently learned about the sorted() function, which is a lot more useful than I thought it would be.\n\nPython's `sorted` is a lot more useful than most people realize. It's basically a sorted list in the form of a tuple, so you can do a lot of nifty things with it.\n\nI've been programming for a few years, but I've never heard of a sorted list in the form of a tuple. Could you explain what you mean?\n\nYou can call the built-in `list` function, which returns a list in the form of a tuple:\n>>> list(1, 2, 3, 4)\n(1, 2, 3, 4)\n>>> list(1, 2, 3, 4, 5)\n(1, 2, 3, 4, 5)\n>>> list(1, 2, 3, 4, 5, 6)\n(1, 2, 3, 4, 5, 6)\n>>> list(1, 2, 3, 4, 5, 6, 7)\n(1, 2, 3, 4, 5", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0] > 0]\n\nThat's not the same as a function that returns only the first positive element of a list.\n\nI think the point of the exercise was to write a function that would return the first positive element of a list, and then to translate that into a list comprehension.\n\nThat is correct.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    def get_positive_or_none(l: list):\n    \"\"\"Return either a positive number or None.\n    >>> get_positive_or_none([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    >>> get_positive_or_none([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    None\n    >>> get_positive_or_none([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return (l[0] > 0) and (l[1] < 0)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l.count() > 0)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0] > 0]\nThis is my own code. It is more efficient than the original solution.\n\nThe code is a little bit more complicated than the original solution, but\nit is more efficient. I think it is the best solution for this problem.\n\nimport math", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0] > 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop(0) == 1\n\nI'd be more impressed if the code actually worked.\n\nSorry for the typo. Fixed now.\n\nI don't know python, but I think the problem is that the first element of the list is an empty string, which is not a positive number.\n\nGood catch. I've fixed it now.\n\nThis is just one of many ways to implement this. The most concise way is probably to use a list comprehension:\n>>> from itertools import chain\n>>> positive_numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[:-1]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l[0] > -1) and (l[1] > -1) and (l[2] > -1) and (l[3] > -1)\n\nI like this, but it is a bit of a hack.\n\nI was thinking the same thing, but I'm not sure how to do it without a hack.\n\nJust have a function that takes a list and returns a list of the positive numbers in that list.\n\nBut it doesn't do anything if the list is empty.\n\nI like it, but I would make it a generator.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop(0)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i in range(1, len(l)):\n       if i < 0:\n          return l[i - 1]\n    return l", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop()\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [2, 3, -3, -5, 9, 0, 123, 1, -10]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 9, 123, 1, -10]\n    \"\"\"\n    return l.pop()\n\nYou can add an assert to check the return value.\n\nThe article doesn't mention it, but I think it's worth noting that the list is usually the result of a function call, and that the list is the result of the function call's return value.\n\nIn Python, you can use the built-in function _all()_ to check if a list is empty:\n>>> all(['x'])\n<class 'builtins.list", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.filter(lambdax: x >= 0)\nI think you want `lambda x: x >= 0` instead of `lambdax: x >= 0`.\n\nI don't think that's correct. It's not an identity function, it's a function that returns only the positive elements.\n\nYou're right.\n\nI'd like to see a version that doesn't require the list to be sorted. I've seen a couple of different approaches to this, but I'd be interested in seeing how this one works.\n\nHere's a version of it that doesn't require the list to be sorted:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return list(filter(lambda x: x > 0, l))\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n    [5, 6, 7, 8, 9, 10]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return list(filter(lambda x: x < 0, l))", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.pop(0)\nThis is a perfectly valid approach, but there are faster ways.  For example, if you know that the list is sorted, you can do a binary search on the list to find the first positive element.\n>>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n[5, 3, 2, 3, 9, 123, 1]\n\nI'm not sure if this is a fair comparison. I'm pretty sure that in Python, you can't do a binary search on a list without first sorting it.\n\nYes, you're right.  I was assuming that you already had a sorted list.  If you have a sorted list, you can do a binary search on it.  If you have an unsorted list, you have to resort it first.\n\nA faster way is to use the Python list module's __contains__ method:\n>>> get_positive(['-1', '2', '-4', '5', '6'])\n['2', '5', '6']\n>>> get_positive(['5', '3', '", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [x for x in l if x >= 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return []\n    return [x for x in l if x > 0]\nI don't know what language you are in, but I think you could do this in any language.\n\nI was thinking more along the lines of a function that could be applied to a list of numbers and return a new list of only the positive numbers.\n\nPython:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return list()\n    else:\n        return list(filter(None, lambda x: x > 0, l))", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[i] for i in range(1, len(l)) if i % 2 == 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 1:\n       return l[0]\n    elif len(l) > 1:\n       return l[1:]\n    else:\n       return None\nThis is a terrible solution.  You should use the built-in function isin.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return list(filter(None, l))", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[::-1]\nThat's a good point, I didn't think about the fact that it's a list, and the negative numbers are just appended at the end.\n\nThanks for the comments, I really appreciate the feedback.\n\nThat's the first thing I thought of as well.\n\nGood point, I didn't think about that. I'll add a note to the post.\n\nI think this is what you're looking for:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.filter(lambda x: x > 0)\nThis is an interesting example of how Python's functional programming capabilities are actually quite limited.  You can't use map, filter, or reduce, because they only work with iterables.  You can't use the map/filter/reduce syntax, because you can't use lambda.  You have to use the ugly and verbose list comprehension syntax.\n\nThat's not really a limitation of Python's functional programming capabilities, it's a limitation of the language. You can't write a functional language without the ability to do map, filter, and reduce.\n\nYes, but if you're trying to write a functional language that's useful for real-world programming, you want to pick a language that has functional programming capabilities.\n\nI think you're missing the point. Python is not a functional language. It's a scripting language. It's not designed for \"real-world programming\". It's designed for scripting. You can't do the things you're talking about because it's not a functional language.\n\nWhat do you mean by \"real-world programming\"?\n\nIt's a term that's been used for a long time. The definition varies a", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0] > 0]\nYou can also use `list.filter(x => x > 0)`</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return list(1)\n    elif len(l) == 1:\n        return list(0)\n    else:\n        return [l[0] for l in l]\n\nWhat's wrong with this?\n\nIt's not _wrong_, but it's a bit of a kludge.\nIt's a bit like doing", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l[0] > 0)\n\nThis is a very interesting example. It shows how a bug can be introduced by a seemingly innocent change in the code. The original code was probably written by someone who had learned about list comprehensions in a university course. This is how they are taught, and it is natural to write them that way.\n\nThe bug is that the code is not tail recursive, and therefore has to do extra work to determine whether or not the list is empty. This extra work causes the function to be non-deterministic: it might not terminate, and will never terminate if the list is empty.\n\nThe solution to this problem is to make the function tail recursive.", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if l.count('\\d') > 0:\n       return l\n    else:\n       return None\nThis is a terrible way to do it.\nYou are comparing the list to a string, and then using a regexp to check if the string contains a positive number.  You should be using `l.find(re.compile(r'[^0-9]*$'))`, which will be much faster.\nAlso, `get_positive` is a bad name for the method.  `get_positive_numbers` or `get_positive_integers` would be more descriptive.</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return (l.index(i) > 0)\nI'm not sure how you would do this with a dict. The best I can think of would be to iterate over the list and call l.pop(i) and then return the index of the first positive value.\n\nMy solution:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i, val in enumerate(l):\n       if val > 0:\n          return val\n    return None", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l[::-1]\nI think you're missing the point of the article.\n\nI know, I was just trying to be funny.\n\nI guess I'm not sure what the point of the article is. It's a bit rambling.\n\nI think the point is that the Python language makes it easy to write unreadable code.\n\nI think the point is that the author has an axe to grind about Python and is using this code as an example.\n\nI think the point is that the author is a fan of Python, and is using this code as an example of something that is both readable and concise.\n\nI think the point is that the author is a fan of Python, and is using this code as an example of something that is both readable and concise _while being Pythonic_.\n\nI think the point is that the author is a fan of Python, and is using this code as an example of something that is both readable and concise _while being Pythonic, and in the process showing that Python has a lot of room for improvement_.\n\nI think the point is that the author is a fan of Python, and is using this code as an example of something that", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    if len(l) == 0:\n        return []\n    return [x for x in l if x > 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return sorted(l.items(), key=lambda item: item[0]>=0)\nThis would be better with sorted(l.items(), key=lambda item: item[0]<=0)\nNot quite, the first item in the list is 0, so that would include that.  I like the way the OP's code works.\nI meant in the case of negative numbers.      return sorted(l.items(), key=lambda item: item[0]<=0)</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.filter( lambda x: x > 0, lambda x: x < 10 )\nI like this one. I'd probably use it like this:", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0]!= -1]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0] > 0]\n\nI'm not sure I like the name. It should be something like \"get_nonnegative\" or \"get_positive_values\".</s>", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[0] for l in l if l[0] > 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [x for x in l if x % 2 == 0]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return l.filter(lambda x: x > 0)", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    for i in range(len(l)):\n        return l[i]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return [l[::-1] for l in l]", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return list(set(l))\n    def get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return list(set(l))\n    def get_zero(l: list):\n    \"\"\"Return only zeros in the list.\n    >>> get_zero([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return list(set(l))\n    def get_one(l: list):\n    \"\"\"Return only ones in the", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return list(filter(lambda x: x >= 0, l))", "def get_positive(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> get_positive([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> get_positive([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\" \"\"\"\n    return list(l.pop())\n> I'm not sure if I understand the purpose of the pop() method.\nIt's the method that returns the first element of a list.\n> It seems to me that if you need to know the first element of a\n> list, you could just use the first element of the list.\n>\n> So why does Python have this method?\n>\n> I'm not trying to be critical, I just want to understand.\n>\n> Thanks,\n>\n> -Chris\n>\n>\n> _________________________________________________\n> For list-related administrative tasks:\n> http://list.cs.brown.edu/mailman/listinfo/plt-scheme>\n></s>"]]